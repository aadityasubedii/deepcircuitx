[
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Not available. Module specification: The provided Verilog code snippet includes only a timescale directive and lacks any functional Verilog modules. Hence, the module name is unspecified as no module is defined. The functionality revolves purely around the setup of simulation parameters, specifically setting both the base unit and the precision of simulation time to 1 nanosecond with the `timescale 1ns / 1ns` directive. There are no input or output ports present; hence no data interfacing or signal processing is described. Additionally, there are no internal signals or different blocks or sections within this code snippet, as it solely consists of a directive for simulation time settings. This directive does not contribute to any computational or data manipulation tasks typically associated with Verilog modules but is essential for accurate timing in simulation environments.",
        "output": "`timescale 1ns / 1ns"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: conv_encoder. Module specification: The 'conv_encoder' is a Verilog module designed for digital communications, specifically intended to implement a convolutional encoder that helps enhance data transmission reliability through error detection and correction. This encoder takes a single input bit 'b' and generates two encoded output bits 'c[0]' and 'c[1]'. The input ports include 'b' for the data bit, 'clk' for the clock signal governing the register updates, and 'reset' for initializing the internal register values to zero under specific conditions. The module outputs a two-bit signal 'c', consisting of bits 'c[0]' and 'c[1]', calculated via XOR operations involving the current and past input bits. Internal signals consist of two registers, 'D_0' and 'D_1', used to store the immediate and next immediate past values of 'b', respectively. The Verilog code is structured into distinct always blocks: one block updates 'D_0' (determined by the 'b' value) and 'D_1' (takes the previous value of 'D_0') at each positive clock edge, handling resets as necessary; another block computes the output 'c' based on the values of 'b', 'D_0', and 'D_1' using XOR logic. This structure ensures the module effectively encodes input data, leveraging past inputs for future error correction in noisy environments.",
        "output": "module conv_encoder (output [1:0] c, input b, input clk, input reset);\n\treg [1:0] c;\n\treg D_0, D_1;\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_0 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_0 <= b;\n\t\tend\n\tend\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_1 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_1 <= D_0;\n\t\tend\n\tend\n\talways @ (D_0 or D_1 or b)\n\tbegin\n\t\tc[0]  <= b^D_0^D_1;\n\t\tc[1]  <= b^D_1;\n\tend \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: PIPE_Data.\nModule specification: The 'PIPE_Data' module is designed to implement a PCIe data processing block for different generation standards, adapting to various bit widths based on the generation selected. It accepts inputs such as a clock signal 'pclk' to ensure synchronous operation, an active-low reset signal 'reset_n' for initialization, a 3-bit 'generation' indicator to select the PCIe standard, 32-bit scrambled data 'scramblerDataOut', 4-bit control characters 'scramblerDataK', 2-bit sync headers 'scramblerSyncHeader', and a valid signal 'scramblerDataValid' to show data presence. The outputs consist of 'TxData', a 32-bit adjusted transmission data line, 'TxDataValid' to convey data validity, 'TxDataK' providing up to 4 control bits for the outgoing data, 'TxSyncHeader' showcasing sync headers, and 'TxStartBlock', a signal to denote the commencement of a transmission block.\n\nNo internal signals are explicitly declared, with the module leveraging the inputs directly to calculate and set the outputs. The code comprises an always block sensitive to all input signals and parameters. Within this block, there's a series of conditional checks to reset outputs on a low 'reset_n', and to determine 'TxData', 'TxDataK', 'TxDataValid', 'TxSyncHeader', and 'TxStartBlock' based on 'generation' and input characteristics. The block processes the input data for the respective PCIe generation, slicing and aligning data and control bits as per PCIe standard requirements. It also incorporates a selection mechanism that tailors the outputs for different PCIe generations using parameterized bit widths, enhancing the module's versatility for communication protocols.",
        "output": "module PIPE_Data #(parameter pipe_width_gen1 = 8,\n                   parameter pipe_width_gen2 = 8,\n                   parameter pipe_width_gen3 = 16,\n                   parameter pipe_width_gen4 = 32,\n                   parameter pipe_width_gen5 = 32\n  )(generation, pclk, reset_n, scramblerDataOut, scramblerDataK, scramblerSyncHeader, scramblerDataValid, TxData, TxDataValid, TxDataK, TxSyncHeader, TxStartBlock);\ninput pclk, reset_n;\ninput [2:0] generation;\ninput [31:0] scramblerDataOut;\ninput [3:0] scramblerDataK;\ninput [1:0] scramblerSyncHeader;\ninput scramblerDataValid;\noutput reg [31:0] TxData; \noutput reg TxDataValid, TxStartBlock; \noutput reg [3:0] TxDataK;\noutput reg [1:0] TxSyncHeader;\nalways @(*) begin\n  if (~reset_n) begin\n  \tTxData = 0;\n  \tTxDataK = 0;\n  \tTxDataValid = 0;\n    TxSyncHeader = 0;\n    TxStartBlock = 0;\n  end\n  else if (generation==1) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen1-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen1/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n  end\n  else if (generation==2) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen2-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen2/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n  end \n  else if (generation==3) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen3-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen3/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;\n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;\n  end \n  else if (generation==4) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen4-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen4/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;\n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;      \n  end\n  else if (generation==5) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen5-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen5/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;   \n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;   \n  end  \n  else begin\n  \t\tTxData=0;\n  \t\tTxDataK=0;\n  \t\tTxDataValid=0;\n      TxSyncHeader= 0;\n      TxStartBlock = 0;\n  end\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: I2C_WRITE_BYTE. \n\nModule specification: This module serves as a hardware-level representation of the I2C protocol for writing data byte into a slave device. It is designed to handle I2C communications, particularly writing byte operations to an I2C slave device, coded in Verilog HDL. The module uses several input and output ports. \n\nThe input ports include RESET_N (active-high reset signal), PT_CK (clock signal), GO (control signal that commences the I2C write operation), LIGHT_INT (functionality unclear), POINTER (byte of data that is part of the information to be sent using the I2C protocol), SLAVE_ADDRESS (the address of the target I2C slave device), WDATA8 (8 bits of data to transmit to slave device) and SDAI (the input data line for the I2C protocol). \n\nOutput ports consist of SDAO (output data line for I2C protocol), SCLO (clock line for the I2C protocol), END_OK (flag indicating completion of an I2C transmission), SDAI_W (SDAI input connected directly to this output), ST (status register indicating current state of I2C transmission), CNT (counter tracking bit position during one byte I2C transmission), BYTE (identifies the byte being transmitted) and ACK_OK (acknowledgment from the slave device). \n\nInternal signals comprise A (9-bit signal to store data to be transmitted), DELY (for creating delay before transitioning to certain states), and SDAI_W (a wire connecting input SDAI to output). \n\nThe code operates in a state machine format, extensively using \"case\" statements to respond to various conditions based on the state of the I2C transmission, as embodied by the ST signal. The states handle diverse duties that include sending the slave address, sending data, creating and maintaining protocol-specific conditions, and waiting for acknowledgment from the slave device.",
        "output": "module I2C_WRITE_BYTE  (\n   input  \t\t\t\tRESET_N ,\n\tinput      \t\t  \tPT_CK,\n\tinput      \t\t  \tGO,\n\tinput LIGHT_INT ,\n\tinput      [7:0] \tPOINTER,\n\tinput      [7:0] \tSLAVE_ADDRESS,\t\n\tinput      [7:0]\tWDATA8,\t\t\n\tinput            \tSDAI,\n\toutput reg       \tSDAO,\n\toutput reg       \tSCLO,\n\toutput reg       \tEND_OK,\n\toutput SDAI_W ,\n\toutput reg [7:0] \tST ,\n\toutput reg [7:0] \tCNT,\n\toutput reg [7:0] \tBYTE,\n\toutput reg       \tACK_OK\n);\nreg   [8:0]A ;\nreg   [7:0]DELY ;\nassign SDAI_W =SDAI ;\nalways @( negedge RESET_N or posedge  PT_CK )begin\nif (!RESET_N  ) ST <=0;\nelse \n\t  case (ST)\n\t    0: begin  \n\t\t      SDAO   <=1; \n\t         SCLO   <=1;\n\t         ACK_OK <=0;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\t\n\t         if (GO) ST  <=30 ; \n\t\t    end\t  \n\t    1: begin  \n\t\t      ST <=2 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n\t\t\t\tA <= {SLAVE_ADDRESS ,1'b1 };\n\t\t    end\n\t    2: begin  \n\t\t      ST <=3 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n\t\t    end\n\t    3: begin  \n\t\t      ST <=4 ; \n\t\t\t   { SDAO, A } <= { A ,1'b0 }; \n\t\t    end\n\t    4: begin  \n\t\t      ST <=5 ; \n\t\t\t   SCLO <= 1'b1 ; \n\t\t\t\tCNT <= CNT +1 ;\n\t\t    end\n\t    5: begin  \n\t\t\t   SCLO <= 1'b0 ; \n\t\t\t   if (CNT==9) begin\n\t\t\t\t     if ( BYTE ==2)  ST <= 6 ; \n\t\t\t\t\t  else  begin \n\t\t\t\t\t           CNT <=0 ; \n\t\t\t\t\t           ST <= 2 ;\n\t\t\t\t\t                if ( BYTE ==0 ) begin BYTE <=1  ; A <= {POINTER ,1'b1 }; end \n\t\t\t\t\t\t\t\t  else if ( BYTE ==1 ) begin BYTE <=2  ; A <= {WDATA8[7:0] ,1'b1 }; end \n\t\t\t\t\t\t\t  end\n\t\t\t\t\t  if ( !SDAI_W ) ACK_OK <=1 ; \n\t\t\t\t\t  else ACK_OK <=0 ; \n\t\t\t\t end\n\t\t\t\t else ST <= 2;\n\t\t    end\n\t    6: begin          \n\t\t      ST <=7 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n         end\n\t    7: begin          \n\t\t      ST <=8 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n         end\n\t    8: begin          \n\t\t      ST <=9 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b11; \n         end \n\t\t9:\tbegin\n\t\t      ST     <= 30; \n\t\t\t\tSDAO   <=1; \n\t         SCLO   <=1;\n\t         ACK_OK <=0;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\n\t\t     end\n\t\t  30: begin\n            if (!GO) ST  <=31;\n          end\t\t\t\n\t\t   31: begin  \n\t\t      END_OK<=0;\n\t\t\t\tST    <=1;\t\n\t\t\tend\t\n\t    40: begin  \n\t\t      END_OK<=0;\n\t\t\t\tCNT <=0 ; \n\t\t      ST <=32 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n\t\t\t\tA <= {SLAVE_ADDRESS ,1'b1 };\n\t\t    end\n\t    32: begin  \n\t\t      ST <=33 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n\t\t    end\t\t\t \n\t    33: begin  \n\t\t      ST <=34 ; \n\t\t\t   { SDAO, A } <= { A ,1'b0 }; \n\t\t    end\n\t    34: begin  \n\t\t      ST <=35 ; \n\t\t\t   SCLO <= 1'b1 ; \n\t\t\t\tCNT <= CNT +1 ;\n\t\t    end\n\t    35: begin  \n\t\t\t  if (CNT==9)  begin DELY<=0;  ST <= 36;end \n\t\t\t  else begin ST <= 32; SCLO <= 1'b0 ; end \n\t\t    end\t\n\t    36: begin  \n\t\t         DELY<=DELY+1;\n\t\t\t\t   if ( DELY > 10 )  begin \n\t\t\t\t\t\t\t  ST <= 31 ;  { SDAO,  SCLO } <= 2'b11; \n\t\t\t      end\n\t\t\tend\t\t\n\t  endcase \n end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: egd_top. \n\nModule specification: The 'egd_top' module is responsible for processing a 16-bit bitstream buffer to decode the exp-Golomb encoded data typically used in video compression systems. This module takes as input a bitstream ('BitStream_buffer_input'), a clock signal ('clk'), a negative reset signal ('reset_n'), and a selector ('exp_golomb_sel') which determines the decoding method. It outputs the decoded exp-Golomb values through 'exp_golomb_decoding_output', and it includes 3-bit and 4-bit counters ('half_fill_counter' and 'reset_counter' respectively) to monitor buffer filling and resetting activities. Internally, the module handles the buffered bitstream output ('BitStream_buffer_output'), the position of the first detected head of '1' in the bitstream ('heading_one_pos'), the length of the exp-Golomb code being processed ('exp_golomb_len'), a enable signal for the detector ('heading_one_en'), a temporary decoding output storage ('temp_egd_out'), and a range adjustor for output ('te_range'). The submodule 'BitStream_buffer' manages the bitstream feeding and tracking, 'heading_one_detector' finds the position of the heading '1', and 'exp_golomb_decoding' performs the actual decoding based on the provided settings and outputs from other sub-modules. Finally, the module uses parameter configuration and conditional assignments to adapt its behavior based on the decoding selection. Such structured processing makes this module crucial for handling exp-Golomb decoding in systems like video decoders, ensuring efficient and accurate decompression of bitstream data.",
        "output": "module egd_top (\n  input           clk, reset_n,\n  input   [1:0]   exp_golomb_sel,\n  input   [15:0]  BitStream_buffer_input,\n  output \t[2:0] \thalf_fill_counter,\n  output \t[3:0] \treset_counter,\n  output  [7:0]   exp_golomb_decoding_output\n);\n  wire  [15:0]  BitStream_buffer_output;\n  wire  [3:0]   heading_one_pos, exp_golomb_len;\n  wire          heading_one_en;\n  wire  [7:0]   temp_egd_out;\n  wire  [2:0]   te_range;\n  parameter te                             = 2'b11;\n  BitStream_buffer BitStream_buffer (\n    .clk(~clk),\n    .reset_n(reset_n),\n    .BitStream_buffer_input(BitStream_buffer_input),\n    .exp_golomb_len(exp_golomb_len),\n    .BitStream_buffer_valid_n(heading_one_en),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .half_fill_counter(half_fill_counter),\n    .reset_counter(reset_counter)\n  );\n  heading_one_detector heading_one_detector (\n    .heading_one_en(heading_one_en),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .heading_one_pos(heading_one_pos)\n  );\n  exp_golomb_decoding exp_golomb_decoding (\n    .heading_one_pos(heading_one_pos),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .exp_golomb_sel(exp_golomb_sel),\n    .te_range(te_range),\n    .exp_golomb_decoding_output(temp_egd_out),\n    .exp_golomb_len(exp_golomb_len)\n  );\n  assign te_range = (exp_golomb_sel == te) ? (temp_egd_out[2:0] + 1) : 0;\n  assign exp_golomb_decoding_output = temp_egd_out;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: idct_add1. Module specification: The module 'idct_add1' performs simple arithmetic operations\u2014specifically addition and subtraction on pairs of 32-bit input signals\u2014to compute and output 32-bit result signals. It comprises input ports s0 to s11, where each pair (s0-s3, s1-s2, s4-s5, s6-s7, s8-s9, and s10-s11) is either added or subtracted to produce outputs t0 to t9. For instance, t0 is the addition of s0 and s3, while t3 is their difference, and this pattern is consistent across the other port pairs. The module lacks internal signals, indicating all operations are straightforward computations directly linking inputs to outputs without intermediary stages. The Verilog code consists of simple 'assign' statements for each arithmetic operation, clearly laying out the logic for generating each output from the corresponding input pairs.",
        "output": "`timescale 1ns / 1ps\nmodule idct_add1(\n    input [31:0] s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,\n    output [31:0] t0, t1, t2, t3, t4, t5, t6, t7, t8, t9\n    );\n        assign t0 = s0 + s3;\n        assign t3 = s0 - s3;\n        assign t1 = s1 + s2;\n        assign t2 = s1 - s2;\n        assign t4 = s4 + s5;\n        assign t5 = s4 - s5;\n        assign t7 = s7 + s6;\n        assign t6 = s7 - s6;\n        assign t9 = s8 - s9;\n        assign t8 = s10 + s11;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: BUFGCE_1. Module specification: The BUFGCE_1 module primarily controls a clock buffer utilizing an enable signal, ensuring that output O either passes the input I or is forced to stay high based on the state of the enable input CE. The module accepts two input ports: CE, the Clock Enable input that dictates whether the output O should follow the input I or default to a high state; and I, which can be any digital signal whose transmission to output O is contingent on CE. The output port, O, reflects the behavior as either a direct pass-through of I or a forced high signal based on CE\u2019s state. Internally, the module leverages an inverted signal NCE, created from CE through an INV block, to control the `BUFGMUX_1` multiplexer selection. The multiplexer (BUFGMUX_1), taking inputs I and a constant high (`1'b1`), determines its output based on the selection signal NCE. When CE is high, the inverter outputs a low NCE, selecting I to pass through to O, while a low CE results in a high NCE, selecting the constant high input, thus setting O high. This controlled logic flow allows for dynamic signal management based on the enabling condition provided by the input CE.",
        "output": "`timescale  1 ps / 1 ps\nmodule BUFGCE_1 (O, CE, I);\n    output O;\n    input  CE, I;\n    wire   NCE;\n    BUFGMUX_1 B1 (.I0(I),\n\t.I1(1'b1),\n\t.O(O),\n\t.S(NCE));\n    INV I1 (.I(CE),\n\t.O(NCE));\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: vdcmul_32b. Module specification: The \"vdcmul_32b\" module is designed for multiplying two 32-bit numbers, referred to by the inputs 'x' and 'y', and produces a 64-bit result in the output 'prod'. The module employs a strategy of sectional multiplication where each 32-bit input is divided into two 16-bit segments. This subdivision leads to the generation of four partial products (pp1, pp2, pp3, pp4) calculated by four instances of the submodule \"vdcmul_16b\". Each instance handles the multiplication of different pairings of 16-bit segments from 'x' and 'y'. Internally, the module also utilizes three instances of a 32-bit ripple carry adder (rca32b), and a half adder to manage the summation of these partial products and the associated carries correctly. The internal signals such as 'sum1', 'sum2', 'sum3', and carry flags 'c1', 'c2', 'c3', 's1', 'ca1' help in facilitating this by storing intermediate sums and carries across different stages of the addition process. The final product ('prod') is an aggregation of these calculated sums and partial products, structured logically to form the intended 64-bit output. This module systematically uses a combination of smaller multipliers and adders to manage and efficiently compute the product of larger binary numbers.",
        "output": "`include \"../src/rca32b.v\"\n`include \"../src/half_adder.v\"\nmodule vdcmul_32b(\n                   x,\n                   y,\n                   prod\n                   );\ninput [31:0] x, y;\noutput [63:0] prod;\nwire [31:0] pp1, pp2, pp3, pp4;\nwire c1, c2, c3,s1,ca1;\nwire [31:0] sum1, sum2 ,sum3;\nvdcmul_16b v161(x[15:0], y[15:0], pp1);\nvdcmul_16b v162(x[15:0], y[31:16], pp2);\nvdcmul_16b v163(x[31:16], y[15:0], pp3);\nvdcmul_16b v164(x[31:16], y[31:16], pp4);\nrca32b r321(pp2, pp3, 1'b0, c1, sum1);\nrca32b r322(sum1, {16'b0, pp1[31:16]}, 1'b0, c2, sum2);\nhalf_adder h1(c1,c2,s1,ca1);\nrca32b r323(pp4, {14'b0, ca1,s1, sum2[31:16]}, 1'b0, c3, sum3);\nassign prod = {sum3, sum2[15:0], pp1[15:0]};\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: a25_barrel_shift.\nModule specification: The \"a25_barrel_shift\" module implements a versatile barrel shifter with options for quick and full barrel shifts, designed to process 32-bit words based on specified shifting functions. It accepts various inputs including a clock signal (`clk`), an active high reset signal (`reset`), scan and test mode flags (`scan_enable`, `test_mode`), a 32-bit word to be shifted (`i_in`), a carry input (`i_carry_in`), an 8-bit shift amount (`i_shift_amount`), a boolean for immediate zero optimization (`i_shift_imm_zero`), and a 2-bit function selector (`i_function`). The outputs are a 32-bit shifted word (`o_out`), a carry output (`o_carry_out`), and a stall signal (`o_stall`) indicating if the quick shifter is active but insufficient for the specified shift amount. Internal signals include `quick_out`, `quick_carry_out` for outputs from the quick shifter, and `full_out`, `full_carry_out`, `full_out_r`, and `full_carry_out_r` for handling and stabilizing outputs from the full shifter across clock cycles. The register `use_quick_r` decides between using quick or full shifter outputs based on the stall condition. The module encapsulates two instances of `a25_shifter` parameterized to function as quick and full barrel shifters. The behavioral component managed by clock and reset signals updates internal registers (`full_out_r`, `full_carry_out_r`, and `use_quick_r`) and outputs based on the current operation mode and the outputs from either of the shifters.",
        "output": "module a25_barrel_shift (\ninput\t\t\t\tclk,\ninput\t\t\t\treset,\ninput                   scan_enable,\ninput\t\t\t\ttest_mode,\ninput       [31:0]          i_in,\ninput                       i_carry_in,\ninput       [7:0]           i_shift_amount,     \ninput                       i_shift_imm_zero,   \ninput       [1:0]           i_function,\noutput      [31:0]          o_out,\noutput                      o_carry_out,\noutput                      o_stall\n);\nwire [31:0] quick_out;\nwire        quick_carry_out;\nwire [31:0] full_out;\nwire        full_carry_out;\nreg  [31:0] full_out_r;\nreg         full_carry_out_r;\nreg         use_quick_r;\nassign o_stall      = (|i_shift_amount[7:2]) & use_quick_r;\nassign o_out        = use_quick_r ? quick_out : full_out_r;\nassign o_carry_out  = use_quick_r ? quick_carry_out : full_carry_out_r;\nalways @(posedge reset, posedge clk) begin\n\tif (reset) begin\n\t\tfull_out_r\t\t<= 'd0;\n\t\tfull_carry_out_r\t<= 'd0;\n\t\tuse_quick_r\t\t<= 1'b1;\n\tend else begin\n\t\tfull_out_r       <= full_out;\n\t\tfull_carry_out_r <= full_carry_out;\n\t\tuse_quick_r      <= !o_stall;\n\tend\nend\na25_shifter #( \n    .FULL_BARREL (1)\n    )\nu_a25_shifter_full (\n    .i_in               ( i_in             ),\n    .i_carry_in         ( i_carry_in       ),\n    .i_shift_amount     ( i_shift_amount   ),   \n    .i_shift_imm_zero   ( i_shift_imm_zero ), \n    .i_function         ( i_function       ),\n    .o_out              ( full_out         ),\n    .o_carry_out        ( full_carry_out   )\n);\na25_shifter #( \n    .FULL_BARREL        ( 0                ) \n    )\nu_a25_shifter_quick (\n    .i_in               ( i_in             ),\n    .i_carry_in         ( i_carry_in       ),\n    .i_shift_amount     ( i_shift_amount   ),   \n    .i_shift_imm_zero   ( i_shift_imm_zero ), \n    .i_function         ( i_function       ),\n    .o_out              ( quick_out        ),\n    .o_carry_out        ( quick_carry_out  )\n);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: cabac_ram_sp_64x16. Module specification: The `cabac_ram_sp_64x16` module functions as a configurable single-port RAM with specific configurations for word and address width to accommodate different simulation or hardware environments. It features input ports: `clk` (clock signal for synchronization of RAM operations), `cen_i` (chip enable input, active low to enable RAM operations), `wen_i` (write enable input, active low to allow data writing), `addr_i` (6-bit address input specifying the target memory address), and `data_i` (16-bit data input for writing data). The sole output port is `data_o`, a 16-bit output delivering data from the specified memory address. There are no internal signals declared within the Verilog module; all ports directly interface with sub-modules. The module includes conditional blocks for `RTL_MODEL` and `XM_MODEL`, each initializing different RAM models (`ram_1p` for the RTL_MODEL and `rfsphd_64x16` for the XM_MODEL) with parameters tailored to the model's requirements. This setup allows the flexibility of using the module efficiently in various simulation or real-hardware setups, focusing on single-port RAM functionality with adaptability to model-specific configurations and environments.",
        "output": "`include \"enc_defines.v\" \nmodule cabac_ram_sp_64x16 (\n    clk      ,\n    cen_i    ,\n    wen_i    , \n    addr_i   , \n    data_i   ,\n    data_o\n    );\n    input                   clk       ;\n    input                   cen_i     ;\n    input                   wen_i     ;\n    input   [6      -1 :0]  addr_i    ;\n    input   [16     -1 :0]  data_i    ;\n    output  [16     -1 :0]  data_o    ;\n`ifdef RTL_MODEL\n  ram_1p #(\n      .Word_Width(  16   ),\n      .Addr_Width(  6    )\n      ) u_ram_1p(\n        .clk    ( clk        ),\n        .cen_i  ( cen_i      ),\n        .oen_i  ( 1'b0       ),\n        .wen_i  ( wen_i      ),\n        .addr_i ( addr_i     ),\n        .data_i ( data_i     ),      \n        .data_o ( data_o     )           \n  );\n`endif\n`ifdef XM_MODEL \n    rfsphd_64x16 u_rfsphd_64x16(\n        .Q          (data_o     ), \n        .CLK        (clk        ), \n        .CEN        (cen_i      ), \n        .WEN        (wen_i      ), \n        .A          (addr_i     ), \n        .D          (data_i     ), \n        .EMA        ( 3'b1 ), \n        .EMAW       ( 2'b0 ),\n        .RET1N      ( 1'b1 )\n        );   \n`endif \nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: piso. Module specification: The 'piso' module is a parallel-in serial-out (PISO) shift register designed for Verilog that converts 1024-bit parallel inputs into a serial output stream, synchronized by a clock input. The module operates with three primary inputs: `clk` to synchronize module operations, `reset` to initialize internal pointers, and `parallel_in` for the 1024-bit data that needs to be serialized. The outputs include `serial_out`, which provides the serialized data; `empty`, a status indicator that is true when no data is left to be output; and `full`, signaling that the memory buffer can accept no more data. Internally, the module utilizes two 10-bit pointers (`rd_ptr` and `wr_ptr`) and a 1024-bit memory (`mem`). `rd_ptr` points to the memory location of the next data bit to output, while `wr_ptr` indicates where the next input data will be stored. The code's always block defines the logic for data handling on positive clock edges, including resetting pointers, writing new data to memory, and updating the `serial_out`. The combinatorial logic outside the always block handles the calculation of the `empty` and `full` signals based on the pointers' states. This structured approach ensures the module efficiently manages data serialization with effective buffer and flow control.",
        "output": "module piso(\n  input wire clk,\n  input wire reset,\n  input wire [1023:0] parallel_in,\n  output reg serial_out,\n  output wire empty,\n  output wire full\n);\n  reg [9:0] rd_ptr;\n  reg [9:0] wr_ptr;\n  reg [1023:0] mem;\n  always@(posedge clk)\n  begin\n    if (reset)\n    begin\n      rd_ptr <= 10'b0;\n      wr_ptr <= 10'b0;\n    end\n    else\n    begin\n      if (!full)\n      begin\n        mem[wr_ptr] <= parallel_in;\n        wr_ptr <= wr_ptr + 1;\n      end\n      if (!empty) \n      begin\n        serial_out <= mem[rd_ptr];\n        rd_ptr <= rd_ptr + 1;\n      end\n    end\n  end\n  assign empty = (rd_ptr == wr_ptr);\n  assign full = ((wr_ptr - rd_ptr) == 1024);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: divider_testbench. Module specification: The 'divider_testbench' is a Verilog test bench designed specifically to verify the functionality of an N-divider circuit, branded within the code as `N_divider`, which is responsible for clock division based on a dynamic division factor. This test bench does not incorporate traditional input or output ports; instead, it uses internal signals to simulate and observe the behavior of the 'N_divider'. The crucial internal signals include `clk`, a `reg` type signal that generates a toggling clock signal; `rst`, another `reg` signal used for resetting the state of 'N_divider'; `en`, a `reg` signal enabling or disabling the divider; `N`, a `reg` representing the division factor, defined in size by `reg_size.v`; and `div_clk`, a `wire` type signal representing the output of 'N_divider'. The test bench features several initial blocks: one setting up the reset sequence, another generating the clock, one simulating different operational scenarios by altering `N`, `en`, and `rst`, and a final block dedicated to initializing the simulation environment for waveform output (`graph.vcd`). This structured approach allows comprehensive testing of the 'N_divider' under different conditions to ensure its robustness and correctness in real-world applications.",
        "output": "`timescale 1ns/1ns\n`include \"reg_size.v\"\nmodule divider_testbench;\nreg clk,rst,en;\nwire div_clk;\nreg[`SIZE-1:0] N;\nN_divider DIV(.ref_clk(clk), .enable(en), .N(N), .reset(rst), .div_clk(div_clk));\ninitial \nbegin\n  rst=0;\n  #2 rst=1;\n  #2 rst=0;\nend\ninitial\nbegin\n  clk=0;\n  forever #5 clk=~clk;\nend  \ninitial\nbegin\n      N=1;\n  #1  en=1;\n  #50 N=2; rst=1; en=0;\n  #2  rst=0; en=1;\n  #100 N=3; rst=1; en=0;\n  #2  rst=0; en=1;\n  #150 $finish;\nend\ninitial\nbegin\n  $dumpfile(\"graph.vcd\");\n  $dumpvars(0,divider_testbench);\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: altera_avalon_st_pipeline_base.  \nModule specification: The altera_avalon_st_pipeline_base module is designed to act as a pipeline stage within a data streaming system, interfacing with both upstream and downstream elements to control data flow based on external signals. The module uses two primary input ports, `clk` (clock signal that triggers updates on every positive edge) and `reset` (initializes internal states on a positive edge). Additionally, it interacts with `in_valid` and `in_data` (indicating incoming data validity and data content, respectively), and `out_ready` (indicating if the next module is ready to receive data). The output ports include `in_ready` (indicating if the module can accept more data), `out_valid` (indicating if the output data is valid), and `out_data` (the data being sent downstream). Internally, the module leverages several signals: `full0` and `full1` (indicators for buffer statuses), `data0` and `data1` (buffers for incoming and outgoing data). The code includes two primary blocks governed by the `PIPELINE_READY` parameter: registered and unregistered pipeline modes. In registered mode (`PIPELINE_READY = 1`), data flow is controlled through double buffering (`data0` and `data1`) where the availability of each buffer is managed by `full0` and `full1`. This mode handles the back-pressure and ensures controlled data transfer even when downstream stages are slow to accept new data. In unregistered mode, the module operates with simpler logic primarily around single-stage buffering (`data1`), where readiness directly influences the acceptance of new data, aimed at minimal latency. Each operational block within the code explicitly handles data loading, buffering, and validating processes during both clock cycles and reset conditions, thereby ensuring robust data handling and synchronization in line with external control signals.",
        "output": "`timescale 1ns / 1ns\nmodule altera_avalon_st_pipeline_base (\n                                       clk,\n                                       reset,\n                                       in_ready,\n                                       in_valid,\n                                       in_data,\n                                       out_ready,\n                                       out_valid,\n                                       out_data\n                                       );\n   parameter  SYMBOLS_PER_BEAT  = 1;\n   parameter  BITS_PER_SYMBOL   = 8;\n   parameter  PIPELINE_READY    = 1;\n   localparam DATA_WIDTH = SYMBOLS_PER_BEAT * BITS_PER_SYMBOL;\n   input clk;\n   input reset;\n   output in_ready;\n   input  in_valid;\n   input [DATA_WIDTH-1:0] in_data;\n   input                  out_ready;\n   output                 out_valid;\n   output [DATA_WIDTH-1:0] out_data;\n   reg                     full0;\n   reg                     full1;\n   reg [DATA_WIDTH-1:0]    data0;\n   reg [DATA_WIDTH-1:0]    data1;\n   assign out_valid = full1;\n   assign out_data  = data1;    \n   generate if (PIPELINE_READY == 1) \n     begin : REGISTERED_READY_PLINE\n        assign in_ready  = !full0;\n        always @(posedge clk, posedge reset) begin\n           if (reset) begin\n              data0 <= {DATA_WIDTH{1'b0}};\n              data1 <= {DATA_WIDTH{1'b0}};\n           end else begin\n              if (~full0)\n                data0 <= in_data;\n              if (~full1 || (out_ready && out_valid)) begin\n                 if (full0)\n                   data1 <= data0;\n                 else\n                   data1 <= in_data;\n              end\n           end\n        end\n        always @(posedge clk or posedge reset) begin\n           if (reset) begin\n              full0    <= 1'b0;\n              full1    <= 1'b0;\n           end else begin\n              if (~full0 & ~full1) begin\n                 if (in_valid) begin\n                    full1 <= 1'b1;\n                 end\n              end \n              if (full1 & ~full0) begin\n                 if (in_valid & ~out_ready) begin\n                    full0 <= 1'b1;\n                 end\n                 if (~in_valid & out_ready) begin\n                    full1 <= 1'b0;\n                 end\n              end \n              if (full1 & full0) begin\n                 if (out_ready) begin\n                    full0 <= 1'b0;\n                 end\n              end \n           end\n        end\n     end \n   else \n     begin : UNREGISTERED_READY_PLINE\n\tassign in_ready = (~full1) | out_ready;\n\talways @(posedge clk or posedge reset) begin\n\t   if (reset) begin\n\t      data1 <= 'b0;\n\t      full1 <= 1'b0;\n\t   end\n\t   else begin\n\t      if (in_ready) begin\n\t\t data1 <= in_data;\n\t\t full1 <= in_valid;\n\t      end\n\t   end\n\tend\t\t\n     end\n   endgenerate\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: piso. Module specification: The `piso` module, short for Parallel-In-Serial-Out shift register, is designed to convert a 4-bit parallel input into a serialized output. The inputs to this module include the 4-bit data input `data_in`, the control signal `control`, the clock signal `clk`, and the clear reset `clear`. The single output is `data_out`, which holds the serialized data output. It employs internal signals: `control_bar` to get the negated value of `control`, `dfr1_out` as the output from the initial D flip-flop with reset (DFR) stage, and `piso_slice_out` array for intermediate outputs between the piso_slices. The module constructs the serial output using sequential piso_slice modules that each act as a stage in the shift register process. These piso_slices use control signals to select data paths, ultimately passing the result to the flip-flop module `dfr` to lock in the processed values per clock cycle and reset condition. The invert module negates the control signal, the DFR module `dfr1` initializes the serialization process, and subsequent piso_slice modules process the serialization under controlled conditions, transitioning the parallel input through stages to achieve the serialized output.",
        "output": "module invert (input wire i, output wire o);\n   assign o = !i;\nendmodule\nmodule and2 (input wire i0, i1, output wire o);\n  assign o = i0 & i1;\nendmodule\nmodule or2 (input wire i0, i1, output wire o);\n  assign o = i0 | i1;\nendmodule\nmodule df (input wire clk, in, output wire out);\n  reg df_out;\n  always@(posedge clk) df_out <= in;\n  assign out = df_out;\nendmodule\nmodule dfr (input wire clk, reset, in, output wire out);\n  wire reset_, df_in;\n  invert invert_0 (reset, reset_);\n  and2 and2_0 (in, reset_, df_in);\n  df df_0 (clk, df_in, out);\nendmodule\nmodule piso_slice (input wire prev, new, control, control_bar, clk, clear, output wire data);\n    wire and_output[0:1];\n    wire or_output;\n    and2 and_1(prev, control, and_output[0]);\n    and2 and_2(new, control_bar, and_output[1]);\n    or2 or_1(and_output[0], and_output[1], or_output);\n    dfr dfr_1(clk, clear, or_output, data);\nendmodule\nmodule piso (input wire control, clk, clear, input wire [0:3] data_in, output wire data_out);\n    wire control_bar, dfr1_out;\n    wire piso_slice_out[0:1];\n    invert invert_1(control, control_bar);\n    dfr dfr1(clk, clear, data_in[0], dfr1_out);\n    piso_slice piso_slice1(dfr1_out, data_in[1], control, control_bar, clk, clear, piso_slice_out[0]);\n    piso_slice piso_slice2(piso_slice_out[0], data_in[2], control, control_bar, clk, clear, piso_slice_out[1]);\n    piso_slice piso_slice3(piso_slice_out[1], data_in[3], control, control_bar, clk, clear, data_out);\nendmodule;"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: top_small. Module specification: The top_small module serves as a configuration and interface layer for the picorv32 microprocessor core, facilitating interaction with external memories and managing signal routing based on operations defined by the core. It includes input ports such as 'clk' (clock signal for synchronization), 'resetn' (active-low reset signal), and 'mem_ready' (indicating readiness of external memory for operations). Output ports include 'mem_valid' (validating memory operations), 'mem_instr' (differentiating instruction fetch), 'mem_addr' (32-bit memory address output), 'mem_wdata' (32-bit output data to memory), and 'mem_wstrb' (4-bit memory write strobe signals). Internally, the module routes these signals directly to and from corresponding ports of the instantiated picorv32 core. There are no unique internal signals that function exclusively within this module; all functionality is dependent on and directed through the picorv32 block. The picorv32 is instantiated with specific parameters turned off such as ENABLE_COUNTERS and ENABLE_IRQ, indicating a basic setup without these features. This setup highlights the primary function of the module is to simply handle interfacing and basic configuration without additional internal processing or peripheral management.",
        "output": "module top_small (\n\tinput clk, resetn,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata\n);\n\tpicorv32 #(\n\t\t.ENABLE_COUNTERS(0),\n\t\t.LATCHED_MEM_RDATA(1),\n\t\t.TWO_STAGE_SHIFT(0),\n\t\t.CATCH_MISALIGN(0),\n\t\t.CATCH_ILLINSN(0)\n\t) picorv32 (\n\t\t.clk      (clk      ),\n\t\t.resetn   (resetn   ),\n\t\t.mem_valid(mem_valid),\n\t\t.mem_instr(mem_instr),\n\t\t.mem_ready(mem_ready),\n\t\t.mem_addr (mem_addr ),\n\t\t.mem_wdata(mem_wdata),\n\t\t.mem_wstrb(mem_wstrb),\n\t\t.mem_rdata(mem_rdata)\n\t);\nendmodule\nmodule top_regular (\n\tinput clk, resetn,\n\toutput trap,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata,\n\toutput        mem_la_read,\n\toutput        mem_la_write,\n\toutput [31:0] mem_la_addr,\n\toutput [31:0] mem_la_wdata,\n\toutput [ 3:0] mem_la_wstrb\n);\n\tpicorv32 picorv32 (\n\t\t.clk         (clk         ),\n\t\t.resetn      (resetn      ),\n\t\t.trap        (trap        ),\n\t\t.mem_valid   (mem_valid   ),\n\t\t.mem_instr   (mem_instr   ),\n\t\t.mem_ready   (mem_ready   ),\n\t\t.mem_addr    (mem_addr    ),\n\t\t.mem_wdata   (mem_wdata   ),\n\t\t.mem_wstrb   (mem_wstrb   ),\n\t\t.mem_rdata   (mem_rdata   ),\n\t\t.mem_la_read (mem_la_read ),\n\t\t.mem_la_write(mem_la_write),\n\t\t.mem_la_addr (mem_la_addr ),\n\t\t.mem_la_wdata(mem_la_wdata),\n\t\t.mem_la_wstrb(mem_la_wstrb)\n\t);\nendmodule\nmodule top_large (\n\tinput clk, resetn,\n\toutput trap,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata,\n\toutput        mem_la_read,\n\toutput        mem_la_write,\n\toutput [31:0] mem_la_addr,\n\toutput [31:0] mem_la_wdata,\n\toutput [ 3:0] mem_la_wstrb,\n\toutput        pcpi_valid,\n\toutput [31:0] pcpi_insn,\n\toutput [31:0] pcpi_rs1,\n\toutput [31:0] pcpi_rs2,\n\tinput         pcpi_wr,\n\tinput  [31:0] pcpi_rd,\n\tinput         pcpi_wait,\n\tinput         pcpi_ready,\n\tinput  [31:0] irq,\n\toutput [31:0] eoi\n);\n\tpicorv32 #(\n\t\t.COMPRESSED_ISA(1),\n\t\t.BARREL_SHIFTER(1),\n\t\t.ENABLE_PCPI(1),\n\t\t.ENABLE_MUL(1),\n\t\t.ENABLE_IRQ(1)\n\t) picorv32 (\n\t\t.clk            (clk            ),\n\t\t.resetn         (resetn         ),\n\t\t.trap           (trap           ),\n\t\t.mem_valid      (mem_valid      ),\n\t\t.mem_instr      (mem_instr      ),\n\t\t.mem_ready      (mem_ready      ),\n\t\t.mem_addr       (mem_addr       ),\n\t\t.mem_wdata      (mem_wdata      ),\n\t\t.mem_wstrb      (mem_wstrb      ),\n\t\t.mem_rdata      (mem_rdata      ),\n\t\t.mem_la_read    (mem_la_read    ),\n\t\t.mem_la_write   (mem_la_write   ),\n\t\t.mem_la_addr    (mem_la_addr    ),\n\t\t.mem_la_wdata   (mem_la_wdata   ),\n\t\t.mem_la_wstrb   (mem_la_wstrb   ),\n\t\t.pcpi_valid     (pcpi_valid     ),\n\t\t.pcpi_insn      (pcpi_insn      ),\n\t\t.pcpi_rs1       (pcpi_rs1       ),\n\t\t.pcpi_rs2       (pcpi_rs2       ),\n\t\t.pcpi_wr        (pcpi_wr        ),\n\t\t.pcpi_rd        (pcpi_rd        ),\n\t\t.pcpi_wait      (pcpi_wait      ),\n\t\t.pcpi_ready     (pcpi_ready     ),\n\t\t.irq            (irq            ),\n\t\t.eoi            (eoi            )\n\t);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: half_adder. \n\nModule specification: The half_adder is a basic digital logic circuit module designed to perform addition of two single-bit binary numbers. Functioning through an XOR operation and an AND operation, it carefully computes and provides the sum and carry of the inputs, respectively. The module relies on two input ports `a` and `b`, which are single-bit binary inputs that are the operands for the addition operation. Further, it utilizes two output ports `s` and `c`, where `s` is the summation output produced by performing an XOR operation between `a` and `b`, and `c` provides the carry output obtained by implementing an AND operation between `a` and `b`. Internally, the module does not require the use of any signals. Its simplistic and direct design needesses computations within the assignment statements themselves, with all operations conducted on the input ports directly to generate the output assignments. This results in a straightforward design with no dependencies on internal signals. Thus, half_adder is a foundational digital logic design module in Verilog, offering precise and reliable binary addition using the simplest of operations.",
        "output": "`timescale 1ns / 1ps\nmodule half_adder(\n    input a,\n    input b,\n    output s,\n    output c\n    );\nassign s = a ^ b;\nassign c = a & b;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: cntr_updn. Module specification: The 'cntr_updn' module functions as a configurable up/down counter with enhanced control features designed to be operated upon a positive clock edge and conditionally when enabled. It integrates several input ports: \u2018clk\u2019 (clock signal triggering counter operations on its positive edge), \u2018ena\u2019 (enable signal for counter operation), \u2018rst\u2019 (asynchronous reset that sets the counter to zero), \u2018sload\u2019 (loads the counter with the value on \u2018sdata\u2019 when high), \u2018sclear\u2019 (clear signal that also sets the counter to zero), \u2018inc_not_dec\u2019 (determines the counting direction; high for increment, low for decrement), and \u2018sdata\u2019 (data input specifying the value to load when \u2018sload\u2019 is active). The module outputs through the \u2018q\u2019 port, which reflects the current counter value. Internally, \u2018q\u2019 is a register defined by the parameter WIDTH (defaulting to 16 bits), storing the current counter value, and is only updated on the positive edge of 'clk' when \u2018ena\u2019 is active or upon a 'rst' signal. The Verilog code encompasses an always block triggered on the rising edge of 'clk' or 'rst', where the counter is reset by \u2018rst\u2019, cleared by \u2018sclear\u2019, loaded from \u2018sdata\u2019 by \u2018sload\u2019, or updated to count up or down based on \u2018inc_not_dec\u2019. This concise design encapsulates all aspects of the up/down counter functionality, providing clear conditions for each action that affects the counter state.",
        "output": "module cntr_updn (clk,ena,rst,sload,sdata,sclear,inc_not_dec,q);\nparameter WIDTH = 16;\ninput clk,ena,rst,sload,sclear,inc_not_dec;\ninput [WIDTH-1:0] sdata;\noutput [WIDTH-1:0] q;\nreg [WIDTH-1:0] q;\nalways @(posedge clk or posedge rst) begin\n\tif (rst) q <= 0;\n\telse begin\n\t\tif (ena) begin\n\t\t\tif (sclear) q <= 0;\n\t\t\telse if (sload) q <= sdata;\n\t\t\telse q <= q + (inc_not_dec ? 1'b1 : {WIDTH{1'b1}});\n\t\tend\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "I regret to inform that without the actual code or its content from the included files \"FPU_PACK.v\", \"EXCEPTION_MODULE.v\", \"MUX_2_4.v\", \"tb_EXCE.v\", and \"tb_MUX.v\", it is impossible to generate a detailed specification of the module you requested. \n\nThe provided Verilog code does not have any module definition, or any information about functionality, input/output ports, internal signals, or code blocks. It only has a list of file inclusions, which we don't have any details about. \n\nIf you are able to provide actual content of these included files, we can definitely generate a detailed specification of the module, including the module name, its functionality, input/output ports, internal signals, and an overview of the different blocks within the code. \n\nIdeally, the answer would look like this:\n\nModule Name: [module name]\n\nModule Specification: This module serves [module functionality]. It has input ports [input ports], which [brief explanation of each]. Output ports include [output ports], which [brief explanation of each]. The module utilizes internal signals [internal signals] function descried as [brief explanation of their purpose]. This module comprises several code blocks, namely [different blocks or sections], performing functions [functions of each block].\n\nWithout the actual content from the included files, it is not possible to fill this template accurately. Please provide more detailed code or the content of the included files so I can help with your request better.",
        "output": "`include \"FPU_PACK.v\"\n`include \"EXCEPTION_MODULE.v\"\n`include \"MUX_2_4.v\"\n`include \"tb_EXCE.v\"\n`include \"tb_MUX.v\""
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: behavioral_full_adder_test. Module specification: The behavioral_full_adder_test module is designed to verify the functionality of a 64-bit full adder by exhaustively testing all possible input combinations of two 64-bit numbers, A and B. The module includes two input registers, A and B, both 64 bits wide, which serve as the operands for the addition. The output is provided on a 65-bit wire named SUM, which accounts for the potential overflow from the addition of two 64-bit values. The module uses two internal integer signals, count and count2, which act as iterators in nested loops to assign all values from 0 to 32 to A and B, respectively, thereby testing the adder in 1,089 (33*33) scenarios. The initial code block initializes the inputs and employs the nested loops for simulation, while a second initial block terminates the simulation after 4000 time units. A monitor statement continuously outputs the results of the addition (A + B = SUM) to verify each operation\u2019s correctness under varied input conditions. This structured and systematic testing approach helps in precisely determining the performance and correctness of the 64-bit full adder.",
        "output": "`timescale 1ns / 1ps\nmodule behavioral_full_adder_test;\n  reg [63:0] A;\n  reg [63:0] B;\n  wire [64:0] SUM;\n  integer count;\n  integer count2;\n  behavioral_full_adder_64 uut\n  (\n    .A(A),\n    .B(B),\n    .SUM(SUM)\n  );\n  initial begin\n    $monitor(\"%d + %d = %d\", A, B, SUM);\n    count = 0;\n    count2 = 0;\n    A = 0;\n    B = 0;\n    for (count = 0; count <= 32; count = count + 1) begin\n      {A} = count;\n      for (count2 = 0; count2 <= 32; count2 = count2 + 1) begin\n        {B} = count2;\n        #1;\n      end\n    end\n  end\n  initial #4000 $finish; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: IBUF_HSTL_IV. Module specification: The IBUF_HSTL_IV is a Verilog module designed to provide a straightforward buffering function for digital signals. This module includes an input port labeled 'I' where the digital signal to be buffered is received. It plays a crucial role in the module by delivering the signal directly to the output port named 'O' without any alteration, ensuring the integrity and quality of the signal in digital circuit applications. The output 'O' then transmits this buffered signal onward within the circuit system, maintaining its integrity. Notably, the module employs a 'buf' primitive, denoted as B1, which directly connects the input 'I' to the output 'O'. This use of the 'buf' primitive indicates a direct and unaltered forwarding of the signal, and as such, there are no internal signals or additional logic processing involved in this module. The module is defined within a `timescale of 1 ps / 1 ps`, ensuring precise simulation timing, although this module's simplicity involves no timing-specific functionality. This design is encapsulated within the 'IBUF_HSTL_IV' module, with clearly defined input and output ports, and straightforward internal connections provided by the 'buf' primitive for reliable signal buffering.",
        "output": "`timescale  1 ps / 1 ps\nmodule IBUF_HSTL_IV (O, I);\n    output O;\n    input  I;\n\tbuf B1 (O, I);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Since no Verilog code was provided in your previous messages, I am unable to deliver a specification as detailed as requested. The information needed to fulfill your requirements, such as the module name, its functionality, input and output ports description, internal signals, and code blocks explanations, cannot be derived without the actual code.\n\nTo proceed effectively, please provide the Verilog RTL code snippet. Once the code is available, I can analyze it to provide a comprehensive and detailed specification according to your guidelines.",
        "output": ""
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: PC_RISC_ARCH. \nModule specification: The PC_RISC_ARCH module is designed to function as a programmable counter (PC) within a RISC architecture system, playing a crucial role in controlling the sequence of program execution. It features four input ports: `PC_Next`, a 32-bit input that indicates the next program counter address; `clk`, a clock signal that synchronizes the PC updates on its rising edge; `areset`, an asynchronous reset signal that resets the `PC_Current` to zero when low; and `load`, a control signal that dictates whether `PC_Current` should be updated with `PC_Next` or retain its old value. The module has one output port, `PC_Current`, a 32-bit register that holds the current PC value, either maintaining its previous state or being updated based on the `load` condition. Internally, `PC_Current` acts both as an output and an internal signal, managing the state between cycles and resetting to zero upon activation of `areset`. The code comprises an `always` block that triggers on either the positive edge of `clk` or the negative edge of `areset`, ensuring responsive updates to the PC value based on the input conditions. This setup facilitates dynamic control over the PC, ensuring accurate flow and transition of execution in the processor as it follows the program's instructions.",
        "output": "module PC_RISC_ARCH(\ninput [31:0]PC_Next,\ninput clk ,\ninput areset ,\ninput load ,\noutput reg [31:0]PC_Current);\nalways @(posedge clk or negedge areset)\nbegin \nif (~areset)\n      PC_Current <= 0;\nelse\nbegin\n       if(load)\n       PC_Current <= PC_Next;\n\t   else \n\t  PC_Current <= PC_Current;\nend\t   \nend\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: pwm_top. \n\nModule specification: The 'pwm_top' is a top-level module designed to generate and control Pulse Width Modulation (PWM) signals for the operation of an audio processing unit. This module includes several blocks like a switch synchronizer, reset generator, and an audio processing unit (APU) to manage the sound generation process. \n\nThe module has several input ports including a clock signal (i_Clk) and four switch inputs (i_Switch_1 to i_Switch_4). The clock signal is used for synchronization throughout the module and the switches allow user interaction triggering different audio processing features. It provides three output ports (io_PMOD_1, io_PMOD_2, io_PMOD_3) that carry a regular PWM signal, a frame pulse from the APU, and an inverted version of the PWM signal respectively, each targeting different functionalities in the audio output hardware.\n\nThe internal signals of the module include the clock signal (i_clk), synchronized switch signals (w_switches), the APU reset signal (w_rst), and the inverse of the switch signals for controlling the APU (w_mixer). Additionally, it utilizes signals for audio sample comparisons (w_compare), frame pulse generation (w_frame_pulse), PWM signal (w_pwm), and PWM cycle end indicator (w_cycle_end). \n\nThe code of the module can be segmented into different blocks. The 'switch synchronizers' block synchronizes the user-operated switch inputs. The 'reset generator' initiates the APU reset when needed. The 'audio processing unit' performs sound signal processing using predefined resources and provides the 'w_compare' and 'w_frame_pulse' signals. The 'pwm' module takes in compare values, providing PWM signal and cycle end outputs. The final assignments tabulate the outputs of the module making the PWM signal, frame pulse, and the inverted PWM signal available at the io_PMOD_1, io_PMOD_2, and io_PMOD_3 outputs.",
        "output": "`default_nettype none\nmodule pwm_top (\n  input wire  i_Clk,\n  input wire  i_Switch_1,\n  input wire  i_Switch_2,\n  input wire  i_Switch_3,\n  input wire  i_Switch_4,\n  output wire io_PMOD_1,\n  output wire io_PMOD_2,\n  output wire io_PMOD_3\n);\n  wire i_clk = i_Clk;\n  wire [3:0] w_switches;\n  switch_synchronizers switches (\n    .i_clk(i_clk),\n    .i_switches({i_Switch_4, i_Switch_3, i_Switch_2, i_Switch_1}),\n    .o_switches(w_switches)\n  );\n  wire w_rst;\n  reset_generator reset_generator (\n    .i_clk(i_clk),\n    .o_rst(w_rst)\n  );\n  wire [3:0] w_mixer = ~w_switches;\n  wire [8:0] w_compare;\n  wire [3:0] w_frame_pulse;\n  audio_processing_unit #(\n    .CLOCK_FREQ(25_000_000),\n    .NOTE_TABLE_FILE(\"resources/note_table_25MHz.txt\"),\n    .VIBRATO_TABLE_FILE(\"resources/vibrato_table_25MHz.txt\"),\n    .NOISE_TABLE_FILE(\"resources/noise_table_25MHz.txt\")\n  ) apu (\n    .i_clk(i_clk),\n    .i_rst(w_rst),\n    .i_mixer(w_mixer),\n    .o_sample(w_compare),\n    .o_frame_pulse(w_frame_pulse)\n  );\n  wire w_pwm;\n  wire w_cycle_end;\n  pwm pwm(\n    .i_clk(i_Clk),\n    .i_top(8'hff),\n    .i_top_valid(1'b1),\n    .i_compare(w_compare),\n    .i_compare_valid(1'b1),\n    .o_pwm(w_pwm),\n    .o_cycle_end(w_cycle_end)\n  );\n  assign io_PMOD_1 = w_pwm;\n  assign io_PMOD_2 = w_frame_pulse[0];\n  assign io_PMOD_3 = ~w_pwm;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Forwarding_unit. \n\nModule specification: The Forwarding_unit module is a vital segment in the pipelining stages of processor architecture designed to prevent data hazards. It determines whether a register write operation is being conducted at different stages (EX/MEM, MEM/WB and ID/EX) and if the corresponding destination register matches the source registers. Should the condition be met, it sets the appropriate forwarding signals (2'b10, 2'b01 or 2'b11), to ensure there is no unnecessary stalling or flushing of the pipeline by using the results as soon as they are available.  \n\nThe input ports for this module include IF_ID_rs, IF_ID_rt, ID_EX_rs, ID_EX_rt, ID_EX_rd, EX_MEM_rd, MEM_WB_rd, ID_EX_RegWrite, EX_MEM_RegWrite, and MEM_WB_RegWrite. These inputs are responsible for delivering the register values of current instructions in the pipeline, register fields of the instruction in different pipeline stages and indicating if a pipeline stage needs to write to a register in the current cycle.\n\nOutput ports include forwardA, forwardB, forwardRs, and forwardRt. These ports help in forwarding the correct data accordingly when a data hazard is detected by setting control signals that guide the operations of multiplexers in the datapath.\n\nInternal signals consist of four output registers namely forwardA, forwardB, forwardRs, and forwardRt, which function as forwarding control signals. These are managed based on the detection of data hazards, and direct how operands for current ALU operation will be forwarded to prevent these data hazards.\n\nThe Verilog code has different sections for controlling each of the four output signals - forwardA, forwardB, forwardRs, and forwardRt. Each section checks for conflicts or potential hazards at different stages of the pipeline and sets its respective output register accordingly to handle those situations, maximizing pipeline efficiency and preventing stalls.\n",
        "output": "module Forwarding_unit(\n    input wire [1:0] IF_ID_rs,\n    input wire [1:0] IF_ID_rt,\n    input wire [1:0] ID_EX_rs,\n    input wire [1:0] ID_EX_rt,\n    input wire [1:0] ID_EX_rd,\n    input wire [1:0] EX_MEM_rd,\n    input wire [1:0] MEM_WB_rd,\n    input wire ID_EX_RegWrite,\n    input wire EX_MEM_RegWrite,\n    input wire MEM_WB_RegWrite,\n    output reg [1:0] forwardA,\n    output reg [1:0] forwardB,\n    output reg [1:0] forwardRs,\n    output reg [1:0] forwardRt\n);\n    always @(*) begin\n        if(EX_MEM_RegWrite && EX_MEM_rd == ID_EX_rs) forwardA = 2'b10;              \n        else if(MEM_WB_RegWrite && MEM_WB_rd == ID_EX_rs) forwardA = 2'b01;         \n        else forwardA=0;\n        if(EX_MEM_RegWrite && EX_MEM_rd == ID_EX_rt) forwardB=2'b10;                \n        else if(MEM_WB_RegWrite && MEM_WB_rd == ID_EX_rt) forwardB = 2'b01;         \n        else forwardB=0;\n        if(ID_EX_RegWrite && ID_EX_rd == IF_ID_rs) forwardRs = 2'b11;               \n        else if(EX_MEM_RegWrite && EX_MEM_rd == IF_ID_rs) forwardRs=2'b10;          \n        else if(MEM_WB_RegWrite && MEM_WB_rd == IF_ID_rs) forwardRs = 2'b01;        \n        else forwardRs=0;\n        if(ID_EX_RegWrite && ID_EX_rd == IF_ID_rt) forwardRt = 2'b11;               \n        else if(EX_MEM_RegWrite && EX_MEM_rd == IF_ID_rt) forwardRt=2'b10;          \n        else if(MEM_WB_RegWrite && MEM_WB_rd == IF_ID_rt) forwardRt = 2'b01;        \n        else forwardRt=0;\n    end        \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: four_bit_adder.\nModule specification: The 'four_bit_adder' is a Verilog module designed to function as a 4-bit binary adder. It calculates the sum of two 4-bit binary numbers, ADD_1 and ADD_2, incorporating an input carry C. The module outputs a 4-bit sum S, a carry-out bit C_OUT, a generate signal G, and a propagate signal P. The inputs are as follows: ADD_1 and ADD_2, which are the 4-bit numbers to be added; C is the input carry. The outputs include: S, the 4-bit result of the addition; G, a signal indicating the generation of any carry without considering input carry; C_OUT, the carry-out for further addition stages; and P, an indicator of whether the input carry will propagate through all the bits.\n\nInternally, the module uses the following signals: Prop, which are the bit-wise XORs of ADD_1 and ADD_2 to determine if a carry will propagate through to the next bit position; Gen, which are bit-wise ANDs of ADD_1 and ADD_2 to determine if a carry is generated without a carry-in; and Ci, the internal carry signals that connect between adder stages, starting with the external C as Ci[0]. The code can be divided into sections where the Gen and Prop signals are computed, the carry-in bits Ci are determined for each bit level, the sum S is calculated, and the overall carry-out C_OUT, propagate P, and generate G signals are obtained. These operations collectively realize the addition process, with special considerations for carry generation and propagation to ensure the correct summation in a ripple-carry adder configuration.",
        "output": "module four_bit_adder (\n  input [3:0] ADD_1,  \n  input [3:0] ADD_2,  \n  output [3:0] S, \n  output G, \n  input C,            \n  output C_OUT, \n  output P \n);\nwire [3:0]Prop;\nwire [3:0]Gen;\nwire [3:0]Ci;\nassign Gen = ADD_1 & ADD_2;\nassign Prop = ADD_1 ^ ADD_2;\nassign Ci[0] = C;\nassign Ci[1]= Gen[0]|(Prop[0]&Ci[0]);\nassign Ci[2] = Gen[1]|(Prop[1]&Ci[1]);\nassign Ci[3] = Gen[2]|(Prop[2]&Ci[2]);\nassign C_OUT = Gen[3]|(Prop[3]&Ci[3]);\nassign S = Prop^Ci;\nassign P = Prop[3] & Prop[2] & Prop[1] & Prop[0];\nassign G = Gen[3] | (Gen[2] & Prop[3]) | (Gen[1] & Prop[2] & Prop[3]) | (Gen[0] & Prop[1] & Prop[2]);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: dffsr_cell. Module specification: The `dffsr_cell` is a D-type flip-flop with set (s) and reset (r) functionalities. It is designed to store a data value based on the triggering of clock (`clk`), set (`s`), or reset (`r`) signals. The input ports include `clk` for the clock input which triggers updates, `d` for the data to be stored, `s` as a set control signal, and `r` as a reset control signal. The output ports are `q`, which stores the output state of the flip-flop, and `notq`, which provides the negated state of `q`. Internally, the module uses `q` as a register to hold the stored data across clock cycles. The Verilog code contains two main blocks: an assignment block that defines `notq` as the logical negation of `q`, preserving simplicity by using basic logical operations, and an always block sensitive to the positive edge of `clk`, `s`, or `r'. This block controls the logic for setting, resetting, or updating the state of `q` based on these inputs; resetting `q` if `r` is high, setting `q` when `s` is high, and following the data input `d` during clock edges under normal conditions. These functionalities allow `dffsr_cell` to perform dynamic and conditional data storage crucial in digital circuit operations, especially where initialization and asynchronous control are desired.",
        "output": "`define default_netname none\nmodule buffer_cell (\n    input wire in,\n    output wire out\n    );\n    assign out = in;\nendmodule\nmodule and_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a & b;\nendmodule\nmodule or_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a | b;\nendmodule\nmodule xor_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a ^ b;\nendmodule\nmodule nand_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = !(a&b);\nendmodule\nmodule not_cell (\n    input wire in,\n    output wire out\n    );\n    assign out = !in;\nendmodule\nmodule mux_cell (\n    input wire a,\n    input wire b,\n    input wire sel,\n    output wire out\n    );\n    assign out = sel ? b : a;\nendmodule\nmodule dff_cell (\n    input wire clk,\n    input wire d,\n    output reg q,\n    output wire notq\n    );\n    assign notq = !q;\n    always @(posedge clk)\n        q <= d;\nendmodule\nmodule dffsr_cell (\n    input wire clk,\n    input wire d,\n    input wire s,\n    input wire r,\n    output reg q,\n    output wire notq\n    );\n    assign notq = !q;\n    always @(posedge clk or posedge s or posedge r) begin\n        if (r)\n            q <= '0;\n        else if (s)\n            q <= '1;\n        else\n            q <= d;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: rx_mainFSM. Module specification: The rx_mainFSM is a Verilog module designed to handle the state-based reception and processing of data through a dual clock driven finite state machine (FSM). The module operates using two input clocks, clka and clkb, along with inputs reset, rx_data, and rx_rdy, which respectively handle initialization, data reception, and readiness signal. The key outputs of this module include rx_out, which outputs processed data; control signals like rx_busy, rx_done, rx_error, rx_idle which indicate the status of the module; and signals rcount and rstate that help in debugging and internal state management. Internally, the module utilizes rtmpout to temporarily store processed data and next_rstate to hold the next state in the FSM transition pending its synchronization to the actual state (`rstate`). The code is divided into several sections: the declaration and initialization of parameters and registers; a function (fsm_function) defining state transitions based on inputs and current state; and always blocks, triggered on negative edges of clka and clkb, which implement the state transition logic, processing logic, and update outputs based on the current state of the FSM. Each section and signal is finely orchestrated to ensure systematic data reception, processing, and output generation, providing robust operation in a multi-clock system environment.",
        "output": "module rx_mainFSM(clka, clkb, reset, rx_data, rx_rdy, rx_busy, rx_out, rx_done, rcount, rstate, rx_error,rx_idle);\ninput wire clka, clkb, reset;\ninput wire [7:0] rx_data;\ninput wire rx_rdy;\noutput reg [7:0] rx_out;\noutput reg [3:0] rcount;\noutput [3:0] rstate;\noutput reg rx_error, rx_busy, rx_done, rx_idle;\nreg [7:0] rtmpout =8'b00000000;\nparameter SIZE = 4;\nparameter S0  = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3=4'b0011, S4=4'b0100, S5=4'b0101, S6  = 4'b0110, S7 = 4'b0111, S8 = 4'b1000;\nreg   [SIZE-1:0]          rstate        ;\nwire   [SIZE-1:0]         temp_rstate   ;\nreg   [SIZE-1:0]          next_rstate   ;\nassign  temp_rstate = fsm_function(rstate, rx_rdy, rx_busy, rcount);\nfunction [SIZE-1:0] fsm_function;\n\tinput [SIZE-1:0] rstate;\n\tinput rx_rdy, rx_busy;\n\tinput [3:0] rcount;\n\tcase(rstate)\n\t\t\tS0: begin \n\t\t\t\tif(~rx_rdy) begin\n\t\t\t\t\tfsm_function = S1;\n\t\t\t\tend \n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (rx_rdy) begin\n\t\t\t\t\tfsm_function = S2;\n\t\t\t\tend else begin\n\t\t\t\t\tfsm_function = S1;\n\t\t\t\tend\t\t\t\t\n\t\t\t    end\n\t\t\tS2: begin \n\t\t\t\tif (rx_busy) begin\n\t\t\t\t\tfsm_function = S2;\n\t\t\t\tend else begin\n\t\t\t\t\tfsm_function = S3;  \n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tfsm_function = S4;    \n\t\t\tend\n\t\t\tS4: begin\n\t\t\t\tfsm_function = S5;  \n\t\t\tend\n\t\t\tS5: begin\n\t\t\t\tfsm_function = S1; \n\t\t\tend\n\t\t\tdefault: fsm_function = S0;\n    endcase\nendfunction\nalways @ (negedge clka)\nbegin\n  if (reset == 1'b1) begin\n    next_rstate <= S0;\n  end else begin\n    next_rstate <= temp_rstate;\n  end\nend\nalways @ (negedge clkb)\nbegin\n  case(next_rstate)\n          S0: begin\n               \trcount <= 4'b0000;\n               \trtmpout  <= 8'b00000000;\n               \trx_error <= 0;\n               \trx_idle <= 1;\n\t\trx_out <= 0;\n\t\trx_done <= 0;\n\t\trx_busy <= 0;\n\t\tif (~rx_done) begin\n\t\t\trx_out <= 0;\n\t\tend\n               \tif (rx_data[0]) begin\n               \t\trx_error <= 1;\n               \tend\n                rstate <= next_rstate;\n          end\n\t  S1: begin\n\t\trstate <= next_rstate;\n\t      end\n          S2: begin\n          \t\trx_idle <= 0;\n        \t\tif (rcount > 4) begin\n          \t\t\trx_busy <= 0;\n          \t\tend\n          \t\telse begin \n          \t\t\trx_busy <= 1;\n      \t\t\tend\n      \t\t\trtmpout [7] <= 1;\n      \t\t\trtmpout [rcount+1] <= rx_data[rcount+1];\n          \t\trcount <= rcount + 1;\n          \t\trstate <= next_rstate;\n          end\n          S3: begin\n          \t\trtmpout [7] <= 0;\n          \t\trx_done <= 1;\n          \t\trstate <= next_rstate;\n          end\n          S4: begin\n         \t\tif (rtmpout [6:2]==rx_data[6:2]) begin\n          \t\t\trx_error <= 0;\n          \t\tend\n          \t\telse begin\n          \t\t\trx_error <= 1;\n          \t\tend\n          \t    rstate <= next_rstate;\n          end\n          S5: begin\n          \t   rx_out <= {rtmpout[7:2], rx_done, rx_error};        \t   \n          \t   rstate <= next_rstate;\n          end\n  endcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: VGA_Ctrl. \n\nModule specification: The VGA_Ctrl is a hardware module designed to handle VGA display control. This module takes as input the intensity values for red, green, and blue color channels, a system reset signal, and a system clock. The module maintains two internal counter signals, H_Cont and V_Cont, for tracking the current horizontal and vertical positions, respectively. The module uses these counters to determine the VGA timings and control display-related operations. The VGA_Ctrl module generates several output signals including those that represent the VGA display color levels, pixel coordinate, pixel address, pixel request flag, horizontal and vertical sync signals, a sync signal, a blank signal, and an inverted system clock. \n\nThe module operation is divided into three core parts: parameter declaration, signal assignments, and procedural always blocks. Parameters define the timings for the VGA display, including timings for horizontal and vertical signals. Input color intensities are directly assigned to output signals. The pixel request flag, addresses, and coordinates are computed based on parameters and internal counters. The blank, sync, and inverted clock signals are assigned as constant or with logic based on H_Cont or V_Cont. The procedural blocks mainly handle the increment of counters and the activation of sync signals based on these counters. The first always block increments the horizontal counter and controls the horizontal sync signal. The second always block increases the vertical counter and operates the vertical sync signal. \n\nTogether, these sections successfully manage the VGA display control operation, facilitating color intensity display, pixel requesting, and synchronization with the VGA protocol through the generation of timely and accurate signals.",
        "output": "module\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toShift_Flag,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t);\ninput\t\t[9:0]\tiRed;\ninput\t\t[9:0]\tiGreen;\ninput\t\t[9:0]\tiBlue;\noutput\t\t[21:0]\toAddress;\noutput\t\t[10:0]\toCurrent_X;\noutput\t\t[10:0]\toCurrent_Y;\noutput\t\t\t\toRequest;\noutput\t\t\t\toShift_Flag;\noutput\t\t[9:0]\toVGA_R;\noutput\t\t[9:0]\toVGA_G;\noutput\t\t[9:0]\toVGA_B;\noutput\treg\t\t\toVGA_HS;\noutput\treg\t\t\toVGA_VS;\noutput\t\t\t\toVGA_SYNC;\noutput\t\t\t\toVGA_BLANK;\noutput\t\t\t\toVGA_CLOCK;\ninput\t\t\t\tiCLK;\ninput\t\t\t\tiRST_N;\t\nreg\t\t\t[10:0]\tH_Cont;\nreg\t\t\t[10:0]\tV_Cont;\nparameter\tH_FRONT\t=\t16;\nparameter\tH_SYNC\t=\t96;\nparameter\tH_BACK\t=\t48;\nparameter\tH_ACT\t=\t640;\nparameter\tH_BLANK\t=\tH_FRONT+H_SYNC+H_BACK;\nparameter\tH_TOTAL\t=\tH_FRONT+H_SYNC+H_BACK+H_ACT;\nparameter\tH_DLY\t\t=\t2; \nparameter\tV_FRONT\t=\t11;\nparameter\tV_SYNC\t=\t2;\nparameter\tV_BACK\t=\t31;\nparameter\tV_ACT\t=\t480;\nparameter\tV_BLANK\t=\tV_FRONT+V_SYNC+V_BACK;\nparameter\tV_TOTAL\t=\tV_FRONT+V_SYNC+V_BACK+V_ACT;\nparameter\tV_DLY\t\t=\t2; \nassign\toVGA_SYNC\t=\t1'b1;\t\t\t\nassign\toVGA_BLANK\t=\t~((H_Cont<H_BLANK)||(V_Cont<V_BLANK));\nassign\toShift_Flag\t=\t~((H_Cont<(H_BLANK-H_DLY))||(V_Cont<(V_BLANK-V_DLY)));\nassign\toVGA_CLOCK\t=\t~iCLK;\nassign\toVGA_R\t\t=\tiRed;\nassign\toVGA_G\t\t=\tiGreen;\nassign\toVGA_B\t\t=\tiBlue;\nassign\toAddress\t=\toCurrent_Y*H_ACT+oCurrent_X;\nassign\toRequest\t=\t((H_Cont>=H_BLANK-H_DLY && H_Cont<H_TOTAL-H_DLY)\t&&\n\t\t\t\t\t\t (V_Cont>=V_BLANK-V_DLY && V_Cont<V_TOTAL-V_DLY));\nassign\toCurrent_X\t=\t(H_Cont>=(H_BLANK-H_DLY) && H_Cont<H_TOTAL)\t?\tH_Cont-(H_BLANK-H_DLY)\t:\t11'h0\t;\nassign\toCurrent_Y\t=\t(V_Cont>=(V_BLANK-V_DLY) && V_Cont<V_TOTAL)\t?\tV_Cont-(V_BLANK-V_DLY)\t:\t11'h0\t;\nalways@(posedge iCLK or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tH_Cont\t\t<=\t0;\n\t\toVGA_HS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(H_Cont<H_TOTAL)\n\t\tH_Cont\t<=\tH_Cont+1'b1;\n\t\telse\n\t\tH_Cont\t<=\t0;\n\t\tif(H_Cont==H_FRONT-1)\t\t\t\n\t\toVGA_HS\t<=\t1'b0;\n\t\tif(H_Cont==H_FRONT+H_SYNC-1)\t\n\t\toVGA_HS\t<=\t1'b1;\n\tend\nend\nalways@(posedge oVGA_HS or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tV_Cont\t\t<=\t0;\n\t\toVGA_VS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(V_Cont<V_TOTAL)\n\t\tV_Cont\t<=\tV_Cont+1'b1;\n\t\telse\n\t\tV_Cont\t<=\t0;\n\t\tif(V_Cont==V_FRONT-1)\t\t\t\n\t\toVGA_VS\t<=\t1'b0;\n\t\tif(V_Cont==V_FRONT+V_SYNC-1)\t\n\t\toVGA_VS\t<=\t1'b1;\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: mux41_25. \nModule specification: The 'mux41_25' Verilog module encodes a 4:1 multiplexer with a 2-bit selector, selecting among four input data lines based on the selector's value. The module features six input ports: S0 and S1 are the selector bits determining which of the four data inputs (D0, D1, D2, D3) is routed to the output; D0, D1, D2, and D3 are these data inputs. The module lacks an explicit output port declaration, which is a required fix for a functional multiplexer in a typical implementation. Internally, the module contains no additional signals or logic but includes an instantiation of another unspecified 'mux41' module, denoting a likely use of a standard LUT-based 4:1 multiplexer approach within this 'mux41_25' wrapper. The existing code mainly comprises port declarations and the instance of 'mux41', but the functionality related to output and detailed internal processing through 'mux41' remains unspecified due to incomplete code visibility.",
        "output": "module mux41_25(S0,D2,S1,D3,D0,D1,);\ninput S0;\ninput D2;\ninput S1;\ninput D3;\ninput D0;\ninput D1;\nmux41\tlpm_instance(.S0(S0),.D2(D2),.S1(S1),.D3(D3),.D0(D0),.D1(D1),);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: freq_divider_60hz. Module specification: The freq_divider_60hz is a Verilog module designed to divide a 30 MHz input clock signal to produce a 60Hz output clock signal. It features two ports: `in_clk`, the input clock that triggers the frequency division logic on its positive edge, and `out_clk`, the output clock which operates at the lower frequency of 60Hz. Internally, the module employs two key signals: `out`, a register that toggles between 0 and 1 to produce the desired output frequency when a counter threshold is met, and `counter`, an integer that counts the input clock pulses and resets upon reaching a predefined threshold of 500,000. The main logic of the module is encapsulated within an `always` block which is activated on the positive edge of `in_clk`. This block increments the counter by one for each clock pulse; when the counter hits 500,000, it resets to zero and toggles the `out` register. If `out` ever becomes undefined, the module sets it back to 0 to maintain signal integrity. An `assign` statement outside the always block links the internal `out` signal to the `out_clk` output port. This setup ensures a stable and defined signal is maintained at the output, in alignment with the intended frequency division.",
        "output": "`timescale 1ns / 1ps\nmodule freq_divider_60hz(\n    input in_clk,\n    output out_clk\n    );\n\t reg out = 0 ;\n\t integer counter = 0 ;\n\t always @(posedge in_clk) \n\t begin\n\t counter = counter + 1 ;\n\t if(counter == 500000)\n\t\tbegin\n\t\t\tcounter = 0;\n\t\t\tout = ~out ; \n\t\tend\n\t else if(out === 1'bx )\n\t\tbegin\n\t\t  out = 0 ;\n\t\t  counter = 0 ;\n\t\tend\n\t end\n\t \t assign out_clk  = out;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: X_IOBUFDS_DCIEN. \n\nModule specification: The module X_IOBUFDS_DCIEN is a configurable input/output buffer that manages bidirectional data flow with differential signaling and control interfaces, suitable for various configurations. The functionality of the X_IOBUFDS_DCIEN module covers handling tristate logic for IO pins controlled by the T signal. It ensures valid high or low outputs based on differential standards and takes into consideration power modes and data quality settings.\n\nThe module includes the following input ports: `DCITERMDISABLE`, `I`, `IBUFDISABLE`, and `T`. `DCITERMDISABLE` controls differential termination, `I` is the data input port, `IBUFDISABLE` controls the internal buffer disable feature, and `T` is the tristate control for the external IO pins. The module's output ports include `O`, `IO`, and `IOB`. `O` reflects the state of the external IO pair, while `IO` and `IOB` are bidirectional pins of the differential pair setup.\n\nInternal signals such as `i_in`, `io_in`, `iob_in`, `ibufdisable_in`, `dcitermdisable_in`, `t_in`, `o_out`, `io_out`, `iob_out`, `O_int`, `DQS_BIAS_BINARY`, `USE_IBUFDISABLE_BINARY`, `t_or_gts`, `not_t_or_ibufdisable`, and `GTS` help to control and manage the buffer's operation and the high-impedance state of IO pins.\n\nThe module divides its verilog code into sections based on function: setup of IO parameters and internal register signals, signal assignments and I/O control logic, initial block for setting up the boolean controls from parameters with error checking, always block for determining the output logic level based on IO ports condition, and specify block for defining the timing specifications. The module ensures reliability in physical hardware setups with design checks and warnings for correct configuration values.",
        "output": "`timescale 1 ps / 1 ps\nmodule X_IOBUFDS_DCIEN (O, IO, IOB, DCITERMDISABLE, I, IBUFDISABLE, T);\n    parameter LOC = \"UNPLACED\";\n    parameter DIFF_TERM = \"FALSE\";\n    parameter DQS_BIAS = \"FALSE\";\n    parameter IBUF_LOW_PWR = \"TRUE\";\n    parameter IOSTANDARD = \"DEFAULT\";\n    parameter SLEW = \"SLOW\";\n    parameter USE_IBUFDISABLE = \"TRUE\";\n  localparam MODULE_NAME = \"X_IOBUFDS_DCIEN\";\n    output O;\n    inout  IO;\n    inout  IOB;\n    input  DCITERMDISABLE;\n    input  I;\n    input  IBUFDISABLE;\n    input  T;\n    wire i_in, io_in, iob_in, ibufdisable_in, dcitermdisable_in, t_in;\n    reg o_out, io_out, iob_out;\n    reg O_int;\n    reg DQS_BIAS_BINARY = 1'b0;\n    reg USE_IBUFDISABLE_BINARY = 1'b0;\n    wire t_or_gts;\n    wire not_t_or_ibufdisable;\n    tri0 GTS = glbl.GTS;\n    assign O =  (USE_IBUFDISABLE_BINARY == 1'b0) ? o_out :\n                ((not_t_or_ibufdisable === 1'b1) ? 1'b1 : ((not_t_or_ibufdisable === 1'b0) ? o_out : 1'bx));\n    assign dcitermdisable_in = DCITERMDISABLE;\n    assign i_in = I;\n    assign ibufdisable_in = IBUFDISABLE;\n    assign t_in = T;\n    assign io_in = IO;\n    assign iob_in = IOB;\n    assign t_or_gts = GTS || t_in;\n    assign IO  = t_or_gts ? 1'bz :  i_in;\n    assign IOB = t_or_gts ? 1'bz : ~i_in;\n    assign not_t_or_ibufdisable = ~t_in || ibufdisable_in;\n    initial begin\n        case (DQS_BIAS)\n            \"TRUE\"  : DQS_BIAS_BINARY <= #1 1'b1;\n            \"FALSE\" : DQS_BIAS_BINARY <= #1 1'b0;\n            default : begin\n                          $display(\"Attribute Syntax Error : The attribute DQS_BIAS on %s instance %m is set to %s.  Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, DQS_BIAS);\n                          $finish;\n                      end\n        endcase\n\tcase (DIFF_TERM)\n            \"TRUE\", \"FALSE\" : ;\n            default : begin\n                          $display(\"Attribute Syntax Error : The attribute DIFF_TERM on %s instance %m is set to %s.  Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, DIFF_TERM);\n                          $finish;\n                      end\n\tendcase \n        case (IBUF_LOW_PWR)\n            \"FALSE\", \"TRUE\" : ;\n            default : begin\n                          $display(\"Attribute Syntax Error : The attribute IBUF_LOW_PWR on %s instance %m is set to %s.  Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, IBUF_LOW_PWR);\n                          $finish;\n                      end\n        endcase\n      if((IOSTANDARD == \"LVDS_25\") || (IOSTANDARD == \"LVDSEXT_25\")) begin\n            $display(\"DRC Warning : The IOSTANDARD attribute on IOBUFDS_DCIEN instance %m is set to %s.  LVDS_25 is a fixed impedance structure optimized to 100ohm differential. If the intended usage is a bus architecture, please use BLVDS. This is only intended to be used in point to point transmissions that do not have turn around timing requirements\", IOSTANDARD);\n        end\n        case (USE_IBUFDISABLE)\n            \"TRUE\"  : USE_IBUFDISABLE_BINARY <= #1 1'b1;\n            \"FALSE\" : USE_IBUFDISABLE_BINARY <= #1 1'b0;\n            default : begin\n                          $display(\"Attribute Syntax Error : The attribute USE_IBUFDISABLE on %s instance %m is set to %s.  Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, USE_IBUFDISABLE);\n                          $finish;\n                      end\n        endcase\n    end\n    always @(io_in or iob_in or DQS_BIAS_BINARY) begin\n        if (io_in == 1'b1 && iob_in == 1'b0)\n          o_out <= 1'b1;\n        else if (io_in == 1'b0 && iob_in == 1'b1)\n          o_out <= 1'b0;\n        else if ((io_in === 1'bz || io_in == 1'b0) && (iob_in === 1'bz || iob_in == 1'b1))\n          if (DQS_BIAS_BINARY == 1'b1)\n            o_out <= 1'b0;\n          else\n            o_out <= 1'bx;\n        else if (io_in === 1'bx || iob_in === 1'bx)\n          o_out <= 1'bx;\n        end\n    specify\n        (DCITERMDISABLE => O)   = (0:0:0,  0:0:0);\n        (DCITERMDISABLE => IO)  = (0:0:0,  0:0:0);\n        (DCITERMDISABLE => IOB) = (0:0:0,  0:0:0);\n        (I => O)                = (0:0:0,  0:0:0);\n        (I => IO)               = (0:0:0,  0:0:0);\n        (I => IOB)              = (0:0:0,  0:0:0);\n        (IO => O)               = (0:0:0,  0:0:0);\n        (IO => IOB)             = (0:0:0,  0:0:0);\n        (IOB => O)              = (0:0:0,  0:0:0);\n        (IOB => IO)             = (0:0:0,  0:0:0);\n        (IBUFDISABLE => O)      = (0:0:0,  0:0:0);\n        (IBUFDISABLE => IO)     = (0:0:0,  0:0:0);\n        (IBUFDISABLE => IOB)    = (0:0:0,  0:0:0);\n        (T => O)                = (0:0:0,  0:0:0);\n        (T => IO)               = (0:0:0,  0:0:0);\n        (T => IOB)              = (0:0:0,  0:0:0);\n        specparam PATHPULSE$ = 0;\n    endspecify\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: dvsd_4bit_binary_counter. \nModule specification: The 'dvsd_4bit_binary_counter' module is designed as a 4-bit binary counter that operates on the rising edge of a clock signal 'clk'. It either increments or decrements based on the 'updown' control input. If 'reset' is high, the counter resets its output 'out' to 0. When counting upwards ('updown' is high), the counter increments its value until it reaches 15 and then resets to 0. Conversely, if counting downwards ('updown' is low), it decrements its value until it reaches 0 and then resets to 15. The module has three input ports: 'clk' for the clock input, 'reset' that initializes the counter to 0 when high, and 'updown' that determines the counting direction. The output of the module is a 4-bit signal 'out', which holds and displays the counter's current value. Internally, 'out' is implemented as a 4-bit register that either increments or decrements based on the logic provided by the 'updown' and 'reset' conditions within the always block which responds to the positive edge of 'clk'. This structure makes sure that updates to the counter's state are synchronous to the clock input, ensuring reliable operation.",
        "output": " module dvsd_4bit_binary_counter (input clk,\n                                   input reset,\n                                   input updown,\n                                   output reg[3:0] out);\n  always @ (posedge clk) begin  \n    if (reset)  \n      out <= 0;\n    else\n        if(updown==1)\n           if(out==15)\n               out <= 0;  \n           else\n               out <= out + 1; \n        else          \n            if(out==0)\n               out<=15;\n           else\n               out<= out-1;  \n  end  \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Data_Source. Module specification: The Data_Source module is designed to generate a predefined sequence of 4-bit data values upon receiving a start signal and operates synchronized with a clock signal. The module operates with two input ports: 'start_impulse' and 'clk'. The 'start_impulse' triggers the data generation process on its positive edge, initializing the sequence. The 'clk' port is used for timing the sequential data output operations according to the clock's positive edges. The outputs include a 4-bit output register 'Data_out', which holds the generated data, and a binary signal 'end_of_work', which indicates the completion of the data sequence. Internally, the module uses signals such as 'start_work' to engage the data generation, 'device_in_work' to show operational status, 'reset_device' to indicate a reset state, and 'i' as a sequence counter. The Verilog code is segmented into various procedural blocks: the first 'always' block monitors 'start_impulse' and 'end_of_work' to control 'start_work', enabling or disabling data generation. The second 'always' block triggered by 'clk' manages the device's active status with 'device_in_work', and processes sequential data output using the 'i' counter through a case statement which assigns data to 'Data_out' and manages the sequence loop and reset conditions. The end of the work cycle is managed by the assignment to 'end_of_work', which combines the 'device_in_work' and 'reset_device' signals to properly signal the end of operation and readiness for a new cycle.",
        "output": "module Data_Source(start_impulse, clk, \n                 Data_out, end_of_work);\ninput start_impulse;\ninput clk;\noutput reg [0:3] Data_out = 4'b0000;\noutput wire end_of_work;\nreg start_work = 1'b0;\nreg device_in_work = 1'b0;\nreg reset_device = 1'b0;\ninteger i = 0;\t\t\nalways @ (posedge start_impulse or posedge end_of_work)\nbegin\n\t\tif (end_of_work)\n\t\tbegin\n\t\tstart_work = 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\tstart_work = 1'b1;\n\t\tend\nend\nalways @ (posedge clk)\nbegin\n\tcase (start_work)\n\t1:\n\tbegin\n\tdevice_in_work = 1'b1;\n\tend\n\t0:\n\tbegin\n\tdevice_in_work = 1'b0;\t\t\n\tend\n\tdefault:\n\tbegin\n\tdevice_in_work = 1'b0;\n\tend\n\tendcase\n\tif (device_in_work==1'b1)\n\t\t\tbegin\n\t\t\t\t\tif (i<13)\t\t\t\n\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tcase(i)\n\t\t\t\t\t\t\t\t0:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1000;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t1:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out =\t\t\t\t\t4'b0100;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t2:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1100;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t3:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out =\t\t\t\t\t4'b0010;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t4:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1010;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t5:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b0110;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t6:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1110;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t7:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b0001;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t8:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1001;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t9:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b0101;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t10:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b1101;\t\t\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t11:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b0000;\n\t\t\t\t\t\t\t\treset_device = 1'b1;\n\t\t\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tData_out = \t\t\t\t\t4'b0000;\n\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t\treset_device = 1'b0;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tendcase\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\ti = 0; \n\t\t\t\t\tdevice_in_work = 1'b0;\n\t\t\t\t\tend\n\t\t\tend\nend\t\nassign end_of_work = device_in_work && reset_device;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: rate_divider_quarter_second. \n\nModule specification: The `rate_divider_quarter_second` is a Verilog module designed to generate a slower clock signal (`clk_out`) derived from a faster input clock (`clk_in`). The module accomplishes this by implementing a 24-bit counter that increments on every rising edge of `clk_in`. The output signal `clk_out` toggles its state based on the comparison between the most significant bit (MSB) of the counter and a predefined constant `START_VAL` (set to 0). This design enables the output clock to toggle at a significantly reduced frequency, potentially every quarter second, contingent on the input clock's frequency. The module has two ports: an input port `clk_in`, which is the reference clock signal that triggers the internal counting process, and an output port `clk_out`, which outputs the divided clock signal. Internally, the module utilizes a register named `counter` which serves to count the rising edges of `clk_in`. The Verilog implementation encompasses a procedural block starting with `always @ (posedge clk_in)` which continually increments the counter upon each rising edge of `clk_in`. Additionally, the module uses an `assign` statement that sets `clk_out` based on the logic condition comparing `counter[23]` (the MSB of the counter) with `START_VAL`. This structure ensures the consistent and predictable division of the input clock frequency to achieve the desired output frequency.",
        "output": "`timescale 1ns / 1ns\nmodule rate_divider_quarter_second (\n\toutput clk_out,\n\tinput clk_in);\n  localparam START_VAL = 1'd0;\n  reg [23:0] counter;\n  always @ (posedge clk_in) begin\n    counter = counter + 1'b1;\n  end\n  assign clk_out = counter[23] == START_VAL;\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: IOBUF_LVDCI_18. \nModule specification: The IOBUF_LVDCI_18 is a Verilog module designed to implement a tri-state I/O buffer suitable for LVDCI_18 logic levels. This module has three main ports: an input port 'I' for data input, a tri-state control input 'T', and an output port 'O' that mirrors the state of the bidirectional port 'IO'. The bidirectional 'IO' port is either driven by the incoming data 'I' when the module is enabled, or is set to high-impedance allowing for external driving when the module is disabled. The enablement of the module is controlled by the internal signal 'ts', which is the result of an OR operation between 'T' and the global tri-state signal 'GTS' sourced from a global `glbl` module. When 'T' is high and 'GTS' is inactive (low), 'ts' enables the buffer, allowing 'I' to be driven out. Conversely, if 'T' is low or 'GTS' is active, 'ts' disables the buffer making 'IO' high-impedance. The module utilizes three primary internal blocks: an OR gate (O1) to determine the state of 'ts', a tri-state buffer (T1) that controls the connection between 'I' and 'IO', and a standard buffer (B1) to link the state of 'IO' to the output 'O'. This design enables efficient management of I/O lines in systems requiring strict control under varying logic conditions, ensuring that the 'IO' line's state is always accurately reflected through 'O', whether it is being driven by the internal signal or an external source.",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_LVDCI_18 (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: top_spi_final. Module specification: The 'top_spi_final' is a Verilog module designed to manage SPI communication between a single SPI master and up to three SPI slave devices. The module operates based on input signals such as the clock ('clk'), reset ('rst'), load, and three slave select signals ('ss0', 'ss1', 'ss2'). The data input ('data_inp') is an 8-bit signal loaded into an internal 8-bit register 'master_data1' when the 'load' signal is high, allowing data transmission initiation. The module includes output signals such as 'mosi' and internal registers 'slave_data1', 'slave_data2', and 'slave_data3' for each slave device. The 'mosi' output reflects the most significant bit of 'master_data1', functioning as the data line to the active slave. Each slave device data exchange is controlled by its respective slave select signal, which triggers bit-shifting operations crucial for the SPI data transfer. The internal block structure of the code within the 'always' block examines the 'rst' condition to reset all data registers and 'mosi'. If 'load' is asserted, 'master_data1' is loaded from 'data_inp'. For active slave select signals ('ss0', 'ss1', 'ss2'), different bit-shifting scenarios control data flow between 'master_data1' and the respective 'slave_dataX', facilitating the serial communication process critical in SPI interfacing.",
        "output": "`timescale 1ns / 1ps\nmodule top_spi_final(data_inp, load, clk, rst, ss0, ss1, ss2, mosi, master_data1, slave_data1, slave_data2, slave_data3);\ninput clk, ss0, ss1, ss2, load, rst; \ninput [0:7] data_inp; \noutput reg mosi; \noutput reg [0:7] master_data1, slave_data1, slave_data2, slave_data3; \nalways@(posedge clk)\nbegin\n    if(rst) begin\n        master_data1 <= 8'b0; \n        slave_data1 <= 8'b0;\n        slave_data2 <= 8'b0;\n        slave_data3 <= 8'b0;\n        mosi <= 0;\n        end\n    if(load) begin\n        master_data1 <= data_inp; \n        mosi <= master_data1[7];\n        end\n    if(ss0 == 1) begin \n        slave_data1[0] <= master_data1[7];\n        master_data1[0] <= slave_data1[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data1[1:7] <= slave_data1[0:6];\n        mosi <= master_data1[7];\n    end\n    else if(ss1 == 1) begin \n        slave_data2[0] <= master_data1[7];\n        master_data1[0] <= slave_data2[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data2[1:7] <= slave_data2[0:6];\n        mosi <= master_data1[7];\n    end\n    else if(ss2 == 1) begin \n        slave_data3[0] <= master_data1[7];\n        master_data1[0] <= slave_data3[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data3[1:7] <= slave_data3[0:6];\n        mosi <= master_data1[7];\n    end\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: mux41_13. Module specification: The `mux41_13` module is designed to implement a 4-to-1 multiplexer, using an instantiation of a presumably predefined module named `mux41`, referred to here as `lpm_instance`. This multiplexer selects one of the four inputs (`D0`, `D1`, `D2`, `D3`) to pass to its output, with the selection being controlled by two select lines (`S0` and `S1`). The input ports include `S0` and `S1`, which are the select lines determining which data input is connected to the output, and `D0`, `D1`, `D2`, `D3`, which are the data inputs to the multiplexer. Though the original code does not explicitly define any output ports, the operation of a multiplexer suggests there should be an output port carrying the value of the selected input data, guided by the combination of select lines. Internally, there are no signals explicitly declared within the `mux41_13` module itself, as the module primarily serves to instantiate the `mux41` module (`lpm_instance`) and directly connects its input ports to those of `mux41_13`, without any intermediate logic or signals. The code consists solely of the module declaration, input port declarations, and the instantiation of the `mux41` module, with the connections made directly using input ports, indicating a straightforward implementation focused on utilizing a predefined multiplexer logic.",
        "output": "module mux41_13(S0,D2,S1,D3,D0,D1,);\ninput S0;\ninput D2;\ninput S1;\ninput D3;\ninput D0;\ninput D1;\nmux41\tlpm_instance(.S0(S0),.D2(D2),.S1(S1),.D3(D3),.D0(D0),.D1(D1),);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: pipo_8bit. Module specification: The pipo_8bit is a Verilog module designed to implement an 8-bit parallel-in parallel-out (PIPO) shift register. Its functionality revolves around capturing 8-bit input data (`in`) and latching it into internal storage elements (flip-flops) based on a slower clock signal derived from the main clock (`clk`). This latching process allows the data to be outputted in synchrony with a slower clock. The module has three input ports: an 8-bit data input `in`, a main clock input `clk`, and a reset input `rst`. `in` is used for the data to be captured, `clk` is leveraged by an internal module (`slow_clk`) to generate a slower clock signal, and `rst` is used to reset the outputs of the flip-flops to zero when asserted. The output port `y` is an 8-bit vector, representing the data latched from the input. Internally, the module uses a wire `w1`, which serves as the slower clock carried from the `slow_clk` sub-module to each of the eight instantiated `d_ff` flip-flops (`d1` to `d8`). Each flip-flop captures a corresponding bit of the `in` vector on the rising edge of `w1` and sets the respective bit in the output vector `y`. This structured design ensures that input data is appropriately captured and outputted based on the slower timing considerations provided by the `slow_clk` sub-module.",
        "output": "`timescale 1ns / 1ps\nmodule pipo_8bit(\n    input [7:0] in,\n    input clk,rst,\n    output [7:0] y\n    );\n    wire w1;\n    slow_clk clock(.clk_in(clk), .slow_clk(w1));\n    d_ff d1(in[0],w1,rst,y[0]);\n    d_ff d2(in[1],w1,rst,y[1]);\n    d_ff d3(in[2],w1,rst,y[2]);\n    d_ff d4(in[3],w1,rst,y[3]);\n    d_ff d5(in[4],w1,rst,y[4]);\n    d_ff d6(in[5],w1,rst,y[5]);\n    d_ff d7(in[6],w1,rst,y[6]);\n    d_ff d8(in[7],w1,rst,y[7]);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: bin_to_gray. Module specification: The 'bin_to_gray' module is designed to convert a binary number into a Gray code format. It accomplishes this by XORing the binary input 'bin' with itself after a right-shift operation by one bit. The input to the module is the binary number 'bin', which is defined using the parameter `WIDTH` set to 8 by default, specifying the size of the binary number. The output of the module is the Gray code 'gray', which matches the width of the input binary number. Internally, the module uses the wire signal 'gray' which calculates the Gray code output using the expression `bin ^ (bin >> 1)` and passes it to the output port also named 'gray'. The core functionality of the module is encapsulated within the assignment operation that directly transforms the input binary number into its corresponding Gray code. This concise design ensures efficient and clear binary-to-Gray code conversion within Verilog environments.",
        "output": "module bin_to_gray (bin,gray);\nparameter WIDTH = 8;\ninput [WIDTH-1:0] bin;\noutput [WIDTH-1:0] gray;\nwire [WIDTH-1:0] gray;\nassign gray = bin ^ (bin >> 1);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Register_File. Module specification: The Register_File module is designed to simulate a register file typically used in processors, managing read and write operations based on a provided clock signal and control inputs. The module includes input ports such as `clk` (clock signal to synchronize register operations), `RegWrite` (enables writing when high), `A1`, `A2`, `A3` (5-bit addresses for register access), and `WD3` (32-bit data input for writing to the register). Additionally, it has output ports `RD1` and `RD2`, both 32-bit, providing data from the registers addressed by `A1` and `A2` respectively. Internally, the module utilizes an array `RegFile` of 32 registers, each 32 bits wide, which stores the register values. The integer `i` is used for initialization of `RegFile` to zero at the beginning. Within the code, there are blocks handling different aspects: an initialization block sets all registers in `RegFile` to zero, a sequential block triggered on the positive edge of `clk` performs the write operation if `RegWrite` is high, and a combinational logic block that updates outputs `RD1` and `RD2` based on addresses `A1` and `A2`. This structure encapsulates both the data handling and flow control necessary for simulating a processor's register file operation effectively.",
        "output": "module Register_File (\n    input clk,RegWrite,\n    input [4:0]A1,\n    input [4:0]A2,\n    input [4:0]A3,\n    input [31:0]WD3,\n    output reg [31:0]RD1,\n    output reg [31:0]RD2\n);\n    reg [31:0]RegFile[0:31];\n    integer i;\n\tinitial\n\tbegin\n\tfor(i=0;i<32;i=i+1)\n\t\tRegFile[i]=0;\t\n\tend \t\n    always @(posedge clk) begin\n        if(RegWrite)\n        RegFile[A3]<=WD3;\n    end\n    always @(*) begin\n\tRD1<=RegFile[A1];\n    RD2<=RegFile[A2];\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: vtc_cell. \nModule specification: The `vtc_cell` module is designed to manage read and write operations to a RAM, dictated by an external Finite State Machine (FSM) and synchronization signals. Input ports include `clk` (a clock signal for timing updates), `reset_n` (an active-low reset signal for initialization), `sin` (synchronization input), `din` (data input), `fsm` (FSM state input), `cycle` (a signal influencing read/write operations), and `rate` (potentially for timing factors), along with `dctv` (additional data input not described but present in the signals). Output ports consist of `wr_addr` (write address for RAM), `rd_addr` (read address for RAM), `ram_wr` (write enable signal for RAM), and `ram_d` (data to be written to RAM). Internal signals include `addr_offset` (register storing address offset for reading from RAM) and `rd_counter` (counter for generating read addresses). The module contains multiple always blocks: `wr_addr_r` handles the increment of write address based on the FSM state indicating a write operation; `addr_offset_r` determines the address offset based on the `cycle` input; `rd_addr_r` and `rd_counter_r` manage the computation of the read address in tandem, influenced by FSM state and the `cycle` signal; `wr_r` controls the RAM write enable conditionally on the FSM state and `sin`; `data_in_r` manages data entry into `ram_d` synchronized with `sin`. Each section specifically responds to the `clk` and `reset_n` signals to ensure stable, predictable operations in line with the synchronization and state transitions dictated by the FSM.",
        "output": "module vtc_cell(\n    clk,\n    reset_n,\n    sin,\n    din,\n    fsm,\n    cycle,\n    rate,\n    wr_addr,\n    rd_addr,\n    ram_wr,\n    ram_d,\n    dctv \n);\nparameter OFFSET1 = 0,\n          OFFSET2 = 0,\n          OFFSET3 = 0;\nparameter D_WID = 8;\nparameter A_WID = 8;\ninput                 clk        ;\ninput                 reset_n    ;\ninput                 rate       ;\ninput   [D_WID-1:0]   din        ; \ninput                 sin        ;\ninput   [3:0]         fsm        ;\ninput   [3:0]         cycle      ;\ninput   [D_WID-1:0]   dctv       ;\noutput  [A_WID-1:0]   wr_addr    ;\noutput  [A_WID-1:0]   rd_addr    ;\noutput                ram_wr     ;\noutput  [D_WID-1:0]   ram_d      ;\nreg     [A_WID-1:0]   wr_addr    ;\nreg     [A_WID-1:0]   rd_addr    ;\nreg                   ram_wr     ;\nreg     [D_WID-1:0]   ram_d      ;\nreg     [A_WID-1:0]   addr_offset;\nreg     [A_WID-1:0]   rd_counter ;\nalways @ (posedge clk or negedge reset_n)\nbegin : wr_addr_r\n    if(!reset_n)\n        wr_addr <= #1 1'b0;\n    else begin\n    case(fsm)\n    4'b0010:\n        if(ram_wr)    \n        wr_addr <= #1 wr_addr + 1'b1;\n    default:\n        wr_addr <= #1 1'b0;\n    endcase\n    end\nend    \nalways @ (*)\nbegin : addr_offset_r\n    case(cycle[3:2])\n    2'b01: addr_offset = OFFSET1;\n    2'b10: addr_offset = OFFSET2;\n    2'b11: addr_offset = OFFSET3;\n    default: addr_offset = 8'h0;\n    endcase\nend    \nalways @ (posedge clk or negedge reset_n)\nbegin : rd_addr_r\n    if(!reset_n)\n        rd_addr <= #1 8'h0;\n    else begin\n    case(fsm)\n    4'b0100:\n        rd_addr <= #1 rd_counter + addr_offset;\n    default:\n        rd_addr <= #1 8'h0;\n    endcase\n    end\nend        \nalways @ (posedge clk or negedge reset_n)\nbegin : rd_counter_r\n    if(!reset_n)\n        rd_counter <= #1 8'h0;\n    else if(fsm[2]) begin \n        if ( cycle[3:2] == 2'b11)\n        rd_counter <= #1 rd_counter + 1'b1;\n        else\n        rd_counter <= #1 rd_counter;\n        end\n    else\n        rd_counter <= #1 8'h0;\nend\nalways @ (posedge clk or negedge reset_n)\nbegin : wr_r\n    if(!reset_n)\n        ram_wr <= #1 1'b0;\n    else if(fsm[1])\n        ram_wr <= #1 sin;\nend\nalways @ (posedge clk or negedge reset_n)\nbegin : data_in_r\n    if(!reset_n)\n         ram_d <= #1 'h0;\n    else if(sin)\n         ram_d <= #1 din;\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: latency_aware_read_master. Module specification: The latency_aware_read_master is a Verilog module designed to handle memory read operations with latency awareness, suitable for FPGA or ASIC environments. It manages read operations by generating memory read addresses and controlling reads based on inputs related to the starting memory address, the amount of data to read, and when to trigger reading. Input ports include clk (clock signal), reset (resets internal states), control_fixed_location (indicates fixed memory address reads), control_read_base (starting address for reads), control_read_length (data amount to read), control_go (triggers start of read), user_read_buffer (fetch data signal from FIFO), master_waitrequest, master_readdatavalid, and master_readdata (memory read interface signals). Output ports feature control_done (indicates completion), control_early_done (signals early completion), user_buffer_data (data to user from FIFO), user_data_available (data presence indicator in FIFO), master_address (current read target address), master_read (memory read request), and master_byteenable (active byte lanes for read). Internal signals such as control_fixed_location_d1 (delayed fixed location read indicator), fifo_empty (FIFO buffer status), address, length, reads_pending (tracks in-flight read requests), too_many_pending_reads (status indicating potential overflow conditions), and fifo_used (tracks used slots in FIFO) manage the module's logic and memory interactions. The module's code is segmented into blocks handling signal delay implementations, read address generation based on control inputs and conditions, master read logic conditioned on FIFO and pending reads, and a FIFO module instantiation managing data transfer between the master and user. Each block plays a critical role in ensuring that data is read efficiently and safely, reflecting the module's design geared toward optimal data handling in systems sensitive to read latency.",
        "output": "module latency_aware_read_master (\n\tclk,\n\treset,\n\tcontrol_fixed_location,\n\tcontrol_read_base,\n\tcontrol_read_length,\n\tcontrol_go,\n\tcontrol_done,\n\tcontrol_early_done,\n\tuser_read_buffer,\n\tuser_buffer_data,\n\tuser_data_available,\n\tmaster_address,\n\tmaster_read,\n\tmaster_byteenable,\n\tmaster_readdata,\n\tmaster_readdatavalid,\n\tmaster_waitrequest\n);\n\tparameter DATAWIDTH = 32;\n\tparameter BYTEENABLEWIDTH = 4;\n\tparameter ADDRESSWIDTH = 32;\n\tparameter FIFODEPTH = 32;\n\tparameter FIFODEPTH_LOG2 = 5;\n\tparameter FIFOUSEMEMORY = 1;  \n\tinput clk;\n\tinput reset;\n\tinput control_fixed_location;\n\tinput [ADDRESSWIDTH-1:0] control_read_base;\n\tinput [ADDRESSWIDTH-1:0] control_read_length;\n\tinput control_go;\n\toutput wire control_done;\n\toutput wire control_early_done;  \n\tinput user_read_buffer;\n\toutput wire [DATAWIDTH-1:0] user_buffer_data;\n\toutput wire user_data_available;\n\tinput master_waitrequest;\n\tinput master_readdatavalid;\n    input [DATAWIDTH-1:0] master_readdata;\n\toutput wire [ADDRESSWIDTH-1:0] master_address;\n\toutput wire master_read;\n\toutput wire [BYTEENABLEWIDTH-1:0] master_byteenable;\n\treg control_fixed_location_d1;\n\twire fifo_empty;\n\treg [ADDRESSWIDTH-1:0] address;\n\treg [ADDRESSWIDTH-1:0] length;\n\treg [FIFODEPTH_LOG2-1:0] reads_pending;\n\twire increment_address;\n\twire too_many_pending_reads;\n\treg too_many_pending_reads_d1;\n\twire [FIFODEPTH_LOG2-1:0] fifo_used;\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tcontrol_fixed_location_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (control_go == 1)\n\t\t\tbegin\n\t\t\t\tcontrol_fixed_location_d1 <= control_fixed_location;\n\t\t\tend\n\t\tend\n\tend\n\tassign master_address = address;\n\tassign master_byteenable = -1;  \n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\taddress <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\taddress <= control_read_base;\n\t\t\tend\n\t\t\telse if((increment_address == 1) & (control_fixed_location_d1 == 0))\n\t\t\tbegin\n\t\t\t\taddress <= address + BYTEENABLEWIDTH;  \n\t\t\tend\n\t\tend\n\tend\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tlength <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\tlength <= control_read_length;\n\t\t\tend\n\t\t\telse if(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tlength <= length - BYTEENABLEWIDTH;  \n\t\t\tend\n\t\tend\n\tend\t\n\tassign too_many_pending_reads = (fifo_used + reads_pending) >= (FIFODEPTH - 4);\n\tassign master_read = (length != 0) & (too_many_pending_reads_d1 == 0);\n\tassign increment_address = (length != 0) & (too_many_pending_reads_d1 == 0) & (master_waitrequest == 0);\n\tassign control_done = (reads_pending == 0) & (length == 0);  \n\tassign control_early_done = (length == 0);  \n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= too_many_pending_reads;\n\t\tend\n\tend\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\treads_pending <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  \n\t\t\t\tend\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  \n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending - 1;  \n\t\t\t\tend\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\n\tassign user_data_available = !fifo_empty;\n\tscfifo the_master_to_user_fifo (\n\t\t.aclr (reset),\n\t\t.clock (clk),\n\t\t.data (master_readdata),\n\t\t.empty (fifo_empty),\n\t\t.q (user_buffer_data),\n\t\t.rdreq (user_read_buffer),\n\t\t.usedw (fifo_used),\n\t\t.wrreq (master_readdatavalid)\n\t);\n\tdefparam the_master_to_user_fifo.lpm_width = DATAWIDTH;\n\tdefparam the_master_to_user_fifo.lpm_numwords = FIFODEPTH;\n\tdefparam the_master_to_user_fifo.lpm_showahead = \"ON\";\n\tdefparam the_master_to_user_fifo.use_eab = (FIFOUSEMEMORY == 1)? \"ON\" : \"OFF\";\n\tdefparam the_master_to_user_fifo.add_ram_output_register = \"OFF\";\n\tdefparam the_master_to_user_fifo.underflow_checking = \"OFF\";\n\tdefparam the_master_to_user_fifo.overflow_checking = \"OFF\";\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: assign2_system_mm_interconnect_0_avalon_st_adapter.\n\nModule specification: The assign2_system_mm_interconnect_0_avalon_st_adapter serves as a generated FPGA or ASIC system interconnect adapter. The module is primarily concerned with parameter validation where checks are performed to ensure given parameters such as data width, utilized ports, validity signals, readiness signals, and more adhere to their expected range or values. If parameters are not within the permissible boundary, an error is relayed to the simulation log.\n\nInput ports include in_clk_0_clk (clock input), in_rst_0_reset (reset input signal), in_0_data (34-bit input data bus), in_0_valid (validity flag for input data), and out_0_ready (indicating the readiness of the connected module to receive data). Output ports encompass in_0_ready (signifies module readiness to receive more input data), out_0_data (34-bit output data bus), out_0_valid (validity flag for output data), out_0_error(error indication signal), and out_0_ready(indicating readiness of this module to send data).\n\nNo explicit internal signals are declared or utilized in the module; main focus is on parameter checking and connections to the instantiated modules. The code is broadly split into two sections - a generate section, where various parameter checks are conducted and the final connectivity to the 'assign2_system_mm_interconnect_0_avalon_st_adapter_error_adapter_0' module. Misconfiguration of parameters halts simulation, enabling mitigative action, thereby ensuring validation before any substantial simulation or synthesis tasks. This module hence operates as a system-level safeguard, underscoring correct parameter configuration.",
        "output": "`timescale 1 ps / 1 ps\nmodule assign2_system_mm_interconnect_0_avalon_st_adapter #(\n\t\tparameter inBitsPerSymbol = 34,\n\t\tparameter inUsePackets    = 0,\n\t\tparameter inDataWidth     = 34,\n\t\tparameter inChannelWidth  = 0,\n\t\tparameter inErrorWidth    = 0,\n\t\tparameter inUseEmptyPort  = 0,\n\t\tparameter inUseValid      = 1,\n\t\tparameter inUseReady      = 1,\n\t\tparameter inReadyLatency  = 0,\n\t\tparameter outDataWidth    = 34,\n\t\tparameter outChannelWidth = 0,\n\t\tparameter outErrorWidth   = 1,\n\t\tparameter outUseEmptyPort = 0,\n\t\tparameter outUseValid     = 1,\n\t\tparameter outUseReady     = 1,\n\t\tparameter outReadyLatency = 0\n\t) (\n\t\tinput  wire        in_clk_0_clk,   \n\t\tinput  wire        in_rst_0_reset, \n\t\tinput  wire [33:0] in_0_data,      \n\t\tinput  wire        in_0_valid,     \n\t\toutput wire        in_0_ready,     \n\t\toutput wire [33:0] out_0_data,     \n\t\toutput wire        out_0_valid,    \n\t\tinput  wire        out_0_ready,    \n\t\toutput wire [0:0]  out_0_error     \n\t);\n\tgenerate\n\t\tif (inBitsPerSymbol != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinbitspersymbol_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUsePackets != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinusepackets_check ( .error(1'b1) );\n\t\tend\n\t\tif (inDataWidth != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tindatawidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inChannelWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinchannelwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inErrorWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinerrorwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseEmptyPort != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinuseemptyport_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseValid != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinusevalid_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseReady != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinuseready_check ( .error(1'b1) );\n\t\tend\n\t\tif (inReadyLatency != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinreadylatency_check ( .error(1'b1) );\n\t\tend\n\t\tif (outDataWidth != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutdatawidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outChannelWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutchannelwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outErrorWidth != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\touterrorwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseEmptyPort != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutuseemptyport_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseValid != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutusevalid_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseReady != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutuseready_check ( .error(1'b1) );\n\t\tend\n\t\tif (outReadyLatency != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutreadylatency_check ( .error(1'b1) );\n\t\tend\n\tendgenerate\n\tassign2_system_mm_interconnect_0_avalon_st_adapter_error_adapter_0 error_adapter_0 (\n\t\t.clk       (in_clk_0_clk),    \n\t\t.reset_n   (~in_rst_0_reset), \n\t\t.in_data   (in_0_data),       \n\t\t.in_valid  (in_0_valid),      \n\t\t.in_ready  (in_0_ready),      \n\t\t.out_data  (out_0_data),      \n\t\t.out_valid (out_0_valid),     \n\t\t.out_ready (out_0_ready),     \n\t\t.out_error (out_0_error)      \n\t);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: soft_ecc_ram_32bit. Module specification: The soft_ecc_ram_32bit is designed to provide reliable data storage through Error Correcting Code (ECC) for two separate ports, Port A and Port B, each facilitated with its own clock. The purpose of the module is to ensure data integrity by encoding data with ECC before storage and decoding it upon retrieval for detecting and correcting any potential errors. Input ports include reset (`rst`), address (`address_a`, `address_b`), clock (`clock_a`, `clock_b`), data (`data_a`, `data_b`), and write enable signals (`wren_a`, `wren_b`). The reset initializes the system, addresses specify the memory locations, clocks synchronize operations, data ports accept input data for storage, and write enable signals control the writing process. Output ports feature data outputs (`q_a`, `q_b`) and error statuses (`err_a`, `err_b`) indicating no error, correctable, and fatal errors. Internally, data inputs are first registered (`data_a_reg`, `data_b_reg`), then encoded (`data_a_code`, `data_b_code`) and stored in the RAM. Upon data retrieval, the ECC-encoded outputs (`q_a_code`, `q_b_code`) are fetched from RAM and decoded to provide final output and error status. The module comprises several functional blocks including ECC encoders (`ecc_encode_32bit`), RAM storage managed by a `ram_block`, and ECC decoders (`ecc_decode_32bit`) with parameters set for handling input-output operations effectively. The entire process ensures that each data path maintains high data integrity and reliable error handling capabilities.",
        "output": "module soft_ecc_ram_32bit (\n\trst,\n\taddress_a,\n\taddress_b,\n\tclock_a,\n\tclock_b,\n\tdata_a,\n\tdata_b,\n\twren_a,\n\twren_b,\n\tq_a,\n\tq_b,\n\terr_a,\n\terr_b\n);\n`include \"log2.inc\"\nparameter NUM_WORDS = 512;\nlocalparam ADDR_WIDTH = log2(NUM_WORDS-1);\nparameter PORT_A_ERROR_INJECT = 39'b0;\nparameter PORT_B_ERROR_INJECT = 39'b0;\n\tinput   rst;\n\tinput\t[ADDR_WIDTH-1:0]  address_a;\n\tinput\t[ADDR_WIDTH-1:0]  address_b;\n\tinput   clock_a;\n\tinput   clock_b;\n\tinput\t[31:0]  data_a;\n\tinput\t[31:0]  data_b;\n\tinput   wren_a;\n\tinput   wren_b;\n\toutput\t[31:0]  q_a;\n\toutput\t[31:0]  q_b;\n\toutput  [2:0] err_a;\n\toutput  [2:0] err_b;\nreg [31:0] data_a_reg;\nalways @(posedge clock_a or posedge rst) begin\n\tif (rst) data_a_reg <= 32'b0;\n\telse data_a_reg <= data_a;\nend\nwire [38:0] data_a_code;\necc_encode_32bit enc_a (.d(data_a_reg),.c(data_a_code));\nreg [31:0] data_b_reg;\nalways @(posedge clock_b or posedge rst) begin\n\tif (rst) data_b_reg <= 32'b0;\n\telse data_b_reg <= data_b;\nend\nwire [38:0] data_b_code;\necc_encode_32bit enc_b (.d(data_b_reg),.c(data_b_code));\nwire [38:0] q_a_code;\nwire [38:0] q_b_code;\nram_block ram (\n\t.aclr_a(rst),\n\t.aclr_b(rst),\n\t.address_a(address_a),\n\t.address_b(address_b),\n\t.clock_a(clock_a),\n\t.clock_b(clock_b),\n\t.data_a(data_a_code),\n\t.data_b(data_b_code),\n\t.wren_a(wren_a),\n\t.wren_b(wren_b),\n\t.q_a(q_a_code),\n\t.q_b(q_b_code)\n);\ndefparam ram .NUM_WORDS = NUM_WORDS;\ndefparam ram .DAT_WIDTH = 39;\necc_decode_32bit dec_a (\n\t.clk(clock_a),\n\t.rst(rst),\n\t.c(q_a_code ^ PORT_A_ERROR_INJECT),\n\t.d(q_a),\n\t.no_err(err_a[0]),\n\t.err_corrected(err_a[1]),\n\t.err_fatal(err_a[2]));\ndefparam dec_a .OUTPUT_REG = 1;\ndefparam dec_a .MIDDLE_REG = 1;\necc_decode_32bit dec_b (\n\t.clk(clock_b),\n\t.rst(rst),\n\t.c(q_b_code ^ PORT_B_ERROR_INJECT),\n\t.d(q_b),\n\t.no_err(err_b[0]),\n\t.err_corrected(err_b[1]),\n\t.err_fatal(err_b[2]));\ndefparam dec_b .OUTPUT_REG = 1;\ndefparam dec_b .MIDDLE_REG = 1;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Top. Module specification: The Top module serves as the primary aggregator in a multi-stage arithmetic system designed for efficient binary addition using carry-save techniques. This module integrates the functionalities of three key sub-modules\u2014stage1_3is2, stage2_3is2, and stage3_4is2\u2014to perform progressive addition operations on multi-bit binary inputs and produce a single 6-bit output. It takes six 4-bit binary numbers as inputs through ports [i1, i2, i3, i4, i5, i6], each feeding into designated stages for initial processing. The outputs are manipulated through various internal signals: [cout_S1, sum_S1, cout_S2, sum_S2, sum_S3, cout_S3], which capture carries and sum outputs intermediate computations, forwarding them between stages to culminate in the final output [answer]. The full addition processes in stage1_3is2 and stage2_3is2 primarily handle the initial expansion and aggregation of the inputs. Stage3_4is2 further synthesizes these intermediate results using both direct inputs from previous stages and propagated carries to finalize the computation. Secondary modules like FullAdder and carrysave_4is2 are utilized within these stages to perform the necessary binary arithmetic. The Top module, by encapsulating this structured multi-stage addition sequence, effectively streamlines complex binary additions into a feasible and scalable operation.",
        "output": "module stage1_3is2 (\ninput [5:0] in1,\ninput [5:0] in2,\ninput [5:0] in3,\noutput [5:0] cout_stage1,\noutput [5:0] sum_stage1\n);\nFullAdder FA2 (in1[0],in2[0],in3[0],sum_stage1[0],cout_stage1[0]);\nFullAdder FA3 (in1[1],in2[1],in3[1],sum_stage1[1],cout_stage1[1]);\nFullAdder FA4 (in1[2],in2[2],in3[2],sum_stage1[2],cout_stage1[2]);\nFullAdder FA5 (in1[3],in2[3],in3[3],sum_stage1[3],cout_stage1[3]);\nFullAdder FA12 (in1[4],in2[4],in3[4],sum_stage1[4],cout_stage1[4]);\nFullAdder FA13 (in1[5],in2[5],in3[5],sum_stage1[5],cout_stage1[5]);\nendmodule\nmodule stage2_3is2 (\ninput [5:0] in4,\ninput [5:0] in5,\ninput [5:0] in6,\noutput [5:0] cout_stage2,\noutput [5:0] sum_stage2\n);\nFullAdder FA6 (in4[0],in5[0],in6[0],sum_stage2[0],cout_stage2[0]);\nFullAdder FA7 (in4[1],in5[1],in6[1],sum_stage2[1],cout_stage2[1]);\nFullAdder FA8 (in4[2],in5[2],in6[2],sum_stage2[2],cout_stage2[2]);\nFullAdder FA9 (in4[3],in5[3],in6[3],sum_stage2[3],cout_stage2[3]);\nFullAdder FA22 (in4[4],in5[4],in6[4],sum_stage2[4],cout_stage2[4]);\nFullAdder FA23 (in4[5],in5[5],in6[5],sum_stage2[5],cout_stage2[5]);\nendmodule\nmodule stage3_4is2 (\ninput [5:0] subin1,\ninput [5:0] subin2,\ninput [5:0] subin3,\ninput [5:0] subin4,\noutput [5:0] sum_stage3,\noutput [5:0] cout_stage3\n);\nwire connection1,connection2,connection3,connection4,connection5;\ncarrysave_4is2 CS1(({1'b0,1'b0,subin3[0],1'b0,subin1[0]}),connection1,cout_stage3[0],sum_stage3[0]);\ncarrysave_4is2 CS2(({connection1,subin4[0],subin3[1],subin2[0],subin1[1]}),connection2,cout_stage3[1],sum_stage3[1]);\ncarrysave_4is2 CS3(({connection2,subin4[1],subin3[2],subin2[1],subin1[2]}),connection3,cout_stage3[2],sum_stage3[2]);\ncarrysave_4is2 CS4(({connection3,subin4[2],subin3[3],subin2[2],subin1[3]}),connection4,cout_stage3[3],sum_stage3[3]);\ncarrysave_4is2 CS5(({connection4,subin4[3],subin3[4],subin2[3],subin1[4]}),connection5,cout_stage3[4],sum_stage3[4]);\ncarrysave_4is2 CS6(({connection5,subin4[4],subin3[5],subin2[4],subin1[5]}), , ,sum_stage3[5]);\nendmodule\nmodule Top (\ninput [3:0] i1,\ninput [3:0] i2,\ninput [3:0] i3,\ninput [3:0] i4,\ninput [3:0] i5,\ninput [3:0] i6,\noutput [5:0] answer\n);\nwire [5:0] cout_S1;\nwire [5:0] sum_S1;\nwire [5:0] cout_S2;\nwire [5:0] sum_S2;\nwire [5:0] sum_S3;\nwire [5:0] cout_S3;\nstage1_3is2 S1 ( {i1[3],i1[3],i1[3:0]} , {i2[3],i2[3],i2[3:0]} , {i3[3],i3[3],i3[3:0]} , cout_S1[5:0] , sum_S1[5:0]);\nstage2_3is2 S2 ( {i4[3],i4[3],i4[3:0]} , {i5[3],i5[3],i5[3:0]} , {i6[3],i6[3],i6[3:0]} , cout_S2[5:0] , sum_S2[5:0]);\nstage3_4is2 S3 (sum_S1[5:0],({cout_S1[4:0],1'b0}),sum_S2[5:0],({cout_S2[4:0],1'b0}),sum_S3[5:0],cout_S3[5:0]);\nassign answer [5:0] = (sum_S3[5:0]) + ({cout_S3[4:0],1'b0}); \nendmodule\nmodule carrysave_4is2 (\ninput [4:0] in,\noutput c0,\noutput c1,\noutput sum\n);\nwire connection;\nFullAdder FA0 (in[0],in[1],in[2],connection,c0);\nFullAdder FA1 (connection,in[4],in[3],sum,c1);\nendmodule\nmodule FullAdder(\ninput in1,\ninput in2,\ninput cin,\noutput sum,\noutput cout\n);\nassign sum = (in1 ^ in2) ^ cin;\nassign cout = (in1 & in2) | (cin & (in1 ^ in2));\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: altpcie_pll_100_250.\nModule specification: The `altpcie_pll_100_250` module is designed to configure a phase-locked loop (PLL) for PCIe applications on Stratix GX FPGA devices, initializing an `altpll` component to generate the output clock `c0` from the input clock `inclk0`. It includes input ports `areset`, an asynchronous reset that ensures the PLL starts in a known state, and `inclk0`, the primary input clock signal. The output `c0` is the stable clock signal derived from the PLL\u2019s configuration. Internal signals such as `sub_wire0` through `sub_wire7` facilitate various functionalities such as clock enable conditions, input clock structuring, and disabling unused features. The `altpll_component` block configures the PLL settings like bandwidth, clock division and multiplication, and duty cycle. Parameters like `inclk0_input_frequency` and `intended_device_family` specifically tailor the PLL for optimal performance in Stratix GX FPGAs targeting PCIe applications.",
        "output": "`timescale 1 ps / 1 ps\nmodule altpcie_pll_100_250 (\n\tareset,\n\tinclk0,\n\tc0);\n\tinput\t  areset;\n\tinput\t  inclk0;\n\toutput\t  c0;\n\twire [5:0] sub_wire0;\n\twire [0:0] sub_wire2 = 1'h0;\n\twire [0:0] sub_wire4 = 1'h1;\n\twire [0:0] sub_wire1 = sub_wire0[0:0];\n\twire  c0 = sub_wire1;\n\twire [5:0] sub_wire3 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire4};\n\twire  sub_wire5 = inclk0;\n\twire [1:0] sub_wire6 = {sub_wire2, sub_wire5};\n\twire [3:0] sub_wire7 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2};\n\taltpll\taltpll_component (\n\t\t\t\t.clkena (sub_wire3),\n\t\t\t\t.inclk (sub_wire6),\n\t\t\t\t.extclkena (sub_wire7),\n\t\t\t\t.areset (areset),\n\t\t\t\t.clk (sub_wire0)\n\t\t\t\t,\n\t\t\t\t.scanclk (),\n\t\t\t\t.pllena (),\n\t\t\t\t.sclkout1 (),\n\t\t\t\t.sclkout0 (),\n\t\t\t\t.fbin (),\n\t\t\t\t.scandone (),\n\t\t\t\t.clkloss (),\n\t\t\t\t.extclk (),\n\t\t\t\t.clkswitch (),\n\t\t\t\t.pfdena (),\n\t\t\t\t.scanaclr (),\n\t\t\t\t.clkbad (),\n\t\t\t\t.scandata (),\n\t\t\t\t.enable1 (),\n\t\t\t\t.scandataout (),\n\t\t\t\t.enable0 (),\n\t\t\t\t.scanwrite (),\n\t\t\t\t.locked (),\n\t\t\t\t.activeclock (),\n\t\t\t\t.scanread ()\n\t\t\t\t);\n\tdefparam\n\t\taltpll_component.bandwidth = 500000,\n\t\taltpll_component.bandwidth_type = \"CUSTOM\",\n\t\taltpll_component.clk0_divide_by = 2,\n\t\taltpll_component.clk0_duty_cycle = 50,\n\t\taltpll_component.clk0_multiply_by = 5,\n\t\taltpll_component.clk0_phase_shift = \"0\",\n\t\taltpll_component.compensate_clock = \"CLK0\",\n\t\taltpll_component.inclk0_input_frequency = 10000,\n\t\taltpll_component.intended_device_family = \"Stratix GX\",\n\t\taltpll_component.lpm_type = \"altpll\",\n\t\taltpll_component.operation_mode = \"NORMAL\",\n\t\taltpll_component.pll_type = \"ENHANCED\",\n\t\taltpll_component.spread_frequency = 0;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Enc8B10B. \nModule specification: The Enc8B10B module is designed for encoding 8-bit binary input data (in) into a 10-bit encoded output (out), using the 8B/10B encoding technique which helps to balance the number of ones and zeros, crucial in communication systems for reliable data transmission and clock recovery. The module operates synchronized to a BYTECLK input signal. It takes additional inputs: a reset signal which resets the internal states when active, and a bit_control signal indicating special control characters during encoding. The key outputs are the 10-bit encoded data and a running disparity output (rd_out), which helps manage long-term balance in the encoded data stream. Internal signals include clk (linked to BYTECLK for synchronizing operations), saving registers like saved_K, saved_L, and saved_data_in for preserving state across cycles, and signals like rd_in_s4, S, COMPLS6, and COMPLS4 used in various encoding control operations. The module's core functional blocks are fcn5b and fcn3b for initial data encoding, disCtrl for managing control and disparity, and fcn5b6b and fcn3b4b for final encoding compositions, producing parts of the final output. The data flow through these blocks, synchronized via clk, results in a robust encoding mechanism to meet communication standards.",
        "output": "`timescale 1ns / 1ps\nmodule Enc8B10B(\n    input BYTECLK, \n    input reset,\n    input bit_control,\n    input [7:0] in,\n    output [9:0] out,\n    output rd_out\n    );\n    wire clk = BYTECLK; \n    wire rd_in_s4, S, COMPLS6, COMPLS4, saved_K;\n    wire [4:0] L, saved_L;    \n    wire [7:0] saved_data_in;\n    wire [5:0] abcdei;\n    wire [3:0] fghj; \n    reg [7:0] data_in;\n    reg K, rd_in;\n    fcn5b   f5b(clk, data_in[4:0], L);\n    fcn3b   f3b(clk, data_in[4:3], rd_in_s4, L, S); \n    disCtrl dis(clk, reset, K, L, S, data_in, rd_in, saved_data_in, saved_L, saved_K, rd_in_s4, COMPLS6, COMPLS4, rd_out);\n    fcn5b6b f56(clk, reset, saved_data_in[4:0], saved_L, saved_K, COMPLS6, abcdei);\n    fcn3b4b f34(clk, reset, saved_data_in[7:5], S, saved_K, COMPLS4, fghj);\n    always @(posedge clk)\n    begin\n        if (reset) begin \n            K <= 0;\n            rd_in = 0;\n            data_in = 0;\n        end\n        else begin \n            K <= bit_control;\n            rd_in = rd_out;\n            data_in = in;\n        end\n    end\n    assign out = {abcdei[5:0], fghj[3:0]}; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: altera_avalon_video_sync_generator. \nModule specification: The altera_avalon_video_sync_generator module is designed to generate synchronization signals for coordinating video display systems, specifically handling horizontal (HD) and vertical (VD) synchronization and determining video data activity (DEN). The module takes inputs such as a clock (clk), an active low reset signal (reset_n), video data stream (data), control signals (valid, sop, eop), and a packet status indicator (empty). It outputs synchronized RGB video data (RGB_OUT), horizontal (HD) and vertical sync signals (VD), and the data enable signal (DEN). The module employs a variety of internal signals like sync_reset, column_count_enable, pixel_count_enable, and many others to manage pixel and scan dimension calculations, synchronize output signals, and control data flow through counters and conditional statements. Key sections of the Verilog code include initialization and reset conditions, logic for pixel management, sync signal generation regulated by counters, and the control of output based on active video zones. The operational blocks handle specifics from resetting on a negative reset edge to calculating when the outputs should be active reflecting calculated synchronization timings.",
        "output": "`timescale 100 ps / 100 ps\nmodule altera_avalon_video_sync_generator\n  (\n   clk,\n   reset_n,\n   ready,\n   valid,\n   data,   \n   sop,    \n   eop,    \n   empty,  \n   RGB_OUT,     \n   HD,\n   VD,\n   DEN\n   );\n   parameter DATA_STREAM_BIT_WIDTH = 8;\n   parameter BEATS_PER_PIXEL       = 3;\n   parameter OUTPUT_CLOCK_EDGE     = 1;  \n   parameter NUM_ROWS              = 480;\n   parameter NUM_COLUMNS           = 800;\n   parameter H_BLANK_PIXELS        = 216;\n   parameter H_FRONT_PORCH_PIXELS  = 40;\n   parameter H_SYNC_PULSE_PIXELS   = 1;\n   parameter H_SYNC_PULSE_POLARITY = 0;\n   parameter V_BLANK_LINES         = 35;\n   parameter V_FRONT_PORCH_LINES   = 10;\n   parameter V_SYNC_PULSE_LINES    = 1;\n   parameter V_SYNC_PULSE_POLARITY = 0;\n   parameter TOTAL_HSCAN_PIXELS    = 1056;\n   parameter TOTAL_VSCAN_LINES     = 525;   \n   localparam COLUMN_COUNTER_WIDTH       = (log2(TOTAL_HSCAN_PIXELS ));\n   localparam ROW_COUNTER_WIDTH          = (log2(TOTAL_VSCAN_LINES  ));\n   localparam PIXEL_PART_COUNTER_WIDTH   = (log2(BEATS_PER_PIXEL+1  )); \n   input     reset_n;\n   input     clk;\n   wire      sync_reset = 1'b0;   \n   output [(DATA_STREAM_BIT_WIDTH - 1):0] RGB_OUT;\n   output \t\t\t\t  HD;\n   output \t\t\t\t  VD;\n   output \t\t\t\t  DEN;\n   output \t\t\t\t  ready;\n   input \t\t\t\t  valid;\n   input [(DATA_STREAM_BIT_WIDTH - 1):0]  data;\n   input \t\t\t\t  sop;\n   input \t\t\t\t  eop;\n   input \t\t\t\t  empty;  \n   function integer log2;\n      input [31:0] \t  value;\n      for (log2=0; value>0; log2=log2+1)\n\tvalue = value>>1;\n   endfunction \n   wire [(DATA_STREAM_BIT_WIDTH - 1):0] pRGB_OUT = data;\n   reg  [PIXEL_PART_COUNTER_WIDTH : 0] pixel_part_counter;\n   wire [PIXEL_PART_COUNTER_WIDTH : 0] next_pixel_part_counter;\n   assign next_pixel_part_counter = (pixel_part_counter == (BEATS_PER_PIXEL - 1)) ?\n\t\t\t             0                                            :\n\t\t\t             pixel_part_counter + 1                       ;\n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)             \n\tpixel_part_counter <= 0;\n      else\n\tpixel_part_counter <= next_pixel_part_counter;\n   end\n   wire  pixel_count_enable;\n   assign pixel_count_enable = (BEATS_PER_PIXEL == 1)    ? \n\t\t\t       1'b1                      : \n\t\t\t       (pixel_part_counter == 0) ;\n   reg  [COLUMN_COUNTER_WIDTH-1:0] column_counter;   \n   wire [COLUMN_COUNTER_WIDTH-1:0] next_column_counter;\n   assign next_column_counter = (column_counter == (TOTAL_HSCAN_PIXELS - 1)) ? \n            \t                0                                            :\n\t                        column_counter + 1   \t\t             ;\n   wire   column_count_enable = pixel_count_enable;\n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)               \n\tcolumn_counter <= 0;\n      else begin\n\tif (sync_reset)               \n\t  column_counter <= 0;\n\telse \n\t  if (column_count_enable)    \n\t    column_counter <= next_column_counter;\n      end\n   end \n   reg  [ROW_COUNTER_WIDTH-1 : 0] row_counter;\n   wire [ROW_COUNTER_WIDTH-1 : 0] next_row_counter;\n   assign next_row_counter = (row_counter == (TOTAL_VSCAN_LINES - 1)) ? \n                              0                                       : \n\t                      row_counter + 1                         ;\n   wire row_counter_enable = column_count_enable                          && \n\t                         (column_counter == (TOTAL_HSCAN_PIXELS - 1))  ; \n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)                 \n\trow_counter <= 0;\n      else begin\n\t if (sync_reset)                \n\t   row_counter <= 0;\n\t else\n\t   if (row_counter_enable)      \n\t     row_counter <= next_row_counter;\n      end\n   end \n   wire pHD = ((column_counter >= 0) && (column_counter <= (H_SYNC_PULSE_PIXELS - 1)));\n   wire pVD = ((   row_counter >= 0) && (   row_counter <= (V_SYNC_PULSE_LINES - 1 )));\n   wire ppHD = (H_SYNC_PULSE_POLARITY == 1) ? pHD : ~pHD;\n   wire ppVD = (V_SYNC_PULSE_POLARITY == 1) ? pVD : ~pVD;\n   wire h_active = (column_counter >= H_BLANK_PIXELS              ) &&\n                   (column_counter <  H_BLANK_PIXELS + NUM_COLUMNS)  ;\n   wire v_active = (   row_counter >= V_BLANK_LINES               ) &&\n                   (   row_counter <  V_BLANK_LINES  + NUM_ROWS   )  ;\n   wire pDEN     = h_active & v_active;\n   reg \tHD;\n   reg \tVD;\n   reg \tDEN;\n   reg \t[(DATA_STREAM_BIT_WIDTH - 1):0] RGB_OUT;\n   wire output_clk = (OUTPUT_CLOCK_EDGE == 0) ? ~clk : clk;\n   always @(posedge output_clk or negedge reset_n) begin\n      if (reset_n == 0) begin\n\t HD      <= 1;\n\t VD      <= 1;\n\t DEN     <= 0;\n\t RGB_OUT <= 0;\n      end\n      else begin\n\t HD      <= ppHD;\n\t VD      <= ppVD;\n\t DEN     <= pDEN;\n\t RGB_OUT <= pRGB_OUT;\n      end\n   end\n   wire first_pixel = (column_counter == H_BLANK_PIXELS) &&\n\t              (row_counter    == V_BLANK_LINES ) &&\n\t              ((pixel_part_counter == 1) || (BEATS_PER_PIXEL == 1)) ;\n   wire stop_dataflow = (pDEN == 0)           ||\n\t                    (sop && ~first_pixel)  ;\n   assign ready = ~stop_dataflow;\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: reset_control. Module specification: The \"reset_control\" module is crafted to manage and synchronize reset signals across multiple clock domains, primarily by filtering noise and adapting reset release sequences according to domain requirements. The module receives multiple `external_rstn` reset signals, one for each external source, aimed at resetting the system securely after noise filtering. These signals are associated with `clk`, an array of clock signals matching each domain, which ensures synchronization of the reset signals to the respective clocks. The output from this module is `rstn`, an array of reset outputs providing stable and synchronized reset signals for each domain. Internally, the module utilizes `filtered_rstn` signals, which represent clean, debounced versions of each `external_rstn` input, obtained using multiple instances of a sub-module named `reset_filter`. This results in `sys_rstn`, a unified system reset signal formed by logically ANDing all `filtered_rstn` outputs, which in turn provides a combined reset condition across domains. The module employs generate blocks for applying `reset_filter` instances to both the external and system reset signals, where the first domain reset output (`rstn[0]`) is directly derived from the `sys_rstn` while subsequent domain resets can be sequenced or immediate based on a parameter `SEQUENTIAL_RELEASE`. This modular structure ensures each domain begins operation in a controlled and expected manner, promoting system-wide coherence and reliability.",
        "output": "module reset_control (\n\texternal_rstn,\n\tclk,\n\trstn\t\n);\nparameter NUM_EXTERNAL_RESETS = 3;\nparameter NUM_DOMAINS = 4;\nparameter SEQUENTIAL_RELEASE = 1'b1;\ninput [NUM_EXTERNAL_RESETS-1:0] external_rstn;\ninput [NUM_DOMAINS-1:0] clk;\noutput [NUM_DOMAINS-1:0] rstn;\ngenvar i;\nwire [NUM_EXTERNAL_RESETS-1:0] filtered_rstn;\ngenerate\nfor (i=0; i<NUM_EXTERNAL_RESETS; i=i+1)\nbegin : lp0\n  reset_filter rf_extern (\n    .enable(1'b1),\n\t.rstn_raw(external_rstn[i]),\n\t.clk(clk[0]),\n\t.rstn_filtered(filtered_rstn[i]));\nend\nendgenerate\nwire sys_rstn = &filtered_rstn;\nreset_filter rf_sys (\n    .enable(1'b1),\n\t.rstn_raw(sys_rstn),\n\t.clk(clk[0]),\n\t.rstn_filtered(rstn[0]));\ngenerate \nfor (i=1;i<NUM_DOMAINS;i=i+1)\nbegin : lp1\n    reset_filter rf_out (\n\t    .enable(SEQUENTIAL_RELEASE ? rstn[i-1] : 1'b1),\n\t    .rstn_raw(sys_rstn),\n\t    .clk(clk[i]),\n\t    .rstn_filtered(rstn[i])\n\t);\nend\nendgenerate\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: mult_control.\n\nModule specification: The 'mult_control' module is a Verilog-based digital hardware component designed to oversee a multiplier unit's multi-step computation process. It utilizes a finite state machine (FSM) to transition through states such as IDLE, LSB, MID, MSB, CALC_DONE, and ERR, depending on input signals and internal logic.\n\nThe module has the following input ports: 'clk', the clock input for synchronization; 'reset_a', an active-low reset that initializes the FSM to IDLE; 'start', a signal that triggers computation; and 'count', a 2-bit input influencing state transitions. The output ports include a 2-bit 'input_sel' that selects computation inputs, a 2-bit 'shift_sel' for the shifting operation mode, a 3-bit 'state_out' indicating the current FSM state, 'done' to signal computation completion, 'clk_ena' for clock enabling, and 'sclr_n' as an active-low synchronous clear signal.\n\nInternally, the module uses two 3-bit registers: 'state_reg', which holds the FSM's current state, and 'state_next', which stores the next state to transition to on positive clock edges. These registers ensure correct state progression based on the module's logic.\n\nThe Verilog code is organized into distinct sections, each with a specific function. The always block sensitive to the clock's positive edge and the reset signal's negative edge handles state transitions stored in 'state_reg'. Another combinational always block, sensitive to all changes, determines the 'state_next' and output port values based on conditions for each state. This includes default settings for outputs and specific logic within a case statement for each state to manage transitions and set output controls. Finally, a continuous assignment links 'state_out' directly to the 'state_reg', providing real-time state updates. \n\nOverall, the 'mult_control' module is essential in managing a stepped arithmetic operation's correct execution sequence and handling error conditions in a digital multiplier computation environment.",
        "output": "`timescale 1ns / 1ps\nmodule mult_control(\ninput clk,reset_a,start,\ninput [1:0] count,\noutput reg [1:0] input_sel,shift_sel,\noutput  [2:0] state_out,\noutput reg done,clk_ena,sclr_n\n);\nreg [2:0] state_reg,state_next;\nlocalparam IDLE=3'b000;\nlocalparam LSB=3'b001; \nlocalparam MID=3'b010; \nlocalparam MSB=3'b011; \nlocalparam CALC_DONE=3'b100; \nlocalparam ERR=3'b101; \nalways@(posedge clk,negedge reset_a)\nbegin\nif(~ reset_a)\n\tstate_reg<=IDLE;\nelse\n\tstate_reg<=state_next;\nend\nalways@(*)\nbegin\ndone = 1'b0 ;\nclk_ena = 1'b0 ;\nsclr_n = 1'b1 ;\ninput_sel = 2'bxx ;\nshift_sel =2'bxx ;\n\tcase(state_reg)\n\t\tIDLE: begin\n\t\tif(start) begin\n\t\t\tstate_next=LSB;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b0 ;\n\t\t\tend\n\t\t  else\n\t         state_next=IDLE;\n\t      end\n  \t\tLSB: begin\n  \t\tif(start==0 && count==2'b00) begin\n\t\t\tstate_next=MID;\n\t\t\tinput_sel = 2'b00 ;\n            shift_sel =2'b00 ;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\telse\n\t       state_next=ERR;\n\t    end\n\t\tMID : begin\n\t\tif(start==0 && count==2'b01) begin\n\t\t\tstate_next=MID;\n\t\t\tinput_sel = 2'b01 ;\n            shift_sel =2'b01 ;\n            clk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\t     else if(start==0 && count==2'b10) begin\n\t\t\tstate_next=MSB;\n\t\t\tinput_sel = 2'b10 ;\n            shift_sel =2'b01 ;\n            clk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\t     else\n\t\t\tstate_next=ERR;\n\t      end\n\t\tMSB:\n\t\tif(start==0 && count==2'b11) begin\n\t\t\tstate_next=CALC_DONE;\n\t\t\tinput_sel = 2'b11 ;\n            shift_sel =2'b10 ;\n            clk_ena = 1'b1 ;\n             sclr_n = 1'b1 ;\n\t\t\tend\n\t\t   else\n\t        state_next=ERR;\n \t\tCALC_DONE:\n \t\t if(start==0) begin\n\t\t\tstate_next=IDLE;\n\t\t\tdone = 1'b1 ;\n\t\t\tclk_ena = 1'b0 ;\n            sclr_n = 1'b1 ;\n\t      end\n\t\t  else\n\t        state_next=ERR;\n\t\tERR:\n\t\tif(start) begin\n\t\t\tstate_next=LSB;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b0 ;\n\t\t\tend\n\t\t   else\n\t        state_next=ERR;\n\t\tdefault:state_next=state_reg;\n\tendcase\nend\nassign state_out = state_reg ;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: m2vfbagen. \nModule specification: The 'm2vfbagen' is a Verilog module primarily designed for generating memory addresses to access video frame buffers. It uses inputs such as block type (`block`), frame context (`frame`), macroblock positions (`mbx`, `mby`), and pixel coordinates (`x2`, `y`) to dynamically compute the address. The module operates with parameters like `MEM_WIDTH`, `MBX_WIDTH`, and `MBY_WIDTH` to define the width of needed memory addresses and macroblock coordinates. The output is `addr`, which represents the formulated address with a width `MEM_WIDTH`. Internally, the module employs `REQUIRED_WIDTH` as a parameter calculated from `MBX_WIDTH`, `MBY_WIDTH`, and an additional 10 bits to manage bit calculations and address generation. The assignment of this `addr` concatenates bits from the inputs conditionally, arranging specific bits based on `frame`, `block`, and positions within the frame buffer. Additionally, if `MEM_WIDTH` exceeds `REQUIRED_WIDTH`, the module pads the higher bits of `addr` with zeros to align with the specified memory width. This approach ensures flexible, efficient memory addressing critical for video processing applications where quick and conditional access to frame buffers is essential.\n",
        "output": "module m2vfbagen #(\n\tparameter\n\tMEM_WIDTH = 21,\n\tMBX_WIDTH = 6,\n\tMBY_WIDTH = 5\n) (\n\tinput [2:0] block,\n\tinput frame,\n\tinput [(MBX_WIDTH-1):0] mbx,\n\tinput [2:0] x2,\n\tinput [(MBY_WIDTH-1):0] mby,\n\tinput [3:0] y,\n\toutput [(MEM_WIDTH-1):0] addr\n);\nlocalparam REQUIRED_WIDTH = MBX_WIDTH + MBY_WIDTH + 10;\nassign addr[(REQUIRED_WIDTH-1):0] =\n{\n\tframe,\n\tblock[2],\n\tmby,\n\tmbx,\n\ty[3:1], block[2] ? 1'b0 : y[0],\n\tx2[2:1], block[2] ? block[0] : x2[0],\n\t1'b0\n};\ngenerate\n\tif(MEM_WIDTH > REQUIRED_WIDTH)\n\t\tassign addr[(MEM_WIDTH-1):REQUIRED_WIDTH] =\n\t\t\t{(MEM_WIDTH-REQUIRED_WIDTH){1'b0}};\nendgenerate\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: AND. Module specification: The 'AND' module is designed to perform a logical AND operation on two input signals, ent1 and ent2, and outputs the result on the output port sal. The functionality of the module is straightforward, where the output sal is high (1) only when both input signals ent1 and ent2 are high (1). Besides the two binary input ports, ent1 and ent2, there is one output port, sal. The output sal reflects the result of the logical AND operation on the inputs. There are no internal signals used in this module; it utilizes a direct assignment approach to achieve the desired functionality. The Verilog code contains a single line of combinational logic that assigns the output sal based on the AND operation of ent1 and ent2, encapsulated within the module structure from 'module' to 'endmodule'. This efficient structure ensures simplicity and clarity in performing the AND operation, making it easy to integrate and maintain within larger digital systems.",
        "output": "module AND( input wire ent1,ent2,output wire sal\n    );\nassign sal=ent1&ent2;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: tb_communication_channel. Module specification: The 'tb_communication_channel' is a Verilog testbench designed for simulating a communication channel with a focus on clock signal generation and evaluating sequential operations. This module does not utilize any input or output ports, fulfilling the traditional role of a testbench that solely generates test conditions internally to examine the behavior of the design under test. Internally, the module utilizes three key signals: 'clk', a clock signal that toggles every 8 units of time to create a clock pulse; 'r', an array of registers loaded with data from \"ytest.txt\" which may represent test vectors or conditions; and 'count', an integer used as a loop counter in the simulation to display periodic messages. The code of 'tb_communication_channel' contains two primary procedural blocks: an 'always' block that perpetually generates the clock signal, and an 'initial' block that starts with displaying a simulation start message, reads data into 'r', iterates to display a \"Next\" message five times with a delay, and finally concludes the simulation with an end message and terminates the testbench execution.",
        "output": "`timescale 1ns/100ps\nmodule tb_communication_channel();\ninteger count;\n\treg clk;\n\treg r[0:13];\n\talways begin\n\t\t#8 clk = 0;\n\t\t#8 clk = 1; \n\tend\n\tinitial\n\tbegin\n\t\t$display(\" << Starting the simulation >>\");\n\t\t$readmemb(\"./ytest.txt\",r);\n\t\tfor(count=0; count<5; count = count + 1)\n\t\tbegin\n\t\t\t#5\n\t\t\t$display(\"Next\");\n\t\tend\n\t\t#20;\n\t\t$display(\" << Finishing the simulation >>\");\n\t\t$finish;\n\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: register_file. Module specification: The \"register_file\" module is a Verilog implementation intended to simulate a register file system for storing and retrieving data values. It is parameterized with \"NMBROFDATABITS\" for defining the data width and \"NMBROFADDRBITS\" for specifying the address width. The module has several input ports: 'reset' resets all registers to a default state and initializes the module to an idle state, 'clk' is the clock signal driving state transitions, 'rd_en' enables reading from a specified address, 'wr_en' enables writing to a specified address, 'wr_addr' is the write address input, 'rd_addr' is the read address input, and 'wr_data' is the data to be written to the register. The output ports include 'rd_data', which holds the data read from the register, and 'rf_data_valid', a signal that indicates whether the data on 'rd_data' is valid post a read operation. Internally, the module utilizes 'array_reg', a two-dimensional register array storing the data values, and 'statereg' which manages the current state of the module, switching between \"idle\" and \"read\" states. The state management logic is implemented within an 'always' block triggered on the positive edge of 'clk', handling resetting, data writing, reading, and state transitions based on the input signals and the internal state.",
        "output": "`timescale 1ns / 1ps\nmodule register_file\n\t\t\t\t\t#(\n\t\t\t\t\t\tparameter   NMBROFDATABITS       =    32,\n\t\t\t\t\t\t\t\t\t\tNMBROFADDRBITS   =    5 \n\t\t\t\t\t)\n\t\t\t\t\t(\n\t\t\t\t\t\tinput \t\t\t\t\t\t\t\t\t\t\t\treset,\n\t\t\t\t\t\tinput\t\t\t\t\t\t\t\t\t\t\t\t\t clk,\n\t\t\t\t\t\tinput \t\t\t\t\t\t\t\t\t\t\t\trd_en,\n\t\t\t\t\t\tinput \t\t\t\t\t\t\t\t\t\t\t\twr_en,\n\t\t\t\t\t\tinput\t \t\t[NMBROFADDRBITS-1:0]\t\t\t\t wr_addr, \n\t\t\t\t\t\tinput \t\t[NMBROFADDRBITS-1:0]\t\t\t\t\t rd_addr,\n\t\t\t\t\t\tinput \t\t[NMBROFDATABITS-1:0]\t\t\t \twr_data,\n\t\t\t\t\t\toutput reg \t[NMBROFDATABITS-1:0]\t \t\t\trd_data,\n\t\t\t\t\t\toutput reg \t\t\t\t\t\t\t\t\t\t\trf_data_valid\n\t\t\t\t\t);\t\nreg [NMBROFDATABITS-1:0]  array_reg/*[NMBROFDATABITS-1:0] */ [0:15]; \nreg statereg;\nlocalparam idle = 1'b0,\n\t\t\t\tread = 1'b1;\nalways@(posedge clk)\nbegin\n\tif(reset)  \n\t\tbegin\n\t\t\tstatereg <= idle;\n\t\t\tarray_reg[0] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[1] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[2] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[3] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[4] <= 32'hFFFFFFFF; \n\t\t\tarray_reg[5] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[6] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[7] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[8] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[9] <= 32'hFFFFFFFF;\n\t\t\tarray_reg[10] <= 32'hFFFFFFF;\n\t\t\tarray_reg[11] <= 32'hFFFFFFF;\n\t\t\tarray_reg[12] <= 32'hFFFFFFF;\n\t\t\tarray_reg[13] <= 32'hFFFFFFF;\n\t\t\tarray_reg[14] <= 32'hFFFFFFF;\n\t\t\tarray_reg[15] <= 32'hFFFFFFF;\n\t\tend\n\telse\n\t\tbegin\n\t\t\tcase(statereg)\n\t\t\t\tidle:\n\t\t\t\t\tbegin\n\t\t\t\t\t\trd_data <= 32'h0;\n\t\t\t\t\t\trf_data_valid <= 0;\n\t\t\t\t\t\tif(rd_en)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\trf_data_valid <= 1'b1;\n\t\t\t\t\t\t\t\tstatereg <= read;\n\t\t\t\t\t\t\t\tif(rd_addr < 16)\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\trd_data <= array_reg[rd_addr[3:0]];\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\trd_data <= 32'hFFFFFFFF;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif(wr_en)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(wr_addr < 16)\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\tarray_reg[wr_addr[3:0]] <= wr_data;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tread:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstatereg <= idle;\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\tendcase\n\t\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: LD.\nModule specification: The LD module is a simple latch device featuring an enable signal for data storage and retrieval. This module primarily interacts with three signals: data input (D), gate control (G), and a global set/reset (GSR). The D input captures data which is stored in the internal register 'q_out' whenever the gate signal G is asserted high, allowing the latch to update its state. The Q output reflects the value held in 'q_out', effectively outputting the current latched data. The GSR signal, connected through a global FPGA setup, caters to asynchronous resets by setting the output Q to the parameter init (INIT) state when GSR is high. The module also involves a timing specification that dictates setup and hold times, ensuring timing reliability during data latch and retrieval operations. Internal workings include an initialization block that sets 'q_out' to INIT at the start, a conditional statement block managing the logic for data latching versus resetting, and a specify block that outlines timing constraints for accurate operation in timing-sensitive environments.",
        "output": "`timescale  1 ps / 1 ps\nmodule LD (Q, D, G);\n    parameter INIT = 1'b0;\n    output Q;\n    wire Q;\n    input  D, G;\n    tri0 GSR = glbl.GSR;\n    reg q_out;\n    initial q_out = INIT;\n    assign Q = q_out;\n    always @(D or G or GSR)\n        if (GSR)\n            q_out <= INIT;\n        else\n\t     if (G)\n\t\tq_out <= D;\n    specify\n\tif (G)\n\t    (D +=> Q) = (100, 100);\n\t(posedge G => (Q +: D)) = (100, 100);\n    endspecify\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: AD9226. Module specification: The Verilog module AD9226 is designed to process 12-bit ADC data. It takes the input data `AD_data`, reverses the bit order, adds a defined offset (`CH_offset`), and outputs the processed data as `wave_CH`. The module operates with a clock input `clk_in` and provides clock output through `AD_clk` for potential external synchronization. It also includes an active-low reset input `rst_n`, which resets the internal data buffer `wave_CH_buf` to zero. The internal buffer `wave_CH_buf` is critical for temporarily holding the reversed bit order of `AD_data` before the addition of the offset to form the output `wave_CH`. The primary blocks of the code include: a parameter definition for `CH_offset`, a register declaration for `wave_CH_buf`, a sequential always block for handling the reset and bit-reversal process every positive clock edge, and continuous assignment statements that define the outputs `wave_CH` and `AD_clk`. This set-up makes the module suitable for tasks that involve the manipulation of ADC data in accordance with specific system requirements.",
        "output": "module AD9226\n(\n\tinput \t\t\tclk_in,\n\tinput \t\t\trst_n,\n\tinput   [11:0] \tAD_data,\n\toutput \t\t\tAD_clk,\n\toutput  [11:0] \twave_CH\n);\nparameter signed \tCH_offset =  27;\nreg  [11:0] \twave_CH_buf = 0;\nalways@(posedge clk_in) begin\n\tif(!rst_n)\n\t\twave_CH_buf <= 12'd0;\n\telse begin\n\t\twave_CH_buf[11] <= AD_data[0];\n\t\twave_CH_buf[10] <= AD_data[1];\n\t\twave_CH_buf[9]  <= AD_data[2];\n\t\twave_CH_buf[8]  <= AD_data[3];\n\t\twave_CH_buf[7]  <= AD_data[4];\n\t\twave_CH_buf[6]  <= AD_data[5];\n\t\twave_CH_buf[5]  <= AD_data[6];\n\t\twave_CH_buf[4]  <= AD_data[7];\n\t\twave_CH_buf[3]  <= AD_data[8];\n\t\twave_CH_buf[2]  <= AD_data[9];\n\t\twave_CH_buf[1]  <= AD_data[10];\n\t\twave_CH_buf[0]  <= AD_data[11];\n\tend\nend\nassign wave_CH = wave_CH_buf + CH_offset;\nassign AD_clk = clk_in;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Not explicitly defined in the provided code snippet.\nModule specification: The provided Verilog code does not instantiate a specific module but is designed to control the inclusion of other Verilog files based on a compilation condition set by the `GL` macro, which likely stands for \"Gate Level.\" This code snippet utilizes preprocessor directives to conditionally include either the gate-level versions (`gl/user_project_wrapper.v` and `gl/cntr_example.v`) or the behavioral versions (`user_project_wrapper.v` and `cntr_example.v`) of the files. This setup is pivotal for simulation environments, allowing the user to switch between gate-level simulation for hardware verification and a more abstract behavioral simulation for functional verification. Due to the nature of this snippet, it does not define or use any input and output ports or internal signals directly. Instead, ports and signals are presumably defined within the included files, which are conditional upon whether the simulation is run at the gate level or at another abstraction level. The snippet efficiently segments the code into blocks discriminated by the `ifdef` and `else` conditions, directing preprocessor compilation flow to adapt to different simulation needs efficaciously.",
        "output": "`include \"defines.v\"\n`define USE_POWER_PINS\n`ifdef GL\n    `default_nettype wire\n    `include \"gl/user_project_wrapper.v\"\n    `include \"gl/cntr_example.v\"\n`else\n    `include \"user_project_wrapper.v\"\n    `include \"cntr_example.v\"\n`endif"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: float2fixed.\n\nModule specification: The float2fixed module is designed for the conversion of a floating-point number, provided in the form of separate mantissa and exponent inputs, into a 13-bit fixed-point representation. The `exponent` input, a 3-bit signal, dictates the degree of bit-shift for the 6-bit `mantissa` signal during this conversion process. The resulting fixed-point value is output on the 13-bit `fixed` signal. Internally, the module employs wire definitions for `exponent` and `mantissa`, reflecting the inputs, and a 13-bit register type signal named `fixed` to hold the conversion result. The core functionality resides within an `always` block, sensitive to all input signals, containing a `case` statement that operates on the `exponent` value. The `case` statement is responsible for bit manipulation and constructing the `fixed` output based on the specified exponent value; it achieves this by shifting the `mantissa` bits and padding with mantissa's sign bit or zeros as necessary to generate the correct 13-bit output corresponding to each exponent case.",
        "output": "module float2fixed(\nmantissa,\nexponent,\nfixed);\ninput [2:0] exponent;\ninput [5:0] mantissa;        \noutput [12:0] fixed;   \nwire [5:0]  mantissa;\nwire [2:0]  exponent;\nreg  [12:0] fixed;\nalways @(*) begin\n       case({exponent})\n       3'b000: begin\n       fixed = {mantissa[5],mantissa[5],mantissa[5],mantissa,1'b0,1'b0,1'b0,1'b0};\n       end\n       3'b001: begin\n       fixed = {mantissa[5],mantissa[5],mantissa,1'b0,1'b0,1'b0,1'b0,1'b0};\n       end\n       3'b010: begin\n       fixed = {mantissa[5],mantissa,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};\n       end\n       3'b011: begin\n       fixed = {mantissa,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};\n       end\n       3'b100: begin\n       fixed = {mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5], mantissa};\n       end\n       3'b101: begin\n       fixed = {mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa,1'b0};\n       end\n       3'b110: begin\n       fixed = {mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa,1'b0,1'b0};\n       end\n       3'b111: begin\n       fixed = {mantissa[5],mantissa[5],mantissa[5],mantissa[5],mantissa,1'b0,1'b0,1'b0};\n       end\n       endcase\nend \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: Data_Memory. \nModule specification: The Data_Memory module in Verilog is designed to simulate a simple synchronous memory block with word-aligned access. This module features a memory array, RAM, made up of 64 32-bit locations, enabling storage and retrieval of 32-bit data words. It operates with three main input ports: 'clk' (clock), 'WE' (Write Enable), and 'A' (Address), along with 'WD' (Write Data). The 'clk' serves as the timing signal for write operations at positive clock edges, 'WE' controls whether the module performs a write operation, 'A' specifies the memory address for data operations using its upper 30 bits to ensure word-aligned addressing, and 'WD' provides the data to be written to the specified address. The output port 'RD' (Read Data) outputs the data stored at the memory location addressed by 'A'. Internally, the module utilizes the 'RAM' array to store data. This array is initialized at power-up with predefined values at certain addresses. In operation, if 'WE' is high, the data from 'WD' is written into the address specified by 'A' during the rising edge of 'clk'. For read operations, the data from the specified address in 'RAM' is continuously assigned to 'RD'. The module is structured with an initial block for setting up initial default values in the RAM, and a sequential always block triggered on the positive edge of the clock for handling write operations.",
        "output": "`timescale 1ns / 1ps\nmodule Data_Memory(\n\t\t   input wire \t      clk, WE,\n\t\t   input wire [31:0]  A, WD,\n\t\t   output wire [31:0] RD\n\t\t   );\n   reg [31:0] \t\t\t      RAM[63:0];\n   assign RD = RAM[A[31:2]]; \ninitial begin\n   RAM[32'h00_00_00_00]  = 32'hFACEFACE;\n   RAM[1]  = 32'h00000002; \n   RAM[2]  = 32'h00000003; \n   RAM[63] = 32'h000000063;  \nend\n   always @(posedge clk)\n     if (WE)\n       RAM[A[31:2]] <= WD;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: conv_encoder. Module specification: The `conv_encoder` Verilog module is designed for convolutional encoding, primarily used for error correction in digital communication systems. It accepts a single binary input 'b', a clock signal 'clk', and a reset signal 'reset'. The module outputs a 2-bit encoded vector 'c', which is calculated through XOR operations involving the input and internal registers. The input ports are 'b', used for the binary data to be encoded; 'clk', which synchronizes the module operations; and 'reset', which initializes internal registers to zero when active. There are three internal signals: 'D_0' and 'D_1', both of which are registers. 'D_0' captures and holds the input 'b' at each positive clock edge unless reset is active, while 'D_1' delays the value in 'D_0' by one clock cycle, effectively remembering the previous input state. The output 'c' is computed in an always block sensitive to 'D_0', 'D_1', and 'b', where 'c[0]' is the XOR of 'b', 'D_0', and 'D_1', and 'c[1]' is the XOR of 'b' and 'D_1'. The code is organized into three main always blocks: one for updating 'D_0' based on 'b', another for updating 'D_1' with 'D_0', and a final block for computing the output 'c'. These operations ensure that the encoder outputs a data stream with added redundancy, facilitating error detection and correction during transmission.",
        "output": "module conv_encoder (output [1:0] c, input b, input clk, input reset);\n\treg [1:0] c;\n\treg D_0, D_1;\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_0 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_0 <= b;\n\t\tend\n\tend\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_1 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_1 <= D_0;\n\t\tend\n\tend\n\talways @ (D_0 or D_1 or b)\n\tbegin\n\t\tc[0]  <= b^D_0^D_1;\n\t\tc[1]  <= b^D_1;\n\tend \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: sync_signal.\nModule specification: The 'sync_signal' is a specialized synchronization module that effectively delays an input signal across a specified number of clock cycles. The module is parameterized with 'WIDTH', defining the width of the input/output signal, and 'N', defining the number of clock cycles the input is delayed. It comprises of two input ports - 'clk', the clock signal that serves as a timing reference, and 'in', the signal to be synchronized of width 'WIDTH'. The module has a single output port - 'out', which outputs the synchronized signal of width 'WIDTH', effectively delayed by 'N' clock cycles. An important element of the module's functionality is the implementation of an array of registers 'sync_reg' of width 'WIDTH' and size 'N', which sequentially buffer the input signal and facilitate the delay process. The operation is initiated at the positive edge of the 'clk', triggering a cycle that assigns the input signal to the first register and propogates the value from one register to the next in the array, concluding with outputting the value from the final register. This modular system ensures precise control over the synchronization process, accommodating variation in signal width and delay cycles.",
        "output": "`resetall\n`timescale 1 ns / 1 ps\n`default_nettype none\nmodule sync_signal #(\n    parameter WIDTH=1, \n    parameter N=2 \n)(\n    input wire clk,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\nreg [WIDTH-1:0] sync_reg[N-1:0];\nassign out = sync_reg[N-1];\ninteger k;\nalways @(posedge clk) begin\n    sync_reg[0] <= in;\n    for (k = 1; k < N; k = k + 1) begin\n        sync_reg[k] <= sync_reg[k-1];\n    end\nend\nendmodule\n`resetall"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: onewire_xmit. \n\nModule specification: The 'onewire_xmit' module implements a one-wire transmitter in Verilog. The transmitter takes 'xmit_data' as its input which is synchronized with the clock signal 'clk', and generates an output 'dout' based on a state machine operation defined within the module. The internal state and timing are controlled by predefined parameters at the beginning of the module. \n\nInput ports for this module are 'rst', 'clk', and 'xmit_data'. The 'rst' signal is used to reset the module. 'clk' is a critical input that provides the timing for all the operations in the module. 'xmit_data' carries the data that will be transmitted over the one-wire interface. The module has a single output port 'dout', which presents the transmitted data as a serialized bit-stream in line with the one-wire communication protocol.\n\nInternally, the module uses signals 'OW_state', 'OW_state_next', 'dly_cnt', 'bcnt', 'xd', 'data_cnt', and 'frame_cnt'. 'OW_state' and 'OW_state_next' define the current and next states of the one-wire transmitter, while 'dly_cnt' and 'bcnt' are counters for delay and bit position respectively. 'xd' is an internal register for the current data being transmitted. 'data_cnt' counts number of successfully transmitted bits and 'frame_cnt' increments each time a complete frame of data has been sent. \n\nThe module contains two major code blocks. The first block controls how and when transitions between states occur. This block manages clocks, delays, and the required counters for bit and frame transmissions. The second block generates output based on the current state and the one-wire protocol. It also sets the next state for the object. In addition, the module includes a function 'clogb2' that calculates logarithm base 2 for timing and bit manipulation requirements. Overall, this module is a critical component in any system requiring one-wire transmission protocol functionality.",
        "output": "`timescale 1ns/100ps\nmodule onewire_xmit (rst, clk, xmit_data, dout);\nparameter CLK_FREQ   = 48000000; \nparameter DLY_TIME   = 200;      \nparameter SYNC_BITS  = 5;        \nparameter DATA_BITS  = 64;       \nparameter FRAME_FREQ = 1000;     \nparameter TPD        = 1.3;\nparameter NUM_DLY_CLKS = CLK_FREQ/1000 * DLY_TIME;\nlocalparam XS    = clogb2(DATA_BITS-1);\nlocalparam FS    = clogb2(FRAME_FREQ-1);\nlocalparam DS    = clogb2(NUM_DLY_CLKS-1);\nlocalparam Q1    = CLK_FREQ/FRAME_FREQ/DATA_BITS/4;\nlocalparam Q123  = 3*Q1;\nlocalparam Q1234 = 4*Q1;\nlocalparam LOW_TIME = 4*Q1234;\nlocalparam QS    = clogb2(LOW_TIME-1);\ninput  wire                 rst;        \ninput  wire                 clk;        \ninput  wire [DATA_BITS-1:0] xmit_data;\noutput reg                  dout;\nreg [4:0] OW_state;\nreg [4:0] OW_state_next;\nreg        [DS-1:0] dly_cnt;\nreg        [QS-1:0] bcnt;\nreg [DATA_BITS-1:0] xd;\nreg        [XS-1:0] data_cnt;\nreg        [FS-1:0] frame_cnt;\nlocalparam OW_IDLE     = 0,\n           OW_DLY      = 1,\n           OW_FRAME    = 2,\n           OW_SYNC_H   = 3,\n           OW_SYNC_L   = 4,\n           OW_LOW      = 5,\n           OW_DATA_Q1  = 6,\n           OW_DATA_Q23 = 7,\n           OW_DATA_Q4  = 8;\nalways @(posedge clk)\nbegin\n  if (OW_state != OW_DLY)\n    dly_cnt <= #TPD 1'b0;\n  else if (dly_cnt != NUM_DLY_CLKS)\n    dly_cnt <= #TPD dly_cnt + 1'b1;\n  if (OW_state == OW_FRAME)\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_SYNC_L) && (bcnt == Q1234))\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_LOW) && (bcnt == LOW_TIME))\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    bcnt <= #TPD 1'b0;\n  else\n    bcnt <= #TPD bcnt + 1'b1;\n  if (OW_state == OW_FRAME)\n    xd <= #TPD xmit_data;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    xd <= #TPD xmit_data;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    xd <= #TPD xd >> 1;\n  if ((OW_state == OW_FRAME) || (OW_state == OW_LOW))\n    data_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    data_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_SYNC_L) && (bcnt == Q1234))\n    data_cnt <= #TPD data_cnt + 1'b1;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    data_cnt <= #TPD data_cnt + 1'b1;\n  if (OW_state == OW_LOW)\n    frame_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    frame_cnt <= #TPD frame_cnt + 1'b1;\n  if (rst)\n    OW_state <= #TPD OW_IDLE;\n  else\n    OW_state <= #TPD OW_state_next;\nend\nalways @*\nbegin\n   case(OW_state)\n     OW_IDLE:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_DLY;  \n     end\n     OW_DLY:\n     begin\n       dout = 1'b0;\n       if (dly_cnt != NUM_DLY_CLKS)\n         OW_state_next = OW_DLY;\n       else\n         OW_state_next = OW_FRAME;  \n     end\n     OW_FRAME:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_SYNC_H;\n     end\n     OW_SYNC_H: \n     begin\n       dout = 1'b1;\n       if (bcnt != Q1) \n         OW_state_next = OW_SYNC_H;\n       else\n         OW_state_next = OW_SYNC_L;\n     end\n     OW_SYNC_L: \n     begin\n       dout = 1'b0;\n        if (bcnt != Q1234) \n         OW_state_next = OW_SYNC_L;\n       else if (data_cnt != (SYNC_BITS-1))\n         OW_state_next = OW_SYNC_H;\n       else\n         OW_state_next = OW_LOW;\n     end\n     OW_LOW: \n     begin\n       dout = 1'b0;\n       if (bcnt != LOW_TIME)\n         OW_state_next = OW_LOW;\n       else\n         OW_state_next = OW_DATA_Q1;\n     end\n     OW_DATA_Q1: \n     begin\n       dout = 1'b1;\n        if (bcnt != Q1) \n         OW_state_next = OW_DATA_Q1;\n       else\n         OW_state_next = OW_DATA_Q23;\n     end\n     OW_DATA_Q23: \n     begin\n       dout = xd[0];\n       if (bcnt != Q123) \n         OW_state_next = OW_DATA_Q23;\n       else\n         OW_state_next = OW_DATA_Q4;\n     end\n     OW_DATA_Q4: \n     begin\n       dout = 1'b0;\n       if (bcnt != Q1234)\n         OW_state_next = OW_DATA_Q4;   \n       else if (data_cnt != (DATA_BITS-1))\n         OW_state_next = OW_DATA_Q1;   \n       else if (frame_cnt != (FRAME_FREQ-1))\n         OW_state_next = OW_DATA_Q1;   \n       else\n         OW_state_next = OW_FRAME;     \n     end\n     default:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_IDLE;\n     end\n   endcase\nend\nfunction integer clogb2;\ninput [31:0] depth;\nbegin\n  for(clogb2=0; depth>0; clogb2=clogb2+1)\n  depth = depth >> 1;\nend\nendfunction\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: tb_pulse.\n\nModule specification: The 'tb_pulse' module is a testbench designed to verify the functionality of a synchronous pulse generator module, presumably named 'pulse', which is instantiated within the testbench as 'pulse_inst'. It simulates a clock signal with a defined period ('CYCLE'), an active-low reset sequence ('rst_n'), and an enable signal ('en') to demonstrate the pulse generator's response under different operational conditions. The input ports include a clock signal 'clk' for timing, 'rst_n' for resetting the module, and 'en' for enabling/disabling the pulse generation functionality. The output port, 'dout', is used to observe the output pulse generated by the 'pulse' module. Internal signals are used to drive the clock, reset, and enable sequences. The code is structured into blocks: a clock generator that continuously toggles the 'clk' signal, a reset sequence that initializes the system, enablement logic that asserts and deasserts the 'en' signal, and commented regions for potential future developments like file I/O or additional control logic. Each of these blocks serves to create conditions for thorough testing of the 'pulse' module within a simulation environment.",
        "output": "`timescale 1ns/1ns\nmodule\ttb_pulse;\nreg\t\t\t\tclk\t\t\t\t;\nreg\t\t\t\trst_n\t\t\t;\nreg\t\t\t\ten\t\t\t\t;\nwire\t\t\tdout\t\t\t;\nparameter\tCYCLE\t\t=\t20\t;\t\nparameter\tRUN_TIME\t=\t10000;\npulse pulse_inst(\n\t.clk\t\t\t(clk)\t\t\t,\n\t.rst_n\t\t\t(rst_n)\t\t\t,\n\t.en\t\t\t\t(en)\t\t\t,\n\t.dout\t\t\t(dout)\t\t\n);\ninitial\tbegin\n\tclk\t=\t0\t;\n\tforever#(CYCLE/2)begin\n\tclk\t=\t~clk\t;\n\tend\nend\ninitial\tbegin\t\n\t#1;\n\trst_n\t=\t0\t;\n\t#(CYCLE*10)\n\trst_n\t=\t1\t;\nend\ninteger\t\tfp_w\t;\nreg\t\t\tflag_get\t;\ninitial\tbegin\nend\ninitial begin\n\t#1;\n\ten\t=\t\t0\t;\n\t#(CYCLE*100)\t;\n\ten\t=\t\t1\t;\n\t#(CYCLE*1)\t\t;\n\ten\t=\t\t0\t;\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: FrameDecoderTB. \n\nModule specification: The FrameDecoderTB module is a testbench designed to verify the FrameDecoder's functionality, specifically ensuring it correctly handles and processes binary data. It utilizes input ports: `clk` (clock signal), `rst` (reset signal), `ena` (enable signal), `wren` (write enable signal for RAM), `iData` (data to be written to RAM), and `WriteAddr` (write address for RAM) to manage and coordinate data flow and processing status. The output ports include `done` (sample valid signal), `frame_done` (frame completion indicator), `bad_frame` (bad frame indicator), `oData` (decoded output data), `rdaddr` (read address for RAM), and `RamData` (data output from RAM). Internally, the code utilizes signals such as `i` (loop index), `samples_read` (counter for the number of processed samples), `file` (file descriptor for I/O operations), `hi` and `lo` (high and low byte data segments), and `memory` (simulated memory storage). The code itself is divided into various blocks: it initializes test parameters and file I/O operations (reading input data from a file, loading it into RAM), controls the clock signal generation, processes output data whenever the `done` signal is triggered, checks for frame completion with `frame_done`, and handles end-of-test activities including file closure. The combination of these signals and code blocks effectively simulates, processes, and evaluates the FrameDecoder's ability to manage and decode frame data.",
        "output": "`include \"RAM.v\"\n`include \"dual_port_ram.v\"\n`timescale 1ns / 100ps\n`define assert(signal, value) \\\n        if (signal !== value) begin \\\n            $display(\"ASSERTION FAILED in %m: signal != value\"); \\\n        end\nmodule FrameDecoderTB;\ninteger i;\nreg clk, rst, ena, wren;\nwire done, frame_done, bad_frame;\nwire signed [15:0] oData;\nwire [15:0] rdaddr, RamData;\nreg [15:0] WriteAddr;\nreg [15:0] iData;\nreg[15:0] memory [0:4096];\nFrameDecoder DUT (.iClock(clk),\n                     .iReset(rst),\n                     .iEnable(ena),\n                     .iUpperBits(1'b1),\n                     .oFrameDone(frame_done),\n                     .oSampleValid(done),\n                     .oSample(oData),\n                     .oBadFrame(bad_frame),\n                     .iStartAddress(16'd0),\n                     .iData(RamData),\n                     .oReadAddr(rdaddr)\n                     );\ndual_port_ram ram(.clk(clk), \n                  .data(iData),\n                  .read_addr(rdaddr), \n                  .write_addr(WriteAddr),\n                  .we(wren), \n                  .q(RamData));\n    always begin\n        #10 clk = !clk;\n    end\n    integer samples_read, file;\n    reg [7:0] hi, lo;\n    initial begin\n        clk = 0; wren = 0; rst = 1; ena = 0;\n        file = $fopen(\"fixed_o4f.frame\", \"rb\");\n        for (i = 0; i < 16000; i = i + 1) begin\n            WriteAddr = i;\n            hi = $fgetc(file);\n            lo = $fgetc(file);\n            iData = {hi[7:0], lo[7:0]};\n            wren = 1;\n            #20;\n        end\n        $fclose(file);\n        file = $fopen(\"decoded_fixed_o4f.txt\", \"w\");\n        samples_read = 0;\n        wren = 0;\n        #20;\n        #50 rst = 0; ena = 1;\n    end\n    always @(posedge clk) begin\n        if (done) begin\n            $display (\"%d\", oData);\n            $fwrite(file, \"%d\\n\", oData);\n            samples_read <= samples_read + 1;\n        end\n        if (frame_done) begin\n            $stop;\n            $fclose(file);\n        end\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: OUT. \nModule specification: The OUT module is designed primarily for data processing and control in serial data communications or handling setups. It leverages various subprocesses, including encoding, decoding, and counting based on the input signals and system clock. The input ports include RST (system reset), clk (clock input), sl_in (serial input), and shift (shift control). The output ports consist of sl_out (serial output), reg1out (21-bit output register holding user-decoded data), decoout (11-bit decoded output), counterout (boolean indicating a full count state), and reg2out (11-bit output register from user-defined processing block). Internal signals such as data_out3 (21-bit data from usr_Dec_bo), data_ouut3 (15-bit lesser significant bits of data_out3 used in Decoder_bo), decout (11-bit output of Decoder_bo), isfulll (boolean from counter_Dec_bo indicating full count), and data_out1 (15-bit output from usrpo_Dec_bo used in sl_out and reg2out) facilitate these operations. The module encompasses submodules usr_Dec_bo for the initial decoding, Decoder_bo for further processing, counter_Dec_bo for counting, and usrpo_Dec_bo for final stage transformations influenced by counter status and decoding output. These components assist in the module's complex data transformation, loading, counting, and output tasks, offering a versatile setup for serial data management based on incoming serial data and internal state conditions.",
        "output": "module OUT\n(\ninput RST,\ninput clk,\ninput sl_in,\ninput shift,\noutput sl_out,\noutput [20:0] reg1out,\noutput [10:0] decoout,\noutput counterout,\noutput [10:0] reg2out\n);\nwire [20:0]data_out3;\nwire [14:0]data_ouut3;\nusr_Dec_bo usr_Dec_bonus\n(\n .clk(clk),\n .RST(RST),\n .shift(1),\n .load(0),\n .sl_in(sl_in),\n .par_load(0),\n .data_out(data_out3)\n );\n assign reg1out =data_out3;\n assign data_ouut3=data_out3[14:0];\n wire [10:0] decout;\n Decoder_bo Decoder_bonus\n(\n .data_in(data_ouut3),\n .data_out(decout)\n);\nassign decoout =decout;\nwire isfulll;\ncounter_Dec_bo counter_Dec_bonus\n(\n  .clk(clk),\n  .en(shift),\n  .isfull(isfulll)\n);\nassign counterout =isfulll;\nwire [14:0]data_out1;\nusrpo_Dec_bo usrpo_Dec_bonus\n(\n .clk(clk),\n .RST(RST),\n .shift(shift),\n .load(isfulll),\n .sl_in(0),\n .par_load(decout),\n .data_out(data_out1)\n);\nassign reg2out =data_out1;\nassign sl_out=data_out1[0];\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: TBLOCK. Module specification: The TBLOCK module, as defined in the provided Verilog code, serves as an empty placeholder within a Verilog design, lacking defined input and output ports as well as internal signals. This module, therefore, does not perform any specific functionality apart from serving as a basic structural unit, which could potentially be expanded with functionality in future designs. Given its current state, the module neither receives any external signals nor outputs any signals to other modules or components, underscoring its role as a standalone, inert unit within a larger circuit design. The code itself is structured with `timescale` directives specifying the simulation time unit and precision as 1 picosecond / 1 picosecond, alongside `celldefine` and `endcelldefine` directives, indicating the module's treatment as a cell or a fundamental design entity in libraries. However, without any internal logic or connectivity to other components, the TBLOCK module's practical application or impact on a circuit's operation cannot be deduced from the snippet provided.",
        "output": "`timescale  1 ps / 1 ps\n`celldefine\nmodule TBLOCK ();\nendmodule\n`endcelldefine"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: spdutb. Module specification: The 'spdutb' module is designated as a testbench for the 'spd' module, simulating and verifying its functionality. This testbench employs input ports including d0 to d3 for binary data inputs, pm0 to pm3 which are 4-bit masks or configurations influencing data processing, along with `clk` for synchronization, and `reset` for initializing the module's state. The singular output port, 'out', captures computed results or status signals from 'spd'. Internally, the signals 'clk' and 'reset' play critical roles; 'clk' toggles every 5 ns to establish controlled operation timing within 'spd', and the 'reset' signal is initially driven high to assure a known start state, then toggled after 10 ns. The code structure introduces the instantiation of the 'spd' module, an always block for the clock signal, sequential initialization logic in an initial block, and debugging provisions through `$shm_open` and `$shm_probe` for signal monitoring, concluding the simulation at 330 ns with `$finish`, ensuring precise and well-monitored testing phases.",
        "output": "`timescale 1ns/10ps\n`include \"spdu.v\"\nmodule spdutb;\n    reg \td0, d1, d2, d3;\n    reg [3:0]\tpm0, pm1, pm2, pm3;\n    reg \tclk, reset;\n    wire \tout;\n    spd spd1(d0, d1, d2, d3, pm0, pm1, pm2, pm3, out, clk, reset);\n    always #5 clk = ~clk;\n    initial #330 $finish;\n    initial\n        begin\n            clk=0;\n\t    pm0=4'd1; pm1=4'd1; pm2=4'd0; pm3=4'd1;\n            d0=1'b0; d1=1'b1; d2=1'b0; d3=1'b1; \n\t    reset=1'b1;\n\t    #10;\n\t    reset=1'b0;\n\t    #10;\n        end\ninitial\n    begin\n\t$shm_open(\"spdu.shm\");\n\t$shm_probe(\"AC\");\t\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: dcache.\nModule specification: The 'dcache' module is designed to simulate a data cache system that interfaces with the main memory. It handles read and write operations, determines cache hits or misses, and manages data written back to the memory if necessary. The input ports include `clock`, `reset` for synchronizing and initializing the cache, `read`, and `write` signals to trigger read or write operations, `address` specifying the location for the operation, `writedata` which is the data to be written into the cache, and `mem_busywait` indicating if the memory is busy. Output ports are `busywait` signaling if the cache is occupied, `readdata` providing the data from a read operation, `mem_read` and `mem_write` to signal memory operations, `mem_writedata` containing data to be written to memory, `mem_readdata` as incoming data from memory, and `mem_address` specifying memory address interactions. Internally, it employs `valid_bit`, `dirty`, `hit`, `tag`, `index`, `word_selector` signals, and maintains the cache data in `cacheMem_array`. The module executes different control states (IDLE, MEM_READ, MEM_WRITE) managed by an FSM (Finite State Machine) to handle transitions based on hits, writes, and busy states of the memory. Sections in the code are dedicated to setting signals based on operations, handling data transfer between cache and main memory during hits and misses, and managing states transitions to ensure coherent operations with respect to external memory status. The initialization and reset behavior is defined within an always block triggered by the clock or reset operations. This module effectively illustrates a practical data caching mechanism interfacing a processor with the main memory.",
        "output": "`timescale 1ns/100ps\nmodule dcache (\n    clock,\n    reset,\n    read,\n    write,\n    address,\n    writedata,\n    readdata,\n    busywait,\n    mem_busywait,\n    mem_read,\n    mem_write,\n    mem_writedata,\n    mem_readdata,\n    mem_address\n);\n    input clock, reset,read,write; \n    output reg busywait; \n    input [7:0] writedata, address; \n    output reg [7:0] readdata; \n    input mem_busywait; \n    output reg mem_read; \n    output reg mem_write;\n    output reg [31:0] mem_writedata; \n    input [31:0] mem_readdata;\n    output reg [5:0] mem_address; \n    wire valid_bit, dirty, hit; \n    wire [2:0] tag, index; \n    reg [7:0] word_selector; \n    reg [36:0] cacheMem_array [7:0]; \n    assign #1 index = address[4:2];\n    assign #1 valid_bit =  cacheMem_array[address[4:2]][35];\n    assign #1 dirty = cacheMem_array[address[4:2]][36];\n    assign #1 tag = cacheMem_array[address[4:2]][34:32];\n    assign #0.9 hit = ((tag == address[7:5])&& valid_bit) ? 1'b1 : 1'b0;\n    always @ (address, hit,read,write)\n    begin\n        if(read && hit)\n        begin\n            case (address[1:0])\n                2'b00: #1 word_selector = cacheMem_array[address[4:2]][7:0];\n                2'b01: #1 word_selector = cacheMem_array[address[4:2]][15:8];\n                2'b10: #1 word_selector = cacheMem_array[address[4:2]][23:16];\n                2'b11: #1 word_selector = cacheMem_array[address[4:2]][31:24];\n            endcase\n            readdata = word_selector;\n        end\n    end\n    always @ (hit)\n    begin\n        if(write && hit)\n        begin\n            case (address[1:0])\n                2'b00: #1 cacheMem_array[address[4:2]][7:0] = writedata;\n                2'b01: #1 cacheMem_array[address[4:2]][15:8] = writedata;\n                2'b10: #1 cacheMem_array[address[4:2]][23:16] = writedata;\n                2'b11: #1 cacheMem_array[address[4:2]][31:24] = writedata;\n            endcase\n            cacheMem_array[address[4:2]][36] = 1;\n        end\n    end\n    always @ ( mem_read)\n    begin\n        if(mem_read == 0)\n        begin\n            #1\n            cacheMem_array[address[4:2]][36] = 0; \n            cacheMem_array[address[4:2]][35] = 1; \n            cacheMem_array[address[4:2]][34:32] = address[7:5]; \n            cacheMem_array[address[4:2]][31:0] = mem_readdata;\n        end\n    end\n    parameter IDLE = 3'b000, MEM_READ = 3'b001, MEM_WRITE = 3'b010;\n    reg [2:0] state, next_state;\n    always @(*)\n    begin\n        case (state)\n            IDLE:\n                if ((read || write) && !dirty && !hit)  \n                    next_state = MEM_READ;\n                else if ((read || write) && dirty && !hit)\n                    next_state = MEM_WRITE;\n                else\n                    next_state = IDLE;\n            MEM_READ:\n                if (!mem_busywait)\n                    next_state = IDLE;\n                else    \n                    next_state = MEM_READ;\n            MEM_WRITE:\n                if (!mem_busywait)\n                    next_state = MEM_READ;\n                else\n                    next_state = MEM_WRITE;\n        endcase\n    end\n    always @(*)\n    begin\n        case(state)\n            IDLE:\n            begin\n                mem_read = 0;\n                mem_write = 0;\n                mem_address = 8'dx;\n                mem_writedata = 32'dx;\n                if((read || write) && !hit) \n                    busywait = 1;\n                else\n                    busywait = 0;\n            end\n            MEM_READ: \n            begin\n                mem_read = 1;\n                mem_write = 0;\n                mem_address = {address[7:5], index};\n                mem_writedata = 32'dx;\n                busywait = 1;\n            end\n            MEM_WRITE:\n            begin\n                mem_read = 0;\n                mem_write = 1;\n                mem_address = {cacheMem_array[address[4:2]][34:32], index};\n                mem_writedata = cacheMem_array[address[4:2]][31:0];\n                busywait = 1;\n            end\n        endcase\n    end\n    integer i; \n    always @(posedge clock, reset)\n    begin\n        if(reset)\n        begin\n            state = IDLE;\n            for (i=0;i<8; i=i+1)\n            begin\n            cacheMem_array[i] = 0;\n            end\n        end\n        else\n        begin\n            state = next_state;\n        end\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: load_stream.\n\nModule specification: The load_stream module is designed to process an incoming stream of coded signals provided as a 64-bit input. It functions by shifting and masking the stream to extract at least 32-bit packets, specifically dealing with special 'FF' hex markers by inserting additional zero bits for proper alignment. The module operates synchronously with a clock signal `clk` and can be controlled by an enable signal `en` and a reset signal `reset`. \n\nThe input ports include:\n- `clk`: Clock signal for synchronization.\n- `en`: Enable signal to initiate processing.\n- `reset`: Resets internal states and outputs to their default values.\n- `codes`: 64-bit incoming stream of coded signals.\n- `len`: 7-bit value indicating the length of valid data within `codes`.\n\nThe output ports are:\n- `code_out`: Provides a 32-bit segment of the processed data.\n- `en_out`: Enable signal indicating the validity of the data in `code_out`.\n- `cod_32`: Shows the upper 32 bits of the internal code register.\n- `len_32`: Indicates the length of data remaining in the internal code register after processing.\n\nInternal signals within the module include:\n- `code_64` and `len_64`: Registers holding the current state of the processed data and its length.\n- `code_temp`, `code_temp_2`: Intermediate wires for combining incoming data with existing data.\n- `len_tmp`: Holds the combined length of current and incoming data lengths.\n- `code_tmp1` to `code_tmp4`: Intermediate wires for sequential handling of the 'FF' markers.\n- `len_1` to `len_4`: Reflects the increasing lengths after processing markers.\n- `en_1` to `en_4`: Enable signals corresponding to each stage of marker processing.\n\nThe module's code consists of several blocks:\n- The `assign` statements outside the always block are used for bit manipulation and conditional checks for 'FF' markers.\n- The `always` block responds to the rising edge of the `clk` or the falling edge of the `reset`. This block manages the overall state and updates outputs based on the incoming data and internal processing status. It also handles the enable conditions and data shifting required to output the processed 32-bit segments.\n- Continuous assignments (`assign` statements) at the end of the module link internal states to output ports for `cod_32` and `len_32`.",
        "output": "`timescale 1ns / 1ps\nmodule load_stream(clk, en, reset, codes, len, code_out, en_out,cod_32,len_32);\n    input clk;\n    input en;\n    input reset;\n    input [63:0] codes;\n    input [6:0] len;\n    output [31:0] code_out;\n    output en_out;\n    output [31:0] cod_32;\n\t output [5:0] len_32;\n\t reg [31:0] code_out;\n    reg en_out;\n\t reg [63:0] code_64;\n\t reg [6:0] len_64;\n\t wire [63:0] code_temp;\n\t wire [63:0] code_temp_2;\n\t wire [6:0] len_tmp;\nassign    #1    code_temp_2=codes>>(len_64);\t \nassign\t#1\t   code_temp=code_64|code_temp_2;\nassign\t#1\t\tlen_tmp=len_64+len;\nwire [63:0] code_tmp1,code_tmp2,code_tmp3,code_tmp4;\nwire [6:0]  len_1,len_2,len_3,len_4; \nwire en_1,en_2,en_3,en_4;\nassign #1 en_1=(len_tmp>=32)&&(code_temp[63:56]==8'hFF);\nassign #1 en_2=(len_tmp>=32)&&(code_tmp1[55:48]==8'hFF);\nassign #1 en_3=(len_tmp>=32)&&(code_tmp2[47:40]==8'hFF);\nassign #1 en_4=(len_tmp>=32)&&(code_tmp3[39:32]==8'hFF);\n   assign #1 code_tmp1=en_1?{code_temp[63:56],1'b0,code_temp[55:1]}:code_temp;\n\tassign #1 len_1    =en_1?(len_tmp+1):len_tmp;\n   assign #1 code_tmp2=en_2?{code_tmp1[63:48],1'b0,code_tmp1[47:1]}:code_tmp1;\n\tassign #1 len_2    =en_2?(len_1+1):len_1;\n\tassign #1 code_tmp3=en_3?{code_tmp2[63:40],1'b0,code_tmp2[39:1]}:code_tmp2;\n\tassign #1 len_3    =en_3?(len_2+1):len_2;\n\tassign #1 code_tmp4=en_4?{code_tmp3[63:32],1'b0,code_tmp3[31:1]}:code_tmp3;\n\tassign #1 len_4    =en_4?(len_3+1):len_3;\n\talways@(posedge clk or negedge reset)\n\t if(!reset)\n\t  begin\n\t  code_out<=0;\n\t  en_out<=0;\n\t  code_64<=0;\n\t  len_64<=0;\n\t  end\n\t else if(en)\n\t   begin\n\t\t  if(len_4>=32)\n\t\t    begin\n\t\t\t  code_64<=(code_tmp4<<32);\n\t\t     len_64<=len_4-32;\n\t\t     code_out<=code_tmp4[63:32];\n\t\t     en_out<=1;\n\t\t    end\n\t\t  else \n\t\t    begin\n\t\t\t  code_64<=code_tmp4;\n\t\t     len_64<=len_4;\n\t\t     code_out<=0;\n\t\t     en_out<=0;\n\t\t   end\n\t\tend\n\t else \n\t   begin\n\t\tcode_out<=0;\n\t   en_out<=0;\n\t   code_64<=code_64;\n\t   len_64<=len_64;\n\t\tend\n assign\tcod_32=code_64[63:32];\n assign  len_32=len_64[5:0]; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: usr_Dec_bo. Module specification: The \"usr_Dec_bo\" is a Verilog module designed for dual register data storage and manipulation, controlled by clock signals and a resetting mechanism. It supports operations like parallel loading, bit shifting, and synchronization with a central clock signal. The module accepts inputs including a clock (`clk`), reset signal (`RST`), shift control signal (`shift`), load control signal (`load`), serial input bit (`sl_in`), and parallel load data (`par_load`) of parameterizable width. It produces an output `data_out`, which also has a parameterizable width, representing the stored data from one of two internal storage registers (`storage1` or `storage2`). These registers are manipulated based on clock signal edges\u2014positive edge operations are applied to `storage1` while negative edge operations are for `storage2`. The module uses internal toggle flags (`a1`, `a2`) which decide the output source based on their XOR result. Each clock edge (positive for `a1` and negative for `a2`) toggles these flags, which are critical in defining the output data path from the registers. The `always` blocks in the code handle the logic for resetting, loading data, and shifting operations, governed by the input signals and specific conditions like the output mismatching the parallel load, ensuring precise and flexible data handling ideal for buffer storage or data manipulation tasks in digital circuits.",
        "output": "module usr_Dec_bo #( parameter width =21 )\n(input clk,\ninput RST,\ninput shift,\ninput load,\ninput sl_in,\ninput [width-1:0] par_load,\noutput [width-1:0] data_out);\nreg [width-1:0] storage1;\nreg [width-1:0] storage2;\nreg a1,a2;\nalways @(posedge clk) \n\tbegin\n\t\tif (RST)\n\t\t\tstorage1<=0;\n\t\telse if(load & (data_out != par_load))\n\t\t\tstorage1 <= par_load;\n\t\telse if(shift)\n\t\t\tstorage1 <= {sl_in, storage2[width-1:1]};\n\t\t\ta1=~a1;\n\tend\n\talways @(negedge clk) \n\tbegin\n\t\tif (RST)\n\t\t\tstorage2<=0;\n\t\telse if(load & (data_out != par_load))\n\t\t\tstorage2 <= par_load;\n\t\telse if(shift)\n\t\t\tstorage2 <= {sl_in, storage1[width-1:1]};\n\t\t\ta2=~a2;\n\tend\n\tassign data_out =(a1^a2==1) ? storage1:storage2 ;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: rx_port_channel_gate.\n\nModule specification: The `rx_port_channel_gate` module interfaces data communication between clock domains, facilitating robust data transitioning from a receiver (RX) to a channel (CHNL). It receives inputs including a reset signal (`RST`), clocks for primary and channel domains (`CLK`,`CHNL_CLK`), receiver signals (`RX`, `RX_LAST`, `RX_LEN`, `RX_OFF`) along with the actual data and its validity (`RD_DATA`, `RD_EMPTY`). Outputs from this module indicate receipt (`RX_RECVD`, `RX_ACK_RECVD`), data consumption (`RX_CONSUMED`), read enable signal (`RD_EN`), and signals transferred to the channel (`CHNL_RX`, `CHNL_RX_LAST`, `CHNL_RX_LEN`, `CHNL_RX_OFF`, `CHNL_RX_DATA`, `CHNL_RX_DATA_VALID`). Internally, it utilizes registers like `rAckd`, `rChnlRxAck`, `rConsumed`, `rConsumedStable`, for managing acknowledgment status, consumed data amount, and stable count of read data. Another set of wires (`wCountRead`, `wDataRead`) assist in the dynamic flow and counting operations. The module uses `cross_domain_signal` for clock domain transfer signals and `syncff` for synchronizing receiver acknowledgments across domains. It efficiently manages acknowledgment responses, data consumption reporting, and valid data transfer confirmation in multi-clock domain environments. Overall, this module supports dynamic data width configuration and aligns data parameters accurately across two clock domains.",
        "output": "`timescale 1ns/1ns\nmodule rx_port_channel_gate #(\n\tparameter C_DATA_WIDTH = 9'd64\n)\n(\n\tinput RST,\n\tinput CLK,\n\tinput RX,\t\t\t\t\t\t\t\t\n\toutput RX_RECVD,\t\t\t\t\t\t\n\toutput RX_ACK_RECVD,\t\t\t\t\t\n\tinput RX_LAST,\t\t\t\t\t\t\t\n\tinput [31:0] RX_LEN,\t\t\t\t\t\n\tinput [30:0] RX_OFF,\t\t\t\t\t\n\toutput [31:0] RX_CONSUMED,\t\t\t\t\n\tinput [C_DATA_WIDTH-1:0] RD_DATA,\t\t\n\tinput RD_EMPTY,\t\t\t\t\t\t\t\n\toutput RD_EN,\t\t\t\t\t\t\t\n\tinput CHNL_CLK,\t\t\t\t\t\t\t\n\toutput CHNL_RX,\t\t\t\t\t\t\t\n\tinput CHNL_RX_ACK,\t\t\t\t\t\t\n\toutput CHNL_RX_LAST,\t\t\t\t\t\n\toutput [31:0] CHNL_RX_LEN,\t\t\t\t\n\toutput [30:0] CHNL_RX_OFF,\t\t\t\t\n\toutput [C_DATA_WIDTH-1:0] CHNL_RX_DATA,\t\n\toutput CHNL_RX_DATA_VALID,\t\t\t\t\n\tinput CHNL_RX_DATA_REN\t\t\t\t\t\n);\nreg\t\t\t\t\t\t\t\trAckd=0, _rAckd=0;\nreg\t\t\t\t\t\t\t\trChnlRxAck=0, _rChnlRxAck=0;\nreg\t\t[31:0]\t\t\t\t\trConsumed=0, _rConsumed=0;\nreg\t\t[31:0]\t\t\t\t\trConsumedStable=0, _rConsumedStable=0;\nreg\t\t[31:0]\t\t\t\t\trConsumedSample=0, _rConsumedSample=0;\nreg\t\t\t\t\t\t\t\trCountRead=0, _rCountRead=0;\nwire\t\t\t\t\t\t\twCountRead;\nwire\t\t\t\t\t\t\twCountStable;\nwire\t\t\t\t\t\t\twDataRead = (CHNL_RX_DATA_REN & CHNL_RX_DATA_VALID);\nassign RX_CONSUMED = rConsumedSample;\nassign RD_EN = CHNL_RX_DATA_REN;\nassign CHNL_RX_LAST = RX_LAST;\nassign CHNL_RX_LEN = RX_LEN;\nassign CHNL_RX_OFF = RX_OFF;\nassign CHNL_RX_DATA = RD_DATA;\nassign CHNL_RX_DATA_VALID = !RD_EMPTY;\nalways @ (posedge CHNL_CLK) begin\n\trChnlRxAck <= #1 (RST ? 1'd0 : _rChnlRxAck);\nend\nalways @ (*) begin\n\t_rChnlRxAck = CHNL_RX_ACK;\nend\ncross_domain_signal rxSig (\n\t.CLK_A(CLK), \n\t.CLK_A_SEND(RX), \n\t.CLK_A_RECV(RX_RECVD), \n\t.CLK_B(CHNL_CLK), \n\t.CLK_B_RECV(CHNL_RX), \n\t.CLK_B_SEND(CHNL_RX)\n);\nsyncff rxAckSig (.CLK(CLK), .IN_ASYNC(rAckd), .OUT_SYNC(RX_ACK_RECVD));\nalways @ (posedge CHNL_CLK) begin\n\trAckd <= #1 (RST ? 1'd0 : _rAckd);\nend\nalways @ (*) begin\n\t_rAckd = (CHNL_RX & (rAckd | rChnlRxAck));\nend\nalways @ (posedge CHNL_CLK) begin\n\trConsumed <= #1 _rConsumed;\n\trConsumedStable <= #1 _rConsumedStable;\n\trCountRead <= #1 (RST ? 1'd0 : _rCountRead);\nend\nalways @ (*) begin\n\t_rConsumed = (!CHNL_RX ? 0 : rConsumed + (wDataRead*(C_DATA_WIDTH/32)));\n\t_rConsumedStable = (wCountRead | rCountRead ? rConsumedStable : rConsumed);\n\t_rCountRead = !wCountRead;\nend\nalways @ (posedge CLK) begin\n\trConsumedSample <= #1 _rConsumedSample;\nend\nalways @ (*) begin\n\t_rConsumedSample = (wCountStable ? rConsumedStable : rConsumedSample);\nend\ncross_domain_signal countSync (\n\t.CLK_A(CHNL_CLK), \n\t.CLK_A_SEND(rCountRead), \n\t.CLK_A_RECV(wCountRead), \n\t.CLK_B(CLK), \n\t.CLK_B_RECV(wCountStable), \n\t.CLK_B_SEND(wCountStable)\n);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: vdcmul_16b. \nModule specification: The vdcmul_16b is a Verilog module designed to perform a 16-bit by 16-bit binary multiplication, producing a 32-bit output product. It accepts two input ports, `x` and `y`, both of which are 16-bit numbers meant to be multiplied. These inputs are systematically broken down and processed to create a single 32-bit output through the output port `prod`. The module utilizes internal signals such as `pp1` to `pp4` for storing the partial products computed by separate instances of 8-bit multipliers, `sum1` to `sum3` for holding intermediate sums calculated using 16-bit Ripple Carry Adders (RCAs), and `c1` to `c3`, `s1`, and `ca1` for managing the carries during the summation processes. Specifically, `c1` to `c3` are carry outputs from the RCAs, `s1` and `ca1` are outputs from a half-adder that manages the sum of carry outputs `c1` and `c2`. The module architecture features four instances of an 8-bit multiplier (`vdcmul_8b`) for generating the partial products. These products are then added together using three instances of the 16-bit RCA (`rca16b`) and a half-adder (`half_adder`) to ensure the carry bits are managed appropriately. The final product `prod` is assembled by combining `sum3`, the low 8 bits of `sum2`, and the lowest 8 bits of `pp1` into a 32-bit word. This structured and systematic approach to multiplication simplifies the complex process of binary multiplication into manageable components, leveraging modular code and internal hierarchy.",
        "output": "`include \"../src/rca16b.v\"\n`include \"../src/half_adder.v\"\nmodule vdcmul_16b(\n                   x,\n                   y,\n                   prod\n                   );\ninput [15:0] x, y;\noutput [31:0] prod;\nwire [15:0] pp1, pp2, pp3, pp4;\nwire c1, c2, c3,s1,ca1;\nwire [15:0] sum1, sum2 ,sum3;\nvdcmul_8b v81(x[7:0], y[7:0], pp1);\nvdcmul_8b v82(x[7:0], y[15:8], pp2);\nvdcmul_8b v83(x[15:8], y[7:0], pp3);\nvdcmul_8b v84(x[15:8], y[15:8], pp4);\nrca16b r161(pp2, pp3, 1'b0, c1, sum1);\nrca16b r162(sum1, {8'b0, pp1[15:8]}, 1'b0, c2, sum2);\nhalf_adder h1(c1,c2,s1,ca1);\nrca16b r163(pp4, {6'b0, ca1,s1, sum2[15:8]}, 1'b0, c3, sum3);\nassign prod = {sum3, sum2[7:0], pp1[7:0]};\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: OBUF_LVCMOS25_S_12. Module specification: The OBUF_LVCMOS25_S_12 is a Verilog module designed to function as an output buffer that regulates the signal flow based on a global tri-state control. Its primary functionality is to pass an input signal (I) through to the output (O) unless a global tri-state signal (GTS) is activated, in which case the output transitions to a high impedance state to prevent signal contention or unwanted power consumption. The module has two ports: 'I', an input port that receives the signal to be buffered, and 'O', an output port that either transmits the input signal or goes to a tri-state, depending on GTS. Internally, the module utilizes 'GTS', a tri0 type signal derived from an external source (glbl.GTS), which controls the state of the output buffer\u2014active or high impedance. The main block in the code, 'bufif0 B1 (O, I, GTS)', implements this buffering mechanism, conditionally connecting the input 'I' to the output 'O' based on the status of 'GTS'. This setup ensures effective signal management in systems with potential output line sharing among multiple devices.",
        "output": "`timescale  1 ps / 1 ps\nmodule OBUF_LVCMOS25_S_12 (O, I);\n    output O;\n    input  I;\n    tri0 GTS = glbl.GTS;\n    bufif0 B1 (O, I, GTS);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: sync_signal. \n\nModule specification: The `sync_signal` is a specialized hardware module designed for signal synchronization, mitigating any potential metastability issues in digital systems. The module utilizes a clock signal ('clk') and captures an input signal ('in') at each rising edge of the clock, moving the captured data through a chain of flip-flops, thereby synchronizing it with the clock. \n\nThe input ports include 'clk', acting as the timing control, and 'in', functioning as the data that needs synchronization. The 'clk' signal controls the synchronizing operation of the module and 'in' is a wire with a width determined by the parameter 'WIDTH'. \n\nThe module has one output port, 'out', serving as the synchronized version of the 'in' signal. The data is passed through the chain of registers (sync_reg) and finally to 'out'. \n\nThe module uses 'sync_reg', an array of registers, as an internal signal for signal synchronization. The width of each element in the 'sync_reg' array is defined by 'WIDTH' and the number of elements, or the depth of synchronization, is determined by another parameter 'N'. \n\nThe Verilog code for the module is divided into sections that each have specific functions. The parameters are declared at the beginning. This is followed by the declaration of input and output ports and internal signals. Then, the output is assigned the last element of the 'sync_reg' array. The main logic is placed inside an \"always\" block, where the first register in 'sync_reg' captures the 'in' data at the rising edge of the 'clk' signal and data is subsequently pushed to the next register at each consecutive clock cycle.",
        "output": "`resetall\n`timescale 1 ns / 1 ps\n`default_nettype none\nmodule sync_signal #(\n    parameter WIDTH=1, \n    parameter N=2 \n)(\n    input wire clk,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\nreg [WIDTH-1:0] sync_reg[N-1:0];\nassign out = sync_reg[N-1];\ninteger k;\nalways @(posedge clk) begin\n    sync_reg[0] <= in;\n    for (k = 1; k < N; k = k + 1) begin\n        sync_reg[k] <= sync_reg[k-1];\n    end\nend\nendmodule\n`resetall"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: cnt25. \nModule specification: The 'cnt25' module is designed for clock division, generating an output clock ('clkdiv25') with a frequency that is 1/25th of the input clock frequency. The module takes three input ports: 'reset', 'clk', and 'enable'. 'reset' is used to reset the counter to 0, restarting the clock division process. 'clk' is the main clock input which, upon each rising edge, will trigger the counter to increment if 'enable' is high. 'enable' controls whether the counter increments or remains static. The single output port, 'clkdiv25', indicates that one cycle of the divided frequency is complete and is asserted high when the counter value reaches 24. Internally, the module utilizes a 6-bit register 'cnt' as the counter. This counter increments upon each 'clk' pulse if 'enable' is active and resets when either 'reset' is triggered or the counter value is 24. The primary sections of the code involve the assignment of 'clkdiv25' based directly on the counter value and an always block that handles the counter increment and reset logic effectively. This always block checks for the rising edge of 'reset' or 'clk', resetting the counter to 0 if 'reset' is high, and otherwise incrementing the counter on the 'clk' rising edge if 'enable' is high and resetting when necessary.",
        "output": "module cnt25 (reset, clk, enable, clkdiv25);\ninput reset, clk, enable;\noutput clkdiv25;\nreg [5:0] cnt;\nassign clkdiv25 =(cnt==5'd24);\nalways @(posedge reset or posedge clk)\n  if (reset) cnt <= 0;\n   else if (enable) \n          if (clkdiv25) cnt <= 0;\n            else cnt <= cnt + 1;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: crypt_TestBench. \n\nModule specification: The crypt_TestBench module serves as a testing framework specifically tailored for the 'crypt' module. It is designed to stimulate the 'crypt' module with a selection of test cases and subsequently verify the output. The module does not have any internal signals, it purely acts as a test bench for the 'crypt' module.\n\nThe module's inputs include 'enable', an activation signal for the 'crypt' module; 'q_in', an 8-bit data input to be encrypted or decrypted; 'key_1' and 'key_2', two 8-bit keys for the encryption or decryption process. These input signals are of the reg data type.\n\nOutputs of the crypt_TestBench module include 'cipher', an 8-bit output holding the result of the encryption or decryption process, and 'debug', a 4-bit output used to debug the 'crypt' module or provide extraneous information about the module's current state. Both are of the wire data type.\n\nThe module follows a series of test case scenarios, each comprising a unique 'q_in', 'key_1', and 'key_2' triplet. Upon providing the 'q_in' and keys, the 'enable' signal is activated until the expected cipher is achieved or the failure is noted accordingly. The entire testing procedure is signaled as completed after the final test case's result is displayed. This testing process ensures effective operation of the 'crypt' module under a multitude of varying conditions.",
        "output": "module crypt_TestBench; \nreg \tenable; \nreg\t\t[7:0] q_in; \nreg\t\t[7:0] key_1; \nreg\t\t[7:0] key_2; \nwire\t[7:0] cipher; \nwire\t[3:0] debug; \ncrypt uut (\n\t.enable(enable),\n\t.q_in(q_in),\n\t.key_1(key_1),\n\t.key_2(key_2),\n\t.cipher(cipher),\n\t.debug(debug));\ninitial \n\tbegin\n$display(\"Commencing test procedure...\");\nenable = 0; #50; enable = 1; #50; \n\tenable = 0; q_in = 8'b11110000; \t\t\t\n\tkey_1 = 8'b11100100; key_2 = 8'b01010011; \n\t#50; \n\tif(cipher != 8'b01011001) $display(\"ERROR: cipher does not match in case 1!\"); \n\telse  $display(\"PASS: case 1!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10101010; \t\t\t\n\tkey_1 = 8'b11100100; key_2 = 8'b01010011; \n\t#50; \n\tif(cipher != 8'b01101011) $display(\"ERROR: cipher does not match in case 2!\"); \n\telse  $display(\"PASS: case 2!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b11111110; \t\t\t\n\tkey_1 = 8'b11011111; key_2 = 8'b11111001; \n\t#50; \n\tif(cipher != 8'b11100110) $display(\"ERROR: cipher does not match in case 3!\"); \n\telse  $display(\"PASS: case 3!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b01111111; \t\t\t\n\tkey_1 = 8'b11111001; key_2 = 8'b11011111; \n\t#50; \n\tif(cipher != 8'b00000000) $display(\"ERROR: cipher does not match in case 4!\"); \n\telse  $display(\"PASS: case 4!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10011001; \t\t\t\n\tkey_1 = 8'b10010100; key_2 = 8'b01010101; \n\t#50; \n\tif(cipher != 8'b00111100) $display(\"ERROR: cipher does not match in case 5!\"); \n\telse  $display(\"PASS: case 5!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10101010; \t\t\t\n\tkey_1 = 8'b01010101; key_2 = 8'b10010100; \n\t#50; \n\tif(cipher != 8'b01111010) $display(\"ERROR: cipher does not match in case 6!\"); \n\telse  $display(\"PASS: case 6!\"); \n$display(\"Testing procedure completed!\");\n\tend\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: RAM. Module specification: The RAM module is designed to simulate a simple synchronous RAM behavior in Verilog. The module uses a clock signal 'clk' to synchronize data transfer, leveraging positive clock edges for data operations. It features input ports including 'clk', 'read_address', 'write_address', 'write', and 'din'. 'clk' is used to synchronize the operations, 'read_address' and 'write_address' determine the memory addresses for reading and writing data. The 'write' signal enables data writing when high, and 'din' carries the input data to be written. The lone output port 'dout' reflects data from the specified memory address at 'read_address'. Internally, the module utilizes a register array 'mem' to represent memory, storing data based on 'data_width' and addressable by '2**addr_width', and a register 'dout' to provide output data. The module initializes 'mem' with contents from the file defined by 'filename' and executes writing or reading based on control signal and read/write addresses during each clock edge. This structured and parameterizable design allows for specific RAM configurations and operations consistent with typical synchronous RAM functionalities in digital systems.",
        "output": "module RAM(clk,read_address,write_address,write,din,dout);\n  parameter data_width = 32; \n  parameter addr_width = 4;\n  parameter filename = \"data.txt\";\n  input clk;\n  input [addr_width-1:0] read_address, write_address;\n  input write;\n  input [data_width-1:0] din;\n  output [data_width-1:0] dout;\n  reg [data_width-1:0] dout;\n  reg [data_width-1:0] mem [2**addr_width-1:0];\n  initial $readmemb(filename, mem);\n  always @ (posedge clk) begin\n    if (write)\n      mem[write_address] <= din;\n    dout <= mem[read_address]; \n  end \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: VGA_Ctrl.\nModule specification: The VGA_Ctrl module is designed to control a VGA display by generating necessary signals, including synchronization, pixel clocks, and RGB outputs. It inputs RGB color values (iRed, iGreen, iBlue) and outputs corresponding VGA signals (oVGA_R, oVGA_G, oVGA_B) to drive the display. Additional outputs include current X and Y coordinates (oCurrent_X, oCurrent_Y), frame memory address (oAddress), and request signal for pixel data (oRequest). The module operates based on the input clock (iCLK) and can be reset via an active-low reset signal (iRST_N). Internally, the module uses horizontal (H_Cont) and vertical (V_Cont) counters to manage the timing and positioning of pixels on the screen, which in turn helps in generating horizontal (oVGA_HS) and vertical (oVGA_VS) synchronization signals. It includes several parameters defining the dimensions and timings of the display raster, crucial for the accurate generation of outputs adjusting to VGA standards. The module involves conditional logics within two always blocks that manage the increment and reset operations for counters based on the clock and reset signals, crucial for controlling H_Cont and V_Cont's progression across their respective ranges. Additional assignments determine oVGA_SYNC, oVGA_BLANK (indicating blanking periods), oVGA_CLOCK (pixel clock), and direct mapping of input RGB values to outputs. This structured approach enables precise control over the VGA interface, ensuring proper display timings and color output.",
        "output": "module\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t);\ninput\t\t[9:0]\tiRed;\ninput\t\t[9:0]\tiGreen;\ninput\t\t[9:0]\tiBlue;\noutput\t\t[21:0]\toAddress;\noutput\t\t[10:0]\toCurrent_X;\noutput\t\t[10:0]\toCurrent_Y;\noutput\t\t\t\toRequest;\noutput\t\t[9:0]\toVGA_R;\noutput\t\t[9:0]\toVGA_G;\noutput\t\t[9:0]\toVGA_B;\noutput\treg\t\t\toVGA_HS;\noutput\treg\t\t\toVGA_VS;\noutput\t\t\t\toVGA_SYNC;\noutput\t\t\t\toVGA_BLANK;\noutput\t\t\t\toVGA_CLOCK;\ninput\t\t\t\tiCLK;\ninput\t\t\t\tiRST_N;\t\nreg\t\t\t[10:0]\tH_Cont;\nreg\t\t\t[10:0]\tV_Cont;\nparameter\tH_FRONT\t=\t16;\nparameter\tH_SYNC\t=\t96;\nparameter\tH_BACK\t=\t48;\nparameter\tH_ACT\t=\t640;\nparameter\tH_BLANK\t=\tH_FRONT+H_SYNC+H_BACK;\nparameter\tH_TOTAL\t=\tH_FRONT+H_SYNC+H_BACK+H_ACT;\nparameter\tV_FRONT\t=\t11;\nparameter\tV_SYNC\t=\t2;\nparameter\tV_BACK\t=\t31;\nparameter\tV_ACT\t=\t480;\nparameter\tV_BLANK\t=\tV_FRONT+V_SYNC+V_BACK;\nparameter\tV_TOTAL\t=\tV_FRONT+V_SYNC+V_BACK+V_ACT;\nassign\toVGA_SYNC\t=\t1'b1;\t\t\t\nassign\toVGA_BLANK\t=\t~((H_Cont<H_BLANK)||(V_Cont<V_BLANK));\nassign\toVGA_CLOCK\t=\t~iCLK;\nassign\toVGA_R\t\t=\tiRed;\nassign\toVGA_G\t\t=\tiGreen;\nassign\toVGA_B\t\t=\tiBlue;\nassign\toAddress\t=\toCurrent_Y*H_ACT+oCurrent_X;\nassign\toRequest\t=\t((H_Cont>=H_BLANK && H_Cont<H_TOTAL)\t&&\n\t\t\t\t\t\t (V_Cont>=V_BLANK && V_Cont<V_TOTAL));\nassign\toCurrent_X\t=\t(H_Cont>=H_BLANK)\t?\tH_Cont-H_BLANK\t:\t11'h0\t;\nassign\toCurrent_Y\t=\t(V_Cont>=V_BLANK)\t?\tV_Cont-V_BLANK\t:\t11'h0\t;\nalways@(posedge iCLK or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tH_Cont\t\t<=\t0;\n\t\toVGA_HS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(H_Cont<H_TOTAL)\n\t\tH_Cont\t<=\tH_Cont+1'b1;\n\t\telse\n\t\tH_Cont\t<=\t0;\n\t\tif(H_Cont==H_FRONT-1)\t\t\t\n\t\toVGA_HS\t<=\t1'b0;\n\t\tif(H_Cont==H_FRONT+H_SYNC-1)\t\n\t\toVGA_HS\t<=\t1'b1;\n\tend\nend\nalways@(posedge oVGA_HS or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tV_Cont\t\t<=\t0;\n\t\toVGA_VS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(V_Cont<V_TOTAL)\n\t\tV_Cont\t<=\tV_Cont+1'b1;\n\t\telse\n\t\tV_Cont\t<=\t0;\n\t\tif(V_Cont==V_FRONT-1)\t\t\t\n\t\toVGA_VS\t<=\t1'b0;\n\t\tif(V_Cont==V_FRONT+V_SYNC-1)\t\n\t\toVGA_VS\t<=\t1'b1;\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: test. \n\nModule specification: The 'test' module serves as a testbench for the TRIGB module, implementing a clock signal and initializing several registers to default values. It also provides scan chain featuers which are important for IC testing. \n\nThe test module takes in several input signals: 'clk' for clock synchronization, 'reset' for resetting internal states, 'scan_in0' to 'scan_in4' for scan chain input data, 'scan_enable' for enabling scan testing, 'test_mode' for activating a test state, 'TR', a register used by TRIGB, and 'AnP', a 16-bit input register. Output ports include 'scan_out0' to 'scan_out4' which output the results of the scan chain testing, and 'AnR', a 16-bit output wire likely used for feedback or status indication. \n\nInternal signals include several wire and register types. The 'scan_out0' to 'scan_out4' wires are utilized as TRIGB module output signals, providing scan chain test results. The 'clk' register generates clock timing; 'reset' is used for resetting testbench variables to default. Similar to input signals, 'scan_in0' to 'scan_in4' registers are used as scan chain test inputs. 'scan_enable' enables or disables scan testing mode; 'test_mode' switches between testing and regular states. The 'TR' and 'AnP' signals feed into the TRIGB module. 'AnR' provides 16-bit feedback status output from TRIGB.\n\nThe code is categorized into a few significant sections. The signal definition block defines input and output ports, along with the clock period constant. The TRIGB instance declaration block initializes the TRIGB module with aforementioned signals. The 'always' block is continuously generating the clock signal. The 'initial' block defines the initial states of the signals, annotates SDF for TRIGB if applicable, and trigger the finish of the simulation. This specification ensures a comprehensive understanding of the module's operation.",
        "output": "`define CLK_PERIOD 20 \nmodule test;\nwire scan_out0, scan_out1, scan_out2, scan_out3, scan_out4;\nreg clk, reset;\nreg scan_in0, scan_in1, scan_in2, scan_in3, scan_in4, scan_enable, test_mode;\nreg         TR;\nreg  [15:0] AnP;\nwire [15:0] AnR; \nTRIGB top (\n  .reset(reset),\n  .clk(clk),\n  .scan_in0(scan_in0),\n  .scan_in1(scan_in1),\n  .scan_in2(scan_in2),\n  .scan_in3(scan_in3),\n  .scan_in4(scan_in4),\n  .scan_enable(scan_enable),\n  .test_mode(test_mode),\n  .TR(TR),\n  .AnP(AnP),\n  .scan_out0(scan_out0),\n  .scan_out1(scan_out1),\n  .scan_out2(scan_out2),\n  .scan_out3(scan_out3),\n  .scan_out4(scan_out4),\n  .AnR(AnR)\n);\nalways #(`CLK_PERIOD/2) clk = ~clk;\ninitial begin\n  $timeformat(-9,2,\"ns\", 16);\n`ifdef SDFSCAN\n  $sdf_annotate(\"sdf/TRIGB_tsmc18_scan.sdf\", test.top);\n`endif\n  clk         = 1'b0;\n  reset       = 1'b0;\n  scan_in0    = 1'b0;\n  scan_in1    = 1'b0;\n  scan_in2    = 1'b0;\n  scan_in3    = 1'b0;\n  scan_in4    = 1'b0;\n  scan_enable = 1'b0;\n  test_mode   = 1'b0;\n  $finish;\nend \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: dout_monitor. Module specification: The \"dout_monitor\" module, designed in Verilog, is primarily tasked with monitoring a sample clock signal and incrementally updating an address based on specific conditions. The module operates synchronized to a main clock (`clk`) and monitors `sample_clk` for a rising edge to increment an address (`addr`). The inputs include the main clock (`clk`), an active-low asynchronous reset (`rst_n`), two data inputs (`d_ch0` and `d_ch1`) which are not actively used in the current logic, and the `sample_clk` which triggers the address increment. The only output from the module is `addr`, which holds the updated address value. Internally, the module employs a register (`sample_clk_t`) to store the previous state of `sample_clk`, facilitating the detection of rising edges on this signal when comparing it to its current state. The code consists of two main always blocks: one for updating the `sample_clk_t` register at every positive edge of `clk`, and another for resetting or incrementing the address register based on the reset signal and the state of `sample_clk`. When `rst_n` is asserted low, `addr` is initialized to 448 (in 10-bit). Conversely, `addr` increments by 1 on the detection of a rising edge from `sample_clk`. This module encapsulates the typical functionality found in clock-driven digital systems where signal transitions dictate operational behavior.",
        "output": "`include \"defines.v\"\nmodule dout_monitor(\ninput clk,rst_n,\noutput reg [`ADDRESS_WIDTH-1:0] addr,\ninput [`DATA_WIDTH-1:0] d_ch0,\ninput [`DATA_WIDTH-1:0] d_ch1,\ninput sample_clk\n);\nreg sample_clk_t;\nalways @(posedge clk)\nbegin\n\tsample_clk_t<=sample_clk;\nend\nalways @(posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\taddr<=10'd448;\n\tend else begin\n\t\tif (sample_clk_t == 1'b0 && sample_clk == 1'b1)\n\t\tbegin\n\t\t\taddr <= addr + 10'd1;\n\t\tend\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: alu. Module specification: The 'alu' module is a Verilog-based Arithmetic Logic Unit (ALU) designed to perform various arithmetic and bitwise operations on two 16-bit inputs, operandA and operandB. These operations are determined by a 4-bit operation code (oper). The module inputs include `clk` (clock signal), `alu_en` (enable signal), `operandA` (first operand), `operandB` (second operand), and `oper` (operation code). The sole output is `q`, a 16-bit output that holds the result of the executed operation. If the operation code is unrecognized or invalid, the output `q` is set to zero. Internally, the ALU's operation is triggered by the rising edge of the clock signal and only executes when `alu_en` is high, ensuring operations are carried out only under correct conditions. The module uses a case statement within an always block (sensitive to the positive edge of `clk`) that checks `alu_en` and`oper` to decide and execute the corresponding operation, such as addition, subtraction, bitwise operations (AND, OR, XOR, NOT), shifts (left and right), and rotations (left and right), or multiplies the operands. There are no explicitly defined internal signals beyond the inputs and outputs; all operations and decision logic occur within the conditional always block, providing direct, efficient data flow and processing within the module.",
        "output": "`default_nettype none\nmodule alu(input wire clk, \n           input alu_en,\n           input [15:0] operandA, \n           input [15:0]operandB, \n           input [3:0] oper, \n           output [15:0] q);\n    always @(posedge clk) begin\n        if (alu_en) begin\n            case(oper)\n            1: q <= operandB + operandA; \n            2: q <= operandB - operandA; \n            3: q <= operandB & operandA; \n            4: q <= operandB | operandA; \n            5: q <= operandB ^ operandA; \n            6: q <= operandA >> operandB; \n            7: q <= operandA << operandB; \n            8: begin \n                q[15] <= operandA[0];\n                q[14:0] <= operandA[15:1];\n            end\n            9: begin \n                q[0] <= operandA[15];\n                q[15:1] <= operandA[14:1];\n            end\n            10: q <= ~operandA; \n            11: q <= operandA * operandB;\n            default: q <= 0;\n            endcase\n        end\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "I'm sorry for any confusion, but the given code sample only contains a timescale directive. This doesn't provide us with the details needed to create a complete specification, as it doesn't have any indication on a module name, module functionality, or any input/output ports and internal signal details. \n\nThe timescale directive specifies the unit of time in which simulation time is measured (1ns in this case) and the precision to which the delay times in the design are rounded off (also 1ns). Unfortunately, without further Verilog code, additional specifications cannot be provided.\n\nPlease provide a complete Verilog module code with inline comments for further discussion.",
        "output": "`timescale 1ns / 1ns"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: decoder_top_lly. Module specification: The 'decoder_top_lly' is a Verilog module responsible for decoding data by interfacing with a sub-module named 'turbo_top'. It uses dual clocks, 'clk' for general operations and 'clk_dp' for data processing, to control the timing of data decoding and internal state updates. Inputs include 'clk', 'clk_dp', 'data_in', and 'rst', where 'data_in' represents encoded input data, and 'rst' is a reset signal for initializing the module's state. The outputs are 'data_out', the decoded data, and 'we_decode', a control signal indicating the status of the decoding process. Internally, the module utilizes registers such as 'data_in_chan' to hold input data temporarily, and 'addr_in_chan' to address internal memory for reading or writing. Counters and control flags like 'we_chan' and 'rst_turbo' are essential for managing data flow and interfacing correctly with the 'turbo_top' module. The code includes blocks handling clock-driven data manipulation, temporary data storage, counter-based signal and address management, and memory access through a 'dist_mem_gen_0' module, alongside the primary decoding process conducted in 'turbo_top'. The module effectively incorporates memory and sub-module operations to facilitate robust and efficient data decoding suitable for applications needing synchronous and controlled data processing.",
        "output": "`define CODELENGTH 256\n`define DATALENGTH 64\n`define ADDRLENGTH 9\n`timescale 1ns / 1ps\nmodule decoder_top_lly(\n     \t           clk, \n\t\t\t\t\t  clk_dp,\n\t\t           data_in,\n\t\t           data_out, \n\t\t           rst,\n\t\t           we_decode\n    );\n\t input           clk; \n\t input           clk_dp;\n\t input           data_in;\n\t output          data_out; \n\t input           rst;\n\t output          we_decode;\n\t wire clk;\n\t wire clk_dp;\n    wire rst;\n\t wire [`DATALENGTH-1:0]data_in;\n\t wire [`DATALENGTH-1:0]data_out;\n\t wire we_decode;\n    (* keep=\"true\" *)reg [47:0] data_in_chan;\n    (* keep=\"true\" *)wire [47:0] data_out_chan;\n    (* keep=\"true\" *)reg [`ADDRLENGTH-1:0] addr_in_chan;\n\t reg we_chan;\n    reg enable;\n\t (* keep=\"true\" *)reg rst_turbo;\n\t reg [47:0]data_in_turbo;\n\t wire [`ADDRLENGTH-1:0]addr_out_turbo;\n\t wire [`DATALENGTH-1:0]data_out_turbo;\n    (* keep=\"true\" *)reg [20:0]counter;\n\t always@(posedge clk_dp)\n\t begin\n\t\tif(!rst)\n\t\t\tbegin\n\t\t\t   counter <= 0; \n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcounter <= counter + 1; \n\t\t\tend\n\t end\n    dist_mem_gen_0 channel_output(\n              .clk(clk_dp),\n              .i_ce(1'b1),\n              .we(we_chan),\n              .a(addr_in_chan),\n              .d(data_in_chan),\n              .spo(data_out_chan)\n              );\n    always@(posedge clk_dp)\n\t begin\n\t\tif(!rst)\n\t\t\tbegin\t\t\t   \n\t\t\t\tdata_in_chan <= data_in[47:0];\n\t\t\tend\n\t\telse if(counter<263)\n\t\t\tbegin\n\t\t\t\tdata_in_chan <= data_in[47:0];\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\tend\n\t end\n   always@(posedge clk_dp)\n\t begin\n\t  if(counter==1)\n\t   begin\n\t\t\taddr_in_chan <= 0;\n\t\tend\n\t  else if(counter<263)\n\t   begin\n\t\t\taddr_in_chan <= addr_in_chan + 1;\n\t\tend\n\t  else \n\t\tbegin\n\t\t\taddr_in_chan <= addr_out_turbo;\n\t\tend\n    end\t \n\t always@(posedge clk_dp)\n\t begin\n\t\tif(!rst)\n\t\t\tbegin\n\t\t\t   we_chan <= 1;\n\t\t\tend\n\t\telse if(counter==263)\n\t\t\tbegin\n\t\t\t\twe_chan <= 0;\n\t\t\tend\n\t\telse \n\t\t   begin\n\t\t\tend\n\t end\n\t always@(posedge clk_dp)\n\t begin\n\t\tif(counter == 263)\n\t\t\tbegin\n\t\t\t   rst_turbo <= 0; \n\t\t\tend\n\t\telse if(counter == 264)\n\t\t\tbegin\n\t\t\t\trst_turbo <= 1; \n\t\t\tend\n\t end\n\t assign data_out = data_out_turbo;\n    turbo_top turbo_top1(\n      .enable(1'b1),\n      .clk(clk_dp),\n      .rst(rst_turbo),\n      .data_in(data_in_turbo),\n      .addr_out(addr_out_turbo),\n      .data_out(data_out_turbo),\n\t\t.we_decode(we_decode)\n      );\n\t always@(posedge clk_dp)\n\t begin\n\t\tdata_in_turbo <= data_out_chan ;\n\t end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: user_project_wrapper. \n\nModule specification: The `user_project_wrapper` is a connectivity layer or an interface for a larger system in Verilog RTL codes. This module handles various signals for multiple subsystems, including input/output assignments for power pins, the Wishbone bus interface, a logic analyzer, and general-purpose I/O.\n\nThe input ports include: 'wb_clk_i', 'wb_rst_i' which are the clock and reset for the Wishbone bus interface. 'wbs_stb_i', 'wbs_cyc_i', 'wbs_we_i' are control signals for the bus interface. 'wbs_sel_i [3:0]', 'wbs_dat_i [31:0]' and 'wbs_adr_i [31:0]' serve as the data and addressing lines for the bus interface. 'la_data_in [127:0]', 'la_oenb [127:0]' serve as the input and control lines for the logic analyzer. 'io_in [`MPRJ_IO_PADS-1:0]' is a general-purpose input line. 'user_clock2' is an additional input clock signal. Lastly, it conditionally includes power input pins.\n\nThe output ports include: 'wbs_ack_o', 'wbs_dat_o [31:0]' as acknowledge and data output lines for the Wishbone bus interface. 'la_data_out [127:0]' is the output line for the logic analyzer. 'io_out [`MPRJ_IO_PADS-1:0]', 'io_oeb [`MPRJ_IO_PADS-1:0]' serve as output and output enable lines for general IO. 'user_irq [2:0]' are user interrupt request lines, and conditionally also includes power output pins.\n\nInout ports encompass 'analog_io [`MPRJ_IO_PADS-10:0]' which are the lines for passing analog signals bidirectionally.\n\nInternally, no signals are created or used within the module function. However, depending on the operation mode, the output signal 'io_out' directly reflects the input signal 'io_in', and 'io_oeb' is assigned to '0' during simulation mode.\n\nThis module does not contain separate functional blocks or sections. It primarily performs I/O assignments and includes many conditional compilation blocks, suggesting different behavior during simulation and normal operation. In conclusion, the `user_project_wrapper` module serves as a fundamental connectivity and interface unit for a more extensive digital system.",
        "output": "`default_nettype none\nmodule user_project_wrapper #(\n    parameter BITS = 32\n)(\n`ifdef USE_POWER_PINS\n    inout vdda1,\t\n    inout vdda2,\t\n    inout vssa1,\t\n    inout vssa2,\t\n    inout vccd1,\t\n    inout vccd2,\t\n    inout vssd1,\t\n    inout vssd2,\t\n`endif\n    input wb_clk_i,\n    input wb_rst_i,\n    input wbs_stb_i,\n    input wbs_cyc_i,\n    input wbs_we_i,\n    input [3:0] wbs_sel_i,\n    input [31:0] wbs_dat_i,\n    input [31:0] wbs_adr_i,\n    output wbs_ack_o,\n    output [31:0] wbs_dat_o,\n    input  [127:0] la_data_in,\n    output [127:0] la_data_out,\n    input  [127:0] la_oenb,\n    input  [`MPRJ_IO_PADS-1:0] io_in,\n    output [`MPRJ_IO_PADS-1:0] io_out,\n    output [`MPRJ_IO_PADS-1:0] io_oeb,\n    inout [`MPRJ_IO_PADS-10:0] analog_io,\n    input   user_clock2,\n    output [2:0] user_irq\n);\n`ifdef SIM\nassign io_out = 0;\nassign io_oeb = 0;\n`else\nassign io_out = io_in;\n`endif\nendmodule\t"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: gridPointsMem. \nModule specification: The 'gridPointsMem' module is crafted as a lookup table, designed to map a 6-bit input, 'in', to a specific 16-bit output, 'out'. The input port 'in', which is a 6-bit wide digital signal, acts as an address to select specific output values stored in a lookup table inside the module. The output port, 'out', is a 16-bit wide register that outputs either predefined values or their two's complement, mirroring the values around zero to generate symmetric waveforms. Within the module, 'out' is used as an internal signal and is initialized to zero at the beginning of every cycle; based on the input 'in', it is assigned corresponding values from predefined sets or their negations. The case structure within the '`always`' block handles this translation by checking the input index and assigning the corresponding value, facilitating the module\u2019s fundamental mapping functionality from index to waveform data points.",
        "output": "`timescale 1ns / 1ps\nmodule gridPointsMem(in,out);\ninput [5:0] in;\noutput reg [15:0] out;\nalways @(*) begin\nout = 16'd0;\ncase (in)\n\t'd0: out = 16'd32760;\n\t'd1: out = 16'd32723;\n\t'd2: out = 16'd32588;\n\t'd3: out = 16'd32364;\n\t'd4: out = 16'd32051;\n\t'd5: out = 16'd31651;\n\t'd6: out = 16'd31164;\n\t'd7: out = 16'd30591;\n\t'd8: out = 16'd29935;\n\t'd9: out = 16'd29196;\n\t'd10: out = 16'd28377;\n\t'd11: out = 16'd27481;\n\t'd12: out = 16'd26509;\n\t'd13: out = 16'd25465;\n\t'd14: out = 16'd24351;\n\t'd15: out = 16'd23170;\n\t'd16: out = 16'd21926;\n\t'd17: out = 16'd20621;\n\t'd18: out = 16'd19260;\n\t'd19: out = 16'd17846;  \n\t'd20: out = 16'd16384; \n\t'd21: out = 16'd14876;\n\t'd22: out = 16'd13327;\n\t'd23: out = 16'd11743;\n\t'd24: out = 16'd10125;\n\t'd25: out = 16'd8480;\n\t'd26: out =\t16'd6812;\n\t'd27: out = 16'd5126;\n\t'd28: out =\t16'd3425;\n\t'd29: out = 16'd1714;\n\t'd30: out = 16'd0;\t  \n\t'd31: out = ~(16'd1714)+1;\n\t'd32: out = ~(16'd3425)+1; \n\t'd33: out = ~(16'd5126)+1;\n\t'd34: out =\t~(16'd6812)+1;\n\t'd35: out =\t~(16'd8480)+1;\n\t'd36: out = ~(16'd10125)+1;\n\t'd37: out =\t~(16'd11743)+1;\n\t'd38: out = ~(16'd13327)+1;\n\t'd39: out =\t~(16'd14876)+1;\n\t'd40: out =\t~(16'd16384)+1;\n\t'd41: out = ~(16'd17846)+1;\n\t'd42: out =\t~(16'd19260)+1;\n\t'd43: out =\t~(16'd20621)+1;\n\t'd44: out = ~(16'd21926)+1;\n\t'd45: out =\t~(16'd23170)+1;\n\t'd46: out =\t~(16'd24351)+1;\n\t'd47: out =\t~(16'd25465)+1;\n\t'd48: out =\t~(16'd26509)+1;\n\t'd49: out =\t~(16'd27481)+1;\n\t'd50: out =\t~(16'd28377)+1;\n\t'd51: out = ~(16'd29196)+1;\n\t'd52: out =\t~(16'd29935)+1;\n\t'd53: out =\t~(16'd30591)+1;\n\t'd54: out =\t~(16'd31164)+1;\n\t'd55: out =\t~(16'd31651)+1;\n\t'd56: out =\t~(16'd32051)+1;\n\t'd57: out = ~(16'd32364)+1;\n\t'd58: out = ~(16'd32588)+1;\n\t'd59: out =\t~(16'd32723)+1;\n\t'd60: out = ~(16'd32760)+1;\nendcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: maquina_estados_cond.\nModule specification: The 'maquina_estados_cond' module is a Verilog-based state machine managing several operational states including RESET, INIT, IDLE, ACTIVE, and ERROR. It synchronizes state transitions with a system clock (clk) and makes state transitions based on input signals and internal logic. The input ports contain clk (the clock signal), init (trigger for INIT state), UmbralesMFs, UmbralesVCs, UmbralesDs (threshold settings for various functions), reset (triggers the RESET state), FIFO_EMPTIES and FIFO_ERRORS (FIFO buffer status indicators). Output ports include error_out_cond (error status), active_out_cond (active processing), idle_out_cond (idle status), UmbralMF_cond, UmbralV0_cond, UmbralV1_cond, UmbralD0_cond, UmbralD1_cond (threshold status outputs), and error_full_cond (FIFO error status). Internal register signals estado and estado_prox manage the current and next state respectively, while UmbralMF, UmbralV0, UmbralV1, UmbralD0, and UmbralD1 hold threshold values. The Verilog code is organized into initial definitions, followed by sequential logic for state transitioning on the clock's positive edge, and combinational logic in an always @(*) block that determines the next state and output conditions based on the current state, input conditions, and reset status. Parameters are defined to represent each state with a unique identifier. The combinational logic block features a case statement that defines the behavior and transitions for each state, as well as logic to update the module's output signals depending on the current state and inputs.",
        "output": "module maquina_estados_cond\n   (\n    input clk,\n    input init,\n    input [3:0] UmbralesMFs,\n    input [31:0] UmbralesVCs,\n    input [7:0] UmbralesDs,\n\tinput reset,\n\tinput [4:0] FIFO_EMPTIES,\n    input [4:0] FIFO_ERRORS,\n\toutput reg error_out_cond,\n    output reg active_out_cond,\n    output reg idle_out_cond,\n    output reg [3:0] UmbralMF_cond,\n    output reg [15:0] UmbralV0_cond,\n    output reg [15:0] UmbralV1_cond,\n    output reg [3:0] UmbralD0_cond,\n    output reg [3:0] UmbralD1_cond,\n    output reg [4:0] error_full_cond);\nreg [2:0] estado;\nreg [2:0] estado_prox;\nreg [3:0] UmbralMF;\nreg [15:0] UmbralV0;\nreg [15:0] UmbralV1;\nreg [3:0] UmbralD0;\nreg [3:0] UmbralD1;\nparameter RESET = 0;\nparameter INIT = 1;\nparameter IDLE = 2;\nparameter ACTIVE = 3;\nparameter ERROR = 4;\nalways @(posedge clk) begin\n    if(reset==0) begin\n        estado <= RESET;\n    end\n    else begin \n        estado<=estado_prox;\n    end\nend\nalways @(*) begin\n    estado_prox=estado;\n    error_out_cond=0;\n    active_out_cond=0;\n    idle_out_cond=0;\n    error_full_cond=0;\n    UmbralMF=UmbralesMFs;\n    UmbralV0=UmbralesVCs[31:16];\n    UmbralV1=UmbralesVCs[15:0];\n    UmbralD0=UmbralesDs[7:4];\n    UmbralD1=UmbralesDs[3:0];\n    if(reset==0)begin\n    UmbralMF_cond=0;\n    UmbralV0_cond=0;\n    UmbralV1_cond=0;\n    UmbralD0_cond=0;\n    UmbralD1_cond=0;\n    end else begin\n    UmbralMF_cond=UmbralMF;\n    UmbralV0_cond=UmbralV0;\n    UmbralV1_cond=UmbralV1;\n    UmbralD0_cond=UmbralD0;\n    UmbralD1_cond=UmbralD1;\n    end\n    case (estado)\n        RESET: begin\n            active_out_cond=0;\n            error_out_cond=0;\n            idle_out_cond=0;\n            error_full_cond=0;\n            UmbralMF_cond=0;\n            UmbralV0_cond=0;\n            UmbralV1_cond=0;\n            UmbralD0_cond=0;\n            UmbralD1_cond=0;\n            if(reset==0)begin\n                if(init==1)\n                estado_prox=INIT;\n            end else\n                estado_prox=INIT;\n        end\n        INIT: begin\n            error_out_cond=0;\n            idle_out_cond=0;\n            active_out_cond=0;\n            error_full_cond=0;\n            UmbralMF=UmbralesMFs;\n            UmbralV0=UmbralesVCs[31:16];\n            UmbralV1=UmbralesVCs[15:0];\n            UmbralD0=UmbralesDs[7:4];\n            UmbralD1=UmbralesDs[3:0];\n            if(reset==0)\n                estado_prox=RESET;\n            else if(init==1)\n                estado_prox=INIT;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES==4'b0)\n                estado_prox= IDLE;\n            else\n                estado_prox = INIT;\n        end\n        IDLE: begin\n            error_out_cond=0;\n            idle_out_cond=1;\n            active_out_cond=0;\n            error_full_cond=0;\n            if(reset==0)\n                estado_prox=RESET;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES!=4'b0)\n                estado_prox=ACTIVE;\n            else\n                estado_prox=IDLE;\n        end\n        ERROR: begin\n            idle_out_cond=0;\n            error_out_cond=1;\n            active_out_cond=0;\n            error_full_cond= FIFO_ERRORS;\n            if(reset==0)\n                estado_prox=RESET;\n            else \n                estado_prox=ERROR;\n        end\n        ACTIVE: begin\n            error_out_cond=0;\n            idle_out_cond=0;\n            active_out_cond=1;\n            if(reset==0)\n                estado_prox=RESET;\n            else if(init==1)\n                estado_prox=INIT;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES==4'b0)\n                estado_prox= IDLE;\n            else\n                estado_prox=ACTIVE;\n        end\n    endcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: cabac_neighbour_1p_8xMB_X_TOTAL. \n\nModule specification: The module cabac_neighbour_1p_8xMB_X_TOTAL is designed primarily to facilitate the interfacing with a single-port register file tailored for CABAC (Context Adaptive Binary Arithmetic Coding) neighbor data handling in a video coding scenario. The register file handles 8-bit data words and the module manages writing to and reading from the register file depending on control signals. Input ports include `clk` (clock signal), `r_en` (read enable, unused in the visible logic), `r_addr` (read address), `w_en` (write enable), `w_addr` (write address), and `w_data` (write data). The single output port is `r_data`, which outputs the data read from the register file. Internal signals within the module include `cen_i` (chip enable, always enabled as it\u2019s set to '0'), `wen_i` (write enable input, which is the inverse of w_en), `addr_i` (address input, selecting between `w_addr` and `r_addr` based on `w_en`), `data_i` (data input, which is the writing data into the register file), and `data_o` (data output, directly mapped to `r_data` for reading operations). The module encapsulates a register file instance named `rf_1p_cabac_neigh_8xMB_X_TOTAL_u0`, parameterized with address and word widths, which interprets these inputs to perform the appropriate data storage or retrieval operations based on the synchronization provided by the `clk` input.",
        "output": "`include \"enc_defines.v\"\nmodule cabac_neighbour_1p_8xMB_X_TOTAL(\n\t\t\t\t\tclk\t\t\t\t,\n\t\t\t\t\tr_en\t\t\t,\n\t\t\t\t\tr_addr\t\t\t,\n\t\t\t\t\tw_en\t\t\t,\n\t\t\t\t\tw_addr\t\t\t,\n\t\t\t\t\tw_data\t\t\t,\n\t\t\t\t\tr_data\n);\ninput\t\t\t\tclk\t\t\t\t\t\t;\t\ninput\t\t\t\tr_en\t\t\t\t\t;\t\ninput\t[(`PIC_X_WIDTH)-1:0]\t\tr_addr\t\t\t\t\t;\t\ninput\t\t\t\tw_en\t\t\t\t\t;\t\ninput\t[(`PIC_X_WIDTH)-1:0]\t\tw_addr\t\t\t\t\t;\t\ninput\t[7:0]\t\tw_data\t\t\t\t\t;\t\noutput\t[7:0]\t\tr_data\t\t\t\t\t;\t\nrf_1p #(.Addr_Width((`PIC_X_WIDTH)), .Word_Width(8))\t \n\t\trf_1p_cabac_neigh_8xMB_X_TOTAL_u0(\n\t\t\t\t.clk    ( clk\t ),\n\t\t        .cen_i  ( 1'b0\t ),\n\t\t        .wen_i  ( ~w_en\t ),\n\t\t        .addr_i ( w_en ? w_addr : r_addr ),\n\t\t        .data_i ( w_data ),\t\t\n\t\t        .data_o\t( r_data )\n);\t\t\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: pipe1. Module specification: The 'pipe1' module is designed as a basic pipeline register in Verilog, which synchronizes with a clock signal ('clk') to manage a 32-bit instruction signal. It takes a 32-bit input ('instruction_in') and either passes this directly to a 32-bit output ('instruction_out') or resets the output to zero based on the state of the reset signal ('reset'). The input ports include 'instruction_in', a 32-bit instruction to be handled by the module; 'clk', the clock signal that triggers state changes at its rising edge; and 'reset', a control signal that when high, clears 'instruction_out' at the next clock edge. Internally, 'instruction_out' serves dual roles as both an output port and a register, holding the instruction value or zero based on the reset condition until the next clock cycle. The main code block is an always block triggered by the positive edge of 'clk', which checks the state of 'reset'; if high, 'instruction_out' is set to zero, otherwise, it mirrors 'instruction_in'. This operation ensures that the output is either the passed-through instruction or a cleared value depending on system reset conditions, thereby maintaining synchronized and stable operation within the module.",
        "output": "module pipe1(instruction_in, instruction_out, clk, reset);\n\tinput [0:31] instruction_in;\n\tinput clk, reset;\n\toutput [0:31] instruction_out;\n\treg [0:31] instruction_out;\n\talways @ (posedge clk)\n\t\tbegin\n\t\tif (reset == 1'b1)\n\t\t\tbegin\n\t\t\tinstruction_out [0:31] <= 32'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tinstruction_out [0:31] <= instruction_in [0:31];\n\t\t\tend\n\t\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: IOBUF_LVCMOS33_F_6. Module specification: The IOBUF_LVCMOS33_F_6 module is designed as a bidirectional I/O buffer compliant with LVCMOS33 standards, incorporating a failsafe mechanism via global and local tristate controls. It features two input ports: 'I', which is the data signal intended to be driven onto the IO pin, and 'T', a tristate control that determines the output behavior of the IO pin in conjunction with the global tristate signal 'GTS'. The module has one output port 'O', which mirrors the current state of the IO pin, allowing external monitoring. Additionally, it includes an inout port 'IO' that serves as a bidirectional interface: it outputs the data from 'I' when enabled, or acts as a high-impedance input when disabled by the tristate control. Internally, the module uses two signals: 'ts', a wire that combines 'GTS' and 'T' using an OR gate to control the IO pin's state, and 'GTS', which is tied to a global setting to enforce high-impedance states under certain conditions. The code contains an OR gate instantiation (O1) to derive 'ts', a buffer with enable (bufif0 T1) to control the state of the 'IO' pin based on 'ts', and a standard buffer (B1) that drives the output 'O' with the state of 'IO'. This design ensures that the module can effectively manage the direction and state of the IO pin while also providing a mechanism to monitor and control it under various operational states, adhering to LVCMOS33 standards with integrated failsafe functionality.",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_LVCMOS33_F_6 (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: lsp_lsf2Test. Module specification: The 'lsp_lsf2Test' module is a testbench designed to verify the 'lsp_lsfPipe' module's functionality, which transforms LSP (Line Spectral Pairs) to LSF (Line Spectral Frequencies). It has input ports such as `start`, `clk`, `reset`, `lspAddr`, `lsfAddr`, `testReadAddr`, `testWriteAddr`, `testMemOut`, `testWriteEn`, and `memMuxSel`. These manage various aspects of the testing process, from initializing the transform operation to handling memory read and write operations during the test. The output ports, `done` and `memIn`, indicate the completion of the processing and output the transformed data respectively. Internal signals include `lspMem` and `lsfMem` for storing test data, and loop counters `i` and `j` to manage iterations through the data during testing. The testbench is structured into multiple initial blocks: one loads data into `lspMem` and `lsfMem`, another manages the simulation's startup and reset conditions, and one iteratively writes to, triggers processing, and then reads back from the tested module to verify correct transformation against expected results. An always block at the end generates the clock signal used throughout the test, ensuring all operations are timed accurately. This comprehensive environment ensures that the 'lsp_lsfPipe' module's functionality can be exhaustively verified under simulated conditions simulating real operational scenarios.",
        "output": "`timescale 1ns / 1ps\nmodule lsp_lsf2Test;\n\treg start;\n\treg clk;\n\treg reset;\n\treg [11:0] lspAddr;\n\treg [11:0] lsfAddr;\n\treg [11:0] testReadAddr;\n\treg [11:0] testWriteAddr;\n\treg [31:0] testMemOut;\n\treg testWriteEn;\n\treg memMuxSel;\n\twire done;\n\twire [31:0] memIn;\n\treg [31:0] lspMem [0:9999];\n\treg [31:0] lsfMem [0:9999];\n\tinteger i,j;\n\tinitial \n\t\tbegin\n\t\t\t$readmemh(\"lsp_lsplsf2_lsp.out\", lspMem);\n\t\t\t$readmemh(\"lsp_lsplsf2_lsf.out\", lsfMem);\t\t\t\n\t\tend\n\tlsp_lsfPipe uut (\n\t\t.start(start), \n\t\t.clk(clk), \n\t\t.reset(reset), \n\t\t.lspAddr(lspAddr), \n\t\t.lsfAddr(lsfAddr), \n\t\t.testReadAddr(testReadAddr), \n\t\t.testWriteAddr(testWriteAddr), \n\t\t.testMemOut(testMemOut), \n\t\t.testWriteEn(testWriteEn), \n\t\t.memMuxSel(memMuxSel), \n\t\t.done(done), \n\t\t.memIn(memIn)\n\t);\n\tinitial begin\n\t\tstart = 0;\n\t\tclk = 0;\n\t\treset = 0;\n\t\tlspAddr = 12'd512;\n\t\tlsfAddr = 12'd1024;\n\t\ttestReadAddr = 0;\n\t\ttestWriteAddr = 0;\n\t\ttestMemOut = 0;\n\t\ttestWriteEn = 0;\n\t\tmemMuxSel = 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk) #5;\n\t\treset = 1;\n\t\t@(posedge clk);\n\t\t@(posedge clk) #5;\n\t\treset = 0;\n\tfor(j=0;j<60;j=j+1)\n\t\tbegin\n\t\t\tfor(i=0;i<10;i=i+1)\n\t\t\tbegin\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk) #5;\t\t\t\t\n\t\t\t\ttestMemOut = lspMem[10*j+i];\t\t\t\t\n\t\t\t\ttestWriteAddr = {lspAddr[10:4], i[3:0]};\t\t\t\t\n\t\t\t\ttestWriteEn = 1;\t\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk) #5;\n\t\t\tend\n\t\t\tmemMuxSel = 1;\t\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\t\t\n\t\t\tstart = 1;\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\n\t\t\tstart = 0;\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\n\t\twait(done);\n\t\tmemMuxSel = 0;\n\t\t\tfor (i = 0; i<10;i=i+1)\n\t\t\tbegin\t\t\t\t\n\t\t\t\t\ttestReadAddr = {lsfAddr[10:4],i[3:0]};\n\t\t\t\t\t@(posedge clk);\n\t\t\t\t\t@(posedge clk) #5;\n\t\t\t\t\tif (memIn != lsfMem[j*10+i])\n\t\t\t\t\t\t$display($time, \" ERROR: lsf[%d] = %x, expected = %x\", j*10+i, memIn, lsfMem[j*10+i]);\n\t\t\t\t\telse if (memIn == lsfMem[j*10+i])\n\t\t\t\t\t\t$display($time, \" CORRECT:  lsf[%d] = %x\", j*10+i, memIn);\n\t\t\t\t\t@(posedge clk)#5; \n\t\t\tend\t\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\t\n\t\tend\n\tend\n\tinitial forever #10 clk = ~clk;   \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: IOBUF_HSTL_IV. \nModule specification: The IOBUF_HSTL_IV module is created to handle communications with a bi-directional I/O pad using High-Speed Transceiver Logic (HSTL) level 4 signaling, particularly for tri-state control. It effectively manages the state of the I/O pad through inputs 'I' and 'T', where 'I' is the input data signal meant to drive the IO line when configured as an output and 'T' is the tri-state control determining whether the IO pin remains in a high-impedance state or drives 'I'. Its output, 'O', mirrors the state of the 'IO' bi-directional pin. Internally, the module utilizes a tri-state control signal 'ts' derived via an OR gate from the local 'T' input and a global tri-state 'GTS' (assumed to be part of an external 'glbl' module), making the 'ts' signal high when either 'GTS' or 'T' is high, which sets the IO line to high impedance. The key blocks of code include setting a default high impedance state using 'tri0' for 'GTS', the 'O1' OR gate which derives the 'ts' signal, 'T1' buffer with enable which controls the output driving based on 'ts', and 'B1' buffer that ensures the IO status is reflected at the output 'O'. This module plays a crucial role in systems with potential multiple driving devices, ensuring controlled access and impedance to prevent conflicts and signal integrity issues.",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_HSTL_IV (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module Name: HalfAdder.\nModule Specification: The HalfAdder is a fundamental Verilog module designed to perform a half-addition operation on two binary digits, received as inputs. It takes two input ports named 'a' and 'b', which are single-bit to represent the binary digits for addition. The module performs XOR (exclusive OR) and AND operations on the input binary digits and generates two outputs. The 'sum' output is derived from the XOR operation, providing a simple binary sum of the inputs 'a' and 'b'. The 'carry' output emanates from the AND operation and displays any carry value that would be forwarded to the next higher bit in higher-bit addition scenarios. Notably, the HalfAdder does not employ any internal signals as all operations are executed directly on the input ports and the results are assigned directly to the output ports. Comprising two primary blocks, the XOR and the AND operations, the first block performs the XOR operation to generate the sum, and the second block processes the AND operation to determine the carry. The module readily serves the needs of digital electronics and binary arithmetic by efficiently summing inputs and handling carries.",
        "output": "CHIP HalfAdder {\n    IN a, b;    \n    OUT sum,    \n        carry;  \n    PARTS:\n    Xor(a=a, b=b, out=sum);\n    And(a=a, b=b, out=carry);\n}"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: MUX. Module specification: The MUX module is a multiplexer designed in Verilog with a parameterizable data width, functioning to select between two input signals (`in1`, `in2`) based on a control select signal (`sel`). The `in1` and `in2` are input data signals, both of which have a width determined by the `data_width` parameter, allowing `data_width` bits to be processed concurrently. The signal `sel` is a binary input that determines which of the two inputs is passed to the output; `in1` is selected when `sel` is low, and `in2` is selected when `sel` is high. The output port, `out`, also matches the `data_width` and presents either `in1` or `in2` depending on `sel`'s state. Internally, the module uses a wire `sel1`, which spans the same width as the inputs and the output. The signal `sel1` is a replication of `sel`, extended across all bits (i.e., `data_width` times), facilitating bitwise operations with `in1` and `in2` for the output logic. Specifically, the module logic employs the expression `assign out = (in1 & (~sel1)) | (in2 & sel1)` to determine the output based on the state of `sel`. This bitwise operation ensures that the respective input is correctly outputted by masking and combining the input signals based on the replicated select signal.",
        "output": "module MUX #(parameter data_width=32)\n(input [data_width-1:0] in1,\ninput [data_width-1:0] in2,\ninput sel,\noutput [data_width-1:0] out);\nwire [data_width-1:0] sel1;\nassign sel1[data_width-1:0]={data_width{sel}};\nassign out=(in1&(~sel1))|(in2 & sel1);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: parallel_adder_subtractor.\n\nModule specification: The parallel_adder_subtractor is designed to perform either addition or subtraction on two 4-bit inputs, A and B, controlled by a single bit K. When K is 0, the module adds A and B; when K is 1, it subtracts B from A. This functionality is supported through the use of XOR gates and four instances of a 1-bit full adder. The module has six ports: two 4-bit input ports, A and B, for the operands; a single-bit input K that selects between addition and subtraction; a single-bit input, Cin, which serves as the carry input for the operation; a 4-bit output port, S, which holds the result; and a single-bit output, Cout, which acts as the carry-out signal indicating an overflow in addition or underflow in subtraction. Internally, the module utilizes wires b0 through b3 for the XOR-ed versions of input B bits with K, effectively toggling B's bits for the subtraction operation when K is 1. It also includes wires c0 through c2 acting as carry-out signals from the first three 1-bit full adders and serving as carry inputs for the subsequent adder stages. The Verilog code is structured into clearly defined sections: the declaration of input and output ports, the instantiation of internal signals b0 to b3 by XOR-ing B's bits with K, and the chain of four 1-bit full adder instances (F0 to F3) that construct the adder/subtractor logic. Each full adder instance receives an operand bit from A and its corresponding modified bit from B (via b0 to b3), along with a carry-in signal, and it produces a result bit for S and a carry-out signal, ensuring seamless addition or subtraction across all four bits.",
        "output": "module parallel_adder_subtractor(A,B,K,S,Cout,Cin);\ninput [3:0]A,B;\ninput K,Cin;\noutput [3:0]S;\noutput Cout;\nwire b0,b1,b2,b3;\nxor(b0,B[0],K);\nxor(b1,B[1],K);\nxor(b2,B[2],K);\nxor(b3,B[3],K);\nwire c0,c1,c2;\nfull_adder_1bit  F0(A[0],b0,Cin,S[0],c0);\nfull_adder_1bit  F1(A[1],b1,c0,S[1],c1);\nfull_adder_1bit  F2(A[2],b2,c1,S[2],c2);\nfull_adder_1bit  F3(A[3],b3,c2,S[3],Cout);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: MMU.\n\nModule specification: The Memory Management Unit (MMU) is a critical module designed for managing memory accesses and data transfers within a system, responding to various clock signals and a reset signal for synchronization. It primarily functions based on input signals, including CLOCK, Clock1, Clock2 for timing; Reset for initialization; Active for enabling operations; Hold to pause operations; Init for setting initial configurations; ACSPage and ACSSegment_minusLSB for addressing specific memory pages and segments. The input port Survivors represents survived data conditions essential for memory management. The module interfaces with external blocks through output ports such as DataTB to send data to a Translation Buffer; RWSelect, ReadClock, and WriteClock for read/write control; RAMEnable for enabling RAM operations; and AddressRAM and DataRAM for direct memory access and data transaction.\n\nInternal signals include dummy, used as a state toggle; SurvRDY for indicating readiness of the survivor data; WrittenSurvivors connecting processed data to RAM; and several address manipulation registers such as AddressRAM and TBPage. The code features clearly differentiated blocks or sections, each handling specific functionalities: clock-driven state toggling, data readiness toggling, survivor data buffering through the ACSSURVIVORBUFFER sub-module, address and page handling for the RAM and Translation Buffer, and dynamically setting and managing read/write operations and data flow based on current state conditions and clock signals. This organization ensures smooth transitions between operations and efficient data handling within the MMU module.",
        "output": "`include \"params.v\"\nmodule MMU (CLOCK, Clock1, Clock2, Reset, Active, Hold, Init, ACSPage, \nACSSegment_minusLSB, Survivors, \nDataTB, AddressTB,\nRWSelect, ReadClock, WriteClock, \nRAMEnable, AddressRAM, DataRAM);\ninput CLOCK, Clock1, Clock2, Reset, Active, Hold, Init;\ninput [`WD_DEPTH-1:0] ACSPage;\ninput [`WD_FSM-2:0] ACSSegment_minusLSB;\ninput [`N_ACS-1:0] Survivors;\noutput [`WD_RAM_DATA-1:0] DataTB;\ninput [`WD_RAM_ADDRESS-`WD_FSM-1:0] AddressTB;\noutput RWSelect, ReadClock, WriteClock, RAMEnable;\noutput [`WD_RAM_ADDRESS-1:0] AddressRAM;\ninout [`WD_RAM_DATA-1:0] DataRAM;\nwire [`WD_RAM_DATA-1:0] WrittenSurvivors;\nreg dummy, SurvRDY;\nreg [`WD_RAM_ADDRESS-1:0] AddressRAM;\nreg [`WD_DEPTH-1:0] TBPage;\nwire [`WD_DEPTH-1:0] TBPage_;\nwire [`WD_DEPTH-1:0] ACSPage;\nwire [`WD_TB_ADDRESS-1:0] AddressTB;\nalways @(posedge Clock2 or negedge Reset) \nif (~Reset) dummy <= 0;else if (Active) dummy <= ~dummy;\nassign WriteClock = (Active && ~dummy) ? Clock1:0;\nassign ReadClock = (Active && ~Hold) ? ~Clock1:0;\nalways @(posedge Clock1 or negedge Reset) \nif (~Reset) SurvRDY <= 1; else if (Active) SurvRDY <= ~SurvRDY;\nACSSURVIVORBUFFER buff (Reset, Clock1, Active, SurvRDY, Survivors, \nWrittenSurvivors);\nalways @(negedge Clock2 or negedge Reset)\nbegin\nif (~Reset) begin\nTBPage <= 0;\nend\nelse if (Init) TBPage <= ACSPage-1;\nelse TBPage <= TBPage_;\nend\nassign TBPage_ = TBPage - 1;\nassign RAMEnable = 0;\nassign RWSelect = (Clock2) ? 1:0;\nassign DataRAM = (~Clock2) ? WrittenSurvivors:'bz;\nassign DataTB = (Clock2) ? DataRAM:'bz;\nalways @(posedge CLOCK or negedge Reset)\nbegin\nif (~Reset) AddressRAM <= 0;\nelse\nif (Active) begin\nif (Clock2 == 0) \nbegin\nAddressRAM <= {ACSPage, ACSSegment_minusLSB};\nend\nelse \nbegin\nAddressRAM <= {TBPage [`WD_DEPTH-1:0],AddressTB};\nend\nend\nend\nendmodule\nmodule ACSSURVIVORBUFFER (Reset, Clock1, Active, SurvRDY, Survivors, \nWrittenSurvivors);\ninput Reset, Clock1, Active, SurvRDY;\ninput [`N_ACS-1:0] Survivors;\noutput [`WD_RAM_DATA-1:0] WrittenSurvivors;\nwire [`WD_RAM_DATA-1:0] WrittenSurvivors;\nreg [`N_ACS-1:0] WrittenSurvivors_;\nalways @(posedge Clock1 or negedge Reset)\nbegin\nif (~Reset) WrittenSurvivors_ = 0;\nelse if (Active)\nWrittenSurvivors_ = Survivors;\nend\nassign WrittenSurvivors = (SurvRDY) ? {Survivors, WrittenSurvivors_}:8'bz;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: tcm_dec_tmu_tree4.\n\nModule specification: The `tcm_dec_tmu_tree4` module is specialized for processing trellis-coded modulation (TCM) in a four-path tree structure for a decision-feedback system. It leverages serial input symbols, an input value, and a clocking system to process and select the most likely path based on the computed metrics. The module has several input ports including `iclk` (clock signal), `ireset` (reset signal), `iclkena` (clock enable signal), `ival` (signifies data availability), and `isymb_m` (symbol metrics array). The outputs consist of `oval` (signal validity), `obm` (best metric), and `osymb_m_idx` (index of best symbol metric). Internally, the module utilizes `val` (3-bit shift register for input data storage), `pre_sum` (intermediate summation values), `symb_m3_line` (storing selected symbol metrics), and `sum` (final metric values). Additionally, `decision4` (2-bit vector) determines the highest metric index which is used for decision output. The code contains various procedural blocks: one `always_ff` block for handling reset and updating shift register `val` based on `ival` and `iclkena`, and another `always_ff` block structured to calculate preliminary and final sums, and to make a decision based on the accumulated metrics using custom functions `max2` and `max4` for determining the maximum values among inputs. The module efficiently aggregates and processes symbol likelihoods to aid in TCM decoding.",
        "output": "`include \"define.vh\"\nmodule tcm_dec_tmu_tree4\n(\n  iclk        ,\n  ireset      ,\n  iclkena     ,\n  ival        ,\n  isymb_m     ,\n  oval        ,\n  obm         ,\n  osymb_m_idx\n);\n  `include \"tcm_trellis.vh\"\n  `include \"tcm_dec_types.vh\"\n  input  logic        iclk        ;\n  input  logic        ireset      ;\n  input  logic        iclkena     ;\n  input  logic        ival        ;\n  input  symb_m_t     isymb_m [4] ;\n  output logic        oval        ;\n  output trel_bm_t    obm         ;\n  output symb_m_idx_t osymb_m_idx ;\n  logic [2 : 0]  val;\n  trel_bm_t      pre_sum       [4];\n  symb_m_value_t symb_m3_line  [2];\n  trel_bm_t      sum           [4];\n  always_ff @(posedge iclk or posedge ireset) begin\n    if (ireset)\n      val <= '0;\n    else if (iclkena)\n      val <= (val << 1) | ival;\n  end\n  always_ff @(posedge iclk) begin\n    bit [1 : 0] decision4;\n    if (iclkena) begin\n      if (ival) begin\n        for (int i = 0; i < 4; i++) begin\n          pre_sum[i] <= isymb_m[i][0] + isymb_m[i][1] + isymb_m[i][2];\n        end\n        symb_m3_line[0] <= isymb_m[0][3];\n        symb_m3_line[1] <= isymb_m[2][3];\n      end\n      if (val[0]) begin\n        for (int i = 0; i < 4; i++) begin\n          sum[i] <= pre_sum[i] + symb_m3_line[i/2];\n        end\n      end\n      if (val[1]) begin\n        decision4 = max4(sum[0], sum[1], sum[2], sum[3]);\n        obm         <= sum[decision4];\n        osymb_m_idx <= decision4;\n      end\n    end\n  end\n  assign oval = val[2];\n  function automatic bit max2 (input trel_bm_t a0, a1);\n    max2 = (a1 > a0);\n  endfunction\n  function automatic bit [1 : 0] max4 (input trel_bm_t a0, a1, a2, a3);\n    logic a1_more_a0;\n    logic a3_more_a2;\n    logic a23_more_a10;\n  begin\n    a1_more_a0    = (a1 > a0);\n    a3_more_a2    = (a3 > a2);\n    a23_more_a10  = ((a3_more_a2 ? a3 : a2) > (a1_more_a0 ? a1 : a0));\n    if (a23_more_a10) begin\n      max4 = a3_more_a2 ? 2'h3 : 2'h2;\n    end\n    else begin\n      max4 = a1_more_a0 ? 2'h1 : 2'h0;\n    end\n  end\n  endfunction\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: xor_gate_tb. Module specification: The `xor_gate_tb` module functions as a testbench designed to validate the XOR gate's operations by applying various combinations of binary inputs and observing the output. It comprises two input ports, `a` and `b`, which simulate the binary inputs to the XOR gate, and an output port, `y`, that receives and displays the XOR result. Internally, the module utilizes the signals `a` and `b` as registers to drive inputs into the XOR gate and `y` as a wire to monitor the gate's output. The code includes an `initial` block that starts by printing header labels and recursively updates test inputs `a` and `b` to execute all possible binary combinations. The changes in inputs and corresponding output `y` are continuously displayed using the `$monitor` function. The test concludes by calling `$finish` after all input combinations have been tested. This ensures thorough verification of the XOR gate's truth table in a controlled testbench environment.",
        "output": "module xor_gate_tb;\n  reg a, b;\n  wire y;\n  xor_gate xor1(.a(a), .b(b), .y(y));\n  initial\n  begin\n    $display(\"a  b  |  y\");\n    $monitor(\"%b   %b  |  %b\", a, b, y);\n    #1 a = 0; b = 0;\n    #1 a = 0; b = 1;\n    #1 a = 1; b = 0;\n    #1 a = 1; b = 1;\n    $finish;\n  end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: adder_nbit. \n\nModule specification: The 'adder_nbit' module is a parameterizable Verilog module primarily used for adding two binary numbers of configurable bit-width, defined by the parameter 'N'. It features two input ports, 'a' and 'b', each accepting a binary number of 'N' bits. The result of the addition, which may include an overflow bit, is output on the 'sum' port, having a width of 'N+1' bits. Internally, the module does not make use of any separate signals, as the addition operation (`a[N-1:0] + b[N-1:0]`) is directly assigned to the 'sum' port within a combinational always block (`always @(*)`). This block ensures that the output is updated anytime there is a change in the inputs. This direct assignment negates the necessity for additional internal signals, simplifying the module's internal architecture and operation. The module is encapsulated within an `adder_nbit` definition and can be instantiated with different widths as shown in an accompanying testbench `tb_adder_nbit`, which demonstrates usage and simulation scenarios with varying input values to validate the adder\u2019s functionality.",
        "output": "module adder_nbit \n    #( parameter N = 3)\n    (input [N-1:0] a,\n     input [N-1:0] b,\n     output reg [N:0] sum);\n    always @(*) begin\n       sum[N:0] = a[N-1:0] + b[N-1:0];\n    end  \nendmodule\n`timescale 1us/1ns\nmodule tb_adder_nbit();\n    parameter ADDER_WIDTH = 10;\n    reg  [ADDER_WIDTH-1:0] a;\n    reg  [ADDER_WIDTH-1:0] b;\n    wire [ADDER_WIDTH:0] sum;\n    adder_nbit \n    #(.N(ADDER_WIDTH))\n    ADDER1\n    (\n        .a(a),\n        .b(b),\n        .sum(sum)      \n    );\n    initial begin\n        $monitor($time, \" a = %d, b = %d, sum = %d\", a, b, sum);\n        #1; a = 0  ; b = 0  ;\n        #2; a = 1  ; b = 99 ;\n        #1; a = 33 ; b = 66 ;\n        #1; a = 100; b = 47 ;\n\t\t#1; $stop;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: wallace_tree\n\nModule specification: The `wallace_tree` module is designed to efficiently multiply two 24-bit binary numbers, `inp1` and `inp2`, using the Wallace Tree algorithm. This algorithm enhances multiplication speeds by reducing sequential addition steps through a parallel structure. The inputs to the module are `inp1` and `inp2`, each a 24-bit binary number acting as the operands for the multiplication. The outputs are `product1`, a 48-bit port providing the multiplication's 48 least-significant bits, and `carryf`, a single-bit port indicating overflow carry from the multiplication. Internally, the module utilizes a series of wire arrays named `p1` to `p24` for holding the partial products generated by considering each bit of `inp2`. Additional internal signals include `carry1` to `carry22` and `sum1` to `sum22`, used in the Wallace Tree's intermediate carry-save adders (CSAs) to combine partial products gradually. The module orchestrates multiple carry-save adders to systematically reduce these partial products and intermediate sums and carries. The final carry-save adder results are fed into a ripple carry adder (`rca24bit`) block, which outputs the final product split into the result (`product1`) and the final carry (`carryf`). This structured approach to multiplying facilitates quicker computation suitable for hardware implementations requiring high-speed arithmetic operations.",
        "output": "`timescale 1ns / 1ps\nmodule wallace_tree(carryf,product1,inp1,inp2);\ninput [23:0]inp1;\ninput [23:0]inp2;\nwire [47:0]product;\noutput [47:0]product1;\noutput carryf;\nwire [49:0]p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24;\nwire [49:0]carry1,carry2,carry3,carry4,carry5,carry6,carry7,carry8,carry9,carry10,carry11,carry12,carry13,carry14,carry15,carry16,carry17,carry18,carry19,carry20,carry21,carry22;\nwire [49:0]sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8,sum9,sum10,sum11,sum12,sum13,sum14,sum15,sum16,sum17,sum18,sum19,sum20,sum21,sum22;\nassign p1=(inp2[0]==1'b1)?{25'b0,inp1}:50'h00000000;\nassign p2=(inp2[1]==1'b1)?{24'b0,inp1,1'b0}:50'h00000000;\nassign p3=(inp2[2]==1'b1)?{23'b0,inp1,2'b0}:50'h00000000;\nassign p4=(inp2[3]==1'b1)?{22'b0,inp1,3'b0}:50'h00000000;\nassign p5=(inp2[4]==1'b1)?{21'b0,inp1,4'b0}:50'h00000000;\nassign p6=(inp2[5]==1'b1)?{20'b0,inp1,5'b0}:50'h00000000;\nassign p7=(inp2[6]==1'b1)?{19'b0,inp1,6'b0}:50'h00000000;\nassign p8=(inp2[7]==1'b1)?{18'b0,inp1,7'b0}:50'h00000000;\nassign p9=(inp2[8]==1'b1)?{17'b0,inp1,8'b0}:50'h00000000;\nassign p10=(inp2[9]==1'b1)?{16'b0,inp1,9'b0}:50'h00000000;\nassign p11=(inp2[10]==1'b1)?{15'b0,inp1,10'b0}:50'h00000000;\nassign p12=(inp2[11]==1'b1)?{14'b0,inp1,11'b0}:50'h00000000;\nassign p13=(inp2[12]==1'b1)?{13'b0,inp1,12'b0}:50'h00000000;\nassign p14=(inp2[13]==1'b1)?{12'b0,inp1,13'b0}:50'h00000000;\nassign p15=(inp2[14]==1'b1)?{11'b0,inp1,14'b0}:50'h00000000;\nassign p16=(inp2[15]==1'b1)?{10'b0,inp1,15'b0}:50'h00000000;\nassign p17=(inp2[16]==1'b1)?{9'b0,inp1,16'b0}:50'h00000000;\nassign p18=(inp2[17]==1'b1)?{8'b0,inp1,17'b0}:50'h00000000;\nassign p19=(inp2[18]==1'b1)?{7'b0,inp1,18'b0}:50'h00000000;\nassign p20=(inp2[19]==1'b1)?{6'b0,inp1,19'b0}:50'h00000000;\nassign p21=(inp2[20]==1'b1)?{5'b0,inp1,20'b0}:50'h00000000;\nassign p22=(inp2[21]==1'b1)?{4'b0,inp1,21'b0}:50'h00000000;\nassign p23=(inp2[22]==1'b1)?{3'b0,inp1,22'b0}:50'h00000000;\nassign p24=(inp2[23]==1'b1)?{2'b0,inp1,23'b0}:50'h00000000;\ncarrysaveadder c1(carry1,sum1,p1,p2,p3);\ncarrysaveadder c2(carry2,sum2,p4,p5,p6);\ncarrysaveadder c3(carry3,sum3,p7,p8,p9);\ncarrysaveadder c4(carry4,sum4,p10,p11,p12);\ncarrysaveadder c5(carry5,sum5,p13,p14,p15);\ncarrysaveadder c6(carry6,sum6,p16,p17,p18);\ncarrysaveadder c7(carry7,sum7,p19,p20,p21);\ncarrysaveadder c8(carry8,sum8,p22,p23,p24);\ncarrysaveadder c9(carry9,sum9,sum1,carry1,sum2);\ncarrysaveadder c10(carry10,sum10,carry2,sum3,carry3);\ncarrysaveadder c11(carry11,sum11,sum4,carry4,sum5);\ncarrysaveadder c12(carry12,sum12,carry5,sum6,carry6);\ncarrysaveadder c13(carry13,sum13,sum7,carry7,sum8);\ncarrysaveadder c14(carry14,sum14,sum9,carry9,sum10);\ncarrysaveadder c15(carry15,sum15,carry10,sum11,carry11);\ncarrysaveadder c16(carry16,sum16,sum12,carry12,sum13);\ncarrysaveadder c17(carry17,sum17,sum14,carry14,sum15);\ncarrysaveadder c18(carry18,sum18,carry15,sum16,carry16);\ncarrysaveadder c19(carry19,sum19,sum17,carry17,sum18);\ncarrysaveadder c20(carry20,sum20,carry18,carry13,carry8);\ncarrysaveadder c21(carry21,sum21,sum19,carry19,sum20);\ncarrysaveadder c22(carry22,sum22,sum21,carry21,carry20);\nrca24bit add1(sum22,carry22,1'b0,product,carryf);\nassign product1 = product[47:0];\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module name: cic_integrator.\nModule specification: \n\nThe 'cic_integrator' is a Verilog module designed to implement a first-order cumulative summing integrator. The module is activated and performs an integration operation only upon the positive edge of the input 'clock' signal whilst the control signal 'strobe' is high. If these conditions are met, the input data 'in_data' is added to the previously accumulated sum in 'out_data'.\n\nThe module takes three input ports. The 'clock' signal controls the timing of the integration operation and is necessary for the functioning of the module. The 'strobe' signal serves as a control signal that dictates whether the integration operation occurs or not. The 'in_data' is the input data stream which is to be integrated. This data is of 'signed' datatype and of a width which is controlled by a 'WIDTH' parameter.\n\nThe output of this module is given by the 'out_data' port. This port holds the accumulated sum generated by the integration operation on 'in_data' while 'strobe' was active at a clock pulse. 'out_data' is similarly 'signed' and has width equal to 'WIDTH'.\n\nThe 'cic_integrator' module does not use any internal signals and operates directly on the inputs to generate the output. This simplicity allows it to operate efficiently and without unnecessary complexity.\n\nIn terms of the code's organization, the parameters and ports are first declared with their widths as needed. Then a simple sequential 'always' block is responsible for the summing integration which only occurs on a positive clock edge if the 'strobe' input is high. The result of the integration is then provided on the 'out_data' output port. \n\nOverall, the 'cic_integrator' module is a simple and efficient Verilog implementation of a first-order cumulative summing integrator.",
        "output": "module cic_integrator( clock, strobe, in_data,  out_data );\nparameter WIDTH = 64;\ninput clock;\ninput strobe;\ninput signed [WIDTH-1:0] in_data;\noutput reg signed [WIDTH-1:0] out_data;\nalways @(posedge clock)\n  if (strobe) out_data <= out_data + in_data;\nendmodule"
    }
]