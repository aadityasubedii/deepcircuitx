[
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe dout_monitor module tracks the rising edge of a sample clock signal to increment an address register. Implementation entails two primary blocks: one capturing the previous state of the sample clock using a temporary register, and another using this captured state to detect rising edges and conditionally increment the address, which is reset to 448 on a low reset signal.\nModule head:\n\nmodule dout_monitor(\ninput clk,rst_n,\noutput reg [`ADDRESS_WIDTH-1:0] addr,\ninput [`DATA_WIDTH-1:0] d_ch0,\ninput [`DATA_WIDTH-1:0] d_ch1,\ninput sample_clk\n)",
        "output": "`include \"defines.v\"\nmodule dout_monitor(\ninput clk,rst_n,\noutput reg [`ADDRESS_WIDTH-1:0] addr,\ninput [`DATA_WIDTH-1:0] d_ch0,\ninput [`DATA_WIDTH-1:0] d_ch1,\ninput sample_clk\n);\nreg sample_clk_t;\nalways @(posedge clk)\nbegin\n\tsample_clk_t<=sample_clk;\nend\nalways @(posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\taddr<=10'd448;\n\tend else begin\n\t\tif (sample_clk_t == 1'b0 && sample_clk == 1'b1)\n\t\tbegin\n\t\t\taddr <= addr + 10'd1;\n\t\tend\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe MUX module serves as a multiplexer, choosing between two input signals based on a select signal. Employing parameterizable data width, it outputs either of the inputs (in1 when sel is low and in2 when sel is high) through bitwise operations facilitated by a replicated sel signal (sel1), allowing element-wise selection between in1 and in2.\nModule head:\nmodule MUX #(parameter data_width=32)",
        "output": "module MUX #(parameter data_width=32)\n(input [data_width-1:0] in1,\ninput [data_width-1:0] in2,\ninput sel,\noutput [data_width-1:0] out);\nwire [data_width-1:0] sel1;\nassign sel1[data_width-1:0]={data_width{sel}};\nassign out=(in1&(~sel1))|(in2 & sel1);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe vdcmul_32b module multiplies two 32-bit numbers (x, y) to produce a 64-bit result (prod). It breaks down the multiplication into four 16-bit operations using vdcmul_16b submodules, producing partial products (pp1-pp4). These are combined through three stages of ripple carry adders (rca32b) and a half adder, systematically summing and shifting intermediates to compute the final product, efficiently managing the multiplication of large binary numbers.\nModule head:\n\nmodule vdcmul_32b(\n                   x,\n                   y,\n                   prod\n                   )",
        "output": "`include \"../src/rca32b.v\"\n`include \"../src/half_adder.v\"\nmodule vdcmul_32b(\n                   x,\n                   y,\n                   prod\n                   );\ninput [31:0] x, y;\noutput [63:0] prod;\nwire [31:0] pp1, pp2, pp3, pp4;\nwire c1, c2, c3,s1,ca1;\nwire [31:0] sum1, sum2 ,sum3;\nvdcmul_16b v161(x[15:0], y[15:0], pp1);\nvdcmul_16b v162(x[15:0], y[31:16], pp2);\nvdcmul_16b v163(x[31:16], y[15:0], pp3);\nvdcmul_16b v164(x[31:16], y[31:16], pp4);\nrca32b r321(pp2, pp3, 1'b0, c1, sum1);\nrca32b r322(sum1, {16'b0, pp1[31:16]}, 1'b0, c2, sum2);\nhalf_adder h1(c1,c2,s1,ca1);\nrca32b r323(pp4, {14'b0, ca1,s1, sum2[31:16]}, 1'b0, c3, sum3);\nassign prod = {sum3, sum2[15:0], pp1[15:0]};\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe \"scrambler\" module encodes input data using an LFSR mechanism to minimize electromagnetic interference and balance DC levels in communication systems. It processes data on a positive clock edge with enable control, using a 58-bit state and a dynamically generated history vector for XOR-based scrambling, outputting captured history upper bits.\nModule head:\n\nmodule scrambler # (\n\tparameter WIDTH = 512\n)",
        "output": "`timescale 1 ps / 1 ps\nmodule scrambler # (\n\tparameter WIDTH = 512\n)(\n\tinput clk,arst,ena,\n\tinput [WIDTH-1:0] din,\t\t\n\toutput reg [WIDTH-1:0] dout\n);\nlocalparam SCRAM_INIT = 58'h3ff_ffff_ffff_ffff;\nreg [57:0] scram_state = SCRAM_INIT;\nwire [WIDTH+58-1:0] history;\nassign history [57:0] = scram_state;\ngenvar i;\ngenerate\n\tfor (i=58; i<WIDTH+58; i=i+1) begin : lp\n\t\tassign history[i] = history[i-58] ^ history[i-39] ^ din[i-58];\t\t\n\tend\nendgenerate\nalways @(posedge clk or posedge arst) begin\n\tif (arst) begin\n\t\tdout <= 0;\n\t\tscram_state <= SCRAM_INIT;\n\tend\n\telse if (ena) begin\n\t\tdout <= history[WIDTH+58-1:58];\n\t\tscram_state <= history[WIDTH+58-1:WIDTH];\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Adder16Test module performs the addition of two 16-bit signed numbers in a synchronous digital system. It takes two signed inputs, A and B, and computes their sum on the rising edge of the input clock signal, iClock. The results are stored in an internal register and output through the port C. This ensures that the output remains stable and reflects the current inputs each clock cycle, using sequential and combinational logic within a clock-driven 'always' block and continuous assignment statements.\nModule head:\nmodule Adder16Test(input iClock, \n                   input signed [15:0] A,\n                   input signed [15:0] B, \n                   output signed [15:0]C)",
        "output": "module Adder16Test(input iClock, \n                   input signed [15:0] A,\n                   input signed [15:0] B, \n                   output signed [15:0]C);\nreg signed [15:0] a, b, c;\nassign C = c;\nalways @(posedge iClock) begin\n    a <= A;\n    b <= B;\n    c <= a + b;\nend"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `altpcie_pll_100_250` module configures a PLL for PCIe applications on Stratix GX FPGAs. It utilizes an `altpll` component to generate a stable clock (`c0`) from `inclk0`, using internal wiring and parameters to set conditions like reset, clock enable, and frequency settings tailored to PCIe specifications.\nModule head:\n\nmodule altpcie_pll_100_250 (\n\tareset,\n\tinclk0,\n\tc0)",
        "output": "`timescale 1 ps / 1 ps\nmodule altpcie_pll_100_250 (\n\tareset,\n\tinclk0,\n\tc0);\n\tinput\t  areset;\n\tinput\t  inclk0;\n\toutput\t  c0;\n\twire [5:0] sub_wire0;\n\twire [0:0] sub_wire2 = 1'h0;\n\twire [0:0] sub_wire4 = 1'h1;\n\twire [0:0] sub_wire1 = sub_wire0[0:0];\n\twire  c0 = sub_wire1;\n\twire [5:0] sub_wire3 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire4};\n\twire  sub_wire5 = inclk0;\n\twire [1:0] sub_wire6 = {sub_wire2, sub_wire5};\n\twire [3:0] sub_wire7 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2};\n\taltpll\taltpll_component (\n\t\t\t\t.clkena (sub_wire3),\n\t\t\t\t.inclk (sub_wire6),\n\t\t\t\t.extclkena (sub_wire7),\n\t\t\t\t.areset (areset),\n\t\t\t\t.clk (sub_wire0)\n\t\t\t\t,\n\t\t\t\t.scanclk (),\n\t\t\t\t.pllena (),\n\t\t\t\t.sclkout1 (),\n\t\t\t\t.sclkout0 (),\n\t\t\t\t.fbin (),\n\t\t\t\t.scandone (),\n\t\t\t\t.clkloss (),\n\t\t\t\t.extclk (),\n\t\t\t\t.clkswitch (),\n\t\t\t\t.pfdena (),\n\t\t\t\t.scanaclr (),\n\t\t\t\t.clkbad (),\n\t\t\t\t.scandata (),\n\t\t\t\t.enable1 (),\n\t\t\t\t.scandataout (),\n\t\t\t\t.enable0 (),\n\t\t\t\t.scanwrite (),\n\t\t\t\t.locked (),\n\t\t\t\t.activeclock (),\n\t\t\t\t.scanread ()\n\t\t\t\t);\n\tdefparam\n\t\taltpll_component.bandwidth = 500000,\n\t\taltpll_component.bandwidth_type = \"CUSTOM\",\n\t\taltpll_component.clk0_divide_by = 2,\n\t\taltpll_component.clk0_duty_cycle = 50,\n\t\taltpll_component.clk0_multiply_by = 5,\n\t\taltpll_component.clk0_phase_shift = \"0\",\n\t\taltpll_component.compensate_clock = \"CLK0\",\n\t\taltpll_component.inclk0_input_frequency = 10000,\n\t\taltpll_component.intended_device_family = \"Stratix GX\",\n\t\taltpll_component.lpm_type = \"altpll\",\n\t\taltpll_component.operation_mode = \"NORMAL\",\n\t\taltpll_component.pll_type = \"ENHANCED\",\n\t\taltpll_component.spread_frequency = 0;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'spdutb' module functions as a testbench for evaluating the 'spd' module. It provides binary data and configuration settings via inputs d0-d3 and pm0-pm3, controls operation with 'clk' and 'reset', and assesses outputs through the 'out' port. The test initiates with default settings, toggles operational signals, and leverages a clock cycle for precise timing, concluding with simulation monitoring after 330 ns.\nModule head:\n\nmodule spdutb;\n    reg \td0, d1, d2, d3;\n    reg [3:0]\tpm0, pm1, pm2, pm3;\n    reg \tclk, reset;\n    wire \tout;\n    spd spd1(d0, d1, d2, d3, pm0, pm1, pm2, pm3, out, clk, reset)",
        "output": "`timescale 1ns/10ps\n`include \"spdu.v\"\nmodule spdutb;\n    reg \td0, d1, d2, d3;\n    reg [3:0]\tpm0, pm1, pm2, pm3;\n    reg \tclk, reset;\n    wire \tout;\n    spd spd1(d0, d1, d2, d3, pm0, pm1, pm2, pm3, out, clk, reset);\n    always #5 clk = ~clk;\n    initial #330 $finish;\n    initial\n        begin\n            clk=0;\n\t    pm0=4'd1; pm1=4'd1; pm2=4'd0; pm3=4'd1;\n            d0=1'b0; d1=1'b1; d2=1'b0; d3=1'b1; \n\t    reset=1'b1;\n\t    #10;\n\t    reset=1'b0;\n\t    #10;\n        end\ninitial\n    begin\n\t$shm_open(\"spdu.shm\");\n\t$shm_probe(\"AC\");\t\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe MIPS_Top module serves as the top-level entity in a MIPS processor, coordinating operations for fetching, decoding, and executing instructions. It integrates a Data Path module (`Data_Path`) which handles computational and data flow and a Control Unit (`Control_Unit`) which dictates control signals based on current instructions. Key to its operation are input signals including instruction, clock, reset, and data read; and outputs such as the program counter, ALU result, and data write-back signals, alongside internal controls for execution paths and data handling.\nModule head:\nmodule MIPS_Top (\ninput   wire   [31:0]     Instr,\ninput   wire              clk,rst,\ninput   wire   [31:0]     RD,\noutput  wire   [31:0]     PC,ALUResult,WD,\noutput  wire              MemWrite\n)",
        "output": "module MIPS_Top (\ninput   wire   [31:0]     Instr,\ninput   wire              clk,rst,\ninput   wire   [31:0]     RD,\noutput  wire   [31:0]     PC,ALUResult,WD,\noutput  wire              MemWrite\n);\nwire             MemtoReg,Branch,ALUSrc,RegDst,RegWrite,Jump,zero,PCSrc;\nwire   [2:0]     ALU_Control;\nData_Path UDP (\n.Instr(Instr),\n.clk(clk),\n.rst(rst),\n.RD(RD),\n.MemtoReg(MemtoReg),\n.Branch(Branch),\n.ALUSrc(ALUSrc),\n.RegDst(RegDst),\n.RegWrite(RegWrite),\n.Jump(Jump),\n.zero(zero),\n.ALU_Control(ALU_Control),\n.PC(PC),\n.ALUResult(ALUResult),\n.WD(WD),\n.PCSrc(PCSrc)\n);\nControl_Unit UCU (\n.Instr(Instr),\n.MemtoReg(MemtoReg),\n.Branch(Branch),\n.ALUSrc(ALUSrc),\n.RegDst(RegDst),\n.RegWrite(RegWrite),\n.Jump(Jump),\n.MemWrite(MemWrite),\n.ALU_Control(ALU_Control),\n.PCSrc(PCSrc),\n.zero(zero)\n);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'cntr_updn' module is a configurable up/down counter with control features, operating on a positive clock edge and enabled signal. It supports asynchronous reset, data loading, and clear functionality. The counter increments or decrements based on an input flag. Implementation involves a synchronous always block, handling reset, enable, clear, data load commands, and direction-based counting, utilizing internal registers for storing and manipulating the counter value.\nModule head:\nmodule cntr_updn (clk,ena,rst,sload,sdata,sclear,inc_not_dec,q)",
        "output": "module cntr_updn (clk,ena,rst,sload,sdata,sclear,inc_not_dec,q);\nparameter WIDTH = 16;\ninput clk,ena,rst,sload,sclear,inc_not_dec;\ninput [WIDTH-1:0] sdata;\noutput [WIDTH-1:0] q;\nreg [WIDTH-1:0] q;\nalways @(posedge clk or posedge rst) begin\n\tif (rst) q <= 0;\n\telse begin\n\t\tif (ena) begin\n\t\t\tif (sclear) q <= 0;\n\t\t\telse if (sload) q <= sdata;\n\t\t\telse q <= q + (inc_not_dec ? 1'b1 : {WIDTH{1'b1}});\n\t\tend\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe interleaver module generates a pseudo-random 16-bit sequence using a clock (`clk`) and reset (`rst`) control. On reset, internal states (`out`, `interleaver_temp`) are zeroed; otherwise, `interleaver_temp` accumulates an increment of `f2*2` each clock cycle, and `out` is updated using modular arithmetic involving `interleaver_temp`, `f1`, `f2`, and a defined `CODELENGTH`, ensuring output consistency within bounds. The result is then delivered through `interleaver_output`.\nModule head:\n\nmodule interleaver(\nclk,\nrst,\ninterleaver_output\n)",
        "output": "`define CODELENGTH 256\n`define f1 15\n`define f2 32\n`timescale 1ns / 1ps\nmodule interleaver(\nclk,\nrst,\ninterleaver_output\n);\ninput clk;\ninput rst;\noutput [15:0]interleaver_output;\nwire [15:0]interleaver_output;\nreg [15:0] out;\nreg [15:0]interleaver_temp;\nalways @(posedge clk or posedge rst)\nbegin\n  if(rst==1)\n    begin\n     out<=0;\n     interleaver_temp<=0;\n    end\n  else\n    begin\n     interleaver_temp<=interleaver_temp+`f2*2;\n     out<=(out+interleaver_temp+`f1+`f2)%`CODELENGTH;\n    end\nend\nassign interleaver_output=out;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe module 'crypt_TestBench' tests the 'crypt' module by stimulating it with diverse inputs and verifying resultant ciphers. Inputs include control signal 'enable', data 'q_in', and keys 'key_1' and 'key_2'. It generates output 'cipher' post encryption/decryption and 'debug' for module state. The internals of the 'crypt' module are stimulated in a series of test case scenarios, controlling the 'enable' signal and comparing output 'cipher' with expected values.\nModule head:\nmodule crypt_TestBench; \nreg \tenable; \nreg\t\t[7:0] q_in; \nreg\t\t[7:0] key_1; \nreg\t\t[7:0] key_2; \nwire\t[7:0] cipher; \nwire\t[3:0] debug; \ncrypt uut (\n\t.enable(enable),\n\t.q_in(q_in),\n\t.key_1(key_1),\n\t.key_2(key_2),\n\t.cipher(cipher),\n\t.debug(debug))",
        "output": "module crypt_TestBench; \nreg \tenable; \nreg\t\t[7:0] q_in; \nreg\t\t[7:0] key_1; \nreg\t\t[7:0] key_2; \nwire\t[7:0] cipher; \nwire\t[3:0] debug; \ncrypt uut (\n\t.enable(enable),\n\t.q_in(q_in),\n\t.key_1(key_1),\n\t.key_2(key_2),\n\t.cipher(cipher),\n\t.debug(debug));\ninitial \n\tbegin\n$display(\"Commencing test procedure...\");\nenable = 0; #50; enable = 1; #50; \n\tenable = 0; q_in = 8'b11110000; \t\t\t\n\tkey_1 = 8'b11100100; key_2 = 8'b01010011; \n\t#50; \n\tif(cipher != 8'b01011001) $display(\"ERROR: cipher does not match in case 1!\"); \n\telse  $display(\"PASS: case 1!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10101010; \t\t\t\n\tkey_1 = 8'b11100100; key_2 = 8'b01010011; \n\t#50; \n\tif(cipher != 8'b01101011) $display(\"ERROR: cipher does not match in case 2!\"); \n\telse  $display(\"PASS: case 2!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b11111110; \t\t\t\n\tkey_1 = 8'b11011111; key_2 = 8'b11111001; \n\t#50; \n\tif(cipher != 8'b11100110) $display(\"ERROR: cipher does not match in case 3!\"); \n\telse  $display(\"PASS: case 3!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b01111111; \t\t\t\n\tkey_1 = 8'b11111001; key_2 = 8'b11011111; \n\t#50; \n\tif(cipher != 8'b00000000) $display(\"ERROR: cipher does not match in case 4!\"); \n\telse  $display(\"PASS: case 4!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10011001; \t\t\t\n\tkey_1 = 8'b10010100; key_2 = 8'b01010101; \n\t#50; \n\tif(cipher != 8'b00111100) $display(\"ERROR: cipher does not match in case 5!\"); \n\telse  $display(\"PASS: case 5!\"); \n\tenable = 1; #50;\n\tenable = 0; q_in = 8'b10101010; \t\t\t\n\tkey_1 = 8'b01010101; key_2 = 8'b10010100; \n\t#50; \n\tif(cipher != 8'b01111010) $display(\"ERROR: cipher does not match in case 6!\"); \n\telse  $display(\"PASS: case 6!\"); \n$display(\"Testing procedure completed!\");\n\tend\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe vdcmul_16b module performs 16-bit by 16-bit multiplication to output a 32-bit product. It processes the inputs through four 8-bit multipliers for partial products and uses three 16-bit Ripple Carry Adders and a half-adder for summing and carry management, assembling the final product from computed sums and partial products efficiently.\nModule head:\n\nmodule vdcmul_16b(\n                   x,\n                   y,\n                   prod\n                   )",
        "output": "`include \"../src/rca16b.v\"\n`include \"../src/half_adder.v\"\nmodule vdcmul_16b(\n                   x,\n                   y,\n                   prod\n                   );\ninput [15:0] x, y;\noutput [31:0] prod;\nwire [15:0] pp1, pp2, pp3, pp4;\nwire c1, c2, c3,s1,ca1;\nwire [15:0] sum1, sum2 ,sum3;\nvdcmul_8b v81(x[7:0], y[7:0], pp1);\nvdcmul_8b v82(x[7:0], y[15:8], pp2);\nvdcmul_8b v83(x[15:8], y[7:0], pp3);\nvdcmul_8b v84(x[15:8], y[15:8], pp4);\nrca16b r161(pp2, pp3, 1'b0, c1, sum1);\nrca16b r162(sum1, {8'b0, pp1[15:8]}, 1'b0, c2, sum2);\nhalf_adder h1(c1,c2,s1,ca1);\nrca16b r163(pp4, {6'b0, ca1,s1, sum2[15:8]}, 1'b0, c3, sum3);\nassign prod = {sum3, sum2[7:0], pp1[7:0]};\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe generic_sram_byte_en module simulates a parameterized SRAM with selective byte enable functionality, enabling partial updates of stored data without overwriting entire data words. It uses input signals for address, data, and byte-specific write enables to control write operations, while outputting the current data based on the specified memory address. During reset, it initializes the memory array either to all zeros or ones based on a configuration parameter. The module supports clocked operations and includes provisions for test modes and scan chain integration.\nModule head:\nmodule generic_sram_byte_en\n#(\n    parameter DATA_WIDTH    = 128,\n    parameter ADDRESS_WIDTH = 10,\n    parameter INITIALIZE_TO_ZERO = 2 \n)",
        "output": "module generic_sram_byte_en\n#(\n    parameter DATA_WIDTH    = 128,\n    parameter ADDRESS_WIDTH = 10,\n    parameter INITIALIZE_TO_ZERO = 2 \n)\n(\n    input                       reset,          \n    input                       clk,            \n    input                       test_mode,      \n    input                       scan_enable,    \n    input                       scan_in0,       \n    input                       scan_in1,       \n    input                       scan_in2,       \n    input                       scan_in3,       \n    input                       scan_in4,       \n    output                      scan_out0,      \n    output                      scan_out1,      \n    output                      scan_out2,      \n    output                      scan_out3,      \n    output                      scan_out4,      \n    input      [DATA_WIDTH-1:0]     i_write_data,\n    input                           i_write_enable,\n    input      [ADDRESS_WIDTH-1:0]  i_address,\n    input      [DATA_WIDTH/8-1:0]   i_byte_enable,\n    output reg [DATA_WIDTH-1:0]     o_read_data\n    );                                                     \nreg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\ninteger i;\ninteger j;\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n      if (INITIALIZE_TO_ZERO) begin\n        o_read_data <= {DATA_WIDTH{1'b0}};\n        for (j = 0; j < (2**ADDRESS_WIDTH); j = j + 1) begin\n            mem[j] <= (INITIALIZE_TO_ZERO == 2) ? {DATA_WIDTH{1'b1}} : {DATA_WIDTH{1'b0}};\n        end\n      end\n    end\n    else begin\n        o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n        if (i_write_enable) begin\n            for (i=0;i<DATA_WIDTH/8;i=i+1) begin\n                mem[i_address][i*8+0] <= i_byte_enable[i] ? i_write_data[i*8+0] : mem[i_address][i*8+0] ;\n                mem[i_address][i*8+1] <= i_byte_enable[i] ? i_write_data[i*8+1] : mem[i_address][i*8+1] ;\n                mem[i_address][i*8+2] <= i_byte_enable[i] ? i_write_data[i*8+2] : mem[i_address][i*8+2] ;\n                mem[i_address][i*8+3] <= i_byte_enable[i] ? i_write_data[i*8+3] : mem[i_address][i*8+3] ;\n                mem[i_address][i*8+4] <= i_byte_enable[i] ? i_write_data[i*8+4] : mem[i_address][i*8+4] ;\n                mem[i_address][i*8+5] <= i_byte_enable[i] ? i_write_data[i*8+5] : mem[i_address][i*8+5] ;\n                mem[i_address][i*8+6] <= i_byte_enable[i] ? i_write_data[i*8+6] : mem[i_address][i*8+6] ;\n                mem[i_address][i*8+7] <= i_byte_enable[i] ? i_write_data[i*8+7] : mem[i_address][i*8+7] ;\n            end\n        end\n    end                                                \nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Enc8B10B module encodes 8-bit data into a 10-bit format using 8B/10B encoding, which balances binary signal transmission. It leverages internal blocks like fcn5b, fcn3b for initial encoding, and fcn5b6b, fcn3b4b for final encoding output, controlled by synchronous logic tied to the BYTECLK signal, managing disparity and control inputs through additional intermediate processing units like disCtrl.\nModule head:\n\nmodule Enc8B10B(\n    input BYTECLK, \n    input reset,\n    input bit_control,\n    input [7:0] in,\n    output [9:0] out,\n    output rd_out\n    )",
        "output": "`timescale 1ns / 1ps\nmodule Enc8B10B(\n    input BYTECLK, \n    input reset,\n    input bit_control,\n    input [7:0] in,\n    output [9:0] out,\n    output rd_out\n    );\n    wire clk = BYTECLK; \n    wire rd_in_s4, S, COMPLS6, COMPLS4, saved_K;\n    wire [4:0] L, saved_L;    \n    wire [7:0] saved_data_in;\n    wire [5:0] abcdei;\n    wire [3:0] fghj; \n    reg [7:0] data_in;\n    reg K, rd_in;\n    fcn5b   f5b(clk, data_in[4:0], L);\n    fcn3b   f3b(clk, data_in[4:3], rd_in_s4, L, S); \n    disCtrl dis(clk, reset, K, L, S, data_in, rd_in, saved_data_in, saved_L, saved_K, rd_in_s4, COMPLS6, COMPLS4, rd_out);\n    fcn5b6b f56(clk, reset, saved_data_in[4:0], saved_L, saved_K, COMPLS6, abcdei);\n    fcn3b4b f34(clk, reset, saved_data_in[7:5], S, saved_K, COMPLS4, fghj);\n    always @(posedge clk)\n    begin\n        if (reset) begin \n            K <= 0;\n            rd_in = 0;\n            data_in = 0;\n        end\n        else begin \n            K <= bit_control;\n            rd_in = rd_out;\n            data_in = in;\n        end\n    end\n    assign out = {abcdei[5:0], fghj[3:0]}; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe load_stream module processes 64-bit coded signal streams, handling 'FF' markers by inserting zero bits into the data for alignment. It uses registers (`code_64`, `len_64`) and intermediate wires (`code_temp`, `code_tmp1`-`code_tmp4`) to shift, mask, and check conditions in the stream per clock cycle. Outputs include a processed 32-bit code packet (`code_out`), and status signals (`en_out`, `cod_32`, `len_32`). The functionality is controlled by clock (`clk`), enable (`en`), and reset (`reset`) signals.\nModule head:\n\nmodule load_stream(clk, en, reset, codes, len, code_out, en_out,cod_32,len_32)",
        "output": "`timescale 1ns / 1ps\nmodule load_stream(clk, en, reset, codes, len, code_out, en_out,cod_32,len_32);\n    input clk;\n    input en;\n    input reset;\n    input [63:0] codes;\n    input [6:0] len;\n    output [31:0] code_out;\n    output en_out;\n    output [31:0] cod_32;\n\t output [5:0] len_32;\n\t reg [31:0] code_out;\n    reg en_out;\n\t reg [63:0] code_64;\n\t reg [6:0] len_64;\n\t wire [63:0] code_temp;\n\t wire [63:0] code_temp_2;\n\t wire [6:0] len_tmp;\nassign    #1    code_temp_2=codes>>(len_64);\t \nassign\t#1\t   code_temp=code_64|code_temp_2;\nassign\t#1\t\tlen_tmp=len_64+len;\nwire [63:0] code_tmp1,code_tmp2,code_tmp3,code_tmp4;\nwire [6:0]  len_1,len_2,len_3,len_4; \nwire en_1,en_2,en_3,en_4;\nassign #1 en_1=(len_tmp>=32)&&(code_temp[63:56]==8'hFF);\nassign #1 en_2=(len_tmp>=32)&&(code_tmp1[55:48]==8'hFF);\nassign #1 en_3=(len_tmp>=32)&&(code_tmp2[47:40]==8'hFF);\nassign #1 en_4=(len_tmp>=32)&&(code_tmp3[39:32]==8'hFF);\n   assign #1 code_tmp1=en_1?{code_temp[63:56],1'b0,code_temp[55:1]}:code_temp;\n\tassign #1 len_1    =en_1?(len_tmp+1):len_tmp;\n   assign #1 code_tmp2=en_2?{code_tmp1[63:48],1'b0,code_tmp1[47:1]}:code_tmp1;\n\tassign #1 len_2    =en_2?(len_1+1):len_1;\n\tassign #1 code_tmp3=en_3?{code_tmp2[63:40],1'b0,code_tmp2[39:1]}:code_tmp2;\n\tassign #1 len_3    =en_3?(len_2+1):len_2;\n\tassign #1 code_tmp4=en_4?{code_tmp3[63:32],1'b0,code_tmp3[31:1]}:code_tmp3;\n\tassign #1 len_4    =en_4?(len_3+1):len_3;\n\talways@(posedge clk or negedge reset)\n\t if(!reset)\n\t  begin\n\t  code_out<=0;\n\t  en_out<=0;\n\t  code_64<=0;\n\t  len_64<=0;\n\t  end\n\t else if(en)\n\t   begin\n\t\t  if(len_4>=32)\n\t\t    begin\n\t\t\t  code_64<=(code_tmp4<<32);\n\t\t     len_64<=len_4-32;\n\t\t     code_out<=code_tmp4[63:32];\n\t\t     en_out<=1;\n\t\t    end\n\t\t  else \n\t\t    begin\n\t\t\t  code_64<=code_tmp4;\n\t\t     len_64<=len_4;\n\t\t     code_out<=0;\n\t\t     en_out<=0;\n\t\t   end\n\t\tend\n\t else \n\t   begin\n\t\tcode_out<=0;\n\t   en_out<=0;\n\t   code_64<=code_64;\n\t   len_64<=len_64;\n\t\tend\n assign\tcod_32=code_64[63:32];\n assign  len_32=len_64[5:0]; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `top_small` module serves as an interface layer for the `picorv32` microprocessor, handling signal routing between the core and external memory. It operates on input signals like `clk` for synchronization and `resetn` for system resets, and manages memory interaction signals like `mem_valid` and `mem_addr`. The module directly connects these interface signals to the corresponding inputs and outputs of the instantiated `picorv32` core, which is configured with basic settings, emphasizing straightforward signal passage and basic memory operation management without extra internal logic.\nModule head:\nmodule top_small (\n\tinput clk, resetn,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata\n)",
        "output": "module top_small (\n\tinput clk, resetn,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata\n);\n\tpicorv32 #(\n\t\t.ENABLE_COUNTERS(0),\n\t\t.LATCHED_MEM_RDATA(1),\n\t\t.TWO_STAGE_SHIFT(0),\n\t\t.CATCH_MISALIGN(0),\n\t\t.CATCH_ILLINSN(0)\n\t) picorv32 (\n\t\t.clk      (clk      ),\n\t\t.resetn   (resetn   ),\n\t\t.mem_valid(mem_valid),\n\t\t.mem_instr(mem_instr),\n\t\t.mem_ready(mem_ready),\n\t\t.mem_addr (mem_addr ),\n\t\t.mem_wdata(mem_wdata),\n\t\t.mem_wstrb(mem_wstrb),\n\t\t.mem_rdata(mem_rdata)\n\t);\nendmodule\nmodule top_regular (\n\tinput clk, resetn,\n\toutput trap,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata,\n\toutput        mem_la_read,\n\toutput        mem_la_write,\n\toutput [31:0] mem_la_addr,\n\toutput [31:0] mem_la_wdata,\n\toutput [ 3:0] mem_la_wstrb\n);\n\tpicorv32 picorv32 (\n\t\t.clk         (clk         ),\n\t\t.resetn      (resetn      ),\n\t\t.trap        (trap        ),\n\t\t.mem_valid   (mem_valid   ),\n\t\t.mem_instr   (mem_instr   ),\n\t\t.mem_ready   (mem_ready   ),\n\t\t.mem_addr    (mem_addr    ),\n\t\t.mem_wdata   (mem_wdata   ),\n\t\t.mem_wstrb   (mem_wstrb   ),\n\t\t.mem_rdata   (mem_rdata   ),\n\t\t.mem_la_read (mem_la_read ),\n\t\t.mem_la_write(mem_la_write),\n\t\t.mem_la_addr (mem_la_addr ),\n\t\t.mem_la_wdata(mem_la_wdata),\n\t\t.mem_la_wstrb(mem_la_wstrb)\n\t);\nendmodule\nmodule top_large (\n\tinput clk, resetn,\n\toutput trap,\n\toutput        mem_valid,\n\toutput        mem_instr,\n\tinput         mem_ready,\n\toutput [31:0] mem_addr,\n\toutput [31:0] mem_wdata,\n\toutput [ 3:0] mem_wstrb,\n\tinput  [31:0] mem_rdata,\n\toutput        mem_la_read,\n\toutput        mem_la_write,\n\toutput [31:0] mem_la_addr,\n\toutput [31:0] mem_la_wdata,\n\toutput [ 3:0] mem_la_wstrb,\n\toutput        pcpi_valid,\n\toutput [31:0] pcpi_insn,\n\toutput [31:0] pcpi_rs1,\n\toutput [31:0] pcpi_rs2,\n\tinput         pcpi_wr,\n\tinput  [31:0] pcpi_rd,\n\tinput         pcpi_wait,\n\tinput         pcpi_ready,\n\tinput  [31:0] irq,\n\toutput [31:0] eoi\n);\n\tpicorv32 #(\n\t\t.COMPRESSED_ISA(1),\n\t\t.BARREL_SHIFTER(1),\n\t\t.ENABLE_PCPI(1),\n\t\t.ENABLE_MUL(1),\n\t\t.ENABLE_IRQ(1)\n\t) picorv32 (\n\t\t.clk            (clk            ),\n\t\t.resetn         (resetn         ),\n\t\t.trap           (trap           ),\n\t\t.mem_valid      (mem_valid      ),\n\t\t.mem_instr      (mem_instr      ),\n\t\t.mem_ready      (mem_ready      ),\n\t\t.mem_addr       (mem_addr       ),\n\t\t.mem_wdata      (mem_wdata      ),\n\t\t.mem_wstrb      (mem_wstrb      ),\n\t\t.mem_rdata      (mem_rdata      ),\n\t\t.mem_la_read    (mem_la_read    ),\n\t\t.mem_la_write   (mem_la_write   ),\n\t\t.mem_la_addr    (mem_la_addr    ),\n\t\t.mem_la_wdata   (mem_la_wdata   ),\n\t\t.mem_la_wstrb   (mem_la_wstrb   ),\n\t\t.pcpi_valid     (pcpi_valid     ),\n\t\t.pcpi_insn      (pcpi_insn      ),\n\t\t.pcpi_rs1       (pcpi_rs1       ),\n\t\t.pcpi_rs2       (pcpi_rs2       ),\n\t\t.pcpi_wr        (pcpi_wr        ),\n\t\t.pcpi_rd        (pcpi_rd        ),\n\t\t.pcpi_wait      (pcpi_wait      ),\n\t\t.pcpi_ready     (pcpi_ready     ),\n\t\t.irq            (irq            ),\n\t\t.eoi            (eoi            )\n\t);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'mult_control' module manages a stepped computation for a multiplier unit using a finite state machine (FSM) with states IDLE, LSB, MID, MSB, CALC_DONE, and ERR. It transitions between states based on 'start' and 'count' inputs, controlling operations like input selection and shifting. Outputs are determined in a combinational logic block, with `state_reg` updating at each clock edge based on `state_next`, which is set dynamically per state and input conditions.\nModule head:\n\nmodule mult_control(\ninput clk,reset_a,start,\ninput [1:0] count,\noutput reg [1:0] input_sel,shift_sel,\noutput  [2:0] state_out,\noutput reg done,clk_ena,sclr_n\n)",
        "output": "`timescale 1ns / 1ps\nmodule mult_control(\ninput clk,reset_a,start,\ninput [1:0] count,\noutput reg [1:0] input_sel,shift_sel,\noutput  [2:0] state_out,\noutput reg done,clk_ena,sclr_n\n);\nreg [2:0] state_reg,state_next;\nlocalparam IDLE=3'b000;\nlocalparam LSB=3'b001; \nlocalparam MID=3'b010; \nlocalparam MSB=3'b011; \nlocalparam CALC_DONE=3'b100; \nlocalparam ERR=3'b101; \nalways@(posedge clk,negedge reset_a)\nbegin\nif(~ reset_a)\n\tstate_reg<=IDLE;\nelse\n\tstate_reg<=state_next;\nend\nalways@(*)\nbegin\ndone = 1'b0 ;\nclk_ena = 1'b0 ;\nsclr_n = 1'b1 ;\ninput_sel = 2'bxx ;\nshift_sel =2'bxx ;\n\tcase(state_reg)\n\t\tIDLE: begin\n\t\tif(start) begin\n\t\t\tstate_next=LSB;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b0 ;\n\t\t\tend\n\t\t  else\n\t         state_next=IDLE;\n\t      end\n  \t\tLSB: begin\n  \t\tif(start==0 && count==2'b00) begin\n\t\t\tstate_next=MID;\n\t\t\tinput_sel = 2'b00 ;\n            shift_sel =2'b00 ;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\telse\n\t       state_next=ERR;\n\t    end\n\t\tMID : begin\n\t\tif(start==0 && count==2'b01) begin\n\t\t\tstate_next=MID;\n\t\t\tinput_sel = 2'b01 ;\n            shift_sel =2'b01 ;\n            clk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\t     else if(start==0 && count==2'b10) begin\n\t\t\tstate_next=MSB;\n\t\t\tinput_sel = 2'b10 ;\n            shift_sel =2'b01 ;\n            clk_ena = 1'b1 ;\n            sclr_n = 1'b1 ;\n\t\t\tend\n\t\t     else\n\t\t\tstate_next=ERR;\n\t      end\n\t\tMSB:\n\t\tif(start==0 && count==2'b11) begin\n\t\t\tstate_next=CALC_DONE;\n\t\t\tinput_sel = 2'b11 ;\n            shift_sel =2'b10 ;\n            clk_ena = 1'b1 ;\n             sclr_n = 1'b1 ;\n\t\t\tend\n\t\t   else\n\t        state_next=ERR;\n \t\tCALC_DONE:\n \t\t if(start==0) begin\n\t\t\tstate_next=IDLE;\n\t\t\tdone = 1'b1 ;\n\t\t\tclk_ena = 1'b0 ;\n            sclr_n = 1'b1 ;\n\t      end\n\t\t  else\n\t        state_next=ERR;\n\t\tERR:\n\t\tif(start) begin\n\t\t\tstate_next=LSB;\n\t\t\tclk_ena = 1'b1 ;\n            sclr_n = 1'b0 ;\n\t\t\tend\n\t\t   else\n\t        state_next=ERR;\n\t\tdefault:state_next=state_reg;\n\tendcase\nend\nassign state_out = state_reg ;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe and_gate module models a basic digital logic AND gate. It takes two binary inputs 'a' and 'b', and produces an output 'y', which is the logical AND of the inputs. The functionality is achieved by a direct connection between the inputs and the AND operation, with the result directly assigned to the output. No internal signals are used within this compact and straightforward implementation.\nModule head:\nmodule and_gate(y, a, b)",
        "output": "module and_gate(y, a, b);\n    input a, b;\n    output y;\n    and(y, a, b);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'maquina_estados_cond' module is a state machine in Verilog for managing hardware operations across RESET, INIT, IDLE, ACTIVE, and ERROR states, based on inputs like thresholds and FIFO status. It uses clock-synchronized state transitions and internal logic within combinational and sequential blocks to update operational states and outputs accordingly.\nModule head:\nmodule maquina_estados_cond\n   (\n    input clk,\n    input init,\n    input [3:0] UmbralesMFs,\n    input [31:0] UmbralesVCs,\n    input [7:0] UmbralesDs,\n\tinput reset,\n\tinput [4:0] FIFO_EMPTIES,\n    input [4:0] FIFO_ERRORS,\n\toutput reg error_out_cond,\n    output reg active_out_cond,\n    output reg idle_out_cond,\n    output reg [3:0] UmbralMF_cond,\n    output reg [15:0] UmbralV0_cond,\n    output reg [15:0] UmbralV1_cond,\n    output reg [3:0] UmbralD0_cond,\n    output reg [3:0] UmbralD1_cond,\n    output reg [4:0] error_full_cond)",
        "output": "module maquina_estados_cond\n   (\n    input clk,\n    input init,\n    input [3:0] UmbralesMFs,\n    input [31:0] UmbralesVCs,\n    input [7:0] UmbralesDs,\n\tinput reset,\n\tinput [4:0] FIFO_EMPTIES,\n    input [4:0] FIFO_ERRORS,\n\toutput reg error_out_cond,\n    output reg active_out_cond,\n    output reg idle_out_cond,\n    output reg [3:0] UmbralMF_cond,\n    output reg [15:0] UmbralV0_cond,\n    output reg [15:0] UmbralV1_cond,\n    output reg [3:0] UmbralD0_cond,\n    output reg [3:0] UmbralD1_cond,\n    output reg [4:0] error_full_cond);\nreg [2:0] estado;\nreg [2:0] estado_prox;\nreg [3:0] UmbralMF;\nreg [15:0] UmbralV0;\nreg [15:0] UmbralV1;\nreg [3:0] UmbralD0;\nreg [3:0] UmbralD1;\nparameter RESET = 0;\nparameter INIT = 1;\nparameter IDLE = 2;\nparameter ACTIVE = 3;\nparameter ERROR = 4;\nalways @(posedge clk) begin\n    if(reset==0) begin\n        estado <= RESET;\n    end\n    else begin \n        estado<=estado_prox;\n    end\nend\nalways @(*) begin\n    estado_prox=estado;\n    error_out_cond=0;\n    active_out_cond=0;\n    idle_out_cond=0;\n    error_full_cond=0;\n    UmbralMF=UmbralesMFs;\n    UmbralV0=UmbralesVCs[31:16];\n    UmbralV1=UmbralesVCs[15:0];\n    UmbralD0=UmbralesDs[7:4];\n    UmbralD1=UmbralesDs[3:0];\n    if(reset==0)begin\n    UmbralMF_cond=0;\n    UmbralV0_cond=0;\n    UmbralV1_cond=0;\n    UmbralD0_cond=0;\n    UmbralD1_cond=0;\n    end else begin\n    UmbralMF_cond=UmbralMF;\n    UmbralV0_cond=UmbralV0;\n    UmbralV1_cond=UmbralV1;\n    UmbralD0_cond=UmbralD0;\n    UmbralD1_cond=UmbralD1;\n    end\n    case (estado)\n        RESET: begin\n            active_out_cond=0;\n            error_out_cond=0;\n            idle_out_cond=0;\n            error_full_cond=0;\n            UmbralMF_cond=0;\n            UmbralV0_cond=0;\n            UmbralV1_cond=0;\n            UmbralD0_cond=0;\n            UmbralD1_cond=0;\n            if(reset==0)begin\n                if(init==1)\n                estado_prox=INIT;\n            end else\n                estado_prox=INIT;\n        end\n        INIT: begin\n            error_out_cond=0;\n            idle_out_cond=0;\n            active_out_cond=0;\n            error_full_cond=0;\n            UmbralMF=UmbralesMFs;\n            UmbralV0=UmbralesVCs[31:16];\n            UmbralV1=UmbralesVCs[15:0];\n            UmbralD0=UmbralesDs[7:4];\n            UmbralD1=UmbralesDs[3:0];\n            if(reset==0)\n                estado_prox=RESET;\n            else if(init==1)\n                estado_prox=INIT;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES==4'b0)\n                estado_prox= IDLE;\n            else\n                estado_prox = INIT;\n        end\n        IDLE: begin\n            error_out_cond=0;\n            idle_out_cond=1;\n            active_out_cond=0;\n            error_full_cond=0;\n            if(reset==0)\n                estado_prox=RESET;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES!=4'b0)\n                estado_prox=ACTIVE;\n            else\n                estado_prox=IDLE;\n        end\n        ERROR: begin\n            idle_out_cond=0;\n            error_out_cond=1;\n            active_out_cond=0;\n            error_full_cond= FIFO_ERRORS;\n            if(reset==0)\n                estado_prox=RESET;\n            else \n                estado_prox=ERROR;\n        end\n        ACTIVE: begin\n            error_out_cond=0;\n            idle_out_cond=0;\n            active_out_cond=1;\n            if(reset==0)\n                estado_prox=RESET;\n            else if(init==1)\n                estado_prox=INIT;\n            else if(FIFO_ERRORS!=4'b0)\n                estado_prox=ERROR;\n            else if(FIFO_EMPTIES==4'b0)\n                estado_prox= IDLE;\n            else\n                estado_prox=ACTIVE;\n        end\n    endcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe IOBUF_LVDCI_18 module manages bidirectional data flow on an IO line using LVDCI_18 logic levels, suitable for systems requiring shared line management. It uses an input 'I' and a tri-state control 'T' to conditionally drive or release the 'IO' port, governed by the internal logic. The output 'O' mirrors the IO line's state, which is controlled via an OR gate that determines the 'ts' signal based on 'T' and a global tri-state 'GTS', ensuring 'IO' is either actively driven by 'I' or set to high-impedance.\nModule head:\n\nmodule IOBUF_LVDCI_18 (O, IO, I, T)",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_LVDCI_18 (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe VGA_Ctrl module controls VGA display operation by taking in color intensities, a system clock, and a reset signal as inputs. It generates VGA-based output signals including color levels, coordinates, address, request, sync, blank, and inverted clock signals, thereby handling color display, pixel requests, and synchronization tasks. Internal counters H_Cont and V_Cont track the current pixel position, driving computations and controls. Timings for VGA operation are defined in parameters. The procedural blocks handle counters advancement and sync signals control.\nModule head:\nmodule\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toShift_Flag,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t)",
        "output": "module\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toShift_Flag,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t);\ninput\t\t[9:0]\tiRed;\ninput\t\t[9:0]\tiGreen;\ninput\t\t[9:0]\tiBlue;\noutput\t\t[21:0]\toAddress;\noutput\t\t[10:0]\toCurrent_X;\noutput\t\t[10:0]\toCurrent_Y;\noutput\t\t\t\toRequest;\noutput\t\t\t\toShift_Flag;\noutput\t\t[9:0]\toVGA_R;\noutput\t\t[9:0]\toVGA_G;\noutput\t\t[9:0]\toVGA_B;\noutput\treg\t\t\toVGA_HS;\noutput\treg\t\t\toVGA_VS;\noutput\t\t\t\toVGA_SYNC;\noutput\t\t\t\toVGA_BLANK;\noutput\t\t\t\toVGA_CLOCK;\ninput\t\t\t\tiCLK;\ninput\t\t\t\tiRST_N;\t\nreg\t\t\t[10:0]\tH_Cont;\nreg\t\t\t[10:0]\tV_Cont;\nparameter\tH_FRONT\t=\t16;\nparameter\tH_SYNC\t=\t96;\nparameter\tH_BACK\t=\t48;\nparameter\tH_ACT\t=\t640;\nparameter\tH_BLANK\t=\tH_FRONT+H_SYNC+H_BACK;\nparameter\tH_TOTAL\t=\tH_FRONT+H_SYNC+H_BACK+H_ACT;\nparameter\tH_DLY\t\t=\t2; \nparameter\tV_FRONT\t=\t11;\nparameter\tV_SYNC\t=\t2;\nparameter\tV_BACK\t=\t31;\nparameter\tV_ACT\t=\t480;\nparameter\tV_BLANK\t=\tV_FRONT+V_SYNC+V_BACK;\nparameter\tV_TOTAL\t=\tV_FRONT+V_SYNC+V_BACK+V_ACT;\nparameter\tV_DLY\t\t=\t2; \nassign\toVGA_SYNC\t=\t1'b1;\t\t\t\nassign\toVGA_BLANK\t=\t~((H_Cont<H_BLANK)||(V_Cont<V_BLANK));\nassign\toShift_Flag\t=\t~((H_Cont<(H_BLANK-H_DLY))||(V_Cont<(V_BLANK-V_DLY)));\nassign\toVGA_CLOCK\t=\t~iCLK;\nassign\toVGA_R\t\t=\tiRed;\nassign\toVGA_G\t\t=\tiGreen;\nassign\toVGA_B\t\t=\tiBlue;\nassign\toAddress\t=\toCurrent_Y*H_ACT+oCurrent_X;\nassign\toRequest\t=\t((H_Cont>=H_BLANK-H_DLY && H_Cont<H_TOTAL-H_DLY)\t&&\n\t\t\t\t\t\t (V_Cont>=V_BLANK-V_DLY && V_Cont<V_TOTAL-V_DLY));\nassign\toCurrent_X\t=\t(H_Cont>=(H_BLANK-H_DLY) && H_Cont<H_TOTAL)\t?\tH_Cont-(H_BLANK-H_DLY)\t:\t11'h0\t;\nassign\toCurrent_Y\t=\t(V_Cont>=(V_BLANK-V_DLY) && V_Cont<V_TOTAL)\t?\tV_Cont-(V_BLANK-V_DLY)\t:\t11'h0\t;\nalways@(posedge iCLK or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tH_Cont\t\t<=\t0;\n\t\toVGA_HS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(H_Cont<H_TOTAL)\n\t\tH_Cont\t<=\tH_Cont+1'b1;\n\t\telse\n\t\tH_Cont\t<=\t0;\n\t\tif(H_Cont==H_FRONT-1)\t\t\t\n\t\toVGA_HS\t<=\t1'b0;\n\t\tif(H_Cont==H_FRONT+H_SYNC-1)\t\n\t\toVGA_HS\t<=\t1'b1;\n\tend\nend\nalways@(posedge oVGA_HS or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tV_Cont\t\t<=\t0;\n\t\toVGA_VS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(V_Cont<V_TOTAL)\n\t\tV_Cont\t<=\tV_Cont+1'b1;\n\t\telse\n\t\tV_Cont\t<=\t0;\n\t\tif(V_Cont==V_FRONT-1)\t\t\t\n\t\toVGA_VS\t<=\t1'b0;\n\t\tif(V_Cont==V_FRONT+V_SYNC-1)\t\n\t\toVGA_VS\t<=\t1'b1;\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe \"altera_up_video_clipper_counters\" module manages frame counting for video processing through synchronized counters for horizontal (width) and vertical (height) dimensions driven by a clock signal. It supports resetting counters and selectively increments based on control inputs, ultimately providing start/end signals for both the outer and designated inner frames, and validates the current position within the inner frame using internally managed validity flags, facilitating dynamic boundary tracking in video clipping applications.\nModule head:\nmodule altera_up_video_clipper_counters (\n\tclk,\n\treset,\n\tincrement_counters,\n\tstart_of_outer_frame,\n\tend_of_outer_frame,\n\tstart_of_inner_frame,\n\tend_of_inner_frame,\n\tinner_frame_valid\n)",
        "output": "module altera_up_video_clipper_counters (\n\tclk,\n\treset,\n\tincrement_counters,\n\tstart_of_outer_frame,\n\tend_of_outer_frame,\n\tstart_of_inner_frame,\n\tend_of_inner_frame,\n\tinner_frame_valid\n);\nparameter IMAGE_WIDTH\t= 640; \nparameter IMAGE_HEIGHT\t= 480; \nparameter WW\t\t\t\t=   9; \nparameter HW\t\t\t\t=   8; \nparameter LEFT_OFFSET\t=   0;\nparameter RIGHT_OFFSET\t=   0;\nparameter TOP_OFFSET\t\t=   0;\nparameter BOTTOM_OFFSET\t=   0;\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\ninput\t\t\t\t\t\tincrement_counters;\noutput\t\t\t\t\tstart_of_outer_frame;\noutput\t\t\t\t\tend_of_outer_frame;\noutput\t\t\t\t\tstart_of_inner_frame;\noutput\t\t\t\t\tend_of_inner_frame;\noutput\t\t\t\t\tinner_frame_valid;\nreg\t\t\t[WW: 0]\twidth;\nreg\t\t\t[HW: 0]\theight;\nreg\t\t\t\t\t\tinner_width_valid;\nreg\t\t\t\t\t\tinner_height_valid;\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\twidth <= 'h0;\n\telse if (increment_counters & (width == (IMAGE_WIDTH - 1)))\n\t\twidth <= 'h0;\n\telse if (increment_counters)\n\t\twidth <= width + 1;\t\nend\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\theight <= 'h0;\n\telse if (increment_counters & (width == (IMAGE_WIDTH - 1)))\n\tbegin\n\t\tif (height == (IMAGE_HEIGHT - 1))\n\t\t\theight <= 'h0;\n\t\telse\n\t\t\theight <= height + 1;\n\tend\nend\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tinner_width_valid <= (LEFT_OFFSET == 0);\n\telse if (increment_counters)\n\tbegin\n\t\tif (width == (IMAGE_WIDTH - 1))\n\t\t\tinner_width_valid <= (LEFT_OFFSET == 0);\n\t\telse if (width == (IMAGE_WIDTH - RIGHT_OFFSET - 1))\n\t\t\tinner_width_valid <= 1'b0;\n\t\telse if (width == (LEFT_OFFSET - 1))\n\t\t\tinner_width_valid <= 1'b1;\n\tend\nend\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tinner_height_valid <= (TOP_OFFSET == 0);\n\telse if (increment_counters & (width == (IMAGE_WIDTH - 1)))\n\tbegin\n\t\tif (height == (IMAGE_HEIGHT - 1))\n\t\t\tinner_height_valid <= (TOP_OFFSET == 0);\n\t\telse if (height == (IMAGE_HEIGHT - BOTTOM_OFFSET - 1))\n\t\t\tinner_height_valid <= 1'b0;\n\t\telse if (height == (TOP_OFFSET - 1))\n\t\t\tinner_height_valid <= 1'b1;\n\tend\nend\nassign start_of_outer_frame\t=\t(width == 'h0) & (height == 'h0);\nassign end_of_outer_frame\t\t=\t(width == (IMAGE_WIDTH - 1)) & \n\t\t\t\t\t\t\t\t\t\t\t(height == (IMAGE_HEIGHT - 1));\nassign start_of_inner_frame\t=\t(width == LEFT_OFFSET) & \n\t\t\t\t\t\t\t\t\t\t\t(height == TOP_OFFSET);\nassign end_of_inner_frame\t\t=\t(width == (IMAGE_WIDTH - RIGHT_OFFSET - 1)) & \n\t\t\t\t\t\t\t\t\t\t\t(height == (IMAGE_HEIGHT - BOTTOM_OFFSET - 1));\nassign inner_frame_valid\t\t=\tinner_width_valid & inner_height_valid;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe behavioral_full_adder_test module tests a 64-bit full adder by simulating all combinations of 64-bit inputs A and B, each ranging from 0 to 32. It employs nested loops, with internal signals count and count2 iterating over possible values, to systematically test and monitor each addition operation. The results are displayed continuously, and the simulation concludes after 4000 time units, ensuring comprehensive verification of the adder\u2019s functionality.\nModule head:\n\nmodule behavioral_full_adder_test;\n  reg [63:0] A;\n  reg [63:0] B;\n  wire [64:0] SUM;\n  integer count;\n  integer count2;\n  behavioral_full_adder_64 uut\n  (\n    .A(A),\n    .B(B),\n    .SUM(SUM)\n  )",
        "output": "`timescale 1ns / 1ps\nmodule behavioral_full_adder_test;\n  reg [63:0] A;\n  reg [63:0] B;\n  wire [64:0] SUM;\n  integer count;\n  integer count2;\n  behavioral_full_adder_64 uut\n  (\n    .A(A),\n    .B(B),\n    .SUM(SUM)\n  );\n  initial begin\n    $monitor(\"%d + %d = %d\", A, B, SUM);\n    count = 0;\n    count2 = 0;\n    A = 0;\n    B = 0;\n    for (count = 0; count <= 32; count = count + 1) begin\n      {A} = count;\n      for (count2 = 0; count2 <= 32; count2 = count2 + 1) begin\n        {B} = count2;\n        #1;\n      end\n    end\n  end\n  initial #4000 $finish; \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'four_bit_adder' module performs 4-bit binary addition of inputs ADD_1 and ADD_2 with an input carry C, producing a 4-bit sum S, carry-out C_OUT, generate G, and propagate P signals. It uses bitwise AND, OR, and XOR operations to calculate internal carry (Ci) and perform the addition, with dedicated logic to determine the G and P signals for carry creation and propagation across the bits.\nModule head:\nmodule four_bit_adder (\n  input [3:0] ADD_1,  \n  input [3:0] ADD_2,  \n  output [3:0] S, \n  output G, \n  input C,            \n  output C_OUT, \n  output P \n)",
        "output": "module four_bit_adder (\n  input [3:0] ADD_1,  \n  input [3:0] ADD_2,  \n  output [3:0] S, \n  output G, \n  input C,            \n  output C_OUT, \n  output P \n);\nwire [3:0]Prop;\nwire [3:0]Gen;\nwire [3:0]Ci;\nassign Gen = ADD_1 & ADD_2;\nassign Prop = ADD_1 ^ ADD_2;\nassign Ci[0] = C;\nassign Ci[1]= Gen[0]|(Prop[0]&Ci[0]);\nassign Ci[2] = Gen[1]|(Prop[1]&Ci[1]);\nassign Ci[3] = Gen[2]|(Prop[2]&Ci[2]);\nassign C_OUT = Gen[3]|(Prop[3]&Ci[3]);\nassign S = Prop^Ci;\nassign P = Prop[3] & Prop[2] & Prop[1] & Prop[0];\nassign G = Gen[3] | (Gen[2] & Prop[3]) | (Gen[1] & Prop[2] & Prop[3]) | (Gen[0] & Prop[1] & Prop[2]);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'bin_to_gray' module converts a binary number into Gray code. It accepts an 8-bit binary input 'bin', and produces an 8-bit Gray code output 'gray'. The output is computed by XORing 'bin' with 'bin' right-shifted by one bit (`bin ^ (bin >> 1)`), efficiently mapping binary to Gray code.\nModule head:\nmodule bin_to_gray (bin,gray)",
        "output": "module bin_to_gray (bin,gray);\nparameter WIDTH = 8;\ninput [WIDTH-1:0] bin;\noutput [WIDTH-1:0] gray;\nwire [WIDTH-1:0] gray;\nassign gray = bin ^ (bin >> 1);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `left_shister_reverse` module performs a bit-reversing left shift on an 8-bit input `a` based on a 3-bit shift amount `amt`. It reverses `a` storing in `ra`, then shifts `ra` cyclically using `amt` to determine the shift configuration in a case block. The result, `y`, outputs the shifted version of `ra`. This setup allows bit manipulation through selective concatenation.\nModule head:\n\nmodule left_shister_reverse(\n\t  input wire [0:7] a,\n     input wire [2:0] amt,\n     output  reg [0:7] y\n    )",
        "output": "`timescale 1ns / 1ps\nmodule left_shister_reverse(\n\t  input wire [0:7] a,\n     input wire [2:0] amt,\n     output  reg [0:7] y\n    );\n\t\twire [7:0] ra;\n      assign ra = {a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7]}; \n always @*\n      case(amt)\n         3'b000: y = ra;\n         3'b001: y = {ra[0], ra[7:1]};\n         3'b010: y = {ra[1:0], ra[7:2]};\n         3'b011: y = {ra[2:0], ra[7:3]};\n         3'b100: y = {ra[3:0], ra[7:4]}; \n         3'b101: y = {ra[4:0], ra[7:5]};\n         3'b110: y = {ra[5:0], ra[7:6]};\n\t\t\t3'b111: y = {ra[6:0], ra[7]};\n      endcase\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `cmm_errman_cnt_en` module serves as an enabling counter with overflow and underflow management, incrementing or decrementing based on the `inc_dec_b` input. It operates synchronously with a clock and can be reset or disabled. Inputs control counting steps, mode, and active status, while internal registers manage interim values and conditions. The design integrates reset-driven state initialization, conditional counting updates, and status signaling for overflow and underflow, ensuring reliable count adjustments under various signal conditions.\nModule head:\n\nmodule cmm_errman_cnt_en (\n                count,                  \n                index,                  \n                inc_dec_b,\n                enable,\n                rst,\n                clk\n                )",
        "output": "`ifndef FFD\n  `define FFD 1\n`endif\nmodule cmm_errman_cnt_en (\n                count,                  \n                index,                  \n                inc_dec_b,\n                enable,\n                rst,\n                clk\n                );\n  output  [3:0] count;\n  input   [2:0] index;       \n  input         inc_dec_b;   \n  input         enable;      \n  input         rst;\n  input         clk;\n  parameter FFD       = 1;        \n  reg     [3:0] reg_cnt;\n  reg           reg_extra;\n  reg           reg_inc_dec_b;\n  reg           reg_uflow;\n  reg     [3:0] cnt;\n  wire          oflow;\n  wire          uflow;\n  always @(posedge clk or posedge rst) begin\n    if (rst)              {reg_extra, reg_cnt} <= #`FFD 5'b00000;\n    else if (~enable)     {reg_extra, reg_cnt} <= #`FFD 5'b00000;\n    else if (inc_dec_b)   {reg_extra, reg_cnt} <= #`FFD cnt + index;\n    else                  {reg_extra, reg_cnt} <= #`FFD cnt - index;\n  end\n  always @(oflow or uflow or reg_cnt) begin  \n    case ({oflow,uflow})    \n      2'b11: cnt = 4'hF;\n      2'b10: cnt = 4'hF;\n      2'b01: cnt = 4'h0;\n      2'b00: cnt = reg_cnt;\n    endcase\n  end\n  always @(posedge clk or posedge rst) begin\n    if (rst)  reg_inc_dec_b <= #`FFD 1'b0;\n    else      reg_inc_dec_b <= #`FFD inc_dec_b;\n  end\n  assign oflow = reg_extra & reg_inc_dec_b;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      reg_uflow <= #`FFD 1'b0;\n    else\n      reg_uflow <= #`FFD ~|count & |index[2:0] & ~inc_dec_b;\n  end\n  assign uflow = reg_uflow;\n  reg     [3:0] reg_count;\n  always @(posedge clk or posedge rst) begin\n    if (rst)            reg_count <= #`FFD 4'b0000;\n    else if (~enable)   reg_count <= #`FFD 4'b0000;\n    else if (oflow)     reg_count <= #`FFD 4'b1111;\n    else if (uflow)     reg_count <= #`FFD 4'b0000;\n    else                reg_count <= #`FFD cnt;\n  end\n  assign count = reg_count;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe assign2_system_mm_interconnect_0_avalon_st_adapter is a system interconnect adapter for FPGAs/ASICs, ensuring parameter configuration validity. It operates by accepting data inputs alongside timing signals, employing multiple parameter checks to verify their compliance with the specified requirements. The module interacts with 'assign2_system_mm_interconnect_0_avalon_st_adapter_error_adapter_0' for error indication. Non-compliance halts simulation, enabling parameter misconfiguration rectification.\nModule head:\n\nmodule assign2_system_mm_interconnect_0_avalon_st_adapter #(\n\t\tparameter inBitsPerSymbol = 34,\n\t\tparameter inUsePackets    = 0,\n\t\tparameter inDataWidth     = 34,\n\t\tparameter inChannelWidth  = 0,\n\t\tparameter inErrorWidth    = 0,\n\t\tparameter inUseEmptyPort  = 0,\n\t\tparameter inUseValid      = 1,\n\t\tparameter inUseReady      = 1,\n\t\tparameter inReadyLatency  = 0,\n\t\tparameter outDataWidth    = 34,\n\t\tparameter outChannelWidth = 0,\n\t\tparameter outErrorWidth   = 1,\n\t\tparameter outUseEmptyPort = 0,\n\t\tparameter outUseValid     = 1,\n\t\tparameter outUseReady     = 1,\n\t\tparameter outReadyLatency = 0\n\t)",
        "output": "`timescale 1 ps / 1 ps\nmodule assign2_system_mm_interconnect_0_avalon_st_adapter #(\n\t\tparameter inBitsPerSymbol = 34,\n\t\tparameter inUsePackets    = 0,\n\t\tparameter inDataWidth     = 34,\n\t\tparameter inChannelWidth  = 0,\n\t\tparameter inErrorWidth    = 0,\n\t\tparameter inUseEmptyPort  = 0,\n\t\tparameter inUseValid      = 1,\n\t\tparameter inUseReady      = 1,\n\t\tparameter inReadyLatency  = 0,\n\t\tparameter outDataWidth    = 34,\n\t\tparameter outChannelWidth = 0,\n\t\tparameter outErrorWidth   = 1,\n\t\tparameter outUseEmptyPort = 0,\n\t\tparameter outUseValid     = 1,\n\t\tparameter outUseReady     = 1,\n\t\tparameter outReadyLatency = 0\n\t) (\n\t\tinput  wire        in_clk_0_clk,   \n\t\tinput  wire        in_rst_0_reset, \n\t\tinput  wire [33:0] in_0_data,      \n\t\tinput  wire        in_0_valid,     \n\t\toutput wire        in_0_ready,     \n\t\toutput wire [33:0] out_0_data,     \n\t\toutput wire        out_0_valid,    \n\t\tinput  wire        out_0_ready,    \n\t\toutput wire [0:0]  out_0_error     \n\t);\n\tgenerate\n\t\tif (inBitsPerSymbol != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinbitspersymbol_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUsePackets != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinusepackets_check ( .error(1'b1) );\n\t\tend\n\t\tif (inDataWidth != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tindatawidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inChannelWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinchannelwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inErrorWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinerrorwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseEmptyPort != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinuseemptyport_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseValid != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinusevalid_check ( .error(1'b1) );\n\t\tend\n\t\tif (inUseReady != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinuseready_check ( .error(1'b1) );\n\t\tend\n\t\tif (inReadyLatency != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\tinreadylatency_check ( .error(1'b1) );\n\t\tend\n\t\tif (outDataWidth != 34)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutdatawidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outChannelWidth != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutchannelwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outErrorWidth != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\touterrorwidth_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseEmptyPort != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutuseemptyport_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseValid != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutusevalid_check ( .error(1'b1) );\n\t\tend\n\t\tif (outUseReady != 1)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutuseready_check ( .error(1'b1) );\n\t\tend\n\t\tif (outReadyLatency != 0)\n\t\tbegin\n\t\t\tinitial begin\n\t\t\t\t$display(\"Generated module instantiated with wrong parameters\");\n\t\t\t\t$stop;\n\t\t\tend\n\t\t\tinstantiated_with_wrong_parameters_error_see_comment_above\n\t\t\t\t\toutreadylatency_check ( .error(1'b1) );\n\t\tend\n\tendgenerate\n\tassign2_system_mm_interconnect_0_avalon_st_adapter_error_adapter_0 error_adapter_0 (\n\t\t.clk       (in_clk_0_clk),    \n\t\t.reset_n   (~in_rst_0_reset), \n\t\t.in_data   (in_0_data),       \n\t\t.in_valid  (in_0_valid),      \n\t\t.in_ready  (in_0_ready),      \n\t\t.out_data  (out_0_data),      \n\t\t.out_valid (out_0_valid),     \n\t\t.out_ready (out_0_ready),     \n\t\t.out_error (out_0_error)      \n\t);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'top_spi_final' module facilitates SPI communication between one master and up to three slave devices. It uses inputs like clock, reset, load, and slave selects to control data transfer, loading data into 'master_data1' from 'data_inp' on 'load'. It performs bit-shifting to exchange MSB and LSB between 'master_data1' and active 'slave_dataX' based on the selected slave, outputting the current MSB through 'mosi' for SPI communication.\nModule head:\n\nmodule top_spi_final(data_inp, load, clk, rst, ss0, ss1, ss2, mosi, master_data1, slave_data1, slave_data2, slave_data3)",
        "output": "`timescale 1ns / 1ps\nmodule top_spi_final(data_inp, load, clk, rst, ss0, ss1, ss2, mosi, master_data1, slave_data1, slave_data2, slave_data3);\ninput clk, ss0, ss1, ss2, load, rst; \ninput [0:7] data_inp; \noutput reg mosi; \noutput reg [0:7] master_data1, slave_data1, slave_data2, slave_data3; \nalways@(posedge clk)\nbegin\n    if(rst) begin\n        master_data1 <= 8'b0; \n        slave_data1 <= 8'b0;\n        slave_data2 <= 8'b0;\n        slave_data3 <= 8'b0;\n        mosi <= 0;\n        end\n    if(load) begin\n        master_data1 <= data_inp; \n        mosi <= master_data1[7];\n        end\n    if(ss0 == 1) begin \n        slave_data1[0] <= master_data1[7];\n        master_data1[0] <= slave_data1[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data1[1:7] <= slave_data1[0:6];\n        mosi <= master_data1[7];\n    end\n    else if(ss1 == 1) begin \n        slave_data2[0] <= master_data1[7];\n        master_data1[0] <= slave_data2[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data2[1:7] <= slave_data2[0:6];\n        mosi <= master_data1[7];\n    end\n    else if(ss2 == 1) begin \n        slave_data3[0] <= master_data1[7];\n        master_data1[0] <= slave_data3[7];\n        master_data1[1:7] <= master_data1[0:6];\n        slave_data3[1:7] <= slave_data3[0:6];\n        mosi <= master_data1[7];\n    end\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Forwarding_Unit module controls data source selection for operands in a pipelined processor, resolving data hazards by generating control signals for operational multiplexers. It evaluates register addresses from different pipeline stages to decide if data should be forwarded from ALU outputs or write-back stages using internal logic defined by comparisons in an always block, initialized in default states to indicate direct data sourcing from the register file.\nModule head:\n\nmodule Forwarding_Unit(f_mux1_ctrl, f_mux2_ctrl, id_ex_src2, id_ex_src1, wb_dest_reg, mem_dest_reg, wb_mem2reg, ex_mem_branch)",
        "output": "`timescale 1ns / 1ps\nmodule Forwarding_Unit(f_mux1_ctrl, f_mux2_ctrl, id_ex_src2, id_ex_src1, wb_dest_reg, mem_dest_reg, wb_mem2reg, ex_mem_branch);\n\toutput reg\t\t[1:0]\t\tf_mux1_ctrl, f_mux2_ctrl;\t\t\n\tinput\t\t\t[4:0]\t\tid_ex_src2, id_ex_src1;\n\tinput\t\t\t[4:0]\t\twb_dest_reg, mem_dest_reg;\n\tinput\t\t\t\t\t\twb_mem2reg;\n\tinput\t\t\t[4:0]\t\tex_mem_branch;\n\tparameter\t\tR_DATA = 2'b00, ALU_OUT = 2'b01, W_DATA = 2'b10;\n\tinitial begin \n\t\tf_mux1_ctrl = 2'b00;\n\t\tf_mux2_ctrl = 2'b00;\n\tend\n\talways@(id_ex_src1 or id_ex_src2 or mem_dest_reg or wb_dest_reg)begin\n\t\tif(id_ex_src1 == mem_dest_reg) begin\t\t\t\n\t\t\t\tf_mux1_ctrl = W_DATA;\n\t\tend else if(id_ex_src1 == wb_dest_reg) begin \t\n\t\t\t\tf_mux1_ctrl = ALU_OUT;\n\t\tend else begin\t\t\t\t\t\t\t\t\t\n\t\t\t\tf_mux1_ctrl = R_DATA;\n\t\tend\n\t\tif(id_ex_src2 == mem_dest_reg)begin\t\t\t\t\n\t\t\t\tf_mux2_ctrl = W_DATA;\n\t\tend else if(id_ex_src2 == wb_dest_reg)begin\n\t\t\t\tf_mux2_ctrl = ALU_OUT;\n\t\tend else begin\t\t\t\t\t\t\t\t\t\n\t\t\t\tf_mux2_ctrl = R_DATA;\n\t\tend\n\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'PIPE_Data' module processes PCIe data for transmission across generations, dynamically adapting data bit widths and control signals based on 'generation'. It uses conditional logic within a combinational always block to reconfigure outputs ('TxData', 'TxDataK', 'TxDataValid', 'TxSyncHeader', 'TxStartBlock') in response to input ('generation', 'scramblerDataOut', 'scramblerDataK', 'scramblerSyncHeader', 'scramblerDataValid') and reset signals.\nModule head:\nmodule PIPE_Data #(parameter pipe_width_gen1 = 8,\n                   parameter pipe_width_gen2 = 8,\n                   parameter pipe_width_gen3 = 16,\n                   parameter pipe_width_gen4 = 32,\n                   parameter pipe_width_gen5 = 32\n  )",
        "output": "module PIPE_Data #(parameter pipe_width_gen1 = 8,\n                   parameter pipe_width_gen2 = 8,\n                   parameter pipe_width_gen3 = 16,\n                   parameter pipe_width_gen4 = 32,\n                   parameter pipe_width_gen5 = 32\n  )(generation, pclk, reset_n, scramblerDataOut, scramblerDataK, scramblerSyncHeader, scramblerDataValid, TxData, TxDataValid, TxDataK, TxSyncHeader, TxStartBlock);\ninput pclk, reset_n;\ninput [2:0] generation;\ninput [31:0] scramblerDataOut;\ninput [3:0] scramblerDataK;\ninput [1:0] scramblerSyncHeader;\ninput scramblerDataValid;\noutput reg [31:0] TxData; \noutput reg TxDataValid, TxStartBlock; \noutput reg [3:0] TxDataK;\noutput reg [1:0] TxSyncHeader;\nalways @(*) begin\n  if (~reset_n) begin\n  \tTxData = 0;\n  \tTxDataK = 0;\n  \tTxDataValid = 0;\n    TxSyncHeader = 0;\n    TxStartBlock = 0;\n  end\n  else if (generation==1) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen1-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen1/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n  end\n  else if (generation==2) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen2-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen2/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n  end \n  else if (generation==3) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen3-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen3/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;\n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;\n  end \n  else if (generation==4) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen4-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen4/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;\n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;      \n  end\n  else if (generation==5) begin\n  \t\tTxData= scramblerDataOut[pipe_width_gen5-1:0];\n  \t\tTxDataK=scramblerDataK[(pipe_width_gen5/8)-1:0];\n  \t\tTxDataValid= scramblerDataValid;\n      TxSyncHeader= scramblerSyncHeader;   \n      if(scramblerSyncHeader==2'b10 || scramblerSyncHeader==2'b01)\n          TxStartBlock=1;\n      else \n          TxStartBlock=0;   \n  end  \n  else begin\n  \t\tTxData=0;\n  \t\tTxDataK=0;\n  \t\tTxDataValid=0;\n      TxSyncHeader= 0;\n      TxStartBlock = 0;\n  end\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe AlphaCalculator2 module computes the 'alpha' value using inputs from autocorrelation functions and model estimates through staged arithmetic operations. It leverages a state machine to manage multiple processing phases of multiplication and addition, conditioned by input signals for enable, reset, and data validity. Output is determined by sequential logic and real-time processing on a positive clock edge, producing the alpha and done signals.\nModule head:\n\nmodule AlphaCalculator2 (\n    input wire iClock,\n    input wire iEnable, \n    input wire iReset,\n    input wire iValid,\n    input wire [3:0] iM,\n    input wire [31:0] iACF1,\n    input wire [31:0] iACF2,\n    input wire [31:0] iModel1,\n    input wire [31:0] iModel2,\n    output wire [31:0] oAlpha,\n    output wire oDone\n    )",
        "output": "`ifndef ALPHA_CALC2_H\n`define ALPHA_CALC2_H\n`define DFP(X) $bitstoshortreal(X)\nmodule AlphaCalculator2 (\n    input wire iClock,\n    input wire iEnable, \n    input wire iReset,\n    input wire iValid,\n    input wire [3:0] iM,\n    input wire [31:0] iACF1,\n    input wire [31:0] iACF2,\n    input wire [31:0] iModel1,\n    input wire [31:0] iModel2,\n    output wire [31:0] oAlpha,\n    output wire oDone\n    );\ninteger i;\nparameter S_CALC_PART_SUMS = 0;\nparameter S_ADD_PHASE1 = 1;\nparameter S_ADD_PHASE2 = 2;\nparameter S_ADD_PHASE3 = 3;\nparameter S_DONE = 4;\nparameter ORDER = 12;\nparameter MULT_LATENCY = 5;\nparameter ADD_LATENCY = 7;\nparameter TOTAL_LATENCY = MULT_LATENCY + ADD_LATENCY;\nreg done;\nreg rValid;\nreg [5:0] phase_count;\nreg [31:0] alpha;\nreg [31:0] rACF1, rACF2, rModel1, rModel2;\nreg [31:0] partial_sums [0:5];\nreg [3:0] state;\nassign oAlpha = alpha;\nassign oDone = done;\nwire [31:0] m1_out, m2_out, a1_out, a2_out;\nwire mult_en = iEnable;\nwire a1_en = iEnable;\nwire a2_en = iEnable;\nreg [31:0] a1_in1, a1_in2, a2_in1, a2_in2;\nreg add_partial_sums;\nfp_mult m1 (\n    .clk_en(mult_en),\n    .clock(iClock),\n    .dataa(rACF2),\n    .datab(rModel1),\n    .nan(),\n    .result(m1_out));\nfp_mult m2 (\n    .clk_en(mult_en),\n    .clock(iClock),\n    .dataa(rACF1),\n    .datab(rModel2),\n    .nan(),\n    .result(m2_out));\nfp_add_sub a1 (\n    .add_sub(1'b1),\n    .clk_en(a1_en),\n    .clock(iClock),\n    .dataa(a1_in1),\n    .datab(a1_in2),\n    .result(a1_out));\nfp_add_sub a2 (\n    .add_sub(1'b1),\n    .clk_en(a2_en),\n    .clock(iClock),\n    .dataa(a2_in1),\n    .datab(a2_in2),\n    .result(a2_out));\nalways @(posedge iClock) begin\n    if (iReset) begin\n        done <= 0;\n        alpha <= 0;\n        rACF1 <= 0;\n        rACF2 <= 0;\n        rModel1 <= 0;\n        rModel2 <= 0;\n        rValid <= 0;\n        partial_sums[0] <= 0;\n        phase_count <= 0;\n        state <= S_CALC_PART_SUMS;\n    end else if (iEnable) begin\n        rACF1 <= iValid ? iACF1 : 0;\n        rACF2 <= iValid ? iACF2 : 0;\n        rModel1 <= iValid ? iModel1 : 0;\n        rModel2 <= iValid ? iModel2 : 0;\n        rValid <= iValid;\n        case (state) \n        S_CALC_PART_SUMS:\n        begin\n            a1_in1 <= m1_out;\n            a1_in2 <= m2_out;\n            phase_count <= phase_count + 1'b1;\n            for (i = 5; i > 0; i = i - 1)\n                partial_sums[i] <= partial_sums[i-1];\n            partial_sums[0] <= a1_out;\n            if (phase_count == TOTAL_LATENCY + 7) begin\n                if (iM == 1) begin\n                    alpha <= partial_sums[4];\n                    state <= S_DONE;\n                end else begin\n                    state <= S_ADD_PHASE1;\n                    phase_count <= 0;   \n                end\n            end\n        end\n        S_ADD_PHASE1:\n        begin\n            phase_count <= phase_count + 1'b1;\n            a1_in1 <= partial_sums[5]; \n            a1_in2 <= partial_sums[4]; \n            a2_in1 <= partial_sums[3]; \n            a2_in2 <= partial_sums[2]; \n            if (phase_count == ADD_LATENCY + 1) begin\n                if (iM == 2 || iM == 3) begin\n                    alpha <= a1_out;\n                    state <= S_DONE;\n                end else begin\n                    state <= S_ADD_PHASE2;\n                    phase_count <= 0;\n                    partial_sums[5] <= a1_out; \n                    partial_sums[4] <= a2_out; \n                end\n            end\n        end\n        S_ADD_PHASE2:\n        begin    \n            phase_count <= phase_count + 1'b1;\n            a1_in1 <= partial_sums[5]; \n            a1_in2 <= partial_sums[4]; \n            a2_in1 <= partial_sums[1]; \n            a2_in2 <= partial_sums[0]; \n            if (phase_count == ADD_LATENCY + 1) begin\n                if (iM == 4 || iM == 5 || iM == 6 || iM == 7) begin\n                    alpha <= a1_out;\n                    state <= S_DONE;\n                end else begin\n                    state <= S_ADD_PHASE3;\n                    phase_count <= 0;\n                    partial_sums[5] <= a1_out; \n                    partial_sums[4] <= a2_out; \n                end\n            end\n        end\n        S_ADD_PHASE3:\n        begin            \n            phase_count <= phase_count + 1'b1;\n            a1_in1 <= partial_sums[5]; \n            a1_in2 <= partial_sums[4]; \n            a2_in1 <= 0;\n            a2_in2 <= 0;\n            if (phase_count == ADD_LATENCY + 1) begin\n                if (iM == 8 || iM == 9 || iM == 10 || iM == 11) begin\n                    alpha <= a1_out;\n                    state <= S_DONE;\n                end\n            end\n        end\n        S_DONE:\n        begin\n            done <= 1'b1;\n        end\n        default:\n        begin\n            done <= 1'b1;\n        end\n        endcase\n    end \nend\nendmodule\n`endif"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'pwm_top' module generates and controls PWM signals for an audio processing unit. It uses a clock signal and four switch inputs to adjust the audio outputs and uses external files for audio tables. Internally, it comprises blocks like a switch synchronizer, reset generator, and APU to handle sound processing. Outputs include regular and inverted PWM signals and a frame pulse. Implementation relies on wire signals for synchronization, control inputs, audio sample comparisons, and cycle indications.\nModule head:\n\nmodule pwm_top (\n  input wire  i_Clk,\n  input wire  i_Switch_1,\n  input wire  i_Switch_2,\n  input wire  i_Switch_3,\n  input wire  i_Switch_4,\n  output wire io_PMOD_1,\n  output wire io_PMOD_2,\n  output wire io_PMOD_3\n)",
        "output": "`default_nettype none\nmodule pwm_top (\n  input wire  i_Clk,\n  input wire  i_Switch_1,\n  input wire  i_Switch_2,\n  input wire  i_Switch_3,\n  input wire  i_Switch_4,\n  output wire io_PMOD_1,\n  output wire io_PMOD_2,\n  output wire io_PMOD_3\n);\n  wire i_clk = i_Clk;\n  wire [3:0] w_switches;\n  switch_synchronizers switches (\n    .i_clk(i_clk),\n    .i_switches({i_Switch_4, i_Switch_3, i_Switch_2, i_Switch_1}),\n    .o_switches(w_switches)\n  );\n  wire w_rst;\n  reset_generator reset_generator (\n    .i_clk(i_clk),\n    .o_rst(w_rst)\n  );\n  wire [3:0] w_mixer = ~w_switches;\n  wire [8:0] w_compare;\n  wire [3:0] w_frame_pulse;\n  audio_processing_unit #(\n    .CLOCK_FREQ(25_000_000),\n    .NOTE_TABLE_FILE(\"resources/note_table_25MHz.txt\"),\n    .VIBRATO_TABLE_FILE(\"resources/vibrato_table_25MHz.txt\"),\n    .NOISE_TABLE_FILE(\"resources/noise_table_25MHz.txt\")\n  ) apu (\n    .i_clk(i_clk),\n    .i_rst(w_rst),\n    .i_mixer(w_mixer),\n    .o_sample(w_compare),\n    .o_frame_pulse(w_frame_pulse)\n  );\n  wire w_pwm;\n  wire w_cycle_end;\n  pwm pwm(\n    .i_clk(i_Clk),\n    .i_top(8'hff),\n    .i_top_valid(1'b1),\n    .i_compare(w_compare),\n    .i_compare_valid(1'b1),\n    .o_pwm(w_pwm),\n    .o_cycle_end(w_cycle_end)\n  );\n  assign io_PMOD_1 = w_pwm;\n  assign io_PMOD_2 = w_frame_pulse[0];\n  assign io_PMOD_3 = ~w_pwm;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `hyperbus_wishbone` module interfaces between HyperBus and Wishbone buses, facilitating data transfer and protocol translation. It utilizes input signals for synchronization and operations control, and outputs for signaling transaction states. Internally, it employs a state machine coordinated with the `hyperbus_fifo` submodule to manage read and write transactions, transitioning through idle, read, write, and wait states based on bus interactions and data transaction statuses.\nModule head:\nmodule hyperbus_wishbone\n#(\n    parameter WB_DATA_WIDTH = 32,\n    parameter WB_ADDR_WIDTH = 32,\n    parameter HBUS_ADDR_WIDTH = 32,\n    parameter HBUS_DATA_WIDTH = 16\n)",
        "output": "module hyperbus_wishbone\n#(\n    parameter WB_DATA_WIDTH = 32,\n    parameter WB_ADDR_WIDTH = 32,\n    parameter HBUS_ADDR_WIDTH = 32,\n    parameter HBUS_DATA_WIDTH = 16\n)\n(\n  input                           hbus_clk,\n  input                           hbus_rst,\n  output [HBUS_ADDR_WIDTH-1:0]    hbus_adr_o,\n  input  [HBUS_DATA_WIDTH-1:0]    hbus_dat_i,\n  output [HBUS_DATA_WIDTH-1:0]    hbus_dat_o,\n  output [(HBUS_DATA_WIDTH/8)-1:0] hbus_mask_o,\n  output                          hbus_rrq,\n  output                          hbus_wrq,\n  input                           hbus_ready,\n  input                           hbus_valid,\n  input                           wb_clk,\n  input                           wb_rst,\n  input [WB_ADDR_WIDTH-1:0]       wb_adr_i,\n  input [WB_DATA_WIDTH-1:0]       wb_dat_i,\n  input                           wb_we_i,\n  input [3:0]                     wb_sel_i,\n  input                           wb_cyc_i,\n  input                           wb_stb_i,\n  input         [2:0]             wb_cti_i,\n  input         [1:0]             wb_bte_i,\n  output [WB_DATA_WIDTH-1:0]      wb_dat_o,\n  output reg                      wb_ack_o,\n  output                          wb_err_o,\n  output                          wb_rty_o\n);\nlocalparam NSTATES =        4;\nlocalparam STATE_IDLE =     4'b0001;\nlocalparam STATE_WRITE =    4'b0010;\nlocalparam STATE_READ =     4'b0100;\nlocalparam STATE_WAIT =     4'b1000;\nreg [NSTATES-1:0] state;\nreg rrq;\nreg wrq;\nwire tx_done;\nwire rx_valid;\nhyperbus_fifo fifo_inst (\n  .hbus_clk(hbus_clk),\n  .hbus_rst(hbus_rst),\n  .hbus_adr_o(hbus_adr_o),\n  .hbus_dat_i(hbus_dat_i),\n  .hbus_dat_o(hbus_dat_o),\n  .hbus_mask_o(hbus_mask_o),\n  .hbus_rrq(hbus_rrq),\n  .hbus_wrq(hbus_wrq),\n  .hbus_ready(hbus_ready),\n  .hbus_valid(hbus_valid),\n  .clk(wb_clk),\n  .rst(wb_rst),\n  .rrq(rrq),\n  .wrq(wrq),\n  .adr_i({wb_adr_i[31:2], 2'b00}),\n  .tx_dat_i(wb_dat_i),\n  .tx_mask_i(~wb_sel_i),\n  .rx_dat_o(wb_dat_o),\n  .tx_done(tx_done),\n  .rx_valid(rx_valid)\n);\nalways @(posedge wb_clk) begin\n  if(wb_rst) begin\n    rrq <= 1'b0;\n    wrq <= 1'b0;\n    state <= STATE_IDLE;\n  end else begin\n    wb_ack_o <= 1'b0;\n    rrq <= 1'b0;\n    wrq <= 1'b0;\n    case(state)\n      STATE_IDLE: begin\n        state <= STATE_IDLE;\n        if (~wb_ack_o & wb_cyc_i & wb_stb_i & wb_we_i) begin\n          wrq <= 1'b1;\n          state <= STATE_WRITE;\n        end else if (~wb_ack_o & wb_cyc_i & wb_stb_i & ~wb_we_i) begin\n          rrq <= 1'b1;\n          state <= STATE_READ;\n        end\n      end\n      STATE_READ: begin\n        if(rx_valid) begin\n          state <= STATE_IDLE;\n          wb_ack_o <= 1'b1;\n        end\n      end\n      STATE_WRITE: begin\n        if(tx_done) begin\n          state <= STATE_IDLE;\n          wb_ack_o <= 1'b1;\n        end\n      end\n      default: state <= STATE_IDLE;\n    endcase\n  end\nend\nassign wb_err_o = 0;\nassign wb_rty_o = 0;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'divider_testbench' module tests the 'N_divider' for clock division with variable factors. It employs internal signals (clk, rst, en, N, div_clk) to simulate operational scenarios, toggling clock and reset signals and altering division factors (N). Waveform output (graph.vcd) is generated for analysis.\nModule head:\n\nmodule divider_testbench;\nreg clk,rst,en;\nwire div_clk;\nreg[`SIZE-1:0] N;\nN_divider DIV(.ref_clk(clk), .enable(en), .N(N), .reset(rst), .div_clk(div_clk))",
        "output": "`timescale 1ns/1ns\n`include \"reg_size.v\"\nmodule divider_testbench;\nreg clk,rst,en;\nwire div_clk;\nreg[`SIZE-1:0] N;\nN_divider DIV(.ref_clk(clk), .enable(en), .N(N), .reset(rst), .div_clk(div_clk));\ninitial \nbegin\n  rst=0;\n  #2 rst=1;\n  #2 rst=0;\nend\ninitial\nbegin\n  clk=0;\n  forever #5 clk=~clk;\nend  \ninitial\nbegin\n      N=1;\n  #1  en=1;\n  #50 N=2; rst=1; en=0;\n  #2  rst=0; en=1;\n  #100 N=3; rst=1; en=0;\n  #2  rst=0; en=1;\n  #150 $finish;\nend\ninitial\nbegin\n  $dumpfile(\"graph.vcd\");\n  $dumpvars(0,divider_testbench);\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'dvsd_4bit_binary_counter' module functions as a 4-bit binary counter that can count up or down based on the 'updown' input, resetting on a high 'reset'. It increments or decrements the 4-bit output 'out' on every positive clock edge. If 'updown' is high, 'out' resets to 0 after reaching 15; if low, it resets to 15 after reaching 0. The operation hinges on conditional checking within a clock-edge triggered always block ensuring synchronous updates.\nModule head:\n module dvsd_4bit_binary_counter (input clk,\n                                   input reset,\n                                   input updown,\n                                   output reg[3:0] out)",
        "output": " module dvsd_4bit_binary_counter (input clk,\n                                   input reset,\n                                   input updown,\n                                   output reg[3:0] out);\n  always @ (posedge clk) begin  \n    if (reset)  \n      out <= 0;\n    else\n        if(updown==1)\n           if(out==15)\n               out <= 0;  \n           else\n               out <= out + 1; \n        else          \n            if(out==0)\n               out<=15;\n           else\n               out<= out-1;  \n  end  \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThis module, I2C_WRITE_BYTE, performs an I2C protocol-based byte write to a slave device. It leverages a state machine design illustrated by input/output ports and internal signals. The key input ports are RESET_N, PT_CK, GO, POINTER, SLAVE_ADDRESS, WDATA8, and SDAI, and the output ports of interest are SDAO, SCLO, END_OK, ST, CNT, BYTE, and ACK_OK. Internally, 9-bit signal 'A' is used for storing transmit data, while 'DELY' provides required delay at certain states. The state machine design characterizes the module's behavior and progresses based on the state transition indicated by the active value of the 'ST' status signal, consequently realizing the I2C transmission protocol.\nModule head:\nmodule I2C_WRITE_BYTE  (\n   input  \t\t\t\tRESET_N ,\n\tinput      \t\t  \tPT_CK,\n\tinput      \t\t  \tGO,\n\tinput LIGHT_INT ,\n\tinput      [7:0] \tPOINTER,\n\tinput      [7:0] \tSLAVE_ADDRESS,\t\n\tinput      [7:0]\tWDATA8,\t\t\n\tinput            \tSDAI,\n\toutput reg       \tSDAO,\n\toutput reg       \tSCLO,\n\toutput reg       \tEND_OK,\n\toutput SDAI_W ,\n\toutput reg [7:0] \tST ,\n\toutput reg [7:0] \tCNT,\n\toutput reg [7:0] \tBYTE,\n\toutput reg       \tACK_OK\n)",
        "output": "module I2C_WRITE_BYTE  (\n   input  \t\t\t\tRESET_N ,\n\tinput      \t\t  \tPT_CK,\n\tinput      \t\t  \tGO,\n\tinput LIGHT_INT ,\n\tinput      [7:0] \tPOINTER,\n\tinput      [7:0] \tSLAVE_ADDRESS,\t\n\tinput      [7:0]\tWDATA8,\t\t\n\tinput            \tSDAI,\n\toutput reg       \tSDAO,\n\toutput reg       \tSCLO,\n\toutput reg       \tEND_OK,\n\toutput SDAI_W ,\n\toutput reg [7:0] \tST ,\n\toutput reg [7:0] \tCNT,\n\toutput reg [7:0] \tBYTE,\n\toutput reg       \tACK_OK\n);\nreg   [8:0]A ;\nreg   [7:0]DELY ;\nassign SDAI_W =SDAI ;\nalways @( negedge RESET_N or posedge  PT_CK )begin\nif (!RESET_N  ) ST <=0;\nelse \n\t  case (ST)\n\t    0: begin  \n\t\t      SDAO   <=1; \n\t         SCLO   <=1;\n\t         ACK_OK <=0;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\t\n\t         if (GO) ST  <=30 ; \n\t\t    end\t  \n\t    1: begin  \n\t\t      ST <=2 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n\t\t\t\tA <= {SLAVE_ADDRESS ,1'b1 };\n\t\t    end\n\t    2: begin  \n\t\t      ST <=3 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n\t\t    end\n\t    3: begin  \n\t\t      ST <=4 ; \n\t\t\t   { SDAO, A } <= { A ,1'b0 }; \n\t\t    end\n\t    4: begin  \n\t\t      ST <=5 ; \n\t\t\t   SCLO <= 1'b1 ; \n\t\t\t\tCNT <= CNT +1 ;\n\t\t    end\n\t    5: begin  \n\t\t\t   SCLO <= 1'b0 ; \n\t\t\t   if (CNT==9) begin\n\t\t\t\t     if ( BYTE ==2)  ST <= 6 ; \n\t\t\t\t\t  else  begin \n\t\t\t\t\t           CNT <=0 ; \n\t\t\t\t\t           ST <= 2 ;\n\t\t\t\t\t                if ( BYTE ==0 ) begin BYTE <=1  ; A <= {POINTER ,1'b1 }; end \n\t\t\t\t\t\t\t\t  else if ( BYTE ==1 ) begin BYTE <=2  ; A <= {WDATA8[7:0] ,1'b1 }; end \n\t\t\t\t\t\t\t  end\n\t\t\t\t\t  if ( !SDAI_W ) ACK_OK <=1 ; \n\t\t\t\t\t  else ACK_OK <=0 ; \n\t\t\t\t end\n\t\t\t\t else ST <= 2;\n\t\t    end\n\t    6: begin          \n\t\t      ST <=7 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n         end\n\t    7: begin          \n\t\t      ST <=8 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n         end\n\t    8: begin          \n\t\t      ST <=9 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b11; \n         end \n\t\t9:\tbegin\n\t\t      ST     <= 30; \n\t\t\t\tSDAO   <=1; \n\t         SCLO   <=1;\n\t         ACK_OK <=0;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\n\t\t     end\n\t\t  30: begin\n            if (!GO) ST  <=31;\n          end\t\t\t\n\t\t   31: begin  \n\t\t      END_OK<=0;\n\t\t\t\tST    <=1;\t\n\t\t\tend\t\n\t    40: begin  \n\t\t      END_OK<=0;\n\t\t\t\tCNT <=0 ; \n\t\t      ST <=32 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n\t\t\t\tA <= {SLAVE_ADDRESS ,1'b1 };\n\t\t    end\n\t    32: begin  \n\t\t      ST <=33 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n\t\t    end\t\t\t \n\t    33: begin  \n\t\t      ST <=34 ; \n\t\t\t   { SDAO, A } <= { A ,1'b0 }; \n\t\t    end\n\t    34: begin  \n\t\t      ST <=35 ; \n\t\t\t   SCLO <= 1'b1 ; \n\t\t\t\tCNT <= CNT +1 ;\n\t\t    end\n\t    35: begin  \n\t\t\t  if (CNT==9)  begin DELY<=0;  ST <= 36;end \n\t\t\t  else begin ST <= 32; SCLO <= 1'b0 ; end \n\t\t    end\t\n\t    36: begin  \n\t\t         DELY<=DELY+1;\n\t\t\t\t   if ( DELY > 10 )  begin \n\t\t\t\t\t\t\t  ST <= 31 ;  { SDAO,  SCLO } <= 2'b11; \n\t\t\t      end\n\t\t\tend\t\t\n\t  endcase \n end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `xor_gate_tb` module is designed as a testbench to verify the correct functionality of an XOR gate by driving different binary values to the gate and monitoring the output. It employs registers `a` and `b` to systematically alter the input values and a wire `y` to observe the output. The module simulates all possible input combinations through a structured sequence in the `initial` block, which also displays the results dynamically using `$monitor`, ensuring comprehensive testing of the XOR logic.\nModule head:\nmodule xor_gate_tb;\n  reg a, b;\n  wire y;\n  xor_gate xor1(.a(a), .b(b), .y(y))",
        "output": "module xor_gate_tb;\n  reg a, b;\n  wire y;\n  xor_gate xor1(.a(a), .b(b), .y(y));\n  initial\n  begin\n    $display(\"a  b  |  y\");\n    $monitor(\"%b   %b  |  %b\", a, b, y);\n    #1 a = 0; b = 0;\n    #1 a = 0; b = 1;\n    #1 a = 1; b = 0;\n    #1 a = 1; b = 1;\n    $finish;\n  end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Data_Memory module simulates a synchronous 64-entry memory block storing 32-bit words with word-aligned addressing via inputs A[31:2]. The module reads data ('RD') from and writes data ('WD') to these addresses based on the 'WE' signal during positive 'clk' edges. The RAM is initialized with specific default values. The main functionalities include conditional writing and continuous reading from the memory array.\nModule head:\n\nmodule Data_Memory(\n\t\t   input wire \t      clk, WE,\n\t\t   input wire [31:0]  A, WD,\n\t\t   output wire [31:0] RD\n\t\t   )",
        "output": "`timescale 1ns / 1ps\nmodule Data_Memory(\n\t\t   input wire \t      clk, WE,\n\t\t   input wire [31:0]  A, WD,\n\t\t   output wire [31:0] RD\n\t\t   );\n   reg [31:0] \t\t\t      RAM[63:0];\n   assign RD = RAM[A[31:2]]; \ninitial begin\n   RAM[32'h00_00_00_00]  = 32'hFACEFACE;\n   RAM[1]  = 32'h00000002; \n   RAM[2]  = 32'h00000003; \n   RAM[63] = 32'h000000063;  \nend\n   always @(posedge clk)\n     if (WE)\n       RAM[A[31:2]] <= WD;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe a25_barrel_shift module performs variable shift operations on a 32-bit input using both quick and full barrel shifting methods, which allows for optimized hardware performance based on shift demands. It selects between these methods using the status of internal registers and control signals, handling outputs and carry results by dynamically updating based on input conditions like shift amount, function mode, and reset events, thereby maintaining functional correctness across different operational states.\nModule head:\nmodule a25_barrel_shift (\ninput\t\t\t\tclk,\ninput\t\t\t\treset,\ninput                   scan_enable,\ninput\t\t\t\ttest_mode,\ninput       [31:0]          i_in,\ninput                       i_carry_in,\ninput       [7:0]           i_shift_amount,     \ninput                       i_shift_imm_zero,   \ninput       [1:0]           i_function,\noutput      [31:0]          o_out,\noutput                      o_carry_out,\noutput                      o_stall\n)",
        "output": "module a25_barrel_shift (\ninput\t\t\t\tclk,\ninput\t\t\t\treset,\ninput                   scan_enable,\ninput\t\t\t\ttest_mode,\ninput       [31:0]          i_in,\ninput                       i_carry_in,\ninput       [7:0]           i_shift_amount,     \ninput                       i_shift_imm_zero,   \ninput       [1:0]           i_function,\noutput      [31:0]          o_out,\noutput                      o_carry_out,\noutput                      o_stall\n);\nwire [31:0] quick_out;\nwire        quick_carry_out;\nwire [31:0] full_out;\nwire        full_carry_out;\nreg  [31:0] full_out_r;\nreg         full_carry_out_r;\nreg         use_quick_r;\nassign o_stall      = (|i_shift_amount[7:2]) & use_quick_r;\nassign o_out        = use_quick_r ? quick_out : full_out_r;\nassign o_carry_out  = use_quick_r ? quick_carry_out : full_carry_out_r;\nalways @(posedge reset, posedge clk) begin\n\tif (reset) begin\n\t\tfull_out_r\t\t<= 'd0;\n\t\tfull_carry_out_r\t<= 'd0;\n\t\tuse_quick_r\t\t<= 1'b1;\n\tend else begin\n\t\tfull_out_r       <= full_out;\n\t\tfull_carry_out_r <= full_carry_out;\n\t\tuse_quick_r      <= !o_stall;\n\tend\nend\na25_shifter #( \n    .FULL_BARREL (1)\n    )\nu_a25_shifter_full (\n    .i_in               ( i_in             ),\n    .i_carry_in         ( i_carry_in       ),\n    .i_shift_amount     ( i_shift_amount   ),   \n    .i_shift_imm_zero   ( i_shift_imm_zero ), \n    .i_function         ( i_function       ),\n    .o_out              ( full_out         ),\n    .o_carry_out        ( full_carry_out   )\n);\na25_shifter #( \n    .FULL_BARREL        ( 0                ) \n    )\nu_a25_shifter_quick (\n    .i_in               ( i_in             ),\n    .i_carry_in         ( i_carry_in       ),\n    .i_shift_amount     ( i_shift_amount   ),   \n    .i_shift_imm_zero   ( i_shift_imm_zero ), \n    .i_function         ( i_function       ),\n    .o_out              ( quick_out        ),\n    .o_carry_out        ( quick_carry_out  )\n);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe ALU_test module verifies the functionality of an ALU (CHIP module) by applying test patterns and comparing outputs with expected results, using a clock-driven simulation. It reads test vectors from external files, drives the ALU inputs based on these vectors at the negative edge of the clock, and checks outputs against expected results at the positive edge. Errors and a summary are logged to a file, ensuring comprehensive error tracking and output verification.\nModule head:\n    \nmodule ALU_test;\nparameter DATA_LENGTH   = 80;\nparameter OUT_LENGTH    = 82;\nreg           clk;\nreg           reset;\nreg   [7:0]   datain1,datain2;\nreg   [2:0]   cmd;\nwire  [15:0]  dataout;\nreg   [2:0]   cmd_mem   [0:DATA_LENGTH-1];\nreg   [15:0]  out_mem   [0:OUT_LENGTH-1];\nreg   [7:0]   image1_mem  [0:DATA_LENGTH-1];\nreg   [7:0]   image2_mem  [0:DATA_LENGTH-1];\nreg   [15:0]  out_temp;\nreg           stop;\ninteger       i, out_f, err, pattern_num;\nreg           over;\n   CHIP top( .clk_p_i(clk), .reset_n_i(reset), .data_a_i(datain1), .data_b_i(datain2), .inst_i(cmd), .data_o(dataout) )",
        "output": "`timescale 1ns/10ps\n`define CYCLE    10           \t         \n`define SDFFILE  \"./CHIP.sdf\"\t         \n`define IMAGE1     \"./data1.dat\"         \n`define IMAGE2     \"./data2.dat\"         \n`define CMD        \"./cmd.dat\"           \n`define EXPECT     \"./out_golden.dat\"    \nmodule ALU_test;\nparameter DATA_LENGTH   = 80;\nparameter OUT_LENGTH    = 82;\nreg           clk;\nreg           reset;\nreg   [7:0]   datain1,datain2;\nreg   [2:0]   cmd;\nwire  [15:0]  dataout;\nreg   [2:0]   cmd_mem   [0:DATA_LENGTH-1];\nreg   [15:0]  out_mem   [0:OUT_LENGTH-1];\nreg   [7:0]   image1_mem  [0:DATA_LENGTH-1];\nreg   [7:0]   image2_mem  [0:DATA_LENGTH-1];\nreg   [15:0]  out_temp;\nreg           stop;\ninteger       i, out_f, err, pattern_num;\nreg           over;\n   CHIP top( .clk_p_i(clk), .reset_n_i(reset), .data_a_i(datain1), .data_b_i(datain2), .inst_i(cmd), .data_o(dataout) );          \ninitial\t$readmemh (`IMAGE1,  image1_mem);\ninitial\t$readmemh (`IMAGE2,  image2_mem);\ninitial\t$readmemh (`CMD,    cmd_mem);\ninitial\t$readmemh (`EXPECT, out_mem);\ninitial begin\n   clk         = 1'b1;\n   reset       = 1'b1;\n   stop        = 1'b0;  \n   over        = 1'b0;\n   pattern_num = 0;\n   err         = 0;\n   i           = 0;   \n    #2.5 reset=1'b0;                            \n    #2.5 reset=1'b1;\nend\nalways begin #(`CYCLE/2) clk = ~clk; end\ninitial begin\n\t$dumpfile(\"alu.fsdb\");\n\t$dumpvars;\n   out_f = $fopen(\"out.dat\");\n   if (out_f == 0) begin\n        $display(\"Output file open error !\");\n        $finish;\n   end\nend\nalways @(negedge clk)begin\n    if (i < OUT_LENGTH) begin\n\t\t if(i < DATA_LENGTH)begin\n          cmd      = cmd_mem[i];\n          datain1  = image1_mem[i];\n\t       datain2  = image2_mem[i];\n\t    end\n\t\t out_temp = out_mem[i];\n\t    i = i+1;      \n    end\n    else                                       \n       stop = 1 ;      \nend\nalways @(posedge clk)begin\n    if(dataout !== out_temp && out_temp!==16'h0000) begin\n        $display(\"ERROR at %d:output %h !=expect %h \",pattern_num-2, dataout, out_temp);\n\t    $fdisplay(out_f,\"ERROR at %d:output %h !=expect %h \",pattern_num-2, dataout, out_temp);\n        err = err + 1 ;\n    end\n    pattern_num = pattern_num + 1; \n    if(pattern_num === OUT_LENGTH)  over = 1'b1;\nend\ninitial begin\n      @(posedge stop)      \n      if(over) begin\n         $display(\"---------------------------------------------\\n\");\n         if (err == 0)  begin\n            $display(\"All data have been generated successfully!\\n\");\n\t\t\t$display(\"You will get 80 score in this gate-level netlist!\\n\");\n            $display(\"-------------------PASS-------------------\\n\");\n         end\n         else begin\n            $display(\"There are %d errors!\\n\", err);\n\t\t\t$display(\"You will get %d score in this RTL!\\n\", 80-err);\n\t\t end\n            $display(\"---------------------------------------------\\n\");\n      end\n      else begin\n        $display(\"---------------------------------------------\\n\");\n        $display(\"Error!!! There is no any data output ...!\\n\");\n        $display(\"-------------------FAIL-------------------\\n\");\n        $display(\"---------------------------------------------\\n\");\n      end\n      $finish;\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `idct_add1` module performs arithmetic operations (addition and subtraction) on paired 32-bit input signals to produce 32-bit output signals, useful in signal processing tasks like Inverse Discrete Cosine Transform (IDCT). It directly assigns the results of these operations to output ports using simple assignment statements in Verilog, thereby avoiding the use of internal signals and enabling a straightforward and efficient computation pathway from input to output.\nModule head:\n\nmodule idct_add1(\n    input [31:0] s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,\n    output [31:0] t0, t1, t2, t3, t4, t5, t6, t7, t8, t9\n    )",
        "output": "`timescale 1ns / 1ps\nmodule idct_add1(\n    input [31:0] s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,\n    output [31:0] t0, t1, t2, t3, t4, t5, t6, t7, t8, t9\n    );\n        assign t0 = s0 + s3;\n        assign t3 = s0 - s3;\n        assign t1 = s1 + s2;\n        assign t2 = s1 - s2;\n        assign t4 = s4 + s5;\n        assign t5 = s4 - s5;\n        assign t7 = s7 + s6;\n        assign t6 = s7 - s6;\n        assign t9 = s8 - s9;\n        assign t8 = s10 + s11;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe IOBUF_LVCMOS33_F_6 module is a bidirectional I/O buffer for LVCMOS33 standards with the capability to drive or tristate the IO pin based on inputs 'I' and control 'T', alongside the global tristate 'GTS'. It utilizes internal logic with an OR gate to determine tristate conditions ('ts') and controls the IO pin state with a conditional buffer (bufif0), while output 'O' reflects the IO pin state, allowing external monitoring of the pin status.\nModule head:\n\nmodule IOBUF_LVCMOS33_F_6 (O, IO, I, T)",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_LVCMOS33_F_6 (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe IOBUF_SSTL3_I module acts as a bidirectional I/O buffer for SSTL3 interfaces, toggling between input and output based on control signals. It manages data transmission through an `IO` pin controlled by input `I` and tristate `T`, impacted also by a global `GTS`. The state of `IO` is replicated at output `O` for monitoring or further transmission. Tristate management uses an internal signal `ts`, computed from `GTS` and `T` through an OR gate, driving a tristate buffer `bufif0` that determines the high-impedance status of `IO`, while a simple buffer maintains the integrity of `O`.\nModule head:\n\nmodule IOBUF_SSTL3_I (O, IO, I, T)",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_SSTL3_I (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Forwarding_unit module prevents data hazards in a pipelined processor by forwarding data based on register write operations at different pipeline stages. Utilizing input register values, the module sets forwarding control signals (forwardA, forwardB, forwardRs, forwardRt) according to potential data hazards detected. This efficient hazard detection and mitigation mechanism prevent pipeline stalls, ensuring smooth data flow throughout the processor operation.\nModule head:\nmodule Forwarding_unit(\n    input wire [1:0] IF_ID_rs,\n    input wire [1:0] IF_ID_rt,\n    input wire [1:0] ID_EX_rs,\n    input wire [1:0] ID_EX_rt,\n    input wire [1:0] ID_EX_rd,\n    input wire [1:0] EX_MEM_rd,\n    input wire [1:0] MEM_WB_rd,\n    input wire ID_EX_RegWrite,\n    input wire EX_MEM_RegWrite,\n    input wire MEM_WB_RegWrite,\n    output reg [1:0] forwardA,\n    output reg [1:0] forwardB,\n    output reg [1:0] forwardRs,\n    output reg [1:0] forwardRt\n)",
        "output": "module Forwarding_unit(\n    input wire [1:0] IF_ID_rs,\n    input wire [1:0] IF_ID_rt,\n    input wire [1:0] ID_EX_rs,\n    input wire [1:0] ID_EX_rt,\n    input wire [1:0] ID_EX_rd,\n    input wire [1:0] EX_MEM_rd,\n    input wire [1:0] MEM_WB_rd,\n    input wire ID_EX_RegWrite,\n    input wire EX_MEM_RegWrite,\n    input wire MEM_WB_RegWrite,\n    output reg [1:0] forwardA,\n    output reg [1:0] forwardB,\n    output reg [1:0] forwardRs,\n    output reg [1:0] forwardRt\n);\n    always @(*) begin\n        if(EX_MEM_RegWrite && EX_MEM_rd == ID_EX_rs) forwardA = 2'b10;              \n        else if(MEM_WB_RegWrite && MEM_WB_rd == ID_EX_rs) forwardA = 2'b01;         \n        else forwardA=0;\n        if(EX_MEM_RegWrite && EX_MEM_rd == ID_EX_rt) forwardB=2'b10;                \n        else if(MEM_WB_RegWrite && MEM_WB_rd == ID_EX_rt) forwardB = 2'b01;         \n        else forwardB=0;\n        if(ID_EX_RegWrite && ID_EX_rd == IF_ID_rs) forwardRs = 2'b11;               \n        else if(EX_MEM_RegWrite && EX_MEM_rd == IF_ID_rs) forwardRs=2'b10;          \n        else if(MEM_WB_RegWrite && MEM_WB_rd == IF_ID_rs) forwardRs = 2'b01;        \n        else forwardRs=0;\n        if(ID_EX_RegWrite && ID_EX_rd == IF_ID_rt) forwardRt = 2'b11;               \n        else if(EX_MEM_RegWrite && EX_MEM_rd == IF_ID_rt) forwardRt=2'b10;          \n        else if(MEM_WB_RegWrite && MEM_WB_rd == IF_ID_rt) forwardRt = 2'b01;        \n        else forwardRt=0;\n    end        \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe VGA_Ctrl module drives a VGA display by generating sync signals and RGB outputs. It takes RGB input values and a clock, outputting appropriate VGA signals including pixel coordinates, sync pulses, and blanking via horizontal and vertical counters, timing parameters, and conditional logic in the always block, ensuring tight synchronization and precise pixel placement.\nModule head:\nmodule\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t)",
        "output": "module\tVGA_Ctrl\t(\t\n\t\t\t\t\t\tiRed,\n\t\t\t\t\t\tiGreen,\n\t\t\t\t\t\tiBlue,\n\t\t\t\t\t\toCurrent_X,\n\t\t\t\t\t\toCurrent_Y,\n\t\t\t\t\t\toAddress,\n\t\t\t\t\t\toRequest,\n\t\t\t\t\t\toVGA_R,\n\t\t\t\t\t\toVGA_G,\n\t\t\t\t\t\toVGA_B,\n\t\t\t\t\t\toVGA_HS,\n\t\t\t\t\t\toVGA_VS,\n\t\t\t\t\t\toVGA_SYNC,\n\t\t\t\t\t\toVGA_BLANK,\n\t\t\t\t\t\toVGA_CLOCK,\n\t\t\t\t\t\tiCLK,\n\t\t\t\t\t\tiRST_N\t);\ninput\t\t[9:0]\tiRed;\ninput\t\t[9:0]\tiGreen;\ninput\t\t[9:0]\tiBlue;\noutput\t\t[21:0]\toAddress;\noutput\t\t[10:0]\toCurrent_X;\noutput\t\t[10:0]\toCurrent_Y;\noutput\t\t\t\toRequest;\noutput\t\t[9:0]\toVGA_R;\noutput\t\t[9:0]\toVGA_G;\noutput\t\t[9:0]\toVGA_B;\noutput\treg\t\t\toVGA_HS;\noutput\treg\t\t\toVGA_VS;\noutput\t\t\t\toVGA_SYNC;\noutput\t\t\t\toVGA_BLANK;\noutput\t\t\t\toVGA_CLOCK;\ninput\t\t\t\tiCLK;\ninput\t\t\t\tiRST_N;\t\nreg\t\t\t[10:0]\tH_Cont;\nreg\t\t\t[10:0]\tV_Cont;\nparameter\tH_FRONT\t=\t16;\nparameter\tH_SYNC\t=\t96;\nparameter\tH_BACK\t=\t48;\nparameter\tH_ACT\t=\t640;\nparameter\tH_BLANK\t=\tH_FRONT+H_SYNC+H_BACK;\nparameter\tH_TOTAL\t=\tH_FRONT+H_SYNC+H_BACK+H_ACT;\nparameter\tV_FRONT\t=\t11;\nparameter\tV_SYNC\t=\t2;\nparameter\tV_BACK\t=\t31;\nparameter\tV_ACT\t=\t480;\nparameter\tV_BLANK\t=\tV_FRONT+V_SYNC+V_BACK;\nparameter\tV_TOTAL\t=\tV_FRONT+V_SYNC+V_BACK+V_ACT;\nassign\toVGA_SYNC\t=\t1'b1;\t\t\t\nassign\toVGA_BLANK\t=\t~((H_Cont<H_BLANK)||(V_Cont<V_BLANK));\nassign\toVGA_CLOCK\t=\t~iCLK;\nassign\toVGA_R\t\t=\tiRed;\nassign\toVGA_G\t\t=\tiGreen;\nassign\toVGA_B\t\t=\tiBlue;\nassign\toAddress\t=\toCurrent_Y*H_ACT+oCurrent_X;\nassign\toRequest\t=\t((H_Cont>=H_BLANK && H_Cont<H_TOTAL)\t&&\n\t\t\t\t\t\t (V_Cont>=V_BLANK && V_Cont<V_TOTAL));\nassign\toCurrent_X\t=\t(H_Cont>=H_BLANK)\t?\tH_Cont-H_BLANK\t:\t11'h0\t;\nassign\toCurrent_Y\t=\t(V_Cont>=V_BLANK)\t?\tV_Cont-V_BLANK\t:\t11'h0\t;\nalways@(posedge iCLK or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tH_Cont\t\t<=\t0;\n\t\toVGA_HS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(H_Cont<H_TOTAL)\n\t\tH_Cont\t<=\tH_Cont+1'b1;\n\t\telse\n\t\tH_Cont\t<=\t0;\n\t\tif(H_Cont==H_FRONT-1)\t\t\t\n\t\toVGA_HS\t<=\t1'b0;\n\t\tif(H_Cont==H_FRONT+H_SYNC-1)\t\n\t\toVGA_HS\t<=\t1'b1;\n\tend\nend\nalways@(posedge oVGA_HS or negedge iRST_N)\nbegin\n\tif(!iRST_N)\n\tbegin\n\t\tV_Cont\t\t<=\t0;\n\t\toVGA_VS\t\t<=\t1;\n\tend\n\telse\n\tbegin\n\t\tif(V_Cont<V_TOTAL)\n\t\tV_Cont\t<=\tV_Cont+1'b1;\n\t\telse\n\t\tV_Cont\t<=\t0;\n\t\tif(V_Cont==V_FRONT-1)\t\t\t\n\t\toVGA_VS\t<=\t1'b0;\n\t\tif(V_Cont==V_FRONT+V_SYNC-1)\t\n\t\toVGA_VS\t<=\t1'b1;\n\tend\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'adder_nbit' module performs addition of two binary numbers with a configurable bit-width 'N'. It directly computes the sum of inputs 'a' and 'b' within a combinational always block, outputting the result on the 'sum' port which has 'N+1' bits to handle overflow, thereby not using any intermediate signals for succinct hardware utilization.\nModule head:\nmodule adder_nbit \n    #( parameter N = 3)",
        "output": "module adder_nbit \n    #( parameter N = 3)\n    (input [N-1:0] a,\n     input [N-1:0] b,\n     output reg [N:0] sum);\n    always @(*) begin\n       sum[N:0] = a[N-1:0] + b[N-1:0];\n    end  \nendmodule\n`timescale 1us/1ns\nmodule tb_adder_nbit();\n    parameter ADDER_WIDTH = 10;\n    reg  [ADDER_WIDTH-1:0] a;\n    reg  [ADDER_WIDTH-1:0] b;\n    wire [ADDER_WIDTH:0] sum;\n    adder_nbit \n    #(.N(ADDER_WIDTH))\n    ADDER1\n    (\n        .a(a),\n        .b(b),\n        .sum(sum)      \n    );\n    initial begin\n        $monitor($time, \" a = %d, b = %d, sum = %d\", a, b, sum);\n        #1; a = 0  ; b = 0  ;\n        #2; a = 1  ; b = 99 ;\n        #1; a = 33 ; b = 66 ;\n        #1; a = 100; b = 47 ;\n\t\t#1; $stop;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe \"IBUFG_SSTL18_II\" module is designed as a buffer, accepting a single-ended input 'I' and delivering a buffered output 'O'. It employs a basic buffer named 'B1' to ensure the integrity of the signal from input to output without using additional internal signals, making it ideal for maintaining signal integrity in compliance with the SSTL18_II standard.\nModule head:\n\nmodule IBUFG_SSTL18_II (O, I)",
        "output": "`timescale  1 ps / 1 ps\nmodule IBUFG_SSTL18_II (O, I);\n    output O;\n    input  I;\n\tbuf B1 (O, I);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe LD module implements a latch mechanism enabled by a gate signal to store and output data. It utilizes input 'D' for data capture and 'G' for gating, outputting through 'Q'. Internally, 'q_out' registers data when 'G' is high, while a global reset 'GSR' asynchronously clears 'q_out' to an initial state given by INIT. Timing constraints are managed by specify blocks, ensuring proper setup and hold times for reliable operations.\nModule head:\n\nmodule LD (Q, D, G)",
        "output": "`timescale  1 ps / 1 ps\nmodule LD (Q, D, G);\n    parameter INIT = 1'b0;\n    output Q;\n    wire Q;\n    input  D, G;\n    tri0 GSR = glbl.GSR;\n    reg q_out;\n    initial q_out = INIT;\n    assign Q = q_out;\n    always @(D or G or GSR)\n        if (GSR)\n            q_out <= INIT;\n        else\n\t     if (G)\n\t\tq_out <= D;\n    specify\n\tif (G)\n\t    (D +=> Q) = (100, 100);\n\t(posedge G => (Q +: D)) = (100, 100);\n    endspecify\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `sync_signal` module synchronizes an input signal ('in') with a given clock signal ('clk'). It uses a sequence of flip-flops defined by the 'sync_reg' array to pipeline 'in' across 'N' clock cycles. On each clock's rising edge, 'in' is loaded into the first register, and the data from each register is sequentially moved to the next, with 'out' giving the synced result from the last flip-flop. This module mitigates metastability issues by allowing the signal multiple clock cycles to stabilize before reaching 'out'.\nModule head:\n\nmodule sync_signal #(\n    parameter WIDTH=1, \n    parameter N=2 \n)",
        "output": "`resetall\n`timescale 1 ns / 1 ps\n`default_nettype none\nmodule sync_signal #(\n    parameter WIDTH=1, \n    parameter N=2 \n)(\n    input wire clk,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\nreg [WIDTH-1:0] sync_reg[N-1:0];\nassign out = sync_reg[N-1];\ninteger k;\nalways @(posedge clk) begin\n    sync_reg[0] <= in;\n    for (k = 1; k < N; k = k + 1) begin\n        sync_reg[k] <= sync_reg[k-1];\n    end\nend\nendmodule\n`resetall"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe pipo_8bit module implements an 8-bit parallel-in parallel-out shift register that captures input data (in) synchronized to a slower clock derived from the main clock (clk). The data captured by the individual flip-flops (d_ff instances) on the rising edge of the generated slow clock (w1 from slow_clk sub-module) is outputted through the y port. The module handles resets using the rst input to clear all stored data.\nModule head:\n\nmodule pipo_8bit(\n    input [7:0] in,\n    input clk,rst,\n    output [7:0] y\n    )",
        "output": "`timescale 1ns / 1ps\nmodule pipo_8bit(\n    input [7:0] in,\n    input clk,rst,\n    output [7:0] y\n    );\n    wire w1;\n    slow_clk clock(.clk_in(clk), .slow_clk(w1));\n    d_ff d1(in[0],w1,rst,y[0]);\n    d_ff d2(in[1],w1,rst,y[1]);\n    d_ff d3(in[2],w1,rst,y[2]);\n    d_ff d4(in[3],w1,rst,y[3]);\n    d_ff d5(in[4],w1,rst,y[4]);\n    d_ff d6(in[5],w1,rst,y[5]);\n    d_ff d7(in[6],w1,rst,y[6]);\n    d_ff d8(in[7],w1,rst,y[7]);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe EEPROM module enables the reading and writing of MAC and IP addresses from/to EEPROM memory using the SPI protocol. Input signals control operations such as read_MAC, read_IP, and write_IP. The processed data is output through This_MAC and This_IP. A state machine driven by the variable EEPROM manages transitions between operational states. Internal registers capture and shift data, while implementing a delay mechanism ensures precise control over data transfer timing. The SPI protocol is adhered to in all read/write operations, maintaining the robustness of the module.\nModule head:\nmodule EEPROM (clock, read_MAC, read_IP, write_IP, IP_to_write, CS, SCK, SI, SO, This_MAC, This_IP, MAC_ready, IP_ready, IP_write_done)",
        "output": "module EEPROM (clock, read_MAC, read_IP, write_IP, IP_to_write, CS, SCK, SI, SO, This_MAC, This_IP, MAC_ready, IP_ready, IP_write_done);\ninput clock;\ninput SO;\ninput read_MAC;\ninput read_IP;\ninput write_IP;\ninput [31:0] IP_to_write;\t\noutput CS;\noutput SI;\noutput SCK;\noutput [47:0]This_MAC;\noutput [31:0]This_IP;\noutput MAC_ready;\noutput IP_ready;\noutput IP_write_done;\nreg CS = 1'b1;\nreg SCK;\nreg SI;\nwire SO;\nreg [5:0]shift_count;\nreg [15:0]EEPROM_read; \nreg [47:0]EEPROM_write;\nreg [7:0]EEPROM_write_enable;\nreg [3:0]EEPROM;\nreg [47:0]This_MAC;\nreg [31:0]This_IP;\nreg MAC_ready;\t\t\t\t\t\t\nreg IP_ready;\t\t\t\t\t\t\nreg IP_flag;\t\t\t\t\t\t\nreg IP_write_done;\t\t\t\t\nreg [16:0]delay;\nlocalparam\tWREN = 8'h06;\nalways @ (posedge clock)\nbegin \n\tcase (EEPROM)\n\t0:\tbegin\n\t\tshift_count <= 0; \t\t\t\t\t\t\t\n\t\tIP_flag <= 0;\t\t\t\t\t\t\t\t\t\n\t\tMAC_ready <= 0;\t\t\t\t\t\t\t\t\n\t\tIP_write_done <= 0;\n\t\tIP_ready  <= 0;\n\t\tdelay <= 0;\n\t\t\tif (read_MAC) begin \t\t\t\t\t\t\n\t\t\t\tEEPROM_read <= 16'h03FA; \t\t\t\n\t\t\t\tCS <= 0;\n\t\t\t\tSI <= EEPROM_read[15];\n\t\t\t\tEEPROM <= 1;\n\t\t\tend\n\t\t\telse if (read_IP) begin\n\t\t\t\tThis_IP <= 0;\n\t\t\t\tEEPROM_read <= 16'h0300;\t\t\t\n\t\t\t\tCS <= 0;\n\t\t\t\tSI <= EEPROM_read[15];\n\t\t\t\tIP_flag <= 1'b1;\t\t\t\t\t\t\n\t\t\t\tEEPROM <= 1;\n\t\t\tend\n\t\t\telse if (write_IP) begin\t\t\t\t\n\t\t\t\tEEPROM_write_enable <= WREN;\t\t\n\t\t\t\tCS <= 0;\n\t\t\t\tSI <= EEPROM_write_enable[7];\n\t\t\t\tEEPROM <= 6;\n\t\t\tend \n\t\t\telse EEPROM <= 0;\n\t\tend \n\t1:  begin\n\t\tSCK <= 1;\n\t\tEEPROM_read <= {EEPROM_read[14:0],1'b0};    \n\t\tEEPROM <= EEPROM + 1'b1;\n\t\tend \n\t2:\tbegin\n\t\tSCK <= 0;\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tif (shift_count != 15) begin\t\t\t\t\t\n\t\t\t\tSI <= EEPROM_read[15];\t\t\t\t\t\t\n\t\t\t\tshift_count <= shift_count + 1'b1;\t\n\t\t\t\tEEPROM <= 1;\n\t\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count <= 0;\n\t\t\t\tEEPROM <= EEPROM + 1'b1;   \n\t\t\tend \n\t\tend \n\t3:\tbegin \n\t\t\tif (IP_flag) begin \n\t\t\t\tif (shift_count != 32) begin \t\t\t\n\t\t\t\t\tThis_IP <= {This_IP[30:0],SO};\n\t\t\t\t\tshift_count <= shift_count + 1'b1;\n\t\t\t\t\tEEPROM <= EEPROM + 1'b1;\n\t\t\t\t\tSCK <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tIP_ready <= 1'b1;\t\t\t\t\t\t\n\t\t\t\t\tCS <= 1'b1;\n\t\t\t\t\tEEPROM <= 5;\t\t\t\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if (shift_count != 48) begin \n\t\t\t\tThis_MAC <= {This_MAC[46:0],SO};\n\t\t\t\tshift_count <= shift_count + 1'b1;\n\t\t\t\tEEPROM <= EEPROM + 1'b1;\n\t\t\t\tSCK <= 1'b1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tMAC_ready <= 1'b1;\t\t\t\t\t\t\n\t\t\t\tCS <= 1'b1;\t\t\t\t\t\t\t\t\t\n\t\t\t\tEEPROM <= 5;\t\t\t\t\t\t\t\t\n\t\t\tend \n\t\tend\n\t4:  begin\n\t\tSCK <= 0;\n\t\tEEPROM <= 3; \n\t\tend \n\t5:\tEEPROM <= 0;\n\t6:  begin\n\t\tSCK <= 1;\n\t\tEEPROM_write_enable <= {EEPROM_write_enable[6:0],1'b0};    \n\t\tEEPROM <= EEPROM + 1'b1;\n\t\tend \n\t7:\tbegin\n\t\tSCK <= 0;\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tif (shift_count != 7) begin\t\t\t\t\n\t\t\t\tSI <= EEPROM_write_enable[7];\t\t\t\n\t\t\t\tshift_count <= shift_count + 1'b1;\t\n\t\t\t\tEEPROM <= 6;\n\t\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count <= 0;\t\t\t\t\t\t\t\n\t\t\t\tCS <= 1'b1;\t\t\t\t\t\t\t\t\t\n\t\t\t\tEEPROM <= EEPROM + 1'b1;   \n\t\t\tend \n\t\tend \n\t8:\tEEPROM <= EEPROM + 1'b1;\n\t9: \tbegin\n\t\tEEPROM_write <= {16'h0200,IP_to_write};\t\t\n\t\tCS <= 0;\n\t\tSI <= EEPROM_write[47];\n\t\tEEPROM <= EEPROM + 1'b1;\n\t\tend\n\t10:  begin\n\t\tSCK <= 1;\n\t\tEEPROM_write <= {EEPROM_write[46:0],1'b0};    \n\t\tEEPROM <= EEPROM + 1'b1;\n\t\tend\n\t11:\tbegin \n\t\tSCK <= 0;\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tif (shift_count != 47) begin\t\t\t\t\t\n\t\t\t\tSI <= EEPROM_write[47];\t\t\t\t\t\t\n\t\t\t\tshift_count <= shift_count + 1'b1;\t\n\t\t\t\tEEPROM <= 10;\n\t\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count <= 0;\n\t\t\t\tCS <= 1'b1;\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tIP_write_done <= 1'b1;\t\t\t\t\t\t\n\t\t\t\tEEPROM <= 5; \t\t\t\t\t\t\t\t\t\n\t\t\tend \n\t\tend \t\n\tdefault: EEPROM <= 0; \n endcase\n end \n endmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe RAM module is a synchronous memory that reads and writes data at given addresses upon a clock signal. Parameters define data and address widths, and initial memory contents are loaded from a file. On each clock's positive edge, it writes data from 'din' to 'write_address' if 'write' is high, and updates 'dout' with the data at 'read_address'. This module provides a dynamic, file-initialized memory emulation for various applications.\nModule head:\nmodule RAM(clk,read_address,write_address,write,din,dout)",
        "output": "module RAM(clk,read_address,write_address,write,din,dout);\n  parameter data_width = 32; \n  parameter addr_width = 4;\n  parameter filename = \"data.txt\";\n  input clk;\n  input [addr_width-1:0] read_address, write_address;\n  input write;\n  input [data_width-1:0] din;\n  output [data_width-1:0] dout;\n  reg [data_width-1:0] dout;\n  reg [data_width-1:0] mem [2**addr_width-1:0];\n  initial $readmemb(filename, mem);\n  always @ (posedge clk) begin\n    if (write)\n      mem[write_address] <= din;\n    dout <= mem[read_address]; \n  end \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'gridPointsMem' module functions as a lookup table, translating a 6-bit input ('in') to a 16-bit output ('out'). It assigns predefined 16-bit values or their negations based on the input, using a case structure in an 'always' block. The internal register 'out' is set to zero at each cycle's start, updated according to 'in'. This module is ideal for symmetric waveform generation.\nModule head:\n\nmodule gridPointsMem(in,out)",
        "output": "`timescale 1ns / 1ps\nmodule gridPointsMem(in,out);\ninput [5:0] in;\noutput reg [15:0] out;\nalways @(*) begin\nout = 16'd0;\ncase (in)\n\t'd0: out = 16'd32760;\n\t'd1: out = 16'd32723;\n\t'd2: out = 16'd32588;\n\t'd3: out = 16'd32364;\n\t'd4: out = 16'd32051;\n\t'd5: out = 16'd31651;\n\t'd6: out = 16'd31164;\n\t'd7: out = 16'd30591;\n\t'd8: out = 16'd29935;\n\t'd9: out = 16'd29196;\n\t'd10: out = 16'd28377;\n\t'd11: out = 16'd27481;\n\t'd12: out = 16'd26509;\n\t'd13: out = 16'd25465;\n\t'd14: out = 16'd24351;\n\t'd15: out = 16'd23170;\n\t'd16: out = 16'd21926;\n\t'd17: out = 16'd20621;\n\t'd18: out = 16'd19260;\n\t'd19: out = 16'd17846;  \n\t'd20: out = 16'd16384; \n\t'd21: out = 16'd14876;\n\t'd22: out = 16'd13327;\n\t'd23: out = 16'd11743;\n\t'd24: out = 16'd10125;\n\t'd25: out = 16'd8480;\n\t'd26: out =\t16'd6812;\n\t'd27: out = 16'd5126;\n\t'd28: out =\t16'd3425;\n\t'd29: out = 16'd1714;\n\t'd30: out = 16'd0;\t  \n\t'd31: out = ~(16'd1714)+1;\n\t'd32: out = ~(16'd3425)+1; \n\t'd33: out = ~(16'd5126)+1;\n\t'd34: out =\t~(16'd6812)+1;\n\t'd35: out =\t~(16'd8480)+1;\n\t'd36: out = ~(16'd10125)+1;\n\t'd37: out =\t~(16'd11743)+1;\n\t'd38: out = ~(16'd13327)+1;\n\t'd39: out =\t~(16'd14876)+1;\n\t'd40: out =\t~(16'd16384)+1;\n\t'd41: out = ~(16'd17846)+1;\n\t'd42: out =\t~(16'd19260)+1;\n\t'd43: out =\t~(16'd20621)+1;\n\t'd44: out = ~(16'd21926)+1;\n\t'd45: out =\t~(16'd23170)+1;\n\t'd46: out =\t~(16'd24351)+1;\n\t'd47: out =\t~(16'd25465)+1;\n\t'd48: out =\t~(16'd26509)+1;\n\t'd49: out =\t~(16'd27481)+1;\n\t'd50: out =\t~(16'd28377)+1;\n\t'd51: out = ~(16'd29196)+1;\n\t'd52: out =\t~(16'd29935)+1;\n\t'd53: out =\t~(16'd30591)+1;\n\t'd54: out =\t~(16'd31164)+1;\n\t'd55: out =\t~(16'd31651)+1;\n\t'd56: out =\t~(16'd32051)+1;\n\t'd57: out = ~(16'd32364)+1;\n\t'd58: out = ~(16'd32588)+1;\n\t'd59: out =\t~(16'd32723)+1;\n\t'd60: out = ~(16'd32760)+1;\nendcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe ShiftRegister module implements a shift register with a parameterizable width, handling operations like data shifting and loading under control signals. It utilizes an internal `data` register to maintain state, updating its value on positive clock edges based on `reset`, `write`, and `shift` inputs. The least and most significant bits of the data are managed specifically for output and input during shifts, respectively.\nModule head:\nmodule ShiftRegister\n#(\n\tparameter WIDTH=11\n)",
        "output": "module ShiftRegister\n#(\n\tparameter WIDTH=11\n)\n(\n\tinput clk,\n\tinput reset,\n\tinput write,\n\tinput shift,\n\tinput[WIDTH-1:0] data_in,\n\tinput serial_in,\n\toutput serial_out,\n\toutput[WIDTH-1:0] data_out\n    );\n\treg[WIDTH-1:0] data;\n\talways @(posedge clk)\n\tbegin\n\t\tif(reset==1)\n\t\t\tdata<=0;\n\t\telse if(write==1)\n\t\t\tdata<=data_in;\n\t\telse if(shift==1)\n\t\t\tdata<={serial_in,data[WIDTH-1:1]};\n\tend\n\tassign serial_out=data[0];\n\tassign data_out=data;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `tb_jk_FF` module functions as a testbench for a JK flip-flop, simulating various input scenarios to validate its operations. It systematically manipulates input signals like clock, reset, write enable, set, and reset, and monitors the outputs `Q` and `Q_BAR`. Implementation includes an initial block for setting and altering inputs, a continuous block for generating a clock signal, and a monitoring block that displays output states at every negative clock edge, ensuring comprehensive testing of the flip-flop's response under controlled conditions.\nModule head:\nmodule tb_jk_FF()",
        "output": "module tb_jk_FF();\n\treg clk;\n\treg reset_n, write_en;\n\treg S, R;\n\twire Q, Q_BAR;\n\tjk_FF uut(clk, reset_n, write_en, S, R, Q, Q_BAR);\n\tinitial begin\n\t\tclk = 0;\n\t\treset_n = 1;\n\t\t#10;\n\t\treset_n = 0;\n\t\twrite_en = 1;\n\t\tS = 1;\n\t\tR = 0;\n\t\t#10;\n\t\tS = 0;\n\t\t#20;\n\t\tR = 1;\n\t\t#10;\n\t\tR = 0;\n\t\t#10;\n\t\tS = 1;\n\t\t#10;\n\t\twrite_en = 0;\n\t\tR = 1;\n\t\t#10;\n\t\tS = 1;\n\t\t#10;\n\t\treset_n = 1;\n\t\t#100;\n\t\t$finish;\n\tend\n\talways begin \n\t\t#5 clk = ~clk;\n\tend\n\t  always @ (negedge clk) begin\n        $display(\"%t: reset_n = %b, write_en = %b, S = %b, R = %b, Q = %b\",$time, reset_n, write_en, S, R, Q);\n    end\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'egd_top' module decodes exp-Golomb encoded data from a 16-bit input bitstream for video compression applications. It synchronizes operations using a clock input, initializes with an active-low reset, and selects decoding methods via a 2-bit selector. The module includes sub-modules for buffering the bitstream, detecting a specific pattern, and performing the decoding. Outputs include decoded data and counters tracking buffer fill and reset events, managed through internal signals coordinating data flow and processing steps.\nModule head:\nmodule egd_top (\n  input           clk, reset_n,\n  input   [1:0]   exp_golomb_sel,\n  input   [15:0]  BitStream_buffer_input,\n  output \t[2:0] \thalf_fill_counter,\n  output \t[3:0] \treset_counter,\n  output  [7:0]   exp_golomb_decoding_output\n)",
        "output": "module egd_top (\n  input           clk, reset_n,\n  input   [1:0]   exp_golomb_sel,\n  input   [15:0]  BitStream_buffer_input,\n  output \t[2:0] \thalf_fill_counter,\n  output \t[3:0] \treset_counter,\n  output  [7:0]   exp_golomb_decoding_output\n);\n  wire  [15:0]  BitStream_buffer_output;\n  wire  [3:0]   heading_one_pos, exp_golomb_len;\n  wire          heading_one_en;\n  wire  [7:0]   temp_egd_out;\n  wire  [2:0]   te_range;\n  parameter te                             = 2'b11;\n  BitStream_buffer BitStream_buffer (\n    .clk(~clk),\n    .reset_n(reset_n),\n    .BitStream_buffer_input(BitStream_buffer_input),\n    .exp_golomb_len(exp_golomb_len),\n    .BitStream_buffer_valid_n(heading_one_en),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .half_fill_counter(half_fill_counter),\n    .reset_counter(reset_counter)\n  );\n  heading_one_detector heading_one_detector (\n    .heading_one_en(heading_one_en),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .heading_one_pos(heading_one_pos)\n  );\n  exp_golomb_decoding exp_golomb_decoding (\n    .heading_one_pos(heading_one_pos),\n    .BitStream_buffer_output(BitStream_buffer_output),\n    .exp_golomb_sel(exp_golomb_sel),\n    .te_range(te_range),\n    .exp_golomb_decoding_output(temp_egd_out),\n    .exp_golomb_len(exp_golomb_len)\n  );\n  assign te_range = (exp_golomb_sel == te) ? (temp_egd_out[2:0] + 1) : 0;\n  assign exp_golomb_decoding_output = temp_egd_out;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'bcdtogray' module converts a 4-bit binary-coded decimal (BCD) into a corresponding 4-bit Gray code. The conversion is achieved using direct bitwise operations on the input 'b' and output 'e'. Each bit of the output 'e' is assigned a value based on these operations, resulting in the desired Gray code. No internal signals are used, simplifying design and increasing efficiency.\nModule head:\nmodule bcdtogray(b,e)",
        "output": "module bcdtogray(b,e);\ninput [3:0]b;\noutput [3:0]e;\nassign e[3] = b[3]|(b[2]&b[0])|(b[2]&b[1]);\nassign e[2] = (b[2]&~b[1]&&b[0])|(~b[2]&&b[0])|(~b[2]&&b[1]);\nassign e[1] = (~b[1]&~b[0])|(b[1]&b[0]);\nassign e[0] = (~b[0]);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'pipe1' module serves as a pipeline register, synchronizing a 32-bit instruction from 'instruction_in' to 'instruction_out' with a clock 'clk'. It uses an always block triggered on the rising edge of 'clk' to either pass 'instruction_in' directly to 'instruction_out' or reset 'instruction_out' to zero based on the 'reset' signal. This implementation ensures synchronized, stable instruction handling within the system.\nModule head:\nmodule pipe1(instruction_in, instruction_out, clk, reset)",
        "output": "module pipe1(instruction_in, instruction_out, clk, reset);\n\tinput [0:31] instruction_in;\n\tinput clk, reset;\n\toutput [0:31] instruction_out;\n\treg [0:31] instruction_out;\n\talways @ (posedge clk)\n\t\tbegin\n\t\tif (reset == 1'b1)\n\t\t\tbegin\n\t\t\tinstruction_out [0:31] <= 32'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tinstruction_out [0:31] <= instruction_in [0:31];\n\t\t\tend\n\t\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `dffsr_cell` module implements a D-type flip-flop with set and reset functionalities, storing data values via a triggered clock (`clk`). It utilizes internal registers (`q`) updated on positive edges of `clk`, `s`, or `r`. The `q` output reflects stored data or set/reset states, while `notq` outputs the negation. This setup provides versatile and conditional data retention crucial in synchronous and asynchronous control circuits.\nModule head:\n\nmodule buffer_cell (\n    input wire in,\n    output wire out\n    )",
        "output": "`define default_netname none\nmodule buffer_cell (\n    input wire in,\n    output wire out\n    );\n    assign out = in;\nendmodule\nmodule and_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a & b;\nendmodule\nmodule or_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a | b;\nendmodule\nmodule xor_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = a ^ b;\nendmodule\nmodule nand_cell (\n    input wire a,\n    input wire b,\n    output wire out\n    );\n    assign out = !(a&b);\nendmodule\nmodule not_cell (\n    input wire in,\n    output wire out\n    );\n    assign out = !in;\nendmodule\nmodule mux_cell (\n    input wire a,\n    input wire b,\n    input wire sel,\n    output wire out\n    );\n    assign out = sel ? b : a;\nendmodule\nmodule dff_cell (\n    input wire clk,\n    input wire d,\n    output reg q,\n    output wire notq\n    );\n    assign notq = !q;\n    always @(posedge clk)\n        q <= d;\nendmodule\nmodule dffsr_cell (\n    input wire clk,\n    input wire d,\n    input wire s,\n    input wire r,\n    output reg q,\n    output wire notq\n    );\n    assign notq = !q;\n    always @(posedge clk or posedge s or posedge r) begin\n        if (r)\n            q <= '0;\n        else if (s)\n            q <= '1;\n        else\n            q <= d;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe latency_aware_read_master module manages latency-aware memory read operations for FPGAs/ASICs. It controls the initiation and management of memory accesses based on input commands, handling read addresses, data amount, and triggering conditions. Internally, it uses registers for address and length tracking, a FIFO for data buffering, and logic for read requests and completion detection. The module optimizes reading by adjusting address increments, managing pending reads against FIFO capacity, and signaling operational states to external components.\nModule head:\nmodule latency_aware_read_master (\n\tclk,\n\treset,\n\tcontrol_fixed_location,\n\tcontrol_read_base,\n\tcontrol_read_length,\n\tcontrol_go,\n\tcontrol_done,\n\tcontrol_early_done,\n\tuser_read_buffer,\n\tuser_buffer_data,\n\tuser_data_available,\n\tmaster_address,\n\tmaster_read,\n\tmaster_byteenable,\n\tmaster_readdata,\n\tmaster_readdatavalid,\n\tmaster_waitrequest\n)",
        "output": "module latency_aware_read_master (\n\tclk,\n\treset,\n\tcontrol_fixed_location,\n\tcontrol_read_base,\n\tcontrol_read_length,\n\tcontrol_go,\n\tcontrol_done,\n\tcontrol_early_done,\n\tuser_read_buffer,\n\tuser_buffer_data,\n\tuser_data_available,\n\tmaster_address,\n\tmaster_read,\n\tmaster_byteenable,\n\tmaster_readdata,\n\tmaster_readdatavalid,\n\tmaster_waitrequest\n);\n\tparameter DATAWIDTH = 32;\n\tparameter BYTEENABLEWIDTH = 4;\n\tparameter ADDRESSWIDTH = 32;\n\tparameter FIFODEPTH = 32;\n\tparameter FIFODEPTH_LOG2 = 5;\n\tparameter FIFOUSEMEMORY = 1;  \n\tinput clk;\n\tinput reset;\n\tinput control_fixed_location;\n\tinput [ADDRESSWIDTH-1:0] control_read_base;\n\tinput [ADDRESSWIDTH-1:0] control_read_length;\n\tinput control_go;\n\toutput wire control_done;\n\toutput wire control_early_done;  \n\tinput user_read_buffer;\n\toutput wire [DATAWIDTH-1:0] user_buffer_data;\n\toutput wire user_data_available;\n\tinput master_waitrequest;\n\tinput master_readdatavalid;\n    input [DATAWIDTH-1:0] master_readdata;\n\toutput wire [ADDRESSWIDTH-1:0] master_address;\n\toutput wire master_read;\n\toutput wire [BYTEENABLEWIDTH-1:0] master_byteenable;\n\treg control_fixed_location_d1;\n\twire fifo_empty;\n\treg [ADDRESSWIDTH-1:0] address;\n\treg [ADDRESSWIDTH-1:0] length;\n\treg [FIFODEPTH_LOG2-1:0] reads_pending;\n\twire increment_address;\n\twire too_many_pending_reads;\n\treg too_many_pending_reads_d1;\n\twire [FIFODEPTH_LOG2-1:0] fifo_used;\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tcontrol_fixed_location_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (control_go == 1)\n\t\t\tbegin\n\t\t\t\tcontrol_fixed_location_d1 <= control_fixed_location;\n\t\t\tend\n\t\tend\n\tend\n\tassign master_address = address;\n\tassign master_byteenable = -1;  \n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\taddress <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\taddress <= control_read_base;\n\t\t\tend\n\t\t\telse if((increment_address == 1) & (control_fixed_location_d1 == 0))\n\t\t\tbegin\n\t\t\t\taddress <= address + BYTEENABLEWIDTH;  \n\t\t\tend\n\t\tend\n\tend\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tlength <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\tlength <= control_read_length;\n\t\t\tend\n\t\t\telse if(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tlength <= length - BYTEENABLEWIDTH;  \n\t\t\tend\n\t\tend\n\tend\t\n\tassign too_many_pending_reads = (fifo_used + reads_pending) >= (FIFODEPTH - 4);\n\tassign master_read = (length != 0) & (too_many_pending_reads_d1 == 0);\n\tassign increment_address = (length != 0) & (too_many_pending_reads_d1 == 0) & (master_waitrequest == 0);\n\tassign control_done = (reads_pending == 0) & (length == 0);  \n\tassign control_early_done = (length == 0);  \n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= too_many_pending_reads;\n\t\tend\n\tend\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\treads_pending <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  \n\t\t\t\tend\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  \n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending - 1;  \n\t\t\t\tend\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\n\tassign user_data_available = !fifo_empty;\n\tscfifo the_master_to_user_fifo (\n\t\t.aclr (reset),\n\t\t.clock (clk),\n\t\t.data (master_readdata),\n\t\t.empty (fifo_empty),\n\t\t.q (user_buffer_data),\n\t\t.rdreq (user_read_buffer),\n\t\t.usedw (fifo_used),\n\t\t.wrreq (master_readdatavalid)\n\t);\n\tdefparam the_master_to_user_fifo.lpm_width = DATAWIDTH;\n\tdefparam the_master_to_user_fifo.lpm_numwords = FIFODEPTH;\n\tdefparam the_master_to_user_fifo.lpm_showahead = \"ON\";\n\tdefparam the_master_to_user_fifo.use_eab = (FIFOUSEMEMORY == 1)? \"ON\" : \"OFF\";\n\tdefparam the_master_to_user_fifo.add_ram_output_register = \"OFF\";\n\tdefparam the_master_to_user_fifo.underflow_checking = \"OFF\";\n\tdefparam the_master_to_user_fifo.overflow_checking = \"OFF\";\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe MMU module manages memory accesses and data transfers, utilizing multiple clock signals and input conditions to synchronize operations. It interfaces with RAM through inputs like Active, Hold, and Init, and outputs like RWSelect and RAMEnable. Internally, state toggling is clock-driven, with sub-modules like ACSSURVIVORBUFFER handling data buffering. Address manipulation and data flow management are dynamically controlled, ensuring efficient operation across various memory segments and pages.\nModule head:\n\nmodule MMU (CLOCK, Clock1, Clock2, Reset, Active, Hold, Init, ACSPage, \nACSSegment_minusLSB, Survivors, \nDataTB, AddressTB,\nRWSelect, ReadClock, WriteClock, \nRAMEnable, AddressRAM, DataRAM)",
        "output": "`include \"params.v\"\nmodule MMU (CLOCK, Clock1, Clock2, Reset, Active, Hold, Init, ACSPage, \nACSSegment_minusLSB, Survivors, \nDataTB, AddressTB,\nRWSelect, ReadClock, WriteClock, \nRAMEnable, AddressRAM, DataRAM);\ninput CLOCK, Clock1, Clock2, Reset, Active, Hold, Init;\ninput [`WD_DEPTH-1:0] ACSPage;\ninput [`WD_FSM-2:0] ACSSegment_minusLSB;\ninput [`N_ACS-1:0] Survivors;\noutput [`WD_RAM_DATA-1:0] DataTB;\ninput [`WD_RAM_ADDRESS-`WD_FSM-1:0] AddressTB;\noutput RWSelect, ReadClock, WriteClock, RAMEnable;\noutput [`WD_RAM_ADDRESS-1:0] AddressRAM;\ninout [`WD_RAM_DATA-1:0] DataRAM;\nwire [`WD_RAM_DATA-1:0] WrittenSurvivors;\nreg dummy, SurvRDY;\nreg [`WD_RAM_ADDRESS-1:0] AddressRAM;\nreg [`WD_DEPTH-1:0] TBPage;\nwire [`WD_DEPTH-1:0] TBPage_;\nwire [`WD_DEPTH-1:0] ACSPage;\nwire [`WD_TB_ADDRESS-1:0] AddressTB;\nalways @(posedge Clock2 or negedge Reset) \nif (~Reset) dummy <= 0;else if (Active) dummy <= ~dummy;\nassign WriteClock = (Active && ~dummy) ? Clock1:0;\nassign ReadClock = (Active && ~Hold) ? ~Clock1:0;\nalways @(posedge Clock1 or negedge Reset) \nif (~Reset) SurvRDY <= 1; else if (Active) SurvRDY <= ~SurvRDY;\nACSSURVIVORBUFFER buff (Reset, Clock1, Active, SurvRDY, Survivors, \nWrittenSurvivors);\nalways @(negedge Clock2 or negedge Reset)\nbegin\nif (~Reset) begin\nTBPage <= 0;\nend\nelse if (Init) TBPage <= ACSPage-1;\nelse TBPage <= TBPage_;\nend\nassign TBPage_ = TBPage - 1;\nassign RAMEnable = 0;\nassign RWSelect = (Clock2) ? 1:0;\nassign DataRAM = (~Clock2) ? WrittenSurvivors:'bz;\nassign DataTB = (Clock2) ? DataRAM:'bz;\nalways @(posedge CLOCK or negedge Reset)\nbegin\nif (~Reset) AddressRAM <= 0;\nelse\nif (Active) begin\nif (Clock2 == 0) \nbegin\nAddressRAM <= {ACSPage, ACSSegment_minusLSB};\nend\nelse \nbegin\nAddressRAM <= {TBPage [`WD_DEPTH-1:0],AddressTB};\nend\nend\nend\nendmodule\nmodule ACSSURVIVORBUFFER (Reset, Clock1, Active, SurvRDY, Survivors, \nWrittenSurvivors);\ninput Reset, Clock1, Active, SurvRDY;\ninput [`N_ACS-1:0] Survivors;\noutput [`WD_RAM_DATA-1:0] WrittenSurvivors;\nwire [`WD_RAM_DATA-1:0] WrittenSurvivors;\nreg [`N_ACS-1:0] WrittenSurvivors_;\nalways @(posedge Clock1 or negedge Reset)\nbegin\nif (~Reset) WrittenSurvivors_ = 0;\nelse if (Active)\nWrittenSurvivors_ = Survivors;\nend\nassign WrittenSurvivors = (SurvRDY) ? {Survivors, WrittenSurvivors_}:8'bz;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `piso` module serializes a 4-bit parallel input into a serial output using a shift register formed by cascading piso_slice stages. These stages, controlled by the `control` signal and its negated form `control_bar`, select and propagate the data through DFR components synchronized by the `clk` and reset by `clear`, achieving the serial output dynamically per clock cycle.\nModule head:\nmodule invert (input wire i, output wire o)",
        "output": "module invert (input wire i, output wire o);\n   assign o = !i;\nendmodule\nmodule and2 (input wire i0, i1, output wire o);\n  assign o = i0 & i1;\nendmodule\nmodule or2 (input wire i0, i1, output wire o);\n  assign o = i0 | i1;\nendmodule\nmodule df (input wire clk, in, output wire out);\n  reg df_out;\n  always@(posedge clk) df_out <= in;\n  assign out = df_out;\nendmodule\nmodule dfr (input wire clk, reset, in, output wire out);\n  wire reset_, df_in;\n  invert invert_0 (reset, reset_);\n  and2 and2_0 (in, reset_, df_in);\n  df df_0 (clk, df_in, out);\nendmodule\nmodule piso_slice (input wire prev, new, control, control_bar, clk, clear, output wire data);\n    wire and_output[0:1];\n    wire or_output;\n    and2 and_1(prev, control, and_output[0]);\n    and2 and_2(new, control_bar, and_output[1]);\n    or2 or_1(and_output[0], and_output[1], or_output);\n    dfr dfr_1(clk, clear, or_output, data);\nendmodule\nmodule piso (input wire control, clk, clear, input wire [0:3] data_in, output wire data_out);\n    wire control_bar, dfr1_out;\n    wire piso_slice_out[0:1];\n    invert invert_1(control, control_bar);\n    dfr dfr1(clk, clear, data_in[0], dfr1_out);\n    piso_slice piso_slice1(dfr1_out, data_in[1], control, control_bar, clk, clear, piso_slice_out[0]);\n    piso_slice piso_slice2(piso_slice_out[0], data_in[2], control, control_bar, clk, clear, piso_slice_out[1]);\n    piso_slice piso_slice3(piso_slice_out[1], data_in[3], control, control_bar, clk, clear, data_out);\nendmodule;"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `user_project_wrapper` module acts as an interface unit for an extensive digital system. Handling signals for multiple subsystems, its functionality comprises assigning and routing I/O signals for Wishbone bus interface, logic analyzer, and general-purpose I/O. It also handles bidirectional analog lines and power lines based on conditional compilation. No internal signals or distinct functional blocks are present. The module directly maps input to output signals, with specific behaviors for simulation mode.\nModule head:\n\nmodule user_project_wrapper #(\n    parameter BITS = 32\n)",
        "output": "`default_nettype none\nmodule user_project_wrapper #(\n    parameter BITS = 32\n)(\n`ifdef USE_POWER_PINS\n    inout vdda1,\t\n    inout vdda2,\t\n    inout vssa1,\t\n    inout vssa2,\t\n    inout vccd1,\t\n    inout vccd2,\t\n    inout vssd1,\t\n    inout vssd2,\t\n`endif\n    input wb_clk_i,\n    input wb_rst_i,\n    input wbs_stb_i,\n    input wbs_cyc_i,\n    input wbs_we_i,\n    input [3:0] wbs_sel_i,\n    input [31:0] wbs_dat_i,\n    input [31:0] wbs_adr_i,\n    output wbs_ack_o,\n    output [31:0] wbs_dat_o,\n    input  [127:0] la_data_in,\n    output [127:0] la_data_out,\n    input  [127:0] la_oenb,\n    input  [`MPRJ_IO_PADS-1:0] io_in,\n    output [`MPRJ_IO_PADS-1:0] io_out,\n    output [`MPRJ_IO_PADS-1:0] io_oeb,\n    inout [`MPRJ_IO_PADS-10:0] analog_io,\n    input   user_clock2,\n    output [2:0] user_irq\n);\n`ifdef SIM\nassign io_out = 0;\nassign io_oeb = 0;\n`else\nassign io_out = io_in;\n`endif\nendmodule\t"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'conv_encoder' module is designed for error correction in digital communications, encoding a single input bit 'b' into two output bits 'c[0]' and 'c[1]'. It uses registers 'D_0' and 'D_1' to store historical bit values, updating these at every positive clock edge. The outputs are computed using XOR operations between the input bit and these registers, providing robust error detection and correction capabilities for reliable data transmission in noisy channels.\nModule head:\nmodule conv_encoder (output [1:0] c, input b, input clk, input reset)",
        "output": "module conv_encoder (output [1:0] c, input b, input clk, input reset);\n\treg [1:0] c;\n\treg D_0, D_1;\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_0 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_0 <= b;\n\t\tend\n\tend\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tD_1 <= 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tD_1 <= D_0;\n\t\tend\n\tend\n\talways @ (D_0 or D_1 or b)\n\tbegin\n\t\tc[0]  <= b^D_0^D_1;\n\t\tc[1]  <= b^D_1;\n\tend \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'mux41_25' module implements a 4:1 multiplexer using a 2-bit selector to choose among four inputs (D0-D3) based on selector bits (S0, S1). The functionality is encapsulated within the unmapped 'mux41' instantiation, suggesting a standard LUT-based approach, although the output handling remains unspecified.\nModule head:\nmodule mux41_25(S0,D2,S1,D3,D0,D1,)",
        "output": "module mux41_25(S0,D2,S1,D3,D0,D1,);\ninput S0;\ninput D2;\ninput S1;\ninput D3;\ninput D0;\ninput D1;\nmux41\tlpm_instance(.S0(S0),.D2(D2),.S1(S1),.D3(D3),.D0(D0),.D1(D1),);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe IOBUF_HSTL_IV module interfaces with a bi-directional I/O pad using HSTL IV signaling, managing IO state control via input 'I' and tri-state control 'T'. It uses internal signal 'ts', derived using OR gate O1 from 'T' and global 'GTS', to control the high-impedance state of IO. Buffers T1 and B1 drive the IO line and mirror its state to output 'O', respectively.\nModule head:\n\nmodule IOBUF_HSTL_IV (O, IO, I, T)",
        "output": "`timescale  1 ps / 1 ps\nmodule IOBUF_HSTL_IV (O, IO, I, T);\n    output O;\n    inout  IO;\n    input  I, T;\n    wire ts;\n    tri0 GTS = glbl.GTS;\n    or O1 (ts, GTS, T);\n    bufif0 T1 (IO, I, ts);\n    buf B1 (O, IO);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `vtc_cell` module manages RAM read and write operations based on an external FSM and synchronization inputs. It utilizes clocks and reset signals for timing. Input signals adjust read/write addresses using internal counters and offsets, dictated by FSM states and cycles. Output signals indicate RAM data and address control, with conditions set in various always blocks that react to clock edges and reset conditions, ensuring synchronized, controlled data transfer and handling.\nModule head:\nmodule vtc_cell(\n    clk,\n    reset_n,\n    sin,\n    din,\n    fsm,\n    cycle,\n    rate,\n    wr_addr,\n    rd_addr,\n    ram_wr,\n    ram_d,\n    dctv \n)",
        "output": "module vtc_cell(\n    clk,\n    reset_n,\n    sin,\n    din,\n    fsm,\n    cycle,\n    rate,\n    wr_addr,\n    rd_addr,\n    ram_wr,\n    ram_d,\n    dctv \n);\nparameter OFFSET1 = 0,\n          OFFSET2 = 0,\n          OFFSET3 = 0;\nparameter D_WID = 8;\nparameter A_WID = 8;\ninput                 clk        ;\ninput                 reset_n    ;\ninput                 rate       ;\ninput   [D_WID-1:0]   din        ; \ninput                 sin        ;\ninput   [3:0]         fsm        ;\ninput   [3:0]         cycle      ;\ninput   [D_WID-1:0]   dctv       ;\noutput  [A_WID-1:0]   wr_addr    ;\noutput  [A_WID-1:0]   rd_addr    ;\noutput                ram_wr     ;\noutput  [D_WID-1:0]   ram_d      ;\nreg     [A_WID-1:0]   wr_addr    ;\nreg     [A_WID-1:0]   rd_addr    ;\nreg                   ram_wr     ;\nreg     [D_WID-1:0]   ram_d      ;\nreg     [A_WID-1:0]   addr_offset;\nreg     [A_WID-1:0]   rd_counter ;\nalways @ (posedge clk or negedge reset_n)\nbegin : wr_addr_r\n    if(!reset_n)\n        wr_addr <= #1 1'b0;\n    else begin\n    case(fsm)\n    4'b0010:\n        if(ram_wr)    \n        wr_addr <= #1 wr_addr + 1'b1;\n    default:\n        wr_addr <= #1 1'b0;\n    endcase\n    end\nend    \nalways @ (*)\nbegin : addr_offset_r\n    case(cycle[3:2])\n    2'b01: addr_offset = OFFSET1;\n    2'b10: addr_offset = OFFSET2;\n    2'b11: addr_offset = OFFSET3;\n    default: addr_offset = 8'h0;\n    endcase\nend    \nalways @ (posedge clk or negedge reset_n)\nbegin : rd_addr_r\n    if(!reset_n)\n        rd_addr <= #1 8'h0;\n    else begin\n    case(fsm)\n    4'b0100:\n        rd_addr <= #1 rd_counter + addr_offset;\n    default:\n        rd_addr <= #1 8'h0;\n    endcase\n    end\nend        \nalways @ (posedge clk or negedge reset_n)\nbegin : rd_counter_r\n    if(!reset_n)\n        rd_counter <= #1 8'h0;\n    else if(fsm[2]) begin \n        if ( cycle[3:2] == 2'b11)\n        rd_counter <= #1 rd_counter + 1'b1;\n        else\n        rd_counter <= #1 rd_counter;\n        end\n    else\n        rd_counter <= #1 8'h0;\nend\nalways @ (posedge clk or negedge reset_n)\nbegin : wr_r\n    if(!reset_n)\n        ram_wr <= #1 1'b0;\n    else if(fsm[1])\n        ram_wr <= #1 sin;\nend\nalways @ (posedge clk or negedge reset_n)\nbegin : data_in_r\n    if(!reset_n)\n         ram_d <= #1 'h0;\n    else if(sin)\n         ram_d <= #1 din;\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe parallel_adder_subtractor module performs 4-bit addition or subtraction on inputs A and B, controlled by K (0 for addition, 1 for subtraction). Implementation uses XOR gates to conditionally toggle B's bits for subtraction and four 1-bit full adders (F0-F3) chained together, handling carry/borrow across the bits.\nModule head:\nmodule parallel_adder_subtractor(A,B,K,S,Cout,Cin)",
        "output": "module parallel_adder_subtractor(A,B,K,S,Cout,Cin);\ninput [3:0]A,B;\ninput K,Cin;\noutput [3:0]S;\noutput Cout;\nwire b0,b1,b2,b3;\nxor(b0,B[0],K);\nxor(b1,B[1],K);\nxor(b2,B[2],K);\nxor(b3,B[3],K);\nwire c0,c1,c2;\nfull_adder_1bit  F0(A[0],b0,Cin,S[0],c0);\nfull_adder_1bit  F1(A[1],b1,c0,S[1],c1);\nfull_adder_1bit  F2(A[2],b2,c1,S[2],c2);\nfull_adder_1bit  F3(A[3],b3,c2,S[3],Cout);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'tb_pulse' Verilog module serves as a testbench for evaluating a pulse generator. It generates a clock signal, simulates a reset event, and toggles an enable signal to validate the module's response. Internal clock toggling, reset sequence, and enable logic are implemented to test the pulse functionality under varying conditions within the instantiated 'pulse' module.\nModule head:\n\nmodule\ttb_pulse;\nreg\t\t\t\tclk\t\t\t\t;\nreg\t\t\t\trst_n\t\t\t;\nreg\t\t\t\ten\t\t\t\t;\nwire\t\t\tdout\t\t\t;\nparameter\tCYCLE\t\t=\t20\t;\t\nparameter\tRUN_TIME\t=\t10000;\npulse pulse_inst(\n\t.clk\t\t\t(clk)\t\t\t,\n\t.rst_n\t\t\t(rst_n)\t\t\t,\n\t.en\t\t\t\t(en)\t\t\t,\n\t.dout\t\t\t(dout)\t\t\n)",
        "output": "`timescale 1ns/1ns\nmodule\ttb_pulse;\nreg\t\t\t\tclk\t\t\t\t;\nreg\t\t\t\trst_n\t\t\t;\nreg\t\t\t\ten\t\t\t\t;\nwire\t\t\tdout\t\t\t;\nparameter\tCYCLE\t\t=\t20\t;\t\nparameter\tRUN_TIME\t=\t10000;\npulse pulse_inst(\n\t.clk\t\t\t(clk)\t\t\t,\n\t.rst_n\t\t\t(rst_n)\t\t\t,\n\t.en\t\t\t\t(en)\t\t\t,\n\t.dout\t\t\t(dout)\t\t\n);\ninitial\tbegin\n\tclk\t=\t0\t;\n\tforever#(CYCLE/2)begin\n\tclk\t=\t~clk\t;\n\tend\nend\ninitial\tbegin\t\n\t#1;\n\trst_n\t=\t0\t;\n\t#(CYCLE*10)\n\trst_n\t=\t1\t;\nend\ninteger\t\tfp_w\t;\nreg\t\t\tflag_get\t;\ninitial\tbegin\nend\ninitial begin\n\t#1;\n\ten\t=\t\t0\t;\n\t#(CYCLE*100)\t;\n\ten\t=\t\t1\t;\n\t#(CYCLE*1)\t\t;\n\ten\t=\t\t0\t;\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'cnt25' module generates a clock signal 'clkdiv25' that is 1/25th the frequency of the input 'clk', controlled by 'enable'. It uses a 6-bit counter 'cnt' that increments on each 'clk' positive edge when 'enable' is high and resets when 'reset' is asserted or when it reaches 24, which also triggers 'clkdiv25' to go high, signaling completion of a division cycle.\nModule head:\nmodule cnt25 (reset, clk, enable, clkdiv25)",
        "output": "module cnt25 (reset, clk, enable, clkdiv25);\ninput reset, clk, enable;\noutput clkdiv25;\nreg [5:0] cnt;\nassign clkdiv25 =(cnt==5'd24);\nalways @(posedge reset or posedge clk)\n  if (reset) cnt <= 0;\n   else if (enable) \n          if (clkdiv25) cnt <= 0;\n            else cnt <= cnt + 1;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe apb_fastdecode module efficiently handles APB address decoding for multiple slave devices. It accepts address and control inputs, and based on configurable parameters, it processes selection and error handling. Outputs manage slave communication by indicating data, error states, and readiness. It uses pre_select_bits for initial addressing, confirm or negate these with select_error, and finally drive appropriate slave signals through select_bits.\nModule head:\nmodule apb_fastdecode\n#(parameter PORTS      = 2,  \n            MS_SLVADR  = 9,  \n            TOP_DEFAULT = 0  \n )",
        "output": "module apb_fastdecode\n#(parameter PORTS      = 2,  \n            MS_SLVADR  = 9,  \n            TOP_DEFAULT = 0  \n )\n(\n   input      [31:0] s_paddr,   \n   input             s_pwrite,\n   input             s_psel,\n   input             s_penable,\n   input      [31:0] s_pwdata,\n   output     [31:0] s_prdata,\n   output            s_pready,\n   output            s_pslverr,\n   output    [MS_SLVADR:0] m_paddr,  \n   output                 m_pwrite,\n   output     [PORTS-1:0] m_psel,\n   output                 m_penable,\n   output          [31:0] m_pwdata,\n   input   [PORTS*32-1:0] m_prdata,\n   input      [PORTS-1:0] m_pready,\n   input      [PORTS-1:0] m_pslverr\n);\nlocalparam SELBITS = PORTS<=2    ? 1 :\n                     PORTS<=4    ? 2 :\n                     PORTS<=8    ? 3 :\n                     PORTS<=16   ? 4 : \n                     PORTS<=32   ? 5 :\n                     PORTS<=64   ? 6 :\n                     PORTS<=128  ? 7 :\n                     0 ; \nwire select_error;    \nwire [SELBITS-1:0] pre_select_bits,select_bits;\n   assign m_paddr   = s_paddr[MS_SLVADR:0]; \n   assign m_pwrite  = s_pwrite;\n   assign m_penable = s_penable;\n   assign m_pwdata  = s_pwdata;\n   assign pre_select_bits = s_paddr[MS_SLVADR+1 +: SELBITS];\n   assign select_error = pre_select_bits>=PORTS;\n   assign select_bits  = TOP_DEFAULT & select_error ? PORTS-1 :  pre_select_bits;\n   assign m_psel    = ~TOP_DEFAULT & select_error ? {PORTS{1'b0}} : s_psel<<select_bits;\n   assign s_prdata  = m_prdata[select_bits*32 +: 32];\n   assign s_pready  = m_pready[select_bits]  | (~TOP_DEFAULT & select_error);\n   assign s_pslverr = m_pslverr[select_bits] | (~TOP_DEFAULT & select_error);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `ahb_code_mux` is a multiplexer module part of the AMBA AHB bus system, managing, and routing bus transactions. It uses internal signals `d_trans_active` and `d_trans_active_reg` to track the activity of the downstream transaction currently and in the next clock cycle. Based on activity, it conditionally assigns values to several output ports. Relevant output port values are determined via conditional assignments, either directly passed through or dependent on `d_trans_active` signal. Independent of transaction, data and readiness output ports straightly transmit input to output. A sequential block updates `d_trans_active_reg` per clock cycle, helping to manage propagation delays.\nModule head:\n\nmodule ahb_code_mux (\n  HCLK, HRESETn,\n  HADDRI, HTRANSI, HSIZEI, HBURSTI, HPROTI,\n  HADDRD, HTRANSD, HSIZED, HBURSTD, HPROTD, HWDATAD, HWRITED, EXREQD,\n  HRDATAC, HREADYC, HRESPC, EXRESPC,\n  HRDATAI, HREADYI, HRESPI, HRDATAD, HREADYD, HRESPD, EXRESPD,\n  HADDRC, HWDATAC, HTRANSC, HWRITEC, HSIZEC, HBURSTC, HPROTC, EXREQC\n  )",
        "output": "`define RESP_OKAY 2'b00\nmodule ahb_code_mux (\n  HCLK, HRESETn,\n  HADDRI, HTRANSI, HSIZEI, HBURSTI, HPROTI,\n  HADDRD, HTRANSD, HSIZED, HBURSTD, HPROTD, HWDATAD, HWRITED, EXREQD,\n  HRDATAC, HREADYC, HRESPC, EXRESPC,\n  HRDATAI, HREADYI, HRESPI, HRDATAD, HREADYD, HRESPD, EXRESPD,\n  HADDRC, HWDATAC, HTRANSC, HWRITEC, HSIZEC, HBURSTC, HPROTC, EXREQC\n  );\n  input         HCLK;             \n  input         HRESETn;          \n  input [31:0]  HADDRI;           \n  input  [1:0]  HTRANSI;          \n  input  [2:0]  HSIZEI;           \n  input  [2:0]  HBURSTI;          \n  input  [3:0]  HPROTI;           \n  input [31:0]  HADDRD;           \n  input  [1:0]  HTRANSD;          \n  input  [2:0]  HSIZED;           \n  input  [2:0]  HBURSTD;          \n  input  [3:0]  HPROTD;           \n  input [31:0]  HWDATAD;          \n  input         HWRITED;          \n  input         EXREQD;           \n  input [31:0]  HRDATAC;          \n  input         HREADYC;          \n  input  [1:0]  HRESPC;           \n  input         EXRESPC;          \n  output [31:0] HRDATAI;          \n  output        HREADYI;          \n  output  [1:0] HRESPI;           \n  output [31:0] HRDATAD;          \n  output        HREADYD;          \n  output  [1:0] HRESPD;           \n  output        EXRESPD;          \n  output [31:0] HADDRC;           \n  output [31:0] HWDATAC;          \n  output  [1:0] HTRANSC;          \n  output        HWRITEC;          \n  output  [2:0] HSIZEC;           \n  output  [2:0] HBURSTC;          \n  output  [3:0] HPROTC;           \n  output        EXREQC;           \n  wire          d_trans_active;     \n  reg           d_trans_active_reg; \n  assign d_trans_active = HTRANSD[1];\n  assign HADDRC  = d_trans_active ? HADDRD  : HADDRI;\n  assign HTRANSC = d_trans_active ? HTRANSD : HTRANSI;\n  assign HWRITEC = d_trans_active ? HWRITED : 1'b0;\n  assign HSIZEC  = d_trans_active ? HSIZED  : HSIZEI;\n  assign HBURSTC = d_trans_active ? HBURSTD : HBURSTI;\n  assign HPROTC  = d_trans_active ? HPROTD  : HPROTI;\n  assign HRDATAI = HRDATAC;\n  assign HRDATAD = HRDATAC;\n  assign HWDATAC = HWDATAD;\n  assign HREADYI = HREADYC;\n  assign HREADYD = HREADYC;\n  assign HRESPI  = d_trans_active_reg ? `RESP_OKAY : HRESPC;\n  assign HRESPD  = d_trans_active_reg ? HRESPC     : `RESP_OKAY;\n  assign EXREQC  = EXREQD;\n  assign EXRESPD = d_trans_active_reg & EXRESPC;\n  always @ (posedge HCLK or negedge HRESETn)\n    begin\n      if (!HRESETn)\n        d_trans_active_reg <= 1'b0;\n      else if (HREADYC)\n        d_trans_active_reg <= d_trans_active;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe axi_revision module interfaces with an AXI bus, managing read and write transactions and serving version data like major, minor, and build numbers. It uses input parameters and internal signals to control datapath operations, employing state machines for read and write sequences. The module ensures synchronization using handshakes and processes version requests with specific AXI read addresses, providing robust and adaptive communication capabilities in SoC environments.\nModule head:\n\nmodule axi_revision#\n(\n    parameter integer S_AXI_DATA_WIDTH   = 32,\n    parameter integer S_AXI_ADDR_WIDTH   =  4\n)",
        "output": "`timescale 1ns / 1ps\nmodule axi_revision#\n(\n    parameter integer S_AXI_DATA_WIDTH   = 32,\n    parameter integer S_AXI_ADDR_WIDTH   =  4\n)\n(\n    input wire  AXI_ACLK,\n    input wire  AXI_ARESETN,\n    input  wire [S_AXI_ADDR_WIDTH-1 : 0]    S_AXI_AWADDR,   \n    input  wire                             S_AXI_AWVALID,  \n    output wire                                             S_AXI_AWREADY,\n    input  wire  [2 : 0]                    S_AXI_AWPROT,\n    input  wire [S_AXI_DATA_WIDTH-1 : 0]    S_AXI_WDATA,      \n    input  wire                             S_AXI_WVALID,\n    input  wire [(S_AXI_DATA_WIDTH/8)-1:0]  S_AXI_WSTRB,\n    output wire                                             S_AXI_WREADY,\n    output  wire [1 : 0]                                    S_AXI_BRESP,\n    output  wire                                            S_AXI_BVALID,\n    input   wire                            S_AXI_BREADY,\n    input  wire [S_AXI_ADDR_WIDTH-1 : 0]    S_AXI_ARADDR,     \n    input  wire                             S_AXI_ARVALID,\n    input  wire [2 : 0]                     S_AXI_ARPROT,     \n    output wire                                             S_AXI_ARREADY,\n    output  wire [S_AXI_DATA_WIDTH-1 : 0]                   S_AXI_RDATA,\n    output  wire                                            S_AXI_RVALID,\n    output  wire [1 : 0]                                    S_AXI_RRESP,\n    input   wire                            S_AXI_RREADY\n );\n    localparam OKAY   = 0;\n    localparam SLVERR = 2;\n    reg  user_read_start,  user_read_idle;\n    reg  user_write_start, user_write_idle;\n    wire user_write_complete = (user_write_start == 0) & user_write_idle;\n    wire user_read_complete  = (user_read_start  == 0) & user_read_idle;\n    wire S_B_HANDSHAKE  = S_AXI_BVALID  & S_AXI_BREADY;\n    wire S_R_HANDSHAKE  = S_AXI_RVALID  & S_AXI_RREADY;\n    wire S_W_HANDSHAKE  = S_AXI_WVALID  & S_AXI_WREADY;\n    wire S_AR_HANDSHAKE = S_AXI_ARVALID & S_AXI_ARREADY;\n    wire S_AW_HANDSHAKE = S_AXI_AWVALID & S_AXI_AWREADY;\n    reg[S_AXI_ADDR_WIDTH-1:0] s_axi_araddr;\n    reg                       s_axi_arready; assign S_AXI_ARREADY = s_axi_arready;\n    reg                       s_axi_rvalid;  assign S_AXI_RVALID  = s_axi_rvalid;\n    reg[1:0]                  s_axi_rresp;   assign S_AXI_RRESP   = s_axi_rresp;\n    reg[S_AXI_DATA_WIDTH-1:0] s_axi_rdata;   assign S_AXI_RDATA   = s_axi_rdata;\n    reg s_read_state;\n    always @(posedge AXI_ACLK) begin\n        user_read_start <= 0;\n        if (AXI_ARESETN == 0) begin\n            s_read_state  <= 0;\n            s_axi_arready <= 1;\n            s_axi_rvalid  <= 0;\n        end else case(s_read_state)\n        0:  begin\n                s_axi_rvalid <= 0;                      \n                if (S_AXI_ARVALID) begin                \n                    s_axi_arready   <= 0;               \n                    s_axi_araddr    <= S_AXI_ARADDR;    \n                    user_read_start <= 1;               \n                    s_read_state    <= 1;               \n                end\n            end\n        1:  if (user_read_complete) begin               \n                s_axi_rvalid <= 1;                      \n                if (S_R_HANDSHAKE) begin                \n                    s_axi_rvalid  <= 0;                 \n                    s_axi_arready <= 1;                 \n                    s_read_state  <= 0;                 \n                end\n            end\n        endcase\n    end\n    reg[S_AXI_ADDR_WIDTH-1:0] s_axi_awaddr;\n    reg[S_AXI_DATA_WIDTH-1:0] s_axi_wdata;\n    reg      s_axi_awready; assign S_AXI_AWREADY = s_axi_arready;\n    reg      s_axi_wready;  assign S_AXI_WREADY  = s_axi_wready;\n    reg      s_axi_bvalid;  assign S_AXI_BVALID  = s_axi_bvalid;\n    reg[1:0] s_axi_bresp;   assign S_AXI_BRESP   = s_axi_bresp;\n    reg s_write_state;\n    always @(posedge AXI_ACLK) begin\n        user_write_start <= 0;\n        if (AXI_ARESETN == 0) begin\n            s_write_state <= 0;\n            s_axi_awready <= 1;\n            s_axi_wready  <= 1;\n            s_axi_bvalid  <= 0;\n        end else case(s_write_state)\n        0:  begin\n                s_axi_bvalid <= 0;                    \n                if (S_AW_HANDSHAKE) begin             \n                    s_axi_awready <= 0;               \n                    s_axi_awaddr  <= S_AXI_AWADDR;    \n                end\n                if (S_W_HANDSHAKE) begin              \n                    s_axi_wready     <= 0;            \n                    s_axi_wdata      <= S_AXI_WDATA;  \n                    user_write_start <= 1;            \n                    s_write_state    <= 1;            \n                end\n            end\n        1:  if (user_write_complete) begin            \n                s_axi_bvalid <= 1;                    \n                if (S_B_HANDSHAKE) begin              \n                    s_axi_awready <= 1;               \n                    s_axi_wready  <= 1;               \n                    s_write_state <= 0;               \n                end\n            end\n        endcase\n    end\n    localparam VERSION_MAJOR = 1;\n    localparam VERSION_MINOR = 0;\n    localparam VERSION_BUILD = 0;\n    localparam VERSION_DAY   = 27;\n    localparam VERSION_MONTH = 7;\n    localparam VERSION_YEAR  = 2022;\n    localparam VERSION_DATE  = (VERSION_MONTH << 24) | (VERSION_DAY << 16) | VERSION_YEAR; \n    localparam REG_MAJOR = 0;\n    localparam REG_MINOR = 1;\n    localparam REG_BUILD = 2;\n    localparam REG_DATE  = 3;\n    always @(posedge AXI_ACLK) begin\n        if (AXI_ARESETN == 0) begin\n            user_read_idle <= 1;\n        end else if (user_read_start) begin\n            s_axi_rresp <= OKAY;\n            case(s_axi_araddr >> 2)\n                REG_MAJOR:  s_axi_rdata <= VERSION_MAJOR;\n                REG_MINOR:  s_axi_rdata <= VERSION_MINOR;\n                REG_BUILD:  s_axi_rdata <= VERSION_BUILD;\n                REG_DATE:   s_axi_rdata <= VERSION_DATE;\n            endcase\n        end\n    end\n    always @(posedge AXI_ACLK) begin\n        user_write_idle <= 1;\n        s_axi_bresp     <= OKAY;\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `cabac_ram_sp_64x16` serves as a configurable single-port RAM with a 64x16 configuration, addressing specific simulation or hardware needs. It supports dual setups: `RTL_MODEL` initializes a generic `ram_1p` module for RTL simulations, while `XM_MODEL` uses `rfsphd_64x16` tailored with additional parameters for XM environments. It operates with standard inputs for clock, enable, write, address, and data, directly interfacing with these models to perform memory operations efficiently.\nModule head:\n \nmodule cabac_ram_sp_64x16 (\n    clk      ,\n    cen_i    ,\n    wen_i    , \n    addr_i   , \n    data_i   ,\n    data_o\n    )",
        "output": "`include \"enc_defines.v\" \nmodule cabac_ram_sp_64x16 (\n    clk      ,\n    cen_i    ,\n    wen_i    , \n    addr_i   , \n    data_i   ,\n    data_o\n    );\n    input                   clk       ;\n    input                   cen_i     ;\n    input                   wen_i     ;\n    input   [6      -1 :0]  addr_i    ;\n    input   [16     -1 :0]  data_i    ;\n    output  [16     -1 :0]  data_o    ;\n`ifdef RTL_MODEL\n  ram_1p #(\n      .Word_Width(  16   ),\n      .Addr_Width(  6    )\n      ) u_ram_1p(\n        .clk    ( clk        ),\n        .cen_i  ( cen_i      ),\n        .oen_i  ( 1'b0       ),\n        .wen_i  ( wen_i      ),\n        .addr_i ( addr_i     ),\n        .data_i ( data_i     ),      \n        .data_o ( data_o     )           \n  );\n`endif\n`ifdef XM_MODEL \n    rfsphd_64x16 u_rfsphd_64x16(\n        .Q          (data_o     ), \n        .CLK        (clk        ), \n        .CEN        (cen_i      ), \n        .WEN        (wen_i      ), \n        .A          (addr_i     ), \n        .D          (data_i     ), \n        .EMA        ( 3'b1 ), \n        .EMAW       ( 2'b0 ),\n        .RET1N      ( 1'b1 )\n        );   \n`endif \nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThis module is a testbench for the 'arb_v' arbitration module. It simulates various input conditions such as reset, clock, DMA and TDSP bus requests and monitors output responses including DMA and TDSP grants. The testbench initializes signals, applies a reset sequence, generates test vectors by manipulating input signals, and runs for 2000 time units with a 40-unit clock period.\nModule head:\nmodule test()",
        "output": "module test();\n    reg\n  \treset,\n  \tclk,\n  \tdma_breq,\n  \ttdsp_breq;\n  wire\n  \tdma_grant,\n  \ttdsp_grant;\n  arb_v top (\n\treset,\n\tclk,\n\tdma_breq,\n\tdma_grant,\n\ttdsp_breq,\n\ttdsp_grant\n\t);\n  initial \n    begin\n      clk = 1'b0;\n      reset = 1'b0;\n      dma_breq = 1'b0;\n      tdsp_breq = 1'b0;\n      @(negedge clk)\n      reset = 1'b1;\n      repeat(2)\n        @(negedge clk);\n      @(negedge clk)\n      reset = 1'b0;\n      repeat(2)\n        @(posedge clk);\n      dma_breq = 1'b1;\n      tdsp_breq = 1'b0;\n      @(posedge clk)\n      @(posedge clk)\n      dma_breq = 1'b1;\n      tdsp_breq = 1'b0;\n      @(posedge clk)\n      @(posedge clk)\n      dma_breq = 1'b0;\n      tdsp_breq = 1'b0;\n    end\n  always #20 clk = ~clk;\n  initial begin\n    #2000 $finish;\n  end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe rx_mainFSM module processes data reception in a state-driven manner using dual clocks, clka and clkb. It incorporates a finite state machine (FSM) with states for handling initialization, data processing, and output, controlled by respective signals. The FSM transitions and output updates occur on negative edges of clocks, utilizing temporary registers for data staging and state transitions. The module efficiently manages data flow, error signaling, and process statuses to ensure reliable operation.\nModule head:\nmodule rx_mainFSM(clka, clkb, reset, rx_data, rx_rdy, rx_busy, rx_out, rx_done, rcount, rstate, rx_error,rx_idle)",
        "output": "module rx_mainFSM(clka, clkb, reset, rx_data, rx_rdy, rx_busy, rx_out, rx_done, rcount, rstate, rx_error,rx_idle);\ninput wire clka, clkb, reset;\ninput wire [7:0] rx_data;\ninput wire rx_rdy;\noutput reg [7:0] rx_out;\noutput reg [3:0] rcount;\noutput [3:0] rstate;\noutput reg rx_error, rx_busy, rx_done, rx_idle;\nreg [7:0] rtmpout =8'b00000000;\nparameter SIZE = 4;\nparameter S0  = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3=4'b0011, S4=4'b0100, S5=4'b0101, S6  = 4'b0110, S7 = 4'b0111, S8 = 4'b1000;\nreg   [SIZE-1:0]          rstate        ;\nwire   [SIZE-1:0]         temp_rstate   ;\nreg   [SIZE-1:0]          next_rstate   ;\nassign  temp_rstate = fsm_function(rstate, rx_rdy, rx_busy, rcount);\nfunction [SIZE-1:0] fsm_function;\n\tinput [SIZE-1:0] rstate;\n\tinput rx_rdy, rx_busy;\n\tinput [3:0] rcount;\n\tcase(rstate)\n\t\t\tS0: begin \n\t\t\t\tif(~rx_rdy) begin\n\t\t\t\t\tfsm_function = S1;\n\t\t\t\tend \n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (rx_rdy) begin\n\t\t\t\t\tfsm_function = S2;\n\t\t\t\tend else begin\n\t\t\t\t\tfsm_function = S1;\n\t\t\t\tend\t\t\t\t\n\t\t\t    end\n\t\t\tS2: begin \n\t\t\t\tif (rx_busy) begin\n\t\t\t\t\tfsm_function = S2;\n\t\t\t\tend else begin\n\t\t\t\t\tfsm_function = S3;  \n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tfsm_function = S4;    \n\t\t\tend\n\t\t\tS4: begin\n\t\t\t\tfsm_function = S5;  \n\t\t\tend\n\t\t\tS5: begin\n\t\t\t\tfsm_function = S1; \n\t\t\tend\n\t\t\tdefault: fsm_function = S0;\n    endcase\nendfunction\nalways @ (negedge clka)\nbegin\n  if (reset == 1'b1) begin\n    next_rstate <= S0;\n  end else begin\n    next_rstate <= temp_rstate;\n  end\nend\nalways @ (negedge clkb)\nbegin\n  case(next_rstate)\n          S0: begin\n               \trcount <= 4'b0000;\n               \trtmpout  <= 8'b00000000;\n               \trx_error <= 0;\n               \trx_idle <= 1;\n\t\trx_out <= 0;\n\t\trx_done <= 0;\n\t\trx_busy <= 0;\n\t\tif (~rx_done) begin\n\t\t\trx_out <= 0;\n\t\tend\n               \tif (rx_data[0]) begin\n               \t\trx_error <= 1;\n               \tend\n                rstate <= next_rstate;\n          end\n\t  S1: begin\n\t\trstate <= next_rstate;\n\t      end\n          S2: begin\n          \t\trx_idle <= 0;\n        \t\tif (rcount > 4) begin\n          \t\t\trx_busy <= 0;\n          \t\tend\n          \t\telse begin \n          \t\t\trx_busy <= 1;\n      \t\t\tend\n      \t\t\trtmpout [7] <= 1;\n      \t\t\trtmpout [rcount+1] <= rx_data[rcount+1];\n          \t\trcount <= rcount + 1;\n          \t\trstate <= next_rstate;\n          end\n          S3: begin\n          \t\trtmpout [7] <= 0;\n          \t\trx_done <= 1;\n          \t\trstate <= next_rstate;\n          end\n          S4: begin\n         \t\tif (rtmpout [6:2]==rx_data[6:2]) begin\n          \t\t\trx_error <= 0;\n          \t\tend\n          \t\telse begin\n          \t\t\trx_error <= 1;\n          \t\tend\n          \t    rstate <= next_rstate;\n          end\n          S5: begin\n          \t   rx_out <= {rtmpout[7:2], rx_done, rx_error};        \t   \n          \t   rstate <= next_rstate;\n          end\n  endcase\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe \"freq_divider_60hz\" module divides a 30 MHz input clock (`in_clk`) to generate a 60Hz output signal (`out_clk`). It uses an integer `counter` to track input clock pulses, toggling an internal register `out` when the count reaches 500,000, thus halving the frequency. The `out` register connects to `out_clk`. If `out` is undefined, it resets to ensure signal integrity.\nModule head:\n\nmodule freq_divider_60hz(\n    input in_clk,\n    output out_clk\n    )",
        "output": "`timescale 1ns / 1ps\nmodule freq_divider_60hz(\n    input in_clk,\n    output out_clk\n    );\n\t reg out = 0 ;\n\t integer counter = 0 ;\n\t always @(posedge in_clk) \n\t begin\n\t counter = counter + 1 ;\n\t if(counter == 500000)\n\t\tbegin\n\t\t\tcounter = 0;\n\t\t\tout = ~out ; \n\t\tend\n\t else if(out === 1'bx )\n\t\tbegin\n\t\t  out = 0 ;\n\t\t  counter = 0 ;\n\t\tend\n\t end\n\t \t assign out_clk  = out;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe cabac_neighbour_1p_8xMB_X_TOTAL module interfaces with a single-port 8-bit register file for CABAC neighbor data handling in video coding. It processes writing and reading operations based on `w_en`. Internally, it utilizes signals like `wen_i` and `addr_i` to control read/write operations and address selection. The register operates synchronously with the `clk` signal, ensuring data integrity during transitions.\nModule head:\n\nmodule cabac_neighbour_1p_8xMB_X_TOTAL(\n\t\t\t\t\tclk\t\t\t\t,\n\t\t\t\t\tr_en\t\t\t,\n\t\t\t\t\tr_addr\t\t\t,\n\t\t\t\t\tw_en\t\t\t,\n\t\t\t\t\tw_addr\t\t\t,\n\t\t\t\t\tw_data\t\t\t,\n\t\t\t\t\tr_data\n)",
        "output": "`include \"enc_defines.v\"\nmodule cabac_neighbour_1p_8xMB_X_TOTAL(\n\t\t\t\t\tclk\t\t\t\t,\n\t\t\t\t\tr_en\t\t\t,\n\t\t\t\t\tr_addr\t\t\t,\n\t\t\t\t\tw_en\t\t\t,\n\t\t\t\t\tw_addr\t\t\t,\n\t\t\t\t\tw_data\t\t\t,\n\t\t\t\t\tr_data\n);\ninput\t\t\t\tclk\t\t\t\t\t\t;\t\ninput\t\t\t\tr_en\t\t\t\t\t;\t\ninput\t[(`PIC_X_WIDTH)-1:0]\t\tr_addr\t\t\t\t\t;\t\ninput\t\t\t\tw_en\t\t\t\t\t;\t\ninput\t[(`PIC_X_WIDTH)-1:0]\t\tw_addr\t\t\t\t\t;\t\ninput\t[7:0]\t\tw_data\t\t\t\t\t;\t\noutput\t[7:0]\t\tr_data\t\t\t\t\t;\t\nrf_1p #(.Addr_Width((`PIC_X_WIDTH)), .Word_Width(8))\t \n\t\trf_1p_cabac_neigh_8xMB_X_TOTAL_u0(\n\t\t\t\t.clk    ( clk\t ),\n\t\t        .cen_i  ( 1'b0\t ),\n\t\t        .wen_i  ( ~w_en\t ),\n\t\t        .addr_i ( w_en ? w_addr : r_addr ),\n\t\t        .data_i ( w_data ),\t\t\n\t\t        .data_o\t( r_data )\n);\t\t\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'onewire_xmit' module is a one-wire transmitter implemented in Verilog. It serializes 'xmit_data' input and generates a 'dout' output, synchronized with a clock 'clk'. The module operates via a state machine controlled by parameters. State transitions along with bit and frame transmissions are driven by internal counters (dly_cnt, bcnt, data_cnt and frame_cnt), and an internal register 'xd' holds current data. The module includes a 'clogb2' function and provides a one-wire transmission protocol essential in digital systems.\nModule head:\n\nmodule onewire_xmit (rst, clk, xmit_data, dout)",
        "output": "`timescale 1ns/100ps\nmodule onewire_xmit (rst, clk, xmit_data, dout);\nparameter CLK_FREQ   = 48000000; \nparameter DLY_TIME   = 200;      \nparameter SYNC_BITS  = 5;        \nparameter DATA_BITS  = 64;       \nparameter FRAME_FREQ = 1000;     \nparameter TPD        = 1.3;\nparameter NUM_DLY_CLKS = CLK_FREQ/1000 * DLY_TIME;\nlocalparam XS    = clogb2(DATA_BITS-1);\nlocalparam FS    = clogb2(FRAME_FREQ-1);\nlocalparam DS    = clogb2(NUM_DLY_CLKS-1);\nlocalparam Q1    = CLK_FREQ/FRAME_FREQ/DATA_BITS/4;\nlocalparam Q123  = 3*Q1;\nlocalparam Q1234 = 4*Q1;\nlocalparam LOW_TIME = 4*Q1234;\nlocalparam QS    = clogb2(LOW_TIME-1);\ninput  wire                 rst;        \ninput  wire                 clk;        \ninput  wire [DATA_BITS-1:0] xmit_data;\noutput reg                  dout;\nreg [4:0] OW_state;\nreg [4:0] OW_state_next;\nreg        [DS-1:0] dly_cnt;\nreg        [QS-1:0] bcnt;\nreg [DATA_BITS-1:0] xd;\nreg        [XS-1:0] data_cnt;\nreg        [FS-1:0] frame_cnt;\nlocalparam OW_IDLE     = 0,\n           OW_DLY      = 1,\n           OW_FRAME    = 2,\n           OW_SYNC_H   = 3,\n           OW_SYNC_L   = 4,\n           OW_LOW      = 5,\n           OW_DATA_Q1  = 6,\n           OW_DATA_Q23 = 7,\n           OW_DATA_Q4  = 8;\nalways @(posedge clk)\nbegin\n  if (OW_state != OW_DLY)\n    dly_cnt <= #TPD 1'b0;\n  else if (dly_cnt != NUM_DLY_CLKS)\n    dly_cnt <= #TPD dly_cnt + 1'b1;\n  if (OW_state == OW_FRAME)\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_SYNC_L) && (bcnt == Q1234))\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_LOW) && (bcnt == LOW_TIME))\n    bcnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    bcnt <= #TPD 1'b0;\n  else\n    bcnt <= #TPD bcnt + 1'b1;\n  if (OW_state == OW_FRAME)\n    xd <= #TPD xmit_data;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    xd <= #TPD xmit_data;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    xd <= #TPD xd >> 1;\n  if ((OW_state == OW_FRAME) || (OW_state == OW_LOW))\n    data_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    data_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_SYNC_L) && (bcnt == Q1234))\n    data_cnt <= #TPD data_cnt + 1'b1;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234))\n    data_cnt <= #TPD data_cnt + 1'b1;\n  if (OW_state == OW_LOW)\n    frame_cnt <= #TPD 1'b0;\n  else if ((OW_state == OW_DATA_Q4) && (bcnt == Q1234) && (data_cnt == (DATA_BITS-1)))\n    frame_cnt <= #TPD frame_cnt + 1'b1;\n  if (rst)\n    OW_state <= #TPD OW_IDLE;\n  else\n    OW_state <= #TPD OW_state_next;\nend\nalways @*\nbegin\n   case(OW_state)\n     OW_IDLE:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_DLY;  \n     end\n     OW_DLY:\n     begin\n       dout = 1'b0;\n       if (dly_cnt != NUM_DLY_CLKS)\n         OW_state_next = OW_DLY;\n       else\n         OW_state_next = OW_FRAME;  \n     end\n     OW_FRAME:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_SYNC_H;\n     end\n     OW_SYNC_H: \n     begin\n       dout = 1'b1;\n       if (bcnt != Q1) \n         OW_state_next = OW_SYNC_H;\n       else\n         OW_state_next = OW_SYNC_L;\n     end\n     OW_SYNC_L: \n     begin\n       dout = 1'b0;\n        if (bcnt != Q1234) \n         OW_state_next = OW_SYNC_L;\n       else if (data_cnt != (SYNC_BITS-1))\n         OW_state_next = OW_SYNC_H;\n       else\n         OW_state_next = OW_LOW;\n     end\n     OW_LOW: \n     begin\n       dout = 1'b0;\n       if (bcnt != LOW_TIME)\n         OW_state_next = OW_LOW;\n       else\n         OW_state_next = OW_DATA_Q1;\n     end\n     OW_DATA_Q1: \n     begin\n       dout = 1'b1;\n        if (bcnt != Q1) \n         OW_state_next = OW_DATA_Q1;\n       else\n         OW_state_next = OW_DATA_Q23;\n     end\n     OW_DATA_Q23: \n     begin\n       dout = xd[0];\n       if (bcnt != Q123) \n         OW_state_next = OW_DATA_Q23;\n       else\n         OW_state_next = OW_DATA_Q4;\n     end\n     OW_DATA_Q4: \n     begin\n       dout = 1'b0;\n       if (bcnt != Q1234)\n         OW_state_next = OW_DATA_Q4;   \n       else if (data_cnt != (DATA_BITS-1))\n         OW_state_next = OW_DATA_Q1;   \n       else if (frame_cnt != (FRAME_FREQ-1))\n         OW_state_next = OW_DATA_Q1;   \n       else\n         OW_state_next = OW_FRAME;     \n     end\n     default:\n     begin\n       dout = 1'b0;\n       OW_state_next = OW_IDLE;\n     end\n   endcase\nend\nfunction integer clogb2;\ninput [31:0] depth;\nbegin\n  for(clogb2=0; depth>0; clogb2=clogb2+1)\n  depth = depth >> 1;\nend\nendfunction\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe half_adder module performs binary addition of two single-bit inputs. Its simplicity lies in using direct bitwise operations on input ports; XOR operation for summation (`s`) and AND operation for carry (`c`). No internal signals, keeping the design straightforward and effective.\nModule head:\n\nmodule half_adder(\n    input a,\n    input b,\n    output s,\n    output c\n    )",
        "output": "`timescale 1ns / 1ps\nmodule half_adder(\n    input a,\n    input b,\n    output s,\n    output c\n    );\nassign s = a ^ b;\nassign c = a & b;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'tb_cencoder' module is a testbench for the 'conv_encoder', aimed at verifying encoder functionality with varied binary inputs 'bin'. It drives a clock 'ck' and reset 'rset' effectively through an 'always' block simulating clock cycles and an 'initial' block for input scenarios and simulation control, outputting results via 'cout'. This setup allows thorough functional testing of the encoder under different conditions.\nModule head:\n\nmodule tb_cencoder()",
        "output": "`timescale 1ns/100ps\n`include \"cencoder.v\"\nmodule tb_cencoder();\n\twire [1:0] cout;\n\treg bin;\t\t\t\n\treg ck;\t\t\t\t\n\treg rset;\t\t\t\n\talways begin\n    \t#5 ck = 0;\n    \t#5 ck = 1;\n    end\t\n\tconv_encoder enc (\n\t\tcout,bin,ck,rset);\n\tinitial\n\tbegin\n\t\t$display(\" << Starting the simulation >>\");\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#3;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#7;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#9;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=1;\n\t\t#9;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b0;\n\t\trset=0;\n\t\t#10;\n\t\tbin = 1'b1;\n\t\trset=1;\n\t\t#20;\n\t\t$display(\" << Finishing the simulation >>\");\n\t\t$finish;\n\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `rx_port_channel_gate` manages data transfer between different clock domains, particularly handling communications from a receiver to a channel. It leverages internal registers (`rAckd`, `rConsumed`, etc.) and synchronization primitives (`cross_domain_signal`, `syncff`) to ensure data integrity and alignment across domains. It supports dynamic data widths and uses signals to indicate various states and readiness, facilitating robust and synchronized transfer of data packets.\nModule head:\n\nmodule rx_port_channel_gate #(\n\tparameter C_DATA_WIDTH = 9'd64\n)",
        "output": "`timescale 1ns/1ns\nmodule rx_port_channel_gate #(\n\tparameter C_DATA_WIDTH = 9'd64\n)\n(\n\tinput RST,\n\tinput CLK,\n\tinput RX,\t\t\t\t\t\t\t\t\n\toutput RX_RECVD,\t\t\t\t\t\t\n\toutput RX_ACK_RECVD,\t\t\t\t\t\n\tinput RX_LAST,\t\t\t\t\t\t\t\n\tinput [31:0] RX_LEN,\t\t\t\t\t\n\tinput [30:0] RX_OFF,\t\t\t\t\t\n\toutput [31:0] RX_CONSUMED,\t\t\t\t\n\tinput [C_DATA_WIDTH-1:0] RD_DATA,\t\t\n\tinput RD_EMPTY,\t\t\t\t\t\t\t\n\toutput RD_EN,\t\t\t\t\t\t\t\n\tinput CHNL_CLK,\t\t\t\t\t\t\t\n\toutput CHNL_RX,\t\t\t\t\t\t\t\n\tinput CHNL_RX_ACK,\t\t\t\t\t\t\n\toutput CHNL_RX_LAST,\t\t\t\t\t\n\toutput [31:0] CHNL_RX_LEN,\t\t\t\t\n\toutput [30:0] CHNL_RX_OFF,\t\t\t\t\n\toutput [C_DATA_WIDTH-1:0] CHNL_RX_DATA,\t\n\toutput CHNL_RX_DATA_VALID,\t\t\t\t\n\tinput CHNL_RX_DATA_REN\t\t\t\t\t\n);\nreg\t\t\t\t\t\t\t\trAckd=0, _rAckd=0;\nreg\t\t\t\t\t\t\t\trChnlRxAck=0, _rChnlRxAck=0;\nreg\t\t[31:0]\t\t\t\t\trConsumed=0, _rConsumed=0;\nreg\t\t[31:0]\t\t\t\t\trConsumedStable=0, _rConsumedStable=0;\nreg\t\t[31:0]\t\t\t\t\trConsumedSample=0, _rConsumedSample=0;\nreg\t\t\t\t\t\t\t\trCountRead=0, _rCountRead=0;\nwire\t\t\t\t\t\t\twCountRead;\nwire\t\t\t\t\t\t\twCountStable;\nwire\t\t\t\t\t\t\twDataRead = (CHNL_RX_DATA_REN & CHNL_RX_DATA_VALID);\nassign RX_CONSUMED = rConsumedSample;\nassign RD_EN = CHNL_RX_DATA_REN;\nassign CHNL_RX_LAST = RX_LAST;\nassign CHNL_RX_LEN = RX_LEN;\nassign CHNL_RX_OFF = RX_OFF;\nassign CHNL_RX_DATA = RD_DATA;\nassign CHNL_RX_DATA_VALID = !RD_EMPTY;\nalways @ (posedge CHNL_CLK) begin\n\trChnlRxAck <= #1 (RST ? 1'd0 : _rChnlRxAck);\nend\nalways @ (*) begin\n\t_rChnlRxAck = CHNL_RX_ACK;\nend\ncross_domain_signal rxSig (\n\t.CLK_A(CLK), \n\t.CLK_A_SEND(RX), \n\t.CLK_A_RECV(RX_RECVD), \n\t.CLK_B(CHNL_CLK), \n\t.CLK_B_RECV(CHNL_RX), \n\t.CLK_B_SEND(CHNL_RX)\n);\nsyncff rxAckSig (.CLK(CLK), .IN_ASYNC(rAckd), .OUT_SYNC(RX_ACK_RECVD));\nalways @ (posedge CHNL_CLK) begin\n\trAckd <= #1 (RST ? 1'd0 : _rAckd);\nend\nalways @ (*) begin\n\t_rAckd = (CHNL_RX & (rAckd | rChnlRxAck));\nend\nalways @ (posedge CHNL_CLK) begin\n\trConsumed <= #1 _rConsumed;\n\trConsumedStable <= #1 _rConsumedStable;\n\trCountRead <= #1 (RST ? 1'd0 : _rCountRead);\nend\nalways @ (*) begin\n\t_rConsumed = (!CHNL_RX ? 0 : rConsumed + (wDataRead*(C_DATA_WIDTH/32)));\n\t_rConsumedStable = (wCountRead | rCountRead ? rConsumedStable : rConsumed);\n\t_rCountRead = !wCountRead;\nend\nalways @ (posedge CLK) begin\n\trConsumedSample <= #1 _rConsumedSample;\nend\nalways @ (*) begin\n\t_rConsumedSample = (wCountStable ? rConsumedStable : rConsumedSample);\nend\ncross_domain_signal countSync (\n\t.CLK_A(CHNL_CLK), \n\t.CLK_A_SEND(rCountRead), \n\t.CLK_A_RECV(wCountRead), \n\t.CLK_B(CLK), \n\t.CLK_B_RECV(wCountStable), \n\t.CLK_B_SEND(wCountStable)\n);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe AND module performs a logical AND operation on two input signals (ent1 and ent2) and outputs the result to the output port sal. The functionality is implemented through direct combinational logic, using an assignment statement that assigns the result of the ent1 and ent2 logical AND operation to sal, ensuring the output reflects the truth table of an AND gate.\nModule head:\nmodule AND( input wire ent1,ent2,output wire sal\n    )",
        "output": "module AND( input wire ent1,ent2,output wire sal\n    );\nassign sal=ent1&ent2;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'controller' module interacts with an Arithmetic Logic Unit (ALU) instance ('dut'), processing binary inputs from switches to generate a result. It uses a clock signal for synchronization, a reset signal for initialization, and 'i_pulsadores' input to load data into operandA, operandB, or opcode registers, based on its value. These values are then fed to the ALU to perform arithmetic or logic operations. The result is output as 'o_result'. The implementation employs a case structure within an always block that reacts to the rising edge of the clock signal.\nModule head:\n\nmodule controller\n#(\n    parameter           NB_DATA = 8,\n    parameter           NB_OPCODE = 6,\n    parameter           N_PULSADORES = 3\n)",
        "output": "`timescale 1ns / 1ps\nmodule controller\n#(\n    parameter           NB_DATA = 8,\n    parameter           NB_OPCODE = 6,\n    parameter           N_PULSADORES = 3\n)\n(\n    input wire signed   [NB_DATA-1:0]           i_switches,\n    input wire          [N_PULSADORES-1:0]      i_pulsadores,\n    input wire                                  i_clock,    \n    input wire                                  i_reset,\n    output wire signed  [NB_DATA-1:0]           o_result\n);\n    reg signed [NB_DATA-1:0]   operandA;\n    reg signed [NB_DATA-1:0]   operandB;\n    reg [NB_OPCODE-1:0]        opcode;\n    always @(posedge i_clock)\n    begin\n        if(i_reset)\n            begin\n                operandA <= {NB_DATA {1'b0}};\n                operandB <= {NB_DATA {1'b0}};\n                opcode <= {NB_OPCODE {1'b0}};\n            end\n        else\n            begin\n                case(i_pulsadores)\n                    {{N_PULSADORES-3 {1'b0}}, 3'b001}: operandA <= i_switches; \n                    {{N_PULSADORES-3 {1'b0}}, 3'b010}: operandB <= i_switches; \n                    {{N_PULSADORES-3 {1'b0}}, 3'b100}: opcode <= i_switches; \n                    default: \n                    begin\n                        operandA <= operandA;\n                        operandB <= operandB;\n                        opcode <= opcode;\n                    end\n                    endcase\n            end\n    end\n    alu\n    #(\n        .NB_DATA    (NB_DATA),\n        .NB_OPCODE  (NB_OPCODE)\n    )\n    dut\n    (\n        .i_op_1 (operandA),\n        .i_op_2 (operandB),             \n        .i_opcode(opcode),\n        .o_result(o_result)\n    );\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'crc32_dat32_any_byte' module calculates CRC-32 checksums for data inputs of varying sizes (8, 16, 24, or 32 bits) as specified by 'dat_size'. It handles data bit reversal based on 'REVERSE_DATA', employs separate CRC calculation submodules for each data width, and uses a generate block with multiplexing for output selection, composite tailoring of CRC results based on input size and conditionally reversed data.\nModule head:\nmodule crc32_dat32_any_byte (\n\tdat_size,\n\tcrc_in,\n\tcrc_out,\n\tdat8,dat16,dat24,dat32\n)",
        "output": "module crc32_dat32_any_byte (\n\tdat_size,\n\tcrc_in,\n\tcrc_out,\n\tdat8,dat16,dat24,dat32\n);\ninput [1:0] dat_size;\ninput [31:0] crc_in;\noutput [31:0] crc_out;\nwire [31:0] crc_out;\ninput [7:0] dat8;\ninput [15:0] dat16;\ninput [23:0] dat24;\ninput [31:0] dat32;\nparameter METHOD = 1; \nparameter REVERSE_DATA = 0; \nwire [7:0] dat8_w;\nwire [15:0] dat16_w;\nwire [23:0] dat24_w;\nwire [31:0] dat32_w;\ngenvar i;\ngenerate\nif (REVERSE_DATA)\nbegin\n\t\tfor (i=0; i<32; i=i+1)\n\t\tbegin : rev_32\n\t\t\tassign dat32_w[i] = dat32[31-i];\t\t\n\t\tend\n\t\tfor (i=0; i<24; i=i+1)\n\t\tbegin : rev_24\n\t\t\tassign dat24_w[i] = dat24[23-i];\t\t\n\t\tend\n\t\tfor (i=0; i<16; i=i+1)\n\t\tbegin : rev_16\n\t\t\tassign dat16_w[i] = dat16[15-i];\t\t\n\t\tend\n\t\tfor (i=0; i<8; i=i+1)\n\t\tbegin : rev_8\n\t\t\tassign dat8_w[i] = dat8[7-i];\t\t\n\t\tend\nend\nelse\nbegin\n\tassign dat32_w = dat32;\n\tassign dat24_w = dat24;\n\tassign dat16_w = dat16;\n\tassign dat8_w = dat8;\nend\nendgenerate\n\twire [31:0] co_a,co_b,co_c,co_d;\n\tcrc32_dat8  a (.crc_in (crc_in),.crc_out (co_a),.dat_in(dat8_w));\n\tcrc32_dat16 b (.crc_in (crc_in),.crc_out (co_b),.dat_in(dat16_w));\n\tcrc32_dat24 c (.crc_in (crc_in),.crc_out (co_c),.dat_in(dat24_w));\n\tcrc32_dat32 d (.crc_in (crc_in),.crc_out (co_d),.dat_in(dat32_w));\n\tdefparam a .METHOD = METHOD;\n\tdefparam b .METHOD = METHOD;\n\tdefparam c .METHOD = METHOD;\n\tdefparam d .METHOD = METHOD;\ngenerate\n\tfor (i=0; i<32;i=i+1)\n\tbegin : parmux\n\t\twire [3:0] tmp_m;\n\t\tassign tmp_m[0] = co_a[i];\n\t\tassign tmp_m[1] = co_b[i];\n\t\tassign tmp_m[2] = co_c[i];\n\t\tassign tmp_m[3] = co_d[i];\n\t\tassign crc_out[i] = tmp_m[dat_size];\n\tend\t\nendgenerate\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe altera_avalon_video_sync_generator module generates synchronization signals to manage video displays, ensuring proper timing and coordination of horizontal and vertical sync signals and video data activity. It processes input video data and control signals, adapts based on internal counters and conditional logic to produce adjusted RGB output, sync pulses, and data enable signals. The implementation uses structured logic blocks for initializing states, computing counters for each pixel and scan line, and aligning outputs with video system requirements.\nModule head:\n\nmodule altera_avalon_video_sync_generator\n  (\n   clk,\n   reset_n,\n   ready,\n   valid,\n   data,   \n   sop,    \n   eop,    \n   empty,  \n   RGB_OUT,     \n   HD,\n   VD,\n   DEN\n   )",
        "output": "`timescale 100 ps / 100 ps\nmodule altera_avalon_video_sync_generator\n  (\n   clk,\n   reset_n,\n   ready,\n   valid,\n   data,   \n   sop,    \n   eop,    \n   empty,  \n   RGB_OUT,     \n   HD,\n   VD,\n   DEN\n   );\n   parameter DATA_STREAM_BIT_WIDTH = 8;\n   parameter BEATS_PER_PIXEL       = 3;\n   parameter OUTPUT_CLOCK_EDGE     = 1;  \n   parameter NUM_ROWS              = 480;\n   parameter NUM_COLUMNS           = 800;\n   parameter H_BLANK_PIXELS        = 216;\n   parameter H_FRONT_PORCH_PIXELS  = 40;\n   parameter H_SYNC_PULSE_PIXELS   = 1;\n   parameter H_SYNC_PULSE_POLARITY = 0;\n   parameter V_BLANK_LINES         = 35;\n   parameter V_FRONT_PORCH_LINES   = 10;\n   parameter V_SYNC_PULSE_LINES    = 1;\n   parameter V_SYNC_PULSE_POLARITY = 0;\n   parameter TOTAL_HSCAN_PIXELS    = 1056;\n   parameter TOTAL_VSCAN_LINES     = 525;   \n   localparam COLUMN_COUNTER_WIDTH       = (log2(TOTAL_HSCAN_PIXELS ));\n   localparam ROW_COUNTER_WIDTH          = (log2(TOTAL_VSCAN_LINES  ));\n   localparam PIXEL_PART_COUNTER_WIDTH   = (log2(BEATS_PER_PIXEL+1  )); \n   input     reset_n;\n   input     clk;\n   wire      sync_reset = 1'b0;   \n   output [(DATA_STREAM_BIT_WIDTH - 1):0] RGB_OUT;\n   output \t\t\t\t  HD;\n   output \t\t\t\t  VD;\n   output \t\t\t\t  DEN;\n   output \t\t\t\t  ready;\n   input \t\t\t\t  valid;\n   input [(DATA_STREAM_BIT_WIDTH - 1):0]  data;\n   input \t\t\t\t  sop;\n   input \t\t\t\t  eop;\n   input \t\t\t\t  empty;  \n   function integer log2;\n      input [31:0] \t  value;\n      for (log2=0; value>0; log2=log2+1)\n\tvalue = value>>1;\n   endfunction \n   wire [(DATA_STREAM_BIT_WIDTH - 1):0] pRGB_OUT = data;\n   reg  [PIXEL_PART_COUNTER_WIDTH : 0] pixel_part_counter;\n   wire [PIXEL_PART_COUNTER_WIDTH : 0] next_pixel_part_counter;\n   assign next_pixel_part_counter = (pixel_part_counter == (BEATS_PER_PIXEL - 1)) ?\n\t\t\t             0                                            :\n\t\t\t             pixel_part_counter + 1                       ;\n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)             \n\tpixel_part_counter <= 0;\n      else\n\tpixel_part_counter <= next_pixel_part_counter;\n   end\n   wire  pixel_count_enable;\n   assign pixel_count_enable = (BEATS_PER_PIXEL == 1)    ? \n\t\t\t       1'b1                      : \n\t\t\t       (pixel_part_counter == 0) ;\n   reg  [COLUMN_COUNTER_WIDTH-1:0] column_counter;   \n   wire [COLUMN_COUNTER_WIDTH-1:0] next_column_counter;\n   assign next_column_counter = (column_counter == (TOTAL_HSCAN_PIXELS - 1)) ? \n            \t                0                                            :\n\t                        column_counter + 1   \t\t             ;\n   wire   column_count_enable = pixel_count_enable;\n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)               \n\tcolumn_counter <= 0;\n      else begin\n\tif (sync_reset)               \n\t  column_counter <= 0;\n\telse \n\t  if (column_count_enable)    \n\t    column_counter <= next_column_counter;\n      end\n   end \n   reg  [ROW_COUNTER_WIDTH-1 : 0] row_counter;\n   wire [ROW_COUNTER_WIDTH-1 : 0] next_row_counter;\n   assign next_row_counter = (row_counter == (TOTAL_VSCAN_LINES - 1)) ? \n                              0                                       : \n\t                      row_counter + 1                         ;\n   wire row_counter_enable = column_count_enable                          && \n\t                         (column_counter == (TOTAL_HSCAN_PIXELS - 1))  ; \n   always @(posedge clk or negedge reset_n) begin\n      if (reset_n == 0)                 \n\trow_counter <= 0;\n      else begin\n\t if (sync_reset)                \n\t   row_counter <= 0;\n\t else\n\t   if (row_counter_enable)      \n\t     row_counter <= next_row_counter;\n      end\n   end \n   wire pHD = ((column_counter >= 0) && (column_counter <= (H_SYNC_PULSE_PIXELS - 1)));\n   wire pVD = ((   row_counter >= 0) && (   row_counter <= (V_SYNC_PULSE_LINES - 1 )));\n   wire ppHD = (H_SYNC_PULSE_POLARITY == 1) ? pHD : ~pHD;\n   wire ppVD = (V_SYNC_PULSE_POLARITY == 1) ? pVD : ~pVD;\n   wire h_active = (column_counter >= H_BLANK_PIXELS              ) &&\n                   (column_counter <  H_BLANK_PIXELS + NUM_COLUMNS)  ;\n   wire v_active = (   row_counter >= V_BLANK_LINES               ) &&\n                   (   row_counter <  V_BLANK_LINES  + NUM_ROWS   )  ;\n   wire pDEN     = h_active & v_active;\n   reg \tHD;\n   reg \tVD;\n   reg \tDEN;\n   reg \t[(DATA_STREAM_BIT_WIDTH - 1):0] RGB_OUT;\n   wire output_clk = (OUTPUT_CLOCK_EDGE == 0) ? ~clk : clk;\n   always @(posedge output_clk or negedge reset_n) begin\n      if (reset_n == 0) begin\n\t HD      <= 1;\n\t VD      <= 1;\n\t DEN     <= 0;\n\t RGB_OUT <= 0;\n      end\n      else begin\n\t HD      <= ppHD;\n\t VD      <= ppVD;\n\t DEN     <= pDEN;\n\t RGB_OUT <= pRGB_OUT;\n      end\n   end\n   wire first_pixel = (column_counter == H_BLANK_PIXELS) &&\n\t              (row_counter    == V_BLANK_LINES ) &&\n\t              ((pixel_part_counter == 1) || (BEATS_PER_PIXEL == 1)) ;\n   wire stop_dataflow = (pDEN == 0)           ||\n\t                    (sop && ~first_pixel)  ;\n   assign ready = ~stop_dataflow;\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'lsp_lsf2Test' Verilog module is a testbench designed to validate the 'lsp_lsfPipe' module which converts LSP to LSF data. It initializes data arrays, executes clock-driven testing using start, reset, and memory address configuration. Verification includes writing test data, triggering the conversion module, reading outputs, and comparing these against expected results to display error messages or confirmations based on output correctness. The design utilizes iterative loops and configured delays to mimic real-time operational conditions, ensuring reliable module testing.\nModule head:\n\nmodule lsp_lsf2Test;\n\treg start;\n\treg clk;\n\treg reset;\n\treg [11:0] lspAddr;\n\treg [11:0] lsfAddr;\n\treg [11:0] testReadAddr;\n\treg [11:0] testWriteAddr;\n\treg [31:0] testMemOut;\n\treg testWriteEn;\n\treg memMuxSel;\n\twire done;\n\twire [31:0] memIn;\n\treg [31:0] lspMem [0:9999];\n\treg [31:0] lsfMem [0:9999];\n\tinteger i,j;\n\tinitial \n\t\tbegin\n\t\t\t$readmemh(\"lsp_lsplsf2_lsp.out\", lspMem)",
        "output": "`timescale 1ns / 1ps\nmodule lsp_lsf2Test;\n\treg start;\n\treg clk;\n\treg reset;\n\treg [11:0] lspAddr;\n\treg [11:0] lsfAddr;\n\treg [11:0] testReadAddr;\n\treg [11:0] testWriteAddr;\n\treg [31:0] testMemOut;\n\treg testWriteEn;\n\treg memMuxSel;\n\twire done;\n\twire [31:0] memIn;\n\treg [31:0] lspMem [0:9999];\n\treg [31:0] lsfMem [0:9999];\n\tinteger i,j;\n\tinitial \n\t\tbegin\n\t\t\t$readmemh(\"lsp_lsplsf2_lsp.out\", lspMem);\n\t\t\t$readmemh(\"lsp_lsplsf2_lsf.out\", lsfMem);\t\t\t\n\t\tend\n\tlsp_lsfPipe uut (\n\t\t.start(start), \n\t\t.clk(clk), \n\t\t.reset(reset), \n\t\t.lspAddr(lspAddr), \n\t\t.lsfAddr(lsfAddr), \n\t\t.testReadAddr(testReadAddr), \n\t\t.testWriteAddr(testWriteAddr), \n\t\t.testMemOut(testMemOut), \n\t\t.testWriteEn(testWriteEn), \n\t\t.memMuxSel(memMuxSel), \n\t\t.done(done), \n\t\t.memIn(memIn)\n\t);\n\tinitial begin\n\t\tstart = 0;\n\t\tclk = 0;\n\t\treset = 0;\n\t\tlspAddr = 12'd512;\n\t\tlsfAddr = 12'd1024;\n\t\ttestReadAddr = 0;\n\t\ttestWriteAddr = 0;\n\t\ttestMemOut = 0;\n\t\ttestWriteEn = 0;\n\t\tmemMuxSel = 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk) #5;\n\t\treset = 1;\n\t\t@(posedge clk);\n\t\t@(posedge clk) #5;\n\t\treset = 0;\n\tfor(j=0;j<60;j=j+1)\n\t\tbegin\n\t\t\tfor(i=0;i<10;i=i+1)\n\t\t\tbegin\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk) #5;\t\t\t\t\n\t\t\t\ttestMemOut = lspMem[10*j+i];\t\t\t\t\n\t\t\t\ttestWriteAddr = {lspAddr[10:4], i[3:0]};\t\t\t\t\n\t\t\t\ttestWriteEn = 1;\t\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk);\n\t\t\t\t@(posedge clk) #5;\n\t\t\tend\n\t\t\tmemMuxSel = 1;\t\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\t\t\n\t\t\tstart = 1;\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\n\t\t\tstart = 0;\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\n\t\twait(done);\n\t\tmemMuxSel = 0;\n\t\t\tfor (i = 0; i<10;i=i+1)\n\t\t\tbegin\t\t\t\t\n\t\t\t\t\ttestReadAddr = {lsfAddr[10:4],i[3:0]};\n\t\t\t\t\t@(posedge clk);\n\t\t\t\t\t@(posedge clk) #5;\n\t\t\t\t\tif (memIn != lsfMem[j*10+i])\n\t\t\t\t\t\t$display($time, \" ERROR: lsf[%d] = %x, expected = %x\", j*10+i, memIn, lsfMem[j*10+i]);\n\t\t\t\t\telse if (memIn == lsfMem[j*10+i])\n\t\t\t\t\t\t$display($time, \" CORRECT:  lsf[%d] = %x\", j*10+i, memIn);\n\t\t\t\t\t@(posedge clk)#5; \n\t\t\tend\t\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk);\n\t\t\t@(posedge clk) #5;\t\n\t\tend\n\tend\n\tinitial forever #10 clk = ~clk;   \nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `channel_2_pulse` module is a key component in a music synthesis system, generating audio waveforms and synchronization pulses. It utilizes `channel_2_note_sequencer` and `phase_generator` submodules and a variety of internal signals like `w_top`, `w_phase`, `w_envelope`, etc. Functionality is achieved through sequenced note processing, phase generation based on phase deltas, data validity checks, and wave shaping by combining envelope and phase information.\nModule head:\n\nmodule channel_2_pulse #(\n  parameter NOTE_TABLE_FILE = \"\"\n)",
        "output": "`default_nettype none\nmodule channel_2_pulse #(\n  parameter NOTE_TABLE_FILE = \"\"\n) (\n  input wire          i_clk,\n  input wire          i_rst,\n  input wire          i_tick_stb,\n  input wire          i_note_stb,\n  output wire [8:0]   o_output,\n  output wire         o_frame_pulse\n);\n  wire [7:0]    w_top;\n  wire          w_top_valid;\n  wire [31:0]   w_phase_delta;\n  wire          w_compare_valid = 1;\n  wire [8:0]    w_envelope;\n  channel_2_note_sequencer #(\n    .NOTE_TABLE_FILE(NOTE_TABLE_FILE)\n  ) sequencer (\n    .i_clk(i_clk),\n    .i_rst(i_rst),\n    .i_tick_stb(i_tick_stb),\n    .i_note_stb(i_note_stb),\n    .o_top(w_top),\n    .o_top_valid(w_top_valid),\n    .o_phase_delta(w_phase_delta),\n    .o_envelope(w_envelope)\n  );\n  wire [31:0] w_phase;\n  phase_generator phase_generator (\n    .i_clk(i_clk),\n    .i_rst(i_rst),\n    .i_phase_delta(w_phase_delta),\n    .i_phase_delta_valid(1'b1),\n    .o_phase(w_phase),\n    .o_phase_strobe()\n  );\n  wire [8:0]  w_compare = (w_phase[31:30] == 2'b11)? w_envelope: 9'd0;\n  assign o_output = w_compare;\n  assign o_frame_pulse = w_phase[31];\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe OBUF_LVCMOS25_S_12 module serves as a conditional output buffer controlled by a global tri-state signal (GTS). It facilitates signal isolation by setting the output (O) to high impedance when GTS is low. The module uses a `bufif0` gate (B1) that connects the input (I) to the output (O) based on GTS state, effectively managing signal contention in shared output environments.\nModule head:\n\nmodule OBUF_LVCMOS25_S_12 (O, I)",
        "output": "`timescale  1 ps / 1 ps\nmodule OBUF_LVCMOS25_S_12 (O, I);\n    output O;\n    input  I;\n    tri0 GTS = glbl.GTS;\n    bufif0 B1 (O, I, GTS);\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'alu_tb' module serves as a testbench for an ALU, simulating various arithmetic and logic operations using randomized inputs (operands, carry, operation codes) over multiple clock cycles. It utilizes an 'initial' block for setting up initial conditions, an 'always' block for clock generation, and dynamic test execution through iterating random inputs and observing outputs to verify ALU behavior extensively.\nModule head:\n \nmodule alu_tb()",
        "output": "`timescale 1ns / 1ps\n`define data_width 4\n`define data_out 5 \n`define DELAY 5 \nmodule alu_tb();\nreg clk ;\nreg rst_n ;\nreg [`data_width-1:0] test_a ;\nreg [`data_width-1:0] test_b ;\nreg [`data_width-1:0]opcode ;\nwire [`data_width-1:0] reg_Y_out ;\nwire [`data_out-1:0] result_out ;\nwire c_out ;\nreg test_c ;\nreg test_bi ;\nwire  sign_b ;\n wire zero_b ;\n wire parity_b ;\n wire overflow;\nalu ALU_DUT(\n .a_in(test_a),\n .b_in(test_b) ,\n .ci(test_c),\n .bi(test_bi), \n .opcode(opcode) , \n .reg_Y_out(reg_Y_out) , \n .clk(clk),\n .c_out(c_out) , \n .sign_b(sign_b), \n .zero_b(zero_b),\n .parity_b(parity_b),\n .overflow(overflow),\n .result_out(result_out), \n .rst_n(rst_n));\n integer i ;\ninitial \nbegin\nclk = 1'b0 ;\n rst_n = 1'b0;\nend\nalways #`DELAY clk = ~clk ;\ninitial begin\ntest_a = 4'b0000 ;\ntest_b = 4'b0000 ;\ntest_c = 1'b0 ;\ntest_bi = 1'b0 ;\n end\ninitial\n  begin\n  rst_n = 1'b1 ;\n  for (i = 0 ; i<50 ; i = i + 1 )\n  begin\n  test_a = $random() ;\n  test_b= $random();\n  test_c = $random() ;\n  test_bi = $random();\n  opcode = $random() ;\n  #`DELAY ;\n  $display(\"Time = %t , test_a = %b , test_b = %b ,test_c = %b , test_bi = %b, reg_Y_out = %b\" , $time , test_a , test_b, test_c , test_bi , reg_Y_out ) ;  \n  end\nend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'matrix_mult' module performs 32-bit specialized matrix multiplication, possibly for cryptographic purposes like AES MixColumns. It processes a 32-bit input 'ip' into four 8-bit segments, conditionally transforms each using shifts and XORs with a polynomial '8'h1b', and combines them to form a 32-bit output 'op'. Each step involves segment extraction, conditional manipulation, and reassembly through XOR operations.\nModule head:\nmodule matrix_mult(\ninput  [31:0] ip,\noutput [31:0] op\n)",
        "output": "module matrix_mult(\ninput  [31:0] ip,\noutput [31:0] op\n);\nwire [7:0] b0;\nwire [7:0] b1;\nwire [7:0] b2;\nwire [7:0] b3;\nwire [7:0] a0;\nwire [7:0] a1;\nwire [7:0] a2;\nwire [7:0] a3;\nassign a0 = ip[31:24];\nassign a1 = ip[23:16];\nassign a2 = ip[15:8];\nassign a3 = ip[7:0];\nassign b0 = (a0[7]==1'b1)?((a0<<1)^(8'h1b)):(a0<<1);\nassign b1 = (a1[7]==1'b1)?((a1<<1)^(8'h1b)):(a1<<1);\nassign b2 = (a2[7]==1'b1)?((a2<<1)^(8'h1b)):(a2<<1);\nassign b3 = (a3[7]==1'b1)?((a3<<1)^(8'h1b)):(a3<<1);\nassign op[31:24] = b0^a3^a2^b1^a1; \nassign op[23:16] = b1^a0^a3^b2^a2;\nassign op[15:8] = b2^a1^a0^b3^a3;\nassign op[7:0] = b3^a2^a1^b0^a0;\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Top module orchestrates a multi-stage binary addition system using carry-save addition techniques. It accepts six 4-bit inputs, processes them through stages stage1_3is2 and stage2_3is2 for initial addition, and then further reduces them in stage3_4is2 to produce a 6-bit output. Internal signals facilitate inter-stage carry and sum propagation, ensuring efficient computation across the stages embedded with FullAdder and carrysave_4is2 sub-modules.\nModule head:\nmodule stage1_3is2 (\ninput [5:0] in1,\ninput [5:0] in2,\ninput [5:0] in3,\noutput [5:0] cout_stage1,\noutput [5:0] sum_stage1\n)",
        "output": "module stage1_3is2 (\ninput [5:0] in1,\ninput [5:0] in2,\ninput [5:0] in3,\noutput [5:0] cout_stage1,\noutput [5:0] sum_stage1\n);\nFullAdder FA2 (in1[0],in2[0],in3[0],sum_stage1[0],cout_stage1[0]);\nFullAdder FA3 (in1[1],in2[1],in3[1],sum_stage1[1],cout_stage1[1]);\nFullAdder FA4 (in1[2],in2[2],in3[2],sum_stage1[2],cout_stage1[2]);\nFullAdder FA5 (in1[3],in2[3],in3[3],sum_stage1[3],cout_stage1[3]);\nFullAdder FA12 (in1[4],in2[4],in3[4],sum_stage1[4],cout_stage1[4]);\nFullAdder FA13 (in1[5],in2[5],in3[5],sum_stage1[5],cout_stage1[5]);\nendmodule\nmodule stage2_3is2 (\ninput [5:0] in4,\ninput [5:0] in5,\ninput [5:0] in6,\noutput [5:0] cout_stage2,\noutput [5:0] sum_stage2\n);\nFullAdder FA6 (in4[0],in5[0],in6[0],sum_stage2[0],cout_stage2[0]);\nFullAdder FA7 (in4[1],in5[1],in6[1],sum_stage2[1],cout_stage2[1]);\nFullAdder FA8 (in4[2],in5[2],in6[2],sum_stage2[2],cout_stage2[2]);\nFullAdder FA9 (in4[3],in5[3],in6[3],sum_stage2[3],cout_stage2[3]);\nFullAdder FA22 (in4[4],in5[4],in6[4],sum_stage2[4],cout_stage2[4]);\nFullAdder FA23 (in4[5],in5[5],in6[5],sum_stage2[5],cout_stage2[5]);\nendmodule\nmodule stage3_4is2 (\ninput [5:0] subin1,\ninput [5:0] subin2,\ninput [5:0] subin3,\ninput [5:0] subin4,\noutput [5:0] sum_stage3,\noutput [5:0] cout_stage3\n);\nwire connection1,connection2,connection3,connection4,connection5;\ncarrysave_4is2 CS1(({1'b0,1'b0,subin3[0],1'b0,subin1[0]}),connection1,cout_stage3[0],sum_stage3[0]);\ncarrysave_4is2 CS2(({connection1,subin4[0],subin3[1],subin2[0],subin1[1]}),connection2,cout_stage3[1],sum_stage3[1]);\ncarrysave_4is2 CS3(({connection2,subin4[1],subin3[2],subin2[1],subin1[2]}),connection3,cout_stage3[2],sum_stage3[2]);\ncarrysave_4is2 CS4(({connection3,subin4[2],subin3[3],subin2[2],subin1[3]}),connection4,cout_stage3[3],sum_stage3[3]);\ncarrysave_4is2 CS5(({connection4,subin4[3],subin3[4],subin2[3],subin1[4]}),connection5,cout_stage3[4],sum_stage3[4]);\ncarrysave_4is2 CS6(({connection5,subin4[4],subin3[5],subin2[4],subin1[5]}), , ,sum_stage3[5]);\nendmodule\nmodule Top (\ninput [3:0] i1,\ninput [3:0] i2,\ninput [3:0] i3,\ninput [3:0] i4,\ninput [3:0] i5,\ninput [3:0] i6,\noutput [5:0] answer\n);\nwire [5:0] cout_S1;\nwire [5:0] sum_S1;\nwire [5:0] cout_S2;\nwire [5:0] sum_S2;\nwire [5:0] sum_S3;\nwire [5:0] cout_S3;\nstage1_3is2 S1 ( {i1[3],i1[3],i1[3:0]} , {i2[3],i2[3],i2[3:0]} , {i3[3],i3[3],i3[3:0]} , cout_S1[5:0] , sum_S1[5:0]);\nstage2_3is2 S2 ( {i4[3],i4[3],i4[3:0]} , {i5[3],i5[3],i5[3:0]} , {i6[3],i6[3],i6[3:0]} , cout_S2[5:0] , sum_S2[5:0]);\nstage3_4is2 S3 (sum_S1[5:0],({cout_S1[4:0],1'b0}),sum_S2[5:0],({cout_S2[4:0],1'b0}),sum_S3[5:0],cout_S3[5:0]);\nassign answer [5:0] = (sum_S3[5:0]) + ({cout_S3[4:0],1'b0}); \nendmodule\nmodule carrysave_4is2 (\ninput [4:0] in,\noutput c0,\noutput c1,\noutput sum\n);\nwire connection;\nFullAdder FA0 (in[0],in[1],in[2],connection,c0);\nFullAdder FA1 (connection,in[4],in[3],sum,c1);\nendmodule\nmodule FullAdder(\ninput in1,\ninput in2,\ninput cin,\noutput sum,\noutput cout\n);\nassign sum = (in1 ^ in2) ^ cin;\nassign cout = (in1 & in2) | (cin & (in1 ^ in2));\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThis module implements a 2-bit bitwise XOR function between inputs 'a' and 'b', and outputs the result on 'out'. Operationally, an 'always @(*)' block updates the output 'out' based on the XOR of corresponding bits from 'a' and 'b', ensuring output immediacy on input change.\nModule head:\nmodule xor2_2bit (a, b, out)",
        "output": "module xor2_2bit (a, b, out);\n\toutput [1:0] out;\n\tinput [1:0] a;\n\tinput [1:0] b;\n\treg [1:0] out;\n\talways @(*)\n\tbegin\n\t\tout[0]=a[0]^b[0];\n\t\tout[1]=a[1]^b[1];\n\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe OUT module manages serial data transformation for communication systems by interfacing with various decoding and counting submodules controlled by a system clock and input signals. Key functionalities include resetting, clock synchronization, data decoding, and status indication based on internal conditions. It processes serial data through a chain of operations starting with the initial decoding in usr_Dec_bo, further processing in Decoder_bo, status checking in counter_Dec_bo, and final modifications in usrpo_Dec_bo, providing outputs like processed data and status flags. The interconnection of these submodules ensures efficient data handling and real-time output adjustments.\nModule head:\nmodule OUT\n(\ninput RST,\ninput clk,\ninput sl_in,\ninput shift,\noutput sl_out,\noutput [20:0] reg1out,\noutput [10:0] decoout,\noutput counterout,\noutput [10:0] reg2out\n)",
        "output": "module OUT\n(\ninput RST,\ninput clk,\ninput sl_in,\ninput shift,\noutput sl_out,\noutput [20:0] reg1out,\noutput [10:0] decoout,\noutput counterout,\noutput [10:0] reg2out\n);\nwire [20:0]data_out3;\nwire [14:0]data_ouut3;\nusr_Dec_bo usr_Dec_bonus\n(\n .clk(clk),\n .RST(RST),\n .shift(1),\n .load(0),\n .sl_in(sl_in),\n .par_load(0),\n .data_out(data_out3)\n );\n assign reg1out =data_out3;\n assign data_ouut3=data_out3[14:0];\n wire [10:0] decout;\n Decoder_bo Decoder_bonus\n(\n .data_in(data_ouut3),\n .data_out(decout)\n);\nassign decoout =decout;\nwire isfulll;\ncounter_Dec_bo counter_Dec_bonus\n(\n  .clk(clk),\n  .en(shift),\n  .isfull(isfulll)\n);\nassign counterout =isfulll;\nwire [14:0]data_out1;\nusrpo_Dec_bo usrpo_Dec_bonus\n(\n .clk(clk),\n .RST(RST),\n .shift(shift),\n .load(isfulll),\n .sl_in(0),\n .par_load(decout),\n .data_out(data_out1)\n);\nassign reg2out =data_out1;\nassign sl_out=data_out1[0];\nendmodule "
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe tb_decoder module serves as a testbench for validating the functionality of the ham_15_11_decoder, which decodes 15-bit encoded input vectors into 11-bit outputs. It loads various binary test vectors into the cin register, applies them to the decoder, and monitors outputs on the qout wire to evaluate error correction and decoding accuracy. The simulation progresses by sequentially updating cin with different test cases, observing the corresponding outputs, and highlighting start and end points with display messages.\nModule head:\n\nmodule tb_decoder()",
        "output": "`timescale 1ns/100ps\n`include \"ham_15_11_decoder.syn.v\"\n`include \"ham_decoder.syn.v\"\n`include \"/auto/home-scf-06/ee577/design_pdk/osu_stdcells/lib/tsmc018/lib/osu018_stdcells.v\"\nmodule tb_decoder();\n\twire [10:0] qout;\n\treg [14:0] cin;\n\tham_15_11_decoder dec (\n\t\tcin,qout);\n\tinitial\n\tbegin\n\t\t$display(\" << Starting the simulation >>\");\n\t\tcin = 15'b110101100000011;\n\t\t$display(cin[1],\" << b1 b2 >>\",cin[2]);\n\t\t$display(cin[3],\" << b1 b2 >>\",cin[4]);\n\t\t#1;\n\t\tcin = 15'b111000111000011;\n\t\t#1;\n\t\tcin = 15'b110011101010011;\n\t\t#1;\n\t\tcin = 15'b111101110010011;\n\t\t#1;\n\t\tcin = 15'b111110000100011;\n\t\t#20;\n\t\t$display(\" << Finishing the simulation >>\");\n\t\t$finish;\n\tend\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe `wallace_tree` module multiplies two 24-bit binary inputs, `inp1` and `inp2`, using the Wallace Tree algorithm for efficient computation. It initially generates 24 partial products shifted according to the bit positions of `inp2`. These products are then combined using multiple stages of carry-save adders (CSAs) to consolidate sums and carries, reducing the operations needed for the final sum. The result is output through a 48-bit product port and a carry flag indicating overflow, both calculated with a final ripple carry adder.\nModule head:\n\nmodule wallace_tree(carryf,product1,inp1,inp2)",
        "output": "`timescale 1ns / 1ps\nmodule wallace_tree(carryf,product1,inp1,inp2);\ninput [23:0]inp1;\ninput [23:0]inp2;\nwire [47:0]product;\noutput [47:0]product1;\noutput carryf;\nwire [49:0]p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24;\nwire [49:0]carry1,carry2,carry3,carry4,carry5,carry6,carry7,carry8,carry9,carry10,carry11,carry12,carry13,carry14,carry15,carry16,carry17,carry18,carry19,carry20,carry21,carry22;\nwire [49:0]sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8,sum9,sum10,sum11,sum12,sum13,sum14,sum15,sum16,sum17,sum18,sum19,sum20,sum21,sum22;\nassign p1=(inp2[0]==1'b1)?{25'b0,inp1}:50'h00000000;\nassign p2=(inp2[1]==1'b1)?{24'b0,inp1,1'b0}:50'h00000000;\nassign p3=(inp2[2]==1'b1)?{23'b0,inp1,2'b0}:50'h00000000;\nassign p4=(inp2[3]==1'b1)?{22'b0,inp1,3'b0}:50'h00000000;\nassign p5=(inp2[4]==1'b1)?{21'b0,inp1,4'b0}:50'h00000000;\nassign p6=(inp2[5]==1'b1)?{20'b0,inp1,5'b0}:50'h00000000;\nassign p7=(inp2[6]==1'b1)?{19'b0,inp1,6'b0}:50'h00000000;\nassign p8=(inp2[7]==1'b1)?{18'b0,inp1,7'b0}:50'h00000000;\nassign p9=(inp2[8]==1'b1)?{17'b0,inp1,8'b0}:50'h00000000;\nassign p10=(inp2[9]==1'b1)?{16'b0,inp1,9'b0}:50'h00000000;\nassign p11=(inp2[10]==1'b1)?{15'b0,inp1,10'b0}:50'h00000000;\nassign p12=(inp2[11]==1'b1)?{14'b0,inp1,11'b0}:50'h00000000;\nassign p13=(inp2[12]==1'b1)?{13'b0,inp1,12'b0}:50'h00000000;\nassign p14=(inp2[13]==1'b1)?{12'b0,inp1,13'b0}:50'h00000000;\nassign p15=(inp2[14]==1'b1)?{11'b0,inp1,14'b0}:50'h00000000;\nassign p16=(inp2[15]==1'b1)?{10'b0,inp1,15'b0}:50'h00000000;\nassign p17=(inp2[16]==1'b1)?{9'b0,inp1,16'b0}:50'h00000000;\nassign p18=(inp2[17]==1'b1)?{8'b0,inp1,17'b0}:50'h00000000;\nassign p19=(inp2[18]==1'b1)?{7'b0,inp1,18'b0}:50'h00000000;\nassign p20=(inp2[19]==1'b1)?{6'b0,inp1,19'b0}:50'h00000000;\nassign p21=(inp2[20]==1'b1)?{5'b0,inp1,20'b0}:50'h00000000;\nassign p22=(inp2[21]==1'b1)?{4'b0,inp1,21'b0}:50'h00000000;\nassign p23=(inp2[22]==1'b1)?{3'b0,inp1,22'b0}:50'h00000000;\nassign p24=(inp2[23]==1'b1)?{2'b0,inp1,23'b0}:50'h00000000;\ncarrysaveadder c1(carry1,sum1,p1,p2,p3);\ncarrysaveadder c2(carry2,sum2,p4,p5,p6);\ncarrysaveadder c3(carry3,sum3,p7,p8,p9);\ncarrysaveadder c4(carry4,sum4,p10,p11,p12);\ncarrysaveadder c5(carry5,sum5,p13,p14,p15);\ncarrysaveadder c6(carry6,sum6,p16,p17,p18);\ncarrysaveadder c7(carry7,sum7,p19,p20,p21);\ncarrysaveadder c8(carry8,sum8,p22,p23,p24);\ncarrysaveadder c9(carry9,sum9,sum1,carry1,sum2);\ncarrysaveadder c10(carry10,sum10,carry2,sum3,carry3);\ncarrysaveadder c11(carry11,sum11,sum4,carry4,sum5);\ncarrysaveadder c12(carry12,sum12,carry5,sum6,carry6);\ncarrysaveadder c13(carry13,sum13,sum7,carry7,sum8);\ncarrysaveadder c14(carry14,sum14,sum9,carry9,sum10);\ncarrysaveadder c15(carry15,sum15,carry10,sum11,carry11);\ncarrysaveadder c16(carry16,sum16,sum12,carry12,sum13);\ncarrysaveadder c17(carry17,sum17,sum14,carry14,sum15);\ncarrysaveadder c18(carry18,sum18,carry15,sum16,carry16);\ncarrysaveadder c19(carry19,sum19,sum17,carry17,sum18);\ncarrysaveadder c20(carry20,sum20,carry18,carry13,carry8);\ncarrysaveadder c21(carry21,sum21,sum19,carry19,sum20);\ncarrysaveadder c22(carry22,sum22,sum21,carry21,carry20);\nrca24bit add1(sum22,carry22,1'b0,product,carryf);\nassign product1 = product[47:0];\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'm2vfbagen' module generates a memory address for video frame buffer access using block type, frame context, and macroblock and pixel positions. It constructs the address dynamically, padding bits if needed, based on input width parameters and internal calculation of bit requirements. This enables efficient, conditional video data access, vital for processing applications.\nModule head:\nmodule m2vfbagen #(\n\tparameter\n\tMEM_WIDTH = 21,\n\tMBX_WIDTH = 6,\n\tMBY_WIDTH = 5\n)",
        "output": "module m2vfbagen #(\n\tparameter\n\tMEM_WIDTH = 21,\n\tMBX_WIDTH = 6,\n\tMBY_WIDTH = 5\n) (\n\tinput [2:0] block,\n\tinput frame,\n\tinput [(MBX_WIDTH-1):0] mbx,\n\tinput [2:0] x2,\n\tinput [(MBY_WIDTH-1):0] mby,\n\tinput [3:0] y,\n\toutput [(MEM_WIDTH-1):0] addr\n);\nlocalparam REQUIRED_WIDTH = MBX_WIDTH + MBY_WIDTH + 10;\nassign addr[(REQUIRED_WIDTH-1):0] =\n{\n\tframe,\n\tblock[2],\n\tmby,\n\tmbx,\n\ty[3:1], block[2] ? 1'b0 : y[0],\n\tx2[2:1], block[2] ? block[0] : x2[0],\n\t1'b0\n};\ngenerate\n\tif(MEM_WIDTH > REQUIRED_WIDTH)\n\t\tassign addr[(MEM_WIDTH-1):REQUIRED_WIDTH] =\n\t\t\t{(MEM_WIDTH-REQUIRED_WIDTH){1'b0}};\nendgenerate\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe Register_File module emulates a processor's register file, synchronizing data write operations on a positive clock edge and allowing continuous data reads. It initializes an internal 32x32-bit register array `RegFile` to zero, writes data to a specified register when `RegWrite` is enabled, and outputs data from two registers based on input addresses. This facilitates dynamic data handling with real-time response to input changes.\nModule head:\nmodule Register_File (\n    input clk,RegWrite,\n    input [4:0]A1,\n    input [4:0]A2,\n    input [4:0]A3,\n    input [31:0]WD3,\n    output reg [31:0]RD1,\n    output reg [31:0]RD2\n)",
        "output": "module Register_File (\n    input clk,RegWrite,\n    input [4:0]A1,\n    input [4:0]A2,\n    input [4:0]A3,\n    input [31:0]WD3,\n    output reg [31:0]RD1,\n    output reg [31:0]RD2\n);\n    reg [31:0]RegFile[0:31];\n    integer i;\n\tinitial\n\tbegin\n\tfor(i=0;i<32;i=i+1)\n\t\tRegFile[i]=0;\t\n\tend \t\n    always @(posedge clk) begin\n        if(RegWrite)\n        RegFile[A3]<=WD3;\n    end\n    always @(*) begin\n\tRD1<=RegFile[A1];\n    RD2<=RegFile[A2];\n    end\nendmodule"
    },
    {
        "instruction": "Given the detailed specifications of a module, generate the corresponding Verilog code.",
        "input": "Module-level description:\nThe 'alu' module acts as an Arithmetic Logic Unit performing arithmetic and bitwise operations on two 16-bit inputs guided by a 4-bit operation code. It operates on the rising edge of the clock when enabled, using a case statement to execute the specified operation, and outputs the result or zeroes on incorrect operations codes.\nModule head:\n\nmodule alu(input wire clk, \n           input alu_en,\n           input [15:0] operandA, \n           input [15:0]operandB, \n           input [3:0] oper, \n           output [15:0] q)",
        "output": "`default_nettype none\nmodule alu(input wire clk, \n           input alu_en,\n           input [15:0] operandA, \n           input [15:0]operandB, \n           input [3:0] oper, \n           output [15:0] q);\n    always @(posedge clk) begin\n        if (alu_en) begin\n            case(oper)\n            1: q <= operandB + operandA; \n            2: q <= operandB - operandA; \n            3: q <= operandB & operandA; \n            4: q <= operandB | operandA; \n            5: q <= operandB ^ operandA; \n            6: q <= operandA >> operandB; \n            7: q <= operandA << operandB; \n            8: begin \n                q[15] <= operandA[0];\n                q[14:0] <= operandA[15:1];\n            end\n            9: begin \n                q[0] <= operandA[15];\n                q[15:1] <= operandA[14:1];\n            end\n            10: q <= ~operandA; \n            11: q <= operandA * operandB;\n            default: q <= 0;\n            endcase\n        end\n    end\nendmodule"
    }
]