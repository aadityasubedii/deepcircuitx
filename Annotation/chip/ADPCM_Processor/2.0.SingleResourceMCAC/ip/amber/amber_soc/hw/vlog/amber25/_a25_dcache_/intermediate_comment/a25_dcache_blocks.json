{
    "line_num": [
        [
            939,
            940
        ],
        [
            932,
            937
        ],
        [
            919,
            929
        ],
        [
            917,
            918
        ],
        [
            908,
            916
        ],
        [
            906,
            906
        ],
        [
            898,
            905
        ],
        [
            896,
            896
        ],
        [
            888,
            895
        ],
        [
            885,
            887
        ],
        [
            873,
            882
        ],
        [
            867,
            871
        ],
        [
            811,
            854
        ],
        [
            806,
            809
        ],
        [
            777,
            804
        ],
        [
            772,
            775
        ],
        [
            747,
            770
        ],
        [
            743,
            746
        ],
        [
            720,
            740
        ],
        [
            715,
            719
        ],
        [
            670,
            709
        ],
        [
            651,
            662
        ],
        [
            641,
            648
        ],
        [
            639,
            640
        ],
        [
            632,
            638
        ],
        [
            630,
            630
        ],
        [
            624,
            629
        ],
        [
            621,
            623
        ],
        [
            611,
            613
        ],
        [
            606,
            609
        ],
        [
            604,
            604
        ],
        [
            548,
            615
        ],
        [
            532,
            541
        ],
        [
            527,
            527
        ],
        [
            518,
            520
        ],
        [
            515,
            515
        ],
        [
            511,
            513
        ],
        [
            506,
            508
        ],
        [
            499,
            503
        ],
        [
            490,
            496
        ],
        [
            477,
            484
        ],
        [
            470,
            474
        ],
        [
            465,
            469
        ],
        [
            455,
            461
        ],
        [
            450,
            453
        ],
        [
            446,
            448
        ],
        [
            439,
            443
        ],
        [
            432,
            436
        ],
        [
            427,
            429
        ],
        [
            406,
            422
        ],
        [
            404,
            404
        ],
        [
            398,
            398
        ],
        [
            395,
            397
        ],
        [
            389,
            389
        ],
        [
            388,
            388
        ],
        [
            382,
            387
        ],
        [
            376,
            379
        ],
        [
            370,
            374
        ],
        [
            364,
            368
        ],
        [
            360,
            363
        ],
        [
            351,
            359
        ],
        [
            230,
            345
        ]
    ],
    "blocks": [
        "end\nendgenerate",
        "    initial\n        begin\n        `TB_ERROR_MESSAGE\n        $display(\"Unsupported number of ways %0d\", WAYS);\n        $display(\"Set A25_DCACHE_WAYS in a25_config_defines.v to either 2,3,4 or 8\");\n        end",
        "    always @( posedge i_clk )\n        if ( (data_hit_way[0] + data_hit_way[1] + \n              data_hit_way[2] + data_hit_way[3] +\n              data_hit_way[4] + data_hit_way[5] +\n              data_hit_way[6] + data_hit_way[7] ) > 4'd1 )\n            begin\n            `TB_ERROR_MESSAGE\n            $display(\"Hit in more than one cache ways!\");                                                  \n            end\n                           \nend",
        "else if ( WAYS == 8 )  begin : check_hit_8ways\n",
        "    always @( posedge i_clk )\n        if ( (data_hit_way[0] + data_hit_way[1] + \n              data_hit_way[2] + data_hit_way[3] ) > 4'd1 )\n            begin\n            `TB_ERROR_MESSAGE\n            $display(\"Hit in more than one cache ways!\");                                                  \n            end\n                           \nend",
        "else if ( WAYS == 4 ) begin : check_hit_4ways",
        "    always @( posedge i_clk )\n        if ( (data_hit_way[0] + data_hit_way[1] + data_hit_way[2] ) > 4'd1 )\n            begin\n            `TB_ERROR_MESSAGE\n            $display(\"Hit in more than one cache ways!\");                                                  \n            end\n                           \nend",
        "else if ( WAYS == 3 ) begin : check_hit_3ways",
        "    always @( posedge i_clk )\n        if ( (data_hit_way[0] + data_hit_way[1] ) > 4'd1 )\n            begin\n            `TB_ERROR_MESSAGE\n            $display(\"Hit in more than one cache ways!\");                                                  \n            end\n                                                      \nend",
        "generate\nif ( WAYS == 2 ) begin : check_hit_2ways\n",
        "assign xC_STATE    = c_state == CS_INIT               ? \"INIT\"               :\n                     c_state == CS_IDLE               ? \"IDLE\"               :\n                     c_state == CS_FILL               ? \"FILL\"               :\n                     c_state == CS_FILL_COMPLETE      ? \"FILL_COMPLETE\"      :\n                     c_state == CS_EX_DELETE          ? \"EX_DELETE\"          :\n                     c_state == CS_TURN_AROUND        ? \"TURN_AROUND\"        :\n                     c_state == CS_WRITE_HIT          ? \"WRITE_HIT\"          :\n                     c_state == CS_WRITE_HIT_WAIT_WB  ? \"WRITE_HIT_WAIT_WB\"  :\n                     c_state == CS_WRITE_MISS_WAIT_WB ? \"WRITE_MISS_WAIT_WB\" :\n                                                        \"UNKNOWN\"               ;",
        "assign xSOURCE_SEL = source_sel[C_CORE]               ? \"C_CORE\"                :\n                     source_sel[C_INIT]               ? \"C_INIT\"                :\n                     source_sel[C_FILL]               ? \"C_FILL\"                :\n                     source_sel[C_INVA]               ? \"C_INVA\"                :\n                                                        \"UNKNON\"                ;",
        "    function [WAYS-1:0] pick_way;\n    input [WAYS-1:0] valid_bits;\n    input [3:0]      random_num;\n    begin\n        if (      valid_bits[0] == 1'd0 )\n            \n            pick_way     = 8'b00000001;\n        else if ( valid_bits[1] == 1'd0 )\n            \n            pick_way     = 8'b00000010;\n        else if ( valid_bits[2] == 1'd0 )\n            \n            pick_way     = 8'b00000100;\n        else if ( valid_bits[3] == 1'd0 )\n            \n            pick_way     = 8'b00001000;\n        else if ( valid_bits[4] == 1'd0 )\n            \n            pick_way     = 8'b00010000;\n        else if ( valid_bits[5] == 1'd0 )\n            \n            pick_way     = 8'b00100000;\n        else if ( valid_bits[6] == 1'd0 )\n            \n            pick_way     = 8'b01000000;\n        else if ( valid_bits[7] == 1'd0 )\n            \n            pick_way     = 8'b10000000;\n        else\n            begin\n            \n            case (random_num[3:1])\n                3'd0:       pick_way = 8'b00010000;\n                3'd1:       pick_way = 8'b00100000;\n                3'd2:       pick_way = 8'b01000000;\n                3'd3:       pick_way = 8'b10000000;\n                3'd4:       pick_way = 8'b00000001;\n                3'd5:       pick_way = 8'b00000010;\n                3'd6:       pick_way = 8'b00000100;\n                default:    pick_way = 8'b00001000;\n            endcase\n            end\n    end\n    endfunction",
        "end\nelse begin : pick_way_8ways\n\n    assign next_way = pick_way ( valid_bits_r, random_num );",
        "    function [WAYS-1:0] pick_way;\n    input [WAYS-1:0] valid_bits;\n    input [3:0]      random_num;\n    begin\n        if (      valid_bits[0] == 1'd0 )\n            \n            pick_way     = 4'b0001;\n        else if ( valid_bits[1] == 1'd0 )\n            \n            pick_way     = 4'b0010;\n        else if ( valid_bits[2] == 1'd0 )\n            \n            pick_way     = 4'b0100;\n        else if ( valid_bits[3] == 1'd0 )\n            \n            pick_way     = 4'b1000;\n        else\n            begin\n            \n            case (random_num[3:1])\n                3'd0, 3'd1: pick_way = 4'b0100;\n                3'd2, 3'd3: pick_way = 4'b1000;\n                3'd4, 3'd5: pick_way = 4'b0001;\n                default:    pick_way = 4'b0010;\n            endcase\n            end\n    end\n    endfunction",
        "end\nelse if ( WAYS == 4 ) begin : pick_way_4ways\n\n    assign next_way = pick_way ( valid_bits_r, random_num );",
        "    function [WAYS-1:0] pick_way;\n    input [WAYS-1:0] valid_bits;\n    input [3:0]      random_num;\n    begin\n        if (      valid_bits[0] == 1'd0 )\n            \n            pick_way     = 3'b001;\n        else if ( valid_bits[1] == 1'd0 )\n            \n            pick_way     = 3'b010;\n        else if ( valid_bits[2] == 1'd0 )\n            \n            pick_way     = 3'b100;\n        else\n            begin\n            \n            case (random_num[3:1])\n                3'd0, 3'd1, 3'd2: pick_way = 3'b010;\n                3'd2, 3'd3, 3'd4: pick_way = 3'b100;\n                default:          pick_way = 3'b001;\n            endcase\n            end\n    end\n    endfunction",
        "else if ( WAYS == 3 ) begin : pick_way_3ways\n\n    assign next_way = pick_way ( valid_bits_r, random_num );\n",
        "    function [WAYS-1:0] pick_way;\n    input [WAYS-1:0] valid_bits;\n    input [3:0]      random_num;\n    begin\n        if (      valid_bits[0] == 1'd0 )\n            \n            pick_way     = 2'b01;\n        else if ( valid_bits[1] == 1'd0 )\n            \n            pick_way     = 2'b10;\n        else\n            begin\n            \n            case (random_num[3:1])\n                3'd0, 3'd3,\n                3'd5, 3'd6: pick_way = 2'b10;\n                default:    pick_way = 2'b01;\n            endcase\n            end\n    end\n    endfunction",
        "generate\nif ( WAYS == 2 ) begin : pick_way_2ways\n\n    assign next_way = pick_way ( valid_bits_r, random_num );\n",
        "generate\nif ( WAYS == 2 ) begin : read_data_2ways\n\n    assign hit_rdata    = data_hit_way[0] ? data_rdata_way[0] :\n                          data_hit_way[1] ? data_rdata_way[1] :\n                                     {CACHE_LINE_WIDTH{1'd1}} ;  \n                           \nend\nelse if ( WAYS == 3 ) begin : read_data_3ways\n\n    assign hit_rdata    = data_hit_way[0] ? data_rdata_way[0] :\n                          data_hit_way[1] ? data_rdata_way[1] :\n                          data_hit_way[2] ? data_rdata_way[2] :\n                                     {CACHE_LINE_WIDTH{1'd1}} ;  \n                           \nend\nelse if ( WAYS == 4 ) begin : read_data_4ways\n\n    assign hit_rdata    = data_hit_way[0] ? data_rdata_way[0] :\n                          data_hit_way[1] ? data_rdata_way[1] :\n                          data_hit_way[2] ? data_rdata_way[2] :\n                          data_hit_way[3] ? data_rdata_way[3] :\n                                     {CACHE_LINE_WIDTH{1'd1}} ;  \n                           \nend\nelse begin : read_data_8ways\n\n    assign hit_rdata    = data_hit_way[0] ? data_rdata_way[0] :\n                          data_hit_way[1] ? data_rdata_way[1] :\n                          data_hit_way[2] ? data_rdata_way[2] :\n                          data_hit_way[3] ? data_rdata_way[3] :\n                          data_hit_way[4] ? data_rdata_way[4] :\n                          data_hit_way[5] ? data_rdata_way[5] :\n                          data_hit_way[6] ? data_rdata_way[6] :\n                          data_hit_way[7] ? data_rdata_way[7] :\n                                     {CACHE_LINE_WIDTH{1'd1}} ;  \n                           \nend\nendgenerate\n",
        "    always @ ( posedge i_clk )\n        if ( c_state == CS_IDLE )\n            valid_bits_r <= {tag_rdata_way[7][TAG_WIDTH-1], \n                             tag_rdata_way[6][TAG_WIDTH-1], \n                             tag_rdata_way[5][TAG_WIDTH-1], \n                             tag_rdata_way[4][TAG_WIDTH-1], \n                             tag_rdata_way[3][TAG_WIDTH-1], \n                             tag_rdata_way[2][TAG_WIDTH-1], \n                             tag_rdata_way[1][TAG_WIDTH-1], \n                             tag_rdata_way[0][TAG_WIDTH-1]};\n                           \nend",
        "    always @ ( posedge i_clk )\n        if ( c_state == CS_IDLE )\n            valid_bits_r <= {tag_rdata_way[3][TAG_WIDTH-1], \n                             tag_rdata_way[2][TAG_WIDTH-1], \n                             tag_rdata_way[1][TAG_WIDTH-1], \n                             tag_rdata_way[0][TAG_WIDTH-1]};\n                           \nend",
        "else if ( WAYS == 4 ) begin : valid_bits_4ways\n",
        "    always @ ( posedge i_clk )\n        if ( c_state == CS_IDLE )\n            valid_bits_r <= {tag_rdata_way[2][TAG_WIDTH-1], \n                             tag_rdata_way[1][TAG_WIDTH-1], \n                             tag_rdata_way[0][TAG_WIDTH-1]};\n                           \nend",
        "else if ( WAYS == 3 ) begin : valid_bits_3ways",
        "    always @ ( posedge i_clk )\n        if ( c_state == CS_IDLE )\n            valid_bits_r <= {tag_rdata_way[1][TAG_WIDTH-1], \n                             tag_rdata_way[0][TAG_WIDTH-1]};\n                           \nend",
        "generate\nif ( WAYS == 2 ) begin : valid_bits_2ways\n",
        "        assign data_hit_way[i]     = tag_rdata_way[i][TAG_WIDTH-1] &&                                                  \n                                     tag_rdata_way[i][TAG_ADDR_WIDTH-1:0] == i_address[31:TAG_ADDR32_LSB] &&  \n                                     c_state == CS_IDLE;                                                               ",
        "        \n        assign data_wenable_way[i] = (source_sel[C_FILL] && select_way[i]) || \n                                     (write_hit && data_hit_way[i] && c_state == CS_IDLE) ||\n                                     (consecutive_write && data_hit_way_r[i]);",
        "        assign tag_wenable_way[i]  = tag_wenable && ( select_way[i] || source_sel[C_INIT] );",
        "generate\n    for ( i=0; i<WAYS;i=i+1 ) begin : rams\n\n        \n        `ifdef XILINX_SPARTAN6_FPGA\n        xs6_sram_256x21_line_en\n        `endif\n\n        `ifdef XILINX_VIRTEX6_FPGA\n        xv6_sram_256x21_line_en\n        `endif\n\n        `ifndef XILINX_FPGA\n        generic_sram_line_en \n        `endif\n\n            #(\n            .DATA_WIDTH                 ( TAG_WIDTH             ),\n            .INITIALIZE_TO_ZERO         ( 1                     ),\n            .ADDRESS_WIDTH              ( CACHE_ADDR_WIDTH      ))\n        u_tag (\n            .i_clk                      ( i_clk                 ),\n            .i_write_data               ( tag_wdata             ),\n            .i_write_enable             ( tag_wenable_way[i]    ),\n            .i_address                  ( tag_address           ),\n\n            .o_read_data                ( tag_rdata_way[i]      )\n            );\n            \n        \n        `ifdef XILINX_SPARTAN6_FPGA\n        xs6_sram_256x128_byte_en\n        `endif\n\n        `ifdef XILINX_VIRTEX6_FPGA\n        xv6_sram_256x128_byte_en\n        `endif\n\n        `ifndef XILINX_FPGA\n        generic_sram_byte_en\n        `endif\n\n            #(\n            .DATA_WIDTH    ( CACHE_LINE_WIDTH) ,\n            .ADDRESS_WIDTH ( CACHE_ADDR_WIDTH) )\n        u_data (\n            .i_clk                      ( i_clk                         ),\n            .i_write_data               ( data_wdata                    ),\n            .i_write_enable             ( data_wenable_way[i]           ),\n            .i_address                  ( data_address                  ),\n            .i_byte_enable              ( {CACHE_LINE_WIDTH/8{1'd1}}    ),\n            .o_read_data                ( data_rdata_way[i]             )\n            );                                                     \n\n\n        \n        assign tag_wenable_way[i]  = tag_wenable && ( select_way[i] || source_sel[C_INIT] );\n\n        \n        assign data_wenable_way[i] = (source_sel[C_FILL] && select_way[i]) || \n                                     (write_hit && data_hit_way[i] && c_state == CS_IDLE) ||\n                                     (consecutive_write && data_hit_way_r[i]);\n        \n        assign data_hit_way[i]     = tag_rdata_way[i][TAG_WIDTH-1] &&                                                  \n                                     tag_rdata_way[i][TAG_ADDR_WIDTH-1:0] == i_address[31:TAG_ADDR32_LSB] &&  \n                                     c_state == CS_IDLE;                                                               \n    end                                                         \nendgenerate",
        "assign write_state      = c_state == CS_IDLE || c_state == CS_WRITE_HIT ||  \n                          c_state == CS_WRITE_HIT_WAIT_WB ||  c_state == CS_WRITE_MISS_WAIT_WB;\n                          \nassign write_stall      = (write_miss && !(i_wb_cached_ready && write_state)) || (write_hit && !i_wb_cached_ready);\n\nassign read_stall       = request_hold && !idle_hit && !rbuf_hit && !wb_hit && !i_write_enable;\n\nassign cache_busy_stall = c_state == CS_FILL_COMPLETE || c_state == CS_TURN_AROUND || c_state == CS_INIT ||\n                          (fill_state && !rbuf_hit && !wb_hit) ||\n                          (c_state == CS_WRITE_HIT && !consecutive_write);",
        "assign ex_read_cache_busy = exclusive_access && !i_write_enable && c_state != CS_IDLE;",
        "\n                          \nassign ex_read_hit      = exclusive_access && !i_write_enable && idle_hit;",
        "assign write_miss       = request_hold &&  i_write_enable && !idle_hit && !consecutive_write;",
        "assign idle_hit         = |data_hit_way;\n\nassign write_hit        = request_hold &&  i_write_enable && idle_hit;",
        "assign request_pulse    = i_request && i_cache_enable;\n\nassign exclusive_access = i_exclusive && i_cache_enable;",
        "assign tag_wenable      = source_sel[C_INVA] ? 1'd1  :\n                          source_sel[C_FILL] ? 1'd1  :\n                          source_sel[C_INIT] ? 1'd1  :\n                          source_sel[C_CORE] ? 1'd0  :\n                                               1'd0  ;",
        "assign write_data_word  = i_byte_enable == 4'b0001 ? { o_read_data[31: 8], i_write_data[ 7: 0]                   } :\n                          i_byte_enable == 4'b0010 ? { o_read_data[31:16], i_write_data[15: 8], o_read_data[ 7:0]} :\n                          i_byte_enable == 4'b0100 ? { o_read_data[31:24], i_write_data[23:16], o_read_data[15:0]} :\n                          i_byte_enable == 4'b1000 ? {                     i_write_data[31:24], o_read_data[23:0]} :\n                          i_byte_enable == 4'b0011 ? { o_read_data[31:16], i_write_data[15: 0]                   } :\n                          i_byte_enable == 4'b1100 ? {                     i_write_data[31:16], o_read_data[15:0]} :\n                                                     i_write_data                                                  ;",
        "assign con_write_data_word  = \n                          i_byte_enable == 4'b0001 ? { con_read_data_word[31: 8], i_write_data[ 7: 0]                          } :\n                          i_byte_enable == 4'b0010 ? { con_read_data_word[31:16], i_write_data[15: 8], con_read_data_word[ 7:0]} :\n                          i_byte_enable == 4'b0100 ? { con_read_data_word[31:24], i_write_data[23:16], con_read_data_word[15:0]} :\n                          i_byte_enable == 4'b1000 ? {                            i_write_data[31:24], con_read_data_word[23:0]} :\n                          i_byte_enable == 4'b0011 ? { con_read_data_word[31:16], i_write_data[15: 0]                          } :\n                          i_byte_enable == 4'b1100 ? {                            i_write_data[31:16], con_read_data_word[15:0]} :\n                                                                   i_write_data                                                  ;",
        "assign con_read_data_word = \n                          i_address[3:2] == 2'd0 ? data_wdata_r[ 31:  0] :\n                          i_address[3:2] == 2'd1 ? data_wdata_r[ 63: 32] : \n                          i_address[3:2] == 2'd2 ? data_wdata_r[ 95: 64] : \n                                                   data_wdata_r[127: 96] ;",
        "assign consecutive_write_wdata = \n                          i_address[3:2] == 2'd0 ? {data_wdata_r[127:32], con_write_data_word                           } :\n                          i_address[3:2] == 2'd1 ? {data_wdata_r[127:64], con_write_data_word, data_wdata_r[31:0]  } :\n                          i_address[3:2] == 2'd2 ? {data_wdata_r[127:96], con_write_data_word, data_wdata_r[63:0]  } :\n                                                   {                      con_write_data_word, data_wdata_r[95:0]  } ;",
        "assign read_miss_wdata  = wb_rdata_burst;\n\n\nassign write_hit_wdata  = i_address[3:2] == 2'd0 ? {hit_rdata[127:32], write_data_word                   } :\n                          i_address[3:2] == 2'd1 ? {hit_rdata[127:64], write_data_word, hit_rdata[31:0]  } :\n                          i_address[3:2] == 2'd2 ? {hit_rdata[127:96], write_data_word, hit_rdata[63:0]  } :\n                                                   {                   write_data_word, hit_rdata[95:0]  } ;",
        "    \nassign data_wdata       = write_hit && c_state == CS_IDLE ? write_hit_wdata : \n                          consecutive_write               ? consecutive_write_wdata :\n                                                            read_miss_wdata ;",
        "assign tag_wdata        = source_sel[C_FILL] ? {1'd1, miss_address[31:TAG_ADDR32_LSB]} :\n                                               {TAG_WIDTH{1'd0}}                       ;\n",
        "assign data_address     = consecutive_write  ? miss_address[CACHE_ADDR32_MSB:CACHE_ADDR32_LSB] : \n                          write_hit          ? i_address   [CACHE_ADDR32_MSB:CACHE_ADDR32_LSB] :\n                          source_sel[C_FILL] ? miss_address[CACHE_ADDR32_MSB:CACHE_ADDR32_LSB] : \n                          source_sel[C_CORE] ? address                                         :\n                                               {CACHE_ADDR_WIDTH{1'd0}}                        ;",
        "assign tag_address      = source_sel[C_FILL] ? miss_address      [CACHE_ADDR32_MSB:CACHE_ADDR32_LSB] :\n                          source_sel[C_INVA] ? ex_read_address                                       :\n                          source_sel[C_INIT] ? init_count[CACHE_ADDR_WIDTH-1:0]                      :\n                          source_sel[C_CORE] ? address                                               :\n                                               {CACHE_ADDR_WIDTH{1'd0}}                              ;",
        "always @ (posedge i_clk)\n    if ( ex_read_hit )\n        ex_read_address <= i_address[CACHE_ADDR32_MSB:CACHE_ADDR32_LSB];",
        "always @ ( posedge i_clk )\n    if ( ex_read_hit_clear )\n        begin\n        ex_read_hit_r   <= 1'd0;\n        ex_read_hit_way <= 'd0;\n        end\n    else if ( ex_read_hit )\n        begin\n        \n        `ifdef A25_CACHE_DEBUG\n            `TB_DEBUG_MESSAGE\n            $display (\"Exclusive access cache hit address 0x%08h\", i_address);\n        `endif\n        \n        ex_read_hit_r   <= 1'd1;\n        ex_read_hit_way <= data_hit_way;\n        end",
        "assign ex_read_hit_clear = c_state == CS_EX_DELETE;",
        "assign request_hold = request_pulse || request_r;",
        "always @(posedge i_clk)\n    request_r <= (request_pulse || request_r) && o_stall;\n",
        "assign wb_hit           = i_address == wb_address && i_wb_cached_ready && fill_state;",
        "assign fill_state       = c_state == CS_FILL ;",
        "always @(posedge i_clk)\n    if ( o_wb_cached_req )\n        wb_address <= i_address;\n    else if ( i_wb_cached_ready && fill_state )    \n        wb_address <= {wb_address[31:4], wb_address[3:2] + 1'd1, 2'd0};\n        ",
        "assign consecutive_write = miss_address[31:4] == i_address[31:4] && \n                           i_write_enable && \n                           c_state == CS_WRITE_HIT && \n                           request_pulse;",
        "always @ ( posedge i_clk )\n    if ( write_hit || consecutive_write )\n        begin\n        data_wdata_r   <= data_wdata;\n        end",
        "always @ ( posedge i_clk )\n    if ( write_hit )\n        begin\n        data_hit_way_r      <= data_hit_way;\n        end",
        "always @ ( posedge i_clk )\n    if ( o_wb_cached_req || write_hit )\n        miss_address <= i_address;\n",
        "always @ ( posedge i_clk )\n    if ( i_wb_cached_ready )\n        wb_rdata_burst <= i_wb_cached_rdata;\n\n        \n\n\n\n",
        "always @ ( posedge i_clk )\n    if ( i_cache_flush )\n        begin\n        c_state     <= CS_INIT;\n        source_sel  <= 1'd1 << C_INIT;\n        init_count  <= 'd0;\n        `ifdef A25_CACHE_DEBUG  \n        `TB_DEBUG_MESSAGE  \n        $display(\"Cache Flush\");\n        `endif            \n        end\n    else    \n        case ( c_state )\n            CS_INIT :\n                if ( init_count < CACHE_LINES [CACHE_ADDR_WIDTH:0] )\n                    begin\n                    init_count  <= init_count + 1'd1;\n                    source_sel  <= 1'd1 << C_INIT;\n                    end\n                else\n                    begin\n                    source_sel  <= 1'd1 << C_CORE;\n                    c_state     <= CS_TURN_AROUND;\n                    end \n                       \n             CS_IDLE :\n                begin\n                source_sel  <= 1'd1 << C_CORE;\n                \n                if ( ex_read_hit || ex_read_hit_r )\n                    begin\n                    select_way  <= data_hit_way | ex_read_hit_way;\n                    c_state     <= CS_EX_DELETE;        \n                    source_sel  <= 1'd1 << C_INVA;\n                    end\n                else if ( read_miss ) \n                    c_state <= CS_FILL; \n                else if ( write_hit )\n                    begin\n                    if ( i_wb_cached_ready )\n                        c_state <= CS_WRITE_HIT;        \n                    else    \n                        c_state <= CS_WRITE_HIT_WAIT_WB;        \n                    end    \n                else if ( write_miss && !i_wb_cached_ready )\n                        c_state <= CS_WRITE_MISS_WAIT_WB;        \n                end\n                   \n                                   \n             CS_FILL :\n                \n                \n                if ( i_wb_cached_ready ) \n                    begin\n                    c_state     <= CS_FILL_COMPLETE;\n                    source_sel  <= 1'd1 << C_FILL;\n                \n                    \n                    \n                    \n                    \n                    select_way  <= next_way; \n                    random_num  <= {random_num[2], random_num[1], random_num[0], \n                                     random_num[3]^random_num[2]};\n                    end\n\n\n             \n             CS_FILL_COMPLETE : \n                begin\n                \n                \n                \n                \n                source_sel  <= 1'd1 << C_CORE;              \n                c_state     <= CS_TURN_AROUND;    \n                end                                 \n                                                        \n\n             \n             \n             CS_TURN_AROUND : \n                begin\n                c_state     <= CS_IDLE;\n                end\n                \n\n             \n             CS_EX_DELETE:       \n                begin\n                `ifdef A25_CACHE_DEBUG    \n                `TB_DEBUG_MESSAGE\n                $display(\"Cache deleted Locked entry\");\n                `endif    \n                c_state    <= CS_TURN_AROUND;\n                source_sel <= 1'd1 << C_CORE;\n                end\n                \n                                 \n             CS_WRITE_HIT:\n                if ( !consecutive_write )           \n                    c_state     <= CS_IDLE;\n\n\n             CS_WRITE_HIT_WAIT_WB:\n                \n                if ( i_wb_cached_ready ) \n                    c_state     <= CS_IDLE;\n\n\n             CS_WRITE_MISS_WAIT_WB:\n                \n                if ( i_wb_cached_ready ) \n                    c_state     <= CS_IDLE;\n                    \n        endcase                       "
    ]
}