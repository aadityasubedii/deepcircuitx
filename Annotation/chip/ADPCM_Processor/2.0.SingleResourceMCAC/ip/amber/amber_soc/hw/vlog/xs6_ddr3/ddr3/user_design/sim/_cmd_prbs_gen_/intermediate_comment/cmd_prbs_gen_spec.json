{
    "spec": "Module name: cmd_prbs_gen. \n\nModule specification: The cmd_prbs_gen is a Pseudo-Random Bit Sequence (PRBS) generator module used for generating pseudo-random sequences of data primarily in test scenarios. This module declares parameters such as TCQ (propagation delay), FAMILY (device family such as SPARTAN6), and PRBS_CMD (type of PRBS command). \n\nThis module has four input ports: clk_i, prbs_seed_init, clk_en, and prbs_seed_i. clk_i is the clock input, synchronizing the execution of sequential logic in the module. prbs_seed_init is a control signal input used to initialize or reset the pseudo-random bit sequence (PRBS) to a known state. clk_en is the clock enable signal deciding if the internal state of the PRBS generator should be updated or not. prbs_seed_i is the seed input for beginning the PRBS. \n\nAn output port, prbs_o, is implemented to provide the calculated PRBS that can be utilized by other modules or entities.\n\nThree internal signals are declared; ZEROS, prbs, and lfsr_q. ZEROS signal generates a zero sequence used when the output bit width is smaller than the SEED_WIDTH for different PRBS commands. The prbs register holds the PRBS derived from the lfsr_q signal. lfsr_q is implemented as a linear feedback shift register in the PRBS generator, continuously updated based on the pseudo-random sequence generation algorithm.\n\nThe module's main features include the generation of 64 bit, 32 bit, or 20 bit PRBS based on PRBS_CMD and PRBS_WIDTH, the possibility of initializing the PRBS with a seed from outside the module, and the ability to emulate different test scenarios for ADDRESSES and INSTRUCTIONS. It includes different conditions for different FPGA families. The internal code is divided into different blocks, each generating a PRBS of unique width and are conditionally compiled based on the PRBS_CMD and PRBS_WIDTH parameters. The final code block assigns the PRBS to the output.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: cmd_prbs_gen. \nExplanation: This is a Pseudo-Random Bit Sequence (PRBS) generator module used primarily for generating pseudo-random sequences of data in test situations. Various parameters are declared, including TCQ (propagation delay), FAMILY (device family such as SPARTAN6), and PRBS_CMD (type of PRBS command). The module generates a pseudo-random sequence (prbs) of width SEED_WIDTH based on the linear feedback shift register (lfsr_q). The module allows various PRBS sequence widths: 64 bit, 32 bit, or 20 bit based on the parameters PRBS_CMD and PRBS_WIDTH.  The starting seed for the PRBS can be fed externally. The module also takes commands that drive the output sequence to emulate different test scenarios for ADDRESSES and INSTRUCTIONS (INSTR). Different conditions are written for different FPGA families (e.g., SPARTAN6)."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:  \n1. clk_i: This is the clock input of the module. It is used to synchronize the execution of the sequential logic written in the module.\n2. prbs_seed_init: This is a control signal input to initialize or reset the PRBS sequence to a known state (mentioned by the seed).\n3. clk_en: This is the clock enable signal which is used to decide whether the internal state of the PRBS generator (lfsr_q) should be updated or not.\n4. prbs_seed_i: This is the input pseudo-random bit sequence seed. It initializes or resets the pseudo-random bit sequence to a known state.\n\nOutput ports:\n1. prbs_o: This is the output pseudo-random bit sequence (PRBS). It provides the calculated pseudo-random sequences that can be used by other modules or entities."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: \n1. ZEROS\n2. prbs\n3. lfsr_q\n\nExplanation: \n1. ZEROS: This signal generates a zero sequence of length equal to ADDR_WIDTH. It is used as part of the undersized PRBS generator when PRBS_CMD is set to \"INSTR\" or \"BLEN\", as the output bit width is smaller than the SEED_WIDTH.\n2. prbs: This register holds the pseudo-random bit sequence, which is derived from the lfsr_q signal. This signal forms the output of the PRBS generator.\n3. lfsr_q: This signal is used for implementing a linear feedback shift register in the PRBS generator. It keeps shifting its values based on the PRBS command and the ticks of the clock. It is initialized with a seed 'prbs_seed_i' and then continuously updated based on the pseudo-random sequence generation algorithm, governed by the bit length PRBS_WIDTH and PRBS_CMD."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule cmd_prbs_gen #\n  (\n   parameter TCQ           = 100,\n   parameter FAMILY     = \"SPARTAN6\",\n   parameter ADDR_WIDTH = 29,\n   parameter DWIDTH     = 32,\n   parameter PRBS_CMD   = \"ADDRESS\", \n   parameter PRBS_WIDTH = 64,          \n   parameter SEED_WIDTH = 32,           \n\n   parameter PRBS_EADDR_MASK_POS = 32'hFFFFD000,\n   parameter PRBS_SADDR_MASK_POS =  32'h00002000,\n   parameter PRBS_EADDR  = 32'h00002000,\n   parameter PRBS_SADDR  = 32'h00002000\n   )\n  (\n   input         clk_i,\n   input         prbs_seed_init,  \n   input         clk_en,\n   input [SEED_WIDTH-1:0]  prbs_seed_i,\n\n   output[SEED_WIDTH-1:0]  prbs_o     \n  );\n\nwire[ADDR_WIDTH - 1:0] ZEROS;\nreg [SEED_WIDTH - 1:0] prbs;\nreg [PRBS_WIDTH :1] lfsr_q;\n\nassign ZEROS = 'b0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 64) begin :gen64_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {31'b0,prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[64] <= #TCQ lfsr_q[64] ^ lfsr_q[63];\n        lfsr_q[63] <= #TCQ lfsr_q[62];\n        lfsr_q[62] <= #TCQ lfsr_q[64] ^ lfsr_q[61];\n        lfsr_q[61] <= #TCQ lfsr_q[64] ^ lfsr_q[60];\n        lfsr_q[60:2] <= #TCQ lfsr_q[59:1];\n        lfsr_q[1] <= #TCQ lfsr_q[64];\n      end\n    end\n\n    always @(lfsr_q[32:1]) begin\n      prbs = lfsr_q[32:1];\n    end\n  end\nendgenerate\n\nfunction integer logb2;\n  input [31:0] in;\n  integer i;\n  begin\n    i = in;\n      for(logb2=1; i>0; logb2=logb2+1)\n        i = i >> 1;\n  end\nendfunction\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 32) begin :gen32_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin \n        lfsr_q <= #TCQ {prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[32:9] <= #TCQ lfsr_q[31:8];\n        lfsr_q[8]    <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n        lfsr_q[7]    <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n        lfsr_q[6:4]  <= #TCQ lfsr_q[5:3];\n\n        lfsr_q[3]    <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n        lfsr_q[2]    <= #TCQ lfsr_q[1] ;\n        lfsr_q[1]    <= #TCQ lfsr_q[32];\n      end\n    end\n\n    integer i;\n    always @(lfsr_q[32:1]) begin\n    \n     if (FAMILY == \"SPARTAN6\" ) begin  \n    \n      for(i = logb2(DWIDTH) + 1; i <= SEED_WIDTH - 1; i = i + 1)\n\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n          \n       prbs[logb2(DWIDTH )  :0] = {logb2(DWIDTH ) + 1{1'b0}};         \n\n      end\n    else begin\n     for(i = logb2(DWIDTH)-4; i <= SEED_WIDTH - 1; i = i + 1)\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n     prbs[logb2(DWIDTH)-5:0] = {logb2(DWIDTH) - 4{1'b0}};\n\n    end  \n \n  end  \nend endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenerate\n  if(PRBS_CMD == \"INSTR\" | PRBS_CMD == \"BLEN\") begin :gen20_taps\n    always @(posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {5'b0,prbs_seed_i[14:0]};\n      end else if(clk_en) begin\n        lfsr_q[20]   <= #TCQ lfsr_q[19];\n        lfsr_q[19]   <= #TCQ lfsr_q[18];\n\n        lfsr_q[18]   <= #TCQ lfsr_q[20] ^lfsr_q[17];\n\n        lfsr_q[17:2] <= #TCQ lfsr_q[16:1];\n        lfsr_q[1]    <= #TCQ lfsr_q[20];\n      end\n    end\n\n    always @ (lfsr_q[SEED_WIDTH - 1:1], ZEROS) begin\n        prbs = {ZEROS[SEED_WIDTH - 1:7],lfsr_q[6:1]};\n    end\n  end\nendgenerate\n\nassign prbs_o = prbs;\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: cmd_prbs_gen. \n\nModule specification: The cmd_prbs_gen is a Pseudo-Random Bit Sequence (PRBS) generator module used for generating pseudo-random sequences of data primarily in test scenarios. This module declares parameters such as TCQ (propagation delay), FAMILY (device family such as SPARTAN6), and PRBS_CMD (type of PRBS command). \n\nThis module has four input ports: clk_i, prbs_seed_init, clk_en, and prbs_seed_i. clk_i is the clock input, synchronizing the execution of sequential logic in the module. prbs_seed_init is a control signal input used to initialize or reset the pseudo-random bit sequence (PRBS) to a known state. clk_en is the clock enable signal deciding if the internal state of the PRBS generator should be updated or not. prbs_seed_i is the seed input for beginning the PRBS. \n\nAn output port, prbs_o, is implemented to provide the calculated PRBS that can be utilized by other modules or entities.\n\nThree internal signals are declared; ZEROS, prbs, and lfsr_q. ZEROS signal generates a zero sequence used when the output bit width is smaller than the SEED_WIDTH for different PRBS commands. The prbs register holds the PRBS derived from the lfsr_q signal. lfsr_q is implemented as a linear feedback shift register in the PRBS generator, continuously updated based on the pseudo-random sequence generation algorithm.\n\nThe module's main features include the generation of 64 bit, 32 bit, or 20 bit PRBS based on PRBS_CMD and PRBS_WIDTH, the possibility of initializing the PRBS with a seed from outside the module, and the ability to emulate different test scenarios for ADDRESSES and INSTRUCTIONS. It includes different conditions for different FPGA families. The internal code is divided into different blocks, each generating a PRBS of unique width and are conditionally compiled based on the PRBS_CMD and PRBS_WIDTH parameters. The final code block assigns the PRBS to the output."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: cmd_prbs_gen. \nExplanation: This is a Pseudo-Random Bit Sequence (PRBS) generator module used primarily for generating pseudo-random sequences of data in test situations. Various parameters are declared, including TCQ (propagation delay), FAMILY (device family such as SPARTAN6), and PRBS_CMD (type of PRBS command). The module generates a pseudo-random sequence (prbs) of width SEED_WIDTH based on the linear feedback shift register (lfsr_q). The module allows various PRBS sequence widths: 64 bit, 32 bit, or 20 bit based on the parameters PRBS_CMD and PRBS_WIDTH.  The starting seed for the PRBS can be fed externally. The module also takes commands that drive the output sequence to emulate different test scenarios for ADDRESSES and INSTRUCTIONS (INSTR). Different conditions are written for different FPGA families (e.g., SPARTAN6)."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:  \n1. clk_i: This is the clock input of the module. It is used to synchronize the execution of the sequential logic written in the module.\n2. prbs_seed_init: This is a control signal input to initialize or reset the PRBS sequence to a known state (mentioned by the seed).\n3. clk_en: This is the clock enable signal which is used to decide whether the internal state of the PRBS generator (lfsr_q) should be updated or not.\n4. prbs_seed_i: This is the input pseudo-random bit sequence seed. It initializes or resets the pseudo-random bit sequence to a known state.\n\nOutput ports:\n1. prbs_o: This is the output pseudo-random bit sequence (PRBS). It provides the calculated pseudo-random sequences that can be used by other modules or entities."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: \n1. ZEROS\n2. prbs\n3. lfsr_q\n\nExplanation: \n1. ZEROS: This signal generates a zero sequence of length equal to ADDR_WIDTH. It is used as part of the undersized PRBS generator when PRBS_CMD is set to \"INSTR\" or \"BLEN\", as the output bit width is smaller than the SEED_WIDTH.\n2. prbs: This register holds the pseudo-random bit sequence, which is derived from the lfsr_q signal. This signal forms the output of the PRBS generator.\n3. lfsr_q: This signal is used for implementing a linear feedback shift register in the PRBS generator. It keeps shifting its values based on the PRBS command and the ticks of the clock. It is initialized with a seed 'prbs_seed_i' and then continuously updated based on the pseudo-random sequence generation algorithm, governed by the bit length PRBS_WIDTH and PRBS_CMD."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule cmd_prbs_gen #\n  (\n   parameter TCQ           = 100,\n   parameter FAMILY     = \"SPARTAN6\",\n   parameter ADDR_WIDTH = 29,\n   parameter DWIDTH     = 32,\n   parameter PRBS_CMD   = \"ADDRESS\", \n   parameter PRBS_WIDTH = 64,          \n   parameter SEED_WIDTH = 32,           \n\n   parameter PRBS_EADDR_MASK_POS = 32'hFFFFD000,\n   parameter PRBS_SADDR_MASK_POS =  32'h00002000,\n   parameter PRBS_EADDR  = 32'h00002000,\n   parameter PRBS_SADDR  = 32'h00002000\n   )\n  (\n   input         clk_i,\n   input         prbs_seed_init,  \n   input         clk_en,\n   input [SEED_WIDTH-1:0]  prbs_seed_i,\n\n   output[SEED_WIDTH-1:0]  prbs_o     \n  );\n\nwire[ADDR_WIDTH - 1:0] ZEROS;\nreg [SEED_WIDTH - 1:0] prbs;\nreg [PRBS_WIDTH :1] lfsr_q;\n\nassign ZEROS = 'b0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 64) begin :gen64_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {31'b0,prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[64] <= #TCQ lfsr_q[64] ^ lfsr_q[63];\n        lfsr_q[63] <= #TCQ lfsr_q[62];\n        lfsr_q[62] <= #TCQ lfsr_q[64] ^ lfsr_q[61];\n        lfsr_q[61] <= #TCQ lfsr_q[64] ^ lfsr_q[60];\n        lfsr_q[60:2] <= #TCQ lfsr_q[59:1];\n        lfsr_q[1] <= #TCQ lfsr_q[64];\n      end\n    end\n\n    always @(lfsr_q[32:1]) begin\n      prbs = lfsr_q[32:1];\n    end\n  end\nendgenerate\n\nfunction integer logb2;\n  input [31:0] in;\n  integer i;\n  begin\n    i = in;\n      for(logb2=1; i>0; logb2=logb2+1)\n        i = i >> 1;\n  end\nendfunction\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 32) begin :gen32_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin \n        lfsr_q <= #TCQ {prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[32:9] <= #TCQ lfsr_q[31:8];\n        lfsr_q[8]    <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n        lfsr_q[7]    <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n        lfsr_q[6:4]  <= #TCQ lfsr_q[5:3];\n\n        lfsr_q[3]    <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n        lfsr_q[2]    <= #TCQ lfsr_q[1] ;\n        lfsr_q[1]    <= #TCQ lfsr_q[32];\n      end\n    end\n\n    integer i;\n    always @(lfsr_q[32:1]) begin\n    \n     if (FAMILY == \"SPARTAN6\" ) begin  \n    \n      for(i = logb2(DWIDTH) + 1; i <= SEED_WIDTH - 1; i = i + 1)\n\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n          \n       prbs[logb2(DWIDTH )  :0] = {logb2(DWIDTH ) + 1{1'b0}};         \n\n      end\n    else begin\n     for(i = logb2(DWIDTH)-4; i <= SEED_WIDTH - 1; i = i + 1)\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n     prbs[logb2(DWIDTH)-5:0] = {logb2(DWIDTH) - 4{1'b0}};\n\n    end  \n \n  end  \nend endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenerate\n  if(PRBS_CMD == \"INSTR\" | PRBS_CMD == \"BLEN\") begin :gen20_taps\n    always @(posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {5'b0,prbs_seed_i[14:0]};\n      end else if(clk_en) begin\n        lfsr_q[20]   <= #TCQ lfsr_q[19];\n        lfsr_q[19]   <= #TCQ lfsr_q[18];\n\n        lfsr_q[18]   <= #TCQ lfsr_q[20] ^lfsr_q[17];\n\n        lfsr_q[17:2] <= #TCQ lfsr_q[16:1];\n        lfsr_q[1]    <= #TCQ lfsr_q[20];\n      end\n    end\n\n    always @ (lfsr_q[SEED_WIDTH - 1:1], ZEROS) begin\n        prbs = {ZEROS[SEED_WIDTH - 1:7],lfsr_q[6:1]};\n    end\n  end\nendgenerate\n\nassign prbs_o = prbs;\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: cmd_prbs_gen. \n\nModule specification: The cmd_prbs_gen is a Pseudo-Random Bit Sequence (PRBS) generator module used for generating pseudo-random sequences of data primarily in test scenarios. This module declares parameters such as TCQ (propagation delay), FAMILY (device family such as SPARTAN6), and PRBS_CMD (type of PRBS command). \n\nThis module has four input ports: clk_i, prbs_seed_init, clk_en, and prbs_seed_i. clk_i is the clock input, synchronizing the execution of sequential logic in the module. prbs_seed_init is a control signal input used to initialize or reset the pseudo-random bit sequence (PRBS) to a known state. clk_en is the clock enable signal deciding if the internal state of the PRBS generator should be updated or not. prbs_seed_i is the seed input for beginning the PRBS. \n\nAn output port, prbs_o, is implemented to provide the calculated PRBS that can be utilized by other modules or entities.\n\nThree internal signals are declared; ZEROS, prbs, and lfsr_q. ZEROS signal generates a zero sequence used when the output bit width is smaller than the SEED_WIDTH for different PRBS commands. The prbs register holds the PRBS derived from the lfsr_q signal. lfsr_q is implemented as a linear feedback shift register in the PRBS generator, continuously updated based on the pseudo-random sequence generation algorithm.\n\nThe module's main features include the generation of 64 bit, 32 bit, or 20 bit PRBS based on PRBS_CMD and PRBS_WIDTH, the possibility of initializing the PRBS with a seed from outside the module, and the ability to emulate different test scenarios for ADDRESSES and INSTRUCTIONS. It includes different conditions for different FPGA families. The internal code is divided into different blocks, each generating a PRBS of unique width and are conditionally compiled based on the PRBS_CMD and PRBS_WIDTH parameters. The final code block assigns the PRBS to the output."
                }
            ]
        }
    ]
}