{
    "line_num": [
        [
            632,
            641
        ],
        [
            550,
            629
        ],
        [
            546,
            546
        ],
        [
            411,
            543
        ],
        [
            340,
            404
        ],
        [
            321,
            321
        ],
        [
            313,
            318
        ],
        [
            311,
            311
        ],
        [
            310,
            310
        ],
        [
            174,
            306
        ],
        [
            163,
            168
        ]
    ],
    "blocks": [
        "function [7:0] rmem;\ninput        tx;   \ninput [31:0] addr;\nbegin\n    if (tx)\n        rmem = mem[addr+3];\n    else\n        rmem = rxm[addr];\nend\nendfunction",
        "task print_pkt;\ninput        tx;   \ninput [31:0] start;\nreg   [15:0] eth_type;\nreg   [7:0]  proto;\nreg   [31:0] frame;\nreg   [3:0]  ip_hdr_len;\nreg   [15:0] ip_len;\nreg   [3:0]  tcp_hdr_len;\nreg   [15:0] tcp_bdy_len;\nreg   [7:0]  tmp;\nreg   [15:0] arp_op;\n\ninteger      i;\nbegin\n    frame = start;\n    \n    if (tx) $write(\"%6d pkt to   amber \", tb.clk_count);\n    else    $write(\"%6d pkt from amber \", tb.clk_count);\n    \n    $display(\"mac-dst %h:%h:%h:%h:%h:%h, mac-src %h:%h:%h:%h:%h:%h, type %h%h\", \n        rmem(tx,frame+0), rmem(tx,frame+1),rmem(tx,frame+2),rmem(tx,frame+3),rmem(tx,frame+4),rmem(tx,frame+5),\n        rmem(tx,frame+6), rmem(tx,frame+7),rmem(tx,frame+8),rmem(tx,frame+9),rmem(tx,frame+10),rmem(tx,frame+11),\n        rmem(tx,frame+12),rmem(tx,frame+13));\n        \n    eth_type = {rmem(tx,frame+12),rmem(tx,frame+13)};\n\n    if (eth_type == 16'h0806) \n        begin\n        frame       = frame + 14;\n        arp_op      = rmem(tx,frame+6) << 8 | rmem(tx,frame+7);\n        \n        $write(\"ARP operation %0d\", arp_op);\n      \n        if (arp_op == 16'd1)\n            $write(\" look for ip %0d.%0d.%0d.%0d\", \n                rmem(tx,frame+24), rmem(tx,frame+25),rmem(tx,frame+26),rmem(tx,frame+27));  \n        $write(\"\\n\");      \n        end\n    \n    if (eth_type == 16'h0800) \n        begin\n        frame       = frame + 14;\n        proto       = rmem(tx,frame+9);\n        tmp         = rmem(tx,frame+0);\n        ip_hdr_len  = tmp[3:0];\n        ip_len      = {rmem(tx,frame+2), rmem(tx,frame+3)};\n        \n        $display(\"   ip-dst %0d.%0d.%0d.%0d, ip-src %0d.%0d.%0d.%0d, proto %0d, ip_len %0d, ihl %0d\", \n            rmem(tx,frame+16), rmem(tx,frame+17),rmem(tx,frame+18),rmem(tx,frame+19),\n            rmem(tx,frame+12), rmem(tx,frame+13),rmem(tx,frame+14),rmem(tx,frame+15), \n            proto, ip_len, ip_hdr_len*4);\n        \n        if (proto == 8'd6) \n            begin\n            frame       = frame + ip_hdr_len*4;\n            tmp         = rmem(tx,frame+12);\n            tcp_hdr_len = tmp[7:4];\n            tcp_bdy_len = ip_len - ({ip_hdr_len,2'd0} + {tcp_hdr_len,2'd0});\n            \n            $display(\"   tcp-dst %0d, tcp-src %0d, tcp hdr len %0d, tcp bdy len %0d\", \n                {rmem(tx,frame+2), rmem(tx,frame+3)},\n                {rmem(tx,frame+0), rmem(tx,frame+1)}, tcp_hdr_len*4, tcp_bdy_len);\n            $display(\"   tcp-seq %0d, tcp-ack %0d\", \n                {rmem(tx,frame+4), rmem(tx,frame+5), rmem(tx,frame+6), rmem(tx,frame+7)},\n                {rmem(tx,frame+8), rmem(tx,frame+9), rmem(tx,frame+10), rmem(tx,frame+11)});\n                \n            if (tcp_bdy_len != 16'd0)\n                begin\n                for (i=0;i<tcp_bdy_len;i=i+1)\n                    if ((rmem(tx,frame+tcp_hdr_len*4+i) > 31 && rmem(tx,frame+tcp_hdr_len*4+i) < 128) ||\n                        (rmem(tx,frame+tcp_hdr_len*4+i) == \"\\n\"))\n                        $write(\"%c\",  rmem(tx,frame+tcp_hdr_len*4+i));\n                end\n                \n            end\n        end\n    $display(\"----\");\nend\nendtask",
        "assign md_io = md_state_r == MD_RDATA ? md_rdata_r[15] : 1'bz;",
        "always@(posedge mdc_i)\n    begin\n    case (md_state_r)\n    \n        MD_IDLE:\n            begin\n            md_count_r <= 'd0;\n            if (md_io == 1'd0)\n                md_state_r   <= MD_START0;\n            end\n            \n            \n        MD_START0:\n            begin\n            if (md_io == 1'd1)\n                md_state_r   <= MD_START1;\n            else\n                md_state_r   <= MD_IDLE;\n            end\n            \n            \n        MD_START1:\n            begin\n            if (md_io == 1'd1)\n                md_state_r  <= MD_READ0;\n            else\n                md_state_r  <= MD_WRITE0;\n            end\n            \n            \n       MD_READ0:\n            begin\n            if (md_io == 1'd0)\n                begin\n                md_state_r  <= MD_PHYADDR;\n                md_op_r     <= MDREAD;\n                end\n            else\n                md_state_r  <= MD_IDLE;\n            end \n            \n            \n       MD_WRITE0:\n            begin\n            if (md_io == 1'd1)\n                begin\n                md_state_r  <= MD_PHYADDR;\n                md_op_r     <= MDWRITE;\n                end\n            else\n                md_state_r  <= MD_IDLE;\n            end \n            \n        MD_PHYADDR:\n            begin\n            md_count_r      <= md_count_r + 1'd1;\n            md_phy_addr_r   <= {md_phy_addr_r[3:0], md_io};\n            \n            if (md_count_r == 5'd4)\n                begin\n                md_state_r  <= MD_REGADDR;\n                md_count_r  <= 'd0;                \n                end\n            end\n            \n        MD_REGADDR:\n            begin\n            md_count_r      <= md_count_r + 1'd1;\n            md_reg_addr_r   <= {md_reg_addr_r[3:0], md_io};\n            \n            if (md_count_r == 5'd4)\n                begin\n                md_count_r  <= 'd0;                \n                md_state_r  <= MD_TURN0;\n                end\n            end\n\n\n        MD_TURN0:\n            md_state_r  <= MD_TURN1;\n\n        MD_TURN1:\n            begin\n            if (md_op_r == MDREAD)\n                md_state_r  <= MD_RDATA;\n            else    \n                md_state_r  <= MD_WDATA;\n                \n            case (md_reg_addr_r)\n                MII_BMCR        : md_rdata_r <= md_bmcr_r;\n                MII_BMSR        : md_rdata_r <= 16'hfe04;\n                MII_CTRL1000    : md_rdata_r <= md_ctrl1000_r;\n                default         : md_rdata_r <= 'd0;   \n            endcase\n            end\n            \n            \n        MD_RDATA:\n            begin\n            md_count_r  <= md_count_r + 1'd1;\n            md_rdata_r  <= {md_rdata_r[14:0], 1'd0};\n            \n            if (md_count_r == 5'd15)\n                md_state_r  <= MD_IDLE;\n            \n            end\n\n\n        MD_WDATA:\n            begin\n            md_count_r  <= md_count_r + 1'd1;\n            md_wdata_r  <= {md_wdata_r[14:0], md_io};\n            \n            if (md_count_r == 5'd15)\n                begin\n                md_state_r  <= MD_WXFR;\n                md_count_r  <= 'd0;                \n                end\n            end\n\n\n        MD_WXFR:\n            begin\n            case (md_reg_addr_r)\n                MII_BMCR        : md_bmcr_r     <= md_wdata_r;\n                MII_CTRL1000    : md_ctrl1000_r <= md_wdata_r;\n            endcase\n            md_state_r  <= MD_IDLE;\n            end\n            \n            \n    endcase\n    end",
        "always@(posedge mtx_clk_i)\n    begin\n    case (rx_state_r)\n        RX_IDLE:\n            begin  \n            rx_line_r  <= 'd0;       \n            if (mrxdv_i)  \n                begin\n                rx_state_r   <= RX_PRE;\n                end\n            end\n                       \n        RX_PRE:\n            begin\n            if (mrxd_i == 4'hd)\n                rx_state_r   <= RX_0;\n            end\n                               \n        RX_0:  \n            begin\n            mrxd_r <= mrxd_i;\n            \n            if (mrxdv_i)\n                rx_state_r     <= RX_1;\n            else\n                rx_state_r     <= RX_DONE;\n            end\n            \n            \n        RX_1:  \n            begin\n            rxm[rx_line_r]      <= {mrxd_i, mrxd_r};\n            rx_line_r           <= rx_line_r + 1'd1;\n            \n            if (mrxdv_i)\n                rx_state_r     <= RX_0;\n            else\n                rx_state_r     <= RX_DONE;\n            end\n\n\n        RX_DONE: \n            begin\n            print_pkt(1'd0, 16'd0);  \n            rx_state_r     <= RX_IDLE;\n            \n                \n            pkt_from_amber_file     = $fopen(pkt_from_amber, \"w\");\n            $fwrite(pkt_from_amber_file, \"%02h\\n\", pkt_from_amber_num);\n            \n            for (x=0;x<rx_line_r;x=x+1)\n                $fwrite(pkt_from_amber_file, \"%02h\\n\", rxm[x]);\n            $fclose(pkt_from_amber_file);\n            \n            \n            if (pkt_from_amber_num == 8'd255)\n                pkt_from_amber_num  <= 8'd1; \n            else\n                pkt_from_amber_num  <=  pkt_from_amber_num + 1'd1; \n            end\n            \n            \n    endcase\n    end\n",
        "assign crc_dinx = {crc_din[0], crc_din[1], crc_din[2], crc_din[3]};",
        "always @*\n    begin\n        crc_din = state_r == TX_0 ? mem[line_r+3][3:0] : \n                  state_r == TX_1 ? mem[line_r+3][7:4] :\n                                   32'd0               ;\n    end",
        "assign enable  = state_r != CRC0;",
        "assign init    = state_r == PREB;",
        "always@(posedge mtx_clk_i)\n    begin\n    case (state_r)\n        IDLE:\n            begin\n            mtxd_o    <= 'd0;\n            mtxdv_o   <= 'd0;\n            mtxerr_o  <= 'd0;\n            wcount_r  <= 'd0;\n            \n            if (md_bmcr_r[9])  \n                begin\n                wcount_r  <= wcount_r + 1'd1;\n                if (wcount_r == 32'd10000)\n                    begin\n                    state_r   <= POLL;\n                    wcount_r  <= 'd0;\n                    $display(\"Start polling for packets to send to amber\");\n                    end\n                end\n            end\n\n        \n        \n        WAIT:\n            begin\n            wcount_r <= wcount_r + 1'd1;\n            if (wcount_r == 32'd100)\n                begin\n                wcount_r <= 'd0;\n                state_r  <= POLL;\n                end\n            end\n\n        \n        POLL: \n            begin\n            mtxd_o    <= 'd0;\n            mtxdv_o   <= 'd0;\n            mtxerr_o  <= 'd0;\n            \n            \n            pkt_to_amber_file               = $fopen(pkt_to_amber, \"r\");            \n            fgets_return                    = $fgets(line, pkt_to_amber_file);\n            pkt_to_amber_address = 0;\n            while (fgets_return)\n                begin\n                pkt_to_amber_data           = hex_chars_to_8bits (line[23:8]);\n                mem[pkt_to_amber_address]   = pkt_to_amber_data[7:0];\n                pkt_to_amber_address        = pkt_to_amber_address + 1;\n                fgets_return                = $fgets(line, pkt_to_amber_file);                \n                end\n            $fclose(pkt_to_amber_file);\n\n            \n            if (mem[0] != last_pkt_num_r) \n                begin\n                state_r         <= PREA;\n                pkt_len_r       <= {mem[1], mem[2]} + 16'd14;\n                last_pkt_num_r  <= mem[0];\n                line_r          <= 'd0;\n                pkt_pos_r       <= 'd0;\n                pcount_r        <= 'd0;\n                wcount_r        <= 'd0;\n    \n                pkt_to_amber_ack_file = $fopen(pkt_to_amber_ack, \"w\");\n                $fwrite(pkt_to_amber_ack_file, \"%d\\n\", mem[0]);\n                $fclose(pkt_to_amber_ack_file);\n                end\n            else begin\n                state_r   <= WAIT;\n                end\n                \n            end\n                        \n        \n        \n        PREA: \n            begin\n            mtxd_o    <= 4'b0101;\n            mtxdv_o   <= 1'd1;\n            pcount_r  <= pcount_r + 1'd1;\n            if (pcount_r == 4'd6)\n                begin\n                pcount_r  <= 'd0;\n                state_r   <= PREB;            \n                end\n            end\n            \n            \n        PREB:\n            begin\n            mtxd_o    <= 4'b1101;\n            mtxdv_o   <= 1'd1;\n            state_r   <= TX_0;\n            \n            print_pkt(1'd1, line_r);  \n            end \n            \n                           \n        TX_0:  \n            begin\n            mtxd_o    <= mem[line_r+3][3:0];\n            mtxdv_o   <= 1'd1;\n            state_r   <= TX_1;\n            end\n            \n            \n        TX_1:  \n            begin\n            mtxd_o    <= mem[line_r+3][7:4];\n            mtxdv_o   <= 1'd1;\n            line_r    <= line_r + 1'd1;\n            \n            if (pkt_pos_r + 1'd1 == pkt_len_r)\n                state_r     <= CRC0;\n            else\n                begin\n                state_r     <= TX_0;\n                pkt_pos_r   <= pkt_pos_r + 1'd1;\n                end\n            end\n\n                        \n        CRC0:\n            begin\n            mtxd_o    <= {~crc[28], ~crc[29], ~crc[30], ~crc[31]};\n            mtxdv_o   <= 1'd1;\n            state_r   <= POLL;\n            end\n            \n    endcase\n    end",
        "initial\n    begin\n    pkt_to_amber_ack_file = $fopen(pkt_to_amber_ack, \"w\");\n    $fwrite(pkt_to_amber_ack_file, \"0\\n\");\n    $fclose(pkt_to_amber_ack_file);\n    end"
    ]
}