{
    "line_num": [
        [
            1512,
            1539
        ],
        [
            1490,
            1509
        ],
        [
            1464,
            1468
        ],
        [
            1440,
            1462
        ],
        [
            1430,
            1432
        ],
        [
            1411,
            1426
        ],
        [
            1398,
            1410
        ],
        [
            1375,
            1377
        ],
        [
            1343,
            1356
        ],
        [
            1330,
            1342
        ],
        [
            1316,
            1329
        ],
        [
            1303,
            1315
        ],
        [
            1294,
            1301
        ],
        [
            1281,
            1291
        ],
        [
            1270,
            1277
        ],
        [
            1257,
            1269
        ],
        [
            1246,
            1256
        ],
        [
            1226,
            1239
        ],
        [
            1206,
            1219
        ],
        [
            1193,
            1205
        ],
        [
            1182,
            1191
        ],
        [
            1171,
            1181
        ],
        [
            1159,
            1169
        ],
        [
            1149,
            1157
        ],
        [
            1136,
            1146
        ],
        [
            1120,
            1129
        ],
        [
            1114,
            1117
        ],
        [
            1103,
            1113
        ],
        [
            1093,
            1102
        ],
        [
            1082,
            1092
        ],
        [
            1068,
            1079
        ],
        [
            1056,
            1067
        ],
        [
            1036,
            1050
        ],
        [
            1022,
            1035
        ],
        [
            1019,
            1021
        ],
        [
            1005,
            1018
        ],
        [
            996,
            1004
        ],
        [
            991,
            994
        ],
        [
            978,
            990
        ],
        [
            967,
            976
        ],
        [
            960,
            966
        ],
        [
            950,
            959
        ],
        [
            946,
            949
        ],
        [
            941,
            945
        ],
        [
            932,
            940
        ],
        [
            923,
            931
        ],
        [
            917,
            922
        ],
        [
            905,
            916
        ],
        [
            884,
            902
        ],
        [
            826,
            869
        ],
        [
            791,
            814
        ],
        [
            780,
            786
        ],
        [
            767,
            775
        ],
        [
            761,
            761
        ],
        [
            760,
            760
        ],
        [
            732,
            753
        ],
        [
            723,
            729
        ],
        [
            713,
            721
        ],
        [
            700,
            710
        ],
        [
            689,
            696
        ],
        [
            665,
            681
        ],
        [
            654,
            662
        ],
        [
            642,
            650
        ],
        [
            612,
            636
        ],
        [
            606,
            606
        ],
        [
            599,
            604
        ],
        [
            585,
            593
        ],
        [
            560,
            566
        ],
        [
            540,
            556
        ],
        [
            538,
            538
        ],
        [
            535,
            535
        ],
        [
            532,
            532
        ],
        [
            522,
            524
        ],
        [
            520,
            521
        ],
        [
            503,
            515
        ],
        [
            499,
            502
        ],
        [
            487,
            496
        ],
        [
            471,
            485
        ],
        [
            427,
            429
        ]
    ],
    "blocks": [
        "        end\n        DONE: begin           \n          Pre_SYSRST              <= 1'b0;    \n          MCB_UICMDEN             <= 1'b0;  \n          STATE <= DONE;\n        end\n        default:        begin\n          MCB_UICMDEN             <= 1'b0;  \n          MCB_UIDONECAL           <= 1'b1;  \n          Pre_SYSRST              <= 1'b0;  \n          IODRPCTRLR_CMD_VALID    <= 1'b0;\n          IODRPCTRLR_MEMCELL_ADDR <= 8'h00;\n          IODRPCTRLR_WRITE_DATA   <= 8'h00;\n          IODRPCTRLR_R_WB         <= 1'b0;\n          IODRPCTRLR_USE_BKST     <= 1'b0;\n          P_Term                  <= 6'b0;\n          N_Term                  <= 5'b0;\n          Active_IODRP            <= ZIO;\n          Max_Value_Previous      <= 8'b0;\n          MCB_UILDQSINC           <= 1'b0;  \n          MCB_UIUDQSINC           <= 1'b0;  \n          MCB_UILDQSDEC           <= 1'b0;  \n          MCB_UIUDQSDEC           <= 1'b0;  \n          counter_en              <= 1'b0;\n          First_Dyn_Cal_Done      <= 1'b0;  \n          Max_Value               <= Max_Value;\n          STATE                   <= START;\n        end",
        "          MCB_UILDQSDEC       <= 1'b0;          \n          MCB_UIUDQSDEC       <= 1'b0;          \n          if (DQS_DELAY != 8'h00) begin\n            case (Inc_Dec_REFRSH_Flag)            \n              3'b011: begin\n                counter_dec <= counter_dec + 1'b1;\n                  STATE               <= DECREMENT; \n                if (DQS_DELAY > DQS_DELAY_LOWER_LIMIT  && counter_dec >= 8'h04) begin \n                  MCB_UILDQSDEC       <= 1'b1;      \n                  MCB_UIUDQSDEC       <= 1'b1;      \n                  DQS_DELAY           <= DQS_DELAY - 1'b1; \n                end\n              end\n              3'b010: begin\n                if (DQS_DELAY > DQS_DELAY_LOWER_LIMIT) \n                  STATE                 <= DECREMENT; \n                end\n              default: begin\n                  STATE               <= START_DYN_CAL; \n              end",
        "          MCB_UILDQSINC       <= 1'b0;          \n          MCB_UIUDQSINC       <= 1'b0;          \n          MCB_UILDQSDEC       <= 1'b0;          \n          MCB_UIUDQSDEC       <= 1'b0;          \n          case (Inc_Dec_REFRSH_Flag)            ",
        "        ANALYZE_MAX_VALUE:  begin \n          if (!First_Dyn_Cal_Done)\n            STATE <= FIRST_DYN_CAL;\n          else\n            if ((Max_Value<Max_Value_Previous)&&(Max_Value_Delta_Dn>=INCDEC_THRESHOLD)) begin\n              STATE <= DECREMENT;         \n              TARGET_DQS_DELAY   <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            end\n          else\n            if ((Max_Value>Max_Value_Previous)&&(Max_Value_Delta_Up>=INCDEC_THRESHOLD)) begin\n              STATE <= INCREMENT;         \n              TARGET_DQS_DELAY   <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            end\n          else begin\n            Max_Value           <= Max_Value_Previous;\n            STATE <= START_DYN_CAL;\n          end\n        end\n        FIRST_DYN_CAL:  begin \n          First_Dyn_Cal_Done  <= 1'b1;          \n          STATE               <= START_DYN_CAL;\n        end\n        INCREMENT: begin      ",
        "          else begin\n            Max_Value           <= IODRPCTRLR_READ_DATA;  \n            if (~First_In_Term_Done) begin",
        "          counter_en  <= 1'b1;\n          if (count < 6'd38)  \n            STATE     <= WAIT9;\n          else\n            STATE     <= READ_MAX_VALUE;\n        end\n        READ_MAX_VALUE: begin     \n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= MaxValue;\n          IODRPCTRLR_R_WB         <= READ_MODE;\n          Max_Value_Previous      <= Max_Value;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= READ_MAX_VALUE;\n          else\n            STATE <= WAIT10;\n        end",
        "        WRITE_CALIBRATE:  begin   \n          Pre_SYSRST              <= 1'b0; \n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= DelayControl;\n          IODRPCTRLR_WRITE_DATA   <= 8'h20; \n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          Active_IODRP            <= RZQ;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WRITE_CALIBRATE;\n          else\n            STATE <= WAIT9;\n        end\n        WAIT9:  begin     ",
        "\n        START_DYN_CAL:  begin       \n          Pre_SYSRST        <= 1'b0;      ",
        "          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_WRITE_POS_INDELAY;\n          else\n            STATE <= UDQS_WAIT1;\n        end\n        UDQS_WAIT1:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_WAIT1;\n          else begin\n            STATE           <= UDQS_WRITE_NEG_INDELAY;\n          end\n        end\n        UDQS_WRITE_NEG_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= NegEdgeInDly;",
        "        LDQS_WAIT2:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_WAIT2;\n          else begin\n            STATE <= UDQS_WRITE_POS_INDELAY;\n          end\n        end\n        UDQS_WRITE_POS_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= PosEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;",
        "            STATE           <= LDQS_WRITE_NEG_INDELAY;\n          end\n        end\n        LDQS_WRITE_NEG_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= NegEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_WRITE_NEG_INDELAY;\n          else\n            STATE <= LDQS_WAIT2;\n        end",
        "          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_WRITE_POS_INDELAY;\n          else\n            STATE <= LDQS_WAIT1;\n        end\n        LDQS_WAIT1:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_WAIT1;\n          else begin",
        "            MCB_UICMDEN <= 1'b1;    \n            DQS_DELAY_INITIAL <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            STATE       <= LDQS_WRITE_POS_INDELAY;\n          end\n          else\n            STATE       <= WAIT_FOR_UODONE;\n        end\n        LDQS_WRITE_POS_INDELAY:  begin",
        "        START_DYN_CAL_PRE:  begin   \n          LastPass_DynCal <= `IN_TERM_PASS;\n          MCB_UICMDEN     <= 1'b0;    \n          MCB_UIDONECAL   <= 1'b1;    \n          Pre_SYSRST      <= 1'b1;    \n          if (~CALMODE_EQ_CALIBRATION)      \n            STATE       <= START_DYN_CAL;  \n          else if (pre_sysrst_minpulse_width_ok)   \n            STATE       <= WAIT_FOR_UODONE;\n          end\n        WAIT_FOR_UODONE:  begin  ",
        "          if (Block_Reset) begin  \n            STATE       <= RST_DELAY;\n          end\t\t\t \n          else begin\n            STATE <= START_DYN_CAL_PRE;\n          end\n        end\n       ",
        "        WAIT8:  begin             \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT8;\n          else begin\n            if (First_In_Term_Done) begin\n              STATE               <= START_DYN_CAL; \n            end\n            else begin\n              STATE               <= WRITE_CALIBRATE; \n            end\n          end\n        end\n        RST_DELAY:  begin     ",
        "        OFF_ZIO_NTERM:  begin     \n          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= 8'b00;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= OFF_ZIO_NTERM;\n          else\n            STATE <= WAIT8;\n        end",
        "        OFF_RZQ_PTERM:  begin        \n          Active_IODRP            <= RZQ;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= 8'b00;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          P_Term                  <= 6'b0;\n          N_Term                  <= 5'b0;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= OFF_RZQ_PTERM;\n          else\n            STATE <= WAIT7;\n        end",
        "          end\n        end\n         UDQS_PIN_WRITE_N_TERM:  begin  \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_w};\n          MCB_UIADDR              <= IOI_UDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_WRITE_N_TERM;\n          else\n            STATE <= UDQS_PIN_N_TERM_WAIT;\n        end\n        UDQS_PIN_N_TERM_WAIT:  begin   ",
        "          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_s};\n          MCB_UIADDR              <= IOI_UDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_WRITE_P_TERM;\n          else\n            STATE <= UDQS_PIN_P_TERM_WAIT;\n        end\n        UDQS_PIN_P_TERM_WAIT:  begin  \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_P_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_PIN_WRITE_N_TERM;",
        "        end\n        UDQS_CLK_N_TERM_WAIT:  begin \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_N_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_PIN_WRITE_P_TERM;\n          end\n        end\n         UDQS_PIN_WRITE_P_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;",
        "        end\n        UDQS_CLK_WRITE_N_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_s};\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_WRITE_N_TERM;\n          else\n            STATE <= UDQS_CLK_N_TERM_WAIT;",
        "          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_WRITE_P_TERM;\n          else\n            STATE <= UDQS_CLK_P_TERM_WAIT;\n        end\n        UDQS_CLK_P_TERM_WAIT:  begin \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_P_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_CLK_WRITE_N_TERM;",
        "            STATE <= LDQS_PIN_N_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_CLK_WRITE_P_TERM;\n          end\n        end\n        UDQS_CLK_WRITE_P_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_w};",
        "         LDQS_PIN_WRITE_N_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_w};\n          MCB_UIADDR              <= IOI_LDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_WRITE_N_TERM;\n          else\n            STATE <= LDQS_PIN_N_TERM_WAIT;\n        end",
        "          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_s};\n          MCB_UIADDR              <= IOI_LDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_WRITE_P_TERM;\n          else\n            STATE <= LDQS_PIN_P_TERM_WAIT;\n        end\n        LDQS_PIN_P_TERM_WAIT:  begin   ",
        "          else begin\n            STATE           <= LDQS_PIN_WRITE_P_TERM;\n          end\n        end",
        "          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_s};\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_WRITE_N_TERM;\n          else\n            STATE <= LDQS_CLK_N_TERM_WAIT;\n        end\n        LDQS_CLK_N_TERM_WAIT:  begin   \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_N_TERM_WAIT;",
        "        LDQS_CLK_P_TERM_WAIT:  begin     \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_P_TERM_WAIT;\n          else begin\n            STATE           <= LDQS_CLK_WRITE_N_TERM;\n          end\n        end\n        LDQS_CLK_WRITE_N_TERM:  begin   \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;",
        "          LDQS_CLK_WRITE_P_TERM:  begin   \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_w};\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_WRITE_P_TERM;\n          else\n            STATE <= LDQS_CLK_P_TERM_WAIT;\n        end",
        "        WAIT6:  begin             \n          if (!MCB_RDY_BUSY_N)\n            STATE <= WAIT6;\n          else if (First_In_Term_Done) begin  \n            if (MCB_UOREFRSHFLAG) begin\n              MCB_UIDRPUPDATE <= 1'b1;\n              STATE           <= OFF_RZQ_PTERM;\n            end\n            else\n              STATE <= WAIT6;   \n          end\n          else",
        "        BROADCAST_NTERM:  begin    \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          MCB_CMD_VALID           <= 1'b1;\n          MCB_USE_BKST            <= 1'b1;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          if (MCB_RDY_BUSY_N)\n            STATE <= BROADCAST_NTERM;\n          else\n            STATE <= WAIT6;\n        end",
        "          if (!MCB_RDY_BUSY_N)\n            STATE <= WAIT5;\n          else if (First_In_Term_Done) begin  \n            if (MCB_UOREFRSHFLAG) begin\n              MCB_UIDRPUPDATE <= 1'b1;\n              if (N_Term != N_Term_Prev) begin\n                N_Term_Prev <= N_Term;\n                STATE       <= BROADCAST_NTERM;\n              end\n              else\n                STATE <= OFF_RZQ_PTERM;\n            end\n            else\n              STATE <= WAIT5;   \n          end",
        "        BROADCAST_PTERM:  begin    \n\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          MCB_CMD_VALID           <= 1'b1;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          MCB_USE_BKST            <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= BROADCAST_PTERM;\n          else\n            STATE <= WAIT5;\n        end\n        WAIT5:  begin   ",
        "          else\n            STATE   <= WAIT_FOR_START_BROADCAST;\n        end",
        "          Pre_SYSRST    <= 1'b0;      \n          Active_IODRP  <= MCB_PORT;\n          if (START_BROADCAST && IODRPCTRLR_RDY_BUSY_N) begin\n            if (P_Term != P_Term_Prev || SKIP_IN_TERM_CAL   ) begin\n              STATE       <= BROADCAST_PTERM;\n              P_Term_Prev <= P_Term;\n            end\n            else if (N_Term != N_Term_Prev) begin\n              N_Term_Prev <= N_Term;\n              STATE       <= BROADCAST_NTERM;\n            end\n            else\n              STATE <= OFF_RZQ_PTERM;\n          end",
        "            P_Term_s <= Mult_Divide(P_Term, MULT_S, DIV_S);\n            N_Term_w <= Mult_Divide(N_Term-1, MULT_W, DIV_W);\n            P_Term_w <= Mult_Divide(P_Term, MULT_W, DIV_W);\n            N_Term_s <= Mult_Divide(N_Term-1, MULT_S, DIV_S);\n            P_Term   <= Mult_Divide(P_Term, MULT_S, DIV_S);\n            N_Term   <= Mult_Divide(N_Term-1, MULT_W, DIV_W);\n            STATE  <= WAIT_FOR_START_BROADCAST;\n        end\n        WAIT_FOR_START_BROADCAST: begin   ",
        "        INC_NTERM: begin    \n          N_Term  <= N_Term + 1;\n          STATE   <= LOAD_ZIO_NTERM;\n        end",
        "        WAIT4:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT4;\n          else if ((!ZIO_IN)||(N_Term == 7'b1111111)) begin\n            if (PNSKEW) begin\n              STATE    <= SKEW;\n            end\n            else \n            STATE <= WAIT_FOR_START_BROADCAST;\n          end\n          else\n            STATE <= INC_NTERM;\n        end",
        "        LOAD_ZIO_NTERM: begin   \n          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_ZIO_NTERM;\n          else\n            STATE <= WAIT4;",
        "        WAIT3:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT3;\n          else begin\n            STATE   <= LOAD_ZIO_NTERM;\n          end\n        end",
        "          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_ZIO_PTERM;\n          else\n            STATE <= WAIT3;\n        end",
        "           P_Term  <= Mult_Divide(P_Term-1, MULT, DIV);  \n           STATE <= LOAD_ZIO_PTERM;\n        end\n        LOAD_ZIO_PTERM: begin   ",
        "        INC_PTERM: begin    \n          P_Term  <= P_Term + 1;\n          STATE   <= LOAD_RZQ_PTERM;\n        end\n        MULTIPLY_DIVIDE: begin ",
        "        WAIT2:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT2;\n          else if ((RZQ_IN)||(P_Term == 6'b111111)) begin\n            STATE <= MULTIPLY_DIVIDE;\n          end\n          else\n            STATE <= INC_PTERM;\n        end",
        "          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_RZQ_PTERM;\n          else\n            STATE <= WAIT2;\n        end",
        "          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT1;\n          else\n            STATE <= LOAD_RZQ_PTERM;\n        end\n        LOAD_RZQ_PTERM: begin ",
        "        LOAD_RZQ_NTERM: begin   \n          Active_IODRP            <= RZQ;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_RZQ_NTERM;\n          else\n            STATE <= WAIT1;\n        end\n        WAIT1:  begin   ",
        "      case (STATE)\n        START:  begin   \n          MCB_UICMDEN     <= 1'b1;        \n          MCB_UIDONECAL   <= 1'b0;        \n          P_Term          <= 6'b0;\n          N_Term          <= 7'b0;\n          Pre_SYSRST      <= 1'b1;        \n          LastPass_DynCal <= `IN_TERM_PASS;\n          if (SKIP_IN_TERM_CAL) begin\n               STATE <= WAIT_FOR_START_BROADCAST;\n               P_Term <= 'b0;\n               N_Term <= 'b0;\n            end\n          else if (IODRPCTRLR_RDY_BUSY_N)\n            STATE  <= LOAD_RZQ_NTERM;\n          else\n            STATE  <= START;\n        end\n",
        "  always @(posedge UI_CLK) begin: NEXT_STATE_LOGIC\n    if (RST_reg) begin                      \n      MCB_CMD_VALID           <= 1'b0;\n      MCB_UIADDR              <= 5'b0;\n      MCB_UICMDEN             <= 1'b1;      \n      MCB_UIDONECAL           <= 1'b0;      \n      MCB_USE_BKST            <= 1'b0;\n      MCB_UIDRPUPDATE         <= 1'b1;\n      Pre_SYSRST              <= 1'b1;      \n      IODRPCTRLR_CMD_VALID    <= 1'b0;\n      IODRPCTRLR_MEMCELL_ADDR <= NoOp;\n      IODRPCTRLR_WRITE_DATA   <= 1'b0;\n      IODRPCTRLR_R_WB         <= WRITE_MODE;\n      IODRPCTRLR_USE_BKST     <= 1'b0;\n      P_Term                  <= 6'b0;\n      N_Term                  <= 7'b0;\n      P_Term_s                <= 6'b0;\n      N_Term_w                <= 7'b0;\n      P_Term_w                <= 6'b0;\n      N_Term_s                <= 7'b0;\n      P_Term_Prev             <= 6'b0;\n      N_Term_Prev             <= 7'b0;\n      Active_IODRP            <= RZQ;\n      MCB_UILDQSINC           <= 1'b0;      \n      MCB_UIUDQSINC           <= 1'b0;      \n      MCB_UILDQSDEC           <= 1'b0;      \n      MCB_UIUDQSDEC           <= 1'b0;      \n      counter_en              <= 1'b0;\n      First_Dyn_Cal_Done      <= 1'b0;      \n      Max_Value               <= 8'b0;\n      Max_Value_Previous      <= 8'b0;\n      STATE                   <= START;\n      DQS_DELAY               <= 8'h0; \n      DQS_DELAY_INITIAL       <= 8'h0;\n      TARGET_DQS_DELAY        <= 8'h0;\n      LastPass_DynCal         <= `IN_TERM_PASS;\n      First_In_Term_Done      <= 1'b0;\n      MCB_UICMD               <= 1'b0;\n      MCB_UICMDIN             <= 1'b0;\n      MCB_UIDQCOUNT           <= 4'h0;\n      counter_inc             <= 8'h0;\n      counter_dec             <= 8'h0;\n    end\n    else begin",
        "  always @(*) begin: ACTIVE_IODRP\n    case (Active_IODRP)\n      RZQ:      begin\n        RZQ_IODRP_CS  = IODRP_CS;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = RZQ_IODRP_SDO;\n      end\n      ZIO:      begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = IODRP_CS;\n        IODRP_SDO     = ZIO_IODRP_SDO;\n      end\n      MCB_PORT: begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = 1'b0;\n      end\n      default:  begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = 1'b0;\n      end\n    endcase\n  end",
        " always @(posedge UI_CLK or posedge MCB_UODATAVALID)\n  begin\n    if (MCB_UODATAVALID)\n        MCB_UODATAVALID_U <= 1'b1;\n    else\n        MCB_UODATAVALID_U <= MCB_UODATAVALID;\n  end",
        " always @(posedge UI_CLK)\n  begin\n    if (RST_reg)\n        count <= 6'd0;\n    else if (counter_en)\n        count <= count + 1'b1;\n    else\n        count <= 6'd0;\n  end",
        "assign Inc_Flag = (TARGET_DQS_DELAY > DQS_DELAY);",
        "assign Dec_Flag = (TARGET_DQS_DELAY < DQS_DELAY);",
        "always @ (posedge UI_CLK) begin\n   if (RST) \n    begin\n       WaitTimer <= 'b0;\n       WarmEnough <= 1'b1;\n    end       \n  else if (~SELFREFRESH_REQ_R2 && SELFREFRESH_REQ_R1)  \n    begin\n       WaitTimer <= 'b0;\n       WarmEnough <= 1'b0;\n    end       \n  else if (WaitTimer == 8'h4)\n    begin\n       WaitTimer <= WaitTimer ;\n       WarmEnough <= 1'b1;\n    end       \n  else if (WaitCountEnable)\n       WaitTimer <= WaitTimer + 1;\n  else\n       WaitTimer <= WaitTimer ;\n  \nend  ",
        "always @ (posedge UI_CLK)\nbegin\nif (RST)\n   State_Start_DynCal_R1 <= 1'b0;\nelse \n   State_Start_DynCal_R1 <= State_Start_DynCal;\nend",
        "always @ (posedge UI_CLK)\nbegin\nif (RST)\n   State_Start_DynCal <= 1'b0;\nelse if (STATE == START_DYN_CAL)   \n   State_Start_DynCal <= 1'b1;\nelse\n   State_Start_DynCal <= 1'b0;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    WaitCountEnable <= 1'b0;\n  else if (~SELFREFRESH_REQ_R2 && SELFREFRESH_REQ_R1)  \n    WaitCountEnable <= 1'b0;\n    \n  else if (!PERFORM_START_DYN_CAL_AFTER_SELFREFRESH && PERFORM_START_DYN_CAL_AFTER_SELFREFRESH_R1)\n    WaitCountEnable <= 1'b1;\n  else\n    WaitCountEnable <=  WaitCountEnable;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    SELFREFRESH_MODE <= 1'b0;\n  else if (SELFREFRESH_MCB_MODE_R2)  \n    SELFREFRESH_MODE <= 1'b1;\n    else if (WarmEnough)\n     SELFREFRESH_MODE <= 1'b0;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST) begin\n    PERFORM_START_DYN_CAL_AFTER_SELFREFRESH  <= 1'b0;\n    START_DYN_CAL_STATE_R1 <= 1'b0;\n  end \n  else begin\n    \n    PERFORM_START_DYN_CAL_AFTER_SELFREFRESH_R1 <= PERFORM_START_DYN_CAL_AFTER_SELFREFRESH;\n    if (STATE == START_DYN_CAL)\n      START_DYN_CAL_STATE_R1 <= 1'b1;\n    else\n      START_DYN_CAL_STATE_R1 <= 1'b0;\n      if (WAIT_SELFREFRESH_EXIT_DQS_CAL && STATE != START_DYN_CAL && START_DYN_CAL_STATE_R1 )\n        PERFORM_START_DYN_CAL_AFTER_SELFREFRESH <= 1'b1;\n      else if (STATE == START_DYN_CAL && ~SELFREFRESH_MCB_MODE_R3)\n        PERFORM_START_DYN_CAL_AFTER_SELFREFRESH <= 1'b0;\n      end",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b0;\n  else if (~SELFREFRESH_MCB_MODE_R3 && SELFREFRESH_MCB_MODE_R2)  \n\n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b1;\n  else if (WAIT_SELFREFRESH_EXIT_DQS_CAL && ~SELFREFRESH_REQ_R3 && PERFORM_START_DYN_CAL_AFTER_SELFREFRESH) \n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b0;\nend   ",
        "always @ ( posedge UI_CLK) begin\n  if (RST)\n    SELFREFRESH_MCB_REQ <= 1'b0;\n  else if (PLL_LOCK_R2 && ~SELFREFRESH_REQ_R3 )\n\n    SELFREFRESH_MCB_REQ <=  1'b0;\n  else if (STATE == START_DYN_CAL && SELFREFRESH_REQ_R3)  \n    SELFREFRESH_MCB_REQ <= 1'b1;\nend",
        "always @ ( posedge UI_CLK, posedge RST) begin\n  \n  if (RST)\n    begin\n      SELFREFRESH_MCB_MODE_R1 <= 1'b0;\n      SELFREFRESH_MCB_MODE_R2 <= 1'b0;\n      SELFREFRESH_MCB_MODE_R3 <= 1'b0;\n      SELFREFRESH_REQ_R1      <= 1'b0;\n      SELFREFRESH_REQ_R2      <= 1'b0;\n      SELFREFRESH_REQ_R3      <= 1'b0;\n      PLL_LOCK_R1             <= 1'b0;\n      PLL_LOCK_R2             <= 1'b0;\n    end\n  else \n    begin\n      SELFREFRESH_MCB_MODE_R1 <= SELFREFRESH_MCB_MODE;\n      SELFREFRESH_MCB_MODE_R2 <= SELFREFRESH_MCB_MODE_R1;\n      SELFREFRESH_MCB_MODE_R3 <= SELFREFRESH_MCB_MODE_R2;\n      SELFREFRESH_REQ_R1      <= SELFREFRESH_REQ;\n      SELFREFRESH_REQ_R2      <= SELFREFRESH_REQ_R1;\n      SELFREFRESH_REQ_R3      <= SELFREFRESH_REQ_R2;\n      PLL_LOCK_R1             <= PLL_LOCK;\n      PLL_LOCK_R2             <= PLL_LOCK_R1;\n    end\n end ",
        "assign pre_sysrst_minpulse_width_ok = pre_sysrst_cnt[3];",
        "always @ (posedge UI_CLK )begin\n  if (STATE == START_DYN_CAL_PRE)\n     pre_sysrst_cnt <= pre_sysrst_cnt + 1;\n  else\n     pre_sysrst_cnt <= 4'b0;\nend",
        "always @ (posedge UI_CLK or posedge non_violating_rst ) begin  \n  if (non_violating_rst)          \n    RST_reg <= 1'b1;                                       \n  else if (~WAIT_200us_COUNTER[15])\n    RST_reg <= 1'b1;         \n  else \n    RST_reg     <= rst_tmp; \n    \nend",
        "always @ (posedge UI_CLK ) begin  \nif (RstCounter >= TZQINIT_MAXCNT) \n    Rst_condition1 <= 1'b1;\nelse\n    Rst_condition1 <= 1'b0;\n\nend",
        "always @ (posedge UI_CLK or posedge RST ) begin  \n  if (RST) begin         \n    Block_Reset <= 1'b0;\n    RstCounter  <= 10'b0;\nend\n  else begin\n    Block_Reset <= 1'b0;                   \n    if (Pre_SYSRST)\n      RstCounter  <= RST_CNT;              \n    else begin\n      if (RstCounter < TZQINIT_MAXCNT) begin \n        Block_Reset <= 1'b1;               \n        RstCounter  <= RstCounter + 1'b1;  \n      end\n    end\n  end\nend",
        "assign MCB_SYSRST = (Pre_SYSRST );",
        "assign non_violating_rst = RST & Rst_condition1;         ",
        "assign rst_tmp    = (~PLL_LOCK_R2 && ~SELFREFRESH_MODE); ",
        "always @ (RST)\n   CKE_Train <= 1'b0;\nend ",
        "generate\nif( C_MEM_TYPE != \"DDR2\") begin : gen_cketrain_b",
        "always @ ( posedge UI_CLK, posedge RST)\nbegin \nif (RST)\n   CKE_Train <= 1'b0;\nelse \n  if (STATE == WAIT_FOR_UODONE && MCB_UODONECAL)\n   CKE_Train <= 1'b0;\n  else if (WAIT_200us_COUNTER[15] && ~MCB_UODONECAL)\n   CKE_Train <= 1'b1;\n  else\n   CKE_Train <= 1'b0;\n  \nend",
        "generate\nif( C_MEM_TYPE == \"DDR2\") begin : gen_cketrain_a\n\n",
        " always @ (posedge UI_CLK, posedge RST)\n  begin\n   if (RST)\n     WAIT_200us_COUNTER <= (C_SIMULATION == \"TRUE\") ? 16'h7FF0 : 16'h0;\n   else \n      if (WAIT_200us_COUNTER[15])  \n        WAIT_200us_COUNTER <= WAIT_200us_COUNTER                        ;\n      else\n        WAIT_200us_COUNTER <= WAIT_200us_COUNTER + 1'b1;\n  end ",
        "function [7:0] Mult_Divide;\ninput   [7:0]   Input;\ninput   [7:0]   Mult;\ninput   [7:0]   Div;\nreg     [3:0]   count;\nreg     [15:0]   Result;\nbegin\n  Result  = 0;\n  for (count = 0; count < Mult; count = count+1) begin\n    Result    = Result + Input;\n  end\n  Result      = Result / Div;\n  Mult_Divide = Result[7:0];\nend\nendfunction",
        "always @ (posedge UI_CLK)\n     DONE_SOFTANDHARD_CAL    <= ((DQS_DELAY_INITIAL != 8'h00) || (STATE == DONE)) && MCB_UODONECAL;  \n"
    ]
}