{
    "line_num": [
        [
            988,
            990
        ],
        [
            971,
            985
        ],
        [
            956,
            970
        ],
        [
            952,
            954
        ],
        [
            927,
            946
        ],
        [
            884,
            920
        ],
        [
            860,
            881
        ],
        [
            840,
            856
        ],
        [
            829,
            835
        ],
        [
            826,
            826
        ],
        [
            807,
            818
        ],
        [
            740,
            786
        ],
        [
            721,
            734
        ],
        [
            582,
            715
        ],
        [
            575,
            575
        ],
        [
            572,
            574
        ],
        [
            562,
            567
        ],
        [
            556,
            556
        ],
        [
            554,
            554
        ],
        [
            455,
            545
        ],
        [
            431,
            442
        ],
        [
            424,
            426
        ],
        [
            373,
            418
        ],
        [
            360,
            370
        ],
        [
            352,
            352
        ],
        [
            349,
            350
        ],
        [
            342,
            346
        ],
        [
            320,
            335
        ],
        [
            264,
            311
        ],
        [
            258,
            262
        ],
        [
            236,
            251
        ],
        [
            234,
            234
        ],
        [
            233,
            233
        ],
        [
            230,
            232
        ]
    ],
    "blocks": [
        "\nendmodule\n",
        "assign xRXD_STATE      = rxd_state == RXD_IDLE       ? \"RXD_IDLE\"      :\n                         rxd_state == RXD_START      ? \"RXD_START\"     :\n                         rxd_state == RXD_START_MID1 ? \"RXD_START_MID1\":\n                         rxd_state == RXD_START_MID  ? \"RXD_START_MID\" :\n                         rxd_state == RXD_DATA0      ? \"RXD_DATA0\"     :\n                         rxd_state == RXD_DATA1      ? \"RXD_DATA1\"     :\n                         rxd_state == RXD_DATA2      ? \"RXD_DATA2\"     :\n                         rxd_state == RXD_DATA3      ? \"RXD_DATA3\"     :\n                         rxd_state == RXD_DATA4      ? \"RXD_DATA4\"     :\n                         rxd_state == RXD_DATA5      ? \"RXD_DATA5\"     :\n                         rxd_state == RXD_DATA6      ? \"RXD_DATA6\"     :\n                         rxd_state == RXD_DATA7      ? \"RXD_DATA7\"     :\n                         rxd_state == RXD_STOP       ? \"RXD_STOP\"      :\n                                                       \"UNKNOWN\"       ;\n",
        "assign xTXD_STATE      = txd_state == TXD_IDLE       ? \"TXD_IDLE\"   :\n                         txd_state == TXD_START      ? \"TXD_START\"  :\n                         txd_state == TXD_DATA0      ? \"TXD_DATA0\"  :\n                         txd_state == TXD_DATA1      ? \"TXD_DATA1\"  :\n                         txd_state == TXD_DATA2      ? \"TXD_DATA2\"  :\n                         txd_state == TXD_DATA3      ? \"TXD_DATA3\"  :\n                         txd_state == TXD_DATA4      ? \"TXD_DATA4\"  :\n                         txd_state == TXD_DATA5      ? \"TXD_DATA5\"  :\n                         txd_state == TXD_DATA6      ? \"TXD_DATA6\"  :\n                         txd_state == TXD_DATA7      ? \"TXD_DATA7\"  :\n                         txd_state == TXD_STOP1      ? \"TXD_STOP1\"  :\n                         txd_state == TXD_STOP2      ? \"TXD_STOP2\"  :\n                         txd_state == TXD_STOP3      ? \"TXD_STOP3\"  :\n                                                       \"UNKNOWN\"    ;\n",
        "wire    [(10*8)-1:0]    xTXD_STATE;\nwire    [(14*8)-1:0]    xRXD_STATE;\n",
        "always @ ( posedge i_clk )\n    begin\n    if ( rx_fifo_pop  && !rx_fifo_push && rx_fifo_empty )\n        begin\n        `TB_WARNING_MESSAGE\n        $write(\"UART rx FIFO underflow\\n\");\n        end\n    if ( !rx_fifo_pop  && rx_fifo_push && rx_fifo_full )\n        begin\n        `TB_WARNING_MESSAGE\n        $write(\"UART rx FIFO overflow\\n\");\n        end\n\n    if ( tx_fifo_push && tx_fifo_full )\n        begin\n        `TB_WARNING_MESSAGE\n        $display(\"UART tx FIFO overflow - char = %c\", wb_wdata32[7:0]);\n        end\n    end\n",
        "always @( posedge i_clk )\n    if ( wb_read_ack || wb_start_write )\n        begin\n        `TB_DEBUG_MESSAGE\n        \n        if ( wb_start_write )\n            $write(\"Write 0x%08x to   \", wb_wdata32);\n        else\n            $write(\"Read  0x%08x from \", o_wb_dat);\n            \n        case ( i_wb_adr[15:0] )\n            AMBER_UART_PID0:    $write(\"UART PID0 register\"); \n            AMBER_UART_PID1:    $write(\"UART PID1 register\"); \n            AMBER_UART_PID2:    $write(\"UART PID2 register\"); \n            AMBER_UART_PID3:    $write(\"UART PID3 register\"); \n            AMBER_UART_CID0:    $write(\"UART CID0 register\"); \n            AMBER_UART_CID1:    $write(\"UART CID1 register\"); \n            AMBER_UART_CID2:    $write(\"UART CID2 register\"); \n            AMBER_UART_CID3:    $write(\"UART CID3 register\"); \n            AMBER_UART_DR:      $write(\"UART Tx/Rx char %c\", wb_start_write ? wb_wdata32[7:0] : o_wb_dat[7:0] );\n            AMBER_UART_RSR:     $write(\"UART (Read) Receive status, (Write) Error Clear\");\n            AMBER_UART_LCRH:    $write(\"UART Line Control High Byte\");\n            AMBER_UART_LCRM:    $write(\"UART Line Control Middle Byte\");\n            AMBER_UART_LCRL:    $write(\"UART Line Control Low Byte\");\n            AMBER_UART_CR:      $write(\"UART Control Register\");\n            AMBER_UART_FR:      $write(\"UART Flag Register\");\n            AMBER_UART_IIR:     $write(\"UART (Read) Interrupt Identification Register\");\n\n            default:\n                begin\n                `TB_ERROR_MESSAGE\n                $write(\"Unknown UART Register region\");\n                end\n        endcase\n        \n        $write(\", Address 0x%08h\\n\", i_wb_adr); \n        end",
        "always @ ( posedge i_clk )\n    begin\n    uart0_rx_int_d1 <= rx_interrupt;\n\n    if ( rx_interrupt && !uart0_rx_int_d1 )\n        begin\n        `TB_DEBUG_MESSAGE\n        $display(\"rx_interrupt Interrupt fifo_enable %d, rx_fifo_full %d\", \n                 fifo_enable, rx_fifo_full);\n        $display(\"rx_fifo_half_or_more %d, rx_int_timer 0x%08h, rx_fifo_count %d\", \n                 rx_fifo_half_or_more, rx_int_timer, rx_fifo_count);\n        end\n        \n    if ( !rx_interrupt && uart0_rx_int_d1 )\n        begin\n        `TB_DEBUG_MESSAGE\n        $display(\"rx_interrupt Interrupt Cleared fifo_enable %d, rx_fifo_full %d\", \n                 fifo_enable, rx_fifo_full);\n        $display(\"    rx_fifo_half_or_more %d, rx_int_timer 0x%08h, rx_fifo_count %d\", \n                 rx_fifo_half_or_more, rx_int_timer, rx_fifo_count);\n        end\n    end",
        "always @ ( posedge i_clk )\n    if ( wb_start_write && i_wb_adr[15:0] == AMBER_UART_ICR )\n            ;\n    else if ( fifo_enable ) \n        begin\n        if (tx_interrupt == 1'd0 && tx_fifo_half_or_less_full && uart_cr_reg[5])\n            $display(\"%m: tx_interrupt Interrupt Set with FIFO enabled\");\n        if (tx_interrupt == 1'd1 && !(tx_fifo_half_or_less_full && uart_cr_reg[5]))\n            $display(\"%m: tx_interrupt Interrupt Cleared with FIFO enabled\");\n        end\n    else\n        begin\n        if (tx_interrupt == 1'd0 && tx_fifo_empty && uart_cr_reg[5])\n            $display(\"%m: tx_interrupt Interrupt Set with FIFO disabled\");\n        if (tx_interrupt == 1'd1 && !(tx_fifo_empty && uart_cr_reg[5]))\n            $display(\"%m: tx_interrupt Interrupt Cleared with FIFO disabled\");\n        end",
        "initial\n    begin\n    $display(\"%m UART period = %f nS, want %f nS, %d, %d\", \n             (TX_BITPULSE_COUNT*11 + TX_BITADJUST_COUNT) * CLK_PERIOD,\n             UART_WORD_PERIOD,\n             TX_BITPULSE_COUNT, TX_BITADJUST_COUNT);\n    end",
        "assign wb_read_ack = i_wb_stb && !i_wb_we &&  o_wb_ack;",
        "initial\n    begin\n    if ((( TX_BITPULSE_COUNT * CLK_PERIOD ) > (UART_BIT_PERIOD * 1.03) ) ||\n        (( TX_BITPULSE_COUNT * CLK_PERIOD ) < (UART_BIT_PERIOD * 0.97) ) )\n        begin\n        `TB_ERROR_MESSAGE\n        $display(\"UART TX bit period, %.1f, is too big. UART will not work!\", TX_BITPULSE_COUNT * CLK_PERIOD);\n        $display(\"Baud rate is %f, and baud bit period is %.1f\", UART_BAUD, UART_BIT_PERIOD);\n        $display(\"Either reduce the baud rate, or increase the system clock frequency\");\n        $display(\"------\");\n        end\n    end",
        "always @( posedge i_clk )\n    if ( wb_start_read )\n        case ( i_wb_adr[15:0] )\n        \n            AMBER_UART_CID0:    wb_rdata32 <= 32'h0d;\n            AMBER_UART_CID1:    wb_rdata32 <= 32'hf0;\n            AMBER_UART_CID2:    wb_rdata32 <= 32'h05;\n            AMBER_UART_CID3:    wb_rdata32 <= 32'hb1;\n            AMBER_UART_PID0:    wb_rdata32 <= 32'h10;\n            AMBER_UART_PID1:    wb_rdata32 <= 32'h10;\n            AMBER_UART_PID2:    wb_rdata32 <= 32'h04;\n            AMBER_UART_PID3:    wb_rdata32 <= 32'h00;\n            \n            AMBER_UART_DR:      \n                    if ( fifo_enable )\n                        wb_rdata32 <= {24'd0, rx_fifo[rx_fifo_rp[3:0]]};\n                    else    \n                        wb_rdata32 <= {24'd0, rx_fifo[0]};\n                                      \n            AMBER_UART_RSR:     wb_rdata32 <= uart_rsr_reg;          \n            AMBER_UART_LCRH:    wb_rdata32 <= uart_lcrh_reg;         \n            AMBER_UART_LCRM:    wb_rdata32 <= uart_lcrm_reg;         \n            AMBER_UART_LCRL:    wb_rdata32 <= uart_lcrl_reg;         \n            AMBER_UART_CR:      wb_rdata32 <= uart_cr_reg;           \n            \n            \n            AMBER_UART_FR:      wb_rdata32 <= {tx_fifo_empty,       \n                                             rx_fifo_full,        \n                                             tx_fifo_full,        \n                                             rx_fifo_empty,       \n                                             !tx_fifo_empty,      \n                                             1'd1,                 \n                                             1'd1,                 \n                                             !uart0_cts_n_d[3]     \n                                             };                    \n            \n            \n            AMBER_UART_IIR:     wb_rdata32 <= {5'd0, \n                                             1'd0,                 \n                                             tx_interrupt,         \n                                             rx_interrupt,         \n                                             1'd0                  \n                                            };                     \n                                            \n            default:            wb_rdata32 <= 32'h00c0ffee;\n            \n        endcase",
        "always @( posedge i_clk )\n    if ( wb_start_write )\n        case ( i_wb_adr[15:0] )\n            \n            AMBER_UART_RSR:  uart_rsr_reg      <= wb_wdata32[7:0];\n            \n            AMBER_UART_LCRH: uart_lcrh_reg     <= wb_wdata32[7:0];\n            \n            AMBER_UART_LCRM: uart_lcrm_reg     <= wb_wdata32[7:0];\n            \n            AMBER_UART_LCRL: uart_lcrl_reg     <= wb_wdata32[7:0];\n            \n            AMBER_UART_CR:   uart_cr_reg       <= wb_wdata32[7:0];\n        endcase",
        "always @( posedge i_clk )\n    case ( rxd_state )\n    \n        RXD_IDLE :\n            if ( rx_fifo_full )\n                rxen                    <= 1'd0;\n            else\n                begin\n                rxd_state               <= RXD_START;\n                rxen                    <= 1'd1;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte                 <= 'd0;\n                end\n            \n        RXD_START : \n            \n            if ( rx_start ) \n                begin\n                rxd_state               <= RXD_START_MID1;\n                restart_rx_bit_count    <= 1'd1;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n\n        \n        \n        \n        RXD_START_MID1 :\n            rxd_state               <= RXD_START_MID;\n            \n        RXD_START_MID :\n            if ( rx_bit_pulse_count == RX_HALFPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA0;\n                restart_rx_bit_count    <= 1'd1;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA0 :\n            if ( rx_bit_pulse_count == RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA1;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[0]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA1 :\n            if ( rx_bit_pulse_count == RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA2;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[1]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA2 :\n            if ( rx_bit_pulse_count == RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA3;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[2]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA3 :\n            if ( rx_bit_pulse_count == RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA4;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[3]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA4 :\n            if ( rx_bit_pulse_count ==  RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA5;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[4]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA5 :\n            if ( rx_bit_pulse_count ==  RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA6;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[5]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA6 :\n            if ( rx_bit_pulse_count ==  RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_DATA7;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[6]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_DATA7 :\n            if ( rx_bit_pulse_count ==  RX_BITPULSE_COUNT )\n                begin\n                rxd_state               <= RXD_STOP;\n                restart_rx_bit_count    <= 1'd1;\n                rx_byte[7]              <= i_uart_rxd;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        RXD_STOP :\n            if ( rx_bit_pulse_count ==  RX_BITPULSE_COUNT )  \n                begin\n                rxd_state               <= RXD_IDLE;\n                restart_rx_bit_count    <= 1'd1;\n                end\n            else    \n                restart_rx_bit_count    <= 1'd0;\n            \n        default :\n            begin\n            rxd_state       <= RXD_IDLE;\n            end\n            \n    endcase",
        "assign rx_start = rxd_d[4:3] == 2'b11 && rxd_d[1:0] == 2'b00;",
        "always @( posedge i_clk )\n    rxd_d[4:0] <= {rxd_d[3:0], i_uart_rxd};\n",
        "always @( posedge i_clk )\n    if ( restart_rx_bit_count )\n        rx_bit_pulse_count <= 'd0;\n    else\n        rx_bit_pulse_count <= rx_bit_pulse_count + 1'd1;\n",
        "assign rx_fifo_push  = rxd_state == RXD_STOP && rx_bit_pulse_count == 10'd0;",
        "assign o_uart_rts_n  = ~rxen;",
        "always @( posedge i_clk )\n    if ( tx_bit_pulse )\n    \n        case ( txd_state )\n        \n            TXD_IDLE :\n                begin\n                txd       <= 1'd1;\n                \n                if ( uart0_cts_n_d[3:1] == 3'b000 && !tx_fifo_empty )\n                    txd_state <= TXD_START;\n                end\n                \n            TXD_START :\n                begin\n                txd       <= 1'd0;\n                txd_state <= TXD_DATA0;\n                end\n                \n            TXD_DATA0 :\n                begin\n                txd       <= tx_byte[0];\n                txd_state <= TXD_DATA1;\n                end\n                \n            TXD_DATA1 :\n                begin\n                txd       <= tx_byte[1];\n                txd_state <= TXD_DATA2;\n                end\n                \n            TXD_DATA2 :\n                begin\n                txd       <= tx_byte[2];\n                txd_state <= TXD_DATA3;\n                end\n                \n            TXD_DATA3 :\n                begin\n                txd       <= tx_byte[3];\n                txd_state <= TXD_DATA4;\n                end\n                \n            TXD_DATA4 :\n                begin\n                txd       <= tx_byte[4];\n                txd_state <= TXD_DATA5;\n                end\n                \n            TXD_DATA5 :\n                begin\n                txd       <= tx_byte[5];\n                txd_state <= TXD_DATA6;\n                end\n                \n            TXD_DATA6 :\n                begin\n                txd       <= tx_byte[6];\n                txd_state <= TXD_DATA7;\n                end\n                \n            TXD_DATA7 :\n                begin\n                txd       <= tx_byte[7];\n                txd_state <= TXD_STOP1;\n                end\n                \n            TXD_STOP1 :\n                begin\n                txd       <= 1'd1;\n                txd_state <= TXD_STOP2;\n                end\n\n            TXD_STOP2 :\n                begin\n                txd       <= 1'd1;\n                txd_state <= TXD_STOP3;\n                end\n                \n            TXD_STOP3 :\n                begin\n                txd       <= 1'd1;\n                txd_state <= TXD_IDLE;\n                end\n                \n            default :\n                begin\n                txd       <= 1'd1;\n                end\n                \n        endcase",
        "always @( posedge i_clk )\n    if (( tx_bit_pulse_count == (TX_BITADJUST_COUNT-1) && txd_state == TXD_STOP2 ) ||\n        ( tx_bit_pulse_count == (TX_BITPULSE_COUNT-1)  && txd_state != TXD_STOP2 )  )\n        begin\n        tx_bit_pulse_count <= 'd0;\n        tx_bit_pulse       <= 1'd1;\n        end\n    else\n        begin\n        tx_bit_pulse_count <= tx_bit_pulse_count + 1'd1;\n        tx_bit_pulse       <= 1'd0;\n        end",
        "always @( posedge i_clk )\n    uart0_cts_n_d <= {uart0_cts_n_d[2:0], i_uart_cts_n};\n                                            ",
        "always @( posedge i_clk )\n    begin      \n    \n    if ( fifo_enable )\n        begin\n        \n        if ( tx_fifo_push_not_full )\n            begin\n            tx_fifo[tx_fifo_wp[3:0]] <= wb_wdata32[7:0];\n            tx_fifo_wp <= tx_fifo_wp + 1'd1;\n            end\n        \n            \n        \n        if ( tx_fifo_pop_not_empty )\n            tx_fifo_rp <= tx_fifo_rp + 1'd1;\n            \n        \n        if (tx_fifo_push_not_full && !tx_fifo_pop_not_empty)\n            tx_fifo_count <= tx_fifo_count + 1'd1;\n            \n        \n        else if (tx_fifo_pop_not_empty  && !tx_fifo_push_not_full)\n            tx_fifo_count <= tx_fifo_count - 1'd1;\n        end\n        \n    \n    else  \n        begin\n        \n        tx_fifo_wp    <= 'd0;\n        tx_fifo_rp    <= 'd0;\n        tx_fifo_count <= 'd0;\n        \n        \n        if ( tx_fifo_push_not_full )\n            begin\n            tx_fifo[0]          <= wb_wdata32[7:0];\n            tx_fifo_full_flag   <= 1'd1;\n            end\n        \n        else if ( tx_fifo_pop_not_empty )\n            tx_fifo_full_flag   <= 1'd0;\n\n        end        \n    end",
        "assign   o_uart_txd                 = txd;\n\nassign   tx_fifo_full               = fifo_enable ? tx_fifo_count >= 5'd16 :  tx_fifo_full_flag;\nassign   tx_fifo_empty              = fifo_enable ? tx_fifo_count == 5'd00 : !tx_fifo_full_flag;\nassign   tx_fifo_half_or_less_full  =               tx_fifo_count <= 5'd8;\nassign   tx_byte                    = fifo_enable ? tx_fifo[tx_fifo_rp[3:0]] : tx_fifo[0] ;\n\nassign   tx_fifo_push               = wb_start_write && i_wb_adr[15:0] == AMBER_UART_DR;\nassign   tx_fifo_push_not_full      = tx_fifo_push && !tx_fifo_full;\nassign   tx_fifo_pop_not_empty      = txd_state == TXD_STOP3 && tx_bit_pulse == 1'd1 && !tx_fifo_empty;\n",
        "assign fifo_enable = uart_lcrh_reg[4];",
        "assign o_uart_int   = ( tx_interrupt & uart_cr_reg[5] )  |  \n                      ( rx_interrupt & uart_cr_reg[4] )  ;  ",
        "always @ ( posedge i_clk )\n    if (fifo_enable)\n        rx_interrupt <=  rx_fifo_half_or_more || rx_int_timer == RX_INTERRUPT_COUNT;\n    else    \n        rx_interrupt <=  rx_fifo_full;",
        "always @ ( posedge i_clk )\n    begin \n    \n    if ( wb_start_write && i_wb_adr[15:0] == AMBER_UART_ICR )\n        tx_interrupt <= 1'd0;\n\n    \n    else if  ( fifo_enable ) \n        \n        \n        tx_interrupt <= tx_fifo_half_or_less_full && uart_cr_reg[5];\n    else \n        \n        \n        tx_interrupt <= tx_fifo_empty && uart_cr_reg[5];\n    end",
        "always @ ( posedge i_clk ) \n    begin\n    if ( fifo_enable )\n        begin\n        \n        if ( rx_fifo_push_not_full )\n            begin\n            rx_fifo[rx_fifo_wp[3:0]]    <= rx_byte;                \n            rx_fifo_wp                  <= rx_fifo_wp + 1'd1;\n            end\n\n        if ( rx_fifo_pop_not_empty )\n            begin\n            rx_fifo_rp                  <= rx_fifo_rp + 1'd1;\n            end\n            \n        if ( rx_fifo_push_not_full && !rx_fifo_pop_not_empty )\n            rx_fifo_count <= rx_fifo_count + 1'd1;\n        else if ( rx_fifo_pop_not_empty  && !rx_fifo_push_not_full )\n            rx_fifo_count <= rx_fifo_count - 1'd1;\n        \n        rx_fifo_full  <= rx_fifo_wp == {~rx_fifo_rp[4], rx_fifo_rp[3:0]};\n        rx_fifo_empty <= rx_fifo_wp == rx_fifo_rp;\n        \n        if ( rx_fifo_empty || rx_fifo_pop )\n            rx_int_timer     <= 'd0;\n        else if ( rx_int_timer != RX_INTERRUPT_COUNT )\n            rx_int_timer     <= rx_int_timer + 1'd1;\n        \n            \n        end\n    else    \n        begin\n        rx_int_timer     <= 'd0;\n        \n        if ( rx_fifo_push )\n            begin\n            rx_fifo[0]         <= rx_byte;\n            rx_fifo_empty      <= 1'd0;\n            rx_fifo_full       <= 1'd1;\n            end\n        else if ( rx_fifo_pop )\n            begin\n            rx_fifo_empty      <= 1'd1;\n            rx_fifo_full       <= 1'd0;\n            end\n        end\n    end",
        "assign rx_fifo_pop           = wb_start_read && i_wb_adr[15:0] == AMBER_UART_DR;\nassign rx_fifo_push_not_full = rx_fifo_push && !rx_fifo_full;\nassign rx_fifo_pop_not_empty = rx_fifo_pop && !rx_fifo_empty;\nassign rx_fifo_half_or_more  = rx_fifo_count >= 5'd8;\n",
        "generate\nif (WB_DWIDTH == 128) \n    begin : wb128\n    assign wb_wdata32   = i_wb_adr[3:2] == 2'd3 ? i_wb_dat[127:96] :\n                          i_wb_adr[3:2] == 2'd2 ? i_wb_dat[ 95:64] :\n                          i_wb_adr[3:2] == 2'd1 ? i_wb_dat[ 63:32] :\n                                                  i_wb_dat[ 31: 0] ;\n                                                                                                                                            \n    assign o_wb_dat    = {4{wb_rdata32}};\n    end\nelse\n    begin : wb32\n    assign wb_wdata32  = i_wb_dat;\n    assign o_wb_dat    = wb_rdata32;\n    end\nendgenerate",
        "assign o_wb_ack = i_wb_stb && ( wb_start_write || wb_start_read_d1 );",
        "assign o_wb_err = 1'd0;",
        "always @( posedge i_clk )\n    wb_start_read_d1 <= wb_start_read;\n"
    ]
}