{
    "spec": "Module name: infrastructure. \n\nModule specification: \n\nThe \"infrastructure\" module is a fundamental structure that manages the clocking configuration in a digital system. This module employs either differential or single-ended input clock types through an input buffer ('IBUFGDS' or 'IBUFG'). A Phase Locked Loop (PLL) defined by 'PLL_ADV' generates multiple targeted frequency outputs from the primary input clock after necessary division and multiplication. The base clocks are buffered using 'BUFG' and 'BUFGCE' modules, and it also handles the system reset functionality, applying the reset only when the PLL is locked. Connecting the PLL output clocks to the MCB interface, BUFPLL_MCB instance functions. The module generates a delayed clock 'pll_ce_90' in addition to the primary 'pll_ce_0'.\n\nInput ports for this module include 'sys_clk_p', 'sys_clk_n', 'sys_clk', and 'sys_rst_i' which respectively represent the positive terminal of the differential system clock, the negative terminal, the single-ended system clock, and the system reset signal input. The output ports include 'clk0', 'rst0', 'async_rst', 'sysclk_2x', 'sysclk_2x_180', 'mcb_drp_clk', 'pll_ce_0', 'pll_ce_90', and 'pll_lock'. These ports represent the divided clock from PLL, synchronous and asynchronous reset signals, double frequency system clock and its 180-degree phase version, memory controller block clock, primary clock enable signal for PLL, phase-delayed version of `pll_ce_0`, and the locked status indicator of the PLL.\n\nInternal signals like 'clk_2x_0', 'clk_2x_180', 'clk0_bufg', 'clk0_bufg_in', 'mcb_drp_clk_bufg_in', 'clkfbout_clkfbin', 'locked', 'rst0_sync_r', 'rst_tmp', 'powerup_pll_locked', 'syn_clk0_powerup_pll_locked', 'sys_rst', 'bufpll_mcb_locked', and 'sys_clk_ibufg' have been used for various operational controls including output from the PLL, buffered clocks, rest signals, and lock status.\n\nThe code has distinct block structures employing the features of Verilog 'generate' construct and procedures encapsulated under 'always' blocks. Notably, these blocks include differential and single-ended input clock handling blocks, clock generation and buffering blocks, system reset handling blocks, and the primary clock enable generation blocks.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\n\nExplanation: The infrastructure module serves as the fundamental structure for the clocking configuration and management for a digital system. It functions by taking various Input and Output parameters defined as constants. It firstly enables either differential or single-ended input clock types using an input buffer ('IBUFGDS' or 'IBUFG'). Then, a Phase Locked Loop (PLL) defined by 'PLL_ADV' helps to generate multiple targeted frequency outputs from the primary input clock after necessary division and multiplication. Base clocks are buffered using 'BUFG' and 'BUFGCE' modules. Moreover, the module handles the system reset functionality and ensures to apply the reset only when the PLL is locked. The BUFPLL_MCB instance links the PLL output clocks to the MCB interface, and the module also generates a delayed clock 'pll_ce_90' besides the primary clock 'pll_ce_0'. In summary, this module creates reliable clocking infrastructure for high-speed digital designs."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports: \n1. sys_clk_p: Explanation: It is the positive terminal of the differential system clock.\n2. sys_clk_n: Explanation: It is the negative terminal of the differential system clock.\n3. sys_clk: Explanation: It is the system clock input when the system clock is single-ended.\n4. sys_rst_i: Explanation: It is the system reset signal input.\n\nOutput Ports:\n1. clk0: Explanation: The first divided clock generated from the PLL module.\n2. rst0: Explanation: The synchronous reset signal which is synchronized to clock `clk0`.\n3. async_rst: Explanation: The asynchronous reset signal. It becomes active when the system reset is active or the PLL is not locked.\n4. sysclk_2x: Explanation: Double frequency system clock.\n5. sysclk_2x_180: Explanation: Double frequency system clock with 180-degree phase.\n6. mcb_drp_clk: Explanation: Memory controller block (mcb) clock.\n7. pll_ce_0: Explanation: The primary clock enable signal for phase-locked loop (PLL).\n8. pll_ce_90: Explanation: It is the phase delayed (90 degree) version of `pll_ce_0`.\n9. pll_lock: Explanation: It is the lock status indicator of the PLL. This flag is set when the PLL is stable and locked."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal Signals: \n\n1. clk_2x_0\n2. clk_2x_180\n3. clk0_bufg\n4. clk0_bufg_in\n5. mcb_drp_clk_bufg_in\n6. clkfbout_clkfbin\n7. locked\n8. rst0_sync_r\n9. rst_tmp\n10. powerup_pll_locked\n11. syn_clk0_powerup_pll_locked\n12. sys_rst\n13. bufpll_mcb_locked\n14. sys_clk_ibufg\n\nExplanation of each internal signal:\n\n1. clk_2x_0: This is the output from PLL advanced module and serves as one of the primary outputs which provide double the frequency of the input clock.\n\n2. clk_2x_180: This is the output from PLL advanced module and provides a version of the doubled clock with 180-degree phase shift.\n\n3. clk0_bufg: This is the buffered version of the `clk0_bufg_in`, after using the clock buffer 'BUFG'.\n\n4. clk0_bufg_in: This is the input to the 'BUFG' for generating `clk0_bufg`.\n\n5. mcb_drp_clk_bufg_in: This is the input to the 'BUFGCE' for generating `mcb_drp_clk`.\n\n6. clkfbout_clkfbin: This wire is looped in and out of the PLL device to generate the feedback mechnaism needed for the PLL's operation.\n\n7. locked: This wire is the output of the PLL module, indicating the lock status of the clock signal.\n\n8. rst0_sync_r: This is the synchronous version of the reset signal, represented as a shift register to synchronize with `clk0_bufg`.\n\n9. rst_tmp: This is a intermediate signal combining the system reset and the unlocked state of the PLL.\n\n10. powerup_pll_locked: This signal is used to hold the lock state of the PLL module during the power-up sequence.\n\n11. syn_clk0_powerup_pll_locked: This signal represents the locked status of the PLL, synchronized with the `clk0_bufg` signal.\n\n12. sys_rst: This is the system reset signal which is inverse of `sys_rst_i` for active low configuration.\n\n13. bufpll_mcb_locked: This functionally represents the lock status of BUFPLL_MCB module.\n\n14. sys_clk_ibufg: This signal represents the buffered system clock after passing through the input buffer (either 'IBUFGDS' or 'IBUFG')."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: infrastructure. \n\nModule specification: \n\nThe \"infrastructure\" module is a fundamental structure that manages the clocking configuration in a digital system. This module employs either differential or single-ended input clock types through an input buffer ('IBUFGDS' or 'IBUFG'). A Phase Locked Loop (PLL) defined by 'PLL_ADV' generates multiple targeted frequency outputs from the primary input clock after necessary division and multiplication. The base clocks are buffered using 'BUFG' and 'BUFGCE' modules, and it also handles the system reset functionality, applying the reset only when the PLL is locked. Connecting the PLL output clocks to the MCB interface, BUFPLL_MCB instance functions. The module generates a delayed clock 'pll_ce_90' in addition to the primary 'pll_ce_0'.\n\nInput ports for this module include 'sys_clk_p', 'sys_clk_n', 'sys_clk', and 'sys_rst_i' which respectively represent the positive terminal of the differential system clock, the negative terminal, the single-ended system clock, and the system reset signal input. The output ports include 'clk0', 'rst0', 'async_rst', 'sysclk_2x', 'sysclk_2x_180', 'mcb_drp_clk', 'pll_ce_0', 'pll_ce_90', and 'pll_lock'. These ports represent the divided clock from PLL, synchronous and asynchronous reset signals, double frequency system clock and its 180-degree phase version, memory controller block clock, primary clock enable signal for PLL, phase-delayed version of `pll_ce_0`, and the locked status indicator of the PLL.\n\nInternal signals like 'clk_2x_0', 'clk_2x_180', 'clk0_bufg', 'clk0_bufg_in', 'mcb_drp_clk_bufg_in', 'clkfbout_clkfbin', 'locked', 'rst0_sync_r', 'rst_tmp', 'powerup_pll_locked', 'syn_clk0_powerup_pll_locked', 'sys_rst', 'bufpll_mcb_locked', and 'sys_clk_ibufg' have been used for various operational controls including output from the PLL, buffered clocks, rest signals, and lock status.\n\nThe code has distinct block structures employing the features of Verilog 'generate' construct and procedures encapsulated under 'always' blocks. Notably, these blocks include differential and single-ended input clock handling blocks, clock generation and buffering blocks, system reset handling blocks, and the primary clock enable generation blocks."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\n\nExplanation: The infrastructure module serves as the fundamental structure for the clocking configuration and management for a digital system. It functions by taking various Input and Output parameters defined as constants. It firstly enables either differential or single-ended input clock types using an input buffer ('IBUFGDS' or 'IBUFG'). Then, a Phase Locked Loop (PLL) defined by 'PLL_ADV' helps to generate multiple targeted frequency outputs from the primary input clock after necessary division and multiplication. Base clocks are buffered using 'BUFG' and 'BUFGCE' modules. Moreover, the module handles the system reset functionality and ensures to apply the reset only when the PLL is locked. The BUFPLL_MCB instance links the PLL output clocks to the MCB interface, and the module also generates a delayed clock 'pll_ce_90' besides the primary clock 'pll_ce_0'. In summary, this module creates reliable clocking infrastructure for high-speed digital designs."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports: \n1. sys_clk_p: Explanation: It is the positive terminal of the differential system clock.\n2. sys_clk_n: Explanation: It is the negative terminal of the differential system clock.\n3. sys_clk: Explanation: It is the system clock input when the system clock is single-ended.\n4. sys_rst_i: Explanation: It is the system reset signal input.\n\nOutput Ports:\n1. clk0: Explanation: The first divided clock generated from the PLL module.\n2. rst0: Explanation: The synchronous reset signal which is synchronized to clock `clk0`.\n3. async_rst: Explanation: The asynchronous reset signal. It becomes active when the system reset is active or the PLL is not locked.\n4. sysclk_2x: Explanation: Double frequency system clock.\n5. sysclk_2x_180: Explanation: Double frequency system clock with 180-degree phase.\n6. mcb_drp_clk: Explanation: Memory controller block (mcb) clock.\n7. pll_ce_0: Explanation: The primary clock enable signal for phase-locked loop (PLL).\n8. pll_ce_90: Explanation: It is the phase delayed (90 degree) version of `pll_ce_0`.\n9. pll_lock: Explanation: It is the lock status indicator of the PLL. This flag is set when the PLL is stable and locked."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal Signals: \n\n1. clk_2x_0\n2. clk_2x_180\n3. clk0_bufg\n4. clk0_bufg_in\n5. mcb_drp_clk_bufg_in\n6. clkfbout_clkfbin\n7. locked\n8. rst0_sync_r\n9. rst_tmp\n10. powerup_pll_locked\n11. syn_clk0_powerup_pll_locked\n12. sys_rst\n13. bufpll_mcb_locked\n14. sys_clk_ibufg\n\nExplanation of each internal signal:\n\n1. clk_2x_0: This is the output from PLL advanced module and serves as one of the primary outputs which provide double the frequency of the input clock.\n\n2. clk_2x_180: This is the output from PLL advanced module and provides a version of the doubled clock with 180-degree phase shift.\n\n3. clk0_bufg: This is the buffered version of the `clk0_bufg_in`, after using the clock buffer 'BUFG'.\n\n4. clk0_bufg_in: This is the input to the 'BUFG' for generating `clk0_bufg`.\n\n5. mcb_drp_clk_bufg_in: This is the input to the 'BUFGCE' for generating `mcb_drp_clk`.\n\n6. clkfbout_clkfbin: This wire is looped in and out of the PLL device to generate the feedback mechnaism needed for the PLL's operation.\n\n7. locked: This wire is the output of the PLL module, indicating the lock status of the clock signal.\n\n8. rst0_sync_r: This is the synchronous version of the reset signal, represented as a shift register to synchronize with `clk0_bufg`.\n\n9. rst_tmp: This is a intermediate signal combining the system reset and the unlocked state of the PLL.\n\n10. powerup_pll_locked: This signal is used to hold the lock state of the PLL module during the power-up sequence.\n\n11. syn_clk0_powerup_pll_locked: This signal represents the locked status of the PLL, synchronized with the `clk0_bufg` signal.\n\n12. sys_rst: This is the system reset signal which is inverse of `sys_rst_i` for active low configuration.\n\n13. bufpll_mcb_locked: This functionally represents the lock status of BUFPLL_MCB module.\n\n14. sys_clk_ibufg: This signal represents the buffered system clock after passing through the input buffer (either 'IBUFGDS' or 'IBUFG')."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: infrastructure. \n\nModule specification: \n\nThe \"infrastructure\" module is a fundamental structure that manages the clocking configuration in a digital system. This module employs either differential or single-ended input clock types through an input buffer ('IBUFGDS' or 'IBUFG'). A Phase Locked Loop (PLL) defined by 'PLL_ADV' generates multiple targeted frequency outputs from the primary input clock after necessary division and multiplication. The base clocks are buffered using 'BUFG' and 'BUFGCE' modules, and it also handles the system reset functionality, applying the reset only when the PLL is locked. Connecting the PLL output clocks to the MCB interface, BUFPLL_MCB instance functions. The module generates a delayed clock 'pll_ce_90' in addition to the primary 'pll_ce_0'.\n\nInput ports for this module include 'sys_clk_p', 'sys_clk_n', 'sys_clk', and 'sys_rst_i' which respectively represent the positive terminal of the differential system clock, the negative terminal, the single-ended system clock, and the system reset signal input. The output ports include 'clk0', 'rst0', 'async_rst', 'sysclk_2x', 'sysclk_2x_180', 'mcb_drp_clk', 'pll_ce_0', 'pll_ce_90', and 'pll_lock'. These ports represent the divided clock from PLL, synchronous and asynchronous reset signals, double frequency system clock and its 180-degree phase version, memory controller block clock, primary clock enable signal for PLL, phase-delayed version of `pll_ce_0`, and the locked status indicator of the PLL.\n\nInternal signals like 'clk_2x_0', 'clk_2x_180', 'clk0_bufg', 'clk0_bufg_in', 'mcb_drp_clk_bufg_in', 'clkfbout_clkfbin', 'locked', 'rst0_sync_r', 'rst_tmp', 'powerup_pll_locked', 'syn_clk0_powerup_pll_locked', 'sys_rst', 'bufpll_mcb_locked', and 'sys_clk_ibufg' have been used for various operational controls including output from the PLL, buffered clocks, rest signals, and lock status.\n\nThe code has distinct block structures employing the features of Verilog 'generate' construct and procedures encapsulated under 'always' blocks. Notably, these blocks include differential and single-ended input clock handling blocks, clock generation and buffering blocks, system reset handling blocks, and the primary clock enable generation blocks."
                }
            ]
        }
    ]
}