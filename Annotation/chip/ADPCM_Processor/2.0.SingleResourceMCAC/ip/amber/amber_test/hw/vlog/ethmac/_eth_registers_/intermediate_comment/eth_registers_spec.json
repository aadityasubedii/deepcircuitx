{
    "spec": "Module name: eth_registers. Module specification: This module implements the Ethernet controller's register block, handling various configuration and status registers for Ethernet operations. It has input ports for data (DataIn), address (Address), read/write control (Rw), chip select (Cs), clock (Clk), reset (Reset), and various control and status signals. Output ports include data output (DataOut), configuration settings (e.g., r_RecSmall, r_Pad, r_HugEn), timing parameters (e.g., r_IPGT, r_IPGR1, r_IPGR2), MAC address (r_MAC), and interrupt output (int_o). Internal signals include register selection signals (e.g., MODER_Sel, INT_SOURCE_Sel), write signals (e.g., MODER_Wr, INT_SOURCE_",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: eth_registers\n\nExplanation: This module implements the Ethernet controller's register block. It handles various configuration and status registers for Ethernet operations, including MAC address, interrupt handling, MII (Media Independent Interface) control, flow control, and other Ethernet-specific parameters. The module provides read and write access to these registers, synchronizes signals between different clock domains, and generates interrupt signals based on various Ethernet events. It plays a crucial role in controlling and monitoring the Ethernet controller's behavior."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nDataIn, Address, Rw, Cs, Clk, Reset, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg, Prsd, TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, NValid_stat, Busy_stat, LinkFail, RstTxPauseRq, TxCtrlEndFrm, StartTxDone, TxClk, RxClk, SetPauseTimer.\n\nExplanation:\nThese inputs handle data input, addressing, read/write control, clock signals, reset, various interrupt requests, MII status signals, and control signals for Ethernet operations.\n\nOutput ports:\nDataOut, r_RecSmall, r_Pad, r_HugEn, r_CrcEn, r_DlyCrcEn, r_FullD, r_ExDfrEn, r_NoBckof, r_LoopBck, r_IFG, r_Pro, r_Iam, r_Bro, r_NoPre, r_TxEn, r_RxEn, r_IPGT, r_IPGR1, r_IPGR2, r_MinFL, r_MaxFL, r_MaxRet, r_CollValid, r_TxFlow, r_RxFlow, r_PassAll, r_MiiNoPre, r_ClkDiv, r_WCtrlData, r_RStat, r_ScanStat, r_RGAD, r_FIAD, r_CtrlData, r_MAC, r_TxBDNum, int_o, r_HASH0, r_HASH1, r_TxPauseTV, r_TxPauseRq.\n\nExplanation:\nThese outputs provide data output, various configuration settings (e.g., padding, CRC, flow control), timing parameters (e.g., inter-packet gap), MII control signals, MAC address, transmit buffer descriptor number, interrupt output, and other Ethernet control signals. They reflect the current state of the Ethernet controller's configuration registers."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nDataOut, Write, Read, MODER_Sel, INT_SOURCE_Sel, INT_MASK_Sel, IPGT_Sel, IPGR1_Sel, IPGR2_Sel, PACKETLEN_Sel, COLLCONF_Sel, CTRLMODER_Sel, MIIMODER_Sel, MIICOMMAND_Sel, MIIADDRESS_Sel, MIITX_DATA_Sel, MAC_ADDR0_Sel, MAC_ADDR1_Sel, HASH0_Sel, HASH1_Sel, TXCTRL_Sel, TX_BD_NUM_Sel, MODER_Wr, INT_SOURCE_Wr, INT_MASK_Wr, IPGT_Wr, IPGR1_Wr, IPGR2_Wr, PACKETLEN_Wr, COLLCONF_Wr, CTRLMODER_Wr, MIIMODER_Wr, MIICOMMAND_Wr, MIIADDRESS_Wr, MIITX_DATA_Wr, MIIRX_DATA_Wr, MAC_ADDR0_Wr, MAC_ADDR1_Wr, HASH0_Wr, HASH1_Wr, TXCTRL_Wr, TX_BD_NUM_Wr, MODEROut, INT_SOURCEOut, INT_MASKOut, IPGTOut, IPGR1Out, IPGR2Out, PACKETLENOut, COLLCONFOut, CTRLMODEROut, MIIMODEROut, MIICOMMANDOut, MIIADDRESSOut, MIITX_DATAOut, MIIRX_DATAOut, MIISTATUSOut, MAC_ADDR0Out, MAC_ADDR1Out, TX_BD_NUMOut, HASH0Out, HASH1Out, TXCTRLOut, irq_txb, irq_txe, irq_rxb, irq_rxe, irq_busy, irq_txc, irq_rxc, SetTxCIrq_txclk, SetTxCIrq_sync1, SetTxCIrq_sync2, SetTxCIrq_sync3, SetTxCIrq, ResetTxCIrq_sync1, ResetTxCIrq_sync2, SetRxCIrq_rxclk, SetRxCIrq_sync1, SetRxCIrq_sync2, SetRxCIrq_sync3, SetRxCIrq, ResetRxCIrq_sync1, ResetRxCIrq_sync2, ResetRxCIrq_sync3.\n\nExplanation:\nThese internal signals serve various purposes within the module:\n1. Register selection signals (e.g., MODER_Sel, INT_SOURCE_Sel) are used to select specific registers based on the input Address.\n2. Write signals (e.g., MODER_Wr, INT_SOURCE_Wr) control write operations to specific registers or register sections.\n3. Output signals (e.g., MODEROut, INT_SOURCEOut) store the current values of various registers.\n4. Interrupt-related signals (e.g., irq_txb, irq_txe) track different types of interrupts.\n5. Synchronization signals (e.g., SetTxCIrq_sync1, SetTxCIrq_sync2) are used to synchronize control signals between different clock domains.\n6. The DataOut signal is used to output register values during read operations.\n\nThese signals collectively manage the Ethernet controller's register operations, interrupt handling, and cross-domain signal synchronization."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_registers( DataIn, Address, Rw, Cs, Clk, Reset, DataOut, \n                      r_RecSmall, r_Pad, r_HugEn, r_CrcEn, r_DlyCrcEn, \n                      r_FullD, r_ExDfrEn, r_NoBckof, r_LoopBck, r_IFG, \n                      r_Pro, r_Iam, r_Bro, r_NoPre, r_TxEn, r_RxEn, \n                      TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, \n                      r_IPGT, r_IPGR1, r_IPGR2, r_MinFL, r_MaxFL, r_MaxRet, \n                      r_CollValid, r_TxFlow, r_RxFlow, r_PassAll, \n                      r_MiiNoPre, r_ClkDiv, r_WCtrlData, r_RStat, r_ScanStat, \n                      r_RGAD, r_FIAD, r_CtrlData, NValid_stat, Busy_stat, \n                      LinkFail, r_MAC, WCtrlDataStart, RStatStart,\n                      UpdateMIIRX_DATAReg, Prsd, r_TxBDNum, int_o,\n                      r_HASH0, r_HASH1, r_TxPauseTV, r_TxPauseRq, RstTxPauseRq, TxCtrlEndFrm, \n                      StartTxDone, TxClk, RxClk, SetPauseTimer\n                    );\n\nparameter Tp = 1;\n\ninput [31:0] DataIn;\ninput [7:0] Address;\n\ninput Rw;\ninput [3:0] Cs;\ninput Clk;\ninput Reset;\n\ninput WCtrlDataStart;\ninput RStatStart;\n\ninput UpdateMIIRX_DATAReg;\ninput [15:0] Prsd;\n\noutput [31:0] DataOut;\nreg    [31:0] DataOut;\n\noutput r_RecSmall;\noutput r_Pad;\noutput r_HugEn;\noutput r_CrcEn;\noutput r_DlyCrcEn;\noutput r_FullD;\noutput r_ExDfrEn;\noutput r_NoBckof;\noutput r_LoopBck;\noutput r_IFG;\noutput r_Pro;\noutput r_Iam;\noutput r_Bro;\noutput r_NoPre;\noutput r_TxEn;\noutput r_RxEn;\noutput [31:0] r_HASH0;\noutput [31:0] r_HASH1;\n\ninput TxB_IRQ;\ninput TxE_IRQ;\ninput RxB_IRQ;\ninput RxE_IRQ;\ninput Busy_IRQ;\n\noutput [6:0] r_IPGT;\n\noutput [6:0] r_IPGR1;\n\noutput [6:0] r_IPGR2;\n\noutput [15:0] r_MinFL;\noutput [15:0] r_MaxFL;\n\noutput [3:0] r_MaxRet;\noutput [5:0] r_CollValid;\n\noutput r_TxFlow;\noutput r_RxFlow;\noutput r_PassAll;\n\noutput r_MiiNoPre;\noutput [7:0] r_ClkDiv;\n\noutput r_WCtrlData;\noutput r_RStat;\noutput r_ScanStat;\n\noutput [4:0] r_RGAD;\noutput [4:0] r_FIAD;\n\noutput [15:0]r_CtrlData;\n\n\ninput NValid_stat;\ninput Busy_stat;\ninput LinkFail;\n\noutput [47:0]r_MAC;\noutput [7:0] r_TxBDNum;\noutput       int_o;\noutput [15:0]r_TxPauseTV;\noutput       r_TxPauseRq;\ninput        RstTxPauseRq;\ninput        TxCtrlEndFrm;\ninput        StartTxDone;\ninput        TxClk;\ninput        RxClk;\ninput        SetPauseTimer;\n\nreg          irq_txb;\nreg          irq_txe;\nreg          irq_rxb;\nreg          irq_rxe;\nreg          irq_busy;\nreg          irq_txc;\nreg          irq_rxc;\n\nreg SetTxCIrq_txclk;\nreg SetTxCIrq_sync1, SetTxCIrq_sync2, SetTxCIrq_sync3;\nreg SetTxCIrq;\nreg ResetTxCIrq_sync1, ResetTxCIrq_sync2;\n\nreg SetRxCIrq_rxclk;\nreg SetRxCIrq_sync1, SetRxCIrq_sync2, SetRxCIrq_sync3;\nreg SetRxCIrq;\nreg ResetRxCIrq_sync1;\nreg ResetRxCIrq_sync2;\nreg ResetRxCIrq_sync3;\n\nwire [3:0] Write =   Cs  & {4{Rw}};\nwire       Read  = (|Cs) &   ~Rw;\n\nwire MODER_Sel      = (Address == `ETH_MODER_ADR       );\nwire INT_SOURCE_Sel = (Address == `ETH_INT_SOURCE_ADR  );\nwire INT_MASK_Sel   = (Address == `ETH_INT_MASK_ADR    );\nwire IPGT_Sel       = (Address == `ETH_IPGT_ADR        );\nwire IPGR1_Sel      = (Address == `ETH_IPGR1_ADR       );\nwire IPGR2_Sel      = (Address == `ETH_IPGR2_ADR       );\nwire PACKETLEN_Sel  = (Address == `ETH_PACKETLEN_ADR   );\nwire COLLCONF_Sel   = (Address == `ETH_COLLCONF_ADR    );\n     \nwire CTRLMODER_Sel  = (Address == `ETH_CTRLMODER_ADR   );\nwire MIIMODER_Sel   = (Address == `ETH_MIIMODER_ADR    );\nwire MIICOMMAND_Sel = (Address == `ETH_MIICOMMAND_ADR  );\nwire MIIADDRESS_Sel = (Address == `ETH_MIIADDRESS_ADR  );\nwire MIITX_DATA_Sel = (Address == `ETH_MIITX_DATA_ADR  );\nwire MAC_ADDR0_Sel  = (Address == `ETH_MAC_ADDR0_ADR   );\nwire MAC_ADDR1_Sel  = (Address == `ETH_MAC_ADDR1_ADR   );\nwire HASH0_Sel      = (Address == `ETH_HASH0_ADR       );\nwire HASH1_Sel      = (Address == `ETH_HASH1_ADR       );\nwire TXCTRL_Sel     = (Address == `ETH_TX_CTRL_ADR     );\nwire RXCTRL_Sel     = (Address == `ETH_RX_CTRL_ADR     );\nwire TX_BD_NUM_Sel  = (Address == `ETH_TX_BD_NUM_ADR   );\n\n\nwire [2:0] MODER_Wr;\nwire [0:0] INT_SOURCE_Wr;\nwire [0:0] INT_MASK_Wr;\nwire [0:0] IPGT_Wr;\nwire [0:0] IPGR1_Wr;\nwire [0:0] IPGR2_Wr;\nwire [3:0] PACKETLEN_Wr;\nwire [2:0] COLLCONF_Wr;\nwire [0:0] CTRLMODER_Wr;\nwire [1:0] MIIMODER_Wr;\nwire [0:0] MIICOMMAND_Wr;\nwire [1:0] MIIADDRESS_Wr;\nwire [1:0] MIITX_DATA_Wr;\nwire       MIIRX_DATA_Wr;\nwire [3:0] MAC_ADDR0_Wr;\nwire [1:0] MAC_ADDR1_Wr;\nwire [3:0] HASH0_Wr;\nwire [3:0] HASH1_Wr;\nwire [2:0] TXCTRL_Wr;\nwire [0:0] TX_BD_NUM_Wr;\n\nassign MODER_Wr[0]       = Write[0]  & MODER_Sel; \nassign MODER_Wr[1]       = Write[1]  & MODER_Sel; \nassign MODER_Wr[2]       = Write[2]  & MODER_Sel; \nassign INT_SOURCE_Wr[0]  = Write[0]  & INT_SOURCE_Sel; \nassign INT_MASK_Wr[0]    = Write[0]  & INT_MASK_Sel; \nassign IPGT_Wr[0]        = Write[0]  & IPGT_Sel; \nassign IPGR1_Wr[0]       = Write[0]  & IPGR1_Sel; \nassign IPGR2_Wr[0]       = Write[0]  & IPGR2_Sel; \nassign PACKETLEN_Wr[0]   = Write[0]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[1]   = Write[1]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[2]   = Write[2]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[3]   = Write[3]  & PACKETLEN_Sel; \nassign COLLCONF_Wr[0]    = Write[0]  & COLLCONF_Sel; \nassign COLLCONF_Wr[1]    = 1'b0;  \nassign COLLCONF_Wr[2]    = Write[2]  & COLLCONF_Sel; \n     \nassign CTRLMODER_Wr[0]   = Write[0]  & CTRLMODER_Sel; \nassign MIIMODER_Wr[0]    = Write[0]  & MIIMODER_Sel; \nassign MIIMODER_Wr[1]    = Write[1]  & MIIMODER_Sel; \nassign MIICOMMAND_Wr[0]  = Write[0]  & MIICOMMAND_Sel; \nassign MIIADDRESS_Wr[0]  = Write[0]  & MIIADDRESS_Sel; \nassign MIIADDRESS_Wr[1]  = Write[1]  & MIIADDRESS_Sel; \nassign MIITX_DATA_Wr[0]  = Write[0]  & MIITX_DATA_Sel; \nassign MIITX_DATA_Wr[1]  = Write[1]  & MIITX_DATA_Sel; \nassign MIIRX_DATA_Wr     = UpdateMIIRX_DATAReg;     \nassign MAC_ADDR0_Wr[0]   = Write[0]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[1]   = Write[1]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[2]   = Write[2]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[3]   = Write[3]  & MAC_ADDR0_Sel; \nassign MAC_ADDR1_Wr[0]   = Write[0]  & MAC_ADDR1_Sel; \nassign MAC_ADDR1_Wr[1]   = Write[1]  & MAC_ADDR1_Sel; \nassign HASH0_Wr[0]       = Write[0]  & HASH0_Sel; \nassign HASH0_Wr[1]       = Write[1]  & HASH0_Sel; \nassign HASH0_Wr[2]       = Write[2]  & HASH0_Sel; \nassign HASH0_Wr[3]       = Write[3]  & HASH0_Sel; \nassign HASH1_Wr[0]       = Write[0]  & HASH1_Sel; \nassign HASH1_Wr[1]       = Write[1]  & HASH1_Sel; \nassign HASH1_Wr[2]       = Write[2]  & HASH1_Sel; \nassign HASH1_Wr[3]       = Write[3]  & HASH1_Sel; \nassign TXCTRL_Wr[0]      = Write[0]  & TXCTRL_Sel; \nassign TXCTRL_Wr[1]      = Write[1]  & TXCTRL_Sel; \nassign TXCTRL_Wr[2]      = Write[2]  & TXCTRL_Sel; \nassign TX_BD_NUM_Wr[0]   = Write[0]  & TX_BD_NUM_Sel & (DataIn<='h80); \n\n\n\nwire [31:0] MODEROut;\nwire [31:0] INT_SOURCEOut;\nwire [31:0] INT_MASKOut;\nwire [31:0] IPGTOut;\nwire [31:0] IPGR1Out;\nwire [31:0] IPGR2Out;\nwire [31:0] PACKETLENOut;\nwire [31:0] COLLCONFOut;\nwire [31:0] CTRLMODEROut;\nwire [31:0] MIIMODEROut;\nwire [31:0] MIICOMMANDOut;\nwire [31:0] MIIADDRESSOut;\nwire [31:0] MIITX_DATAOut;\nwire [31:0] MIIRX_DATAOut;\nwire [31:0] MIISTATUSOut;\nwire [31:0] MAC_ADDR0Out;\nwire [31:0] MAC_ADDR1Out;\nwire [31:0] TX_BD_NUMOut;\nwire [31:0] HASH0Out;\nwire [31:0] HASH1Out;\nwire [31:0] TXCTRLOut;\n\n\neth_register #(`ETH_MODER_WIDTH_0, `ETH_MODER_DEF_0)        MODER_0\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_0 - 1:0]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_0 - 1:0]),\n   .Write     (MODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MODER_WIDTH_1, `ETH_MODER_DEF_1)        MODER_1\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_1 + 7:8]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_1 + 7:8]),\n   .Write     (MODER_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MODER_WIDTH_2, `ETH_MODER_DEF_2)        MODER_2\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_2 + 15:16]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_2 + 15:16]),\n   .Write     (MODER_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MODEROut[31:`ETH_MODER_WIDTH_2 + 16] = 0;\n\n\neth_register #(`ETH_INT_MASK_WIDTH_0, `ETH_INT_MASK_DEF_0)  INT_MASK_0\n  (\n   .DataIn    (DataIn[`ETH_INT_MASK_WIDTH_0 - 1:0]),  \n   .DataOut   (INT_MASKOut[`ETH_INT_MASK_WIDTH_0 - 1:0]),\n   .Write     (INT_MASK_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign INT_MASKOut[31:`ETH_INT_MASK_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGT_WIDTH_0, `ETH_IPGT_DEF_0)          IPGT_0\n  (\n   .DataIn    (DataIn[`ETH_IPGT_WIDTH_0 - 1:0]),\n   .DataOut   (IPGTOut[`ETH_IPGT_WIDTH_0 - 1:0]),\n   .Write     (IPGT_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGTOut[31:`ETH_IPGT_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGR1_WIDTH_0, `ETH_IPGR1_DEF_0)        IPGR1_0\n  (\n   .DataIn    (DataIn[`ETH_IPGR1_WIDTH_0 - 1:0]),\n   .DataOut   (IPGR1Out[`ETH_IPGR1_WIDTH_0 - 1:0]),\n   .Write     (IPGR1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGR1Out[31:`ETH_IPGR1_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGR2_WIDTH_0, `ETH_IPGR2_DEF_0)        IPGR2_0\n  (\n   .DataIn    (DataIn[`ETH_IPGR2_WIDTH_0 - 1:0]),\n   .DataOut   (IPGR2Out[`ETH_IPGR2_WIDTH_0 - 1:0]),\n   .Write     (IPGR2_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGR2Out[31:`ETH_IPGR2_WIDTH_0] = 0;\n\n\neth_register #(`ETH_PACKETLEN_WIDTH_0, `ETH_PACKETLEN_DEF_0) PACKETLEN_0\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_0 - 1:0]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_0 - 1:0]),\n   .Write     (PACKETLEN_Wr[0]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_1, `ETH_PACKETLEN_DEF_1) PACKETLEN_1\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_1 + 7:8]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_1 + 7:8]),\n   .Write     (PACKETLEN_Wr[1]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_2, `ETH_PACKETLEN_DEF_2) PACKETLEN_2\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_2 + 15:16]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_2 + 15:16]),\n   .Write     (PACKETLEN_Wr[2]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_3, `ETH_PACKETLEN_DEF_3) PACKETLEN_3\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_3 + 23:24]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_3 + 23:24]),\n   .Write     (PACKETLEN_Wr[3]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_COLLCONF_WIDTH_0, `ETH_COLLCONF_DEF_0)   COLLCONF_0\n  (\n   .DataIn    (DataIn[`ETH_COLLCONF_WIDTH_0 - 1:0]),\n   .DataOut   (COLLCONFOut[`ETH_COLLCONF_WIDTH_0 - 1:0]),\n   .Write     (COLLCONF_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_COLLCONF_WIDTH_2, `ETH_COLLCONF_DEF_2)   COLLCONF_2\n  (\n   .DataIn    (DataIn[`ETH_COLLCONF_WIDTH_2 + 15:16]),\n   .DataOut   (COLLCONFOut[`ETH_COLLCONF_WIDTH_2 + 15:16]),\n   .Write     (COLLCONF_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign COLLCONFOut[15:`ETH_COLLCONF_WIDTH_0] = 0;\nassign COLLCONFOut[31:`ETH_COLLCONF_WIDTH_2 + 16] = 0;\n\n\neth_register #(`ETH_TX_BD_NUM_WIDTH_0, `ETH_TX_BD_NUM_DEF_0) TX_BD_NUM_0\n  (\n   .DataIn    (DataIn[`ETH_TX_BD_NUM_WIDTH_0 - 1:0]),\n   .DataOut   (TX_BD_NUMOut[`ETH_TX_BD_NUM_WIDTH_0 - 1:0]),\n   .Write     (TX_BD_NUM_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign TX_BD_NUMOut[31:`ETH_TX_BD_NUM_WIDTH_0] = 0;\n\n\neth_register #(`ETH_CTRLMODER_WIDTH_0, `ETH_CTRLMODER_DEF_0)  CTRLMODER_0\n  (\n   .DataIn    (DataIn[`ETH_CTRLMODER_WIDTH_0 - 1:0]),\n   .DataOut   (CTRLMODEROut[`ETH_CTRLMODER_WIDTH_0 - 1:0]),\n   .Write     (CTRLMODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign CTRLMODEROut[31:`ETH_CTRLMODER_WIDTH_0] = 0;\n\n\neth_register #(`ETH_MIIMODER_WIDTH_0, `ETH_MIIMODER_DEF_0)    MIIMODER_0\n  (\n   .DataIn    (DataIn[`ETH_MIIMODER_WIDTH_0 - 1:0]),\n   .DataOut   (MIIMODEROut[`ETH_MIIMODER_WIDTH_0 - 1:0]),\n   .Write     (MIIMODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIIMODER_WIDTH_1, `ETH_MIIMODER_DEF_1)    MIIMODER_1\n  (\n   .DataIn    (DataIn[`ETH_MIIMODER_WIDTH_1 + 7:8]),\n   .DataOut   (MIIMODEROut[`ETH_MIIMODER_WIDTH_1 + 7:8]),\n   .Write     (MIIMODER_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIMODEROut[31:`ETH_MIIMODER_WIDTH_1 + 8] = 0;\n\n\neth_register #(1, 0)                                      MIICOMMAND0\n  (\n   .DataIn    (DataIn[0]),\n   .DataOut   (MIICOMMANDOut[0]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(1, 0)                                      MIICOMMAND1\n  (\n   .DataIn    (DataIn[1]),\n   .DataOut   (MIICOMMANDOut[1]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (RStatStart)\n  );\neth_register #(1, 0)                                      MIICOMMAND2\n  (\n   .DataIn    (DataIn[2]),\n   .DataOut   (MIICOMMANDOut[2]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (WCtrlDataStart)\n  );\nassign MIICOMMANDOut[31:`ETH_MIICOMMAND_WIDTH_0] = 29'h0;\n\n\neth_register #(`ETH_MIIADDRESS_WIDTH_0, `ETH_MIIADDRESS_DEF_0) MIIADDRESS_0\n  (\n   .DataIn    (DataIn[`ETH_MIIADDRESS_WIDTH_0 - 1:0]),\n   .DataOut   (MIIADDRESSOut[`ETH_MIIADDRESS_WIDTH_0 - 1:0]),\n   .Write     (MIIADDRESS_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIIADDRESS_WIDTH_1, `ETH_MIIADDRESS_DEF_1) MIIADDRESS_1\n  (\n   .DataIn    (DataIn[`ETH_MIIADDRESS_WIDTH_1 + 7:8]),\n   .DataOut   (MIIADDRESSOut[`ETH_MIIADDRESS_WIDTH_1 + 7:8]),\n   .Write     (MIIADDRESS_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIADDRESSOut[7:`ETH_MIIADDRESS_WIDTH_0] = 0;\nassign MIIADDRESSOut[31:`ETH_MIIADDRESS_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_MIITX_DATA_WIDTH_0, `ETH_MIITX_DATA_DEF_0) MIITX_DATA_0\n  (\n   .DataIn    (DataIn[`ETH_MIITX_DATA_WIDTH_0 - 1:0]),\n   .DataOut   (MIITX_DATAOut[`ETH_MIITX_DATA_WIDTH_0 - 1:0]), \n   .Write     (MIITX_DATA_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIITX_DATA_WIDTH_1, `ETH_MIITX_DATA_DEF_1) MIITX_DATA_1\n  (\n   .DataIn    (DataIn[`ETH_MIITX_DATA_WIDTH_1 + 7:8]),\n   .DataOut   (MIITX_DATAOut[`ETH_MIITX_DATA_WIDTH_1 + 7:8]), \n   .Write     (MIITX_DATA_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIITX_DATAOut[31:`ETH_MIITX_DATA_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_MIIRX_DATA_WIDTH, `ETH_MIIRX_DATA_DEF) MIIRX_DATA\n  (\n   .DataIn    (Prsd[`ETH_MIIRX_DATA_WIDTH-1:0]),\n   .DataOut   (MIIRX_DATAOut[`ETH_MIIRX_DATA_WIDTH-1:0]),\n   .Write     (MIIRX_DATA_Wr), \n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIRX_DATAOut[31:`ETH_MIIRX_DATA_WIDTH] = 0;\n\n\neth_register #(`ETH_MAC_ADDR0_WIDTH_0, `ETH_MAC_ADDR0_DEF_0)  MAC_ADDR0_0\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_0 - 1:0]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_0 - 1:0]),\n   .Write     (MAC_ADDR0_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_1, `ETH_MAC_ADDR0_DEF_1)  MAC_ADDR0_1\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_1 + 7:8]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_1 + 7:8]),\n   .Write     (MAC_ADDR0_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_2, `ETH_MAC_ADDR0_DEF_2)  MAC_ADDR0_2\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_2 + 15:16]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_2 + 15:16]),\n   .Write     (MAC_ADDR0_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_3, `ETH_MAC_ADDR0_DEF_3)  MAC_ADDR0_3\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_3 + 23:24]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_3 + 23:24]),\n   .Write     (MAC_ADDR0_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_MAC_ADDR1_WIDTH_0, `ETH_MAC_ADDR1_DEF_0)  MAC_ADDR1_0\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR1_WIDTH_0 - 1:0]),\n   .DataOut   (MAC_ADDR1Out[`ETH_MAC_ADDR1_WIDTH_0 - 1:0]),\n   .Write     (MAC_ADDR1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR1_WIDTH_1, `ETH_MAC_ADDR1_DEF_1)  MAC_ADDR1_1\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR1_WIDTH_1 + 7:8]),\n   .DataOut   (MAC_ADDR1Out[`ETH_MAC_ADDR1_WIDTH_1 + 7:8]),\n   .Write     (MAC_ADDR1_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MAC_ADDR1Out[31:`ETH_MAC_ADDR1_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_HASH0_WIDTH_0, `ETH_HASH0_DEF_0)          RXHASH0_0\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_0 - 1:0]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_0 - 1:0]),\n   .Write     (HASH0_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_1, `ETH_HASH0_DEF_1)          RXHASH0_1\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_1 + 7:8]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_1 + 7:8]),\n   .Write     (HASH0_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_2, `ETH_HASH0_DEF_2)          RXHASH0_2\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_2 + 15:16]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_2 + 15:16]),\n   .Write     (HASH0_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_3, `ETH_HASH0_DEF_3)          RXHASH0_3\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_3 + 23:24]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_3 + 23:24]),\n   .Write     (HASH0_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_HASH1_WIDTH_0, `ETH_HASH1_DEF_0)          RXHASH1_0\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_0 - 1:0]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_0 - 1:0]),\n   .Write     (HASH1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_1, `ETH_HASH1_DEF_1)          RXHASH1_1\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_1 + 7:8]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_1 + 7:8]),\n   .Write     (HASH1_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_2, `ETH_HASH1_DEF_2)          RXHASH1_2\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_2 + 15:16]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_2 + 15:16]),\n   .Write     (HASH1_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_3, `ETH_HASH1_DEF_3)          RXHASH1_3\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_3 + 23:24]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_3 + 23:24]),\n   .Write     (HASH1_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_TX_CTRL_WIDTH_0, `ETH_TX_CTRL_DEF_0)  TXCTRL_0\n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_0 - 1:0]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_0 - 1:0]),\n   .Write     (TXCTRL_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_TX_CTRL_WIDTH_1, `ETH_TX_CTRL_DEF_1)  TXCTRL_1\n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_1 + 7:8]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_1 + 7:8]),\n   .Write     (TXCTRL_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_TX_CTRL_WIDTH_2, `ETH_TX_CTRL_DEF_2)  TXCTRL_2 \n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_2 + 15:16]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_2 + 15:16]),\n   .Write     (TXCTRL_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (RstTxPauseRq)\n  );\nassign TXCTRLOut[31:`ETH_TX_CTRL_WIDTH_2 + 16] = 0;\n\n\n\n\nalways @ (Address       or Read           or MODEROut       or INT_SOURCEOut  or\n          INT_MASKOut   or IPGTOut        or IPGR1Out       or IPGR2Out       or\n          PACKETLENOut  or COLLCONFOut    or CTRLMODEROut   or MIIMODEROut    or\n          MIICOMMANDOut or MIIADDRESSOut  or MIITX_DATAOut  or MIIRX_DATAOut  or \n          MIISTATUSOut  or MAC_ADDR0Out   or MAC_ADDR1Out   or TX_BD_NUMOut   or\n          HASH0Out      or HASH1Out       or TXCTRLOut       \n         )\nbegin\n  if(Read)  \n    begin\n      case(Address)\n        `ETH_MODER_ADR        :  DataOut<=MODEROut;\n        `ETH_INT_SOURCE_ADR   :  DataOut<=INT_SOURCEOut;\n        `ETH_INT_MASK_ADR     :  DataOut<=INT_MASKOut;\n        `ETH_IPGT_ADR         :  DataOut<=IPGTOut;\n        `ETH_IPGR1_ADR        :  DataOut<=IPGR1Out;\n        `ETH_IPGR2_ADR        :  DataOut<=IPGR2Out;\n        `ETH_PACKETLEN_ADR    :  DataOut<=PACKETLENOut;\n        `ETH_COLLCONF_ADR     :  DataOut<=COLLCONFOut;\n        `ETH_CTRLMODER_ADR    :  DataOut<=CTRLMODEROut;\n        `ETH_MIIMODER_ADR     :  DataOut<=MIIMODEROut;\n        `ETH_MIICOMMAND_ADR   :  DataOut<=MIICOMMANDOut;\n        `ETH_MIIADDRESS_ADR   :  DataOut<=MIIADDRESSOut;\n        `ETH_MIITX_DATA_ADR   :  DataOut<=MIITX_DATAOut;\n        `ETH_MIIRX_DATA_ADR   :  DataOut<=MIIRX_DATAOut;\n        `ETH_MIISTATUS_ADR    :  DataOut<=MIISTATUSOut;\n        `ETH_MAC_ADDR0_ADR    :  DataOut<=MAC_ADDR0Out;\n        `ETH_MAC_ADDR1_ADR    :  DataOut<=MAC_ADDR1Out;\n        `ETH_TX_BD_NUM_ADR    :  DataOut<=TX_BD_NUMOut;\n        `ETH_HASH0_ADR        :  DataOut<=HASH0Out;\n        `ETH_HASH1_ADR        :  DataOut<=HASH1Out;\n        `ETH_TX_CTRL_ADR      :  DataOut<=TXCTRLOut;\n\n        default:             DataOut<=32'h0;\n      endcase\n    end\n  else\n    DataOut<=32'h0;\nend\n\n\nassign r_RecSmall         = MODEROut[16];\nassign r_Pad              = MODEROut[15];\nassign r_HugEn            = MODEROut[14];\nassign r_CrcEn            = MODEROut[13];\nassign r_DlyCrcEn         = MODEROut[12];\n\nassign r_FullD            = MODEROut[10];\nassign r_ExDfrEn          = MODEROut[9];\nassign r_NoBckof          = MODEROut[8];\nassign r_LoopBck          = MODEROut[7];\nassign r_IFG              = MODEROut[6];\nassign r_Pro              = MODEROut[5];\nassign r_Iam              = MODEROut[4];\nassign r_Bro              = MODEROut[3];\nassign r_NoPre            = MODEROut[2];\nassign r_TxEn             = MODEROut[1] & (TX_BD_NUMOut>0);     \nassign r_RxEn             = MODEROut[0] & (TX_BD_NUMOut<'h80);  \n\nassign r_IPGT[6:0]        = IPGTOut[6:0];\n\nassign r_IPGR1[6:0]       = IPGR1Out[6:0];\n\nassign r_IPGR2[6:0]       = IPGR2Out[6:0];\n\nassign r_MinFL[15:0]      = PACKETLENOut[31:16];\nassign r_MaxFL[15:0]      = PACKETLENOut[15:0];\n\nassign r_MaxRet[3:0]      = COLLCONFOut[19:16];\nassign r_CollValid[5:0]   = COLLCONFOut[5:0];\n\nassign r_TxFlow           = CTRLMODEROut[2];\nassign r_RxFlow           = CTRLMODEROut[1];\nassign r_PassAll          = CTRLMODEROut[0];\n\nassign r_MiiNoPre         = MIIMODEROut[8];\nassign r_ClkDiv[7:0]      = MIIMODEROut[7:0];\n\nassign r_WCtrlData        = MIICOMMANDOut[2];\nassign r_RStat            = MIICOMMANDOut[1];\nassign r_ScanStat         = MIICOMMANDOut[0];\n\nassign r_RGAD[4:0]        = MIIADDRESSOut[12:8];\nassign r_FIAD[4:0]        = MIIADDRESSOut[4:0];\n\nassign r_CtrlData[15:0]   = MIITX_DATAOut[15:0];\n\nassign MIISTATUSOut[31:`ETH_MIISTATUS_WIDTH] = 0; \nassign MIISTATUSOut[2]    = NValid_stat         ; \nassign MIISTATUSOut[1]    = Busy_stat           ; \nassign MIISTATUSOut[0]    = LinkFail            ; \n\nassign r_MAC[31:0]        = MAC_ADDR0Out[31:0];\nassign r_MAC[47:32]       = MAC_ADDR1Out[15:0];\nassign r_HASH1[31:0]      = HASH1Out;\nassign r_HASH0[31:0]      = HASH0Out;\n\nassign r_TxBDNum[7:0]     = TX_BD_NUMOut[7:0];\n\nassign r_TxPauseTV[15:0]  = TXCTRLOut[15:0];\nassign r_TxPauseRq        = TXCTRLOut[16];\n\n\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_txclk <=#Tp 1'b0;\n  else\n  if(TxCtrlEndFrm & StartTxDone & r_TxFlow)\n    SetTxCIrq_txclk <=#Tp 1'b1;\n  else\n  if(ResetTxCIrq_sync2)\n    SetTxCIrq_txclk <=#Tp 1'b0;\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync1 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync1 <=#Tp SetTxCIrq_txclk;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync2 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync2 <=#Tp SetTxCIrq_sync1;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync3 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync3 <=#Tp SetTxCIrq_sync2;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq <=#Tp 1'b0;\n  else\n    SetTxCIrq <=#Tp SetTxCIrq_sync2 & ~SetTxCIrq_sync3;\nend\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetTxCIrq_sync1 <=#Tp 1'b0;\n  else\n    ResetTxCIrq_sync1 <=#Tp SetTxCIrq_sync2;\nend\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetTxCIrq_sync2 <=#Tp 1'b0;\n  else\n    ResetTxCIrq_sync2 <=#Tp SetTxCIrq_sync1;\nend\n\n\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_rxclk <=#Tp 1'b0;\n  else\n  if(SetPauseTimer & r_RxFlow)\n    SetRxCIrq_rxclk <=#Tp 1'b1;\n  else\n  if(ResetRxCIrq_sync2 & (~ResetRxCIrq_sync3))\n    SetRxCIrq_rxclk <=#Tp 1'b0;\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync1 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync1 <=#Tp SetRxCIrq_rxclk;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync2 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync2 <=#Tp SetRxCIrq_sync1;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync3 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync3 <=#Tp SetRxCIrq_sync2;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq <=#Tp 1'b0;\n  else\n    SetRxCIrq <=#Tp SetRxCIrq_sync2 & ~SetRxCIrq_sync3;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync1 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync1 <=#Tp SetRxCIrq_sync2;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync2 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync2 <=#Tp ResetRxCIrq_sync1;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync3 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync3 <=#Tp ResetRxCIrq_sync2;\nend\n\n\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txb <= 1'b0;\n  else\n  if(TxB_IRQ)\n    irq_txb <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[0])\n    irq_txb <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txe <= 1'b0;\n  else\n  if(TxE_IRQ)\n    irq_txe <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[1])\n    irq_txe <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxb <= 1'b0;\n  else\n  if(RxB_IRQ)\n    irq_rxb <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[2])\n    irq_rxb <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxe <= 1'b0;\n  else\n  if(RxE_IRQ)\n    irq_rxe <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[3])\n    irq_rxe <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_busy <= 1'b0;\n  else\n  if(Busy_IRQ)\n    irq_busy <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[4])\n    irq_busy <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txc <= 1'b0;\n  else\n  if(SetTxCIrq)\n    irq_txc <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[5])\n    irq_txc <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxc <= 1'b0;\n  else\n  if(SetRxCIrq)\n    irq_rxc <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[6])\n    irq_rxc <= #Tp 1'b0;\nend\n\n\nassign int_o = irq_txb  & INT_MASKOut[0] | \n               irq_txe  & INT_MASKOut[1] | \n               irq_rxb  & INT_MASKOut[2] | \n               irq_rxe  & INT_MASKOut[3] | \n               irq_busy & INT_MASKOut[4] | \n               irq_txc  & INT_MASKOut[5] | \n               irq_rxc  & INT_MASKOut[6] ;\n\n\nassign INT_SOURCEOut = {{(32-`ETH_INT_SOURCE_WIDTH_0){1'b0}}, irq_rxc, irq_txc, irq_busy, irq_rxe, irq_rxb, irq_txe, irq_txb};\n\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: eth_registers. Module specification: This module implements the Ethernet controller's register block, handling various configuration and status registers for Ethernet operations. It has input ports for data (DataIn), address (Address), read/write control (Rw), chip select (Cs), clock (Clk), reset (Reset), and various control and status signals. Output ports include data output (DataOut), configuration settings (e.g., r_RecSmall, r_Pad, r_HugEn), timing parameters (e.g., r_IPGT, r_IPGR1, r_IPGR2), MAC address (r_MAC), and interrupt output (int_o). Internal signals include register selection signals (e.g., MODER_Sel, INT_SOURCE_Sel), write signals (e.g., MODER_Wr, INT_SOURCE_"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: eth_registers\n\nExplanation: This module implements the Ethernet controller's register block. It handles various configuration and status registers for Ethernet operations, including MAC address, interrupt handling, MII (Media Independent Interface) control, flow control, and other Ethernet-specific parameters. The module provides read and write access to these registers, synchronizes signals between different clock domains, and generates interrupt signals based on various Ethernet events. It plays a crucial role in controlling and monitoring the Ethernet controller's behavior."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nDataIn, Address, Rw, Cs, Clk, Reset, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg, Prsd, TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, NValid_stat, Busy_stat, LinkFail, RstTxPauseRq, TxCtrlEndFrm, StartTxDone, TxClk, RxClk, SetPauseTimer.\n\nExplanation:\nThese inputs handle data input, addressing, read/write control, clock signals, reset, various interrupt requests, MII status signals, and control signals for Ethernet operations.\n\nOutput ports:\nDataOut, r_RecSmall, r_Pad, r_HugEn, r_CrcEn, r_DlyCrcEn, r_FullD, r_ExDfrEn, r_NoBckof, r_LoopBck, r_IFG, r_Pro, r_Iam, r_Bro, r_NoPre, r_TxEn, r_RxEn, r_IPGT, r_IPGR1, r_IPGR2, r_MinFL, r_MaxFL, r_MaxRet, r_CollValid, r_TxFlow, r_RxFlow, r_PassAll, r_MiiNoPre, r_ClkDiv, r_WCtrlData, r_RStat, r_ScanStat, r_RGAD, r_FIAD, r_CtrlData, r_MAC, r_TxBDNum, int_o, r_HASH0, r_HASH1, r_TxPauseTV, r_TxPauseRq.\n\nExplanation:\nThese outputs provide data output, various configuration settings (e.g., padding, CRC, flow control), timing parameters (e.g., inter-packet gap), MII control signals, MAC address, transmit buffer descriptor number, interrupt output, and other Ethernet control signals. They reflect the current state of the Ethernet controller's configuration registers."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nDataOut, Write, Read, MODER_Sel, INT_SOURCE_Sel, INT_MASK_Sel, IPGT_Sel, IPGR1_Sel, IPGR2_Sel, PACKETLEN_Sel, COLLCONF_Sel, CTRLMODER_Sel, MIIMODER_Sel, MIICOMMAND_Sel, MIIADDRESS_Sel, MIITX_DATA_Sel, MAC_ADDR0_Sel, MAC_ADDR1_Sel, HASH0_Sel, HASH1_Sel, TXCTRL_Sel, TX_BD_NUM_Sel, MODER_Wr, INT_SOURCE_Wr, INT_MASK_Wr, IPGT_Wr, IPGR1_Wr, IPGR2_Wr, PACKETLEN_Wr, COLLCONF_Wr, CTRLMODER_Wr, MIIMODER_Wr, MIICOMMAND_Wr, MIIADDRESS_Wr, MIITX_DATA_Wr, MIIRX_DATA_Wr, MAC_ADDR0_Wr, MAC_ADDR1_Wr, HASH0_Wr, HASH1_Wr, TXCTRL_Wr, TX_BD_NUM_Wr, MODEROut, INT_SOURCEOut, INT_MASKOut, IPGTOut, IPGR1Out, IPGR2Out, PACKETLENOut, COLLCONFOut, CTRLMODEROut, MIIMODEROut, MIICOMMANDOut, MIIADDRESSOut, MIITX_DATAOut, MIIRX_DATAOut, MIISTATUSOut, MAC_ADDR0Out, MAC_ADDR1Out, TX_BD_NUMOut, HASH0Out, HASH1Out, TXCTRLOut, irq_txb, irq_txe, irq_rxb, irq_rxe, irq_busy, irq_txc, irq_rxc, SetTxCIrq_txclk, SetTxCIrq_sync1, SetTxCIrq_sync2, SetTxCIrq_sync3, SetTxCIrq, ResetTxCIrq_sync1, ResetTxCIrq_sync2, SetRxCIrq_rxclk, SetRxCIrq_sync1, SetRxCIrq_sync2, SetRxCIrq_sync3, SetRxCIrq, ResetRxCIrq_sync1, ResetRxCIrq_sync2, ResetRxCIrq_sync3.\n\nExplanation:\nThese internal signals serve various purposes within the module:\n1. Register selection signals (e.g., MODER_Sel, INT_SOURCE_Sel) are used to select specific registers based on the input Address.\n2. Write signals (e.g., MODER_Wr, INT_SOURCE_Wr) control write operations to specific registers or register sections.\n3. Output signals (e.g., MODEROut, INT_SOURCEOut) store the current values of various registers.\n4. Interrupt-related signals (e.g., irq_txb, irq_txe) track different types of interrupts.\n5. Synchronization signals (e.g., SetTxCIrq_sync1, SetTxCIrq_sync2) are used to synchronize control signals between different clock domains.\n6. The DataOut signal is used to output register values during read operations.\n\nThese signals collectively manage the Ethernet controller's register operations, interrupt handling, and cross-domain signal synchronization."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_registers( DataIn, Address, Rw, Cs, Clk, Reset, DataOut, \n                      r_RecSmall, r_Pad, r_HugEn, r_CrcEn, r_DlyCrcEn, \n                      r_FullD, r_ExDfrEn, r_NoBckof, r_LoopBck, r_IFG, \n                      r_Pro, r_Iam, r_Bro, r_NoPre, r_TxEn, r_RxEn, \n                      TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, \n                      r_IPGT, r_IPGR1, r_IPGR2, r_MinFL, r_MaxFL, r_MaxRet, \n                      r_CollValid, r_TxFlow, r_RxFlow, r_PassAll, \n                      r_MiiNoPre, r_ClkDiv, r_WCtrlData, r_RStat, r_ScanStat, \n                      r_RGAD, r_FIAD, r_CtrlData, NValid_stat, Busy_stat, \n                      LinkFail, r_MAC, WCtrlDataStart, RStatStart,\n                      UpdateMIIRX_DATAReg, Prsd, r_TxBDNum, int_o,\n                      r_HASH0, r_HASH1, r_TxPauseTV, r_TxPauseRq, RstTxPauseRq, TxCtrlEndFrm, \n                      StartTxDone, TxClk, RxClk, SetPauseTimer\n                    );\n\nparameter Tp = 1;\n\ninput [31:0] DataIn;\ninput [7:0] Address;\n\ninput Rw;\ninput [3:0] Cs;\ninput Clk;\ninput Reset;\n\ninput WCtrlDataStart;\ninput RStatStart;\n\ninput UpdateMIIRX_DATAReg;\ninput [15:0] Prsd;\n\noutput [31:0] DataOut;\nreg    [31:0] DataOut;\n\noutput r_RecSmall;\noutput r_Pad;\noutput r_HugEn;\noutput r_CrcEn;\noutput r_DlyCrcEn;\noutput r_FullD;\noutput r_ExDfrEn;\noutput r_NoBckof;\noutput r_LoopBck;\noutput r_IFG;\noutput r_Pro;\noutput r_Iam;\noutput r_Bro;\noutput r_NoPre;\noutput r_TxEn;\noutput r_RxEn;\noutput [31:0] r_HASH0;\noutput [31:0] r_HASH1;\n\ninput TxB_IRQ;\ninput TxE_IRQ;\ninput RxB_IRQ;\ninput RxE_IRQ;\ninput Busy_IRQ;\n\noutput [6:0] r_IPGT;\n\noutput [6:0] r_IPGR1;\n\noutput [6:0] r_IPGR2;\n\noutput [15:0] r_MinFL;\noutput [15:0] r_MaxFL;\n\noutput [3:0] r_MaxRet;\noutput [5:0] r_CollValid;\n\noutput r_TxFlow;\noutput r_RxFlow;\noutput r_PassAll;\n\noutput r_MiiNoPre;\noutput [7:0] r_ClkDiv;\n\noutput r_WCtrlData;\noutput r_RStat;\noutput r_ScanStat;\n\noutput [4:0] r_RGAD;\noutput [4:0] r_FIAD;\n\noutput [15:0]r_CtrlData;\n\n\ninput NValid_stat;\ninput Busy_stat;\ninput LinkFail;\n\noutput [47:0]r_MAC;\noutput [7:0] r_TxBDNum;\noutput       int_o;\noutput [15:0]r_TxPauseTV;\noutput       r_TxPauseRq;\ninput        RstTxPauseRq;\ninput        TxCtrlEndFrm;\ninput        StartTxDone;\ninput        TxClk;\ninput        RxClk;\ninput        SetPauseTimer;\n\nreg          irq_txb;\nreg          irq_txe;\nreg          irq_rxb;\nreg          irq_rxe;\nreg          irq_busy;\nreg          irq_txc;\nreg          irq_rxc;\n\nreg SetTxCIrq_txclk;\nreg SetTxCIrq_sync1, SetTxCIrq_sync2, SetTxCIrq_sync3;\nreg SetTxCIrq;\nreg ResetTxCIrq_sync1, ResetTxCIrq_sync2;\n\nreg SetRxCIrq_rxclk;\nreg SetRxCIrq_sync1, SetRxCIrq_sync2, SetRxCIrq_sync3;\nreg SetRxCIrq;\nreg ResetRxCIrq_sync1;\nreg ResetRxCIrq_sync2;\nreg ResetRxCIrq_sync3;\n\nwire [3:0] Write =   Cs  & {4{Rw}};\nwire       Read  = (|Cs) &   ~Rw;\n\nwire MODER_Sel      = (Address == `ETH_MODER_ADR       );\nwire INT_SOURCE_Sel = (Address == `ETH_INT_SOURCE_ADR  );\nwire INT_MASK_Sel   = (Address == `ETH_INT_MASK_ADR    );\nwire IPGT_Sel       = (Address == `ETH_IPGT_ADR        );\nwire IPGR1_Sel      = (Address == `ETH_IPGR1_ADR       );\nwire IPGR2_Sel      = (Address == `ETH_IPGR2_ADR       );\nwire PACKETLEN_Sel  = (Address == `ETH_PACKETLEN_ADR   );\nwire COLLCONF_Sel   = (Address == `ETH_COLLCONF_ADR    );\n     \nwire CTRLMODER_Sel  = (Address == `ETH_CTRLMODER_ADR   );\nwire MIIMODER_Sel   = (Address == `ETH_MIIMODER_ADR    );\nwire MIICOMMAND_Sel = (Address == `ETH_MIICOMMAND_ADR  );\nwire MIIADDRESS_Sel = (Address == `ETH_MIIADDRESS_ADR  );\nwire MIITX_DATA_Sel = (Address == `ETH_MIITX_DATA_ADR  );\nwire MAC_ADDR0_Sel  = (Address == `ETH_MAC_ADDR0_ADR   );\nwire MAC_ADDR1_Sel  = (Address == `ETH_MAC_ADDR1_ADR   );\nwire HASH0_Sel      = (Address == `ETH_HASH0_ADR       );\nwire HASH1_Sel      = (Address == `ETH_HASH1_ADR       );\nwire TXCTRL_Sel     = (Address == `ETH_TX_CTRL_ADR     );\nwire RXCTRL_Sel     = (Address == `ETH_RX_CTRL_ADR     );\nwire TX_BD_NUM_Sel  = (Address == `ETH_TX_BD_NUM_ADR   );\n\n\nwire [2:0] MODER_Wr;\nwire [0:0] INT_SOURCE_Wr;\nwire [0:0] INT_MASK_Wr;\nwire [0:0] IPGT_Wr;\nwire [0:0] IPGR1_Wr;\nwire [0:0] IPGR2_Wr;\nwire [3:0] PACKETLEN_Wr;\nwire [2:0] COLLCONF_Wr;\nwire [0:0] CTRLMODER_Wr;\nwire [1:0] MIIMODER_Wr;\nwire [0:0] MIICOMMAND_Wr;\nwire [1:0] MIIADDRESS_Wr;\nwire [1:0] MIITX_DATA_Wr;\nwire       MIIRX_DATA_Wr;\nwire [3:0] MAC_ADDR0_Wr;\nwire [1:0] MAC_ADDR1_Wr;\nwire [3:0] HASH0_Wr;\nwire [3:0] HASH1_Wr;\nwire [2:0] TXCTRL_Wr;\nwire [0:0] TX_BD_NUM_Wr;\n\nassign MODER_Wr[0]       = Write[0]  & MODER_Sel; \nassign MODER_Wr[1]       = Write[1]  & MODER_Sel; \nassign MODER_Wr[2]       = Write[2]  & MODER_Sel; \nassign INT_SOURCE_Wr[0]  = Write[0]  & INT_SOURCE_Sel; \nassign INT_MASK_Wr[0]    = Write[0]  & INT_MASK_Sel; \nassign IPGT_Wr[0]        = Write[0]  & IPGT_Sel; \nassign IPGR1_Wr[0]       = Write[0]  & IPGR1_Sel; \nassign IPGR2_Wr[0]       = Write[0]  & IPGR2_Sel; \nassign PACKETLEN_Wr[0]   = Write[0]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[1]   = Write[1]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[2]   = Write[2]  & PACKETLEN_Sel; \nassign PACKETLEN_Wr[3]   = Write[3]  & PACKETLEN_Sel; \nassign COLLCONF_Wr[0]    = Write[0]  & COLLCONF_Sel; \nassign COLLCONF_Wr[1]    = 1'b0;  \nassign COLLCONF_Wr[2]    = Write[2]  & COLLCONF_Sel; \n     \nassign CTRLMODER_Wr[0]   = Write[0]  & CTRLMODER_Sel; \nassign MIIMODER_Wr[0]    = Write[0]  & MIIMODER_Sel; \nassign MIIMODER_Wr[1]    = Write[1]  & MIIMODER_Sel; \nassign MIICOMMAND_Wr[0]  = Write[0]  & MIICOMMAND_Sel; \nassign MIIADDRESS_Wr[0]  = Write[0]  & MIIADDRESS_Sel; \nassign MIIADDRESS_Wr[1]  = Write[1]  & MIIADDRESS_Sel; \nassign MIITX_DATA_Wr[0]  = Write[0]  & MIITX_DATA_Sel; \nassign MIITX_DATA_Wr[1]  = Write[1]  & MIITX_DATA_Sel; \nassign MIIRX_DATA_Wr     = UpdateMIIRX_DATAReg;     \nassign MAC_ADDR0_Wr[0]   = Write[0]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[1]   = Write[1]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[2]   = Write[2]  & MAC_ADDR0_Sel; \nassign MAC_ADDR0_Wr[3]   = Write[3]  & MAC_ADDR0_Sel; \nassign MAC_ADDR1_Wr[0]   = Write[0]  & MAC_ADDR1_Sel; \nassign MAC_ADDR1_Wr[1]   = Write[1]  & MAC_ADDR1_Sel; \nassign HASH0_Wr[0]       = Write[0]  & HASH0_Sel; \nassign HASH0_Wr[1]       = Write[1]  & HASH0_Sel; \nassign HASH0_Wr[2]       = Write[2]  & HASH0_Sel; \nassign HASH0_Wr[3]       = Write[3]  & HASH0_Sel; \nassign HASH1_Wr[0]       = Write[0]  & HASH1_Sel; \nassign HASH1_Wr[1]       = Write[1]  & HASH1_Sel; \nassign HASH1_Wr[2]       = Write[2]  & HASH1_Sel; \nassign HASH1_Wr[3]       = Write[3]  & HASH1_Sel; \nassign TXCTRL_Wr[0]      = Write[0]  & TXCTRL_Sel; \nassign TXCTRL_Wr[1]      = Write[1]  & TXCTRL_Sel; \nassign TXCTRL_Wr[2]      = Write[2]  & TXCTRL_Sel; \nassign TX_BD_NUM_Wr[0]   = Write[0]  & TX_BD_NUM_Sel & (DataIn<='h80); \n\n\n\nwire [31:0] MODEROut;\nwire [31:0] INT_SOURCEOut;\nwire [31:0] INT_MASKOut;\nwire [31:0] IPGTOut;\nwire [31:0] IPGR1Out;\nwire [31:0] IPGR2Out;\nwire [31:0] PACKETLENOut;\nwire [31:0] COLLCONFOut;\nwire [31:0] CTRLMODEROut;\nwire [31:0] MIIMODEROut;\nwire [31:0] MIICOMMANDOut;\nwire [31:0] MIIADDRESSOut;\nwire [31:0] MIITX_DATAOut;\nwire [31:0] MIIRX_DATAOut;\nwire [31:0] MIISTATUSOut;\nwire [31:0] MAC_ADDR0Out;\nwire [31:0] MAC_ADDR1Out;\nwire [31:0] TX_BD_NUMOut;\nwire [31:0] HASH0Out;\nwire [31:0] HASH1Out;\nwire [31:0] TXCTRLOut;\n\n\neth_register #(`ETH_MODER_WIDTH_0, `ETH_MODER_DEF_0)        MODER_0\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_0 - 1:0]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_0 - 1:0]),\n   .Write     (MODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MODER_WIDTH_1, `ETH_MODER_DEF_1)        MODER_1\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_1 + 7:8]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_1 + 7:8]),\n   .Write     (MODER_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MODER_WIDTH_2, `ETH_MODER_DEF_2)        MODER_2\n  (\n   .DataIn    (DataIn[`ETH_MODER_WIDTH_2 + 15:16]),\n   .DataOut   (MODEROut[`ETH_MODER_WIDTH_2 + 15:16]),\n   .Write     (MODER_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MODEROut[31:`ETH_MODER_WIDTH_2 + 16] = 0;\n\n\neth_register #(`ETH_INT_MASK_WIDTH_0, `ETH_INT_MASK_DEF_0)  INT_MASK_0\n  (\n   .DataIn    (DataIn[`ETH_INT_MASK_WIDTH_0 - 1:0]),  \n   .DataOut   (INT_MASKOut[`ETH_INT_MASK_WIDTH_0 - 1:0]),\n   .Write     (INT_MASK_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign INT_MASKOut[31:`ETH_INT_MASK_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGT_WIDTH_0, `ETH_IPGT_DEF_0)          IPGT_0\n  (\n   .DataIn    (DataIn[`ETH_IPGT_WIDTH_0 - 1:0]),\n   .DataOut   (IPGTOut[`ETH_IPGT_WIDTH_0 - 1:0]),\n   .Write     (IPGT_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGTOut[31:`ETH_IPGT_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGR1_WIDTH_0, `ETH_IPGR1_DEF_0)        IPGR1_0\n  (\n   .DataIn    (DataIn[`ETH_IPGR1_WIDTH_0 - 1:0]),\n   .DataOut   (IPGR1Out[`ETH_IPGR1_WIDTH_0 - 1:0]),\n   .Write     (IPGR1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGR1Out[31:`ETH_IPGR1_WIDTH_0] = 0;\n\n\neth_register #(`ETH_IPGR2_WIDTH_0, `ETH_IPGR2_DEF_0)        IPGR2_0\n  (\n   .DataIn    (DataIn[`ETH_IPGR2_WIDTH_0 - 1:0]),\n   .DataOut   (IPGR2Out[`ETH_IPGR2_WIDTH_0 - 1:0]),\n   .Write     (IPGR2_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign IPGR2Out[31:`ETH_IPGR2_WIDTH_0] = 0;\n\n\neth_register #(`ETH_PACKETLEN_WIDTH_0, `ETH_PACKETLEN_DEF_0) PACKETLEN_0\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_0 - 1:0]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_0 - 1:0]),\n   .Write     (PACKETLEN_Wr[0]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_1, `ETH_PACKETLEN_DEF_1) PACKETLEN_1\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_1 + 7:8]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_1 + 7:8]),\n   .Write     (PACKETLEN_Wr[1]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_2, `ETH_PACKETLEN_DEF_2) PACKETLEN_2\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_2 + 15:16]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_2 + 15:16]),\n   .Write     (PACKETLEN_Wr[2]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_PACKETLEN_WIDTH_3, `ETH_PACKETLEN_DEF_3) PACKETLEN_3\n  (\n   .DataIn    (DataIn[`ETH_PACKETLEN_WIDTH_3 + 23:24]),\n   .DataOut   (PACKETLENOut[`ETH_PACKETLEN_WIDTH_3 + 23:24]),\n   .Write     (PACKETLEN_Wr[3]),\n   .Clk       (Clk), \n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_COLLCONF_WIDTH_0, `ETH_COLLCONF_DEF_0)   COLLCONF_0\n  (\n   .DataIn    (DataIn[`ETH_COLLCONF_WIDTH_0 - 1:0]),\n   .DataOut   (COLLCONFOut[`ETH_COLLCONF_WIDTH_0 - 1:0]),\n   .Write     (COLLCONF_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_COLLCONF_WIDTH_2, `ETH_COLLCONF_DEF_2)   COLLCONF_2\n  (\n   .DataIn    (DataIn[`ETH_COLLCONF_WIDTH_2 + 15:16]),\n   .DataOut   (COLLCONFOut[`ETH_COLLCONF_WIDTH_2 + 15:16]),\n   .Write     (COLLCONF_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign COLLCONFOut[15:`ETH_COLLCONF_WIDTH_0] = 0;\nassign COLLCONFOut[31:`ETH_COLLCONF_WIDTH_2 + 16] = 0;\n\n\neth_register #(`ETH_TX_BD_NUM_WIDTH_0, `ETH_TX_BD_NUM_DEF_0) TX_BD_NUM_0\n  (\n   .DataIn    (DataIn[`ETH_TX_BD_NUM_WIDTH_0 - 1:0]),\n   .DataOut   (TX_BD_NUMOut[`ETH_TX_BD_NUM_WIDTH_0 - 1:0]),\n   .Write     (TX_BD_NUM_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign TX_BD_NUMOut[31:`ETH_TX_BD_NUM_WIDTH_0] = 0;\n\n\neth_register #(`ETH_CTRLMODER_WIDTH_0, `ETH_CTRLMODER_DEF_0)  CTRLMODER_0\n  (\n   .DataIn    (DataIn[`ETH_CTRLMODER_WIDTH_0 - 1:0]),\n   .DataOut   (CTRLMODEROut[`ETH_CTRLMODER_WIDTH_0 - 1:0]),\n   .Write     (CTRLMODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign CTRLMODEROut[31:`ETH_CTRLMODER_WIDTH_0] = 0;\n\n\neth_register #(`ETH_MIIMODER_WIDTH_0, `ETH_MIIMODER_DEF_0)    MIIMODER_0\n  (\n   .DataIn    (DataIn[`ETH_MIIMODER_WIDTH_0 - 1:0]),\n   .DataOut   (MIIMODEROut[`ETH_MIIMODER_WIDTH_0 - 1:0]),\n   .Write     (MIIMODER_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIIMODER_WIDTH_1, `ETH_MIIMODER_DEF_1)    MIIMODER_1\n  (\n   .DataIn    (DataIn[`ETH_MIIMODER_WIDTH_1 + 7:8]),\n   .DataOut   (MIIMODEROut[`ETH_MIIMODER_WIDTH_1 + 7:8]),\n   .Write     (MIIMODER_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIMODEROut[31:`ETH_MIIMODER_WIDTH_1 + 8] = 0;\n\n\neth_register #(1, 0)                                      MIICOMMAND0\n  (\n   .DataIn    (DataIn[0]),\n   .DataOut   (MIICOMMANDOut[0]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(1, 0)                                      MIICOMMAND1\n  (\n   .DataIn    (DataIn[1]),\n   .DataOut   (MIICOMMANDOut[1]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (RStatStart)\n  );\neth_register #(1, 0)                                      MIICOMMAND2\n  (\n   .DataIn    (DataIn[2]),\n   .DataOut   (MIICOMMANDOut[2]),\n   .Write     (MIICOMMAND_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (WCtrlDataStart)\n  );\nassign MIICOMMANDOut[31:`ETH_MIICOMMAND_WIDTH_0] = 29'h0;\n\n\neth_register #(`ETH_MIIADDRESS_WIDTH_0, `ETH_MIIADDRESS_DEF_0) MIIADDRESS_0\n  (\n   .DataIn    (DataIn[`ETH_MIIADDRESS_WIDTH_0 - 1:0]),\n   .DataOut   (MIIADDRESSOut[`ETH_MIIADDRESS_WIDTH_0 - 1:0]),\n   .Write     (MIIADDRESS_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIIADDRESS_WIDTH_1, `ETH_MIIADDRESS_DEF_1) MIIADDRESS_1\n  (\n   .DataIn    (DataIn[`ETH_MIIADDRESS_WIDTH_1 + 7:8]),\n   .DataOut   (MIIADDRESSOut[`ETH_MIIADDRESS_WIDTH_1 + 7:8]),\n   .Write     (MIIADDRESS_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIADDRESSOut[7:`ETH_MIIADDRESS_WIDTH_0] = 0;\nassign MIIADDRESSOut[31:`ETH_MIIADDRESS_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_MIITX_DATA_WIDTH_0, `ETH_MIITX_DATA_DEF_0) MIITX_DATA_0\n  (\n   .DataIn    (DataIn[`ETH_MIITX_DATA_WIDTH_0 - 1:0]),\n   .DataOut   (MIITX_DATAOut[`ETH_MIITX_DATA_WIDTH_0 - 1:0]), \n   .Write     (MIITX_DATA_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MIITX_DATA_WIDTH_1, `ETH_MIITX_DATA_DEF_1) MIITX_DATA_1\n  (\n   .DataIn    (DataIn[`ETH_MIITX_DATA_WIDTH_1 + 7:8]),\n   .DataOut   (MIITX_DATAOut[`ETH_MIITX_DATA_WIDTH_1 + 7:8]), \n   .Write     (MIITX_DATA_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIITX_DATAOut[31:`ETH_MIITX_DATA_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_MIIRX_DATA_WIDTH, `ETH_MIIRX_DATA_DEF) MIIRX_DATA\n  (\n   .DataIn    (Prsd[`ETH_MIIRX_DATA_WIDTH-1:0]),\n   .DataOut   (MIIRX_DATAOut[`ETH_MIIRX_DATA_WIDTH-1:0]),\n   .Write     (MIIRX_DATA_Wr), \n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MIIRX_DATAOut[31:`ETH_MIIRX_DATA_WIDTH] = 0;\n\n\neth_register #(`ETH_MAC_ADDR0_WIDTH_0, `ETH_MAC_ADDR0_DEF_0)  MAC_ADDR0_0\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_0 - 1:0]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_0 - 1:0]),\n   .Write     (MAC_ADDR0_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_1, `ETH_MAC_ADDR0_DEF_1)  MAC_ADDR0_1\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_1 + 7:8]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_1 + 7:8]),\n   .Write     (MAC_ADDR0_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_2, `ETH_MAC_ADDR0_DEF_2)  MAC_ADDR0_2\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_2 + 15:16]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_2 + 15:16]),\n   .Write     (MAC_ADDR0_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR0_WIDTH_3, `ETH_MAC_ADDR0_DEF_3)  MAC_ADDR0_3\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR0_WIDTH_3 + 23:24]),\n   .DataOut   (MAC_ADDR0Out[`ETH_MAC_ADDR0_WIDTH_3 + 23:24]),\n   .Write     (MAC_ADDR0_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_MAC_ADDR1_WIDTH_0, `ETH_MAC_ADDR1_DEF_0)  MAC_ADDR1_0\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR1_WIDTH_0 - 1:0]),\n   .DataOut   (MAC_ADDR1Out[`ETH_MAC_ADDR1_WIDTH_0 - 1:0]),\n   .Write     (MAC_ADDR1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_MAC_ADDR1_WIDTH_1, `ETH_MAC_ADDR1_DEF_1)  MAC_ADDR1_1\n  (\n   .DataIn    (DataIn[`ETH_MAC_ADDR1_WIDTH_1 + 7:8]),\n   .DataOut   (MAC_ADDR1Out[`ETH_MAC_ADDR1_WIDTH_1 + 7:8]),\n   .Write     (MAC_ADDR1_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\nassign MAC_ADDR1Out[31:`ETH_MAC_ADDR1_WIDTH_1 + 8] = 0;\n\n\neth_register #(`ETH_HASH0_WIDTH_0, `ETH_HASH0_DEF_0)          RXHASH0_0\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_0 - 1:0]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_0 - 1:0]),\n   .Write     (HASH0_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_1, `ETH_HASH0_DEF_1)          RXHASH0_1\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_1 + 7:8]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_1 + 7:8]),\n   .Write     (HASH0_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_2, `ETH_HASH0_DEF_2)          RXHASH0_2\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_2 + 15:16]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_2 + 15:16]),\n   .Write     (HASH0_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH0_WIDTH_3, `ETH_HASH0_DEF_3)          RXHASH0_3\n  (\n   .DataIn    (DataIn[`ETH_HASH0_WIDTH_3 + 23:24]),\n   .DataOut   (HASH0Out[`ETH_HASH0_WIDTH_3 + 23:24]),\n   .Write     (HASH0_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_HASH1_WIDTH_0, `ETH_HASH1_DEF_0)          RXHASH1_0\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_0 - 1:0]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_0 - 1:0]),\n   .Write     (HASH1_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_1, `ETH_HASH1_DEF_1)          RXHASH1_1\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_1 + 7:8]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_1 + 7:8]),\n   .Write     (HASH1_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_2, `ETH_HASH1_DEF_2)          RXHASH1_2\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_2 + 15:16]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_2 + 15:16]),\n   .Write     (HASH1_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_HASH1_WIDTH_3, `ETH_HASH1_DEF_3)          RXHASH1_3\n  (\n   .DataIn    (DataIn[`ETH_HASH1_WIDTH_3 + 23:24]),\n   .DataOut   (HASH1Out[`ETH_HASH1_WIDTH_3 + 23:24]),\n   .Write     (HASH1_Wr[3]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\n\n\neth_register #(`ETH_TX_CTRL_WIDTH_0, `ETH_TX_CTRL_DEF_0)  TXCTRL_0\n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_0 - 1:0]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_0 - 1:0]),\n   .Write     (TXCTRL_Wr[0]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_TX_CTRL_WIDTH_1, `ETH_TX_CTRL_DEF_1)  TXCTRL_1\n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_1 + 7:8]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_1 + 7:8]),\n   .Write     (TXCTRL_Wr[1]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (1'b0)\n  );\neth_register #(`ETH_TX_CTRL_WIDTH_2, `ETH_TX_CTRL_DEF_2)  TXCTRL_2 \n  (\n   .DataIn    (DataIn[`ETH_TX_CTRL_WIDTH_2 + 15:16]),\n   .DataOut   (TXCTRLOut[`ETH_TX_CTRL_WIDTH_2 + 15:16]),\n   .Write     (TXCTRL_Wr[2]),\n   .Clk       (Clk),\n   .Reset     (Reset),\n   .SyncReset (RstTxPauseRq)\n  );\nassign TXCTRLOut[31:`ETH_TX_CTRL_WIDTH_2 + 16] = 0;\n\n\n\n\nalways @ (Address       or Read           or MODEROut       or INT_SOURCEOut  or\n          INT_MASKOut   or IPGTOut        or IPGR1Out       or IPGR2Out       or\n          PACKETLENOut  or COLLCONFOut    or CTRLMODEROut   or MIIMODEROut    or\n          MIICOMMANDOut or MIIADDRESSOut  or MIITX_DATAOut  or MIIRX_DATAOut  or \n          MIISTATUSOut  or MAC_ADDR0Out   or MAC_ADDR1Out   or TX_BD_NUMOut   or\n          HASH0Out      or HASH1Out       or TXCTRLOut       \n         )\nbegin\n  if(Read)  \n    begin\n      case(Address)\n        `ETH_MODER_ADR        :  DataOut<=MODEROut;\n        `ETH_INT_SOURCE_ADR   :  DataOut<=INT_SOURCEOut;\n        `ETH_INT_MASK_ADR     :  DataOut<=INT_MASKOut;\n        `ETH_IPGT_ADR         :  DataOut<=IPGTOut;\n        `ETH_IPGR1_ADR        :  DataOut<=IPGR1Out;\n        `ETH_IPGR2_ADR        :  DataOut<=IPGR2Out;\n        `ETH_PACKETLEN_ADR    :  DataOut<=PACKETLENOut;\n        `ETH_COLLCONF_ADR     :  DataOut<=COLLCONFOut;\n        `ETH_CTRLMODER_ADR    :  DataOut<=CTRLMODEROut;\n        `ETH_MIIMODER_ADR     :  DataOut<=MIIMODEROut;\n        `ETH_MIICOMMAND_ADR   :  DataOut<=MIICOMMANDOut;\n        `ETH_MIIADDRESS_ADR   :  DataOut<=MIIADDRESSOut;\n        `ETH_MIITX_DATA_ADR   :  DataOut<=MIITX_DATAOut;\n        `ETH_MIIRX_DATA_ADR   :  DataOut<=MIIRX_DATAOut;\n        `ETH_MIISTATUS_ADR    :  DataOut<=MIISTATUSOut;\n        `ETH_MAC_ADDR0_ADR    :  DataOut<=MAC_ADDR0Out;\n        `ETH_MAC_ADDR1_ADR    :  DataOut<=MAC_ADDR1Out;\n        `ETH_TX_BD_NUM_ADR    :  DataOut<=TX_BD_NUMOut;\n        `ETH_HASH0_ADR        :  DataOut<=HASH0Out;\n        `ETH_HASH1_ADR        :  DataOut<=HASH1Out;\n        `ETH_TX_CTRL_ADR      :  DataOut<=TXCTRLOut;\n\n        default:             DataOut<=32'h0;\n      endcase\n    end\n  else\n    DataOut<=32'h0;\nend\n\n\nassign r_RecSmall         = MODEROut[16];\nassign r_Pad              = MODEROut[15];\nassign r_HugEn            = MODEROut[14];\nassign r_CrcEn            = MODEROut[13];\nassign r_DlyCrcEn         = MODEROut[12];\n\nassign r_FullD            = MODEROut[10];\nassign r_ExDfrEn          = MODEROut[9];\nassign r_NoBckof          = MODEROut[8];\nassign r_LoopBck          = MODEROut[7];\nassign r_IFG              = MODEROut[6];\nassign r_Pro              = MODEROut[5];\nassign r_Iam              = MODEROut[4];\nassign r_Bro              = MODEROut[3];\nassign r_NoPre            = MODEROut[2];\nassign r_TxEn             = MODEROut[1] & (TX_BD_NUMOut>0);     \nassign r_RxEn             = MODEROut[0] & (TX_BD_NUMOut<'h80);  \n\nassign r_IPGT[6:0]        = IPGTOut[6:0];\n\nassign r_IPGR1[6:0]       = IPGR1Out[6:0];\n\nassign r_IPGR2[6:0]       = IPGR2Out[6:0];\n\nassign r_MinFL[15:0]      = PACKETLENOut[31:16];\nassign r_MaxFL[15:0]      = PACKETLENOut[15:0];\n\nassign r_MaxRet[3:0]      = COLLCONFOut[19:16];\nassign r_CollValid[5:0]   = COLLCONFOut[5:0];\n\nassign r_TxFlow           = CTRLMODEROut[2];\nassign r_RxFlow           = CTRLMODEROut[1];\nassign r_PassAll          = CTRLMODEROut[0];\n\nassign r_MiiNoPre         = MIIMODEROut[8];\nassign r_ClkDiv[7:0]      = MIIMODEROut[7:0];\n\nassign r_WCtrlData        = MIICOMMANDOut[2];\nassign r_RStat            = MIICOMMANDOut[1];\nassign r_ScanStat         = MIICOMMANDOut[0];\n\nassign r_RGAD[4:0]        = MIIADDRESSOut[12:8];\nassign r_FIAD[4:0]        = MIIADDRESSOut[4:0];\n\nassign r_CtrlData[15:0]   = MIITX_DATAOut[15:0];\n\nassign MIISTATUSOut[31:`ETH_MIISTATUS_WIDTH] = 0; \nassign MIISTATUSOut[2]    = NValid_stat         ; \nassign MIISTATUSOut[1]    = Busy_stat           ; \nassign MIISTATUSOut[0]    = LinkFail            ; \n\nassign r_MAC[31:0]        = MAC_ADDR0Out[31:0];\nassign r_MAC[47:32]       = MAC_ADDR1Out[15:0];\nassign r_HASH1[31:0]      = HASH1Out;\nassign r_HASH0[31:0]      = HASH0Out;\n\nassign r_TxBDNum[7:0]     = TX_BD_NUMOut[7:0];\n\nassign r_TxPauseTV[15:0]  = TXCTRLOut[15:0];\nassign r_TxPauseRq        = TXCTRLOut[16];\n\n\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_txclk <=#Tp 1'b0;\n  else\n  if(TxCtrlEndFrm & StartTxDone & r_TxFlow)\n    SetTxCIrq_txclk <=#Tp 1'b1;\n  else\n  if(ResetTxCIrq_sync2)\n    SetTxCIrq_txclk <=#Tp 1'b0;\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync1 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync1 <=#Tp SetTxCIrq_txclk;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync2 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync2 <=#Tp SetTxCIrq_sync1;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq_sync3 <=#Tp 1'b0;\n  else\n    SetTxCIrq_sync3 <=#Tp SetTxCIrq_sync2;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetTxCIrq <=#Tp 1'b0;\n  else\n    SetTxCIrq <=#Tp SetTxCIrq_sync2 & ~SetTxCIrq_sync3;\nend\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetTxCIrq_sync1 <=#Tp 1'b0;\n  else\n    ResetTxCIrq_sync1 <=#Tp SetTxCIrq_sync2;\nend\n\nalways @ (posedge TxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetTxCIrq_sync2 <=#Tp 1'b0;\n  else\n    ResetTxCIrq_sync2 <=#Tp SetTxCIrq_sync1;\nend\n\n\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_rxclk <=#Tp 1'b0;\n  else\n  if(SetPauseTimer & r_RxFlow)\n    SetRxCIrq_rxclk <=#Tp 1'b1;\n  else\n  if(ResetRxCIrq_sync2 & (~ResetRxCIrq_sync3))\n    SetRxCIrq_rxclk <=#Tp 1'b0;\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync1 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync1 <=#Tp SetRxCIrq_rxclk;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync2 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync2 <=#Tp SetRxCIrq_sync1;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq_sync3 <=#Tp 1'b0;\n  else\n    SetRxCIrq_sync3 <=#Tp SetRxCIrq_sync2;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    SetRxCIrq <=#Tp 1'b0;\n  else\n    SetRxCIrq <=#Tp SetRxCIrq_sync2 & ~SetRxCIrq_sync3;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync1 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync1 <=#Tp SetRxCIrq_sync2;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync2 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync2 <=#Tp ResetRxCIrq_sync1;\nend\n\nalways @ (posedge RxClk or posedge Reset)\nbegin\n  if(Reset)\n    ResetRxCIrq_sync3 <=#Tp 1'b0;\n  else\n    ResetRxCIrq_sync3 <=#Tp ResetRxCIrq_sync2;\nend\n\n\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txb <= 1'b0;\n  else\n  if(TxB_IRQ)\n    irq_txb <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[0])\n    irq_txb <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txe <= 1'b0;\n  else\n  if(TxE_IRQ)\n    irq_txe <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[1])\n    irq_txe <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxb <= 1'b0;\n  else\n  if(RxB_IRQ)\n    irq_rxb <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[2])\n    irq_rxb <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxe <= 1'b0;\n  else\n  if(RxE_IRQ)\n    irq_rxe <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[3])\n    irq_rxe <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_busy <= 1'b0;\n  else\n  if(Busy_IRQ)\n    irq_busy <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[4])\n    irq_busy <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_txc <= 1'b0;\n  else\n  if(SetTxCIrq)\n    irq_txc <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[5])\n    irq_txc <= #Tp 1'b0;\nend\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    irq_rxc <= 1'b0;\n  else\n  if(SetRxCIrq)\n    irq_rxc <= #Tp 1'b1;\n  else\n  if(INT_SOURCE_Wr[0] & DataIn[6])\n    irq_rxc <= #Tp 1'b0;\nend\n\n\nassign int_o = irq_txb  & INT_MASKOut[0] | \n               irq_txe  & INT_MASKOut[1] | \n               irq_rxb  & INT_MASKOut[2] | \n               irq_rxe  & INT_MASKOut[3] | \n               irq_busy & INT_MASKOut[4] | \n               irq_txc  & INT_MASKOut[5] | \n               irq_rxc  & INT_MASKOut[6] ;\n\n\nassign INT_SOURCEOut = {{(32-`ETH_INT_SOURCE_WIDTH_0){1'b0}}, irq_rxc, irq_txc, irq_busy, irq_rxe, irq_rxb, irq_txe, irq_txb};\n\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: eth_registers. Module specification: This module implements the Ethernet controller's register block, handling various configuration and status registers for Ethernet operations. It has input ports for data (DataIn), address (Address), read/write control (Rw), chip select (Cs), clock (Clk), reset (Reset), and various control and status signals. Output ports include data output (DataOut), configuration settings (e.g., r_RecSmall, r_Pad, r_HugEn), timing parameters (e.g., r_IPGT, r_IPGR1, r_IPGR2), MAC address (r_MAC), and interrupt output (int_o). Internal signals include register selection signals (e.g., MODER_Sel, INT_SOURCE_Sel), write signals (e.g., MODER_Wr, INT_SOURCE_"
                }
            ]
        }
    ]
}