{
    "line_num": [
        [
            1739,
            1744
        ],
        [
            1737,
            1737
        ],
        [
            1708,
            1735
        ],
        [
            1704,
            1704
        ],
        [
            1680,
            1680
        ],
        [
            1662,
            1678
        ],
        [
            1625,
            1658
        ],
        [
            1557,
            1621
        ],
        [
            1431,
            1551
        ],
        [
            1418,
            1428
        ],
        [
            1416,
            1416
        ],
        [
            1408,
            1408
        ],
        [
            1403,
            1403
        ],
        [
            623,
            1039
        ],
        [
            608,
            615
        ],
        [
            603,
            605
        ],
        [
            590,
            598
        ],
        [
            576,
            578
        ],
        [
            568,
            571
        ],
        [
            562,
            562
        ],
        [
            544,
            559
        ],
        [
            522,
            540
        ],
        [
            501,
            519
        ],
        [
            480,
            486
        ],
        [
            455,
            477
        ],
        [
            408,
            450
        ],
        [
            389,
            401
        ]
    ],
    "blocks": [
        "always @( posedge i_clk )\n    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n        begin\n        `TB_ERROR_MESSAGE\n        $display(\"Instruction with x's =%08h\", instruction);\n        end",
        "assign xMODE  = mode_name ( status_bits_mode_r );",
        "assign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_EXEC3   ? \"MTRANS_EXEC3\"   :\n                               control_state == MTRANS_EXEC3B  ? \"MTRANS_EXEC3B\"  :\n                               control_state == MTRANS_EXEC4   ? \"MTRANS_EXEC4\"   :\n                               control_state == MTRANS5_ABORT  ? \"MTRANS5_ABORT\"  :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;",
        "",
        "assign dabt = dabt_reg || i_dabt;",
        "always @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        irq   <= i_irq;\n        firq  <= i_firq;\n\n        if ( control_state == INT_WAIT1 && status_bits_mode_r == SVC )\n            begin\n            dabt_reg  <= 1'd0;\n            end\n        else\n            begin\n            dabt_reg  <= dabt_reg || i_dabt;\n            end\n\n        dabt_reg_d1  <= dabt_reg;\n        end",
        "always @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        \n        \n        \n        \n        \n        if      (itype == MTRANS)\n            begin\n            saved_current_instruction              <= mtrans_instruction_nxt;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n        else if (saved_current_instruction_wen)\n            begin\n            saved_current_instruction              <= instruction;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n\n        if      (pre_fetch_instruction_wen)\n            begin\n            pre_fetch_instruction                  <= o_read_data;\n            pre_fetch_instruction_iabt             <= iabt_reg;\n            pre_fetch_instruction_adex             <= adex_reg;\n            pre_fetch_instruction_address          <= abt_address_reg;\n            pre_fetch_instruction_iabt_status      <= abt_status_reg;\n            end\n        end",
        "always @ ( posedge i_clk )\n    if (!i_fetch_stall)\n        begin\n        o_read_data                 <= i_read_data;\n        o_read_data_alignment       <= {i_execute_address[1:0], 3'd0};\n        abt_address_reg             <= i_execute_address;\n        iabt_reg                    <= i_iabt;\n        adex_reg                    <= i_adex;\n        abt_status_reg              <= i_abt_status;\n        status_bits_mode_r          <= status_bits_mode_nxt;\n        status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n        status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n        o_imm32                     <= imm32_nxt;\n        o_imm_shift_amount          <= imm_shift_amount_nxt;\n        o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n                                        \n                                        \n                                        \n                                        \n                                        \n        condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n        o_exclusive_exec            <= exclusive_exec_nxt;\n        o_data_access_exec          <= data_access_exec_nxt;\n\n        o_rm_sel                    <= o_rm_sel_nxt;\n        o_rds_sel                   <= o_rds_sel_nxt;\n        o_rn_sel                    <= o_rn_sel_nxt;\n        o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n        o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n        o_barrel_shift_function     <= barrel_shift_function_nxt;\n        o_alu_function              <= alu_function_nxt;\n        o_use_carry_in              <= use_carry_in_nxt;\n        o_multiply_function         <= multiply_function_nxt;\n        o_interrupt_vector_sel      <= next_interrupt;\n        address_sel_r               <= address_sel_nxt;\n        pc_sel_r                    <= pc_sel_nxt;\n        o_byte_enable_sel           <= byte_enable_sel_nxt;\n        o_status_bits_sel           <= status_bits_sel_nxt;\n        o_reg_write_sel             <= reg_write_sel_nxt;\n        o_user_mode_regs_load       <= user_mode_regs_load_nxt;\n        o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n        o_write_data_wen            <= write_data_wen_nxt;\n        o_base_address_wen          <= base_address_wen_nxt;\n        pc_wen_r                    <= pc_wen_nxt;\n        o_reg_bank_wsel             <= reg_bank_wsel_nxt;\n        o_reg_bank_wen              <= decode ( reg_bank_wsel_nxt );\n        o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n        o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n        o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n        o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n        o_copro_opcode1             <= instruction[23:21];\n        o_copro_opcode2             <= instruction[7:5];\n        o_copro_crn                 <= instruction[19:16];\n        o_copro_crm                 <= instruction[3:0];\n        o_copro_num                 <= instruction[11:8];\n        o_copro_operation           <= copro_operation_nxt;\n        o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n        mtrans_r15                  <= mtrans_r15_nxt;\n        restore_base_address        <= restore_base_address_nxt;\n        control_state               <= control_state_nxt;\n        mtrans_reg_d1               <= mtrans_reg;\n        mtrans_reg_d2               <= mtrans_reg_d1;\n        end",
        " always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS5_ABORT ) control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if (mtrans_instruction_nxt[15:0] != 16'd0)\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            control_state_nxt = MTRANS_EXEC3;\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        control_state_nxt = MTRANS_EXEC3;\n\n    if ( control_state == MTRANS_EXEC3 )     control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC3B )    control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC4  )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS5_ABORT;\n        else if (write_pc) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( mem_op )  \n             control_state_nxt = MEM_WAIT1;\n        if ( write_pc )\n             control_state_nxt = PC_STALL1;\n        if ( itype == MTRANS )\n            begin\n            if ( mtrans_num_registers != 5'd0 )\n                begin\n                \n                if ( mtrans_num_registers == 5'd1 )\n                    control_state_nxt = MTRANS_EXEC3B;\n                else\n                    control_state_nxt = MTRANS_EXEC1;\n                end\n            else\n                control_state_nxt = MTRANS_EXEC3;\n            end\n\n        if ( itype == MULT )\n                control_state_nxt = MULT_PROC1;\n\n        if ( itype == SWAP )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( itype == CORTRANS && !und_request )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt )\n                control_state_nxt = INT_WAIT1;\n        end\n    end",
        "assign instruction_valid = (control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                     \n                     \n                    (!instruction_execute && (control_state == PC_STALL1    ||\n                                              control_state == MEM_WAIT1    ||\n                                              control_state == COPRO_WAIT   ||\n                                              control_state == SWAP_WRITE   ||\n                                              control_state == MULT_PROC1   ||\n                                              control_state == MTRANS_EXEC1 ||\n                                              control_state == MTRANS_EXEC3 ||\n                                              control_state == MTRANS_EXEC3B  ) );",
        "assign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );",
        "assign firq_not_user_mode_nxt = !user_mode_regs_load_nxt && status_bits_mode_nxt == FIRQ;",
        "    end",
        "always @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    exclusive_exec_nxt              = 1'd0;\n    data_access_exec_nxt            = 1'd0;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    mtrans_r15_nxt                  = mtrans_r15;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    address_sel_nxt                 = 'd0;\n    pc_sel_nxt                      = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    user_mode_regs_load_nxt         = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wsel_nxt               = 'hF;  \n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt )\n        begin\n        if ( itype == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt      = 2'd1; \n                    address_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wsel_nxt = instruction[15:12];\n                end\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_function_nxt  = instruction[6:5];\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shifter_operand && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shifter_operand && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt  = 4'd6; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n            end\n\n        \n        if ( mem_op )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( itype == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( o_rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 2'd1;\n                else\n                    reg_bank_wsel_nxt = o_rn_sel_nxt;\n                end\n\n                \n            if ( mem_op_post_indexed )\n               address_sel_nxt = 4'd4; \n            else\n               address_sel_nxt = 4'd1; \n\n            if ( instruction[25] && itype ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( itype == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n        if ( itype == BRANCH )\n            begin\n            pc_sel_nxt      = 2'd1; \n            address_sel_nxt = 4'd1; \n            alu_out_sel_nxt = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wsel_nxt  = 4'd14;  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n        if ( itype == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n            mtrans_r15_nxt                  = instruction[15];  \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] ) \n                begin\n                if ( instruction[24] )    \n                    address_sel_nxt = 4'd7; \n                else\n                    address_sel_nxt = 4'd4; \n                end\n            else \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    address_sel_nxt  = 4'd6; \n                else\n                    address_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            \n            \n            if ( {instruction[22:20],instruction[15]} == 4'b1010 )\n                user_mode_regs_load_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20]} == 3'b100 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wsel_nxt  = o_rn_sel_nxt;\n            end\n\n\n        if ( itype == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( itype == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            barrel_shift_data_sel_nxt       = 2'd2; \n            address_sel_nxt                 = 4'd4; \n            exclusive_exec_nxt              = 1'd1; \n            end\n\n\n        \n        if ( itype == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            address_sel_nxt                 = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( itype == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wsel_nxt               = 4'd14;  \n\n            address_sel_nxt                 = 4'd2;            \n            pc_sel_nxt                      = 2'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end\n\n    \n    \n    \n    \n    \n    \n    if ( instruction_valid && interrupt &&  next_interrupt != 3'd6 )\n        begin\n        \n        \n        \n        saved_current_instruction_wen   = 1'd1;\n\n        \n        \n        if ( next_interrupt == 3'd4 )\n            reg_write_sel_nxt               = 3'd7;            \n        else\n            reg_write_sel_nxt               = 3'd1;            \n\n        reg_bank_wsel_nxt               = 4'd14;           \n\n        address_sel_nxt                 = 4'd2;            \n        pc_sel_nxt                      = 2'd2;            \n\n        status_bits_mode_nxt            = interrupt_mode;  \n        status_bits_mode_wen_nxt        = 1'd1;\n\n        \n        status_bits_irq_mask_nxt        = 1'd1;\n        status_bits_irq_mask_wen_nxt    = 1'd1;\n\n        \n        if ( next_interrupt == 3'd2 ) \n            begin\n            status_bits_firq_mask_nxt        = 1'd1;\n            status_bits_firq_mask_wen_nxt    = 1'd1;\n            end\n        end\n",
        "assign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;",
        "assign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 ;   ",
        "assign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  ",
        "assign und_request  =   itype == CODTRANS ||\n                        itype == COREGOP  ||\n                      ( itype == CORTRANS && instruction[11:8] != 4'd15 );",
        "assign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = itype == SWI;\nassign dabt_request = dabt_reg;",
        "assign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};",
        "assign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;",
        "always @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase",
        "always @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_reg = 4'h0 ;\n    16'b??????????????10 : mtrans_reg = 4'h1 ;\n    16'b?????????????100 : mtrans_reg = 4'h2 ;\n    16'b????????????1000 : mtrans_reg = 4'h3 ;\n    16'b???????????10000 : mtrans_reg = 4'h4 ;\n    16'b??????????100000 : mtrans_reg = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg = 4'h6 ;\n    16'b????????10000000 : mtrans_reg = 4'h7 ;\n    16'b???????100000000 : mtrans_reg = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg = 4'ha ;\n    16'b????100000000000 : mtrans_reg = 4'hb ;\n    16'b???1000000000000 : mtrans_reg = 4'hc ;\n    16'b??10000000000000 : mtrans_reg = 4'hd ;\n    16'b?100000000000000 : mtrans_reg = 4'he ;\n    default              : mtrans_reg = 4'hf ;\n    endcase",
        "assign imm_shift_amount_nxt = shift_imm ;\n\n       \n       \nassign shift_imm_zero_nxt   = imm_shift_amount_nxt == 5'd0 &&       \n                              barrel_shift_amount_sel_nxt == 2'd2;  \n",
        "assign imm32_nxt            =  \n                               itype == MULT               ? {  32'd0                      } :\n\n                               \n                               itype == MTRANS             ? {  mtrans_base_reg_change     } :\n                               itype == BRANCH             ? {  offset24                   } :\n                               itype == TRANS              ? {  offset12                   } :\n                               instruction[11:8] == 4'h0  ? {            24'h0, imm8[7:0] } :\n                               instruction[11:8] == 4'h1  ? { imm8[1:0], 24'h0, imm8[7:2] } :\n                               instruction[11:8] == 4'h2  ? { imm8[3:0], 24'h0, imm8[7:4] } :\n                               instruction[11:8] == 4'h3  ? { imm8[5:0], 24'h0, imm8[7:6] } :\n                               instruction[11:8] == 4'h4  ? { imm8[7:0], 24'h0            } :\n                               instruction[11:8] == 4'h5  ? { 2'h0,  imm8[7:0], 22'h0     } :\n                               instruction[11:8] == 4'h6  ? { 4'h0,  imm8[7:0], 20'h0     } :\n                               instruction[11:8] == 4'h7  ? { 6'h0,  imm8[7:0], 18'h0     } :\n                               instruction[11:8] == 4'h8  ? { 8'h0,  imm8[7:0], 16'h0     } :\n                               instruction[11:8] == 4'h9  ? { 10'h0, imm8[7:0], 14'h0     } :\n                               instruction[11:8] == 4'ha  ? { 12'h0, imm8[7:0], 12'h0     } :\n                               instruction[11:8] == 4'hb  ? { 14'h0, imm8[7:0], 10'h0     } :\n                               instruction[11:8] == 4'hc  ? { 16'h0, imm8[7:0], 8'h0      } :\n                               instruction[11:8] == 4'hd  ? { 18'h0, imm8[7:0], 6'h0      } :\n                               instruction[11:8] == 4'he  ? { 20'h0, imm8[7:0], 4'h0      } :\n                                                            { 22'h0, imm8[7:0], 2'h0      } ;",
        "assign opcode        = instruction[24:21];\nassign condition_nxt = instruction[31:28];\n\nassign o_rm_sel_nxt    = instruction[3:0];\n\nassign o_rn_sel_nxt    = branch  ? 4'd15              : \n                                   instruction[19:16] ;\n\nassign o_rds_sel_nxt   = control_state == SWAP_WRITE  ? instruction[3:0]   : \n                         itype == MTRANS              ? mtrans_reg         :\n                         branch                       ? 4'd15              : \n                         rds_use_rs                   ? instruction[11:8]  :\n                                                        instruction[15:12] ;\n\n\nassign shift_imm     = instruction[11:7];\n\n\nassign shift_extend  = !instruction[25] && !instruction[4] && !(|instruction[11:7]) && instruction[6:5] == 2'b11;\n\nassign offset12      = { 20'h0, instruction[11:0]};\nassign offset24      = {{6{instruction[23]}}, instruction[23:0], 2'd0 }; \nassign imm8          = instruction[7:0];\n\nassign immediate_shifter_operand = instruction[25];\nassign rds_use_rs                = (itype == REGOP && !instruction[25] && instruction[4]) ||\n                                   (itype == MULT &&\n                                    (control_state == MULT_PROC1  ||\n                                     control_state == MULT_PROC2  ||\n                                     instruction_valid && !interrupt )) ;\nassign branch                    = itype == BRANCH;\nassign opcode_compare =\n            opcode == CMP ||\n            opcode == CMN ||\n            opcode == TEQ ||\n            opcode == TST ;\n\n\nassign mem_op               = itype == TRANS;\nassign load_op              = mem_op && instruction[20];\nassign store_op             = mem_op && !instruction[20];\nassign write_pc             = pc_wen_nxt && pc_sel_nxt != 2'd0;\nassign regop_set_flags      = itype == REGOP && instruction[20];",
        "always @*\n    casez ({instruction[27:20], instruction[7:4]})\n        12'b00010?001001 : itype = SWAP;\n        12'b000000??1001 : itype = MULT;\n        12'b00?????????? : itype = REGOP;\n        12'b01?????????? : itype = TRANS;\n        12'b100????????? : itype = MTRANS;\n        12'b101????????? : itype = BRANCH;\n        12'b110????????? : itype = CODTRANS;\n        12'b1110???????0 : itype = COREGOP;\n        12'b1110???????1 : itype = CORTRANS;\n        default:           itype = SWI;\n    endcase"
    ]
}