{
    "spec": "Module name: cmd_gen. Module specification: The cmd_gen module is a command generator for memory interface operations, designed to generate read, write, and refresh commands with associated addresses and burst lengths. It supports various modes of operation, including fixed, sequential, and pseudo-random (PRBS) patterns for address generation and instruction selection. The module takes inputs such as clk_i (clock), rst_i (reset), run_traffic_i (run signal), and various configuration signals for address, data, and instruction modes. It outputs addr_o (address), instr_o (instruction), bl_o (burst length), and cmd_o_vld (command valid signal). Internally, it uses signals like addr_counts (address counter), prbs_addr (PRBS-generated address), and instr_out (instruction output) to manage command generation. The module is divided into sections for address generation, instruction selection, burst length",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: cmd_gen\n\nExplanation: The cmd_gen module is a command generator for memory interface operations. It generates memory commands (read, write, refresh) with associated addresses and burst lengths. The module supports various modes of operation, including fixed, sequential, and pseudo-random (PRBS) patterns for address generation and instruction selection. It also handles burst length control and manages the flow of commands based on available buffer space and timing constraints. The module is configurable for different FPGA families (Spartan-6 and Virtex-6) and memory interface widths, allowing for flexibility in various memory controller designs."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk_i, rst_i, run_traffic_i, rd_buff_avail_i, force_wrcmd_gen_i, start_addr_i, end_addr_i, cmd_seed_i, data_seed_i, load_seed_i, addr_mode_i, data_mode_i, instr_mode_i, bl_mode_i, mode_load_i, fixed_bl_i, fixed_instr_i, fixed_addr_i, bram_addr_i, bram_instr_i, bram_bl_i, bram_valid_i, reading_rd_data_i, rdy_i.\n\nExplanation: These inputs control the module's operation, including clock, reset, run signals, address and data configurations, mode selections, and various parameters for generating commands and addresses.\n\nOutput ports:\naddr_o, instr_o, bl_o, cmd_o_vld, bram_rdy_o.\n\nExplanation:\n- addr_o: Output address for memory commands\n- instr_o: Output instruction (read/write/refresh)\n- bl_o: Output burst length\n- cmd_o_vld: Indicates when the output command is valid\n- bram_rdy_o: Indicates when the module is ready to accept BRAM data\n\nThese outputs provide the generated memory commands, addresses, and control signals to the memory interface."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nINC_COUNTS, addr_mode_reg, bl_mode_reg, addr_counts, addr_counts_next_r, prbs_bl, instr_out, prbs_instr_a, prbs_instr_b, prbs_brlen, prbs_addr, seq_addr, fixed_addr, addr_out, bl_out, bl_out_reg, mode_load_d1, mode_load_d2, mode_load_pulse, pipe_data_o, cmd_clk_en, pipe_out_vld, end_addr_range, force_bl1, A0_G_E0, A1_G_E1, A2_G_E2, A3_G_E3, AC3_G_E3, AC2_G_E2, AC1_G_E1, bl_out_clk_en, pipe_data_in, instr_vld, bl_out_vld, pipe_data_in_vld, gen_addr_larger, buf_avail_r, rd_data_received_counts, rd_data_counts_asked, rd_data_received_counts_total, instr_vld_dly1, first_load_pulse, mem_init_done, refresh_cmd_en, refresh_timer, refresh_prbs, cmd_vld, run_traffic_r, run_traffic_pulse.\n\nExplanation:\n- INC_COUNTS: Increment value for address counting\n- addr_mode_reg, bl_mode_reg: Registers to store address and burst length modes\n- addr_counts, addr_counts_next_r: Current and next address counters\n- prbs_bl, prbs_instr_a, prbs_instr_b, prbs_addr: PRBS generated values for burst length, instructions, and addresses\n- instr_out: Output instruction before pipelining\n- seq_addr, fixed_addr: Sequential and fixed address values\n- addr_out, bl_out, bl_out_reg: Output address, burst length, and registered burst length\n- mode_load_d1, mode_load_d2, mode_load_pulse: Mode load control signals\n- pipe_data_o, pipe_data_in: Pipelined data output and input\n- cmd_clk_en, pipe_out_vld: Command clock enable and pipeline output valid signals\n- end_addr_range: Calculated end address range\n- force_bl1: Flag to force burst length to 1\n- A0_G_E0, A1_G_E1, A2_G_E2, A3_G_E3, AC3_G_E3, AC2_G_E2, AC1_G_E1: Address comparison flags\n- bl_out_clk_en, instr_vld, bl_out_vld, pipe_data_in_vld: Various valid and enable signals\n- gen_addr_larger: Flag indicating if generated address is larger than end address\n- buf_avail_r, rd_data_received_counts, rd_data_counts_asked: Buffer and read data tracking\n- instr_vld_dly1, first_load_pulse: Delayed instruction valid and first load pulse signals\n- mem_init_done: Memory initialization completion flag\n- refresh_cmd_en, refresh_timer, refresh_prbs: Refresh command control signals\n- cmd_vld: Command valid signal\n- run_traffic_r, run_traffic_pulse: Run traffic control signals\n\nThese internal signals are used for various purposes such as address generation, instruction selection, pipelining, mode control, and managing the overall operation of the command generator module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n`define RD              3'b001;\n`define RDP             3'b011;\n`define WR              3'b000;\n`define WRP             3'b010;\n`define REFRESH         3'b100;\n\n\nmodule cmd_gen #\n  (\n   parameter TCQ           = 100,\n\n   parameter FAMILY = \"SPARTAN6\",\n   parameter MEM_BURST_LEN = 8,\n   parameter PORT_MODE = \"BI_MODE\",\n   parameter NUM_DQ_PINS   = 8,\n   parameter DATA_PATTERN  = \"DGEN_ALL\", \n   parameter CMD_PATTERN  = \"CGEN_ALL\",    \n   parameter ADDR_WIDTH    = 30,\n   parameter DWIDTH        = 32,\n   parameter PIPE_STAGES   = 0,\n   parameter MEM_COL_WIDTH = 10,       \n   parameter PRBS_EADDR_MASK_POS = 32'hFFFFD000,\n   parameter PRBS_SADDR_MASK_POS =  32'h00002000,\n   parameter PRBS_EADDR = 32'h00002000,\n   parameter PRBS_SADDR  = 32'h00002000\n   )\n  (\n   input           clk_i,\n   input [9:0]          rst_i,\n   input           run_traffic_i,\n  \n  input [6:0]               rd_buff_avail_i,\n  input                     force_wrcmd_gen_i,\n   input [31:0]             start_addr_i,   \n   input [31:0]             end_addr_i,\n   input [31:0]             cmd_seed_i,    \n   input [31:0]             data_seed_i,\n   input                    load_seed_i,   \n   \n   \n   input [2:0]              addr_mode_i,  \n                                          \n                                          \n                                          \n\n   input [3:0]              data_mode_i,  \n                                          \n                                          \n                                          \n                                          \n                                          \n\n  \n  \n   input [3:0]              instr_mode_i, \n                                          \n                                          \n                                          \n                                          \n                                          \n                                          \n\n\n   input [1:0]              bl_mode_i,  \n                                        \n                                        \n\n   input                    mode_load_i,\n\n   \n   input [5:0]              fixed_bl_i,      \n   input [2:0]              fixed_instr_i,   \n                                            \n                                            \n                                            \n                                            \n   input [31:0]             fixed_addr_i, \n   \n   input [31:0]             bram_addr_i,  \n   input [2:0]              bram_instr_i,\n   input [5:0]              bram_bl_i,\n   input                    bram_valid_i,\n   output                   bram_rdy_o,\n\n   input                    reading_rd_data_i,\n   \n   input           rdy_i,\n\n   output  [31:0]  addr_o,     \n   output  [2:0]   instr_o,    \n   output  [5:0]   bl_o,       \n\n   output          cmd_o_vld      \n  );\n\n   localparam PRBS_ADDR_WIDTH = 32;\n   localparam INSTR_PRBS_WIDTH = 16;\n   localparam BL_PRBS_WIDTH    = 16;\n\nlocalparam BRAM_DATAL_MODE       =    4'b0000;\nlocalparam FIXED_DATA_MODE       =    4'b0001;\nlocalparam ADDR_DATA_MODE        =    4'b0010;\nlocalparam HAMMER_DATA_MODE      =    4'b0011;\nlocalparam NEIGHBOR_DATA_MODE    =    4'b0100;\nlocalparam WALKING1_DATA_MODE    =    4'b0101;\nlocalparam WALKING0_DATA_MODE    =    4'b0110;\nlocalparam PRBS_DATA_MODE        =    4'b0111;\n\nreg [10:0] INC_COUNTS;\nreg [2:0]  addr_mode_reg;\nreg [1:0]  bl_mode_reg;\n\nreg [31:0] addr_counts;\nreg [31:0] addr_counts_next_r;\n\nwire  [14:0]  prbs_bl;\nreg [2:0] instr_out;\nwire [14:0] prbs_instr_a;\nwire [14:0] prbs_instr_b;\n\nreg  [5:0]   prbs_brlen;\n\nwire [31:0] prbs_addr;\nwire [31:0] seq_addr;\nwire [31:0] fixed_addr;\nreg [31:0] addr_out ;\nreg [5:0]  bl_out;\nreg [5:0] bl_out_reg;\nreg mode_load_d1;\nreg mode_load_d2;\nreg mode_load_pulse;\nwire [41:0] pipe_data_o;\nwire     cmd_clk_en;\n\nwire     pipe_out_vld;\nreg [15:0] end_addr_range;\n\nreg force_bl1;\nreg A0_G_E0;\nreg A1_G_E1;\nreg A2_G_E2;\nreg A3_G_E3;\nreg AC3_G_E3;\nreg AC2_G_E2;\nreg AC1_G_E1;\nreg bl_out_clk_en;\nreg [41:0] pipe_data_in;\nreg instr_vld;\nreg bl_out_vld;\nreg pipe_data_in_vld;\nreg gen_addr_larger ;\n    reg [6:0] buf_avail_r;\n    reg [6:0] rd_data_received_counts;\n    reg [6:0] rd_data_counts_asked;\n\n    reg [15:0] rd_data_received_counts_total;\nreg instr_vld_dly1;\nreg first_load_pulse;\nreg mem_init_done;\nreg refresh_cmd_en ;\nreg [9:0] refresh_timer;\nreg       refresh_prbs;\nreg       cmd_vld;\nreg run_traffic_r;\nreg run_traffic_pulse;\nalways @ (posedge clk_i)\nbegin\n     run_traffic_r <= #TCQ run_traffic_i;\n     if (  run_traffic_i &&   ~run_traffic_r )\n          run_traffic_pulse <= #TCQ 1'b1;\n     else\n          run_traffic_pulse <= #TCQ 1'b0;\nend     \n     \n\n\nassign addr_o       = pipe_data_o[31:0];\nassign instr_o      = pipe_data_o[34:32];\nassign bl_o         = pipe_data_o[40:35];\n\n\nassign cmd_o_vld    = pipe_data_o[41] & run_traffic_r;\nassign pipe_out_vld = pipe_data_o[41] & run_traffic_r;\n\n\nassign pipe_data_o = pipe_data_in;\n\nalways @(posedge clk_i) begin                    \n\n     instr_vld        <=  #TCQ  (cmd_clk_en | (mode_load_pulse & first_load_pulse));\n     bl_out_clk_en    <=  #TCQ  (cmd_clk_en | (mode_load_pulse & first_load_pulse));\n     bl_out_vld       <=  #TCQ  bl_out_clk_en;\n     pipe_data_in_vld <=  #TCQ  instr_vld;\n end\n\nalways @ (posedge clk_i) begin\n if (rst_i[0])\n    first_load_pulse <= #TCQ 1'b1;\n else if (mode_load_pulse)\n    first_load_pulse <= #TCQ 1'b0;\n else\n    first_load_pulse <= #TCQ first_load_pulse;\n end\n \ngenerate\nif (CMD_PATTERN == \"CGEN_BRAM\")  begin: cv1\n\nalways @(posedge clk_i) begin \n    cmd_vld          <=  #TCQ (cmd_clk_en ); \n                   \nend\nend endgenerate\n\n\ngenerate\nif (CMD_PATTERN != \"CGEN_BRAM\")  begin: cv2\n\nalways @(posedge clk_i) begin \n    cmd_vld          <=  #TCQ (cmd_clk_en | (mode_load_pulse & first_load_pulse )); \n                   \nend\nend endgenerate\n\n \nassign cmd_clk_en =  ( rdy_i & pipe_out_vld & run_traffic_i ||  mode_load_pulse && (CMD_PATTERN == \"CGEN_BRAM\"));\n \n\n \ninteger i;\ngenerate\nif (FAMILY == \"SPARTAN6\")  begin: pipe_in_s6\n    always @ (posedge clk_i) begin\n    if (rst_i[0])\n       pipe_data_in[31:0] <= #TCQ    start_addr_i;\n    else if (instr_vld)\n         if (gen_addr_larger && (addr_mode_reg == 3'b100 || addr_mode_reg == 3'b010)) \n            if (DWIDTH == 32)\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:8],8'h0};\n            else if (DWIDTH == 64)\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:9],9'h0};\n            else\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:10],10'h0};\n            \n         else begin\n             if (DWIDTH == 32)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:2],2'b00} ;\n             else if (DWIDTH == 64)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:3],3'b000} ;\n             else if (DWIDTH == 128)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:4],4'b0000} ;\n             end\nend\n\nend endgenerate\n\ngenerate\nif (FAMILY == \"VIRTEX6\")  begin: pipe_in_v6\n    always @ (posedge clk_i) begin\n    if (rst_i[1])\n       pipe_data_in[31:0] <= #TCQ    start_addr_i;\n    else if (instr_vld)\n       \n      if (gen_addr_larger && (addr_mode_reg == 3'b100 || addr_mode_reg == 3'b010)) \n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:8],8'h0};\n      else if ((NUM_DQ_PINS >= 128) && (NUM_DQ_PINS <=  144))\n      begin\n         if (MEM_BURST_LEN == 8)\n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:7], 7'b0000000};\n         else      \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:6], 6'b000000};\n       end\n            \n      else if ((NUM_DQ_PINS >= 64) && (NUM_DQ_PINS < 128))\n            begin\n\n         if (MEM_BURST_LEN == 8)\n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:6], 6'b000000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:5], 5'b00000};\n       end\n         \n      else if ((NUM_DQ_PINS == 32) || (NUM_DQ_PINS == 40) || (NUM_DQ_PINS == 48) || (NUM_DQ_PINS == 56))\n            begin\n\n         if (MEM_BURST_LEN == 8)     \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:5], 5'b00000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:4], 4'b0000};\n       end\n         \n      else if ((NUM_DQ_PINS == 16) || (NUM_DQ_PINS == 24))\n         if (MEM_BURST_LEN == 8)     \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:4], 4'b0000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:3], 3'b000};\n         \n      else if ((NUM_DQ_PINS == 8) )\n         if (MEM_BURST_LEN == 8)             \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:3], 3'b000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:2], 2'b00};\n         \nend\n\nend endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreg force_wrcmd_gen;\n   always @ (posedge clk_i) begin\n    if (rst_i[0])\n         force_wrcmd_gen <= #TCQ  1'b0;\n    else if (buf_avail_r == 63)\n         force_wrcmd_gen <= #TCQ  1'b0;\n    else if (instr_vld_dly1 && pipe_data_in[32]== 1 && pipe_data_in[41:35] > 16)\n         force_wrcmd_gen <= #TCQ  1'b1;\n    end\n\nreg [3:0]instr_mode_reg;\n always @ (posedge clk_i)\n begin\n      instr_mode_reg <= #TCQ  instr_mode_i;\n end \nreg force_smallvalue;\n always @ (posedge clk_i)\n begin\n    if (rst_i[2]) begin\n       pipe_data_in[40:32] <= #TCQ    'b0;\n       force_smallvalue <= #TCQ  1'b0;\n       end\n    else if (instr_vld) begin\n      if (instr_mode_reg == 0) begin\n              pipe_data_in[34:32] <= #TCQ    instr_out;\n              end\n      else if (instr_out[2]) begin\n              pipe_data_in[34:32] <= #TCQ    3'b100;\n              end\n        \n      else if ( FAMILY == \"SPARTAN6\" && PORT_MODE == \"RD_MODE\")\n      begin\n            pipe_data_in[34:32] <= #TCQ  {instr_out[2:1],1'b1};\n              end\n            \n      else if ((force_wrcmd_gen || buf_avail_r <=  15) && FAMILY == \"SPARTAN6\" &&  PORT_MODE != \"RD_MODE\")\n      begin\n            pipe_data_in[34:32] <= #TCQ    {instr_out[2],2'b00};\n              end\n      else begin\n             pipe_data_in[34:32] <= #TCQ    instr_out; \n              end\n\n   \n   \n     if (bl_mode_i[1:0] == 2'b00)                                        \n          pipe_data_in[40:35] <=  #TCQ   bl_out;\n     else if (FAMILY == \"VIRTEX6\")\n              pipe_data_in[40:35] <=  #TCQ   bl_out;\n     else if (force_bl1 && (bl_mode_reg == 2'b10 ) && FAMILY == \"SPARTAN6\") \n\n      pipe_data_in[40:35] <=  #TCQ   6'b000001;\n     else if ((buf_avail_r[5:0]  >= 6'b111100 && buf_avail_r[6] == 1'b0) && pipe_data_in[32] == 1'b1 && FAMILY == \"SPARTAN6\")         \n\n\n       begin\n        if (bl_mode_reg == 2'b10)\n            force_smallvalue    <= #TCQ  ~force_smallvalue;\n      \n        if ((buf_avail_r[6] && bl_mode_reg == 2'b10))\n\n\n             pipe_data_in[40:35] <= #TCQ    {2'b0,bl_out[3:1],1'b1};\n        else\n            pipe_data_in[40:35] <=   #TCQ  bl_out;\n        end\n   else if (buf_avail_r  < 64 && rd_buff_avail_i >= 0 && instr_out[0] == 1'b1 && (bl_mode_reg == 2'b10 )) \n         if (FAMILY == \"SPARTAN6\")\n         pipe_data_in[40:35] <=  #TCQ   {2'b0,bl_out[3:0] + 1};\n         else\n            pipe_data_in[40:35] <=   #TCQ  bl_out;\n\n    end  \n end \n\nalways @ (posedge clk_i) \nbegin\n     if (rst_i[2])\n        pipe_data_in[41] <=  #TCQ   'b0;\n     else if (cmd_vld)\n        pipe_data_in[41] <=  #TCQ   instr_vld;\n     else if (rdy_i && pipe_out_vld)\n        pipe_data_in[41] <=  #TCQ   1'b0;\n end\n\n always @ (posedge clk_i)\n    instr_vld_dly1  <=  #TCQ instr_vld;\n\nalways @ (posedge clk_i) begin\n if (rst_i[0]) begin\n    rd_data_counts_asked <= #TCQ  'b0;\n  end else if (instr_vld_dly1 && pipe_data_in[32]== 1) begin\n    if (pipe_data_in[40:35] == 0)\n       rd_data_counts_asked <=  #TCQ rd_data_counts_asked + (64) ;\n    else\n       rd_data_counts_asked <=  #TCQ rd_data_counts_asked + (pipe_data_in[40:35]) ;\n\n    end\n end\n\nalways @ (posedge clk_i) begin\n if (rst_i[0]) begin\n     rd_data_received_counts <= #TCQ  'b0;\n     rd_data_received_counts_total <= #TCQ  'b0;\n  end else if(reading_rd_data_i) begin\n     rd_data_received_counts <= #TCQ  rd_data_received_counts + 1;\n     rd_data_received_counts_total <= #TCQ  rd_data_received_counts_total + 1;\n     end\n end\n\n \n always @ (posedge clk_i)\n     buf_avail_r <= #TCQ  (rd_data_received_counts + 64) - rd_data_counts_asked;\n\nlocalparam BRAM_ADDR       = 2'b00;\nlocalparam FIXED_ADDR      = 2'b01;\nlocalparam PRBS_ADDR       = 2'b10;\nlocalparam SEQUENTIAL_ADDR = 2'b11;\n\n\nalways @ (posedge clk_i) begin\n   if (rst_i[3])\n        if (CMD_PATTERN == \"CGEN_BRAM\")\n         addr_mode_reg  <= #TCQ    3'b000;\n        else                                     \n         addr_mode_reg  <= #TCQ    3'b011;\n   else if (mode_load_pulse)\n         addr_mode_reg  <= #TCQ    addr_mode_i;\nend\n\nalways @ (posedge clk_i) begin\n   if (mode_load_pulse) begin\n        bl_mode_reg    <= #TCQ    bl_mode_i ;\n   end\n   mode_load_d1         <= #TCQ    mode_load_i;\n   mode_load_d2         <= #TCQ    mode_load_d1;\nend\n\nalways @ (posedge clk_i)\n     mode_load_pulse <= #TCQ  mode_load_d1 & ~mode_load_d2;\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk_i) begin\nif (rst_i[3])\n  addr_out <= #TCQ    start_addr_i;\nelse\n   case({addr_mode_reg})\n         3'b000: addr_out <= #TCQ    bram_addr_i;\n         3'b001: addr_out <= #TCQ    fixed_addr;\n         3'b010: addr_out <= #TCQ    prbs_addr;\n         3'b011: addr_out <= #TCQ    {2'b0,seq_addr[29:0]};\n         3'b100: addr_out <= #TCQ    {2'b00,seq_addr[6:2],seq_addr[23:0]};\n         3'b101: addr_out <= #TCQ    {prbs_addr[31:20],seq_addr[19:0]} ;\n\n         default : addr_out <= #TCQ    'b0;\n   endcase\nend\n\n\ngenerate\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_addr\ncmd_prbs_gen #\n  ( \n    .TCQ               (TCQ),\n    .FAMILY      (FAMILY),\n    .ADDR_WIDTH          (32),\n    .DWIDTH     (DWIDTH),\n    .PRBS_WIDTH (32),\n    .SEED_WIDTH (32),\n    .PRBS_EADDR_MASK_POS          (PRBS_EADDR_MASK_POS ),\n    .PRBS_SADDR_MASK_POS           (PRBS_SADDR_MASK_POS  ),\n    .PRBS_EADDR         (PRBS_EADDR),\n    .PRBS_SADDR          (PRBS_SADDR )\n   )\n   addr_prbs_gen\n  (\n   .clk_i            (clk_i),\n   .clk_en           (cmd_clk_en),\n   .prbs_seed_init   (mode_load_pulse),\n   .prbs_seed_i      (cmd_seed_i[31:0]),\n   .prbs_o           (prbs_addr)\n  );\nend\nendgenerate\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:8] >= end_addr_i[31:8])\n    gen_addr_larger <=     1'b1;\nelse\n    gen_addr_larger <=     1'b0;\nend\n\ngenerate\nif (FAMILY == \"SPARTAN6\" ) begin : INC_COUNTS_S\nalways @ (posedge clk_i)\nif (mem_init_done)\n    INC_COUNTS <= #TCQ  (DWIDTH/8)*(bl_out_reg);\nelse  begin\n    if (fixed_bl_i == 0)\n       INC_COUNTS <= #TCQ  (DWIDTH/8)*(64);\n    else\n       INC_COUNTS <= #TCQ  (DWIDTH/8)*(fixed_bl_i);\n    end\nend\nendgenerate\n\n\nlocalparam MEM_BURST_INT = MEM_BURST_LEN ;\n\n\ngenerate\nif (FAMILY == \"VIRTEX6\" ) begin : INC_COUNTS_V\n    always @ (posedge clk_i) begin\n    \nif ( (NUM_DQ_PINS >= 128 && NUM_DQ_PINS <= 144))       \n     INC_COUNTS <= #TCQ  64 * (MEM_BURST_INT/4);\n    \nelse if ( (NUM_DQ_PINS >= 64 && NUM_DQ_PINS < 128))       \n     INC_COUNTS <= #TCQ  32 * (MEM_BURST_INT/4);\nelse if ((NUM_DQ_PINS >= 32) && (NUM_DQ_PINS < 64))   \n     INC_COUNTS <= #TCQ  16 * (MEM_BURST_INT/4)   ;\nelse if ((NUM_DQ_PINS == 16) || (NUM_DQ_PINS == 24))  \n     INC_COUNTS <= #TCQ  8 * (MEM_BURST_INT/4);\nelse if ((NUM_DQ_PINS == 8) )\n     INC_COUNTS <= #TCQ  4 * (MEM_BURST_INT/4);\nend\nend\nendgenerate\n\ngenerate\n\n\nreg [31:0] end_addr_r;\n\nalways @ (posedge clk_i) begin\n     end_addr_r <= #TCQ  end_addr_i - DWIDTH/8*fixed_bl_i +1;\nend\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:24] >= end_addr_r[31:24])\n    AC3_G_E3 <= #TCQ    1'b1;\nelse\n    AC3_G_E3 <= #TCQ    1'b0;\n\nif (addr_out[23:16] >= end_addr_r[23:16])\n    AC2_G_E2 <= #TCQ    1'b1;\nelse\n    AC2_G_E2 <= #TCQ    1'b0;\n\nif (addr_out[15:8] >= end_addr_r[15:8])\n    AC1_G_E1 <= #TCQ    1'b1;\nelse\n    AC1_G_E1 <= #TCQ    1'b0;\nend\n\n\n    assign seq_addr = addr_counts;\n\nreg mode_load_pulse_r1;\n\nalways @ (posedge clk_i)\nbegin\n    mode_load_pulse_r1 <= #TCQ  mode_load_pulse;\n\nend\n\nalways @ (posedge clk_i)\n    end_addr_range <= #TCQ    end_addr_i[15:0] - (DWIDTH/8 *bl_out_reg) + 1   ;\n\nalways @ (posedge clk_i)\n    addr_counts_next_r <= #TCQ    addr_counts  + INC_COUNTS   ;\n\nreg cmd_clk_en_r;\nalways @ (posedge clk_i)\n  cmd_clk_en_r <= #TCQ  cmd_clk_en;\nalways @ (posedge clk_i) begin\n   if (rst_i[4]) begin\n        addr_counts <= #TCQ    start_addr_i;\n        mem_init_done <= #TCQ  1'b0;\n  end else if (cmd_clk_en_r || mode_load_pulse_r1)\n    if(addr_counts_next_r>= end_addr_i) begin\n                addr_counts <= #TCQ    start_addr_i;\n                mem_init_done <= #TCQ  1'b1;\n    end else if(addr_counts < end_addr_r)  \n                addr_counts <= #TCQ    addr_counts + INC_COUNTS;\nend\n\n \n\nendgenerate\n\ngenerate\n\nif (CMD_PATTERN == \"CGEN_FIXED\" || CMD_PATTERN == \"CGEN_ALL\" ) begin : fixed_addr_gen\n    assign fixed_addr = (DWIDTH == 32)?  {fixed_addr_i[31:2],2'b0} :\n                        (DWIDTH == 64)?  {fixed_addr_i[31:3],3'b0}:\n                        (DWIDTH <= 128)? {fixed_addr_i[31:4],4'b0}:\n                        (DWIDTH <= 256)? {fixed_addr_i[31:5],5'b0}:\n                                         {fixed_addr_i[31:6],6'b0};\n  end\nendgenerate\n\ngenerate\n\nif (CMD_PATTERN == \"CGEN_BRAM\" || CMD_PATTERN == \"CGEN_ALL\" ) begin : bram_addr_gen\nassign bram_rdy_o = run_traffic_i & cmd_clk_en & bram_valid_i | mode_load_pulse;\nend\nendgenerate\n\n\n\n\n\n\n\n\n\n\n\n\nreg [9:0]force_rd_counts;\nreg force_rd;\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n    force_rd_counts <= #TCQ  'b0;\nelse if (instr_vld) begin\n    force_rd_counts <= #TCQ  force_rd_counts + 1;\n    end\nend\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n    force_rd <= #TCQ  1'b0;\nelse if (force_rd_counts[3])\n    force_rd <= #TCQ  1'b1;\nelse\n    force_rd <= #TCQ  1'b0;\nend\n\n\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n   refresh_timer <= #TCQ  'b0;\nelse\n   refresh_timer <= #TCQ  refresh_timer + 1'b1;\n\nend\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n   refresh_cmd_en <= #TCQ  'b0;\n\nelse if (refresh_timer == 10'h3ff)\n\n   refresh_cmd_en <= #TCQ  'b1;\nelse if (cmd_clk_en && refresh_cmd_en)\n   refresh_cmd_en <= #TCQ  'b0;\n\nend   \n\nalways @ (posedge clk_i) begin\nif (FAMILY == \"SPARTAN6\")\n    refresh_prbs <= #TCQ  prbs_instr_b[3] & refresh_cmd_en;\nelse\n    refresh_prbs <= #TCQ  1'b0;\nend    \n  \nalways @ (instr_mode_i)\n  if(instr_mode_i  >2 && FAMILY == \"VIRTEX6\") begin\n   $display(\"Error ! Not valid instruction mode\");\n   $stop;\n   end\n  \n\nalways @ (posedge clk_i) begin\n   case(instr_mode_i)\n         0: instr_out <= #TCQ    bram_instr_i;\n         1: instr_out <= #TCQ    fixed_instr_i;\n         2: instr_out <= #TCQ    {2'b00,(prbs_instr_a[0] | force_rd)};\n         3: instr_out <= #TCQ    {2'b0,prbs_instr_a[0]};  \n         4: instr_out <= #TCQ    {1'b0,prbs_instr_b[0], prbs_instr_a[0]};  \n         \n\n         5: instr_out <= #TCQ    {refresh_prbs ,prbs_instr_b[0], prbs_instr_a[0]};  \n\n\n         default : instr_out <= #TCQ    {2'b00,prbs_instr_a[0]};\n   endcase\nend\n\ngenerate  \n\n\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_instr\ncmd_prbs_gen #\n  (\n    .TCQ               (TCQ),\n    .PRBS_CMD    (\"INSTR\"),\n    .ADDR_WIDTH  (32),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   instr_prbs_gen_a\n  (\n   .clk_i              (clk_i),\n   .clk_en             (cmd_clk_en),\n   .prbs_seed_init     (load_seed_i),\n   .prbs_seed_i        (cmd_seed_i[14:0]),\n   .prbs_o             (prbs_instr_a)\n  );\n\ncmd_prbs_gen #\n  (\n    .PRBS_CMD    (\"INSTR\"),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   instr_prbs_gen_b\n  (\n   .clk_i              (clk_i),\n   .clk_en             (cmd_clk_en),\n   .prbs_seed_init     (load_seed_i),\n   .prbs_seed_i        (cmd_seed_i[16:2]),\n   .prbs_o             (prbs_instr_b)\n  );\nend\nendgenerate\n\n\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:24] >= end_addr_i[31:24])\n    A3_G_E3 <= #TCQ    1'b1;\nelse\n    A3_G_E3 <= #TCQ    1'b0;\n\nif (addr_out[23:16] >= end_addr_i[23:16])\n    A2_G_E2 <= #TCQ    1'b1;\nelse\n    A2_G_E2 <= #TCQ    1'b0;\n\nif (addr_out[15:8] >= end_addr_i[15:8])\n    A1_G_E1 <= #TCQ    1'b1;\nelse\n    A1_G_E1 <= #TCQ    1'b0;\n\nif (addr_out[7:0] > end_addr_i[7:0] - DWIDTH/8* bl_out + 1)\n    A0_G_E0 <= #TCQ    1'b1;\nelse\n    A0_G_E0 <= #TCQ    1'b0;\nend\n\nalways @(addr_out,bl_out,end_addr_i,rst_i,buf_avail_r) begin\n    if (rst_i[5])\n        force_bl1 =   1'b0;\n    else if (((addr_out + bl_out* (DWIDTH/8)) >= end_addr_i) || (buf_avail_r  <= 50 && PORT_MODE == \"RD_MODE\"))\n        force_bl1 =   1'b1;\n    else\n        force_bl1 =   1'b0;\nend\n\nalways @(posedge clk_i) begin\n   if (rst_i[6])\n       bl_out_reg <= #TCQ    fixed_bl_i;\n   else if (bl_out_vld)\n       bl_out_reg <= #TCQ    bl_out;\nend\n\nalways @ (posedge clk_i) begin\n   if (mode_load_pulse)\n        bl_out <= #TCQ    fixed_bl_i ;\n   else if (cmd_clk_en) begin\n     case({bl_mode_reg})\n         0: bl_out <= #TCQ    bram_bl_i  ;\n         1: bl_out <= #TCQ    fixed_bl_i ;\n         2: bl_out <= #TCQ    prbs_brlen;\n         default : bl_out <= #TCQ    6'h1;\n     endcase\n   end\nend\n\n  \nalways @ (bl_out)\n  if(bl_out >2 && FAMILY == \"VIRTEX6\") begin\n   $display(\"Error ! Not valid burst length\");\n   $stop;\n   end\n  \n\ngenerate\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_bl\ncmd_prbs_gen #\n      (\n    .TCQ               (TCQ),      \n    .FAMILY      (FAMILY),\n    .PRBS_CMD    (\"BLEN\"),\n    .ADDR_WIDTH  (32),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   bl_prbs_gen\n  (\n   .clk_i             (clk_i),\n   .clk_en            (cmd_clk_en),\n   .prbs_seed_init    (load_seed_i),\n   .prbs_seed_i       (cmd_seed_i[16:2]),\n   .prbs_o            (prbs_bl)\n  );\nend\n\nalways @ (prbs_bl)\nif (FAMILY == \"SPARTAN6\")  \n    prbs_brlen =  (prbs_bl[5:0] == 6'b000000) ? 6'b000001: prbs_bl[5:0];\nelse \n     prbs_brlen =  6'b000010;\nendgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: cmd_gen. Module specification: The cmd_gen module is a command generator for memory interface operations, designed to generate read, write, and refresh commands with associated addresses and burst lengths. It supports various modes of operation, including fixed, sequential, and pseudo-random (PRBS) patterns for address generation and instruction selection. The module takes inputs such as clk_i (clock), rst_i (reset), run_traffic_i (run signal), and various configuration signals for address, data, and instruction modes. It outputs addr_o (address), instr_o (instruction), bl_o (burst length), and cmd_o_vld (command valid signal). Internally, it uses signals like addr_counts (address counter), prbs_addr (PRBS-generated address), and instr_out (instruction output) to manage command generation. The module is divided into sections for address generation, instruction selection, burst length"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: cmd_gen\n\nExplanation: The cmd_gen module is a command generator for memory interface operations. It generates memory commands (read, write, refresh) with associated addresses and burst lengths. The module supports various modes of operation, including fixed, sequential, and pseudo-random (PRBS) patterns for address generation and instruction selection. It also handles burst length control and manages the flow of commands based on available buffer space and timing constraints. The module is configurable for different FPGA families (Spartan-6 and Virtex-6) and memory interface widths, allowing for flexibility in various memory controller designs."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk_i, rst_i, run_traffic_i, rd_buff_avail_i, force_wrcmd_gen_i, start_addr_i, end_addr_i, cmd_seed_i, data_seed_i, load_seed_i, addr_mode_i, data_mode_i, instr_mode_i, bl_mode_i, mode_load_i, fixed_bl_i, fixed_instr_i, fixed_addr_i, bram_addr_i, bram_instr_i, bram_bl_i, bram_valid_i, reading_rd_data_i, rdy_i.\n\nExplanation: These inputs control the module's operation, including clock, reset, run signals, address and data configurations, mode selections, and various parameters for generating commands and addresses.\n\nOutput ports:\naddr_o, instr_o, bl_o, cmd_o_vld, bram_rdy_o.\n\nExplanation:\n- addr_o: Output address for memory commands\n- instr_o: Output instruction (read/write/refresh)\n- bl_o: Output burst length\n- cmd_o_vld: Indicates when the output command is valid\n- bram_rdy_o: Indicates when the module is ready to accept BRAM data\n\nThese outputs provide the generated memory commands, addresses, and control signals to the memory interface."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nINC_COUNTS, addr_mode_reg, bl_mode_reg, addr_counts, addr_counts_next_r, prbs_bl, instr_out, prbs_instr_a, prbs_instr_b, prbs_brlen, prbs_addr, seq_addr, fixed_addr, addr_out, bl_out, bl_out_reg, mode_load_d1, mode_load_d2, mode_load_pulse, pipe_data_o, cmd_clk_en, pipe_out_vld, end_addr_range, force_bl1, A0_G_E0, A1_G_E1, A2_G_E2, A3_G_E3, AC3_G_E3, AC2_G_E2, AC1_G_E1, bl_out_clk_en, pipe_data_in, instr_vld, bl_out_vld, pipe_data_in_vld, gen_addr_larger, buf_avail_r, rd_data_received_counts, rd_data_counts_asked, rd_data_received_counts_total, instr_vld_dly1, first_load_pulse, mem_init_done, refresh_cmd_en, refresh_timer, refresh_prbs, cmd_vld, run_traffic_r, run_traffic_pulse.\n\nExplanation:\n- INC_COUNTS: Increment value for address counting\n- addr_mode_reg, bl_mode_reg: Registers to store address and burst length modes\n- addr_counts, addr_counts_next_r: Current and next address counters\n- prbs_bl, prbs_instr_a, prbs_instr_b, prbs_addr: PRBS generated values for burst length, instructions, and addresses\n- instr_out: Output instruction before pipelining\n- seq_addr, fixed_addr: Sequential and fixed address values\n- addr_out, bl_out, bl_out_reg: Output address, burst length, and registered burst length\n- mode_load_d1, mode_load_d2, mode_load_pulse: Mode load control signals\n- pipe_data_o, pipe_data_in: Pipelined data output and input\n- cmd_clk_en, pipe_out_vld: Command clock enable and pipeline output valid signals\n- end_addr_range: Calculated end address range\n- force_bl1: Flag to force burst length to 1\n- A0_G_E0, A1_G_E1, A2_G_E2, A3_G_E3, AC3_G_E3, AC2_G_E2, AC1_G_E1: Address comparison flags\n- bl_out_clk_en, instr_vld, bl_out_vld, pipe_data_in_vld: Various valid and enable signals\n- gen_addr_larger: Flag indicating if generated address is larger than end address\n- buf_avail_r, rd_data_received_counts, rd_data_counts_asked: Buffer and read data tracking\n- instr_vld_dly1, first_load_pulse: Delayed instruction valid and first load pulse signals\n- mem_init_done: Memory initialization completion flag\n- refresh_cmd_en, refresh_timer, refresh_prbs: Refresh command control signals\n- cmd_vld: Command valid signal\n- run_traffic_r, run_traffic_pulse: Run traffic control signals\n\nThese internal signals are used for various purposes such as address generation, instruction selection, pipelining, mode control, and managing the overall operation of the command generator module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n`define RD              3'b001;\n`define RDP             3'b011;\n`define WR              3'b000;\n`define WRP             3'b010;\n`define REFRESH         3'b100;\n\n\nmodule cmd_gen #\n  (\n   parameter TCQ           = 100,\n\n   parameter FAMILY = \"SPARTAN6\",\n   parameter MEM_BURST_LEN = 8,\n   parameter PORT_MODE = \"BI_MODE\",\n   parameter NUM_DQ_PINS   = 8,\n   parameter DATA_PATTERN  = \"DGEN_ALL\", \n   parameter CMD_PATTERN  = \"CGEN_ALL\",    \n   parameter ADDR_WIDTH    = 30,\n   parameter DWIDTH        = 32,\n   parameter PIPE_STAGES   = 0,\n   parameter MEM_COL_WIDTH = 10,       \n   parameter PRBS_EADDR_MASK_POS = 32'hFFFFD000,\n   parameter PRBS_SADDR_MASK_POS =  32'h00002000,\n   parameter PRBS_EADDR = 32'h00002000,\n   parameter PRBS_SADDR  = 32'h00002000\n   )\n  (\n   input           clk_i,\n   input [9:0]          rst_i,\n   input           run_traffic_i,\n  \n  input [6:0]               rd_buff_avail_i,\n  input                     force_wrcmd_gen_i,\n   input [31:0]             start_addr_i,   \n   input [31:0]             end_addr_i,\n   input [31:0]             cmd_seed_i,    \n   input [31:0]             data_seed_i,\n   input                    load_seed_i,   \n   \n   \n   input [2:0]              addr_mode_i,  \n                                          \n                                          \n                                          \n\n   input [3:0]              data_mode_i,  \n                                          \n                                          \n                                          \n                                          \n                                          \n\n  \n  \n   input [3:0]              instr_mode_i, \n                                          \n                                          \n                                          \n                                          \n                                          \n                                          \n\n\n   input [1:0]              bl_mode_i,  \n                                        \n                                        \n\n   input                    mode_load_i,\n\n   \n   input [5:0]              fixed_bl_i,      \n   input [2:0]              fixed_instr_i,   \n                                            \n                                            \n                                            \n                                            \n   input [31:0]             fixed_addr_i, \n   \n   input [31:0]             bram_addr_i,  \n   input [2:0]              bram_instr_i,\n   input [5:0]              bram_bl_i,\n   input                    bram_valid_i,\n   output                   bram_rdy_o,\n\n   input                    reading_rd_data_i,\n   \n   input           rdy_i,\n\n   output  [31:0]  addr_o,     \n   output  [2:0]   instr_o,    \n   output  [5:0]   bl_o,       \n\n   output          cmd_o_vld      \n  );\n\n   localparam PRBS_ADDR_WIDTH = 32;\n   localparam INSTR_PRBS_WIDTH = 16;\n   localparam BL_PRBS_WIDTH    = 16;\n\nlocalparam BRAM_DATAL_MODE       =    4'b0000;\nlocalparam FIXED_DATA_MODE       =    4'b0001;\nlocalparam ADDR_DATA_MODE        =    4'b0010;\nlocalparam HAMMER_DATA_MODE      =    4'b0011;\nlocalparam NEIGHBOR_DATA_MODE    =    4'b0100;\nlocalparam WALKING1_DATA_MODE    =    4'b0101;\nlocalparam WALKING0_DATA_MODE    =    4'b0110;\nlocalparam PRBS_DATA_MODE        =    4'b0111;\n\nreg [10:0] INC_COUNTS;\nreg [2:0]  addr_mode_reg;\nreg [1:0]  bl_mode_reg;\n\nreg [31:0] addr_counts;\nreg [31:0] addr_counts_next_r;\n\nwire  [14:0]  prbs_bl;\nreg [2:0] instr_out;\nwire [14:0] prbs_instr_a;\nwire [14:0] prbs_instr_b;\n\nreg  [5:0]   prbs_brlen;\n\nwire [31:0] prbs_addr;\nwire [31:0] seq_addr;\nwire [31:0] fixed_addr;\nreg [31:0] addr_out ;\nreg [5:0]  bl_out;\nreg [5:0] bl_out_reg;\nreg mode_load_d1;\nreg mode_load_d2;\nreg mode_load_pulse;\nwire [41:0] pipe_data_o;\nwire     cmd_clk_en;\n\nwire     pipe_out_vld;\nreg [15:0] end_addr_range;\n\nreg force_bl1;\nreg A0_G_E0;\nreg A1_G_E1;\nreg A2_G_E2;\nreg A3_G_E3;\nreg AC3_G_E3;\nreg AC2_G_E2;\nreg AC1_G_E1;\nreg bl_out_clk_en;\nreg [41:0] pipe_data_in;\nreg instr_vld;\nreg bl_out_vld;\nreg pipe_data_in_vld;\nreg gen_addr_larger ;\n    reg [6:0] buf_avail_r;\n    reg [6:0] rd_data_received_counts;\n    reg [6:0] rd_data_counts_asked;\n\n    reg [15:0] rd_data_received_counts_total;\nreg instr_vld_dly1;\nreg first_load_pulse;\nreg mem_init_done;\nreg refresh_cmd_en ;\nreg [9:0] refresh_timer;\nreg       refresh_prbs;\nreg       cmd_vld;\nreg run_traffic_r;\nreg run_traffic_pulse;\nalways @ (posedge clk_i)\nbegin\n     run_traffic_r <= #TCQ run_traffic_i;\n     if (  run_traffic_i &&   ~run_traffic_r )\n          run_traffic_pulse <= #TCQ 1'b1;\n     else\n          run_traffic_pulse <= #TCQ 1'b0;\nend     \n     \n\n\nassign addr_o       = pipe_data_o[31:0];\nassign instr_o      = pipe_data_o[34:32];\nassign bl_o         = pipe_data_o[40:35];\n\n\nassign cmd_o_vld    = pipe_data_o[41] & run_traffic_r;\nassign pipe_out_vld = pipe_data_o[41] & run_traffic_r;\n\n\nassign pipe_data_o = pipe_data_in;\n\nalways @(posedge clk_i) begin                    \n\n     instr_vld        <=  #TCQ  (cmd_clk_en | (mode_load_pulse & first_load_pulse));\n     bl_out_clk_en    <=  #TCQ  (cmd_clk_en | (mode_load_pulse & first_load_pulse));\n     bl_out_vld       <=  #TCQ  bl_out_clk_en;\n     pipe_data_in_vld <=  #TCQ  instr_vld;\n end\n\nalways @ (posedge clk_i) begin\n if (rst_i[0])\n    first_load_pulse <= #TCQ 1'b1;\n else if (mode_load_pulse)\n    first_load_pulse <= #TCQ 1'b0;\n else\n    first_load_pulse <= #TCQ first_load_pulse;\n end\n \ngenerate\nif (CMD_PATTERN == \"CGEN_BRAM\")  begin: cv1\n\nalways @(posedge clk_i) begin \n    cmd_vld          <=  #TCQ (cmd_clk_en ); \n                   \nend\nend endgenerate\n\n\ngenerate\nif (CMD_PATTERN != \"CGEN_BRAM\")  begin: cv2\n\nalways @(posedge clk_i) begin \n    cmd_vld          <=  #TCQ (cmd_clk_en | (mode_load_pulse & first_load_pulse )); \n                   \nend\nend endgenerate\n\n \nassign cmd_clk_en =  ( rdy_i & pipe_out_vld & run_traffic_i ||  mode_load_pulse && (CMD_PATTERN == \"CGEN_BRAM\"));\n \n\n \ninteger i;\ngenerate\nif (FAMILY == \"SPARTAN6\")  begin: pipe_in_s6\n    always @ (posedge clk_i) begin\n    if (rst_i[0])\n       pipe_data_in[31:0] <= #TCQ    start_addr_i;\n    else if (instr_vld)\n         if (gen_addr_larger && (addr_mode_reg == 3'b100 || addr_mode_reg == 3'b010)) \n            if (DWIDTH == 32)\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:8],8'h0};\n            else if (DWIDTH == 64)\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:9],9'h0};\n            else\n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:10],10'h0};\n            \n         else begin\n             if (DWIDTH == 32)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:2],2'b00} ;\n             else if (DWIDTH == 64)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:3],3'b000} ;\n             else if (DWIDTH == 128)\n              pipe_data_in[31:0] <= #TCQ    {addr_out[31:4],4'b0000} ;\n             end\nend\n\nend endgenerate\n\ngenerate\nif (FAMILY == \"VIRTEX6\")  begin: pipe_in_v6\n    always @ (posedge clk_i) begin\n    if (rst_i[1])\n       pipe_data_in[31:0] <= #TCQ    start_addr_i;\n    else if (instr_vld)\n       \n      if (gen_addr_larger && (addr_mode_reg == 3'b100 || addr_mode_reg == 3'b010)) \n              pipe_data_in[31:0] <= #TCQ  {end_addr_i[31:8],8'h0};\n      else if ((NUM_DQ_PINS >= 128) && (NUM_DQ_PINS <=  144))\n      begin\n         if (MEM_BURST_LEN == 8)\n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:7], 7'b0000000};\n         else      \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:6], 6'b000000};\n       end\n            \n      else if ((NUM_DQ_PINS >= 64) && (NUM_DQ_PINS < 128))\n            begin\n\n         if (MEM_BURST_LEN == 8)\n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:6], 6'b000000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:5], 5'b00000};\n       end\n         \n      else if ((NUM_DQ_PINS == 32) || (NUM_DQ_PINS == 40) || (NUM_DQ_PINS == 48) || (NUM_DQ_PINS == 56))\n            begin\n\n         if (MEM_BURST_LEN == 8)     \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:5], 5'b00000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:4], 4'b0000};\n       end\n         \n      else if ((NUM_DQ_PINS == 16) || (NUM_DQ_PINS == 24))\n         if (MEM_BURST_LEN == 8)     \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:4], 4'b0000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:3], 3'b000};\n         \n      else if ((NUM_DQ_PINS == 8) )\n         if (MEM_BURST_LEN == 8)             \n            pipe_data_in[31:0] <= #TCQ    {addr_out[31:3], 3'b000};\n         else\n         pipe_data_in[31:0] <= #TCQ    {addr_out[31:2], 2'b00};\n         \nend\n\nend endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreg force_wrcmd_gen;\n   always @ (posedge clk_i) begin\n    if (rst_i[0])\n         force_wrcmd_gen <= #TCQ  1'b0;\n    else if (buf_avail_r == 63)\n         force_wrcmd_gen <= #TCQ  1'b0;\n    else if (instr_vld_dly1 && pipe_data_in[32]== 1 && pipe_data_in[41:35] > 16)\n         force_wrcmd_gen <= #TCQ  1'b1;\n    end\n\nreg [3:0]instr_mode_reg;\n always @ (posedge clk_i)\n begin\n      instr_mode_reg <= #TCQ  instr_mode_i;\n end \nreg force_smallvalue;\n always @ (posedge clk_i)\n begin\n    if (rst_i[2]) begin\n       pipe_data_in[40:32] <= #TCQ    'b0;\n       force_smallvalue <= #TCQ  1'b0;\n       end\n    else if (instr_vld) begin\n      if (instr_mode_reg == 0) begin\n              pipe_data_in[34:32] <= #TCQ    instr_out;\n              end\n      else if (instr_out[2]) begin\n              pipe_data_in[34:32] <= #TCQ    3'b100;\n              end\n        \n      else if ( FAMILY == \"SPARTAN6\" && PORT_MODE == \"RD_MODE\")\n      begin\n            pipe_data_in[34:32] <= #TCQ  {instr_out[2:1],1'b1};\n              end\n            \n      else if ((force_wrcmd_gen || buf_avail_r <=  15) && FAMILY == \"SPARTAN6\" &&  PORT_MODE != \"RD_MODE\")\n      begin\n            pipe_data_in[34:32] <= #TCQ    {instr_out[2],2'b00};\n              end\n      else begin\n             pipe_data_in[34:32] <= #TCQ    instr_out; \n              end\n\n   \n   \n     if (bl_mode_i[1:0] == 2'b00)                                        \n          pipe_data_in[40:35] <=  #TCQ   bl_out;\n     else if (FAMILY == \"VIRTEX6\")\n              pipe_data_in[40:35] <=  #TCQ   bl_out;\n     else if (force_bl1 && (bl_mode_reg == 2'b10 ) && FAMILY == \"SPARTAN6\") \n\n      pipe_data_in[40:35] <=  #TCQ   6'b000001;\n     else if ((buf_avail_r[5:0]  >= 6'b111100 && buf_avail_r[6] == 1'b0) && pipe_data_in[32] == 1'b1 && FAMILY == \"SPARTAN6\")         \n\n\n       begin\n        if (bl_mode_reg == 2'b10)\n            force_smallvalue    <= #TCQ  ~force_smallvalue;\n      \n        if ((buf_avail_r[6] && bl_mode_reg == 2'b10))\n\n\n             pipe_data_in[40:35] <= #TCQ    {2'b0,bl_out[3:1],1'b1};\n        else\n            pipe_data_in[40:35] <=   #TCQ  bl_out;\n        end\n   else if (buf_avail_r  < 64 && rd_buff_avail_i >= 0 && instr_out[0] == 1'b1 && (bl_mode_reg == 2'b10 )) \n         if (FAMILY == \"SPARTAN6\")\n         pipe_data_in[40:35] <=  #TCQ   {2'b0,bl_out[3:0] + 1};\n         else\n            pipe_data_in[40:35] <=   #TCQ  bl_out;\n\n    end  \n end \n\nalways @ (posedge clk_i) \nbegin\n     if (rst_i[2])\n        pipe_data_in[41] <=  #TCQ   'b0;\n     else if (cmd_vld)\n        pipe_data_in[41] <=  #TCQ   instr_vld;\n     else if (rdy_i && pipe_out_vld)\n        pipe_data_in[41] <=  #TCQ   1'b0;\n end\n\n always @ (posedge clk_i)\n    instr_vld_dly1  <=  #TCQ instr_vld;\n\nalways @ (posedge clk_i) begin\n if (rst_i[0]) begin\n    rd_data_counts_asked <= #TCQ  'b0;\n  end else if (instr_vld_dly1 && pipe_data_in[32]== 1) begin\n    if (pipe_data_in[40:35] == 0)\n       rd_data_counts_asked <=  #TCQ rd_data_counts_asked + (64) ;\n    else\n       rd_data_counts_asked <=  #TCQ rd_data_counts_asked + (pipe_data_in[40:35]) ;\n\n    end\n end\n\nalways @ (posedge clk_i) begin\n if (rst_i[0]) begin\n     rd_data_received_counts <= #TCQ  'b0;\n     rd_data_received_counts_total <= #TCQ  'b0;\n  end else if(reading_rd_data_i) begin\n     rd_data_received_counts <= #TCQ  rd_data_received_counts + 1;\n     rd_data_received_counts_total <= #TCQ  rd_data_received_counts_total + 1;\n     end\n end\n\n \n always @ (posedge clk_i)\n     buf_avail_r <= #TCQ  (rd_data_received_counts + 64) - rd_data_counts_asked;\n\nlocalparam BRAM_ADDR       = 2'b00;\nlocalparam FIXED_ADDR      = 2'b01;\nlocalparam PRBS_ADDR       = 2'b10;\nlocalparam SEQUENTIAL_ADDR = 2'b11;\n\n\nalways @ (posedge clk_i) begin\n   if (rst_i[3])\n        if (CMD_PATTERN == \"CGEN_BRAM\")\n         addr_mode_reg  <= #TCQ    3'b000;\n        else                                     \n         addr_mode_reg  <= #TCQ    3'b011;\n   else if (mode_load_pulse)\n         addr_mode_reg  <= #TCQ    addr_mode_i;\nend\n\nalways @ (posedge clk_i) begin\n   if (mode_load_pulse) begin\n        bl_mode_reg    <= #TCQ    bl_mode_i ;\n   end\n   mode_load_d1         <= #TCQ    mode_load_i;\n   mode_load_d2         <= #TCQ    mode_load_d1;\nend\n\nalways @ (posedge clk_i)\n     mode_load_pulse <= #TCQ  mode_load_d1 & ~mode_load_d2;\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk_i) begin\nif (rst_i[3])\n  addr_out <= #TCQ    start_addr_i;\nelse\n   case({addr_mode_reg})\n         3'b000: addr_out <= #TCQ    bram_addr_i;\n         3'b001: addr_out <= #TCQ    fixed_addr;\n         3'b010: addr_out <= #TCQ    prbs_addr;\n         3'b011: addr_out <= #TCQ    {2'b0,seq_addr[29:0]};\n         3'b100: addr_out <= #TCQ    {2'b00,seq_addr[6:2],seq_addr[23:0]};\n         3'b101: addr_out <= #TCQ    {prbs_addr[31:20],seq_addr[19:0]} ;\n\n         default : addr_out <= #TCQ    'b0;\n   endcase\nend\n\n\ngenerate\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_addr\ncmd_prbs_gen #\n  ( \n    .TCQ               (TCQ),\n    .FAMILY      (FAMILY),\n    .ADDR_WIDTH          (32),\n    .DWIDTH     (DWIDTH),\n    .PRBS_WIDTH (32),\n    .SEED_WIDTH (32),\n    .PRBS_EADDR_MASK_POS          (PRBS_EADDR_MASK_POS ),\n    .PRBS_SADDR_MASK_POS           (PRBS_SADDR_MASK_POS  ),\n    .PRBS_EADDR         (PRBS_EADDR),\n    .PRBS_SADDR          (PRBS_SADDR )\n   )\n   addr_prbs_gen\n  (\n   .clk_i            (clk_i),\n   .clk_en           (cmd_clk_en),\n   .prbs_seed_init   (mode_load_pulse),\n   .prbs_seed_i      (cmd_seed_i[31:0]),\n   .prbs_o           (prbs_addr)\n  );\nend\nendgenerate\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:8] >= end_addr_i[31:8])\n    gen_addr_larger <=     1'b1;\nelse\n    gen_addr_larger <=     1'b0;\nend\n\ngenerate\nif (FAMILY == \"SPARTAN6\" ) begin : INC_COUNTS_S\nalways @ (posedge clk_i)\nif (mem_init_done)\n    INC_COUNTS <= #TCQ  (DWIDTH/8)*(bl_out_reg);\nelse  begin\n    if (fixed_bl_i == 0)\n       INC_COUNTS <= #TCQ  (DWIDTH/8)*(64);\n    else\n       INC_COUNTS <= #TCQ  (DWIDTH/8)*(fixed_bl_i);\n    end\nend\nendgenerate\n\n\nlocalparam MEM_BURST_INT = MEM_BURST_LEN ;\n\n\ngenerate\nif (FAMILY == \"VIRTEX6\" ) begin : INC_COUNTS_V\n    always @ (posedge clk_i) begin\n    \nif ( (NUM_DQ_PINS >= 128 && NUM_DQ_PINS <= 144))       \n     INC_COUNTS <= #TCQ  64 * (MEM_BURST_INT/4);\n    \nelse if ( (NUM_DQ_PINS >= 64 && NUM_DQ_PINS < 128))       \n     INC_COUNTS <= #TCQ  32 * (MEM_BURST_INT/4);\nelse if ((NUM_DQ_PINS >= 32) && (NUM_DQ_PINS < 64))   \n     INC_COUNTS <= #TCQ  16 * (MEM_BURST_INT/4)   ;\nelse if ((NUM_DQ_PINS == 16) || (NUM_DQ_PINS == 24))  \n     INC_COUNTS <= #TCQ  8 * (MEM_BURST_INT/4);\nelse if ((NUM_DQ_PINS == 8) )\n     INC_COUNTS <= #TCQ  4 * (MEM_BURST_INT/4);\nend\nend\nendgenerate\n\ngenerate\n\n\nreg [31:0] end_addr_r;\n\nalways @ (posedge clk_i) begin\n     end_addr_r <= #TCQ  end_addr_i - DWIDTH/8*fixed_bl_i +1;\nend\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:24] >= end_addr_r[31:24])\n    AC3_G_E3 <= #TCQ    1'b1;\nelse\n    AC3_G_E3 <= #TCQ    1'b0;\n\nif (addr_out[23:16] >= end_addr_r[23:16])\n    AC2_G_E2 <= #TCQ    1'b1;\nelse\n    AC2_G_E2 <= #TCQ    1'b0;\n\nif (addr_out[15:8] >= end_addr_r[15:8])\n    AC1_G_E1 <= #TCQ    1'b1;\nelse\n    AC1_G_E1 <= #TCQ    1'b0;\nend\n\n\n    assign seq_addr = addr_counts;\n\nreg mode_load_pulse_r1;\n\nalways @ (posedge clk_i)\nbegin\n    mode_load_pulse_r1 <= #TCQ  mode_load_pulse;\n\nend\n\nalways @ (posedge clk_i)\n    end_addr_range <= #TCQ    end_addr_i[15:0] - (DWIDTH/8 *bl_out_reg) + 1   ;\n\nalways @ (posedge clk_i)\n    addr_counts_next_r <= #TCQ    addr_counts  + INC_COUNTS   ;\n\nreg cmd_clk_en_r;\nalways @ (posedge clk_i)\n  cmd_clk_en_r <= #TCQ  cmd_clk_en;\nalways @ (posedge clk_i) begin\n   if (rst_i[4]) begin\n        addr_counts <= #TCQ    start_addr_i;\n        mem_init_done <= #TCQ  1'b0;\n  end else if (cmd_clk_en_r || mode_load_pulse_r1)\n    if(addr_counts_next_r>= end_addr_i) begin\n                addr_counts <= #TCQ    start_addr_i;\n                mem_init_done <= #TCQ  1'b1;\n    end else if(addr_counts < end_addr_r)  \n                addr_counts <= #TCQ    addr_counts + INC_COUNTS;\nend\n\n \n\nendgenerate\n\ngenerate\n\nif (CMD_PATTERN == \"CGEN_FIXED\" || CMD_PATTERN == \"CGEN_ALL\" ) begin : fixed_addr_gen\n    assign fixed_addr = (DWIDTH == 32)?  {fixed_addr_i[31:2],2'b0} :\n                        (DWIDTH == 64)?  {fixed_addr_i[31:3],3'b0}:\n                        (DWIDTH <= 128)? {fixed_addr_i[31:4],4'b0}:\n                        (DWIDTH <= 256)? {fixed_addr_i[31:5],5'b0}:\n                                         {fixed_addr_i[31:6],6'b0};\n  end\nendgenerate\n\ngenerate\n\nif (CMD_PATTERN == \"CGEN_BRAM\" || CMD_PATTERN == \"CGEN_ALL\" ) begin : bram_addr_gen\nassign bram_rdy_o = run_traffic_i & cmd_clk_en & bram_valid_i | mode_load_pulse;\nend\nendgenerate\n\n\n\n\n\n\n\n\n\n\n\n\nreg [9:0]force_rd_counts;\nreg force_rd;\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n    force_rd_counts <= #TCQ  'b0;\nelse if (instr_vld) begin\n    force_rd_counts <= #TCQ  force_rd_counts + 1;\n    end\nend\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n    force_rd <= #TCQ  1'b0;\nelse if (force_rd_counts[3])\n    force_rd <= #TCQ  1'b1;\nelse\n    force_rd <= #TCQ  1'b0;\nend\n\n\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n   refresh_timer <= #TCQ  'b0;\nelse\n   refresh_timer <= #TCQ  refresh_timer + 1'b1;\n\nend\n\nalways @ (posedge clk_i) begin\nif (rst_i[4])\n   refresh_cmd_en <= #TCQ  'b0;\n\nelse if (refresh_timer == 10'h3ff)\n\n   refresh_cmd_en <= #TCQ  'b1;\nelse if (cmd_clk_en && refresh_cmd_en)\n   refresh_cmd_en <= #TCQ  'b0;\n\nend   \n\nalways @ (posedge clk_i) begin\nif (FAMILY == \"SPARTAN6\")\n    refresh_prbs <= #TCQ  prbs_instr_b[3] & refresh_cmd_en;\nelse\n    refresh_prbs <= #TCQ  1'b0;\nend    \n  \nalways @ (instr_mode_i)\n  if(instr_mode_i  >2 && FAMILY == \"VIRTEX6\") begin\n   $display(\"Error ! Not valid instruction mode\");\n   $stop;\n   end\n  \n\nalways @ (posedge clk_i) begin\n   case(instr_mode_i)\n         0: instr_out <= #TCQ    bram_instr_i;\n         1: instr_out <= #TCQ    fixed_instr_i;\n         2: instr_out <= #TCQ    {2'b00,(prbs_instr_a[0] | force_rd)};\n         3: instr_out <= #TCQ    {2'b0,prbs_instr_a[0]};  \n         4: instr_out <= #TCQ    {1'b0,prbs_instr_b[0], prbs_instr_a[0]};  \n         \n\n         5: instr_out <= #TCQ    {refresh_prbs ,prbs_instr_b[0], prbs_instr_a[0]};  \n\n\n         default : instr_out <= #TCQ    {2'b00,prbs_instr_a[0]};\n   endcase\nend\n\ngenerate  \n\n\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_instr\ncmd_prbs_gen #\n  (\n    .TCQ               (TCQ),\n    .PRBS_CMD    (\"INSTR\"),\n    .ADDR_WIDTH  (32),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   instr_prbs_gen_a\n  (\n   .clk_i              (clk_i),\n   .clk_en             (cmd_clk_en),\n   .prbs_seed_init     (load_seed_i),\n   .prbs_seed_i        (cmd_seed_i[14:0]),\n   .prbs_o             (prbs_instr_a)\n  );\n\ncmd_prbs_gen #\n  (\n    .PRBS_CMD    (\"INSTR\"),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   instr_prbs_gen_b\n  (\n   .clk_i              (clk_i),\n   .clk_en             (cmd_clk_en),\n   .prbs_seed_init     (load_seed_i),\n   .prbs_seed_i        (cmd_seed_i[16:2]),\n   .prbs_o             (prbs_instr_b)\n  );\nend\nendgenerate\n\n\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk_i) begin\nif (addr_out[31:24] >= end_addr_i[31:24])\n    A3_G_E3 <= #TCQ    1'b1;\nelse\n    A3_G_E3 <= #TCQ    1'b0;\n\nif (addr_out[23:16] >= end_addr_i[23:16])\n    A2_G_E2 <= #TCQ    1'b1;\nelse\n    A2_G_E2 <= #TCQ    1'b0;\n\nif (addr_out[15:8] >= end_addr_i[15:8])\n    A1_G_E1 <= #TCQ    1'b1;\nelse\n    A1_G_E1 <= #TCQ    1'b0;\n\nif (addr_out[7:0] > end_addr_i[7:0] - DWIDTH/8* bl_out + 1)\n    A0_G_E0 <= #TCQ    1'b1;\nelse\n    A0_G_E0 <= #TCQ    1'b0;\nend\n\nalways @(addr_out,bl_out,end_addr_i,rst_i,buf_avail_r) begin\n    if (rst_i[5])\n        force_bl1 =   1'b0;\n    else if (((addr_out + bl_out* (DWIDTH/8)) >= end_addr_i) || (buf_avail_r  <= 50 && PORT_MODE == \"RD_MODE\"))\n        force_bl1 =   1'b1;\n    else\n        force_bl1 =   1'b0;\nend\n\nalways @(posedge clk_i) begin\n   if (rst_i[6])\n       bl_out_reg <= #TCQ    fixed_bl_i;\n   else if (bl_out_vld)\n       bl_out_reg <= #TCQ    bl_out;\nend\n\nalways @ (posedge clk_i) begin\n   if (mode_load_pulse)\n        bl_out <= #TCQ    fixed_bl_i ;\n   else if (cmd_clk_en) begin\n     case({bl_mode_reg})\n         0: bl_out <= #TCQ    bram_bl_i  ;\n         1: bl_out <= #TCQ    fixed_bl_i ;\n         2: bl_out <= #TCQ    prbs_brlen;\n         default : bl_out <= #TCQ    6'h1;\n     endcase\n   end\nend\n\n  \nalways @ (bl_out)\n  if(bl_out >2 && FAMILY == \"VIRTEX6\") begin\n   $display(\"Error ! Not valid burst length\");\n   $stop;\n   end\n  \n\ngenerate\nif (CMD_PATTERN == \"CGEN_PRBS\" || CMD_PATTERN == \"CGEN_ALL\" ) begin: gen_prbs_bl\ncmd_prbs_gen #\n      (\n    .TCQ               (TCQ),      \n    .FAMILY      (FAMILY),\n    .PRBS_CMD    (\"BLEN\"),\n    .ADDR_WIDTH  (32),\n    .SEED_WIDTH  (15),\n    .PRBS_WIDTH  (20)\n   )\n   bl_prbs_gen\n  (\n   .clk_i             (clk_i),\n   .clk_en            (cmd_clk_en),\n   .prbs_seed_init    (load_seed_i),\n   .prbs_seed_i       (cmd_seed_i[16:2]),\n   .prbs_o            (prbs_bl)\n  );\nend\n\nalways @ (prbs_bl)\nif (FAMILY == \"SPARTAN6\")  \n    prbs_brlen =  (prbs_bl[5:0] == 6'b000000) ? 6'b000001: prbs_bl[5:0];\nelse \n     prbs_brlen =  6'b000010;\nendgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: cmd_gen. Module specification: The cmd_gen module is a command generator for memory interface operations, designed to generate read, write, and refresh commands with associated addresses and burst lengths. It supports various modes of operation, including fixed, sequential, and pseudo-random (PRBS) patterns for address generation and instruction selection. The module takes inputs such as clk_i (clock), rst_i (reset), run_traffic_i (run signal), and various configuration signals for address, data, and instruction modes. It outputs addr_o (address), instr_o (instruction), bl_o (burst length), and cmd_o_vld (command valid signal). Internally, it uses signals like addr_counts (address counter), prbs_addr (PRBS-generated address), and instr_out (instruction output) to manage command generation. The module is divided into sections for address generation, instruction selection, burst length"
                }
            ]
        }
    ]
}