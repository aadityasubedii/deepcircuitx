{
    "line_num": [
        [
            1519,
            1541
        ],
        [
            1509,
            1518
        ],
        [
            1497,
            1508
        ],
        [
            1485,
            1496
        ],
        [
            1462,
            1484
        ],
        [
            1457,
            1461
        ],
        [
            1438,
            1456
        ],
        [
            1426,
            1437
        ],
        [
            1417,
            1425
        ],
        [
            1409,
            1416
        ],
        [
            1390,
            1408
        ],
        [
            1375,
            1389
        ],
        [
            1365,
            1374
        ],
        [
            1355,
            1364
        ],
        [
            1347,
            1354
        ],
        [
            1337,
            1346
        ],
        [
            1329,
            1336
        ],
        [
            1311,
            1328
        ],
        [
            1301,
            1310
        ],
        [
            1291,
            1300
        ],
        [
            1278,
            1290
        ],
        [
            1268,
            1276
        ],
        [
            1246,
            1267
        ],
        [
            1240,
            1244
        ],
        [
            1228,
            1238
        ],
        [
            1215,
            1227
        ],
        [
            1200,
            1214
        ],
        [
            1185,
            1199
        ],
        [
            1172,
            1184
        ],
        [
            1160,
            1171
        ],
        [
            1147,
            1159
        ],
        [
            1136,
            1146
        ],
        [
            1122,
            1135
        ],
        [
            1107,
            1121
        ],
        [
            1092,
            1106
        ],
        [
            1083,
            1091
        ],
        [
            1072,
            1082
        ],
        [
            1068,
            1071
        ],
        [
            1056,
            1066
        ],
        [
            1035,
            1054
        ],
        [
            1022,
            1034
        ],
        [
            1004,
            1021
        ],
        [
            995,
            1003
        ],
        [
            991,
            994
        ],
        [
            978,
            990
        ],
        [
            968,
            975
        ],
        [
            960,
            965
        ],
        [
            949,
            955
        ],
        [
            945,
            948
        ],
        [
            941,
            944
        ],
        [
            932,
            940
        ],
        [
            922,
            931
        ],
        [
            916,
            920
        ],
        [
            905,
            915
        ],
        [
            884,
            901
        ],
        [
            869,
            870
        ],
        [
            826,
            868
        ],
        [
            791,
            814
        ],
        [
            780,
            786
        ],
        [
            767,
            775
        ],
        [
            761,
            761
        ],
        [
            760,
            760
        ],
        [
            732,
            753
        ],
        [
            723,
            729
        ],
        [
            713,
            721
        ],
        [
            700,
            710
        ],
        [
            689,
            696
        ],
        [
            665,
            682
        ],
        [
            654,
            662
        ],
        [
            642,
            650
        ],
        [
            612,
            636
        ],
        [
            606,
            606
        ],
        [
            599,
            604
        ],
        [
            585,
            593
        ],
        [
            560,
            566
        ],
        [
            540,
            556
        ],
        [
            538,
            538
        ],
        [
            535,
            535
        ],
        [
            532,
            532
        ],
        [
            522,
            524
        ],
        [
            520,
            521
        ],
        [
            516,
            516
        ],
        [
            503,
            515
        ],
        [
            499,
            502
        ],
        [
            487,
            496
        ],
        [
            471,
            485
        ],
        [
            427,
            429
        ]
    ],
    "blocks": [
        "          MCB_UICMDEN             <= 1'b0;  \n          MCB_UIDONECAL           <= 1'b1;  \n          Pre_SYSRST              <= 1'b0;  \n          IODRPCTRLR_CMD_VALID    <= 1'b0;\n          IODRPCTRLR_MEMCELL_ADDR <= 8'h00;\n          IODRPCTRLR_WRITE_DATA   <= 8'h00;\n          IODRPCTRLR_R_WB         <= 1'b0;\n          IODRPCTRLR_USE_BKST     <= 1'b0;\n          P_Term                  <= 6'b0;\n          N_Term                  <= 5'b0;\n          Active_IODRP            <= ZIO;\n          Max_Value_Previous      <= 8'b0;\n          MCB_UILDQSINC           <= 1'b0;  \n          MCB_UIUDQSINC           <= 1'b0;  \n          MCB_UILDQSDEC           <= 1'b0;  \n          MCB_UIUDQSDEC           <= 1'b0;  \n          counter_en              <= 1'b0;\n          First_Dyn_Cal_Done      <= 1'b0;  \n          Max_Value               <= Max_Value;\n          STATE                   <= START;\n        end\n      endcase\n    end",
        "              end\n            endcase\n          end\n        end\n        DONE: begin           \n          Pre_SYSRST              <= 1'b0;    \n          MCB_UICMDEN             <= 1'b0;  \n          STATE <= DONE;\n        end\n        default:        begin",
        "                if (DQS_DELAY > DQS_DELAY_LOWER_LIMIT  && counter_dec >= 8'h04) begin \n                  MCB_UILDQSDEC       <= 1'b1;      \n                  MCB_UIUDQSDEC       <= 1'b1;      \n                  DQS_DELAY           <= DQS_DELAY - 1'b1; \n                end\n              end\n              3'b010: begin\n                if (DQS_DELAY > DQS_DELAY_LOWER_LIMIT) \n                  STATE                 <= DECREMENT; \n                end\n              default: begin\n                  STATE               <= START_DYN_CAL; ",
        "        end\n        DECREMENT: begin      \n          STATE               <= START_DYN_CAL; \n          MCB_UILDQSINC       <= 1'b0;          \n          MCB_UIUDQSINC       <= 1'b0;          \n          MCB_UILDQSDEC       <= 1'b0;          \n          MCB_UIUDQSDEC       <= 1'b0;          \n          if (DQS_DELAY != 8'h00) begin\n            case (Inc_Dec_REFRSH_Flag)            \n              3'b011: begin\n                counter_dec <= counter_dec + 1'b1;\n                  STATE               <= DECREMENT; ",
        "        INCREMENT: begin      \n          STATE               <= START_DYN_CAL; \n          MCB_UILDQSINC       <= 1'b0;          \n          MCB_UIUDQSINC       <= 1'b0;          \n          MCB_UILDQSDEC       <= 1'b0;          \n          MCB_UIUDQSDEC       <= 1'b0;          \n          case (Inc_Dec_REFRSH_Flag)            \n            3'b101: begin\n              counter_inc <= counter_inc + 1'b1;\n                STATE               <= INCREMENT; \n              if (DQS_DELAY < DQS_DELAY_UPPER_LIMIT && counter_inc >= 8'h04) begin \n                MCB_UILDQSINC       <= 1'b1;      \n                MCB_UIUDQSINC       <= 1'b1;      \n                DQS_DELAY           <= DQS_DELAY + 1'b1;\n              end\n            end\n            3'b100: begin\n              if (DQS_DELAY < DQS_DELAY_UPPER_LIMIT)\n                STATE                <= INCREMENT; \n              end\n            default:  \n                STATE               <= START_DYN_CAL; \n          endcase",
        "        end\n        FIRST_DYN_CAL:  begin \n          First_Dyn_Cal_Done  <= 1'b1;          \n          STATE               <= START_DYN_CAL;\n        end",
        "          end\n        end\n        ANALYZE_MAX_VALUE:  begin \n          if (!First_Dyn_Cal_Done)\n            STATE <= FIRST_DYN_CAL;\n          else\n            if ((Max_Value<Max_Value_Previous)&&(Max_Value_Delta_Dn>=INCDEC_THRESHOLD)) begin\n              STATE <= DECREMENT;         \n              TARGET_DQS_DELAY   <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            end\n          else\n            if ((Max_Value>Max_Value_Previous)&&(Max_Value_Delta_Up>=INCDEC_THRESHOLD)) begin\n              STATE <= INCREMENT;         \n              TARGET_DQS_DELAY   <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            end\n          else begin\n            Max_Value           <= Max_Value_Previous;\n            STATE <= START_DYN_CAL;\n          end",
        "        end\n        WAIT10:  begin    \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT10;\n          else begin\n            Max_Value           <= IODRPCTRLR_READ_DATA;  \n            if (~First_In_Term_Done) begin\n              STATE               <= RST_DELAY;\n              First_In_Term_Done  <= 1'b1;\n            end\n            else\n              STATE               <= ANALYZE_MAX_VALUE;",
        "        READ_MAX_VALUE: begin     \n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= MaxValue;\n          IODRPCTRLR_R_WB         <= READ_MODE;\n          Max_Value_Previous      <= Max_Value;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= READ_MAX_VALUE;\n          else\n            STATE <= WAIT10;",
        "        end\n        WAIT9:  begin     \n          counter_en  <= 1'b1;\n          if (count < 6'd38)  \n            STATE     <= WAIT9;\n          else\n            STATE     <= READ_MAX_VALUE;\n        end",
        "            else begin\n              LastPass_DynCal <= `DYN_CAL_PASS;\n              STATE           <= WRITE_CALIBRATE;\n            end\n          end\n          else\n            STATE     <= START_DYN_CAL;\n        end\n        WRITE_CALIBRATE:  begin   \n          Pre_SYSRST              <= 1'b0; \n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= DelayControl;\n          IODRPCTRLR_WRITE_DATA   <= 8'h20; \n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          Active_IODRP            <= RZQ;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WRITE_CALIBRATE;\n          else\n            STATE <= WAIT9;",
        "\n        START_DYN_CAL:  begin       \n          Pre_SYSRST        <= 1'b0;      \n          counter_inc       <= 8'b0;\n          counter_dec       <= 8'b0;\n          if (SKIP_DYNAMIC_DQS_CAL & SKIP_DYN_IN_TERMINATION)\n            STATE <= DONE;  \n          else\n          if (IODRPCTRLR_RDY_BUSY_N && MCB_UODONECAL && ~SELFREFRESH_REQ_R1 ) begin  \n\n            \n            if (~SKIP_DYN_IN_TERMINATION & (LastPass_DynCal == `DYN_CAL_PASS)) begin\n              LastPass_DynCal <= `IN_TERM_PASS;\n              STATE           <= LOAD_RZQ_NTERM;\n            end",
        "        end\n        UDQS_WAIT2:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_WAIT2;\n          else begin\n            DQS_DELAY         <= DQS_DELAY_INITIAL;\n            TARGET_DQS_DELAY  <= DQS_DELAY_INITIAL;\n            STATE             <= START_DYN_CAL;\n          end\n        end",
        "        UDQS_WRITE_NEG_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= NegEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_WRITE_NEG_INDELAY;\n          else\n            STATE <= UDQS_WAIT2;",
        "        end\n        UDQS_WAIT1:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_WAIT1;\n          else begin\n            STATE           <= UDQS_WRITE_NEG_INDELAY;\n          end\n        end",
        "        UDQS_WRITE_POS_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= PosEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_WRITE_POS_INDELAY;\n          else\n            STATE <= UDQS_WAIT1;",
        "        end\n        LDQS_WAIT2:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_WAIT2;\n          else begin\n            STATE <= UDQS_WRITE_POS_INDELAY;\n          end\n        end",
        "        end\n        LDQS_WAIT1:  begin           \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_WAIT1;\n          else begin\n            STATE           <= LDQS_WRITE_NEG_INDELAY;\n          end\n        end\n        LDQS_WRITE_NEG_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= NegEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_WRITE_NEG_INDELAY;\n          else\n            STATE <= LDQS_WAIT2;",
        "        LDQS_WRITE_POS_INDELAY:  begin\n          IODRPCTRLR_MEMCELL_ADDR <= PosEdgeInDly;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= DQS_DELAY_INITIAL;\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_WRITE_POS_INDELAY;\n          else\n            STATE <= LDQS_WAIT1;",
        "        WAIT_FOR_UODONE:  begin  \n          Pre_SYSRST      <= 1'b0;    \n          if (IODRPCTRLR_RDY_BUSY_N && MCB_UODONECAL) begin \n            MCB_UICMDEN <= 1'b1;    \n            DQS_DELAY_INITIAL <= Mult_Divide(Max_Value, DQS_NUMERATOR, DQS_DENOMINATOR);\n            STATE       <= LDQS_WRITE_POS_INDELAY;\n          end\n          else\n            STATE       <= WAIT_FOR_UODONE;\n        end",
        "\n\n\n        START_DYN_CAL_PRE:  begin   \n          LastPass_DynCal <= `IN_TERM_PASS;\n          MCB_UICMDEN     <= 1'b0;    \n          MCB_UIDONECAL   <= 1'b1;    \n          Pre_SYSRST      <= 1'b1;    \n          if (~CALMODE_EQ_CALIBRATION)      \n            STATE       <= START_DYN_CAL;  \n          else if (pre_sysrst_minpulse_width_ok)   \n            STATE       <= WAIT_FOR_UODONE;\n          end",
        "        end\n        RST_DELAY:  begin     \n          if (Block_Reset) begin  \n            STATE       <= RST_DELAY;\n          end\t\t\t \n          else begin\n            STATE <= START_DYN_CAL_PRE;\n          end\n        end",
        "        OFF_ZIO_NTERM:  begin     \n          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= 8'b00;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= OFF_ZIO_NTERM;\n          else\n            STATE <= WAIT8;\n        end\n        WAIT8:  begin             \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT8;\n          else begin\n            if (First_In_Term_Done) begin\n              STATE               <= START_DYN_CAL; \n            end\n            else begin\n              STATE               <= WRITE_CALIBRATE; \n            end\n          end",
        "        WAIT7:  begin             \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT7;\n          else\n            STATE <= OFF_ZIO_NTERM;",
        "          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= 8'b00;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          P_Term                  <= 6'b0;\n          N_Term                  <= 5'b0;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= OFF_RZQ_PTERM;\n          else\n            STATE <= WAIT7;",
        "            STATE <= UDQS_PIN_WRITE_N_TERM;\n          else\n            STATE <= UDQS_PIN_N_TERM_WAIT;\n        end\n        UDQS_PIN_N_TERM_WAIT:  begin   \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_N_TERM_WAIT;\n          else begin\n            STATE           <= OFF_RZQ_PTERM;\n          end\n        end\n        OFF_RZQ_PTERM:  begin        \n          Active_IODRP            <= RZQ;",
        "        end\n        UDQS_PIN_P_TERM_WAIT:  begin  \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_P_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_PIN_WRITE_N_TERM;\n          end\n        end\n         UDQS_PIN_WRITE_N_TERM:  begin  \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_w};\n          MCB_UIADDR              <= IOI_UDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)",
        "            STATE <= UDQS_CLK_N_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_PIN_WRITE_P_TERM;\n          end\n        end\n         UDQS_PIN_WRITE_P_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_s};\n          MCB_UIADDR              <= IOI_UDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_PIN_WRITE_P_TERM;\n          else\n            STATE <= UDQS_PIN_P_TERM_WAIT;",
        "        UDQS_CLK_WRITE_N_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_s};\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_WRITE_N_TERM;\n          else\n            STATE <= UDQS_CLK_N_TERM_WAIT;\n        end\n        UDQS_CLK_N_TERM_WAIT:  begin \n          if (!MCB_RDY_BUSY_N)",
        "          if (MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_WRITE_P_TERM;\n          else\n            STATE <= UDQS_CLK_P_TERM_WAIT;\n        end\n        UDQS_CLK_P_TERM_WAIT:  begin \n          if (!MCB_RDY_BUSY_N)\n            STATE <= UDQS_CLK_P_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_CLK_WRITE_N_TERM;\n          end\n        end",
        "        LDQS_PIN_N_TERM_WAIT:  begin  \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_N_TERM_WAIT;\n          else begin\n            STATE           <= UDQS_CLK_WRITE_P_TERM;\n          end\n        end\n        UDQS_CLK_WRITE_P_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_w};\n          MCB_UIADDR              <= IOI_UDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;",
        "         LDQS_PIN_WRITE_N_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_w};\n          MCB_UIADDR              <= IOI_LDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_WRITE_N_TERM;\n          else\n            STATE <= LDQS_PIN_N_TERM_WAIT;\n        end",
        "          MCB_UIADDR              <= IOI_LDQS_PIN;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_WRITE_P_TERM;\n          else\n            STATE <= LDQS_PIN_P_TERM_WAIT;\n        end\n        LDQS_PIN_P_TERM_WAIT:  begin   \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_PIN_P_TERM_WAIT;\n          else begin\n            STATE           <= LDQS_PIN_WRITE_N_TERM;\n          end\n        end",
        "            STATE <= LDQS_CLK_WRITE_N_TERM;\n          else\n            STATE <= LDQS_CLK_N_TERM_WAIT;\n        end\n        LDQS_CLK_N_TERM_WAIT:  begin   \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_N_TERM_WAIT;\n          else begin\n            STATE           <= LDQS_PIN_WRITE_P_TERM;\n          end\n        end\n         LDQS_PIN_WRITE_P_TERM:  begin \n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_s};",
        "        end\n        LDQS_CLK_P_TERM_WAIT:  begin     \n          if (!MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_P_TERM_WAIT;\n          else begin\n            STATE           <= LDQS_CLK_WRITE_N_TERM;\n          end\n        end\n        LDQS_CLK_WRITE_N_TERM:  begin   \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0, N_Term_s};\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)",
        "          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00, P_Term_w};\n          MCB_UIADDR              <= IOI_LDQS_CLK;\n          MCB_CMD_VALID           <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= LDQS_CLK_WRITE_P_TERM;\n          else\n            STATE <= LDQS_CLK_P_TERM_WAIT;",
        "            if (MCB_UOREFRSHFLAG) begin\n              MCB_UIDRPUPDATE <= 1'b1;\n              STATE           <= OFF_RZQ_PTERM;\n            end\n            else\n              STATE <= WAIT6;   \n          end\n          else\n               STATE <= LDQS_CLK_WRITE_P_TERM;\n        end\n          LDQS_CLK_WRITE_P_TERM:  begin   ",
        "        WAIT6:  begin             \n          if (!MCB_RDY_BUSY_N)\n            STATE <= WAIT6;\n          else if (First_In_Term_Done) begin  ",
        "        BROADCAST_NTERM:  begin    \n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          MCB_CMD_VALID           <= 1'b1;\n          MCB_USE_BKST            <= 1'b1;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          if (MCB_RDY_BUSY_N)\n            STATE <= BROADCAST_NTERM;\n          else\n            STATE <= WAIT6;",
        "        WAIT5:  begin   \n          if (!MCB_RDY_BUSY_N)\n            STATE <= WAIT5;\n          else if (First_In_Term_Done) begin  \n            if (MCB_UOREFRSHFLAG) begin\n              MCB_UIDRPUPDATE <= 1'b1;\n              if (N_Term != N_Term_Prev) begin\n                N_Term_Prev <= N_Term;\n                STATE       <= BROADCAST_NTERM;\n              end\n              else\n                STATE <= OFF_RZQ_PTERM;\n            end\n            else\n              STATE <= WAIT5;   \n          end\n          else begin\n            N_Term_Prev <= N_Term;\n            STATE <= BROADCAST_NTERM;\n          end",
        "        BROADCAST_PTERM:  begin    \n\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          MCB_CMD_VALID           <= 1'b1;\n          MCB_UIDRPUPDATE         <= ~First_In_Term_Done; \n          MCB_USE_BKST            <= 1'b1;\n          if (MCB_RDY_BUSY_N)\n            STATE <= BROADCAST_PTERM;\n          else\n            STATE <= WAIT5;\n        end",
        "        WAIT_FOR_START_BROADCAST: begin   \n          Pre_SYSRST    <= 1'b0;      \n          Active_IODRP  <= MCB_PORT;\n          if (START_BROADCAST && IODRPCTRLR_RDY_BUSY_N) begin\n            if (P_Term != P_Term_Prev || SKIP_IN_TERM_CAL   ) begin\n              STATE       <= BROADCAST_PTERM;\n              P_Term_Prev <= P_Term;\n            end\n            else if (N_Term != N_Term_Prev) begin\n              N_Term_Prev <= N_Term;\n              STATE       <= BROADCAST_NTERM;\n            end\n            else\n              STATE <= OFF_RZQ_PTERM;\n          end\n          else\n            STATE   <= WAIT_FOR_START_BROADCAST;\n        end",
        "        SKEW : begin \n            P_Term_s <= Mult_Divide(P_Term, MULT_S, DIV_S);\n            N_Term_w <= Mult_Divide(N_Term-1, MULT_W, DIV_W);\n            P_Term_w <= Mult_Divide(P_Term, MULT_W, DIV_W);\n            N_Term_s <= Mult_Divide(N_Term-1, MULT_S, DIV_S);\n            P_Term   <= Mult_Divide(P_Term, MULT_S, DIV_S);\n            N_Term   <= Mult_Divide(N_Term-1, MULT_W, DIV_W);\n            STATE  <= WAIT_FOR_START_BROADCAST;\n        end",
        "        INC_NTERM: begin    \n          N_Term  <= N_Term + 1;\n          STATE   <= LOAD_ZIO_NTERM;\n        end",
        "        WAIT4:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT4;\n          else if ((!ZIO_IN)||(N_Term == 7'b1111111)) begin\n            if (PNSKEW) begin\n              STATE    <= SKEW;\n            end\n            else \n            STATE <= WAIT_FOR_START_BROADCAST;\n          end\n          else\n            STATE <= INC_NTERM;\n        end",
        "          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_ZIO_NTERM;\n          else",
        "        WAIT3:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT3;\n          else begin\n            STATE   <= LOAD_ZIO_NTERM;\n          end",
        "        LOAD_ZIO_PTERM: begin   \n          Active_IODRP            <= ZIO;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)",
        "        MULTIPLY_DIVIDE: begin \n           P_Term  <= Mult_Divide(P_Term-1, MULT, DIV);  \n           STATE <= LOAD_ZIO_PTERM;\n        end",
        "        INC_PTERM: begin    \n          P_Term  <= P_Term + 1;\n          STATE   <= LOAD_RZQ_PTERM;\n        end",
        "        WAIT2:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT2;\n          else if ((RZQ_IN)||(P_Term == 6'b111111)) begin\n            STATE <= MULTIPLY_DIVIDE;\n          end\n          else\n            STATE <= INC_PTERM;\n        end",
        "        LOAD_RZQ_PTERM: begin \n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= PTerm;\n          IODRPCTRLR_WRITE_DATA   <= {2'b00,P_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_RZQ_PTERM;\n          else\n            STATE <= WAIT2;\n        end",
        "        WAIT1:  begin   \n          if (!IODRPCTRLR_RDY_BUSY_N)\n            STATE <= WAIT1;\n          else\n            STATE <= LOAD_RZQ_PTERM;",
        "        LOAD_RZQ_NTERM: begin   \n          Active_IODRP            <= RZQ;\n          IODRPCTRLR_CMD_VALID    <= 1'b1;\n          IODRPCTRLR_MEMCELL_ADDR <= NTerm;\n          IODRPCTRLR_WRITE_DATA   <= {1'b0,N_Term};\n          IODRPCTRLR_R_WB         <= WRITE_MODE;\n          if (IODRPCTRLR_RDY_BUSY_N)\n            STATE <= LOAD_RZQ_NTERM;\n          else\n            STATE <= WAIT1;\n        end",
        "      case (STATE)\n        START:  begin   \n          MCB_UICMDEN     <= 1'b1;        \n          MCB_UIDONECAL   <= 1'b0;        \n          P_Term          <= 6'b0;\n          N_Term          <= 7'b0;\n          Pre_SYSRST      <= 1'b1;        \n          LastPass_DynCal <= `IN_TERM_PASS;\n          if (SKIP_IN_TERM_CAL) begin\n               STATE <= WAIT_FOR_START_BROADCAST;\n               P_Term <= 'b0;\n               N_Term <= 'b0;\n            end\n          else if (IODRPCTRLR_RDY_BUSY_N)\n            STATE  <= LOAD_RZQ_NTERM;\n          else\n            STATE  <= START;\n        end",
        "    else begin\n      counter_en              <= 1'b0;",
        "  always @(posedge UI_CLK) begin: NEXT_STATE_LOGIC\n    if (RST_reg) begin                      \n      MCB_CMD_VALID           <= 1'b0;\n      MCB_UIADDR              <= 5'b0;\n      MCB_UICMDEN             <= 1'b1;      \n      MCB_UIDONECAL           <= 1'b0;      \n      MCB_USE_BKST            <= 1'b0;\n      MCB_UIDRPUPDATE         <= 1'b1;\n      Pre_SYSRST              <= 1'b1;      \n      IODRPCTRLR_CMD_VALID    <= 1'b0;\n      IODRPCTRLR_MEMCELL_ADDR <= NoOp;\n      IODRPCTRLR_WRITE_DATA   <= 1'b0;\n      IODRPCTRLR_R_WB         <= WRITE_MODE;\n      IODRPCTRLR_USE_BKST     <= 1'b0;\n      P_Term                  <= 6'b0;\n      N_Term                  <= 7'b0;\n      P_Term_s                <= 6'b0;\n      N_Term_w                <= 7'b0;\n      P_Term_w                <= 6'b0;\n      N_Term_s                <= 7'b0;\n      P_Term_Prev             <= 6'b0;\n      N_Term_Prev             <= 7'b0;\n      Active_IODRP            <= RZQ;\n      MCB_UILDQSINC           <= 1'b0;      \n      MCB_UIUDQSINC           <= 1'b0;      \n      MCB_UILDQSDEC           <= 1'b0;      \n      MCB_UIUDQSDEC           <= 1'b0;      \n      counter_en              <= 1'b0;\n      First_Dyn_Cal_Done      <= 1'b0;      \n      Max_Value               <= 8'b0;\n      Max_Value_Previous      <= 8'b0;\n      STATE                   <= START;\n      DQS_DELAY               <= 8'h0; \n      DQS_DELAY_INITIAL       <= 8'h0;\n      TARGET_DQS_DELAY        <= 8'h0;\n      LastPass_DynCal         <= `IN_TERM_PASS;\n      First_In_Term_Done      <= 1'b0;\n      MCB_UICMD               <= 1'b0;\n      MCB_UICMDIN             <= 1'b0;\n      MCB_UIDQCOUNT           <= 4'h0;\n      counter_inc             <= 8'h0;\n      counter_dec             <= 8'h0;\n    end",
        "  always @(*) begin: ACTIVE_IODRP\n    case (Active_IODRP)\n      RZQ:      begin\n        RZQ_IODRP_CS  = IODRP_CS;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = RZQ_IODRP_SDO;\n      end\n      ZIO:      begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = IODRP_CS;\n        IODRP_SDO     = ZIO_IODRP_SDO;\n      end\n      MCB_PORT: begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = 1'b0;\n      end\n      default:  begin\n        RZQ_IODRP_CS  = 1'b0;\n        ZIO_IODRP_CS  = 1'b0;\n        IODRP_SDO     = 1'b0;\n      end\n    endcase\n  end",
        " always @(posedge UI_CLK or posedge MCB_UODATAVALID)\n  begin\n    if (MCB_UODATAVALID)\n        MCB_UODATAVALID_U <= 1'b1;\n    else\n        MCB_UODATAVALID_U <= MCB_UODATAVALID;\n  end",
        " always @(posedge UI_CLK)\n  begin\n    if (RST_reg)\n        count <= 6'd0;\n    else if (counter_en)\n        count <= count + 1'b1;\n    else\n        count <= 6'd0;\n  end",
        "assign Inc_Flag = (TARGET_DQS_DELAY > DQS_DELAY);",
        "assign Dec_Flag = (TARGET_DQS_DELAY < DQS_DELAY);",
        "always @ (posedge UI_CLK) begin\n   if (RST) \n    begin\n       WaitTimer <= 'b0;\n       WarmEnough <= 1'b1;\n    end       \n  else if (~SELFREFRESH_REQ_R2 && SELFREFRESH_REQ_R1)  \n    begin\n       WaitTimer <= 'b0;\n       WarmEnough <= 1'b0;\n    end       \n  else if (WaitTimer == 8'h4)\n    begin\n       WaitTimer <= WaitTimer ;\n       WarmEnough <= 1'b1;\n    end       \n  else if (WaitCountEnable)\n       WaitTimer <= WaitTimer + 1;\n  else\n       WaitTimer <= WaitTimer ;\n  \nend  ",
        "always @ (posedge UI_CLK)\nbegin\nif (RST)\n   State_Start_DynCal_R1 <= 1'b0;\nelse \n   State_Start_DynCal_R1 <= State_Start_DynCal;\nend",
        "always @ (posedge UI_CLK)\nbegin\nif (RST)\n   State_Start_DynCal <= 1'b0;\nelse if (STATE == START_DYN_CAL)   \n   State_Start_DynCal <= 1'b1;\nelse\n   State_Start_DynCal <= 1'b0;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    WaitCountEnable <= 1'b0;\n  else if (~SELFREFRESH_REQ_R2 && SELFREFRESH_REQ_R1)  \n    WaitCountEnable <= 1'b0;\n    \n  else if (!PERFORM_START_DYN_CAL_AFTER_SELFREFRESH && PERFORM_START_DYN_CAL_AFTER_SELFREFRESH_R1)\n    WaitCountEnable <= 1'b1;\n  else\n    WaitCountEnable <=  WaitCountEnable;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    SELFREFRESH_MODE <= 1'b0;\n  else if (SELFREFRESH_MCB_MODE_R2)  \n    SELFREFRESH_MODE <= 1'b1;\n    else if (WarmEnough)\n     SELFREFRESH_MODE <= 1'b0;\nend",
        "always @ (posedge UI_CLK) begin\n  if (RST) begin\n    PERFORM_START_DYN_CAL_AFTER_SELFREFRESH  <= 1'b0;\n    START_DYN_CAL_STATE_R1 <= 1'b0;\n  end \n  else begin\n    \n    PERFORM_START_DYN_CAL_AFTER_SELFREFRESH_R1 <= PERFORM_START_DYN_CAL_AFTER_SELFREFRESH;\n    if (STATE == START_DYN_CAL)\n      START_DYN_CAL_STATE_R1 <= 1'b1;\n    else\n      START_DYN_CAL_STATE_R1 <= 1'b0;\n      if (WAIT_SELFREFRESH_EXIT_DQS_CAL && STATE != START_DYN_CAL && START_DYN_CAL_STATE_R1 )\n        PERFORM_START_DYN_CAL_AFTER_SELFREFRESH <= 1'b1;\n      else if (STATE == START_DYN_CAL && ~SELFREFRESH_MCB_MODE_R3)\n        PERFORM_START_DYN_CAL_AFTER_SELFREFRESH <= 1'b0;\n      end\n  end",
        "always @ (posedge UI_CLK) begin\n  if (RST)\n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b0;\n  else if (~SELFREFRESH_MCB_MODE_R3 && SELFREFRESH_MCB_MODE_R2)  \n\n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b1;\n  else if (WAIT_SELFREFRESH_EXIT_DQS_CAL && ~SELFREFRESH_REQ_R3 && PERFORM_START_DYN_CAL_AFTER_SELFREFRESH) \n    WAIT_SELFREFRESH_EXIT_DQS_CAL <= 1'b0;\nend   ",
        "always @ ( posedge UI_CLK) begin\n  if (RST)\n    SELFREFRESH_MCB_REQ <= 1'b0;\n  else if (PLL_LOCK_R2 && ~SELFREFRESH_REQ_R3 )\n\n    SELFREFRESH_MCB_REQ <=  1'b0;\n  else if (STATE == START_DYN_CAL && SELFREFRESH_REQ_R3)  \n    SELFREFRESH_MCB_REQ <= 1'b1;\nend",
        "always @ ( posedge UI_CLK, posedge RST) begin\n  \n  if (RST)\n    begin\n      SELFREFRESH_MCB_MODE_R1 <= 1'b0;\n      SELFREFRESH_MCB_MODE_R2 <= 1'b0;\n      SELFREFRESH_MCB_MODE_R3 <= 1'b0;\n      SELFREFRESH_REQ_R1      <= 1'b0;\n      SELFREFRESH_REQ_R2      <= 1'b0;\n      SELFREFRESH_REQ_R3      <= 1'b0;\n      PLL_LOCK_R1             <= 1'b0;\n      PLL_LOCK_R2             <= 1'b0;\n    end\n  else \n    begin\n      SELFREFRESH_MCB_MODE_R1 <= SELFREFRESH_MCB_MODE;\n      SELFREFRESH_MCB_MODE_R2 <= SELFREFRESH_MCB_MODE_R1;\n      SELFREFRESH_MCB_MODE_R3 <= SELFREFRESH_MCB_MODE_R2;\n      SELFREFRESH_REQ_R1      <= SELFREFRESH_REQ;\n      SELFREFRESH_REQ_R2      <= SELFREFRESH_REQ_R1;\n      SELFREFRESH_REQ_R3      <= SELFREFRESH_REQ_R2;\n      PLL_LOCK_R1             <= PLL_LOCK;\n      PLL_LOCK_R2             <= PLL_LOCK_R1;\n    end\n end ",
        "assign pre_sysrst_minpulse_width_ok = pre_sysrst_cnt[3];",
        "always @ (posedge UI_CLK )begin\n  if (STATE == START_DYN_CAL_PRE)\n     pre_sysrst_cnt <= pre_sysrst_cnt + 1;\n  else\n     pre_sysrst_cnt <= 4'b0;\nend",
        "always @ (posedge UI_CLK or posedge non_violating_rst ) begin  \n  if (non_violating_rst)          \n    RST_reg <= 1'b1;                                       \n  else if (~WAIT_200us_COUNTER[15])\n    RST_reg <= 1'b1;         \n  else \n    RST_reg     <= rst_tmp; \n    \nend",
        "always @ (posedge UI_CLK ) begin  \nif (RstCounter >= TZQINIT_MAXCNT) \n    Rst_condition1 <= 1'b1;\nelse\n    Rst_condition1 <= 1'b0;\n\nend",
        "always @ (posedge UI_CLK or posedge RST ) begin  \n  if (RST) begin         \n    Block_Reset <= 1'b0;\n    RstCounter  <= 10'b0;\nend\n  else begin\n    Block_Reset <= 1'b0;                   \n    if (Pre_SYSRST)\n      RstCounter  <= RST_CNT;              \n    else begin\n      if (RstCounter < TZQINIT_MAXCNT) begin \n        Block_Reset <= 1'b1;               \n        RstCounter  <= RstCounter + 1'b1;  \n      end\n    end\n  end\nend",
        "assign MCB_SYSRST = (Pre_SYSRST );",
        "assign non_violating_rst = RST & Rst_condition1;         ",
        "assign rst_tmp    = (~PLL_LOCK_R2 && ~SELFREFRESH_MODE); ",
        "always @ (RST)\n   CKE_Train <= 1'b0;\nend ",
        "generate\nif( C_MEM_TYPE != \"DDR2\") begin : gen_cketrain_b",
        "end",
        "always @ ( posedge UI_CLK, posedge RST)\nbegin \nif (RST)\n   CKE_Train <= 1'b0;\nelse \n  if (STATE == WAIT_FOR_UODONE && MCB_UODONECAL)\n   CKE_Train <= 1'b0;\n  else if (WAIT_200us_COUNTER[15] && ~MCB_UODONECAL)\n   CKE_Train <= 1'b1;\n  else\n   CKE_Train <= 1'b0;\n  \nend",
        "generate\nif( C_MEM_TYPE == \"DDR2\") begin : gen_cketrain_a\n\n",
        " always @ (posedge UI_CLK, posedge RST)\n  begin\n   if (RST)\n     WAIT_200us_COUNTER <= (C_SIMULATION == \"TRUE\") ? 16'h7FF0 : 16'h0;\n   else \n      if (WAIT_200us_COUNTER[15])  \n        WAIT_200us_COUNTER <= WAIT_200us_COUNTER                        ;\n      else\n        WAIT_200us_COUNTER <= WAIT_200us_COUNTER + 1'b1;\n  end ",
        "function [7:0] Mult_Divide;\ninput   [7:0]   Input;\ninput   [7:0]   Mult;\ninput   [7:0]   Div;\nreg     [3:0]   count;\nreg     [15:0]   Result;\nbegin\n  Result  = 0;\n  for (count = 0; count < Mult; count = count+1) begin\n    Result    = Result + Input;\n  end\n  Result      = Result / Div;\n  Mult_Divide = Result[7:0];\nend\nendfunction",
        "always @ (posedge UI_CLK)\n     DONE_SOFTANDHARD_CAL    <= ((DQS_DELAY_INITIAL != 8'h00) || (STATE == DONE)) && MCB_UODONECAL;  \n"
    ]
}