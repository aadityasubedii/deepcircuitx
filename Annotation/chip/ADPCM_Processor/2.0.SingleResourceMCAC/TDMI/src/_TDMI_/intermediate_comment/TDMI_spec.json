{
    "spec": "Module name: TDMI. \n\nModule specification: The TDMI module functions as a serial data receiver, primarily used for Test Data Input (TDI) within a JTAG interface. It receives and processes serial data under operation of the \"ser_clk\" signal, attends to frame synchronization via \"frame_sync\", and consequently stores processed data in system registers that are readable via a Wishbone interface. The module also provides test mode, scan mode, and typical operation mode options, and includes ports for handling reset, input-output operations, and error checks. \n\nData communication is enabled by numerous input and output ports such as \"reset\", \"ser_clk\", \"data_in\u201c, \"frame_sync\", \"scan_in0 to scan_in4\", \"scan_enable\", \"test_mode\" as input ports, and \"new_data_int\", \"scan_out0 to scan_out4\", \"o_wb_dat\", \"o_wb_ack\", \"o_wb_err\" as output ports. The input ports serve controls like data input, serial clocking, frame syncing, and Wishbone interfacing, while output ports deliver data and status information, demonstrating data's availability, acknowledging data transfers, or indicating errors.\n\nInternally, signals such as \"sys_clk\", \"serial_clk\", \"selected_clk\", \"ch_count\", \"bit_count\", \"prev_frame_sync\", \"data_out_buf\", \"ch_buf_1\", \"ch_buf_2\", \"data_buf_1\", \"data_buf_2\", \"start_read\", \"int_buf_1\", \"int_set\", \"bit_count_buf\", \"tdmi_begin\", \"fs_start\" are employed to manage clocking, data pipelining, bit counting, frame syncing, channel and data buffering, read triggering, interrupts, and process beginning.\n\nThe RTL code is structured into distinct blocks corresponding to initialization, clock buffering, frame buffer operations, data and channel buffering, reading/writing operations, and error handling. Each block performs specific tasks, affording the module its serial data processing ability and interfacing functionality. With such design and operation, TDMI qualifies as an intricate part of the hardware system, purposing data reception and processing.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: TDMI.\n\nExplanation: The TDMI module looks like a serial data receiver module specifically used for Test Data Input (TDI) in a JTAG interface. It seems to be receiving serial data clocked by the \"ser_clk\" signal, receiving \"data_in\" as an input and handling \"frame_sync\" for frame synchronization. This data is somehow processed and stored in system registers, which can then be read through a Wishbone interface. Furthermore, it looks like there are also options for a test mode, a scan mode, and a normal operation mode. In the scan mode, \"scan_in\" inputs are used and \"scan_out\" outputs are provided. Moreover, it has provisions to handle reset, input-output operations, and error checks."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset - The reset signal to initialize the states of internal registers.\n2. ser_clk - The clock for serial data transfer.\n3. data_in - Serial data input stream.\n4. frame_sync - Frame synchronization signal to indicate the start of a new data frame.\n5. scan_in0 to scan_in4 - These represent parallel data inputs during scan-test mode.\n6. scan_enable - This input signal enables scan-test mode.\n7. test_mode - This input signal to switch between normal operation and test modes.\n8. clk - System clock signifying the main clock for the system.\n9. i_wb_adr - Wishbone address input for read/write operation.\n10. i_wb_sel - Wishbone select signal for selecting the particular bits for write operation.\n11. i_wb_we - Wishbone write enable input signal (write occurs if this is high, read if low).\n12. i_wb_dat - The data bus for Wishbone write operation.\n13. i_wb_cyc - Wishbone bus cycle signal to indicate a valid bus cycle.\n14. i_wb_stb - Wishbone strobe signal, indicates a valid data transfer.\n\nOutput ports:\n1. new_data_int - This indicates the availability of new data to be read.\n2. scan_out0 to scan_out4 - These represent parallel data outputs during scan-test mode.\n3. o_wb_dat - The data bus for Wishbone read operation.\n4. o_wb_ack - Wishbone acknowledge signal indicating the completion of read/write operation.\n5. o_wb_err - Wishbone error signal indicating an error in data transfer. \n\nExplanation: These input and output ports allow interaction and control of the TDMI module. The input ports control data input, serial clock, reset, frame sync, and Wishbone interface commands. The output ports respond with data and status signals, indicating the availability of new data, acknowledging data transfer completion, or signifying an error. They are used to extract data and status information from the TDMI module."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: sys_clk, serial_clk, selected_clk, ch_count, bit_count, prev_frame_sync, data_out_buf, ch_buf_1, ch_buf_2, data_buf_1, data_buf_2, start_read, int_buf_1, int_set, bit_count_buf, tdmi_begin, fs_start.\n\nExplanation:\n1. sys_clk: It is the system clock signal which is used to clock the operations carried out inside the design modules.\n2. serial_clk: It is the negated version of the selected clock i.e either the system clk (clk) or the serial data clock(ser_clk) based on the test mode.\n3. selected_clk: This clock is selected based on whether we are in testing mode or not, providing both serial and regular clocking options.\n4. ch_count: The count of the channel currently being processed.\n5. bit_count: The count of the bit currently being processed in the serial data stream.\n6. prev_frame_sync: The previous frame_sync signal value, used to detect the rising edge of frame_sync to identify the start of a new data frame.\n7. data_out_buf: The buffer for holding the output data.\n8. ch_buf_1 and ch_buf_2: The buffers to hold channel data. They act as a pipeline for the channel data.\n9. data_buf_1 and data_buf_2: These are the buffers to hold the data. They act as a pipeline for data to be read.\n10. start_read: A trigger to start reading, synchronized with Wishbone signals.\n11. int_buf_1: A buffer to hold the interrupt signal.\n12. int_set: An indication that an interrupt has been set.\n13. bit_count_buf: A buffer to hold the bit count. It is used to synchronize the bit count from the serial clock domain to system clock domain.\n14. tdmi_begin: It is a flag to indicate the beginning of TDMI operation. It is controlled by Wishbone operation.\n15. fs_start: It is the start flag for frame synchronization, used to indicate the start of data reading."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule TDMI (\n\t\tinput reset,\n\t\tinput ser_clk,\n\t\tinput data_in,\n\t\tinput frame_sync,\n\t\tinput scan_in0,\n\t\tinput scan_in1,\n\t\tinput scan_in2,\n\t\tinput scan_in3,\n\t\tinput scan_in4,\n\t\tinput scan_enable,\n\t\tinput test_mode,\n\t\toutput reg new_data_int,\n\t\toutput scan_out0,\n\t\toutput scan_out1,\n\t\toutput scan_out2,\n\t\toutput scan_out3,\n\t\toutput scan_out4,\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tinput\t\tclk,\n\t\tinput       [31:0]          i_wb_adr,\t\n\t\tinput       [3:0] \t    i_wb_sel,\t\n\t\tinput                       i_wb_we,\t\n\t\toutput reg  [31:0] \t    o_wb_dat,\t\n\t\tinput       [31:0] \t    i_wb_dat,\t\n\t\tinput                       i_wb_cyc,\t\n\t\tinput                       i_wb_stb,\t\n\t\toutput\t                o_wb_ack,\t\n\t\toutput                      o_wb_err\t\n);\n\n`include \"../include/register_addresses.vh\"\t\t\n\n\nwire \t sys_clk, serial_clk;\t\t\nwire\t selected_clk;\t\t\t\n\nreg [4:0] \tch_count;\t\t\t\nreg [2:0] \tbit_count;\t\t\t\nreg\t\tprev_frame_sync;\t\t\nreg [7:0]\tdata_out_buf;\t\t\nreg [4:0] \tch_buf_1, ch_buf_2;\t\nreg [7:0] \tdata_buf_1, data_buf_2; \nreg\t\tstart_read;\nreg\t\tint_buf_1;\nreg\t\tint_set;\nreg [2:0]\tbit_count_buf;\nreg\t\ttdmi_begin;\nreg\t\tfs_start;\n\nassign o_wb_ack = (i_wb_we) ? (i_wb_stb & i_wb_cyc) : (i_wb_stb & i_wb_cyc & start_read) ;\t\n\nassign o_wb_err = 1'b0;\t\t\t\t\n\nCLKBUFX4 clk_buf_1 (\t\t\t\t\n\t.A(clk),\n\t.Y(sys_clk)\n);\n\nassign selected_clk = (test_mode) ? (clk) : (ser_clk);\t\n\nCLKINVX4 clk_buf_2 (\t\t\t\t\t\t\t\n\t.A(selected_clk),\n\t.Y(serial_clk)\n);\n\n\n\n\nalways@ (posedge serial_clk, posedge reset) begin\n\tif (reset) begin\t\t\t\t\t\t\n\t\tch_count\t\t<= 5'b00000;\n\t\tbit_count\t\t<= 3'b111;\t\t\t\n\t\tprev_frame_sync \t<= 1'b0;\n\t\tdata_out_buf \t<= 8'h00;\n\t\tfs_start\t\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\t\n\t\t\t\tch_count <= 5'b00000;\t\t\t\n\t\t\t\tdata_out_buf[7] <= data_in;\t\t\n\t\t\t\tbit_count <= 3'b110;\t\t\t\n\t\t\t\tfs_start <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tdata_out_buf[bit_count] <= data_in;\t\n\t\t\t\tbit_count <= bit_count - 3'b001;\t\n\t\t\t\tif (bit_count == 3'b111) begin\t\n\t\t\t\t\tch_count <= ch_count + 5'b00001;\t\n\t\t\t\tend\n\t\t\tend\n\t\t\tprev_frame_sync <= frame_sync;\t\t\n\t\tend\n\tend\nend\n\n\nalways@ (posedge sys_clk, posedge reset) begin\n\n\tif (reset) begin\n\t\tdata_buf_1\t<= 8'h00;\n\t\tdata_buf_2\t<= 8'h00;\n\t\tch_buf_1\t<= 5'b00000;\n\t\tch_buf_2\t<= 5'b00000;\n\t\to_wb_dat\t<= 32'h00000000;\n\t\tint_buf_1   <= 1'b0;\n\t\tint_set\t<= 1'b0;\n\t\tnew_data_int <= 1'b0;\n\t\tstart_read <= 1'b0;\n\t\tbit_count_buf <= 3'b000;\n\t\ttdmi_begin\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tbit_count_buf <= bit_count;\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\n\t\t\t\tint_buf_1 <= 1'b0;\n\t\t\t\tint_set <= int_set;\n\t\t\tend else if ((bit_count_buf != 3'b111) || (bit_count != 3'b111)) begin\n\t\t\t\tint_set <= 1'b0;\n\t\t\t\tint_buf_1 <= int_buf_1;\n\t\t\tend else if (~int_set & fs_start) begin\n\t\t\t\tint_buf_1 <= 1'b1;\t\n\t\t\t\tint_set <= 1'b1;\n\t\t\tend\n\t\t\tnew_data_int <= int_buf_1;\n\t\t\tif (bit_count == 3'b111) begin\n\t\t\t\tch_buf_1 <= ch_count;\t\n\t\t\t\tdata_buf_1 <= data_out_buf; \n\t\t\tend\n\t\t\tdata_buf_2 <= data_buf_1;\t\n\t\t\tch_buf_2 <= ch_buf_1;\n\t\tend\n\t\tif (i_wb_stb & i_wb_cyc & (~i_wb_we)) begin\t\n\t\t\tcase (i_wb_adr[15:0])\t\t\t\t\n\t\t\t\tTDMI_ALL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_CHANNEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {27'h0000000, ch_buf_2[4:0]};\t\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_DATA:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {24'h00000, data_buf_2};\t\t\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\tendcase\n\t\t\tstart_read <= 1'b1;\n\t\t\tint_buf_1 <= 1'b0;\t\n\t\tend else if (i_wb_stb & i_wb_cyc & i_wb_we) begin\n\t\t\tcase (i_wb_adr[15:0])\n\t\t\t\tTDMI_START:\n\t\t\t\t\tbegin\n\t\t\t\t\t\ttdmi_begin <= i_wb_dat[0];\n\t\t\t\t\tend\n\t\t\t\tdefault:\ttdmi_begin <= 1'b0;\n\t\t\tendcase\n\t\t\tstart_read <= 1'b0;\n\t\tend else begin\n\t\t\tstart_read <= 1'b0;\n\t\tend\n\tend\nend\n\n\nendmodule \n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: TDMI. \n\nModule specification: The TDMI module functions as a serial data receiver, primarily used for Test Data Input (TDI) within a JTAG interface. It receives and processes serial data under operation of the \"ser_clk\" signal, attends to frame synchronization via \"frame_sync\", and consequently stores processed data in system registers that are readable via a Wishbone interface. The module also provides test mode, scan mode, and typical operation mode options, and includes ports for handling reset, input-output operations, and error checks. \n\nData communication is enabled by numerous input and output ports such as \"reset\", \"ser_clk\", \"data_in\u201c, \"frame_sync\", \"scan_in0 to scan_in4\", \"scan_enable\", \"test_mode\" as input ports, and \"new_data_int\", \"scan_out0 to scan_out4\", \"o_wb_dat\", \"o_wb_ack\", \"o_wb_err\" as output ports. The input ports serve controls like data input, serial clocking, frame syncing, and Wishbone interfacing, while output ports deliver data and status information, demonstrating data's availability, acknowledging data transfers, or indicating errors.\n\nInternally, signals such as \"sys_clk\", \"serial_clk\", \"selected_clk\", \"ch_count\", \"bit_count\", \"prev_frame_sync\", \"data_out_buf\", \"ch_buf_1\", \"ch_buf_2\", \"data_buf_1\", \"data_buf_2\", \"start_read\", \"int_buf_1\", \"int_set\", \"bit_count_buf\", \"tdmi_begin\", \"fs_start\" are employed to manage clocking, data pipelining, bit counting, frame syncing, channel and data buffering, read triggering, interrupts, and process beginning.\n\nThe RTL code is structured into distinct blocks corresponding to initialization, clock buffering, frame buffer operations, data and channel buffering, reading/writing operations, and error handling. Each block performs specific tasks, affording the module its serial data processing ability and interfacing functionality. With such design and operation, TDMI qualifies as an intricate part of the hardware system, purposing data reception and processing."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: TDMI.\n\nExplanation: The TDMI module looks like a serial data receiver module specifically used for Test Data Input (TDI) in a JTAG interface. It seems to be receiving serial data clocked by the \"ser_clk\" signal, receiving \"data_in\" as an input and handling \"frame_sync\" for frame synchronization. This data is somehow processed and stored in system registers, which can then be read through a Wishbone interface. Furthermore, it looks like there are also options for a test mode, a scan mode, and a normal operation mode. In the scan mode, \"scan_in\" inputs are used and \"scan_out\" outputs are provided. Moreover, it has provisions to handle reset, input-output operations, and error checks."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset - The reset signal to initialize the states of internal registers.\n2. ser_clk - The clock for serial data transfer.\n3. data_in - Serial data input stream.\n4. frame_sync - Frame synchronization signal to indicate the start of a new data frame.\n5. scan_in0 to scan_in4 - These represent parallel data inputs during scan-test mode.\n6. scan_enable - This input signal enables scan-test mode.\n7. test_mode - This input signal to switch between normal operation and test modes.\n8. clk - System clock signifying the main clock for the system.\n9. i_wb_adr - Wishbone address input for read/write operation.\n10. i_wb_sel - Wishbone select signal for selecting the particular bits for write operation.\n11. i_wb_we - Wishbone write enable input signal (write occurs if this is high, read if low).\n12. i_wb_dat - The data bus for Wishbone write operation.\n13. i_wb_cyc - Wishbone bus cycle signal to indicate a valid bus cycle.\n14. i_wb_stb - Wishbone strobe signal, indicates a valid data transfer.\n\nOutput ports:\n1. new_data_int - This indicates the availability of new data to be read.\n2. scan_out0 to scan_out4 - These represent parallel data outputs during scan-test mode.\n3. o_wb_dat - The data bus for Wishbone read operation.\n4. o_wb_ack - Wishbone acknowledge signal indicating the completion of read/write operation.\n5. o_wb_err - Wishbone error signal indicating an error in data transfer. \n\nExplanation: These input and output ports allow interaction and control of the TDMI module. The input ports control data input, serial clock, reset, frame sync, and Wishbone interface commands. The output ports respond with data and status signals, indicating the availability of new data, acknowledging data transfer completion, or signifying an error. They are used to extract data and status information from the TDMI module."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: sys_clk, serial_clk, selected_clk, ch_count, bit_count, prev_frame_sync, data_out_buf, ch_buf_1, ch_buf_2, data_buf_1, data_buf_2, start_read, int_buf_1, int_set, bit_count_buf, tdmi_begin, fs_start.\n\nExplanation:\n1. sys_clk: It is the system clock signal which is used to clock the operations carried out inside the design modules.\n2. serial_clk: It is the negated version of the selected clock i.e either the system clk (clk) or the serial data clock(ser_clk) based on the test mode.\n3. selected_clk: This clock is selected based on whether we are in testing mode or not, providing both serial and regular clocking options.\n4. ch_count: The count of the channel currently being processed.\n5. bit_count: The count of the bit currently being processed in the serial data stream.\n6. prev_frame_sync: The previous frame_sync signal value, used to detect the rising edge of frame_sync to identify the start of a new data frame.\n7. data_out_buf: The buffer for holding the output data.\n8. ch_buf_1 and ch_buf_2: The buffers to hold channel data. They act as a pipeline for the channel data.\n9. data_buf_1 and data_buf_2: These are the buffers to hold the data. They act as a pipeline for data to be read.\n10. start_read: A trigger to start reading, synchronized with Wishbone signals.\n11. int_buf_1: A buffer to hold the interrupt signal.\n12. int_set: An indication that an interrupt has been set.\n13. bit_count_buf: A buffer to hold the bit count. It is used to synchronize the bit count from the serial clock domain to system clock domain.\n14. tdmi_begin: It is a flag to indicate the beginning of TDMI operation. It is controlled by Wishbone operation.\n15. fs_start: It is the start flag for frame synchronization, used to indicate the start of data reading."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule TDMI (\n\t\tinput reset,\n\t\tinput ser_clk,\n\t\tinput data_in,\n\t\tinput frame_sync,\n\t\tinput scan_in0,\n\t\tinput scan_in1,\n\t\tinput scan_in2,\n\t\tinput scan_in3,\n\t\tinput scan_in4,\n\t\tinput scan_enable,\n\t\tinput test_mode,\n\t\toutput reg new_data_int,\n\t\toutput scan_out0,\n\t\toutput scan_out1,\n\t\toutput scan_out2,\n\t\toutput scan_out3,\n\t\toutput scan_out4,\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tinput\t\tclk,\n\t\tinput       [31:0]          i_wb_adr,\t\n\t\tinput       [3:0] \t    i_wb_sel,\t\n\t\tinput                       i_wb_we,\t\n\t\toutput reg  [31:0] \t    o_wb_dat,\t\n\t\tinput       [31:0] \t    i_wb_dat,\t\n\t\tinput                       i_wb_cyc,\t\n\t\tinput                       i_wb_stb,\t\n\t\toutput\t                o_wb_ack,\t\n\t\toutput                      o_wb_err\t\n);\n\n`include \"../include/register_addresses.vh\"\t\t\n\n\nwire \t sys_clk, serial_clk;\t\t\nwire\t selected_clk;\t\t\t\n\nreg [4:0] \tch_count;\t\t\t\nreg [2:0] \tbit_count;\t\t\t\nreg\t\tprev_frame_sync;\t\t\nreg [7:0]\tdata_out_buf;\t\t\nreg [4:0] \tch_buf_1, ch_buf_2;\t\nreg [7:0] \tdata_buf_1, data_buf_2; \nreg\t\tstart_read;\nreg\t\tint_buf_1;\nreg\t\tint_set;\nreg [2:0]\tbit_count_buf;\nreg\t\ttdmi_begin;\nreg\t\tfs_start;\n\nassign o_wb_ack = (i_wb_we) ? (i_wb_stb & i_wb_cyc) : (i_wb_stb & i_wb_cyc & start_read) ;\t\n\nassign o_wb_err = 1'b0;\t\t\t\t\n\nCLKBUFX4 clk_buf_1 (\t\t\t\t\n\t.A(clk),\n\t.Y(sys_clk)\n);\n\nassign selected_clk = (test_mode) ? (clk) : (ser_clk);\t\n\nCLKINVX4 clk_buf_2 (\t\t\t\t\t\t\t\n\t.A(selected_clk),\n\t.Y(serial_clk)\n);\n\n\n\n\nalways@ (posedge serial_clk, posedge reset) begin\n\tif (reset) begin\t\t\t\t\t\t\n\t\tch_count\t\t<= 5'b00000;\n\t\tbit_count\t\t<= 3'b111;\t\t\t\n\t\tprev_frame_sync \t<= 1'b0;\n\t\tdata_out_buf \t<= 8'h00;\n\t\tfs_start\t\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\t\n\t\t\t\tch_count <= 5'b00000;\t\t\t\n\t\t\t\tdata_out_buf[7] <= data_in;\t\t\n\t\t\t\tbit_count <= 3'b110;\t\t\t\n\t\t\t\tfs_start <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tdata_out_buf[bit_count] <= data_in;\t\n\t\t\t\tbit_count <= bit_count - 3'b001;\t\n\t\t\t\tif (bit_count == 3'b111) begin\t\n\t\t\t\t\tch_count <= ch_count + 5'b00001;\t\n\t\t\t\tend\n\t\t\tend\n\t\t\tprev_frame_sync <= frame_sync;\t\t\n\t\tend\n\tend\nend\n\n\nalways@ (posedge sys_clk, posedge reset) begin\n\n\tif (reset) begin\n\t\tdata_buf_1\t<= 8'h00;\n\t\tdata_buf_2\t<= 8'h00;\n\t\tch_buf_1\t<= 5'b00000;\n\t\tch_buf_2\t<= 5'b00000;\n\t\to_wb_dat\t<= 32'h00000000;\n\t\tint_buf_1   <= 1'b0;\n\t\tint_set\t<= 1'b0;\n\t\tnew_data_int <= 1'b0;\n\t\tstart_read <= 1'b0;\n\t\tbit_count_buf <= 3'b000;\n\t\ttdmi_begin\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tbit_count_buf <= bit_count;\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\n\t\t\t\tint_buf_1 <= 1'b0;\n\t\t\t\tint_set <= int_set;\n\t\t\tend else if ((bit_count_buf != 3'b111) || (bit_count != 3'b111)) begin\n\t\t\t\tint_set <= 1'b0;\n\t\t\t\tint_buf_1 <= int_buf_1;\n\t\t\tend else if (~int_set & fs_start) begin\n\t\t\t\tint_buf_1 <= 1'b1;\t\n\t\t\t\tint_set <= 1'b1;\n\t\t\tend\n\t\t\tnew_data_int <= int_buf_1;\n\t\t\tif (bit_count == 3'b111) begin\n\t\t\t\tch_buf_1 <= ch_count;\t\n\t\t\t\tdata_buf_1 <= data_out_buf; \n\t\t\tend\n\t\t\tdata_buf_2 <= data_buf_1;\t\n\t\t\tch_buf_2 <= ch_buf_1;\n\t\tend\n\t\tif (i_wb_stb & i_wb_cyc & (~i_wb_we)) begin\t\n\t\t\tcase (i_wb_adr[15:0])\t\t\t\t\n\t\t\t\tTDMI_ALL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_CHANNEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {27'h0000000, ch_buf_2[4:0]};\t\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_DATA:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {24'h00000, data_buf_2};\t\t\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\tendcase\n\t\t\tstart_read <= 1'b1;\n\t\t\tint_buf_1 <= 1'b0;\t\n\t\tend else if (i_wb_stb & i_wb_cyc & i_wb_we) begin\n\t\t\tcase (i_wb_adr[15:0])\n\t\t\t\tTDMI_START:\n\t\t\t\t\tbegin\n\t\t\t\t\t\ttdmi_begin <= i_wb_dat[0];\n\t\t\t\t\tend\n\t\t\t\tdefault:\ttdmi_begin <= 1'b0;\n\t\t\tendcase\n\t\t\tstart_read <= 1'b0;\n\t\tend else begin\n\t\t\tstart_read <= 1'b0;\n\t\tend\n\tend\nend\n\n\nendmodule \n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: TDMI. \n\nModule specification: The TDMI module functions as a serial data receiver, primarily used for Test Data Input (TDI) within a JTAG interface. It receives and processes serial data under operation of the \"ser_clk\" signal, attends to frame synchronization via \"frame_sync\", and consequently stores processed data in system registers that are readable via a Wishbone interface. The module also provides test mode, scan mode, and typical operation mode options, and includes ports for handling reset, input-output operations, and error checks. \n\nData communication is enabled by numerous input and output ports such as \"reset\", \"ser_clk\", \"data_in\u201c, \"frame_sync\", \"scan_in0 to scan_in4\", \"scan_enable\", \"test_mode\" as input ports, and \"new_data_int\", \"scan_out0 to scan_out4\", \"o_wb_dat\", \"o_wb_ack\", \"o_wb_err\" as output ports. The input ports serve controls like data input, serial clocking, frame syncing, and Wishbone interfacing, while output ports deliver data and status information, demonstrating data's availability, acknowledging data transfers, or indicating errors.\n\nInternally, signals such as \"sys_clk\", \"serial_clk\", \"selected_clk\", \"ch_count\", \"bit_count\", \"prev_frame_sync\", \"data_out_buf\", \"ch_buf_1\", \"ch_buf_2\", \"data_buf_1\", \"data_buf_2\", \"start_read\", \"int_buf_1\", \"int_set\", \"bit_count_buf\", \"tdmi_begin\", \"fs_start\" are employed to manage clocking, data pipelining, bit counting, frame syncing, channel and data buffering, read triggering, interrupts, and process beginning.\n\nThe RTL code is structured into distinct blocks corresponding to initialization, clock buffering, frame buffer operations, data and channel buffering, reading/writing operations, and error handling. Each block performs specific tasks, affording the module its serial data processing ability and interfacing functionality. With such design and operation, TDMI qualifies as an intricate part of the hardware system, purposing data reception and processing."
                }
            ]
        }
    ]
}