{
    "spec": "Module name: a25_execute. Module specification: The a25_execute module is a critical component of a CPU architecture, responsible for executing instructions decoded in previous pipeline stages. It processes various input signals including control signals, register selections, immediates, ALU and shift function selectors, and signals for updating processor state. The module performs operations such as ALU computations, barrel shifting, multiplication, and address determination for instruction fetch and data access. Key inputs include clock, reset, stall signals, data from writeback stage, and various control and selection signals. Outputs encompass data for register/memory writeback, instruction/data addresses, and processor status information. Internally, the module utilizes signals for managing write data, byte enables, program counter operations, ALU outputs, register values, and status bits. The code is structured into sections for status bit management, address calculations, barrel shifting, ALU operations, multiplication, and register bank interactions. It incorporates",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: a25_execute. \n\nExplanation: The module `a25_execute` is a major component of a CPU architecture, which primarily functions to execute the different instructions that have been decoded in a previous pipeline stage. \n\nIt ingests inputs such as various control signals, register selection, immediates, various ALU and shift function selectors, and signals for updating different parts of the processor state. Then, depending on these inputs, it performs a number of operations such as ALU operations, barrel shifting, multiplication, and determining the addresses for instruction fetch and data access. \n\nThe module also manages the program counter, instruction and data address, and several CPU statuses. Its outputs include data that needs to be written back to registers or memory, flags from ALU/multiply operation, the actual instruction and data addresses and signals that show if any particular part of the processor state is to be updated.\n\nThis module also includes instances of `a25_barrel_shift`, `a25_alu`, `a25_multiply`, and `a25_register_bank` entities meaning it uses a barrel shifter, an ALU, a multiplier, and a register bank to perform various operations."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. clk: The clock signal used to time and synchronise operations within the CPU.\n2. reset: Signal to initialize the system to a known state.\n3. scan_enable, test_mode: These are test signals generally used to perform scan testing or other modes of test on the processor.\n4. i_core_stall, i_mem_stall: These signals indicate whether the CPU core or memory is experiencing a stall. A stall means the core/memory has to wait due to dependencies, hazards or slow response etc.\n5. i_wb_read_data: The data read from the writeback stage of CPU.\n6. i_wb_read_data_valid: Indicates whether the data read from the writeback stage is valid or not.\n7. i_wb_load_rd: The register destination id for the data coming from writeback stage.\n8. i_copro_read_data: Data read from the co-processor.\n9. i_decode_iaccess, i_decode_daccess: These are two control signals coming from the decode stage indicating whether an instruction access or data access is occurring.\n10. i_decode_load_rd: Register destination id as decoded from the instruction.\n11. Signals related to shifting operations: i_imm32, i_imm_shift_amount, i_shift_imm_zero, i_barrel_shift_amount_sel, i_barrel_shift_data_sel, i_barrel_shift_function.\n12. Input signals relating to status bits: i_status_bits_mode, i_status_bits_irq_mask, i_status_bits_firq_mask.\n13. Signal selectors for different registers, address, ALU/multiplier operation, and status bit: i_rm_sel, i_rs_sel, i_rn_sel, i_barrel_shift_amount_sel, i_barrel_shift_data_sel, i_alu_function, i_multiply_function, i_interrupt_vector_sel, i_iaddress_sel, i_daddress_sel, i_pc_sel, i_byte_enable_sel, i_status_bits_sel, i_reg_write_sel.\n14. Other miscellaneous input signals relate to user-mode, WEN (write-enable) signals for different components.\n\nOutput Ports: \n\n1. o_exec_stall: Signal indicating if the execute stage of the CPU is currently in a stall.\n2. o_copro_write_data, o_write_data: The data to be written to the coprocessor or the CPU (Register file/Data Memory).\n3. o_iaddress, o_iaddress_nxt: Current & next instruction address.\n4. o_daddress, o_daddress_nxt: Current & next data address.\n5. o_iaddress_valid, o_daddress_valid: Validity signals for instruction and data address.\n6. Flags indicating states: o_adex, o_priviledged, o_exclusive, o_write_enable.\n7. o_byte_enable: Selector signal for byte-wise data operation.\n8. o_exec_load_rd: Register destination id coming out of the execute stage.\n9. o_status_bits: Updated processor status bits after execution of current instruction.\n10. o_multiply_done: Signal to indicate whether the multiply operation has been completed."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n1. Internal Signals: \n - write_data_nxt\n - byte_enable_nxt\n - pc_plus4\n - pc_minus4\n - daddress_plus4\n - alu_plus4\n - rn_plus4\n - alu_out\n - alu_flags\n - rm\n - rs\n - rd\n - rn\n - reg_bank_rn\n - reg_bank_rm\n - reg_bank_rs\n - reg_bank_rd\n - pc\n - pc_nxt\n - interrupt_vector\n - shift_amount\n - barrel_shift_in\n - barrel_shift_out\n - barrel_shift_carry\n - barrel_shift_stall\n - barrel_shift_carry_alu\n - status_bits_flags_nxt\n - status_bits_flags\n - status_bits_mode_nxt\n - status_bits_mode\n - status_bits_mode_rds_oh_nxt\n - status_bits_mode_rds_oh\n - status_bits_irq_mask_nxt\n - status_bits_irq_mask\n - status_bits_firq_mask_nxt\n - status_bits_firq_mask\n - exec_load_rd_nxt\n - execute\n - reg_write_nxt\n - pc_wen\n - reg_bank_wen\n - multiply_out\n - base_address\n - read_data_filtered1\n - read_data_filtered\n - read_data_filtered_c\n - read_data_filtered_r\n - load_rd_r\n - load_rd_c\n - write_enable_nxt\n - daddress_valid_nxt\n - iaddress_valid_nxt\n - priviledged_nxt\n - priviledged_update\n - iaddress_update\n - daddress_update\n - base_address_update\n - write_data_update\n - copro_write_data_update\n - byte_enable_update\n - exec_load_rd_update\n - write_enable_update\n - exclusive_update\n - status_bits_flags_update\n - status_bits_mode_update\n - status_bits_irq_mask_update\n - status_bits_firq_mask_update\n - alu_out_pc_filtered\n - adex_nxt\n - save_int_pc\n - save_int_pc_m4\n - ldm_flags\n - ldm_status_bits\n - carry_in\n - iaddress_r\n - status_bits_mode_out\n - ldm_flags\n - ldm_status_bits\n - interrupt_vector\n - pc_dmem_wen\n - shift_amount\n - barrel_shift_in\n - alu_out_pc_filtered\n - o_iaddress_nxt\n - o_daddress_nxt\n - adex_nxt\n - read_data_filtered1\n - read_data_filtered\n - pc_nxt\n - save_int_pc\n - save_int_pc_m4\n - reg_write_nxt\n - byte_enable_nxt\n - write_data_nxt\n - execute\n - pc_wen\n - reg_bank_wen\n - priviledged_nxt\n - write_enable_nxt\n - daddress_valid_nxt\n - iaddress_valid_nxt\n - rn\n - rm\n - rs\n - rd\n - read_data_filtered_r\n - load_rd_r\n - read_data_filtered_r\n - load_rd_c\n - exec_load_rd_nxt\n - iaddress_r\n - status_bits_mode_out\n - xCONDITION\n - xMODE\n\n2. Explanation: \n\n- write_data_nxt: Next data value to write in the following cycle.\n- byte_enable_nxt: Selects byte-wise data for the next cycle.\n- pc_plus4, pc_minus4: Pc value incremented/decremented by 4. Used in calculating next pc.\n- daddress_plus4, alu_plus4, rn_plus4: Used for calculating next addresses for different conditions.\n- alu_out: Outcome of the ALU operation.\n- alu_flags: ALU flags update after the execution of an ALU operation.\n- rm, rs, rd, rn: Holds the register values for the current operation.\n- reg_bank_rn, reg_bank_rm, reg_bank_rs, reg_bank_rd: Holds the register bank values based on the reading signals.\n- pc: Current pc value.\n- pc_nxt: Next pc value, to get updated in the next cycle.\n- interrupt_vector: Holds interrupt vector according to requirements.\n- shift_amount, barrel_shift_in: Input to the barrel shifter.\n- barrel_shift_out: Output from the barrel shifter.\n- barrel_shift_carry, barrel_shift_stall, barrel_shift_carry_alu: Control signals associated with barrel shifter.\n- status_bits_* : Various status bits related computation for next cycle update.\n- execute: Signal that indicates the instruction should be executed.\n- reg_write_nxt: next register write value.\n- pc_wen : Write enable signal for the Program Counter.\n- reg_bank_wen : Write enable signal for the Register Bank.\n- multiply_out : Output from the multiplier unit.\n- base_address : Holds the value of base address.\n- read_data_filtered, read_data_filtered_c, read_data_filtered_r, read_data_filtered1 : Filtered read data in different conditions.\n- load_rd_r, load_rd_c : Store the register destination from load stage.\n- write_enable_nxt, daddress_valid_nxt, iaddress_valid_nxt : Next values for different signals to get updated in the next cycle.\n- *_update : Signals to control when to update various module"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule a25_execute (\n\ninput                       clk,\ninput                       reset,\ninput                       scan_enable,\ninput                       test_mode,\n\ninput                       i_core_stall,               \ninput                       i_mem_stall,                \noutput                      o_exec_stall,               \n\ninput       [31:0]          i_wb_read_data,             \ninput                       i_wb_read_data_valid,       \ninput       [10:0]          i_wb_load_rd,               \n\ninput       [31:0]          i_copro_read_data,          \n                                                        \ninput                       i_decode_iaccess,           \ninput                       i_decode_daccess,           \ninput       [7:0]           i_decode_load_rd,           \n\noutput reg  [31:0]          o_copro_write_data,\noutput reg  [31:0]          o_write_data,\noutput wire [31:0]          o_iaddress,\noutput      [31:0]          o_iaddress_nxt,             \n                                                        \noutput reg                  o_iaddress_valid,     \noutput reg  [31:0]          o_daddress,         \noutput      [31:0]          o_daddress_nxt,             \n                                                        \noutput reg                  o_daddress_valid,     \noutput reg                  o_adex,               \noutput reg                  o_priviledged,        \noutput reg                  o_exclusive,          \noutput reg                  o_write_enable,\noutput reg  [3:0]           o_byte_enable,\noutput reg  [8:0]           o_exec_load_rd,       \noutput      [31:0]          o_status_bits,              \noutput                      o_multiply_done,\n\n\n\n\n\ninput      [1:0]            i_status_bits_mode,\ninput                       i_status_bits_irq_mask,\ninput                       i_status_bits_firq_mask,\ninput      [31:0]           i_imm32,\ninput      [4:0]            i_imm_shift_amount,\ninput                       i_shift_imm_zero,\ninput      [3:0]            i_condition,\ninput                       i_decode_exclusive,       \n\ninput      [3:0]            i_rm_sel,\ninput      [3:0]            i_rs_sel,\ninput      [3:0]            i_rn_sel,\ninput      [1:0]            i_barrel_shift_amount_sel,\ninput      [1:0]            i_barrel_shift_data_sel,\ninput      [1:0]            i_barrel_shift_function,\ninput      [8:0]            i_alu_function,\ninput      [1:0]            i_multiply_function,\ninput      [2:0]            i_interrupt_vector_sel,\ninput      [3:0]            i_iaddress_sel,\ninput      [3:0]            i_daddress_sel,\ninput      [2:0]            i_pc_sel,\ninput      [1:0]            i_byte_enable_sel,\ninput      [2:0]            i_status_bits_sel,\ninput      [2:0]            i_reg_write_sel,\ninput                       i_user_mode_regs_store_nxt,\ninput                       i_firq_not_user_mode,\ninput                       i_use_carry_in,         \n\ninput                       i_write_data_wen,\ninput                       i_base_address_wen,     \n                                                    \ninput                       i_pc_wen,\ninput      [14:0]           i_reg_bank_wen,\ninput                       i_status_bits_flags_wen,\ninput                       i_status_bits_mode_wen,\ninput                       i_status_bits_irq_mask_wen,\ninput                       i_status_bits_firq_mask_wen,\ninput                       i_copro_write_data_wen,\ninput                       i_conflict,\ninput                       i_rn_use_read,\ninput                       i_rm_use_read,\ninput                       i_rs_use_read,\ninput                       i_rd_use_read\n);\n\n`include \"../include/a25_localparams.vh\"\n`include \"../include/a25_functions.vh\"\n\n\n\n\nwire [31:0]         write_data_nxt;\nwire [3:0]          byte_enable_nxt;\nwire [31:0]         pc_plus4;\nwire [31:0]         pc_minus4;\nwire [31:0]         daddress_plus4;\nwire [31:0]         alu_plus4;\nwire [31:0]         rn_plus4;\nwire [31:0]         alu_out;\nwire [3:0]          alu_flags;\nwire [31:0]         rm;\nwire [31:0]         rs;\nwire [31:0]         rd;\nwire [31:0]         rn;\nwire [31:0]         reg_bank_rn;\nwire [31:0]         reg_bank_rm;\nwire [31:0]         reg_bank_rs;\nwire [31:0]         reg_bank_rd;\nwire [31:0]         pc;\nwire [31:0]         pc_nxt;\nwire [31:0]         interrupt_vector;\nwire [7:0]          shift_amount;\nwire [31:0]         barrel_shift_in;\nwire [31:0]         barrel_shift_out;\nwire                barrel_shift_carry;\nwire                barrel_shift_stall;\nwire                barrel_shift_carry_alu;\n\nwire [3:0]          status_bits_flags_nxt;\nreg  [3:0]          status_bits_flags;\nwire [1:0]          status_bits_mode_nxt;\nreg  [1:0]          status_bits_mode;\n                    \nwire [3:0]          status_bits_mode_rds_oh_nxt;\nreg  [3:0]          status_bits_mode_rds_oh;\nwire                status_bits_mode_rds_oh_update;\nwire                status_bits_irq_mask_nxt;\nreg                 status_bits_irq_mask;\nwire                status_bits_firq_mask_nxt;\nreg                 status_bits_firq_mask;\nwire [8:0]          exec_load_rd_nxt;\n\nwire                execute;                    \nwire [31:0]         reg_write_nxt;\nwire                pc_wen;\nwire [14:0]         reg_bank_wen;\nwire [31:0]         multiply_out;\nwire [1:0]          multiply_flags;\nreg  [31:0]         base_address;             \n                                                    \nwire [31:0]         read_data_filtered1;\nwire [31:0]         read_data_filtered;\nwire [31:0]         read_data_filtered_c;\nreg  [31:0]         read_data_filtered_r;\nreg  [5:0]          load_rd_r;\nwire [5:0]          load_rd_c;\n\nwire                write_enable_nxt;\nwire                daddress_valid_nxt;\nwire                iaddress_valid_nxt;\nwire                priviledged_nxt;\nwire                priviledged_update;\nwire                iaddress_update;\nwire                daddress_update;\nwire                base_address_update;\nwire                write_data_update;\nwire                copro_write_data_update;\nwire                byte_enable_update;\nwire                exec_load_rd_update;\nwire                write_enable_update;\nwire                exclusive_update;\nwire                status_bits_flags_update;\nwire                status_bits_mode_update;\nwire                status_bits_irq_mask_update;\nwire                status_bits_firq_mask_update;\n\nwire [31:0]         alu_out_pc_filtered;\nwire                adex_nxt;\nwire [31:0]         save_int_pc;\nwire [31:0]         save_int_pc_m4;\nwire                ldm_flags;\nwire                ldm_status_bits;\n\nwire                carry_in;\n\nreg   [31:0]        iaddress_r;\n\n\n\n\n\nwire [1:0] status_bits_mode_out;\nassign status_bits_mode_out = (i_status_bits_mode_wen && i_status_bits_sel == 3'd1 && !ldm_status_bits) ?\n                                    alu_out[1:0] : status_bits_mode ;\n\nassign o_status_bits = {   status_bits_flags,           \n                           status_bits_irq_mask,        \n                           status_bits_firq_mask,       \n                           24'd0,\n                           status_bits_mode_out };      \n\n\n\n\n\nassign ldm_flags                 = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[8];\nassign ldm_status_bits           = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[7];\n\n\nassign status_bits_flags_nxt     = ldm_flags                 ? read_data_filtered[31:28]           :\n                                   i_status_bits_sel == 3'd0 ? alu_flags                           :\n                                   i_status_bits_sel == 3'd1 ? alu_out          [31:28]            :\n                                   i_status_bits_sel == 3'd3 ? i_copro_read_data[31:28]            :\n                                   \n                                   i_status_bits_sel == 3'd4 ? { multiply_flags, status_bits_flags[1:0] } :\n                                   \n                                   i_status_bits_sel == 3'd5 ? { alu_flags[3:1], status_bits_flags[0] } :\n                                                               4'b1111 ;\n\nassign status_bits_mode_nxt      = ldm_status_bits           ? read_data_filtered [1:0] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_mode       :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_mode       :\n                                   i_status_bits_sel == 3'd1 ? alu_out            [1:0] :\n                                                               i_copro_read_data  [1:0] ;\n\n\n\n\n\n\n\n\n\nassign status_bits_mode_rds_oh_nxt    = i_user_mode_regs_store_nxt ? 1'd1 << OH_USR                            :\n                                        status_bits_mode_update    ? oh_status_bits_mode(status_bits_mode_nxt) :\n                                                                     oh_status_bits_mode(status_bits_mode)     ;\n\n\nassign status_bits_irq_mask_nxt  = ldm_status_bits           ? read_data_filtered     [27] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_irq_mask      :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_irq_mask      :\n                                   i_status_bits_sel == 3'd1 ? alu_out                [27] :\n                                                               i_copro_read_data      [27] ;\n\nassign status_bits_firq_mask_nxt = ldm_status_bits           ? read_data_filtered     [26] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_firq_mask     :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_firq_mask     :\n                                   i_status_bits_sel == 3'd1 ? alu_out                [26] :\n                                                               i_copro_read_data      [26] ;\n\n\n\n\n\n\nassign pc_plus4       = pc         + 32'd4;\nassign pc_minus4      = pc         - 32'd4;\nassign daddress_plus4 = o_daddress + 32'd4;\nassign alu_plus4      = alu_out    + 32'd4;\nassign rn_plus4       = rn         + 32'd4;\n\n\n\n\n\nassign shift_amount = i_barrel_shift_amount_sel == 2'd0 ? 8'd0                         :\n                      i_barrel_shift_amount_sel == 2'd1 ? rs[7:0]                      :\n                                                          {3'd0, i_imm_shift_amount  } ;\n\n\n\n\n\nassign barrel_shift_in = i_barrel_shift_data_sel == 2'd0 ? i_imm32 : rm ;\n\n\n\n\n\n\nassign interrupt_vector = \n                          (i_interrupt_vector_sel == 3'd0) ? 32'h00000000 :\n                          \n                          (i_interrupt_vector_sel == 3'd1) ? 32'h00000010 :\n                          \n                          (i_interrupt_vector_sel == 3'd2) ? 32'h0000001c :\n                          \n                          (i_interrupt_vector_sel == 3'd3) ? 32'h00000018 :\n                          \n                          (i_interrupt_vector_sel == 3'd5) ? 32'h0000000c :\n                          \n                          (i_interrupt_vector_sel == 3'd6) ? 32'h00000004 :\n                          \n                          (i_interrupt_vector_sel == 3'd7) ? 32'h00000008 :\n                          \n                                                             32'h00000014 ;\n\n\n\n\n\nassign pc_dmem_wen    = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[3:0] == 4'd15;\n\n\n\nassign alu_out_pc_filtered = pc_wen && i_pc_sel == 3'd1 ? pcf(alu_out) : alu_out;\n\n\n\nassign o_iaddress_nxt = (pc_dmem_wen)            ? pcf(read_data_filtered) :\n                        (!execute)               ? pc_plus4                :\n                        (i_iaddress_sel == 4'd0) ? pc_plus4                :\n                        (i_iaddress_sel == 4'd1) ? alu_out_pc_filtered     :\n                        (i_iaddress_sel == 4'd2) ? interrupt_vector        :\n                                                   pc                      ;\n\n\n\n\n\nassign o_daddress_nxt = (i_daddress_sel == 4'd1) ? alu_out_pc_filtered   :\n                        (i_daddress_sel == 4'd2) ? interrupt_vector      :\n                        (i_daddress_sel == 4'd4) ? rn                    :\n                        (i_daddress_sel == 4'd5) ? daddress_plus4        :  \n                        (i_daddress_sel == 4'd6) ? alu_plus4             :  \n                                                   rn_plus4              ;  \n\n\n\nassign adex_nxt      = |o_iaddress_nxt[31:26] && i_decode_iaccess;\n\n\n\n\n\n\n\n\n\n\n\nassign read_data_filtered1 = i_wb_load_rd[10:9] == 2'd0 ? i_wb_read_data                                :\n                             i_wb_load_rd[10:9] == 2'd1 ? {i_wb_read_data[7:0],  i_wb_read_data[31:8]}  :\n                             i_wb_load_rd[10:9] == 2'd2 ? {i_wb_read_data[15:0], i_wb_read_data[31:16]} :\n                                                          {i_wb_read_data[23:0], i_wb_read_data[31:24]} ;\n\nassign read_data_filtered  = i_wb_load_rd[4] ? {24'd0, read_data_filtered1[7:0]} : read_data_filtered1 ;\n\n\n\n\n\n\n\nassign pc_nxt = (!execute)       ? pc_plus4                :\n                i_pc_sel == 3'd0 ? pc_plus4                :\n                i_pc_sel == 3'd1 ? alu_out                 :\n                i_pc_sel == 3'd2 ? interrupt_vector        :\n                i_pc_sel == 3'd3 ? pcf(read_data_filtered) :\n                                   pc_minus4               ;\n\n\n\n\n\n\nassign save_int_pc    = { status_bits_flags,\n                          status_bits_irq_mask,\n                          status_bits_firq_mask,\n                          pc[25:2],\n                          status_bits_mode      };\n\n\nassign save_int_pc_m4 = { status_bits_flags,\n                          status_bits_irq_mask,\n                          status_bits_firq_mask,\n                          pc_minus4[25:2],\n                          status_bits_mode      };\n\n\nassign reg_write_nxt = i_reg_write_sel == 3'd0 ? alu_out               :\n                       \n                       i_reg_write_sel == 3'd1 ? save_int_pc_m4        :\n                       \n                       i_reg_write_sel == 3'd2 ? multiply_out          :\n                       i_reg_write_sel == 3'd3 ? o_status_bits         :\n                       i_reg_write_sel == 3'd5 ? i_copro_read_data     :  \n                       i_reg_write_sel == 3'd6 ? base_address          :\n                                                 save_int_pc           ;\n\n\n\n\n\nassign byte_enable_nxt = i_byte_enable_sel == 2'd0   ? 4'b1111 :  \n                         i_byte_enable_sel == 2'd2   ?            \n                         ( o_daddress_nxt[1] == 1'd0 ? 4'b0011 :\n                                                       4'b1100  ) :\n\n                         o_daddress_nxt[1:0] == 2'd0 ? 4'b0001 :  \n                         o_daddress_nxt[1:0] == 2'd1 ? 4'b0010 :\n                         o_daddress_nxt[1:0] == 2'd2 ? 4'b0100 :\n                                                       4'b1000 ;\n\n\n\n\n\nassign write_data_nxt = i_byte_enable_sel == 2'd0 ? rd            :\n                                                    {4{rd[ 7:0]}} ;\n\n\n\n\n\nassign execute = conditional_execute ( i_condition, status_bits_flags );\n\n\n\nassign pc_wen       = (i_pc_wen || !execute) && !i_conflict;\n\n\nassign reg_bank_wen = {{15{execute}} & i_reg_bank_wen};\n\n\n\n\n\n\n\nassign priviledged_nxt  = ( i_status_bits_mode_wen ? status_bits_mode_nxt : status_bits_mode ) != USR ;\n\n\n\n\n\n\nassign write_enable_nxt = execute && i_write_data_wen;\n\n\n\n\n\nassign daddress_valid_nxt = execute && i_decode_daccess && !i_core_stall;\n\n\n\n\nassign iaddress_valid_nxt = i_decode_iaccess || !execute;\n\n\n\n\n\nassign rn = i_rn_use_read && i_rn_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rn;\nassign rm = i_rm_use_read && i_rm_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rm;\nassign rs = i_rs_use_read && i_rs_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rs;\nassign rd = i_rd_use_read && i_rs_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rd;\n\n\nalways@( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\t  read_data_filtered_r <= 'd0;\n\t\t  load_rd_r            <= 'd0;\n\tend else begin\n\t\tif ( i_wb_read_data_valid ) begin\n\t\t  read_data_filtered_r <= read_data_filtered;\n\t\t  load_rd_r            <= {i_wb_load_rd[6:5], i_wb_load_rd[3:0]};\n\t\tend\n\tend\nend\n\nassign read_data_filtered_c = i_wb_read_data_valid ? read_data_filtered : read_data_filtered_r;\n\n\nassign load_rd_c            = i_wb_read_data_valid ? {i_wb_load_rd[6:5], i_wb_load_rd[3:0]}  : load_rd_r;\n\n\n\n\n\n\nassign  exec_load_rd_nxt   = { i_decode_load_rd[7:6],\n                               i_decode_load_rd[5] ? USR : status_bits_mode,  \n                               i_decode_load_rd[4:0] };\n\n\n\n\n\nassign o_exec_stall                    = barrel_shift_stall;\n\nassign daddress_update                 = !i_core_stall;\nassign exec_load_rd_update             = !i_core_stall && execute;\nassign priviledged_update              = !i_core_stall;\nassign exclusive_update                = !i_core_stall && execute;\nassign write_enable_update             = !i_core_stall;\nassign write_data_update               = !i_core_stall && execute && i_write_data_wen;\nassign byte_enable_update              = !i_core_stall && execute && i_write_data_wen;\n\nassign iaddress_update                 = pc_dmem_wen || (!i_core_stall && !i_conflict);\nassign copro_write_data_update         = !i_core_stall && execute && i_copro_write_data_wen;\n\nassign base_address_update             = !i_core_stall && execute && i_base_address_wen;\nassign status_bits_flags_update        = ldm_flags       || (!i_core_stall && execute && i_status_bits_flags_wen);\nassign status_bits_mode_update         = ldm_status_bits || (!i_core_stall && execute && i_status_bits_mode_wen);\nassign status_bits_mode_rds_oh_update  = !i_core_stall;\nassign status_bits_irq_mask_update     = ldm_status_bits || (!i_core_stall && execute && i_status_bits_irq_mask_wen);\nassign status_bits_firq_mask_update    = ldm_status_bits || (!i_core_stall && execute && i_status_bits_firq_mask_wen);\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\to_daddress              <= 'd0;\n\t\to_daddress_valid        <= 'd0;\n\t\to_exec_load_rd          <= 'd0;\n\t\to_priviledged           <= 'd0;\n\t\to_exclusive             <= 'd0;\n\t\to_write_enable          <= 'd0;\n\t\to_write_data            <= 'd0;\n\t\to_byte_enable           <= 'd0;\n\t\tiaddress_r              <= 32'hdead_dead;\n\t\to_iaddress_valid        <= 'd0;\n\t\to_adex                  <= 'd0;\n\t\to_copro_write_data      <= 'd0;\n\t\tbase_address            <= 'd0;\n\t\tstatus_bits_flags       <= 'd0;\n\t\tstatus_bits_mode        <= SVC;\n\t\tstatus_bits_mode_rds_oh <= 1'd1 << OH_SVC;\n\t\tstatus_bits_irq_mask    <= 1'd1;\n\t\tstatus_bits_firq_mask   <= 1'd1;\n\tend else begin\n\t\to_daddress              <= daddress_update                ? o_daddress_nxt               : o_daddress;\n\t\to_daddress_valid        <= daddress_update                ? daddress_valid_nxt           : o_daddress_valid;\n\t\to_exec_load_rd          <= exec_load_rd_update            ? exec_load_rd_nxt             : o_exec_load_rd;\n\t\to_priviledged           <= priviledged_update             ? priviledged_nxt              : o_priviledged;\n\t\to_exclusive             <= exclusive_update               ? i_decode_exclusive           : o_exclusive;\n\t\to_write_enable          <= write_enable_update            ? write_enable_nxt             : o_write_enable;\n\t\to_write_data            <= write_data_update              ? write_data_nxt               : o_write_data;\n\t\to_byte_enable           <= byte_enable_update             ? byte_enable_nxt              : o_byte_enable;\n\t\tiaddress_r              <= iaddress_update                ? o_iaddress_nxt               : iaddress_r;\n\t\to_iaddress_valid        <= iaddress_update                ? iaddress_valid_nxt           : o_iaddress_valid;\n\t\to_adex                  <= iaddress_update                ? adex_nxt                     : o_adex;\n\t\to_copro_write_data      <= copro_write_data_update        ? write_data_nxt               : o_copro_write_data;\n\n\t\tbase_address            <= base_address_update            ? rn                           : base_address;\n\n\t\tstatus_bits_flags       <= status_bits_flags_update       ? status_bits_flags_nxt        : status_bits_flags;\n\t\tstatus_bits_mode        <= status_bits_mode_update        ? status_bits_mode_nxt         : status_bits_mode;\n\t\tstatus_bits_mode_rds_oh <= status_bits_mode_rds_oh_update ? status_bits_mode_rds_oh_nxt  : status_bits_mode_rds_oh;\n\t\tstatus_bits_irq_mask    <= status_bits_irq_mask_update    ? status_bits_irq_mask_nxt     : status_bits_irq_mask;\n\t\tstatus_bits_firq_mask   <= status_bits_firq_mask_update   ? status_bits_firq_mask_nxt    : status_bits_firq_mask;\n\tend\nend\n\nassign o_iaddress = iaddress_r;\n\n\n\n\n\nassign carry_in = i_use_carry_in ? status_bits_flags[1] : 1'd0;\n\na25_barrel_shift u_barrel_shift  (\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_in             ( barrel_shift_in           ),\n    .i_carry_in       ( carry_in                  ),\n    .i_shift_amount   ( shift_amount              ),\n    .i_shift_imm_zero ( i_shift_imm_zero          ),\n    .i_function       ( i_barrel_shift_function   ),\n\n    .o_out            ( barrel_shift_out          ),\n    .o_carry_out      ( barrel_shift_carry        ),\n    .o_stall          ( barrel_shift_stall        ));\n\n\n\n\n\nassign barrel_shift_carry_alu =  i_barrel_shift_data_sel == 2'd0 ?\n                                  (i_imm_shift_amount[4:1] == 0 ? status_bits_flags[1] : i_imm32[31]) :\n                                   barrel_shift_carry;\n\na25_alu u_alu (\n    .i_a_in                 ( rn                      ),\n    .i_b_in                 ( barrel_shift_out        ),\n    .i_barrel_shift_carry   ( barrel_shift_carry_alu  ),\n    .i_status_bits_carry    ( status_bits_flags[1]    ),\n    .i_function             ( i_alu_function          ),\n\n    .o_out                  ( alu_out                 ),\n    .o_flags                ( alu_flags               ));\n\n\n\n\n\n\na25_multiply u_multiply (\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_core_stall   ( i_core_stall          ),\n    .i_a_in         ( rs                    ),\n    .i_b_in         ( rm                    ),\n    .i_function     ( i_multiply_function   ),\n    .i_execute      ( execute               ),\n    .o_out          ( multiply_out          ),\n    .o_flags        ( multiply_flags        ),  \n    .o_done         ( o_multiply_done       )\n);\n\n\n\n\n\na25_register_bank u_register_bank(\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_core_stall            ( i_core_stall              ),\n    .i_mem_stall             ( i_mem_stall               ),\n    .i_rm_sel                ( i_rm_sel                  ),\n    .i_rs_sel                ( i_rs_sel                  ),\n    .i_rn_sel                ( i_rn_sel                  ),\n    .i_pc_wen                ( pc_wen                    ),\n    .i_reg_bank_wen          ( reg_bank_wen              ),\n    .i_pc                    ( pc_nxt[25:2]              ),\n    .i_reg                   ( reg_write_nxt             ),\n    .i_mode_idec             ( i_status_bits_mode        ),\n    .i_mode_exec             ( status_bits_mode          ),\n\n    .i_wb_read_data          ( read_data_filtered        ),\n    .i_wb_read_data_valid    ( i_wb_read_data_valid      ),\n    .i_wb_read_data_rd       ( i_wb_load_rd[3:0]         ),\n    .i_wb_mode               ( i_wb_load_rd[6:5]         ),\n\n    .i_status_bits_flags     ( status_bits_flags         ),\n    .i_status_bits_irq_mask  ( status_bits_irq_mask      ),\n    .i_status_bits_firq_mask ( status_bits_firq_mask     ),\n\n    \n    .i_firq_not_user_mode    ( i_firq_not_user_mode      ),\n\n    \n    .i_mode_rds_exec         ( status_bits_mode_rds_oh   ),\n\n    .o_rm                    ( reg_bank_rm               ),\n    .o_rs                    ( reg_bank_rs               ),\n    .o_rd                    ( reg_bank_rd               ),\n    .o_rn                    ( reg_bank_rn               ),\n    .o_pc                    ( pc                        )\n);\n\n\n\n\n\n\n\n\nwire    [(2*8)-1:0]    xCONDITION;\nwire    [(4*8)-1:0]    xMODE;\n\nassign  xCONDITION           = i_condition == EQ ? \"EQ\"  :\n                               i_condition == NE ? \"NE\"  :\n                               i_condition == CS ? \"CS\"  :\n                               i_condition == CC ? \"CC\"  :\n                               i_condition == MI ? \"MI\"  :\n                               i_condition == PL ? \"PL\"  :\n                               i_condition == VS ? \"VS\"  :\n                               i_condition == VC ? \"VC\"  :\n                               i_condition == HI ? \"HI\"  :\n                               i_condition == LS ? \"LS\"  :\n                               i_condition == GE ? \"GE\"  :\n                               i_condition == LT ? \"LT\"  :\n                               i_condition == GT ? \"GT\"  :\n                               i_condition == LE ? \"LE\"  :\n                               i_condition == AL ? \"AL\"  :\n                                                   \"NV \" ;\n\nassign  xMODE  =  status_bits_mode == SVC  ? \"SVC\"  :\n                  status_bits_mode == IRQ  ? \"IRQ\"  :\n                  status_bits_mode == FIRQ ? \"FIRQ\" :\n                  status_bits_mode == USR  ? \"USR\"  :\n                                             \"XXX\"  ;\n\n\n\n\nendmodule\n\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: a25_execute. Module specification: The a25_execute module is a critical component of a CPU architecture, responsible for executing instructions decoded in previous pipeline stages. It processes various input signals including control signals, register selections, immediates, ALU and shift function selectors, and signals for updating processor state. The module performs operations such as ALU computations, barrel shifting, multiplication, and address determination for instruction fetch and data access. Key inputs include clock, reset, stall signals, data from writeback stage, and various control and selection signals. Outputs encompass data for register/memory writeback, instruction/data addresses, and processor status information. Internally, the module utilizes signals for managing write data, byte enables, program counter operations, ALU outputs, register values, and status bits. The code is structured into sections for status bit management, address calculations, barrel shifting, ALU operations, multiplication, and register bank interactions. It incorporates"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: a25_execute. \n\nExplanation: The module `a25_execute` is a major component of a CPU architecture, which primarily functions to execute the different instructions that have been decoded in a previous pipeline stage. \n\nIt ingests inputs such as various control signals, register selection, immediates, various ALU and shift function selectors, and signals for updating different parts of the processor state. Then, depending on these inputs, it performs a number of operations such as ALU operations, barrel shifting, multiplication, and determining the addresses for instruction fetch and data access. \n\nThe module also manages the program counter, instruction and data address, and several CPU statuses. Its outputs include data that needs to be written back to registers or memory, flags from ALU/multiply operation, the actual instruction and data addresses and signals that show if any particular part of the processor state is to be updated.\n\nThis module also includes instances of `a25_barrel_shift`, `a25_alu`, `a25_multiply`, and `a25_register_bank` entities meaning it uses a barrel shifter, an ALU, a multiplier, and a register bank to perform various operations."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. clk: The clock signal used to time and synchronise operations within the CPU.\n2. reset: Signal to initialize the system to a known state.\n3. scan_enable, test_mode: These are test signals generally used to perform scan testing or other modes of test on the processor.\n4. i_core_stall, i_mem_stall: These signals indicate whether the CPU core or memory is experiencing a stall. A stall means the core/memory has to wait due to dependencies, hazards or slow response etc.\n5. i_wb_read_data: The data read from the writeback stage of CPU.\n6. i_wb_read_data_valid: Indicates whether the data read from the writeback stage is valid or not.\n7. i_wb_load_rd: The register destination id for the data coming from writeback stage.\n8. i_copro_read_data: Data read from the co-processor.\n9. i_decode_iaccess, i_decode_daccess: These are two control signals coming from the decode stage indicating whether an instruction access or data access is occurring.\n10. i_decode_load_rd: Register destination id as decoded from the instruction.\n11. Signals related to shifting operations: i_imm32, i_imm_shift_amount, i_shift_imm_zero, i_barrel_shift_amount_sel, i_barrel_shift_data_sel, i_barrel_shift_function.\n12. Input signals relating to status bits: i_status_bits_mode, i_status_bits_irq_mask, i_status_bits_firq_mask.\n13. Signal selectors for different registers, address, ALU/multiplier operation, and status bit: i_rm_sel, i_rs_sel, i_rn_sel, i_barrel_shift_amount_sel, i_barrel_shift_data_sel, i_alu_function, i_multiply_function, i_interrupt_vector_sel, i_iaddress_sel, i_daddress_sel, i_pc_sel, i_byte_enable_sel, i_status_bits_sel, i_reg_write_sel.\n14. Other miscellaneous input signals relate to user-mode, WEN (write-enable) signals for different components.\n\nOutput Ports: \n\n1. o_exec_stall: Signal indicating if the execute stage of the CPU is currently in a stall.\n2. o_copro_write_data, o_write_data: The data to be written to the coprocessor or the CPU (Register file/Data Memory).\n3. o_iaddress, o_iaddress_nxt: Current & next instruction address.\n4. o_daddress, o_daddress_nxt: Current & next data address.\n5. o_iaddress_valid, o_daddress_valid: Validity signals for instruction and data address.\n6. Flags indicating states: o_adex, o_priviledged, o_exclusive, o_write_enable.\n7. o_byte_enable: Selector signal for byte-wise data operation.\n8. o_exec_load_rd: Register destination id coming out of the execute stage.\n9. o_status_bits: Updated processor status bits after execution of current instruction.\n10. o_multiply_done: Signal to indicate whether the multiply operation has been completed."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n1. Internal Signals: \n - write_data_nxt\n - byte_enable_nxt\n - pc_plus4\n - pc_minus4\n - daddress_plus4\n - alu_plus4\n - rn_plus4\n - alu_out\n - alu_flags\n - rm\n - rs\n - rd\n - rn\n - reg_bank_rn\n - reg_bank_rm\n - reg_bank_rs\n - reg_bank_rd\n - pc\n - pc_nxt\n - interrupt_vector\n - shift_amount\n - barrel_shift_in\n - barrel_shift_out\n - barrel_shift_carry\n - barrel_shift_stall\n - barrel_shift_carry_alu\n - status_bits_flags_nxt\n - status_bits_flags\n - status_bits_mode_nxt\n - status_bits_mode\n - status_bits_mode_rds_oh_nxt\n - status_bits_mode_rds_oh\n - status_bits_irq_mask_nxt\n - status_bits_irq_mask\n - status_bits_firq_mask_nxt\n - status_bits_firq_mask\n - exec_load_rd_nxt\n - execute\n - reg_write_nxt\n - pc_wen\n - reg_bank_wen\n - multiply_out\n - base_address\n - read_data_filtered1\n - read_data_filtered\n - read_data_filtered_c\n - read_data_filtered_r\n - load_rd_r\n - load_rd_c\n - write_enable_nxt\n - daddress_valid_nxt\n - iaddress_valid_nxt\n - priviledged_nxt\n - priviledged_update\n - iaddress_update\n - daddress_update\n - base_address_update\n - write_data_update\n - copro_write_data_update\n - byte_enable_update\n - exec_load_rd_update\n - write_enable_update\n - exclusive_update\n - status_bits_flags_update\n - status_bits_mode_update\n - status_bits_irq_mask_update\n - status_bits_firq_mask_update\n - alu_out_pc_filtered\n - adex_nxt\n - save_int_pc\n - save_int_pc_m4\n - ldm_flags\n - ldm_status_bits\n - carry_in\n - iaddress_r\n - status_bits_mode_out\n - ldm_flags\n - ldm_status_bits\n - interrupt_vector\n - pc_dmem_wen\n - shift_amount\n - barrel_shift_in\n - alu_out_pc_filtered\n - o_iaddress_nxt\n - o_daddress_nxt\n - adex_nxt\n - read_data_filtered1\n - read_data_filtered\n - pc_nxt\n - save_int_pc\n - save_int_pc_m4\n - reg_write_nxt\n - byte_enable_nxt\n - write_data_nxt\n - execute\n - pc_wen\n - reg_bank_wen\n - priviledged_nxt\n - write_enable_nxt\n - daddress_valid_nxt\n - iaddress_valid_nxt\n - rn\n - rm\n - rs\n - rd\n - read_data_filtered_r\n - load_rd_r\n - read_data_filtered_r\n - load_rd_c\n - exec_load_rd_nxt\n - iaddress_r\n - status_bits_mode_out\n - xCONDITION\n - xMODE\n\n2. Explanation: \n\n- write_data_nxt: Next data value to write in the following cycle.\n- byte_enable_nxt: Selects byte-wise data for the next cycle.\n- pc_plus4, pc_minus4: Pc value incremented/decremented by 4. Used in calculating next pc.\n- daddress_plus4, alu_plus4, rn_plus4: Used for calculating next addresses for different conditions.\n- alu_out: Outcome of the ALU operation.\n- alu_flags: ALU flags update after the execution of an ALU operation.\n- rm, rs, rd, rn: Holds the register values for the current operation.\n- reg_bank_rn, reg_bank_rm, reg_bank_rs, reg_bank_rd: Holds the register bank values based on the reading signals.\n- pc: Current pc value.\n- pc_nxt: Next pc value, to get updated in the next cycle.\n- interrupt_vector: Holds interrupt vector according to requirements.\n- shift_amount, barrel_shift_in: Input to the barrel shifter.\n- barrel_shift_out: Output from the barrel shifter.\n- barrel_shift_carry, barrel_shift_stall, barrel_shift_carry_alu: Control signals associated with barrel shifter.\n- status_bits_* : Various status bits related computation for next cycle update.\n- execute: Signal that indicates the instruction should be executed.\n- reg_write_nxt: next register write value.\n- pc_wen : Write enable signal for the Program Counter.\n- reg_bank_wen : Write enable signal for the Register Bank.\n- multiply_out : Output from the multiplier unit.\n- base_address : Holds the value of base address.\n- read_data_filtered, read_data_filtered_c, read_data_filtered_r, read_data_filtered1 : Filtered read data in different conditions.\n- load_rd_r, load_rd_c : Store the register destination from load stage.\n- write_enable_nxt, daddress_valid_nxt, iaddress_valid_nxt : Next values for different signals to get updated in the next cycle.\n- *_update : Signals to control when to update various module"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule a25_execute (\n\ninput                       clk,\ninput                       reset,\ninput                       scan_enable,\ninput                       test_mode,\n\ninput                       i_core_stall,               \ninput                       i_mem_stall,                \noutput                      o_exec_stall,               \n\ninput       [31:0]          i_wb_read_data,             \ninput                       i_wb_read_data_valid,       \ninput       [10:0]          i_wb_load_rd,               \n\ninput       [31:0]          i_copro_read_data,          \n                                                        \ninput                       i_decode_iaccess,           \ninput                       i_decode_daccess,           \ninput       [7:0]           i_decode_load_rd,           \n\noutput reg  [31:0]          o_copro_write_data,\noutput reg  [31:0]          o_write_data,\noutput wire [31:0]          o_iaddress,\noutput      [31:0]          o_iaddress_nxt,             \n                                                        \noutput reg                  o_iaddress_valid,     \noutput reg  [31:0]          o_daddress,         \noutput      [31:0]          o_daddress_nxt,             \n                                                        \noutput reg                  o_daddress_valid,     \noutput reg                  o_adex,               \noutput reg                  o_priviledged,        \noutput reg                  o_exclusive,          \noutput reg                  o_write_enable,\noutput reg  [3:0]           o_byte_enable,\noutput reg  [8:0]           o_exec_load_rd,       \noutput      [31:0]          o_status_bits,              \noutput                      o_multiply_done,\n\n\n\n\n\ninput      [1:0]            i_status_bits_mode,\ninput                       i_status_bits_irq_mask,\ninput                       i_status_bits_firq_mask,\ninput      [31:0]           i_imm32,\ninput      [4:0]            i_imm_shift_amount,\ninput                       i_shift_imm_zero,\ninput      [3:0]            i_condition,\ninput                       i_decode_exclusive,       \n\ninput      [3:0]            i_rm_sel,\ninput      [3:0]            i_rs_sel,\ninput      [3:0]            i_rn_sel,\ninput      [1:0]            i_barrel_shift_amount_sel,\ninput      [1:0]            i_barrel_shift_data_sel,\ninput      [1:0]            i_barrel_shift_function,\ninput      [8:0]            i_alu_function,\ninput      [1:0]            i_multiply_function,\ninput      [2:0]            i_interrupt_vector_sel,\ninput      [3:0]            i_iaddress_sel,\ninput      [3:0]            i_daddress_sel,\ninput      [2:0]            i_pc_sel,\ninput      [1:0]            i_byte_enable_sel,\ninput      [2:0]            i_status_bits_sel,\ninput      [2:0]            i_reg_write_sel,\ninput                       i_user_mode_regs_store_nxt,\ninput                       i_firq_not_user_mode,\ninput                       i_use_carry_in,         \n\ninput                       i_write_data_wen,\ninput                       i_base_address_wen,     \n                                                    \ninput                       i_pc_wen,\ninput      [14:0]           i_reg_bank_wen,\ninput                       i_status_bits_flags_wen,\ninput                       i_status_bits_mode_wen,\ninput                       i_status_bits_irq_mask_wen,\ninput                       i_status_bits_firq_mask_wen,\ninput                       i_copro_write_data_wen,\ninput                       i_conflict,\ninput                       i_rn_use_read,\ninput                       i_rm_use_read,\ninput                       i_rs_use_read,\ninput                       i_rd_use_read\n);\n\n`include \"../include/a25_localparams.vh\"\n`include \"../include/a25_functions.vh\"\n\n\n\n\nwire [31:0]         write_data_nxt;\nwire [3:0]          byte_enable_nxt;\nwire [31:0]         pc_plus4;\nwire [31:0]         pc_minus4;\nwire [31:0]         daddress_plus4;\nwire [31:0]         alu_plus4;\nwire [31:0]         rn_plus4;\nwire [31:0]         alu_out;\nwire [3:0]          alu_flags;\nwire [31:0]         rm;\nwire [31:0]         rs;\nwire [31:0]         rd;\nwire [31:0]         rn;\nwire [31:0]         reg_bank_rn;\nwire [31:0]         reg_bank_rm;\nwire [31:0]         reg_bank_rs;\nwire [31:0]         reg_bank_rd;\nwire [31:0]         pc;\nwire [31:0]         pc_nxt;\nwire [31:0]         interrupt_vector;\nwire [7:0]          shift_amount;\nwire [31:0]         barrel_shift_in;\nwire [31:0]         barrel_shift_out;\nwire                barrel_shift_carry;\nwire                barrel_shift_stall;\nwire                barrel_shift_carry_alu;\n\nwire [3:0]          status_bits_flags_nxt;\nreg  [3:0]          status_bits_flags;\nwire [1:0]          status_bits_mode_nxt;\nreg  [1:0]          status_bits_mode;\n                    \nwire [3:0]          status_bits_mode_rds_oh_nxt;\nreg  [3:0]          status_bits_mode_rds_oh;\nwire                status_bits_mode_rds_oh_update;\nwire                status_bits_irq_mask_nxt;\nreg                 status_bits_irq_mask;\nwire                status_bits_firq_mask_nxt;\nreg                 status_bits_firq_mask;\nwire [8:0]          exec_load_rd_nxt;\n\nwire                execute;                    \nwire [31:0]         reg_write_nxt;\nwire                pc_wen;\nwire [14:0]         reg_bank_wen;\nwire [31:0]         multiply_out;\nwire [1:0]          multiply_flags;\nreg  [31:0]         base_address;             \n                                                    \nwire [31:0]         read_data_filtered1;\nwire [31:0]         read_data_filtered;\nwire [31:0]         read_data_filtered_c;\nreg  [31:0]         read_data_filtered_r;\nreg  [5:0]          load_rd_r;\nwire [5:0]          load_rd_c;\n\nwire                write_enable_nxt;\nwire                daddress_valid_nxt;\nwire                iaddress_valid_nxt;\nwire                priviledged_nxt;\nwire                priviledged_update;\nwire                iaddress_update;\nwire                daddress_update;\nwire                base_address_update;\nwire                write_data_update;\nwire                copro_write_data_update;\nwire                byte_enable_update;\nwire                exec_load_rd_update;\nwire                write_enable_update;\nwire                exclusive_update;\nwire                status_bits_flags_update;\nwire                status_bits_mode_update;\nwire                status_bits_irq_mask_update;\nwire                status_bits_firq_mask_update;\n\nwire [31:0]         alu_out_pc_filtered;\nwire                adex_nxt;\nwire [31:0]         save_int_pc;\nwire [31:0]         save_int_pc_m4;\nwire                ldm_flags;\nwire                ldm_status_bits;\n\nwire                carry_in;\n\nreg   [31:0]        iaddress_r;\n\n\n\n\n\nwire [1:0] status_bits_mode_out;\nassign status_bits_mode_out = (i_status_bits_mode_wen && i_status_bits_sel == 3'd1 && !ldm_status_bits) ?\n                                    alu_out[1:0] : status_bits_mode ;\n\nassign o_status_bits = {   status_bits_flags,           \n                           status_bits_irq_mask,        \n                           status_bits_firq_mask,       \n                           24'd0,\n                           status_bits_mode_out };      \n\n\n\n\n\nassign ldm_flags                 = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[8];\nassign ldm_status_bits           = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[7];\n\n\nassign status_bits_flags_nxt     = ldm_flags                 ? read_data_filtered[31:28]           :\n                                   i_status_bits_sel == 3'd0 ? alu_flags                           :\n                                   i_status_bits_sel == 3'd1 ? alu_out          [31:28]            :\n                                   i_status_bits_sel == 3'd3 ? i_copro_read_data[31:28]            :\n                                   \n                                   i_status_bits_sel == 3'd4 ? { multiply_flags, status_bits_flags[1:0] } :\n                                   \n                                   i_status_bits_sel == 3'd5 ? { alu_flags[3:1], status_bits_flags[0] } :\n                                                               4'b1111 ;\n\nassign status_bits_mode_nxt      = ldm_status_bits           ? read_data_filtered [1:0] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_mode       :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_mode       :\n                                   i_status_bits_sel == 3'd1 ? alu_out            [1:0] :\n                                                               i_copro_read_data  [1:0] ;\n\n\n\n\n\n\n\n\n\nassign status_bits_mode_rds_oh_nxt    = i_user_mode_regs_store_nxt ? 1'd1 << OH_USR                            :\n                                        status_bits_mode_update    ? oh_status_bits_mode(status_bits_mode_nxt) :\n                                                                     oh_status_bits_mode(status_bits_mode)     ;\n\n\nassign status_bits_irq_mask_nxt  = ldm_status_bits           ? read_data_filtered     [27] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_irq_mask      :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_irq_mask      :\n                                   i_status_bits_sel == 3'd1 ? alu_out                [27] :\n                                                               i_copro_read_data      [27] ;\n\nassign status_bits_firq_mask_nxt = ldm_status_bits           ? read_data_filtered     [26] :\n                                   i_status_bits_sel == 3'd0 ? i_status_bits_firq_mask     :\n                                   i_status_bits_sel == 3'd5 ? i_status_bits_firq_mask     :\n                                   i_status_bits_sel == 3'd1 ? alu_out                [26] :\n                                                               i_copro_read_data      [26] ;\n\n\n\n\n\n\nassign pc_plus4       = pc         + 32'd4;\nassign pc_minus4      = pc         - 32'd4;\nassign daddress_plus4 = o_daddress + 32'd4;\nassign alu_plus4      = alu_out    + 32'd4;\nassign rn_plus4       = rn         + 32'd4;\n\n\n\n\n\nassign shift_amount = i_barrel_shift_amount_sel == 2'd0 ? 8'd0                         :\n                      i_barrel_shift_amount_sel == 2'd1 ? rs[7:0]                      :\n                                                          {3'd0, i_imm_shift_amount  } ;\n\n\n\n\n\nassign barrel_shift_in = i_barrel_shift_data_sel == 2'd0 ? i_imm32 : rm ;\n\n\n\n\n\n\nassign interrupt_vector = \n                          (i_interrupt_vector_sel == 3'd0) ? 32'h00000000 :\n                          \n                          (i_interrupt_vector_sel == 3'd1) ? 32'h00000010 :\n                          \n                          (i_interrupt_vector_sel == 3'd2) ? 32'h0000001c :\n                          \n                          (i_interrupt_vector_sel == 3'd3) ? 32'h00000018 :\n                          \n                          (i_interrupt_vector_sel == 3'd5) ? 32'h0000000c :\n                          \n                          (i_interrupt_vector_sel == 3'd6) ? 32'h00000004 :\n                          \n                          (i_interrupt_vector_sel == 3'd7) ? 32'h00000008 :\n                          \n                                                             32'h00000014 ;\n\n\n\n\n\nassign pc_dmem_wen    = i_wb_read_data_valid & ~i_mem_stall & i_wb_load_rd[3:0] == 4'd15;\n\n\n\nassign alu_out_pc_filtered = pc_wen && i_pc_sel == 3'd1 ? pcf(alu_out) : alu_out;\n\n\n\nassign o_iaddress_nxt = (pc_dmem_wen)            ? pcf(read_data_filtered) :\n                        (!execute)               ? pc_plus4                :\n                        (i_iaddress_sel == 4'd0) ? pc_plus4                :\n                        (i_iaddress_sel == 4'd1) ? alu_out_pc_filtered     :\n                        (i_iaddress_sel == 4'd2) ? interrupt_vector        :\n                                                   pc                      ;\n\n\n\n\n\nassign o_daddress_nxt = (i_daddress_sel == 4'd1) ? alu_out_pc_filtered   :\n                        (i_daddress_sel == 4'd2) ? interrupt_vector      :\n                        (i_daddress_sel == 4'd4) ? rn                    :\n                        (i_daddress_sel == 4'd5) ? daddress_plus4        :  \n                        (i_daddress_sel == 4'd6) ? alu_plus4             :  \n                                                   rn_plus4              ;  \n\n\n\nassign adex_nxt      = |o_iaddress_nxt[31:26] && i_decode_iaccess;\n\n\n\n\n\n\n\n\n\n\n\nassign read_data_filtered1 = i_wb_load_rd[10:9] == 2'd0 ? i_wb_read_data                                :\n                             i_wb_load_rd[10:9] == 2'd1 ? {i_wb_read_data[7:0],  i_wb_read_data[31:8]}  :\n                             i_wb_load_rd[10:9] == 2'd2 ? {i_wb_read_data[15:0], i_wb_read_data[31:16]} :\n                                                          {i_wb_read_data[23:0], i_wb_read_data[31:24]} ;\n\nassign read_data_filtered  = i_wb_load_rd[4] ? {24'd0, read_data_filtered1[7:0]} : read_data_filtered1 ;\n\n\n\n\n\n\n\nassign pc_nxt = (!execute)       ? pc_plus4                :\n                i_pc_sel == 3'd0 ? pc_plus4                :\n                i_pc_sel == 3'd1 ? alu_out                 :\n                i_pc_sel == 3'd2 ? interrupt_vector        :\n                i_pc_sel == 3'd3 ? pcf(read_data_filtered) :\n                                   pc_minus4               ;\n\n\n\n\n\n\nassign save_int_pc    = { status_bits_flags,\n                          status_bits_irq_mask,\n                          status_bits_firq_mask,\n                          pc[25:2],\n                          status_bits_mode      };\n\n\nassign save_int_pc_m4 = { status_bits_flags,\n                          status_bits_irq_mask,\n                          status_bits_firq_mask,\n                          pc_minus4[25:2],\n                          status_bits_mode      };\n\n\nassign reg_write_nxt = i_reg_write_sel == 3'd0 ? alu_out               :\n                       \n                       i_reg_write_sel == 3'd1 ? save_int_pc_m4        :\n                       \n                       i_reg_write_sel == 3'd2 ? multiply_out          :\n                       i_reg_write_sel == 3'd3 ? o_status_bits         :\n                       i_reg_write_sel == 3'd5 ? i_copro_read_data     :  \n                       i_reg_write_sel == 3'd6 ? base_address          :\n                                                 save_int_pc           ;\n\n\n\n\n\nassign byte_enable_nxt = i_byte_enable_sel == 2'd0   ? 4'b1111 :  \n                         i_byte_enable_sel == 2'd2   ?            \n                         ( o_daddress_nxt[1] == 1'd0 ? 4'b0011 :\n                                                       4'b1100  ) :\n\n                         o_daddress_nxt[1:0] == 2'd0 ? 4'b0001 :  \n                         o_daddress_nxt[1:0] == 2'd1 ? 4'b0010 :\n                         o_daddress_nxt[1:0] == 2'd2 ? 4'b0100 :\n                                                       4'b1000 ;\n\n\n\n\n\nassign write_data_nxt = i_byte_enable_sel == 2'd0 ? rd            :\n                                                    {4{rd[ 7:0]}} ;\n\n\n\n\n\nassign execute = conditional_execute ( i_condition, status_bits_flags );\n\n\n\nassign pc_wen       = (i_pc_wen || !execute) && !i_conflict;\n\n\nassign reg_bank_wen = {{15{execute}} & i_reg_bank_wen};\n\n\n\n\n\n\n\nassign priviledged_nxt  = ( i_status_bits_mode_wen ? status_bits_mode_nxt : status_bits_mode ) != USR ;\n\n\n\n\n\n\nassign write_enable_nxt = execute && i_write_data_wen;\n\n\n\n\n\nassign daddress_valid_nxt = execute && i_decode_daccess && !i_core_stall;\n\n\n\n\nassign iaddress_valid_nxt = i_decode_iaccess || !execute;\n\n\n\n\n\nassign rn = i_rn_use_read && i_rn_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rn;\nassign rm = i_rm_use_read && i_rm_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rm;\nassign rs = i_rs_use_read && i_rs_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rs;\nassign rd = i_rd_use_read && i_rs_sel == load_rd_c[3:0] && status_bits_mode == load_rd_c[5:4] ? read_data_filtered_c : reg_bank_rd;\n\n\nalways@( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\t  read_data_filtered_r <= 'd0;\n\t\t  load_rd_r            <= 'd0;\n\tend else begin\n\t\tif ( i_wb_read_data_valid ) begin\n\t\t  read_data_filtered_r <= read_data_filtered;\n\t\t  load_rd_r            <= {i_wb_load_rd[6:5], i_wb_load_rd[3:0]};\n\t\tend\n\tend\nend\n\nassign read_data_filtered_c = i_wb_read_data_valid ? read_data_filtered : read_data_filtered_r;\n\n\nassign load_rd_c            = i_wb_read_data_valid ? {i_wb_load_rd[6:5], i_wb_load_rd[3:0]}  : load_rd_r;\n\n\n\n\n\n\nassign  exec_load_rd_nxt   = { i_decode_load_rd[7:6],\n                               i_decode_load_rd[5] ? USR : status_bits_mode,  \n                               i_decode_load_rd[4:0] };\n\n\n\n\n\nassign o_exec_stall                    = barrel_shift_stall;\n\nassign daddress_update                 = !i_core_stall;\nassign exec_load_rd_update             = !i_core_stall && execute;\nassign priviledged_update              = !i_core_stall;\nassign exclusive_update                = !i_core_stall && execute;\nassign write_enable_update             = !i_core_stall;\nassign write_data_update               = !i_core_stall && execute && i_write_data_wen;\nassign byte_enable_update              = !i_core_stall && execute && i_write_data_wen;\n\nassign iaddress_update                 = pc_dmem_wen || (!i_core_stall && !i_conflict);\nassign copro_write_data_update         = !i_core_stall && execute && i_copro_write_data_wen;\n\nassign base_address_update             = !i_core_stall && execute && i_base_address_wen;\nassign status_bits_flags_update        = ldm_flags       || (!i_core_stall && execute && i_status_bits_flags_wen);\nassign status_bits_mode_update         = ldm_status_bits || (!i_core_stall && execute && i_status_bits_mode_wen);\nassign status_bits_mode_rds_oh_update  = !i_core_stall;\nassign status_bits_irq_mask_update     = ldm_status_bits || (!i_core_stall && execute && i_status_bits_irq_mask_wen);\nassign status_bits_firq_mask_update    = ldm_status_bits || (!i_core_stall && execute && i_status_bits_firq_mask_wen);\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\to_daddress              <= 'd0;\n\t\to_daddress_valid        <= 'd0;\n\t\to_exec_load_rd          <= 'd0;\n\t\to_priviledged           <= 'd0;\n\t\to_exclusive             <= 'd0;\n\t\to_write_enable          <= 'd0;\n\t\to_write_data            <= 'd0;\n\t\to_byte_enable           <= 'd0;\n\t\tiaddress_r              <= 32'hdead_dead;\n\t\to_iaddress_valid        <= 'd0;\n\t\to_adex                  <= 'd0;\n\t\to_copro_write_data      <= 'd0;\n\t\tbase_address            <= 'd0;\n\t\tstatus_bits_flags       <= 'd0;\n\t\tstatus_bits_mode        <= SVC;\n\t\tstatus_bits_mode_rds_oh <= 1'd1 << OH_SVC;\n\t\tstatus_bits_irq_mask    <= 1'd1;\n\t\tstatus_bits_firq_mask   <= 1'd1;\n\tend else begin\n\t\to_daddress              <= daddress_update                ? o_daddress_nxt               : o_daddress;\n\t\to_daddress_valid        <= daddress_update                ? daddress_valid_nxt           : o_daddress_valid;\n\t\to_exec_load_rd          <= exec_load_rd_update            ? exec_load_rd_nxt             : o_exec_load_rd;\n\t\to_priviledged           <= priviledged_update             ? priviledged_nxt              : o_priviledged;\n\t\to_exclusive             <= exclusive_update               ? i_decode_exclusive           : o_exclusive;\n\t\to_write_enable          <= write_enable_update            ? write_enable_nxt             : o_write_enable;\n\t\to_write_data            <= write_data_update              ? write_data_nxt               : o_write_data;\n\t\to_byte_enable           <= byte_enable_update             ? byte_enable_nxt              : o_byte_enable;\n\t\tiaddress_r              <= iaddress_update                ? o_iaddress_nxt               : iaddress_r;\n\t\to_iaddress_valid        <= iaddress_update                ? iaddress_valid_nxt           : o_iaddress_valid;\n\t\to_adex                  <= iaddress_update                ? adex_nxt                     : o_adex;\n\t\to_copro_write_data      <= copro_write_data_update        ? write_data_nxt               : o_copro_write_data;\n\n\t\tbase_address            <= base_address_update            ? rn                           : base_address;\n\n\t\tstatus_bits_flags       <= status_bits_flags_update       ? status_bits_flags_nxt        : status_bits_flags;\n\t\tstatus_bits_mode        <= status_bits_mode_update        ? status_bits_mode_nxt         : status_bits_mode;\n\t\tstatus_bits_mode_rds_oh <= status_bits_mode_rds_oh_update ? status_bits_mode_rds_oh_nxt  : status_bits_mode_rds_oh;\n\t\tstatus_bits_irq_mask    <= status_bits_irq_mask_update    ? status_bits_irq_mask_nxt     : status_bits_irq_mask;\n\t\tstatus_bits_firq_mask   <= status_bits_firq_mask_update   ? status_bits_firq_mask_nxt    : status_bits_firq_mask;\n\tend\nend\n\nassign o_iaddress = iaddress_r;\n\n\n\n\n\nassign carry_in = i_use_carry_in ? status_bits_flags[1] : 1'd0;\n\na25_barrel_shift u_barrel_shift  (\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_in             ( barrel_shift_in           ),\n    .i_carry_in       ( carry_in                  ),\n    .i_shift_amount   ( shift_amount              ),\n    .i_shift_imm_zero ( i_shift_imm_zero          ),\n    .i_function       ( i_barrel_shift_function   ),\n\n    .o_out            ( barrel_shift_out          ),\n    .o_carry_out      ( barrel_shift_carry        ),\n    .o_stall          ( barrel_shift_stall        ));\n\n\n\n\n\nassign barrel_shift_carry_alu =  i_barrel_shift_data_sel == 2'd0 ?\n                                  (i_imm_shift_amount[4:1] == 0 ? status_bits_flags[1] : i_imm32[31]) :\n                                   barrel_shift_carry;\n\na25_alu u_alu (\n    .i_a_in                 ( rn                      ),\n    .i_b_in                 ( barrel_shift_out        ),\n    .i_barrel_shift_carry   ( barrel_shift_carry_alu  ),\n    .i_status_bits_carry    ( status_bits_flags[1]    ),\n    .i_function             ( i_alu_function          ),\n\n    .o_out                  ( alu_out                 ),\n    .o_flags                ( alu_flags               ));\n\n\n\n\n\n\na25_multiply u_multiply (\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_core_stall   ( i_core_stall          ),\n    .i_a_in         ( rs                    ),\n    .i_b_in         ( rm                    ),\n    .i_function     ( i_multiply_function   ),\n    .i_execute      ( execute               ),\n    .o_out          ( multiply_out          ),\n    .o_flags        ( multiply_flags        ),  \n    .o_done         ( o_multiply_done       )\n);\n\n\n\n\n\na25_register_bank u_register_bank(\n    .clk            ( clk                     ),\n    .reset          ( reset                   ),\n    .scan_enable    ( scan_enable             ),\n    .test_mode      ( test_mode               ),\n\n    .i_core_stall            ( i_core_stall              ),\n    .i_mem_stall             ( i_mem_stall               ),\n    .i_rm_sel                ( i_rm_sel                  ),\n    .i_rs_sel                ( i_rs_sel                  ),\n    .i_rn_sel                ( i_rn_sel                  ),\n    .i_pc_wen                ( pc_wen                    ),\n    .i_reg_bank_wen          ( reg_bank_wen              ),\n    .i_pc                    ( pc_nxt[25:2]              ),\n    .i_reg                   ( reg_write_nxt             ),\n    .i_mode_idec             ( i_status_bits_mode        ),\n    .i_mode_exec             ( status_bits_mode          ),\n\n    .i_wb_read_data          ( read_data_filtered        ),\n    .i_wb_read_data_valid    ( i_wb_read_data_valid      ),\n    .i_wb_read_data_rd       ( i_wb_load_rd[3:0]         ),\n    .i_wb_mode               ( i_wb_load_rd[6:5]         ),\n\n    .i_status_bits_flags     ( status_bits_flags         ),\n    .i_status_bits_irq_mask  ( status_bits_irq_mask      ),\n    .i_status_bits_firq_mask ( status_bits_firq_mask     ),\n\n    \n    .i_firq_not_user_mode    ( i_firq_not_user_mode      ),\n\n    \n    .i_mode_rds_exec         ( status_bits_mode_rds_oh   ),\n\n    .o_rm                    ( reg_bank_rm               ),\n    .o_rs                    ( reg_bank_rs               ),\n    .o_rd                    ( reg_bank_rd               ),\n    .o_rn                    ( reg_bank_rn               ),\n    .o_pc                    ( pc                        )\n);\n\n\n\n\n\n\n\n\nwire    [(2*8)-1:0]    xCONDITION;\nwire    [(4*8)-1:0]    xMODE;\n\nassign  xCONDITION           = i_condition == EQ ? \"EQ\"  :\n                               i_condition == NE ? \"NE\"  :\n                               i_condition == CS ? \"CS\"  :\n                               i_condition == CC ? \"CC\"  :\n                               i_condition == MI ? \"MI\"  :\n                               i_condition == PL ? \"PL\"  :\n                               i_condition == VS ? \"VS\"  :\n                               i_condition == VC ? \"VC\"  :\n                               i_condition == HI ? \"HI\"  :\n                               i_condition == LS ? \"LS\"  :\n                               i_condition == GE ? \"GE\"  :\n                               i_condition == LT ? \"LT\"  :\n                               i_condition == GT ? \"GT\"  :\n                               i_condition == LE ? \"LE\"  :\n                               i_condition == AL ? \"AL\"  :\n                                                   \"NV \" ;\n\nassign  xMODE  =  status_bits_mode == SVC  ? \"SVC\"  :\n                  status_bits_mode == IRQ  ? \"IRQ\"  :\n                  status_bits_mode == FIRQ ? \"FIRQ\" :\n                  status_bits_mode == USR  ? \"USR\"  :\n                                             \"XXX\"  ;\n\n\n\n\nendmodule\n\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: a25_execute. Module specification: The a25_execute module is a critical component of a CPU architecture, responsible for executing instructions decoded in previous pipeline stages. It processes various input signals including control signals, register selections, immediates, ALU and shift function selectors, and signals for updating processor state. The module performs operations such as ALU computations, barrel shifting, multiplication, and address determination for instruction fetch and data access. Key inputs include clock, reset, stall signals, data from writeback stage, and various control and selection signals. Outputs encompass data for register/memory writeback, instruction/data addresses, and processor status information. Internally, the module utilizes signals for managing write data, byte enables, program counter operations, ALU outputs, register values, and status bits. The code is structured into sections for status bit management, address calculations, barrel shifting, ALU operations, multiplication, and register bank interactions. It incorporates"
                }
            ]
        }
    ]
}