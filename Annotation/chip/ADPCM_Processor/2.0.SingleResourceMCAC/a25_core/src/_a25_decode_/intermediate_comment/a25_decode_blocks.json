{
    "line_num": [
        [
            1916,
            1926
        ],
        [
            1900,
            1913
        ],
        [
            1874,
            1898
        ],
        [
            1868,
            1868
        ],
        [
            1842,
            1842
        ],
        [
            1822,
            1840
        ],
        [
            1753,
            1820
        ],
        [
            1628,
            1751
        ],
        [
            1505,
            1622
        ],
        [
            1489,
            1502
        ],
        [
            1481,
            1481
        ],
        [
            1476,
            1476
        ],
        [
            775,
            1167
        ],
        [
            762,
            769
        ],
        [
            757,
            760
        ],
        [
            748,
            751
        ],
        [
            734,
            742
        ],
        [
            720,
            722
        ],
        [
            712,
            716
        ],
        [
            706,
            706
        ],
        [
            688,
            703
        ],
        [
            666,
            684
        ],
        [
            646,
            664
        ],
        [
            644,
            644
        ],
        [
            623,
            641
        ],
        [
            613,
            613
        ],
        [
            585,
            611
        ]
    ],
    "blocks": [
        "always @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\n\tend else begin\n\t    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n\t\t  begin\n\t\t  `TB_ERROR_MESSAGE\n\t\t  $display(\"Instruction with x's =%08h\", instruction);\n\t\t  end\n\tend\nend",
        "assign xMODE  = mode_name ( status_bits_mode_r );\n\nassign xTYPE  =\n                               type == REGOP    ? \"REGOP\"    :\n                               type == MULT     ? \"MULT\"     :\n                               type == SWAP     ? \"SWAP\"     :\n                               type == TRANS    ? \"TRANS\"    :\n                               type == MTRANS   ? \"MTRANS\"   :\n                               type == BRANCH   ? \"BRANCH\"   :\n                               type == CODTRANS ? \"CODTRANS\" :\n                               type == COREGOP  ? \"COREGOP\"  :\n                               type == CORTRANS ? \"CORTRANS\" :\n                               type == SWI      ? \"SWI\"      :\n                                                  \"UNKNOWN\"  ;",
        "assign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_ABORT   ? \"MTRANS_ABORT\"   :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;",
        "",
        "assign dabt = dabt_reg || i_dabt;",
        "always @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tirq   <= 'd0;\n\t\tfirq  <= 'd0;\n\t\tdabt_reg  <= 'd0;\n\t\tdabt_reg_d1  <= 'd0;\n\tend else begin\n\t\tif ( !i_core_stall ) begin\n\t\t\tirq   <= i_irq;\n\t\t\tfirq  <= i_firq;\n\t\t\tif ( control_state == INT_WAIT1 && status_bits_mode_r == SVC ) begin\n\t\t\t\tdabt_reg  <= 1'd0;\n\t\t\tend else begin\n\t\t\t\tdabt_reg  <= dabt_reg || i_dabt;\n\t\t\tend\n\t\t\tdabt_reg_d1  <= dabt_reg;\n\t\tend\n\tend\nend",
        "always @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tsaved_current_instruction              <= 'd0;\n\t\tsaved_current_instruction_type         <= 'd0;\n\t\tsaved_current_instruction_iabt         <= 'd0;\n\t\tsaved_current_instruction_adex         <= 'd0;\n\t\tsaved_current_instruction_address      <= 'd0;\n\t\tsaved_current_instruction_iabt_status  <= 'd0;\n\t\tpre_fetch_instruction                  <= 'd0;\n\t\tpre_fetch_instruction_type             <= 'd0;\n\t\tpre_fetch_instruction_iabt             <= 'd0;\n\t\tpre_fetch_instruction_adex             <= 'd0;\n\t\tpre_fetch_instruction_address          <= 'd0;\n\t\tpre_fetch_instruction_iabt_status      <= 'd0;\n\t\thold_instruction              <= 'd0;\n\t\thold_instruction_type         <= 'd0;\n\t\thold_instruction_iabt         <= 'd0;\n\t\thold_instruction_adex         <= 'd0;\n\t\thold_instruction_address      <= 'd0;\n\t\thold_instruction_iabt_status  <= 'd0;\n\tend else begin\n\t    if ( !i_core_stall )\n\t\t  begin\n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  if      ( type == MTRANS )\n\t\t      begin\n\t\t      saved_current_instruction              <= mtrans_instruction_nxt;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\t\t  else if ( saved_current_instruction_wen )\n\t\t      begin\n\t\t      saved_current_instruction              <= instruction;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\n\t\t  if      ( pre_fetch_instruction_wen )\n\t\t      begin\n\t\t      pre_fetch_instruction                  <= fetch_instruction_r;\n\t\t      pre_fetch_instruction_type             <= fetch_instruction_type_r;\n\t\t      pre_fetch_instruction_iabt             <= iabt_reg;\n\t\t      pre_fetch_instruction_adex             <= adex_reg;\n\t\t      pre_fetch_instruction_address          <= fetch_address_r;\n\t\t      pre_fetch_instruction_iabt_status      <= abt_status_reg;\n\t\t      end\n\n\n\t\t  \n\t\t  hold_instruction              <= instruction;\n\t\t  hold_instruction_type         <= type;\n\t\t  hold_instruction_iabt         <= instruction_iabt;\n\t\t  hold_instruction_adex         <= instruction_adex;\n\t\t  hold_instruction_address      <= instruction_address;\n\t\t  hold_instruction_iabt_status  <= instruction_iabt_status;\n\t\t  end\n\tend\nend",
        "always @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tfetch_instruction_r         <= 'd0;\n\t\tfetch_instruction_type_r    <= 'd0;\n\t\tfetch_address_r             <= 'd0;\n\t\tiabt_reg                    <= 'd0;\n\t\tadex_reg                    <= 'd0;\n\t\tabt_status_reg              <= 'd0;\n\t\tstatus_bits_mode_r          <= 2'b11;\n\t\tstatus_bits_irq_mask_r      <= 1'd1;\n\t\tstatus_bits_firq_mask_r     <= 1'd1;\n\t\to_imm32                     <= 'd0;\n\t\to_imm_shift_amount          <= 'd0;\n\t\to_shift_imm_zero            <= 'd0;\n\t\tcondition_r                 <= 4'hE;\n\t\to_decode_exclusive          <= 'd0;\n\t\tdecode_iaccess_r            <= 1'd1;\n\t\to_decode_daccess            <= 'd0;\n\t\to_rm_sel                    <= 'd0;\n\t\to_rs_sel                    <= 'd0;\n\t\to_load_rd                   <= 'd0;\n\t\tload_rd_d1                  <= 'd0;\n\t\tload_pc_r                   <= 'd0;\n\t\to_rn_sel                    <= 'd0;\n\t\to_barrel_shift_amount_sel   <= 'd0;\n\t\to_barrel_shift_data_sel     <= 'd0;\n\t\to_barrel_shift_function     <= 'd0;\n\t\to_alu_function              <= 'd0;\n\t\to_use_carry_in              <= 'd0;\n\t\to_multiply_function         <= 'd0;\n\t\to_interrupt_vector_sel      <= 'd0;\n\t\tiaddress_sel_r              <= 4'd2;\n\t\tdaddress_sel_r              <= 4'd2;\n\t\tpc_sel_r                    <= 3'd2;\n\t\to_byte_enable_sel           <= 'd0;\n\t\to_status_bits_sel           <= 'd0;\n\t\to_reg_write_sel             <= 'd0;\n\t\to_firq_not_user_mode        <= 'd0;\n\t\to_write_data_wen            <= 'd0;\n\t\to_base_address_wen          <= 'd0;\n\t\tpc_wen_r                    <= 1'd1;\n\t\to_reg_bank_wen              <= 'd0;\n\t\to_status_bits_flags_wen     <= 'd0;\n\t\to_status_bits_mode_wen      <= 'd0;\n\t\to_status_bits_irq_mask_wen  <= 'd0;\n\t\to_status_bits_firq_mask_wen <= 'd0;\n\t\to_copro_opcode1             <= 'd0;\n\t\to_copro_opcode2             <= 'd0;\n\t\to_copro_crn                 <= 'd0;\n\t\to_copro_crm                 <= 'd0;\n\t\to_copro_num                 <= 'd0;\n\t\to_copro_operation           <= 'd0;\n\t\to_copro_write_data_wen      <= 'd0;\n\t\trestore_base_address        <= 'd0;\n\t\tcontrol_state               <= RST_WAIT1;\n\tend else begin\n\t    if ( !i_core_stall ) begin\n\t\t  if (!conflict) begin\n\t\t      fetch_instruction_r         <= i_fetch_instruction;\n\t\t      fetch_instruction_type_r    <= instruction_type(i_fetch_instruction);\n\t\t      fetch_address_r             <= i_execute_iaddress;\n\t\t      iabt_reg                    <= i_iabt;\n\t\t      adex_reg                    <= i_adex;\n\t\t      abt_status_reg              <= i_abt_status;\n\t\t      end\n\n\t\t  status_bits_mode_r          <= status_bits_mode_nxt;\n\t\t  status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n\t\t  status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n\t\t  o_imm32                     <= imm32_nxt;\n\t\t  o_imm_shift_amount          <= imm_shift_amount_nxt;\n\t\t  o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t  condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n\t\t  o_decode_exclusive          <= decode_exclusive_nxt;\n\t\t  decode_iaccess_r            <= decode_iaccess_nxt;\n\t\t  o_decode_daccess            <= decode_daccess_nxt;\n\n\t\t  o_rm_sel                    <= rm_sel_nxt;\n\t\t  o_rs_sel                    <= rs_sel_nxt;\n\t\t  o_load_rd                   <= load_rd_nxt;\n\t\t  load_rd_d1                  <= load_rd_d1_nxt;\n\t\t  load_pc_r                   <= load_pc_nxt;\n\t\t  o_rn_sel                    <= rn_sel_nxt;\n\t\t  o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n\t\t  o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n\t\t  o_barrel_shift_function     <= barrel_shift_function_nxt;\n\t\t  o_alu_function              <= alu_function_nxt;\n\t\t  o_use_carry_in              <= use_carry_in_nxt;\n\t\t  o_multiply_function         <= multiply_function_nxt;\n\t\t  o_interrupt_vector_sel      <= next_interrupt;\n\t\t  iaddress_sel_r              <= iaddress_sel_nxt;\n\t\t  daddress_sel_r              <= daddress_sel_nxt;\n\t\t  pc_sel_r                    <= pc_sel_nxt;\n\t\t  o_byte_enable_sel           <= byte_enable_sel_nxt;\n\t\t  o_status_bits_sel           <= status_bits_sel_nxt;\n\t\t  o_reg_write_sel             <= reg_write_sel_nxt;\n\t\t  o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n\t\t  o_write_data_wen            <= write_data_wen_nxt;\n\t\t  o_base_address_wen          <= base_address_wen_nxt;\n\t\t  pc_wen_r                    <= pc_wen_nxt;\n\t\t  o_reg_bank_wen              <= reg_bank_wen_nxt;\n\t\t  o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n\t\t  o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n\t\t  o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n\t\t  o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n\t\t  o_copro_opcode1             <= instruction[23:21];\n\t\t  o_copro_opcode2             <= instruction[7:5];\n\t\t  o_copro_crn                 <= instruction[19:16];\n\t\t  o_copro_crm                 <= instruction[3:0];\n\t\t  o_copro_num                 <= instruction[11:8];\n\t\t  o_copro_operation           <= copro_operation_nxt;\n\t\t  o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n\t\t  restore_base_address        <= restore_base_address_nxt;\n\t\t  control_state               <= control_state_nxt;\n\t\tend\n\tend\nend",
        " always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS_ABORT )  control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if ( mtrans_instruction_nxt[15:0] != 16'd0 )\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            begin\n            if ( dabt ) \n                control_state_nxt = MTRANS_ABORT;\n            else if ( write_pc ) \n                control_state_nxt = MEM_WAIT1;\n            else\n                control_state_nxt = PRE_FETCH_EXEC;\n            end\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS_ABORT;\n        else if ( write_pc ) \n            control_state_nxt = MEM_WAIT1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( current_write_pc )\n             control_state_nxt = PC_STALL1;\n\n        if ( load_op && instruction[15:12]  == 4'd15 )  \n             control_state_nxt = MEM_WAIT1;\n\n        \n        if ( type == MTRANS && instruction[20] && mtrans_reg1 == 4'd15 ) \n             control_state_nxt = MEM_WAIT1;\n\n        if ( type == MTRANS && !conflict && mtrans_num_registers != 5'd0 && mtrans_num_registers != 5'd1 )\n            control_state_nxt = MTRANS_EXEC1;\n\n        if ( type == MULT && !conflict )\n                control_state_nxt = MULT_PROC1;\n\n        if ( type == SWAP && !conflict )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( type == CORTRANS && !und_request && !conflict )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt && !conflict )\n                control_state_nxt = INT_WAIT1;\n        end\n\n    end",
        "assign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );\n\n\n\n\nassign instruction_valid = ((control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                              \n                              \n                             (!instruction_execute && (control_state == PC_STALL1    ||\n                                                       control_state == MEM_WAIT1    ||\n                                                       control_state == COPRO_WAIT   ||\n                                                       control_state == SWAP_WRITE   ||\n                                                       control_state == MULT_PROC1   ||\n                                                       control_state == MTRANS_EXEC1  ) ));",
        "assign firq_not_user_mode_nxt = status_bits_mode_nxt == FIRQ;",
        "    end",
        "always @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    decode_exclusive_nxt            = 1'd0;\n    decode_daccess_nxt              = 1'd0;\n    decode_iaccess_nxt              = 1'd1;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    iaddress_sel_nxt                = 'd0;\n    daddress_sel_nxt                = 'd0;\n    pc_sel_nxt                      = 'd0;\n    load_pc_nxt                     = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wen_nxt                = 'd0;  \n\n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt && !conflict )\n        begin\n        if ( type == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt       = 3'd1; \n                    iaddress_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wen_nxt = decode (instruction[15:12]);\n                end\n\n            if ( !immediate_shift_op )\n                begin\n                barrel_shift_function_nxt  = instruction[6:5];\n                end\n\n            if ( !immediate_shift_op )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shift_op && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shift_op && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt = 4'd6;  \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n            end\n\n        \n        if ( mem_op )\n            begin\n            if ( load_op && instruction[15:12]  == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n\n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( type == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 3'd1;\n                else\n                    reg_bank_wen_nxt = decode ( rn_sel_nxt );\n                end\n\n                \n            if ( mem_op_post_indexed )\n               daddress_sel_nxt = 4'd4; \n            else\n               daddress_sel_nxt = 4'd1; \n\n            if ( instruction[25] && type ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( type == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n\n        if ( type == BRANCH )\n            begin\n            pc_sel_nxt            = 3'd1; \n            iaddress_sel_nxt      = 4'd1; \n            alu_out_sel_nxt       = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wen_nxt  = decode (4'd14);  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n\n        if ( type == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            if ( mtrans_num_registers > 4'd1 )\n                begin\n                iaddress_sel_nxt        = 4'd3; \n                pc_wen_nxt              = 1'd0; \n                end\n\n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] )\n                begin\n                if ( instruction[24] )    \n                    daddress_sel_nxt = 4'd7; \n                else\n                    daddress_sel_nxt = 4'd4; \n                end\n            else\n            \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    daddress_sel_nxt  = 4'd6; \n                else\n                    daddress_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            if ( {instruction[22],instruction[20]} == 2'b10 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wen_nxt  = decode (rn_sel_nxt);\n\n            \n            if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n            end\n\n\n        if ( type == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( type == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            decode_iaccess_nxt              = 1'd0; \n            decode_daccess_nxt              = 1'd1; \n            barrel_shift_data_sel_nxt       = 2'd2; \n            daddress_sel_nxt                = 4'd4; \n            decode_exclusive_nxt            = 1'd1; \n            end\n\n\n        \n        if ( type == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            iaddress_sel_nxt                = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( type == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wen_nxt                = decode (4'd14);  \n\n            iaddress_sel_nxt                = 4'd2;            \n            pc_sel_nxt                      = 3'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end",
        "assign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;",
        "assign interrupt_or_conflict\n                     =  next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6  ;  ",
        "assign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 &&  \n                        !conflict               ;  ",
        "assign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  ",
        "assign und_request  =   type == CODTRANS ||\n                        type == COREGOP  ||\n                      ( type == CORTRANS && instruction[11:8] != 4'd15 );",
        "assign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = type == SWI;\nassign dabt_request = dabt_reg;\n",
        "assign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};",
        "assign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;",
        "always @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase",
        "always @*\n    casez ( instruction[15:0] & ~mtrans_reg2_mask )\n    16'b???????????????1 : mtrans_reg2 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg2 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg2 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg2 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg2 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg2 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg2 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg2 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg2 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg2 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg2 = 4'ha ;\n    16'b????100000000000 : mtrans_reg2 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg2 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg2 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg2 = 4'he ;\n    default              : mtrans_reg2 = 4'hf ;\n    endcase",
        "assign mtrans_reg2_mask = 1'd1<<mtrans_reg1;",
        "always @*\n    casez ( instruction[15:0] )\n    16'b???????????????1 : mtrans_reg1 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg1 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg1 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg1 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg1 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg1 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg1 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg1 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg1 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg1 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg1 = 4'ha ;\n    16'b????100000000000 : mtrans_reg1 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg1 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg1 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg1 = 4'he ;\n    default              : mtrans_reg1 = 4'hf ;\n    endcase",
        "assign o_conflict = conflict;",
        "always @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tconflict_r              <= 'd0;\n\t\tinstruction_execute_r   <= 'd0;\n\t\trn_conflict1_r          <= 'd0;\n\t\trm_conflict1_r          <= 'd0;\n\t\trs_conflict1_r          <= 'd0;\n\t\trd_conflict1_r          <= 'd0;\n\t\to_rn_use_read           <= 'd0;\n\t\to_rm_use_read           <= 'd0;\n\t\to_rs_use_read           <= 'd0;\n\t\to_rd_use_read           <= 'd0;\n\tend else begin\n\t\tif ( !i_core_stall ) begin\n\t\t\tconflict_r              <= conflict;\n\t\t\tinstruction_execute_r   <= instruction_execute;\n\t\t\trn_conflict1_r          <= rn_conflict1 && instruction_execute;\n\t\t\trm_conflict1_r          <= rm_conflict1 && instruction_execute;\n\t\t\trs_conflict1_r          <= rs_conflict1 && instruction_execute;\n\t\t\trd_conflict1_r          <= rd_conflict1 && instruction_execute;\n\t\t\to_rn_use_read           <= instruction_valid && ( rn_conflict1_r || rn_conflict2 );\n\t\t\to_rm_use_read           <= instruction_valid && ( rm_conflict1_r || rm_conflict2 );\n\t\t\to_rs_use_read           <= instruction_valid && ( rs_conflict1_r || rs_conflict2 );\n\t\t\to_rd_use_read           <= instruction_valid && ( rd_conflict1_r || rd_conflict2 );\n\t\tend\n\tend\nend"
    ]
}