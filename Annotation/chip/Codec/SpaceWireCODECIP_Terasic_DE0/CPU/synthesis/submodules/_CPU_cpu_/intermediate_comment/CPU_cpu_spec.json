{
    "spec": "Module name: CPU_cpu. Module specification: This module implements the main CPU core for a NIOS II processor. It contains the key pipeline stages (fetch, decode, execute, memory, writeback) and associated control logic. The module handles instruction fetch, decoding, execution of arithmetic/logic operations, memory access, and writing results back to registers. It also includes logic for branch prediction, exception handling, and interfacing with other system components like memory and peripherals. Key input ports include clk (system clock), reset_n (active-low reset), d_irq (data memory interrupt request), and i_readdata (instruction read data). Output ports include d_address (data memory address), i_address (instruction memory address), and various control signals. Internal signals such as F_pc (fetch stage program counter), D_iw (decode stage instruction word), and E_alu_result (execute stage ALU result) are use",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: CPU_cpu\n\nExplanation: This module implements the main CPU core for a NIOS II processor. It contains the key pipeline stages (fetch, decode, execute, memory, writeback) and associated control logic. The module handles instruction fetch, decoding, execution of arithmetic/logic operations, memory access, and writing results back to registers. It also includes logic for branch prediction, exception handling, and interfacing with other system components like memory and peripherals. The module implements the NIOS II instruction set and manages the flow of instructions and data through the processor pipeline."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the CPU_cpu module, here are the input and output ports along with explanations:\n\nInput ports:\nclk, d_irq, d_readdata, d_waitrequest, i_readdata, i_waitrequest, jtag_debug_module_address, jtag_debug_module_byteenable, jtag_debug_module_debugaccess, jtag_debug_module_read, jtag_debug_module_write, jtag_debug_module_writedata, reset_n, reset_req\n\nExplanation:\n- clk: System clock input\n- d_irq: Data memory interrupt request\n- d_readdata: Data read from data memory\n- d_waitrequest: Data memory wait request signal\n- i_readdata: Instruction read from instruction memory\n- i_waitrequest: Instruction memory wait request signal\n- jtag_debug_module_*: Various signals for JTAG debug module interface\n- reset_n: Active-low reset signal\n- reset_req: Reset request signal\n\nOutput ports:\nd_address, d_byteenable, d_read, d_write, d_writedata, i_address, i_read, jtag_debug_module_debugaccess_to_roms, jtag_debug_module_readdata, jtag_debug_module_resetrequest, jtag_debug_module_waitrequest, no_ci_readra\n\nExplanation:\n- d_address: Data memory address output\n- d_byteenable: Data memory byte enable signals\n- d_read: Data memory read enable\n- d_write: Data memory write enable\n- d_writedata: Data to be written to data memory\n- i_address: Instruction memory address output\n- i_read: Instruction memory read enable\n- jtag_debug_module_*: Various signals for JTAG debug module interface\n- no_ci_readra: Custom instruction-related signal\n\nThese ports allow the CPU core to interact with memory, handle interrupts, support debugging, and interface with other system components."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nBased on the given code, here are the key internal signals and their explanations:\n\nInternal signals: F_pc, D_iw, E_valid, R_wr_dst_reg, W_status_reg_pie, W_estatus_reg, W_bstatus_reg, W_ienable_reg, W_ipending_reg, F_iw, R_ctrl_ld, E_logic_result, E_mem_byte_en, av_ld_data_aligned_filtered.\n\nExplanation:\n- F_pc: Fetch stage program counter\n- D_iw: Decode stage instruction word\n- E_valid: Execute stage valid signal\n- R_wr_dst_reg: Register file write destination register\n- W_status_reg_pie: Processor status register PIE (Processor Interrupt Enable) bit\n- W_estatus_reg: Exception status register\n- W_bstatus_reg: Break status register\n- W_ienable_reg: Interrupt enable register\n- W_ipending_reg: Interrupt pending register\n- F_iw: Fetch stage instruction word\n- R_ctrl_ld: Load instruction control signal\n- E_logic_result: Execute stage logic operation result\n- E_mem_byte_en: Memory byte enable signals\n- av_ld_data_aligned_filtered: Aligned and filtered load data\n\nThese signals represent various control and data elements used throughout the CPU pipeline stages for instruction processing, execution control, and status tracking."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_register_bank_a_module (\n                                        \n                                         clock,\n                                         data,\n                                         rdaddress,\n                                         wraddress,\n                                         wren,\n\n                                        \n                                         q\n                                      )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input            clock;\n  input   [ 31: 0] data;\n  input   [  4: 0] rdaddress;\n  input   [  4: 0] wraddress;\n  input            wren;\n\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_data;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign ram_data = data;\n  altsyncram the_altsyncram\n    (\n      .address_a (wraddress),\n      .address_b (rdaddress),\n      .clock0 (clock),\n      .data_a (ram_data),\n      .q_b (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.address_reg_b = \"CLOCK0\",\n           the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 32,\n           the_altsyncram.numwords_b = 32,\n           the_altsyncram.operation_mode = \"DUAL_PORT\",\n           the_altsyncram.outdata_reg_b = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.rdcontrol_reg_b = \"CLOCK0\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_b = 32,\n           the_altsyncram.widthad_a = 5,\n           the_altsyncram.widthad_b = 5;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_register_bank_b_module (\n                                        \n                                         clock,\n                                         data,\n                                         rdaddress,\n                                         wraddress,\n                                         wren,\n\n                                        \n                                         q\n                                      )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input            clock;\n  input   [ 31: 0] data;\n  input   [  4: 0] rdaddress;\n  input   [  4: 0] wraddress;\n  input            wren;\n\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_data;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign ram_data = data;\n  altsyncram the_altsyncram\n    (\n      .address_a (wraddress),\n      .address_b (rdaddress),\n      .clock0 (clock),\n      .data_a (ram_data),\n      .q_b (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.address_reg_b = \"CLOCK0\",\n           the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 32,\n           the_altsyncram.numwords_b = 32,\n           the_altsyncram.operation_mode = \"DUAL_PORT\",\n           the_altsyncram.outdata_reg_b = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.rdcontrol_reg_b = \"CLOCK0\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_b = 32,\n           the_altsyncram.widthad_a = 5,\n           the_altsyncram.widthad_b = 5;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_debug (\n                                 \n                                  clk,\n                                  dbrk_break,\n                                  debugreq,\n                                  hbreak_enabled,\n                                  jdo,\n                                  jrst_n,\n                                  ocireg_ers,\n                                  ocireg_mrs,\n                                  reset,\n                                  st_ready_test_idle,\n                                  take_action_ocimem_a,\n                                  take_action_ocireg,\n                                  xbrk_break,\n\n                                 \n                                  debugack,\n                                  monitor_error,\n                                  monitor_go,\n                                  monitor_ready,\n                                  oci_hbreak_req,\n                                  resetlatch,\n                                  resetrequest\n                               )\n;\n\n  output           debugack;\n  output           monitor_error;\n  output           monitor_go;\n  output           monitor_ready;\n  output           oci_hbreak_req;\n  output           resetlatch;\n  output           resetrequest;\n  input            clk;\n  input            dbrk_break;\n  input            debugreq;\n  input            hbreak_enabled;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            ocireg_ers;\n  input            ocireg_mrs;\n  input            reset;\n  input            st_ready_test_idle;\n  input            take_action_ocimem_a;\n  input            take_action_ocireg;\n  input            xbrk_break;\n\n  reg              break_on_reset ;\n  wire             debugack;\n  reg              jtag_break ;\n  reg              monitor_error ;\n  reg              monitor_go ;\n  reg              monitor_ready ;\n  wire             oci_hbreak_req;\n  wire             reset_sync;\n  reg              resetlatch ;\n  reg              resetrequest ;\n  wire             unxcomplemented_resetxx0;\n  assign unxcomplemented_resetxx0 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer\n    (\n      .clk (clk),\n      .din (reset),\n      .dout (reset_sync),\n      .reset_n (unxcomplemented_resetxx0)\n    );\n\n  defparam the_altera_std_synchronizer.depth = 2;\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          break_on_reset <= 1'b0;\n          resetrequest <= 1'b0;\n          jtag_break <= 1'b0;\n        end\n      else if (take_action_ocimem_a)\n        begin\n          resetrequest <= jdo[22];\n          jtag_break <= jdo[21]     ? 1 \n                    : jdo[20]  ? 0 \n                    : jtag_break;\n\n          break_on_reset <= jdo[19]     ? 1\n                    : jdo[18]  ? 0\n                    :  break_on_reset;\n\n          resetlatch <= jdo[24] ? 0 : resetlatch;\n        end\n      else if (reset_sync)\n        begin\n          jtag_break <= break_on_reset;\n          resetlatch <= 1;\n        end\n      else if (debugreq & ~debugack & break_on_reset)\n          jtag_break <= 1'b1;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          monitor_ready <= 1'b0;\n          monitor_error <= 1'b0;\n          monitor_go <= 1'b0;\n        end\n      else \n        begin\n          if (take_action_ocimem_a && jdo[25])\n              monitor_ready <= 1'b0;\n          else if (take_action_ocireg && ocireg_mrs)\n              monitor_ready <= 1'b1;\n          if (take_action_ocimem_a && jdo[25])\n              monitor_error <= 1'b0;\n          else if (take_action_ocireg && ocireg_ers)\n              monitor_error <= 1'b1;\n          if (take_action_ocimem_a && jdo[23])\n              monitor_go <= 1'b1;\n          else if (st_ready_test_idle)\n              monitor_go <= 1'b0;\n        end\n    end\n\n\n  assign oci_hbreak_req = jtag_break | dbrk_break | xbrk_break | debugreq;\n  assign debugack = ~hbreak_enabled;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_ociram_sp_ram_module (\n                                      \n                                       address,\n                                       byteenable,\n                                       clock,\n                                       data,\n                                       reset_req,\n                                       wren,\n\n                                      \n                                       q\n                                    )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input   [  7: 0] address;\n  input   [  3: 0] byteenable;\n  input            clock;\n  input   [ 31: 0] data;\n  input            reset_req;\n  input            wren;\n\n  wire             clocken;\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign clocken = ~reset_req;\n  altsyncram the_altsyncram\n    (\n      .address_a (address),\n      .byteena_a (byteenable),\n      .clock0 (clock),\n      .clocken0 (clocken),\n      .data_a (data),\n      .q_a (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 256,\n           the_altsyncram.operation_mode = \"SINGLE_PORT\",\n           the_altsyncram.outdata_reg_a = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_byteena_a = 4,\n           the_altsyncram.widthad_a = 8;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_ocimem (\n                              \n                               address,\n                               byteenable,\n                               clk,\n                               debugaccess,\n                               jdo,\n                               jrst_n,\n                               read,\n                               reset_req,\n                               take_action_ocimem_a,\n                               take_action_ocimem_b,\n                               take_no_action_ocimem_a,\n                               write,\n                               writedata,\n\n                              \n                               MonDReg,\n                               ociram_readdata,\n                               waitrequest\n                            )\n;\n\n  output  [ 31: 0] MonDReg;\n  output  [ 31: 0] ociram_readdata;\n  output           waitrequest;\n  input   [  8: 0] address;\n  input   [  3: 0] byteenable;\n  input            clk;\n  input            debugaccess;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            read;\n  input            reset_req;\n  input            take_action_ocimem_a;\n  input            take_action_ocimem_b;\n  input            take_no_action_ocimem_a;\n  input            write;\n  input   [ 31: 0] writedata;\n\n  reg     [ 10: 0] MonAReg ;\n  wire    [  8: 0] MonARegAddrInc;\n  wire             MonARegAddrIncAccessingRAM;\n  reg     [ 31: 0] MonDReg ;\n  reg              avalon_ociram_readdata_ready ;\n  wire             avalon_ram_wr;\n  wire    [ 31: 0] cfgrom_readdata;\n  reg              jtag_ram_access ;\n  reg              jtag_ram_rd ;\n  reg              jtag_ram_rd_d1 ;\n  reg              jtag_ram_wr ;\n  reg              jtag_rd ;\n  reg              jtag_rd_d1 ;\n  wire    [  7: 0] ociram_addr;\n  wire    [  3: 0] ociram_byteenable;\n  wire    [ 31: 0] ociram_readdata;\n  wire    [ 31: 0] ociram_wr_data;\n  wire             ociram_wr_en;\n  reg              waitrequest ;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          jtag_rd <= 1'b0;\n          jtag_rd_d1 <= 1'b0;\n          jtag_ram_wr <= 1'b0;\n          jtag_ram_rd <= 1'b0;\n          jtag_ram_rd_d1 <= 1'b0;\n          jtag_ram_access <= 1'b0;\n          MonAReg <= 0;\n          MonDReg <= 0;\n          waitrequest <= 1'b1;\n          avalon_ociram_readdata_ready <= 1'b0;\n        end\n      else \n        begin\n          if (take_no_action_ocimem_a)\n            begin\n              MonAReg[10 : 2] <= MonARegAddrInc;\n              jtag_rd <= 1'b1;\n              jtag_ram_rd <= MonARegAddrIncAccessingRAM;\n              jtag_ram_access <= MonARegAddrIncAccessingRAM;\n            end\n          else if (take_action_ocimem_a)\n            begin\n              MonAReg[10 : 2] <= { jdo[17],\n                            jdo[33 : 26] };\n\n              jtag_rd <= 1'b1;\n              jtag_ram_rd <= ~jdo[17];\n              jtag_ram_access <= ~jdo[17];\n            end\n          else if (take_action_ocimem_b)\n            begin\n              MonAReg[10 : 2] <= MonARegAddrInc;\n              MonDReg <= jdo[34 : 3];\n              jtag_ram_wr <= MonARegAddrIncAccessingRAM;\n              jtag_ram_access <= MonARegAddrIncAccessingRAM;\n            end\n          else \n            begin\n              jtag_rd <= 0;\n              jtag_ram_wr <= 0;\n              jtag_ram_rd <= 0;\n              jtag_ram_access <= 0;\n              if (jtag_rd_d1)\n                  MonDReg <= jtag_ram_rd_d1 ? ociram_readdata : cfgrom_readdata;\n            end\n          jtag_rd_d1 <= jtag_rd;\n          jtag_ram_rd_d1 <= jtag_ram_rd;\n          if (~waitrequest)\n            begin\n              waitrequest <= 1'b1;\n              avalon_ociram_readdata_ready <= 1'b0;\n            end\n          else if (write)\n              waitrequest <= ~address[8] & jtag_ram_access;\n          else if (read)\n            begin\n              avalon_ociram_readdata_ready <= ~(~address[8] & jtag_ram_access);\n              waitrequest <= ~avalon_ociram_readdata_ready;\n            end\n          else \n            begin\n              waitrequest <= 1'b1;\n              avalon_ociram_readdata_ready <= 1'b0;\n            end\n        end\n    end\n\n\n  assign MonARegAddrInc = MonAReg[10 : 2]+1;\n  assign MonARegAddrIncAccessingRAM = ~MonARegAddrInc[8];\n  assign avalon_ram_wr = write & ~address[8] & debugaccess;\n  assign ociram_addr = jtag_ram_access ? MonAReg[9 : 2] : address[7 : 0];\n  assign ociram_wr_data = jtag_ram_access ? MonDReg[31 : 0] : writedata;\n  assign ociram_byteenable = jtag_ram_access ? 4'b1111 : byteenable;\n  assign ociram_wr_en = jtag_ram_access ? jtag_ram_wr : avalon_ram_wr;\n\nCPU_cpu_ociram_sp_ram_module CPU_cpu_ociram_sp_ram\n  (\n    .address    (ociram_addr),\n    .byteenable (ociram_byteenable),\n    .clock      (clk),\n    .data       (ociram_wr_data),\n    .q          (ociram_readdata),\n    .reset_req  (reset_req),\n    .wren       (ociram_wr_en)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_ociram_sp_ram.lpm_file = \"CPU_cpu_ociram_default_contents.dat\";\n`else\ndefparam CPU_cpu_ociram_sp_ram.lpm_file = \"CPU_cpu_ociram_default_contents.hex\";\n`endif\n\n\n\n\n  assign cfgrom_readdata = (MonAReg[4 : 2] == 3'd0)? 32'h00800020 :\n    (MonAReg[4 : 2] == 3'd1)? 32'h00001919 :\n    (MonAReg[4 : 2] == 3'd2)? 32'h00040000 :\n    (MonAReg[4 : 2] == 3'd3)? 32'h00000100 :\n    (MonAReg[4 : 2] == 3'd4)? 32'h20000000 :\n    (MonAReg[4 : 2] == 3'd5)? 32'h00800000 :\n    (MonAReg[4 : 2] == 3'd6)? 32'h00000000 :\n    32'h00000000;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_avalon_reg (\n                                  \n                                   address,\n                                   clk,\n                                   debugaccess,\n                                   monitor_error,\n                                   monitor_go,\n                                   monitor_ready,\n                                   reset_n,\n                                   write,\n                                   writedata,\n\n                                  \n                                   oci_ienable,\n                                   oci_reg_readdata,\n                                   oci_single_step_mode,\n                                   ocireg_ers,\n                                   ocireg_mrs,\n                                   take_action_ocireg\n                                )\n;\n\n  output  [ 31: 0] oci_ienable;\n  output  [ 31: 0] oci_reg_readdata;\n  output           oci_single_step_mode;\n  output           ocireg_ers;\n  output           ocireg_mrs;\n  output           take_action_ocireg;\n  input   [  8: 0] address;\n  input            clk;\n  input            debugaccess;\n  input            monitor_error;\n  input            monitor_go;\n  input            monitor_ready;\n  input            reset_n;\n  input            write;\n  input   [ 31: 0] writedata;\n\n  reg     [ 31: 0] oci_ienable;\n  wire             oci_reg_00_addressed;\n  wire             oci_reg_01_addressed;\n  wire    [ 31: 0] oci_reg_readdata;\n  reg              oci_single_step_mode;\n  wire             ocireg_ers;\n  wire             ocireg_mrs;\n  wire             ocireg_sstep;\n  wire             take_action_oci_intr_mask_reg;\n  wire             take_action_ocireg;\n  wire             write_strobe;\n  assign oci_reg_00_addressed = address == 9'h100;\n  assign oci_reg_01_addressed = address == 9'h101;\n  assign write_strobe = write & debugaccess;\n  assign take_action_ocireg = write_strobe & oci_reg_00_addressed;\n  assign take_action_oci_intr_mask_reg = write_strobe & oci_reg_01_addressed;\n  assign ocireg_ers = writedata[1];\n  assign ocireg_mrs = writedata[0];\n  assign ocireg_sstep = writedata[3];\n  assign oci_reg_readdata = oci_reg_00_addressed ? {28'b0, oci_single_step_mode, monitor_go,\n    monitor_ready, monitor_error} : \n    oci_reg_01_addressed ?  oci_ienable :   \n    32'b0;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_single_step_mode <= 1'b0;\n      else if (take_action_ocireg)\n          oci_single_step_mode <= ocireg_sstep;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_ienable <= 32'b00000000000000000000000000000001;\n      else if (take_action_oci_intr_mask_reg)\n          oci_ienable <= writedata | ~(32'b00000000000000000000000000000001);\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_break (\n                                 \n                                  clk,\n                                  dbrk_break,\n                                  dbrk_goto0,\n                                  dbrk_goto1,\n                                  jdo,\n                                  jrst_n,\n                                  reset_n,\n                                  take_action_break_a,\n                                  take_action_break_b,\n                                  take_action_break_c,\n                                  take_no_action_break_a,\n                                  take_no_action_break_b,\n                                  take_no_action_break_c,\n                                  xbrk_goto0,\n                                  xbrk_goto1,\n\n                                 \n                                  break_readreg,\n                                  dbrk_hit0_latch,\n                                  dbrk_hit1_latch,\n                                  dbrk_hit2_latch,\n                                  dbrk_hit3_latch,\n                                  trigbrktype,\n                                  trigger_state_0,\n                                  trigger_state_1,\n                                  xbrk_ctrl0,\n                                  xbrk_ctrl1,\n                                  xbrk_ctrl2,\n                                  xbrk_ctrl3\n                               )\n;\n\n  output  [ 31: 0] break_readreg;\n  output           dbrk_hit0_latch;\n  output           dbrk_hit1_latch;\n  output           dbrk_hit2_latch;\n  output           dbrk_hit3_latch;\n  output           trigbrktype;\n  output           trigger_state_0;\n  output           trigger_state_1;\n  output  [  7: 0] xbrk_ctrl0;\n  output  [  7: 0] xbrk_ctrl1;\n  output  [  7: 0] xbrk_ctrl2;\n  output  [  7: 0] xbrk_ctrl3;\n  input            clk;\n  input            dbrk_break;\n  input            dbrk_goto0;\n  input            dbrk_goto1;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            reset_n;\n  input            take_action_break_a;\n  input            take_action_break_b;\n  input            take_action_break_c;\n  input            take_no_action_break_a;\n  input            take_no_action_break_b;\n  input            take_no_action_break_c;\n  input            xbrk_goto0;\n  input            xbrk_goto1;\n\n  wire    [  3: 0] break_a_wpr;\n  wire    [  1: 0] break_a_wpr_high_bits;\n  wire    [  1: 0] break_a_wpr_low_bits;\n  wire    [  1: 0] break_b_rr;\n  wire    [  1: 0] break_c_rr;\n  reg     [ 31: 0] break_readreg ;\n  wire             dbrk0_high_value;\n  wire             dbrk0_low_value;\n  wire             dbrk1_high_value;\n  wire             dbrk1_low_value;\n  wire             dbrk2_high_value;\n  wire             dbrk2_low_value;\n  wire             dbrk3_high_value;\n  wire             dbrk3_low_value;\n  wire             dbrk_hit0_latch;\n  wire             dbrk_hit1_latch;\n  wire             dbrk_hit2_latch;\n  wire             dbrk_hit3_latch;\n  wire             take_action_any_break;\n  reg              trigbrktype ;\n  reg              trigger_state;\n  wire             trigger_state_0;\n  wire             trigger_state_1;\n  wire    [ 31: 0] xbrk0_value;\n  wire    [ 31: 0] xbrk1_value;\n  wire    [ 31: 0] xbrk2_value;\n  wire    [ 31: 0] xbrk3_value;\n  reg     [  7: 0] xbrk_ctrl0 ;\n  reg     [  7: 0] xbrk_ctrl1 ;\n  reg     [  7: 0] xbrk_ctrl2 ;\n  reg     [  7: 0] xbrk_ctrl3 ;\n  assign break_a_wpr = jdo[35 : 32];\n  assign break_a_wpr_high_bits = break_a_wpr[3 : 2];\n  assign break_a_wpr_low_bits = break_a_wpr[1 : 0];\n  assign break_b_rr = jdo[33 : 32];\n  assign break_c_rr = jdo[33 : 32];\n  assign take_action_any_break = take_action_break_a | take_action_break_b | take_action_break_c;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          xbrk_ctrl0 <= 0;\n          xbrk_ctrl1 <= 0;\n          xbrk_ctrl2 <= 0;\n          xbrk_ctrl3 <= 0;\n          trigbrktype <= 0;\n        end\n      else \n        begin\n          if (take_action_any_break)\n              trigbrktype <= 0;\n          else if (dbrk_break)\n              trigbrktype <= 1;\n          if (take_action_break_b)\n            begin\n              if ((break_b_rr == 2'b00) && (0 >= 1))\n                begin\n                  xbrk_ctrl0[0] <= jdo[27];\n                  xbrk_ctrl0[1] <= jdo[28];\n                  xbrk_ctrl0[2] <= jdo[29];\n                  xbrk_ctrl0[3] <= jdo[30];\n                  xbrk_ctrl0[4] <= jdo[21];\n                  xbrk_ctrl0[5] <= jdo[20];\n                  xbrk_ctrl0[6] <= jdo[19];\n                  xbrk_ctrl0[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b01) && (0 >= 2))\n                begin\n                  xbrk_ctrl1[0] <= jdo[27];\n                  xbrk_ctrl1[1] <= jdo[28];\n                  xbrk_ctrl1[2] <= jdo[29];\n                  xbrk_ctrl1[3] <= jdo[30];\n                  xbrk_ctrl1[4] <= jdo[21];\n                  xbrk_ctrl1[5] <= jdo[20];\n                  xbrk_ctrl1[6] <= jdo[19];\n                  xbrk_ctrl1[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b10) && (0 >= 3))\n                begin\n                  xbrk_ctrl2[0] <= jdo[27];\n                  xbrk_ctrl2[1] <= jdo[28];\n                  xbrk_ctrl2[2] <= jdo[29];\n                  xbrk_ctrl2[3] <= jdo[30];\n                  xbrk_ctrl2[4] <= jdo[21];\n                  xbrk_ctrl2[5] <= jdo[20];\n                  xbrk_ctrl2[6] <= jdo[19];\n                  xbrk_ctrl2[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b11) && (0 >= 4))\n                begin\n                  xbrk_ctrl3[0] <= jdo[27];\n                  xbrk_ctrl3[1] <= jdo[28];\n                  xbrk_ctrl3[2] <= jdo[29];\n                  xbrk_ctrl3[3] <= jdo[30];\n                  xbrk_ctrl3[4] <= jdo[21];\n                  xbrk_ctrl3[5] <= jdo[20];\n                  xbrk_ctrl3[6] <= jdo[19];\n                  xbrk_ctrl3[7] <= jdo[18];\n                end\n            end\n        end\n    end\n\n\n  assign dbrk_hit0_latch = 1'b0;\n  assign dbrk0_low_value = 0;\n  assign dbrk0_high_value = 0;\n  assign dbrk_hit1_latch = 1'b0;\n  assign dbrk1_low_value = 0;\n  assign dbrk1_high_value = 0;\n  assign dbrk_hit2_latch = 1'b0;\n  assign dbrk2_low_value = 0;\n  assign dbrk2_high_value = 0;\n  assign dbrk_hit3_latch = 1'b0;\n  assign dbrk3_low_value = 0;\n  assign dbrk3_high_value = 0;\n  assign xbrk0_value = 32'b0;\n  assign xbrk1_value = 32'b0;\n  assign xbrk2_value = 32'b0;\n  assign xbrk3_value = 32'b0;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          break_readreg <= 32'b0;\n      else if (take_action_any_break)\n          break_readreg <= jdo[31 : 0];\n      else if (take_no_action_break_a)\n          case (break_a_wpr_high_bits)\n          \n              2'd0: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= xbrk0_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= xbrk1_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= xbrk2_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= xbrk3_value;\n                      end \n                  \n                  endcase \n              end \n          \n              2'd1: begin\n                  break_readreg <= 32'b0;\n              end \n          \n              2'd2: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= dbrk0_low_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= dbrk1_low_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= dbrk2_low_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= dbrk3_low_value;\n                      end \n                  \n                  endcase \n              end \n          \n              2'd3: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= dbrk0_high_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= dbrk1_high_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= dbrk2_high_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= dbrk3_high_value;\n                      end \n                  \n                  endcase \n              end \n          \n          endcase \n      else if (take_no_action_break_b)\n          break_readreg <= jdo[31 : 0];\n      else if (take_no_action_break_c)\n          break_readreg <= jdo[31 : 0];\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          trigger_state <= 0;\n      else if (trigger_state_1 & (xbrk_goto0 | dbrk_goto0))\n          trigger_state <= 0;\n      else if (trigger_state_0 & (xbrk_goto1 | dbrk_goto1))\n          trigger_state <= -1;\n    end\n\n\n  assign trigger_state_0 = ~trigger_state;\n  assign trigger_state_1 = trigger_state;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_xbrk (\n                                \n                                 D_valid,\n                                 E_valid,\n                                 F_pc,\n                                 clk,\n                                 reset_n,\n                                 trigger_state_0,\n                                 trigger_state_1,\n                                 xbrk_ctrl0,\n                                 xbrk_ctrl1,\n                                 xbrk_ctrl2,\n                                 xbrk_ctrl3,\n\n                                \n                                 xbrk_break,\n                                 xbrk_goto0,\n                                 xbrk_goto1,\n                                 xbrk_traceoff,\n                                 xbrk_traceon,\n                                 xbrk_trigout\n                              )\n;\n\n  output           xbrk_break;\n  output           xbrk_goto0;\n  output           xbrk_goto1;\n  output           xbrk_traceoff;\n  output           xbrk_traceon;\n  output           xbrk_trigout;\n  input            D_valid;\n  input            E_valid;\n  input   [ 22: 0] F_pc;\n  input            clk;\n  input            reset_n;\n  input            trigger_state_0;\n  input            trigger_state_1;\n  input   [  7: 0] xbrk_ctrl0;\n  input   [  7: 0] xbrk_ctrl1;\n  input   [  7: 0] xbrk_ctrl2;\n  input   [  7: 0] xbrk_ctrl3;\n\n  wire             D_cpu_addr_en;\n  wire             E_cpu_addr_en;\n  reg              E_xbrk_goto0;\n  reg              E_xbrk_goto1;\n  reg              E_xbrk_traceoff;\n  reg              E_xbrk_traceon;\n  reg              E_xbrk_trigout;\n  wire    [ 24: 0] cpu_i_address;\n  wire             xbrk0_armed;\n  wire             xbrk0_break_hit;\n  wire             xbrk0_goto0_hit;\n  wire             xbrk0_goto1_hit;\n  wire             xbrk0_toff_hit;\n  wire             xbrk0_ton_hit;\n  wire             xbrk0_tout_hit;\n  wire             xbrk1_armed;\n  wire             xbrk1_break_hit;\n  wire             xbrk1_goto0_hit;\n  wire             xbrk1_goto1_hit;\n  wire             xbrk1_toff_hit;\n  wire             xbrk1_ton_hit;\n  wire             xbrk1_tout_hit;\n  wire             xbrk2_armed;\n  wire             xbrk2_break_hit;\n  wire             xbrk2_goto0_hit;\n  wire             xbrk2_goto1_hit;\n  wire             xbrk2_toff_hit;\n  wire             xbrk2_ton_hit;\n  wire             xbrk2_tout_hit;\n  wire             xbrk3_armed;\n  wire             xbrk3_break_hit;\n  wire             xbrk3_goto0_hit;\n  wire             xbrk3_goto1_hit;\n  wire             xbrk3_toff_hit;\n  wire             xbrk3_ton_hit;\n  wire             xbrk3_tout_hit;\n  reg              xbrk_break;\n  wire             xbrk_break_hit;\n  wire             xbrk_goto0;\n  wire             xbrk_goto0_hit;\n  wire             xbrk_goto1;\n  wire             xbrk_goto1_hit;\n  wire             xbrk_toff_hit;\n  wire             xbrk_ton_hit;\n  wire             xbrk_tout_hit;\n  wire             xbrk_traceoff;\n  wire             xbrk_traceon;\n  wire             xbrk_trigout;\n  assign cpu_i_address = {F_pc, 2'b00};\n  assign D_cpu_addr_en = D_valid;\n  assign E_cpu_addr_en = E_valid;\n  assign xbrk0_break_hit = 0;\n  assign xbrk0_ton_hit = 0;\n  assign xbrk0_toff_hit = 0;\n  assign xbrk0_tout_hit = 0;\n  assign xbrk0_goto0_hit = 0;\n  assign xbrk0_goto1_hit = 0;\n  assign xbrk1_break_hit = 0;\n  assign xbrk1_ton_hit = 0;\n  assign xbrk1_toff_hit = 0;\n  assign xbrk1_tout_hit = 0;\n  assign xbrk1_goto0_hit = 0;\n  assign xbrk1_goto1_hit = 0;\n  assign xbrk2_break_hit = 0;\n  assign xbrk2_ton_hit = 0;\n  assign xbrk2_toff_hit = 0;\n  assign xbrk2_tout_hit = 0;\n  assign xbrk2_goto0_hit = 0;\n  assign xbrk2_goto1_hit = 0;\n  assign xbrk3_break_hit = 0;\n  assign xbrk3_ton_hit = 0;\n  assign xbrk3_toff_hit = 0;\n  assign xbrk3_tout_hit = 0;\n  assign xbrk3_goto0_hit = 0;\n  assign xbrk3_goto1_hit = 0;\n  assign xbrk_break_hit = (xbrk0_break_hit) | (xbrk1_break_hit) | (xbrk2_break_hit) | (xbrk3_break_hit);\n  assign xbrk_ton_hit = (xbrk0_ton_hit) | (xbrk1_ton_hit) | (xbrk2_ton_hit) | (xbrk3_ton_hit);\n  assign xbrk_toff_hit = (xbrk0_toff_hit) | (xbrk1_toff_hit) | (xbrk2_toff_hit) | (xbrk3_toff_hit);\n  assign xbrk_tout_hit = (xbrk0_tout_hit) | (xbrk1_tout_hit) | (xbrk2_tout_hit) | (xbrk3_tout_hit);\n  assign xbrk_goto0_hit = (xbrk0_goto0_hit) | (xbrk1_goto0_hit) | (xbrk2_goto0_hit) | (xbrk3_goto0_hit);\n  assign xbrk_goto1_hit = (xbrk0_goto1_hit) | (xbrk1_goto1_hit) | (xbrk2_goto1_hit) | (xbrk3_goto1_hit);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          xbrk_break <= 0;\n      else if (E_cpu_addr_en)\n          xbrk_break <= xbrk_break_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_traceon <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_traceon <= xbrk_ton_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_traceoff <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_traceoff <= xbrk_toff_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_trigout <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_trigout <= xbrk_tout_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_goto0 <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_goto0 <= xbrk_goto0_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_goto1 <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_goto1 <= xbrk_goto1_hit;\n    end\n\n\n  assign xbrk_traceon = 1'b0;\n  assign xbrk_traceoff = 1'b0;\n  assign xbrk_trigout = 1'b0;\n  assign xbrk_goto0 = 1'b0;\n  assign xbrk_goto1 = 1'b0;\n  assign xbrk0_armed = (xbrk_ctrl0[4] & trigger_state_0) ||\n    (xbrk_ctrl0[5] & trigger_state_1);\n\n  assign xbrk1_armed = (xbrk_ctrl1[4] & trigger_state_0) ||\n    (xbrk_ctrl1[5] & trigger_state_1);\n\n  assign xbrk2_armed = (xbrk_ctrl2[4] & trigger_state_0) ||\n    (xbrk_ctrl2[5] & trigger_state_1);\n\n  assign xbrk3_armed = (xbrk_ctrl3[4] & trigger_state_0) ||\n    (xbrk_ctrl3[5] & trigger_state_1);\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_dbrk (\n                                \n                                 E_st_data,\n                                 av_ld_data_aligned_filtered,\n                                 clk,\n                                 d_address,\n                                 d_read,\n                                 d_waitrequest,\n                                 d_write,\n                                 debugack,\n                                 reset_n,\n\n                                \n                                 cpu_d_address,\n                                 cpu_d_read,\n                                 cpu_d_readdata,\n                                 cpu_d_wait,\n                                 cpu_d_write,\n                                 cpu_d_writedata,\n                                 dbrk_break,\n                                 dbrk_goto0,\n                                 dbrk_goto1,\n                                 dbrk_traceme,\n                                 dbrk_traceoff,\n                                 dbrk_traceon,\n                                 dbrk_trigout\n                              )\n;\n\n  output  [ 24: 0] cpu_d_address;\n  output           cpu_d_read;\n  output  [ 31: 0] cpu_d_readdata;\n  output           cpu_d_wait;\n  output           cpu_d_write;\n  output  [ 31: 0] cpu_d_writedata;\n  output           dbrk_break;\n  output           dbrk_goto0;\n  output           dbrk_goto1;\n  output           dbrk_traceme;\n  output           dbrk_traceoff;\n  output           dbrk_traceon;\n  output           dbrk_trigout;\n  input   [ 31: 0] E_st_data;\n  input   [ 31: 0] av_ld_data_aligned_filtered;\n  input            clk;\n  input   [ 24: 0] d_address;\n  input            d_read;\n  input            d_waitrequest;\n  input            d_write;\n  input            debugack;\n  input            reset_n;\n\n  wire    [ 24: 0] cpu_d_address;\n  wire             cpu_d_read;\n  wire    [ 31: 0] cpu_d_readdata;\n  wire             cpu_d_wait;\n  wire             cpu_d_write;\n  wire    [ 31: 0] cpu_d_writedata;\n  wire             dbrk0_armed;\n  wire             dbrk0_break_pulse;\n  wire             dbrk0_goto0;\n  wire             dbrk0_goto1;\n  wire             dbrk0_traceme;\n  wire             dbrk0_traceoff;\n  wire             dbrk0_traceon;\n  wire             dbrk0_trigout;\n  wire             dbrk1_armed;\n  wire             dbrk1_break_pulse;\n  wire             dbrk1_goto0;\n  wire             dbrk1_goto1;\n  wire             dbrk1_traceme;\n  wire             dbrk1_traceoff;\n  wire             dbrk1_traceon;\n  wire             dbrk1_trigout;\n  wire             dbrk2_armed;\n  wire             dbrk2_break_pulse;\n  wire             dbrk2_goto0;\n  wire             dbrk2_goto1;\n  wire             dbrk2_traceme;\n  wire             dbrk2_traceoff;\n  wire             dbrk2_traceon;\n  wire             dbrk2_trigout;\n  wire             dbrk3_armed;\n  wire             dbrk3_break_pulse;\n  wire             dbrk3_goto0;\n  wire             dbrk3_goto1;\n  wire             dbrk3_traceme;\n  wire             dbrk3_traceoff;\n  wire             dbrk3_traceon;\n  wire             dbrk3_trigout;\n  reg              dbrk_break;\n  reg              dbrk_break_pulse;\n  wire    [ 31: 0] dbrk_data;\n  reg              dbrk_goto0;\n  reg              dbrk_goto1;\n  reg              dbrk_traceme;\n  reg              dbrk_traceoff;\n  reg              dbrk_traceon;\n  reg              dbrk_trigout;\n  assign cpu_d_address = d_address;\n  assign cpu_d_readdata = av_ld_data_aligned_filtered;\n  assign cpu_d_read = d_read;\n  assign cpu_d_writedata = E_st_data;\n  assign cpu_d_write = d_write;\n  assign cpu_d_wait = d_waitrequest;\n  assign dbrk_data = cpu_d_write ? cpu_d_writedata : cpu_d_readdata;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          dbrk_break <= 0;\n      else \n        dbrk_break <= dbrk_break   ? ~debugack   \n                : dbrk_break_pulse;\n\n    end\n\n\n  assign dbrk0_armed = 1'b0;\n  assign dbrk0_trigout = 1'b0;\n  assign dbrk0_break_pulse = 1'b0;\n  assign dbrk0_traceoff = 1'b0;\n  assign dbrk0_traceon = 1'b0;\n  assign dbrk0_traceme = 1'b0;\n  assign dbrk0_goto0 = 1'b0;\n  assign dbrk0_goto1 = 1'b0;\n  assign dbrk1_armed = 1'b0;\n  assign dbrk1_trigout = 1'b0;\n  assign dbrk1_break_pulse = 1'b0;\n  assign dbrk1_traceoff = 1'b0;\n  assign dbrk1_traceon = 1'b0;\n  assign dbrk1_traceme = 1'b0;\n  assign dbrk1_goto0 = 1'b0;\n  assign dbrk1_goto1 = 1'b0;\n  assign dbrk2_armed = 1'b0;\n  assign dbrk2_trigout = 1'b0;\n  assign dbrk2_break_pulse = 1'b0;\n  assign dbrk2_traceoff = 1'b0;\n  assign dbrk2_traceon = 1'b0;\n  assign dbrk2_traceme = 1'b0;\n  assign dbrk2_goto0 = 1'b0;\n  assign dbrk2_goto1 = 1'b0;\n  assign dbrk3_armed = 1'b0;\n  assign dbrk3_trigout = 1'b0;\n  assign dbrk3_break_pulse = 1'b0;\n  assign dbrk3_traceoff = 1'b0;\n  assign dbrk3_traceon = 1'b0;\n  assign dbrk3_traceme = 1'b0;\n  assign dbrk3_goto0 = 1'b0;\n  assign dbrk3_goto1 = 1'b0;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          dbrk_trigout <= 0;\n          dbrk_break_pulse <= 0;\n          dbrk_traceoff <= 0;\n          dbrk_traceon <= 0;\n          dbrk_traceme <= 0;\n          dbrk_goto0 <= 0;\n          dbrk_goto1 <= 0;\n        end\n      else \n        begin\n          dbrk_trigout <= dbrk0_trigout | dbrk1_trigout | dbrk2_trigout | dbrk3_trigout;\n          dbrk_break_pulse <= dbrk0_break_pulse | dbrk1_break_pulse | dbrk2_break_pulse | dbrk3_break_pulse;\n          dbrk_traceoff <= dbrk0_traceoff | dbrk1_traceoff | dbrk2_traceoff | dbrk3_traceoff;\n          dbrk_traceon <= dbrk0_traceon | dbrk1_traceon | dbrk2_traceon | dbrk3_traceon;\n          dbrk_traceme <= dbrk0_traceme | dbrk1_traceme | dbrk2_traceme | dbrk3_traceme;\n          dbrk_goto0 <= dbrk0_goto0 | dbrk1_goto0 | dbrk2_goto0 | dbrk3_goto0;\n          dbrk_goto1 <= dbrk0_goto1 | dbrk1_goto1 | dbrk2_goto1 | dbrk3_goto1;\n        end\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_itrace (\n                                  \n                                   clk,\n                                   dbrk_traceoff,\n                                   dbrk_traceon,\n                                   jdo,\n                                   jrst_n,\n                                   take_action_tracectrl,\n                                   trc_enb,\n                                   xbrk_traceoff,\n                                   xbrk_traceon,\n                                   xbrk_wrap_traceoff,\n\n                                  \n                                   dct_buffer,\n                                   dct_count,\n                                   itm,\n                                   trc_ctrl,\n                                   trc_on\n                                )\n;\n\n  output  [ 29: 0] dct_buffer;\n  output  [  3: 0] dct_count;\n  output  [ 35: 0] itm;\n  output  [ 15: 0] trc_ctrl;\n  output           trc_on;\n  input            clk;\n  input            dbrk_traceoff;\n  input            dbrk_traceon;\n  input   [ 15: 0] jdo;\n  input            jrst_n;\n  input            take_action_tracectrl;\n  input            trc_enb;\n  input            xbrk_traceoff;\n  input            xbrk_traceon;\n  input            xbrk_wrap_traceoff;\n\n  wire             advanced_exc_occured;\n  wire             curr_pid;\n  reg     [ 29: 0] dct_buffer ;\n  wire    [  1: 0] dct_code;\n  reg     [  3: 0] dct_count ;\n  wire             dct_is_taken;\n  wire    [ 31: 0] eic_addr;\n  wire    [ 31: 0] exc_addr;\n  wire             instr_retired;\n  wire             is_cond_dct;\n  wire             is_dct;\n  wire             is_exception_no_break;\n  wire             is_external_interrupt;\n  wire             is_fast_tlb_miss_exception;\n  wire             is_idct;\n  reg     [ 35: 0] itm ;\n  wire             not_in_debug_mode;\n  reg              pending_curr_pid ;\n  reg              pending_exc ;\n  reg     [ 31: 0] pending_exc_addr ;\n  reg     [ 31: 0] pending_exc_handler ;\n  reg              pending_exc_record_handler ;\n  reg     [  3: 0] pending_frametype ;\n  reg              pending_prev_pid ;\n  reg              prev_pid ;\n  reg              prev_pid_valid ;\n  wire             record_dct_outcome_in_sync;\n  wire             record_itrace;\n  wire    [ 31: 0] retired_pcb;\n  reg              snapped_curr_pid ;\n  reg              snapped_pid ;\n  reg              snapped_prev_pid ;\n  wire    [  1: 0] sync_code;\n  wire    [  6: 0] sync_interval;\n  reg     [  6: 0] sync_timer ;\n  wire    [  6: 0] sync_timer_next;\n  wire             sync_timer_reached_zero;\n  reg              trc_clear ;\n  wire    [ 15: 0] trc_ctrl;\n  reg     [ 10: 0] trc_ctrl_reg ;\n  wire             trc_on;\n  assign is_cond_dct = 1'b0;\n  assign is_dct = 1'b0;\n  assign dct_is_taken = 1'b0;\n  assign is_idct = 1'b0;\n  assign retired_pcb = 32'b0;\n  assign not_in_debug_mode = 1'b0;\n  assign instr_retired = 1'b0;\n  assign advanced_exc_occured = 1'b0;\n  assign is_exception_no_break = 1'b0;\n  assign is_external_interrupt = 1'b0;\n  assign is_fast_tlb_miss_exception = 1'b0;\n  assign curr_pid = 1'b0;\n  assign exc_addr = 32'b0;\n  assign eic_addr = 32'b0;\n  assign sync_code = trc_ctrl[3 : 2];\n  assign sync_interval = { sync_code[1] & sync_code[0], 1'b0, sync_code[1] & ~sync_code[0], 1'b0, ~sync_code[1] & sync_code[0], 2'b00 };\n  assign sync_timer_reached_zero = sync_timer == 0;\n  assign record_dct_outcome_in_sync = dct_is_taken & sync_timer_reached_zero;\n  assign sync_timer_next = sync_timer_reached_zero ? sync_timer : (sync_timer - 1);\n  assign record_itrace = trc_on & trc_ctrl[4];\n  assign dct_code = {is_cond_dct, dct_is_taken};\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          trc_clear <= 0;\n      else \n        trc_clear <= ~trc_enb & \n                take_action_tracectrl & jdo[4];\n\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          itm <= 0;\n          dct_buffer <= 0;\n          dct_count <= 0;\n          sync_timer <= 0;\n          pending_frametype <= 4'b0000;\n          pending_exc <= 0;\n          pending_exc_addr <= 0;\n          pending_exc_handler <= 0;\n          pending_exc_record_handler <= 0;\n          prev_pid <= 0;\n          prev_pid_valid <= 0;\n          snapped_pid <= 0;\n          snapped_curr_pid <= 0;\n          snapped_prev_pid <= 0;\n          pending_curr_pid <= 0;\n          pending_prev_pid <= 0;\n        end\n      else if (trc_clear || (!0 && !0))\n        begin\n          itm <= 0;\n          dct_buffer <= 0;\n          dct_count <= 0;\n          sync_timer <= 0;\n          pending_frametype <= 4'b0000;\n          pending_exc <= 0;\n          pending_exc_addr <= 0;\n          pending_exc_handler <= 0;\n          pending_exc_record_handler <= 0;\n          prev_pid <= 0;\n          prev_pid_valid <= 0;\n          snapped_pid <= 0;\n          snapped_curr_pid <= 0;\n          snapped_prev_pid <= 0;\n          pending_curr_pid <= 0;\n          pending_prev_pid <= 0;\n        end\n      else \n        begin\n          if (!prev_pid_valid)\n            begin\n              prev_pid <= curr_pid;\n              prev_pid_valid <= 1;\n            end\n          if ((curr_pid != prev_pid) & prev_pid_valid & !snapped_pid)\n            begin\n              snapped_pid <= 1;\n              snapped_curr_pid <= curr_pid;\n              snapped_prev_pid <= prev_pid;\n              prev_pid <= curr_pid;\n              prev_pid_valid <= 1;\n            end\n          if (instr_retired | advanced_exc_occured)\n            begin\n              if (~record_itrace)\n                  pending_frametype <= 4'b1010;\n              else if (is_exception_no_break)\n                begin\n                  pending_exc <= 1;\n                  pending_exc_addr <= exc_addr;\n                  pending_exc_record_handler <= 0;\n                  if (is_external_interrupt)\n                      pending_exc_handler <= eic_addr;\n                  else if (is_fast_tlb_miss_exception)\n                      pending_exc_handler <= 32'h0;\n                  else \n                    pending_exc_handler <= 32'h800020;\n                  pending_frametype <= 4'b0000;\n                end\n              else if (is_idct)\n                  pending_frametype <= 4'b1001;\n              else if (record_dct_outcome_in_sync)\n                  pending_frametype <= 4'b1000;\n              else if (!is_dct & snapped_pid)\n                begin\n                  pending_frametype <= 4'b0011;\n                  pending_curr_pid <= snapped_curr_pid;\n                  pending_prev_pid <= snapped_prev_pid;\n                  snapped_pid <= 0;\n                end\n              else \n                pending_frametype <= 4'b0000;\n              if ((dct_count != 0) & \n             (~record_itrace | \n              is_exception_no_break |\n              is_idct |\n              record_dct_outcome_in_sync |\n              (!is_dct & snapped_pid)))\n                begin\n                  itm <= {4'b0001, dct_buffer, 2'b00};\n                  dct_buffer <= 0;\n                  dct_count <= 0;\n                  sync_timer <= sync_timer_next;\n                end\n              else \n                begin\n                  if (record_itrace & (is_dct & (dct_count != 4'd15)) & ~record_dct_outcome_in_sync & ~advanced_exc_occured)\n                    begin\n                      dct_buffer <= {dct_code, dct_buffer[29 : 2]};\n                      dct_count <= dct_count + 1;\n                    end\n                  if (record_itrace & (\n                  (pending_frametype == 4'b1000) |\n                  (pending_frametype == 4'b1010) |\n                  (pending_frametype == 4'b1001)))\n                    begin\n                      itm <= {pending_frametype, retired_pcb};\n                      sync_timer <= sync_interval;\n                      if (0 &\n                      ((pending_frametype == 4'b1000) | (pending_frametype == 4'b1010)) &\n                      !snapped_pid & prev_pid_valid)\n                        begin\n                          snapped_pid <= 1;\n                          snapped_curr_pid <= curr_pid;\n                          snapped_prev_pid <= prev_pid;\n                        end\n                    end\n                  else if (record_itrace & \n                  0 & (pending_frametype == 4'b0011))\n                      itm <= {4'b0011, 2'b00, pending_prev_pid, 2'b00, pending_curr_pid};\n                  else if (record_itrace & is_dct)\n                    begin\n                      if (dct_count == 4'd15)\n                        begin\n                          itm <= {4'b0001, dct_code, dct_buffer};\n                          dct_buffer <= 0;\n                          dct_count <= 0;\n                          sync_timer <= sync_timer_next;\n                        end\n                      else \n                        itm <= 4'b0000;\n                    end\n                  else \n                    itm <= {4'b0000, 32'b0};\n                end\n            end\n          else if (record_itrace & pending_exc)\n            begin\n              if (pending_exc_record_handler)\n                begin\n                  itm <= {4'b0010, pending_exc_handler[31 : 1], 1'b1};\n                  pending_exc <= 1'b0;\n                  pending_exc_record_handler <= 1'b0;\n                end\n              else \n                begin\n                  itm <= {4'b0010, pending_exc_addr[31 : 1], 1'b0};\n                  pending_exc_record_handler <= 1'b1;\n                end\n            end\n          else \n            itm <= {4'b0000, 32'b0};\n        end\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          trc_ctrl_reg[0] <= 1'b0;\n          trc_ctrl_reg[1] <= 1'b0;\n          trc_ctrl_reg[3 : 2] <= 2'b00;\n          trc_ctrl_reg[4] <= 1'b0;\n          trc_ctrl_reg[7 : 5] <= 3'b000;\n          trc_ctrl_reg[8] <= 0;\n          trc_ctrl_reg[9] <= 1'b0;\n          trc_ctrl_reg[10] <= 1'b0;\n        end\n      else if (take_action_tracectrl)\n        begin\n          trc_ctrl_reg[0] <= jdo[5];\n          trc_ctrl_reg[1] <= jdo[6];\n          trc_ctrl_reg[3 : 2] <= jdo[8 : 7];\n          trc_ctrl_reg[4] <= jdo[9];\n          trc_ctrl_reg[9] <= jdo[14];\n          trc_ctrl_reg[10] <= jdo[2];\n          if (0)\n              trc_ctrl_reg[7 : 5] <= jdo[12 : 10];\n          if (0 & 0)\n              trc_ctrl_reg[8] <= jdo[13];\n        end\n      else if (xbrk_wrap_traceoff)\n        begin\n          trc_ctrl_reg[1] <= 0;\n          trc_ctrl_reg[0] <= 0;\n        end\n      else if (dbrk_traceoff | xbrk_traceoff)\n          trc_ctrl_reg[1] <= 0;\n      else if (trc_ctrl_reg[0] & \n                                  (dbrk_traceon | xbrk_traceon))\n          trc_ctrl_reg[1] <= 1;\n    end\n\n\n  assign trc_ctrl = (0 || 0) ? {6'b000000, trc_ctrl_reg} : 0;\n  assign trc_on = trc_ctrl[1] & (trc_ctrl[9] | not_in_debug_mode);\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_td_mode (\n                                   \n                                    ctrl,\n\n                                   \n                                    td_mode\n                                 )\n;\n\n  output  [  3: 0] td_mode;\n  input   [  8: 0] ctrl;\n\n  wire    [  2: 0] ctrl_bits_for_mux;\n  reg     [  3: 0] td_mode;\n  assign ctrl_bits_for_mux = ctrl[7 : 5];\n  always @(ctrl_bits_for_mux)\n    begin\n      case (ctrl_bits_for_mux)\n      \n          3'b000: begin\n              td_mode = 4'b0000;\n          end \n      \n          3'b001: begin\n              td_mode = 4'b1000;\n          end \n      \n          3'b010: begin\n              td_mode = 4'b0100;\n          end \n      \n          3'b011: begin\n              td_mode = 4'b1100;\n          end \n      \n          3'b100: begin\n              td_mode = 4'b0010;\n          end \n      \n          3'b101: begin\n              td_mode = 4'b1010;\n          end \n      \n          3'b110: begin\n              td_mode = 4'b0101;\n          end \n      \n          3'b111: begin\n              td_mode = 4'b1111;\n          end \n      \n      endcase \n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_dtrace (\n                                  \n                                   clk,\n                                   cpu_d_address,\n                                   cpu_d_read,\n                                   cpu_d_readdata,\n                                   cpu_d_wait,\n                                   cpu_d_write,\n                                   cpu_d_writedata,\n                                   jrst_n,\n                                   trc_ctrl,\n\n                                  \n                                   atm,\n                                   dtm\n                                )\n;\n\n  output  [ 35: 0] atm;\n  output  [ 35: 0] dtm;\n  input            clk;\n  input   [ 24: 0] cpu_d_address;\n  input            cpu_d_read;\n  input   [ 31: 0] cpu_d_readdata;\n  input            cpu_d_wait;\n  input            cpu_d_write;\n  input   [ 31: 0] cpu_d_writedata;\n  input            jrst_n;\n  input   [ 15: 0] trc_ctrl;\n\n  reg     [ 35: 0] atm ;\n  wire    [ 31: 0] cpu_d_address_0_padded;\n  wire    [ 31: 0] cpu_d_readdata_0_padded;\n  wire    [ 31: 0] cpu_d_writedata_0_padded;\n  reg     [ 35: 0] dtm ;\n  wire             record_load_addr;\n  wire             record_load_data;\n  wire             record_store_addr;\n  wire             record_store_data;\n  wire    [  3: 0] td_mode_trc_ctrl;\n  assign cpu_d_writedata_0_padded = cpu_d_writedata | 32'b0;\n  assign cpu_d_readdata_0_padded = cpu_d_readdata | 32'b0;\n  assign cpu_d_address_0_padded = cpu_d_address | 32'b0;\n  \n  CPU_cpu_nios2_oci_td_mode CPU_cpu_nios2_oci_trc_ctrl_td_mode\n    (\n      .ctrl    (trc_ctrl[8 : 0]),\n      .td_mode (td_mode_trc_ctrl)\n    );\n\n  assign {record_load_addr, record_store_addr,\n         record_load_data, record_store_data} = td_mode_trc_ctrl;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          atm <= 0;\n          dtm <= 0;\n        end\n      else if (0)\n        begin\n          if (cpu_d_write & ~cpu_d_wait & record_store_addr)\n              atm <= {4'b0101, cpu_d_address_0_padded};\n          else if (cpu_d_read & ~cpu_d_wait & record_load_addr)\n              atm <= {4'b0100, cpu_d_address_0_padded};\n          else \n            atm <= {4'b0000, cpu_d_address_0_padded};\n          if (cpu_d_write & ~cpu_d_wait & record_store_data)\n              dtm <= {4'b0111, cpu_d_writedata_0_padded};\n          else if (cpu_d_read & ~cpu_d_wait & record_load_data)\n              dtm <= {4'b0110, cpu_d_readdata_0_padded};\n          else \n            dtm <= {4'b0000, cpu_d_readdata_0_padded};\n        end\n      else \n        begin\n          atm <= 0;\n          dtm <= 0;\n        end\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_compute_input_tm_cnt (\n                                                \n                                                 atm_valid,\n                                                 dtm_valid,\n                                                 itm_valid,\n\n                                                \n                                                 compute_input_tm_cnt\n                                              )\n;\n\n  output  [  1: 0] compute_input_tm_cnt;\n  input            atm_valid;\n  input            dtm_valid;\n  input            itm_valid;\n\n  reg     [  1: 0] compute_input_tm_cnt;\n  wire    [  2: 0] switch_for_mux;\n  assign switch_for_mux = {itm_valid, atm_valid, dtm_valid};\n  always @(switch_for_mux)\n    begin\n      case (switch_for_mux)\n      \n          3'b000: begin\n              compute_input_tm_cnt = 0;\n          end \n      \n          3'b001: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b010: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b011: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b100: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b101: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b110: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b111: begin\n              compute_input_tm_cnt = 3;\n          end \n      \n      endcase \n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo_wrptr_inc (\n                                          \n                                           ge2_free,\n                                           ge3_free,\n                                           input_tm_cnt,\n\n                                          \n                                           fifo_wrptr_inc\n                                        )\n;\n\n  output  [  3: 0] fifo_wrptr_inc;\n  input            ge2_free;\n  input            ge3_free;\n  input   [  1: 0] input_tm_cnt;\n\n  reg     [  3: 0] fifo_wrptr_inc;\n  always @(ge2_free or ge3_free or input_tm_cnt)\n    begin\n      if (ge3_free & (input_tm_cnt == 3))\n          fifo_wrptr_inc = 3;\n      else if (ge2_free & (input_tm_cnt >= 2))\n          fifo_wrptr_inc = 2;\n      else if (input_tm_cnt >= 1)\n          fifo_wrptr_inc = 1;\n      else \n        fifo_wrptr_inc = 0;\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo_cnt_inc (\n                                        \n                                         empty,\n                                         ge2_free,\n                                         ge3_free,\n                                         input_tm_cnt,\n\n                                        \n                                         fifo_cnt_inc\n                                      )\n;\n\n  output  [  4: 0] fifo_cnt_inc;\n  input            empty;\n  input            ge2_free;\n  input            ge3_free;\n  input   [  1: 0] input_tm_cnt;\n\n  reg     [  4: 0] fifo_cnt_inc;\n  always @(empty or ge2_free or ge3_free or input_tm_cnt)\n    begin\n      if (empty)\n          fifo_cnt_inc = input_tm_cnt[1 : 0];\n      else if (ge3_free & (input_tm_cnt == 3))\n          fifo_cnt_inc = 2;\n      else if (ge2_free & (input_tm_cnt >= 2))\n          fifo_cnt_inc = 1;\n      else if (input_tm_cnt >= 1)\n          fifo_cnt_inc = 0;\n      else \n        fifo_cnt_inc = {5{1'b1}};\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo (\n                                \n                                 atm,\n                                 clk,\n                                 dbrk_traceme,\n                                 dbrk_traceoff,\n                                 dbrk_traceon,\n                                 dct_buffer,\n                                 dct_count,\n                                 dtm,\n                                 itm,\n                                 jrst_n,\n                                 reset_n,\n                                 test_ending,\n                                 test_has_ended,\n                                 trc_on,\n\n                                \n                                 tw\n                              )\n;\n\n  output  [ 35: 0] tw;\n  input   [ 35: 0] atm;\n  input            clk;\n  input            dbrk_traceme;\n  input            dbrk_traceoff;\n  input            dbrk_traceon;\n  input   [ 29: 0] dct_buffer;\n  input   [  3: 0] dct_count;\n  input   [ 35: 0] dtm;\n  input   [ 35: 0] itm;\n  input            jrst_n;\n  input            reset_n;\n  input            test_ending;\n  input            test_has_ended;\n  input            trc_on;\n\n  wire             atm_valid;\n  wire    [  1: 0] compute_input_tm_cnt;\n  wire             dtm_valid;\n  wire             empty;\n  reg     [ 35: 0] fifo_0;\n  wire             fifo_0_enable;\n  wire    [ 35: 0] fifo_0_mux;\n  reg     [ 35: 0] fifo_1;\n  reg     [ 35: 0] fifo_10;\n  wire             fifo_10_enable;\n  wire    [ 35: 0] fifo_10_mux;\n  reg     [ 35: 0] fifo_11;\n  wire             fifo_11_enable;\n  wire    [ 35: 0] fifo_11_mux;\n  reg     [ 35: 0] fifo_12;\n  wire             fifo_12_enable;\n  wire    [ 35: 0] fifo_12_mux;\n  reg     [ 35: 0] fifo_13;\n  wire             fifo_13_enable;\n  wire    [ 35: 0] fifo_13_mux;\n  reg     [ 35: 0] fifo_14;\n  wire             fifo_14_enable;\n  wire    [ 35: 0] fifo_14_mux;\n  reg     [ 35: 0] fifo_15;\n  wire             fifo_15_enable;\n  wire    [ 35: 0] fifo_15_mux;\n  wire             fifo_1_enable;\n  wire    [ 35: 0] fifo_1_mux;\n  reg     [ 35: 0] fifo_2;\n  wire             fifo_2_enable;\n  wire    [ 35: 0] fifo_2_mux;\n  reg     [ 35: 0] fifo_3;\n  wire             fifo_3_enable;\n  wire    [ 35: 0] fifo_3_mux;\n  reg     [ 35: 0] fifo_4;\n  wire             fifo_4_enable;\n  wire    [ 35: 0] fifo_4_mux;\n  reg     [ 35: 0] fifo_5;\n  wire             fifo_5_enable;\n  wire    [ 35: 0] fifo_5_mux;\n  reg     [ 35: 0] fifo_6;\n  wire             fifo_6_enable;\n  wire    [ 35: 0] fifo_6_mux;\n  reg     [ 35: 0] fifo_7;\n  wire             fifo_7_enable;\n  wire    [ 35: 0] fifo_7_mux;\n  reg     [ 35: 0] fifo_8;\n  wire             fifo_8_enable;\n  wire    [ 35: 0] fifo_8_mux;\n  reg     [ 35: 0] fifo_9;\n  wire             fifo_9_enable;\n  wire    [ 35: 0] fifo_9_mux;\n  reg     [  4: 0] fifo_cnt ;\n  wire    [  4: 0] fifo_cnt_inc;\n  wire    [ 35: 0] fifo_head;\n  reg     [  3: 0] fifo_rdptr ;\n  wire    [ 35: 0] fifo_read_mux;\n  reg     [  3: 0] fifo_wrptr ;\n  wire    [  3: 0] fifo_wrptr_inc;\n  wire    [  3: 0] fifo_wrptr_plus1;\n  wire    [  3: 0] fifo_wrptr_plus2;\n  wire             ge2_free;\n  wire             ge3_free;\n  wire             input_ge1;\n  wire             input_ge2;\n  wire             input_ge3;\n  wire    [  1: 0] input_tm_cnt;\n  wire             itm_valid;\n  reg              overflow_pending ;\n  wire    [ 35: 0] overflow_pending_atm;\n  wire    [ 35: 0] overflow_pending_dtm;\n  wire             trc_this;\n  wire    [ 35: 0] tw;\n  assign trc_this = trc_on | (dbrk_traceon & ~dbrk_traceoff) | dbrk_traceme;\n  assign itm_valid = |itm[35 : 32];\n  assign atm_valid = |atm[35 : 32] & trc_this;\n  assign dtm_valid = |dtm[35 : 32] & trc_this;\n  assign ge2_free = ~fifo_cnt[4];\n  assign ge3_free = ge2_free & ~&fifo_cnt[3 : 0];\n  assign empty = ~|fifo_cnt;\n  assign fifo_wrptr_plus1 = fifo_wrptr + 1;\n  assign fifo_wrptr_plus2 = fifo_wrptr + 2;\n  CPU_cpu_nios2_oci_compute_input_tm_cnt the_CPU_cpu_nios2_oci_compute_input_tm_cnt\n    (\n      .atm_valid            (atm_valid),\n      .compute_input_tm_cnt (compute_input_tm_cnt),\n      .dtm_valid            (dtm_valid),\n      .itm_valid            (itm_valid)\n    );\n\n  assign input_tm_cnt = compute_input_tm_cnt;\n  CPU_cpu_nios2_oci_fifo_wrptr_inc the_CPU_cpu_nios2_oci_fifo_wrptr_inc\n    (\n      .fifo_wrptr_inc (fifo_wrptr_inc),\n      .ge2_free       (ge2_free),\n      .ge3_free       (ge3_free),\n      .input_tm_cnt   (input_tm_cnt)\n    );\n\n  CPU_cpu_nios2_oci_fifo_cnt_inc the_CPU_cpu_nios2_oci_fifo_cnt_inc\n    (\n      .empty        (empty),\n      .fifo_cnt_inc (fifo_cnt_inc),\n      .ge2_free     (ge2_free),\n      .ge3_free     (ge3_free),\n      .input_tm_cnt (input_tm_cnt)\n    );\n\n  CPU_cpu_oci_test_bench the_CPU_cpu_oci_test_bench\n    (\n      .dct_buffer     (dct_buffer),\n      .dct_count      (dct_count),\n      .test_ending    (test_ending),\n      .test_has_ended (test_has_ended)\n    );\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          fifo_rdptr <= 0;\n          fifo_wrptr <= 0;\n          fifo_cnt <= 0;\n          overflow_pending <= 1;\n        end\n      else \n        begin\n          fifo_wrptr <= fifo_wrptr + fifo_wrptr_inc;\n          fifo_cnt <= fifo_cnt + fifo_cnt_inc;\n          if (~empty)\n              fifo_rdptr <= fifo_rdptr + 1;\n          if (~trc_this || (~ge2_free & input_ge2) || (~ge3_free & input_ge3))\n              overflow_pending <= 1;\n          else if (atm_valid | dtm_valid)\n              overflow_pending <= 0;\n        end\n    end\n\n\n  assign fifo_head = fifo_read_mux;\n  assign tw = 0 ?  { (empty ? 4'h0 : fifo_head[35 : 32]),   fifo_head[31 : 0]}  : itm;\n  assign fifo_0_enable = ((fifo_wrptr == 4'd0) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd0) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd0) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_0 <= 0;\n      else if (fifo_0_enable)\n          fifo_0 <= fifo_0_mux;\n    end\n\n\n  assign fifo_0_mux = (((fifo_wrptr == 4'd0) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd0) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd0) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_1_enable = ((fifo_wrptr == 4'd1) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd1) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd1) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_1 <= 0;\n      else if (fifo_1_enable)\n          fifo_1 <= fifo_1_mux;\n    end\n\n\n  assign fifo_1_mux = (((fifo_wrptr == 4'd1) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd1) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd1) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_2_enable = ((fifo_wrptr == 4'd2) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd2) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd2) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_2 <= 0;\n      else if (fifo_2_enable)\n          fifo_2 <= fifo_2_mux;\n    end\n\n\n  assign fifo_2_mux = (((fifo_wrptr == 4'd2) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd2) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd2) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_3_enable = ((fifo_wrptr == 4'd3) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd3) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd3) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_3 <= 0;\n      else if (fifo_3_enable)\n          fifo_3 <= fifo_3_mux;\n    end\n\n\n  assign fifo_3_mux = (((fifo_wrptr == 4'd3) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd3) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd3) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_4_enable = ((fifo_wrptr == 4'd4) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd4) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd4) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_4 <= 0;\n      else if (fifo_4_enable)\n          fifo_4 <= fifo_4_mux;\n    end\n\n\n  assign fifo_4_mux = (((fifo_wrptr == 4'd4) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd4) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd4) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_5_enable = ((fifo_wrptr == 4'd5) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd5) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd5) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_5 <= 0;\n      else if (fifo_5_enable)\n          fifo_5 <= fifo_5_mux;\n    end\n\n\n  assign fifo_5_mux = (((fifo_wrptr == 4'd5) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd5) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd5) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_6_enable = ((fifo_wrptr == 4'd6) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd6) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd6) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_6 <= 0;\n      else if (fifo_6_enable)\n          fifo_6 <= fifo_6_mux;\n    end\n\n\n  assign fifo_6_mux = (((fifo_wrptr == 4'd6) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd6) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd6) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_7_enable = ((fifo_wrptr == 4'd7) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd7) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd7) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_7 <= 0;\n      else if (fifo_7_enable)\n          fifo_7 <= fifo_7_mux;\n    end\n\n\n  assign fifo_7_mux = (((fifo_wrptr == 4'd7) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd7) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd7) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_8_enable = ((fifo_wrptr == 4'd8) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd8) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd8) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_8 <= 0;\n      else if (fifo_8_enable)\n          fifo_8 <= fifo_8_mux;\n    end\n\n\n  assign fifo_8_mux = (((fifo_wrptr == 4'd8) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd8) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd8) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_9_enable = ((fifo_wrptr == 4'd9) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd9) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd9) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_9 <= 0;\n      else if (fifo_9_enable)\n          fifo_9 <= fifo_9_mux;\n    end\n\n\n  assign fifo_9_mux = (((fifo_wrptr == 4'd9) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd9) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd9) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_10_enable = ((fifo_wrptr == 4'd10) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd10) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd10) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_10 <= 0;\n      else if (fifo_10_enable)\n          fifo_10 <= fifo_10_mux;\n    end\n\n\n  assign fifo_10_mux = (((fifo_wrptr == 4'd10) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd10) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd10) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_11_enable = ((fifo_wrptr == 4'd11) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd11) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd11) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_11 <= 0;\n      else if (fifo_11_enable)\n          fifo_11 <= fifo_11_mux;\n    end\n\n\n  assign fifo_11_mux = (((fifo_wrptr == 4'd11) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd11) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd11) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_12_enable = ((fifo_wrptr == 4'd12) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd12) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd12) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_12 <= 0;\n      else if (fifo_12_enable)\n          fifo_12 <= fifo_12_mux;\n    end\n\n\n  assign fifo_12_mux = (((fifo_wrptr == 4'd12) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd12) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd12) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_13_enable = ((fifo_wrptr == 4'd13) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd13) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd13) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_13 <= 0;\n      else if (fifo_13_enable)\n          fifo_13 <= fifo_13_mux;\n    end\n\n\n  assign fifo_13_mux = (((fifo_wrptr == 4'd13) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd13) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd13) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_14_enable = ((fifo_wrptr == 4'd14) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd14) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd14) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_14 <= 0;\n      else if (fifo_14_enable)\n          fifo_14 <= fifo_14_mux;\n    end\n\n\n  assign fifo_14_mux = (((fifo_wrptr == 4'd14) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd14) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd14) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_15_enable = ((fifo_wrptr == 4'd15) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd15) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd15) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_15 <= 0;\n      else if (fifo_15_enable)\n          fifo_15 <= fifo_15_mux;\n    end\n\n\n  assign fifo_15_mux = (((fifo_wrptr == 4'd15) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd15) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd15) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign input_ge1 = |input_tm_cnt;\n  assign input_ge2 = input_tm_cnt[1];\n  assign input_ge3 = &input_tm_cnt;\n  assign overflow_pending_atm = {overflow_pending, atm[34 : 0]};\n  assign overflow_pending_dtm = {overflow_pending, dtm[34 : 0]};\n  assign fifo_read_mux = (fifo_rdptr == 4'd0)? fifo_0 :\n    (fifo_rdptr == 4'd1)? fifo_1 :\n    (fifo_rdptr == 4'd2)? fifo_2 :\n    (fifo_rdptr == 4'd3)? fifo_3 :\n    (fifo_rdptr == 4'd4)? fifo_4 :\n    (fifo_rdptr == 4'd5)? fifo_5 :\n    (fifo_rdptr == 4'd6)? fifo_6 :\n    (fifo_rdptr == 4'd7)? fifo_7 :\n    (fifo_rdptr == 4'd8)? fifo_8 :\n    (fifo_rdptr == 4'd9)? fifo_9 :\n    (fifo_rdptr == 4'd10)? fifo_10 :\n    (fifo_rdptr == 4'd11)? fifo_11 :\n    (fifo_rdptr == 4'd12)? fifo_12 :\n    (fifo_rdptr == 4'd13)? fifo_13 :\n    (fifo_rdptr == 4'd14)? fifo_14 :\n    fifo_15;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_pib (\n                               \n                                clk,\n                                clkx2,\n                                jrst_n,\n                                tw,\n\n                               \n                                tr_clk,\n                                tr_data\n                             )\n;\n\n  output           tr_clk;\n  output  [ 17: 0] tr_data;\n  input            clk;\n  input            clkx2;\n  input            jrst_n;\n  input   [ 35: 0] tw;\n\n  wire             phase;\n  wire             tr_clk;\n  reg              tr_clk_reg ;\n  wire    [ 17: 0] tr_data;\n  reg     [ 17: 0] tr_data_reg ;\n  reg              x1 ;\n  reg              x2 ;\n  assign phase = x1^x2;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          x1 <= 0;\n      else \n        x1 <= ~x1;\n    end\n\n\n  always @(posedge clkx2 or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          x2 <= 0;\n          tr_clk_reg <= 0;\n          tr_data_reg <= 0;\n        end\n      else \n        begin\n          x2 <= x1;\n          tr_clk_reg <= ~phase;\n          tr_data_reg <= phase ?   tw[17 : 0] :   tw[35 : 18];\n        end\n    end\n\n\n  assign tr_clk = 0 ? tr_clk_reg : 0;\n  assign tr_data = 0 ? tr_data_reg : 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_im (\n                              \n                               clk,\n                               jdo,\n                               jrst_n,\n                               reset_n,\n                               take_action_tracectrl,\n                               take_action_tracemem_a,\n                               take_action_tracemem_b,\n                               take_no_action_tracemem_a,\n                               trc_ctrl,\n                               tw,\n\n                              \n                               tracemem_on,\n                               tracemem_trcdata,\n                               tracemem_tw,\n                               trc_enb,\n                               trc_im_addr,\n                               trc_wrap,\n                               xbrk_wrap_traceoff\n                            )\n;\n\n  output           tracemem_on;\n  output  [ 35: 0] tracemem_trcdata;\n  output           tracemem_tw;\n  output           trc_enb;\n  output  [  6: 0] trc_im_addr;\n  output           trc_wrap;\n  output           xbrk_wrap_traceoff;\n  input            clk;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            reset_n;\n  input            take_action_tracectrl;\n  input            take_action_tracemem_a;\n  input            take_action_tracemem_b;\n  input            take_no_action_tracemem_a;\n  input   [ 15: 0] trc_ctrl;\n  input   [ 35: 0] tw;\n\n  wire             tracemem_on;\n  wire    [ 35: 0] tracemem_trcdata;\n  wire             tracemem_tw;\n  wire             trc_enb;\n  reg     [  6: 0] trc_im_addr ;\n  wire    [ 35: 0] trc_im_data;\n  reg     [ 16: 0] trc_jtag_addr ;\n  wire             trc_on_chip;\n  reg              trc_wrap ;\n  wire             tw_valid;\n  wire             xbrk_wrap_traceoff;\n  assign trc_im_data = tw;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          trc_im_addr <= 0;\n          trc_wrap <= 0;\n        end\n      else if (!0)\n        begin\n          trc_im_addr <= 0;\n          trc_wrap <= 0;\n        end\n      else if (take_action_tracectrl && \n                      (jdo[4] | jdo[3]))\n        begin\n          if (jdo[4])\n              trc_im_addr <= 0;\n          if (jdo[3])\n              trc_wrap <= 0;\n        end\n      else if (trc_enb & trc_on_chip & tw_valid)\n        begin\n          trc_im_addr <= trc_im_addr+1;\n          if (&trc_im_addr)\n              trc_wrap <= 1;\n        end\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          trc_jtag_addr <= 0;\n      else if (take_action_tracemem_a ||\n                take_no_action_tracemem_a || \n                take_action_tracemem_b)\n          trc_jtag_addr <= take_action_tracemem_a ? \n                    jdo[35 : 19] : \n                    trc_jtag_addr + 1;\n\n    end\n\n\n  assign trc_enb = trc_ctrl[0];\n  assign trc_on_chip = ~trc_ctrl[8];\n  assign tw_valid = |trc_im_data[35 : 32];\n  assign xbrk_wrap_traceoff = trc_ctrl[10] & trc_wrap;\n  assign tracemem_tw = trc_wrap;\n  assign tracemem_on = trc_enb;\n  assign tracemem_trcdata = 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_performance_monitors \n;\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci (\n                           \n                            D_valid,\n                            E_st_data,\n                            E_valid,\n                            F_pc,\n                            address_nxt,\n                            av_ld_data_aligned_filtered,\n                            byteenable_nxt,\n                            clk,\n                            d_address,\n                            d_read,\n                            d_waitrequest,\n                            d_write,\n                            debugaccess_nxt,\n                            hbreak_enabled,\n                            read_nxt,\n                            reset,\n                            reset_n,\n                            reset_req,\n                            test_ending,\n                            test_has_ended,\n                            write_nxt,\n                            writedata_nxt,\n\n                           \n                            jtag_debug_module_debugaccess_to_roms,\n                            oci_hbreak_req,\n                            oci_ienable,\n                            oci_single_step_mode,\n                            readdata,\n                            resetrequest,\n                            waitrequest\n                         )\n;\n\n  output           jtag_debug_module_debugaccess_to_roms;\n  output           oci_hbreak_req;\n  output  [ 31: 0] oci_ienable;\n  output           oci_single_step_mode;\n  output  [ 31: 0] readdata;\n  output           resetrequest;\n  output           waitrequest;\n  input            D_valid;\n  input   [ 31: 0] E_st_data;\n  input            E_valid;\n  input   [ 22: 0] F_pc;\n  input   [  8: 0] address_nxt;\n  input   [ 31: 0] av_ld_data_aligned_filtered;\n  input   [  3: 0] byteenable_nxt;\n  input            clk;\n  input   [ 24: 0] d_address;\n  input            d_read;\n  input            d_waitrequest;\n  input            d_write;\n  input            debugaccess_nxt;\n  input            hbreak_enabled;\n  input            read_nxt;\n  input            reset;\n  input            reset_n;\n  input            reset_req;\n  input            test_ending;\n  input            test_has_ended;\n  input            write_nxt;\n  input   [ 31: 0] writedata_nxt;\n\n  wire    [ 31: 0] MonDReg;\n  reg     [  8: 0] address;\n  wire    [ 35: 0] atm;\n  wire    [ 31: 0] break_readreg;\n  reg     [  3: 0] byteenable;\n  wire             clkx2;\n  wire    [ 24: 0] cpu_d_address;\n  wire             cpu_d_read;\n  wire    [ 31: 0] cpu_d_readdata;\n  wire             cpu_d_wait;\n  wire             cpu_d_write;\n  wire    [ 31: 0] cpu_d_writedata;\n  wire             dbrk_break;\n  wire             dbrk_goto0;\n  wire             dbrk_goto1;\n  wire             dbrk_hit0_latch;\n  wire             dbrk_hit1_latch;\n  wire             dbrk_hit2_latch;\n  wire             dbrk_hit3_latch;\n  wire             dbrk_traceme;\n  wire             dbrk_traceoff;\n  wire             dbrk_traceon;\n  wire             dbrk_trigout;\n  wire    [ 29: 0] dct_buffer;\n  wire    [  3: 0] dct_count;\n  reg              debugaccess;\n  wire             debugack;\n  wire             debugreq;\n  wire    [ 35: 0] dtm;\n  wire             dummy_sink;\n  wire    [ 35: 0] itm;\n  wire    [ 37: 0] jdo;\n  wire             jrst_n;\n  wire             jtag_debug_module_debugaccess_to_roms;\n  wire             monitor_error;\n  wire             monitor_go;\n  wire             monitor_ready;\n  wire             oci_hbreak_req;\n  wire    [ 31: 0] oci_ienable;\n  wire    [ 31: 0] oci_reg_readdata;\n  wire             oci_single_step_mode;\n  wire    [ 31: 0] ociram_readdata;\n  wire             ocireg_ers;\n  wire             ocireg_mrs;\n  reg              read;\n  reg     [ 31: 0] readdata;\n  wire             resetlatch;\n  wire             resetrequest;\n  wire             st_ready_test_idle;\n  wire             take_action_break_a;\n  wire             take_action_break_b;\n  wire             take_action_break_c;\n  wire             take_action_ocimem_a;\n  wire             take_action_ocimem_b;\n  wire             take_action_ocireg;\n  wire             take_action_tracectrl;\n  wire             take_action_tracemem_a;\n  wire             take_action_tracemem_b;\n  wire             take_no_action_break_a;\n  wire             take_no_action_break_b;\n  wire             take_no_action_break_c;\n  wire             take_no_action_ocimem_a;\n  wire             take_no_action_tracemem_a;\n  wire             tr_clk;\n  wire    [ 17: 0] tr_data;\n  wire             tracemem_on;\n  wire    [ 35: 0] tracemem_trcdata;\n  wire             tracemem_tw;\n  wire    [ 15: 0] trc_ctrl;\n  wire             trc_enb;\n  wire    [  6: 0] trc_im_addr;\n  wire             trc_on;\n  wire             trc_wrap;\n  wire             trigbrktype;\n  wire             trigger_state_0;\n  wire             trigger_state_1;\n  wire             trigout;\n  wire    [ 35: 0] tw;\n  wire             waitrequest;\n  reg              write;\n  reg     [ 31: 0] writedata;\n  wire             xbrk_break;\n  wire    [  7: 0] xbrk_ctrl0;\n  wire    [  7: 0] xbrk_ctrl1;\n  wire    [  7: 0] xbrk_ctrl2;\n  wire    [  7: 0] xbrk_ctrl3;\n  wire             xbrk_goto0;\n  wire             xbrk_goto1;\n  wire             xbrk_traceoff;\n  wire             xbrk_traceon;\n  wire             xbrk_trigout;\n  wire             xbrk_wrap_traceoff;\n  CPU_cpu_nios2_oci_debug the_CPU_cpu_nios2_oci_debug\n    (\n      .clk                  (clk),\n      .dbrk_break           (dbrk_break),\n      .debugack             (debugack),\n      .debugreq             (debugreq),\n      .hbreak_enabled       (hbreak_enabled),\n      .jdo                  (jdo),\n      .jrst_n               (jrst_n),\n      .monitor_error        (monitor_error),\n      .monitor_go           (monitor_go),\n      .monitor_ready        (monitor_ready),\n      .oci_hbreak_req       (oci_hbreak_req),\n      .ocireg_ers           (ocireg_ers),\n      .ocireg_mrs           (ocireg_mrs),\n      .reset                (reset),\n      .resetlatch           (resetlatch),\n      .resetrequest         (resetrequest),\n      .st_ready_test_idle   (st_ready_test_idle),\n      .take_action_ocimem_a (take_action_ocimem_a),\n      .take_action_ocireg   (take_action_ocireg),\n      .xbrk_break           (xbrk_break)\n    );\n\n  CPU_cpu_nios2_ocimem the_CPU_cpu_nios2_ocimem\n    (\n      .MonDReg                 (MonDReg),\n      .address                 (address),\n      .byteenable              (byteenable),\n      .clk                     (clk),\n      .debugaccess             (debugaccess),\n      .jdo                     (jdo),\n      .jrst_n                  (jrst_n),\n      .ociram_readdata         (ociram_readdata),\n      .read                    (read),\n      .reset_req               (reset_req),\n      .take_action_ocimem_a    (take_action_ocimem_a),\n      .take_action_ocimem_b    (take_action_ocimem_b),\n      .take_no_action_ocimem_a (take_no_action_ocimem_a),\n      .waitrequest             (waitrequest),\n      .write                   (write),\n      .writedata               (writedata)\n    );\n\n  CPU_cpu_nios2_avalon_reg the_CPU_cpu_nios2_avalon_reg\n    (\n      .address              (address),\n      .clk                  (clk),\n      .debugaccess          (debugaccess),\n      .monitor_error        (monitor_error),\n      .monitor_go           (monitor_go),\n      .monitor_ready        (monitor_ready),\n      .oci_ienable          (oci_ienable),\n      .oci_reg_readdata     (oci_reg_readdata),\n      .oci_single_step_mode (oci_single_step_mode),\n      .ocireg_ers           (ocireg_ers),\n      .ocireg_mrs           (ocireg_mrs),\n      .reset_n              (reset_n),\n      .take_action_ocireg   (take_action_ocireg),\n      .write                (write),\n      .writedata            (writedata)\n    );\n\n  CPU_cpu_nios2_oci_break the_CPU_cpu_nios2_oci_break\n    (\n      .break_readreg          (break_readreg),\n      .clk                    (clk),\n      .dbrk_break             (dbrk_break),\n      .dbrk_goto0             (dbrk_goto0),\n      .dbrk_goto1             (dbrk_goto1),\n      .dbrk_hit0_latch        (dbrk_hit0_latch),\n      .dbrk_hit1_latch        (dbrk_hit1_latch),\n      .dbrk_hit2_latch        (dbrk_hit2_latch),\n      .dbrk_hit3_latch        (dbrk_hit3_latch),\n      .jdo                    (jdo),\n      .jrst_n                 (jrst_n),\n      .reset_n                (reset_n),\n      .take_action_break_a    (take_action_break_a),\n      .take_action_break_b    (take_action_break_b),\n      .take_action_break_c    (take_action_break_c),\n      .take_no_action_break_a (take_no_action_break_a),\n      .take_no_action_break_b (take_no_action_break_b),\n      .take_no_action_break_c (take_no_action_break_c),\n      .trigbrktype            (trigbrktype),\n      .trigger_state_0        (trigger_state_0),\n      .trigger_state_1        (trigger_state_1),\n      .xbrk_ctrl0             (xbrk_ctrl0),\n      .xbrk_ctrl1             (xbrk_ctrl1),\n      .xbrk_ctrl2             (xbrk_ctrl2),\n      .xbrk_ctrl3             (xbrk_ctrl3),\n      .xbrk_goto0             (xbrk_goto0),\n      .xbrk_goto1             (xbrk_goto1)\n    );\n\n  CPU_cpu_nios2_oci_xbrk the_CPU_cpu_nios2_oci_xbrk\n    (\n      .D_valid         (D_valid),\n      .E_valid         (E_valid),\n      .F_pc            (F_pc),\n      .clk             (clk),\n      .reset_n         (reset_n),\n      .trigger_state_0 (trigger_state_0),\n      .trigger_state_1 (trigger_state_1),\n      .xbrk_break      (xbrk_break),\n      .xbrk_ctrl0      (xbrk_ctrl0),\n      .xbrk_ctrl1      (xbrk_ctrl1),\n      .xbrk_ctrl2      (xbrk_ctrl2),\n      .xbrk_ctrl3      (xbrk_ctrl3),\n      .xbrk_goto0      (xbrk_goto0),\n      .xbrk_goto1      (xbrk_goto1),\n      .xbrk_traceoff   (xbrk_traceoff),\n      .xbrk_traceon    (xbrk_traceon),\n      .xbrk_trigout    (xbrk_trigout)\n    );\n\n  CPU_cpu_nios2_oci_dbrk the_CPU_cpu_nios2_oci_dbrk\n    (\n      .E_st_data                   (E_st_data),\n      .av_ld_data_aligned_filtered (av_ld_data_aligned_filtered),\n      .clk                         (clk),\n      .cpu_d_address               (cpu_d_address),\n      .cpu_d_read                  (cpu_d_read),\n      .cpu_d_readdata              (cpu_d_readdata),\n      .cpu_d_wait                  (cpu_d_wait),\n      .cpu_d_write                 (cpu_d_write),\n      .cpu_d_writedata             (cpu_d_writedata),\n      .d_address                   (d_address),\n      .d_read                      (d_read),\n      .d_waitrequest               (d_waitrequest),\n      .d_write                     (d_write),\n      .dbrk_break                  (dbrk_break),\n      .dbrk_goto0                  (dbrk_goto0),\n      .dbrk_goto1                  (dbrk_goto1),\n      .dbrk_traceme                (dbrk_traceme),\n      .dbrk_traceoff               (dbrk_traceoff),\n      .dbrk_traceon                (dbrk_traceon),\n      .dbrk_trigout                (dbrk_trigout),\n      .debugack                    (debugack),\n      .reset_n                     (reset_n)\n    );\n\n  CPU_cpu_nios2_oci_itrace the_CPU_cpu_nios2_oci_itrace\n    (\n      .clk                   (clk),\n      .dbrk_traceoff         (dbrk_traceoff),\n      .dbrk_traceon          (dbrk_traceon),\n      .dct_buffer            (dct_buffer),\n      .dct_count             (dct_count),\n      .itm                   (itm),\n      .jdo                   (jdo),\n      .jrst_n                (jrst_n),\n      .take_action_tracectrl (take_action_tracectrl),\n      .trc_ctrl              (trc_ctrl),\n      .trc_enb               (trc_enb),\n      .trc_on                (trc_on),\n      .xbrk_traceoff         (xbrk_traceoff),\n      .xbrk_traceon          (xbrk_traceon),\n      .xbrk_wrap_traceoff    (xbrk_wrap_traceoff)\n    );\n\n  CPU_cpu_nios2_oci_dtrace the_CPU_cpu_nios2_oci_dtrace\n    (\n      .atm             (atm),\n      .clk             (clk),\n      .cpu_d_address   (cpu_d_address),\n      .cpu_d_read      (cpu_d_read),\n      .cpu_d_readdata  (cpu_d_readdata),\n      .cpu_d_wait      (cpu_d_wait),\n      .cpu_d_write     (cpu_d_write),\n      .cpu_d_writedata (cpu_d_writedata),\n      .dtm             (dtm),\n      .jrst_n          (jrst_n),\n      .trc_ctrl        (trc_ctrl)\n    );\n\n  CPU_cpu_nios2_oci_fifo the_CPU_cpu_nios2_oci_fifo\n    (\n      .atm            (atm),\n      .clk            (clk),\n      .dbrk_traceme   (dbrk_traceme),\n      .dbrk_traceoff  (dbrk_traceoff),\n      .dbrk_traceon   (dbrk_traceon),\n      .dct_buffer     (dct_buffer),\n      .dct_count      (dct_count),\n      .dtm            (dtm),\n      .itm            (itm),\n      .jrst_n         (jrst_n),\n      .reset_n        (reset_n),\n      .test_ending    (test_ending),\n      .test_has_ended (test_has_ended),\n      .trc_on         (trc_on),\n      .tw             (tw)\n    );\n\n  CPU_cpu_nios2_oci_pib the_CPU_cpu_nios2_oci_pib\n    (\n      .clk     (clk),\n      .clkx2   (clkx2),\n      .jrst_n  (jrst_n),\n      .tr_clk  (tr_clk),\n      .tr_data (tr_data),\n      .tw      (tw)\n    );\n\n  CPU_cpu_nios2_oci_im the_CPU_cpu_nios2_oci_im\n    (\n      .clk                       (clk),\n      .jdo                       (jdo),\n      .jrst_n                    (jrst_n),\n      .reset_n                   (reset_n),\n      .take_action_tracectrl     (take_action_tracectrl),\n      .take_action_tracemem_a    (take_action_tracemem_a),\n      .take_action_tracemem_b    (take_action_tracemem_b),\n      .take_no_action_tracemem_a (take_no_action_tracemem_a),\n      .tracemem_on               (tracemem_on),\n      .tracemem_trcdata          (tracemem_trcdata),\n      .tracemem_tw               (tracemem_tw),\n      .trc_ctrl                  (trc_ctrl),\n      .trc_enb                   (trc_enb),\n      .trc_im_addr               (trc_im_addr),\n      .trc_wrap                  (trc_wrap),\n      .tw                        (tw),\n      .xbrk_wrap_traceoff        (xbrk_wrap_traceoff)\n    );\n\n  assign trigout = dbrk_trigout | xbrk_trigout;\n  assign jtag_debug_module_debugaccess_to_roms = debugack;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          address <= 0;\n      else \n        address <= address_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          byteenable <= 0;\n      else \n        byteenable <= byteenable_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          writedata <= 0;\n      else \n        writedata <= writedata_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          debugaccess <= 0;\n      else \n        debugaccess <= debugaccess_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          read <= 0;\n      else \n        read <= read ? waitrequest : read_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          write <= 0;\n      else \n        write <= write ? waitrequest : write_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          readdata <= 0;\n      else \n        readdata <= address[8] ? oci_reg_readdata : ociram_readdata;\n    end\n\n\n  CPU_cpu_jtag_debug_module_wrapper the_CPU_cpu_jtag_debug_module_wrapper\n    (\n      .MonDReg                   (MonDReg),\n      .break_readreg             (break_readreg),\n      .clk                       (clk),\n      .dbrk_hit0_latch           (dbrk_hit0_latch),\n      .dbrk_hit1_latch           (dbrk_hit1_latch),\n      .dbrk_hit2_latch           (dbrk_hit2_latch),\n      .dbrk_hit3_latch           (dbrk_hit3_latch),\n      .debugack                  (debugack),\n      .jdo                       (jdo),\n      .jrst_n                    (jrst_n),\n      .monitor_error             (monitor_error),\n      .monitor_ready             (monitor_ready),\n      .reset_n                   (reset_n),\n      .resetlatch                (resetlatch),\n      .st_ready_test_idle        (st_ready_test_idle),\n      .take_action_break_a       (take_action_break_a),\n      .take_action_break_b       (take_action_break_b),\n      .take_action_break_c       (take_action_break_c),\n      .take_action_ocimem_a      (take_action_ocimem_a),\n      .take_action_ocimem_b      (take_action_ocimem_b),\n      .take_action_tracectrl     (take_action_tracectrl),\n      .take_action_tracemem_a    (take_action_tracemem_a),\n      .take_action_tracemem_b    (take_action_tracemem_b),\n      .take_no_action_break_a    (take_no_action_break_a),\n      .take_no_action_break_b    (take_no_action_break_b),\n      .take_no_action_break_c    (take_no_action_break_c),\n      .take_no_action_ocimem_a   (take_no_action_ocimem_a),\n      .take_no_action_tracemem_a (take_no_action_tracemem_a),\n      .tracemem_on               (tracemem_on),\n      .tracemem_trcdata          (tracemem_trcdata),\n      .tracemem_tw               (tracemem_tw),\n      .trc_im_addr               (trc_im_addr),\n      .trc_on                    (trc_on),\n      .trc_wrap                  (trc_wrap),\n      .trigbrktype               (trigbrktype),\n      .trigger_state_1           (trigger_state_1)\n    );\n\n  \n  assign dummy_sink = tr_clk |\n    tr_data |\n    trigout |\n    debugack;\n\n  assign debugreq = 0;\n  assign clkx2 = 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu (\n                 \n                  clk,\n                  d_irq,\n                  d_readdata,\n                  d_waitrequest,\n                  i_readdata,\n                  i_waitrequest,\n                  jtag_debug_module_address,\n                  jtag_debug_module_byteenable,\n                  jtag_debug_module_debugaccess,\n                  jtag_debug_module_read,\n                  jtag_debug_module_write,\n                  jtag_debug_module_writedata,\n                  reset_n,\n                  reset_req,\n\n                 \n                  d_address,\n                  d_byteenable,\n                  d_read,\n                  d_write,\n                  d_writedata,\n                  i_address,\n                  i_read,\n                  jtag_debug_module_debugaccess_to_roms,\n                  jtag_debug_module_readdata,\n                  jtag_debug_module_resetrequest,\n                  jtag_debug_module_waitrequest,\n                  no_ci_readra\n               )\n;\n\n  output  [ 24: 0] d_address;\n  output  [  3: 0] d_byteenable;\n  output           d_read;\n  output           d_write;\n  output  [ 31: 0] d_writedata;\n  output  [ 24: 0] i_address;\n  output           i_read;\n  output           jtag_debug_module_debugaccess_to_roms;\n  output  [ 31: 0] jtag_debug_module_readdata;\n  output           jtag_debug_module_resetrequest;\n  output           jtag_debug_module_waitrequest;\n  output           no_ci_readra;\n  input            clk;\n  input   [ 31: 0] d_irq;\n  input   [ 31: 0] d_readdata;\n  input            d_waitrequest;\n  input   [ 31: 0] i_readdata;\n  input            i_waitrequest;\n  input   [  8: 0] jtag_debug_module_address;\n  input   [  3: 0] jtag_debug_module_byteenable;\n  input            jtag_debug_module_debugaccess;\n  input            jtag_debug_module_read;\n  input            jtag_debug_module_write;\n  input   [ 31: 0] jtag_debug_module_writedata;\n  input            reset_n;\n  input            reset_req;\n\n  wire    [  1: 0] D_compare_op;\n  wire             D_ctrl_alu_force_xor;\n  wire             D_ctrl_alu_signed_comparison;\n  wire             D_ctrl_alu_subtract;\n  wire             D_ctrl_b_is_dst;\n  wire             D_ctrl_br;\n  wire             D_ctrl_br_cmp;\n  wire             D_ctrl_br_uncond;\n  wire             D_ctrl_break;\n  wire             D_ctrl_crst;\n  wire             D_ctrl_custom;\n  wire             D_ctrl_custom_multi;\n  wire             D_ctrl_exception;\n  wire             D_ctrl_force_src2_zero;\n  wire             D_ctrl_hi_imm16;\n  wire             D_ctrl_ignore_dst;\n  wire             D_ctrl_implicit_dst_eretaddr;\n  wire             D_ctrl_implicit_dst_retaddr;\n  wire             D_ctrl_jmp_direct;\n  wire             D_ctrl_jmp_indirect;\n  wire             D_ctrl_ld;\n  wire             D_ctrl_ld_io;\n  wire             D_ctrl_ld_non_io;\n  wire             D_ctrl_ld_signed;\n  wire             D_ctrl_logic;\n  wire             D_ctrl_rdctl_inst;\n  wire             D_ctrl_retaddr;\n  wire             D_ctrl_rot_right;\n  wire             D_ctrl_shift_logical;\n  wire             D_ctrl_shift_right_arith;\n  wire             D_ctrl_shift_rot;\n  wire             D_ctrl_shift_rot_right;\n  wire             D_ctrl_src2_choose_imm;\n  wire             D_ctrl_st;\n  wire             D_ctrl_uncond_cti_non_br;\n  wire             D_ctrl_unsigned_lo_imm16;\n  wire             D_ctrl_wrctl_inst;\n  wire    [  4: 0] D_dst_regnum;\n  wire    [ 55: 0] D_inst;\n  reg     [ 31: 0] D_iw ;\n  wire    [  4: 0] D_iw_a;\n  wire    [  4: 0] D_iw_b;\n  wire    [  4: 0] D_iw_c;\n  wire    [  2: 0] D_iw_control_regnum;\n  wire    [  7: 0] D_iw_custom_n;\n  wire             D_iw_custom_readra;\n  wire             D_iw_custom_readrb;\n  wire             D_iw_custom_writerc;\n  wire    [ 15: 0] D_iw_imm16;\n  wire    [ 25: 0] D_iw_imm26;\n  wire    [  4: 0] D_iw_imm5;\n  wire    [  1: 0] D_iw_memsz;\n  wire    [  5: 0] D_iw_op;\n  wire    [  5: 0] D_iw_opx;\n  wire    [  4: 0] D_iw_shift_imm5;\n  wire    [  4: 0] D_iw_trap_break_imm5;\n  wire    [ 22: 0] D_jmp_direct_target_waddr;\n  wire    [  1: 0] D_logic_op;\n  wire    [  1: 0] D_logic_op_raw;\n  wire             D_mem16;\n  wire             D_mem32;\n  wire             D_mem8;\n  wire             D_op_add;\n  wire             D_op_addi;\n  wire             D_op_and;\n  wire             D_op_andhi;\n  wire             D_op_andi;\n  wire             D_op_beq;\n  wire             D_op_bge;\n  wire             D_op_bgeu;\n  wire             D_op_blt;\n  wire             D_op_bltu;\n  wire             D_op_bne;\n  wire             D_op_br;\n  wire             D_op_break;\n  wire             D_op_bret;\n  wire             D_op_call;\n  wire             D_op_callr;\n  wire             D_op_cmpeq;\n  wire             D_op_cmpeqi;\n  wire             D_op_cmpge;\n  wire             D_op_cmpgei;\n  wire             D_op_cmpgeu;\n  wire             D_op_cmpgeui;\n  wire             D_op_cmplt;\n  wire             D_op_cmplti;\n  wire             D_op_cmpltu;\n  wire             D_op_cmpltui;\n  wire             D_op_cmpne;\n  wire             D_op_cmpnei;\n  wire             D_op_crst;\n  wire             D_op_custom;\n  wire             D_op_div;\n  wire             D_op_divu;\n  wire             D_op_eret;\n  wire             D_op_flushd;\n  wire             D_op_flushda;\n  wire             D_op_flushi;\n  wire             D_op_flushp;\n  wire             D_op_hbreak;\n  wire             D_op_initd;\n  wire             D_op_initda;\n  wire             D_op_initi;\n  wire             D_op_intr;\n  wire             D_op_jmp;\n  wire             D_op_jmpi;\n  wire             D_op_ldb;\n  wire             D_op_ldbio;\n  wire             D_op_ldbu;\n  wire             D_op_ldbuio;\n  wire             D_op_ldh;\n  wire             D_op_ldhio;\n  wire             D_op_ldhu;\n  wire             D_op_ldhuio;\n  wire             D_op_ldl;\n  wire             D_op_ldw;\n  wire             D_op_ldwio;\n  wire             D_op_mul;\n  wire             D_op_muli;\n  wire             D_op_mulxss;\n  wire             D_op_mulxsu;\n  wire             D_op_mulxuu;\n  wire             D_op_nextpc;\n  wire             D_op_nor;\n  wire             D_op_opx;\n  wire             D_op_or;\n  wire             D_op_orhi;\n  wire             D_op_ori;\n  wire             D_op_rdctl;\n  wire             D_op_rdprs;\n  wire             D_op_ret;\n  wire             D_op_rol;\n  wire             D_op_roli;\n  wire             D_op_ror;\n  wire             D_op_rsv02;\n  wire             D_op_rsv09;\n  wire             D_op_rsv10;\n  wire             D_op_rsv17;\n  wire             D_op_rsv18;\n  wire             D_op_rsv25;\n  wire             D_op_rsv26;\n  wire             D_op_rsv33;\n  wire             D_op_rsv34;\n  wire             D_op_rsv41;\n  wire             D_op_rsv42;\n  wire             D_op_rsv49;\n  wire             D_op_rsv57;\n  wire             D_op_rsv61;\n  wire             D_op_rsv62;\n  wire             D_op_rsv63;\n  wire             D_op_rsvx00;\n  wire             D_op_rsvx10;\n  wire             D_op_rsvx15;\n  wire             D_op_rsvx17;\n  wire             D_op_rsvx21;\n  wire             D_op_rsvx25;\n  wire             D_op_rsvx33;\n  wire             D_op_rsvx34;\n  wire             D_op_rsvx35;\n  wire             D_op_rsvx42;\n  wire             D_op_rsvx43;\n  wire             D_op_rsvx44;\n  wire             D_op_rsvx47;\n  wire             D_op_rsvx50;\n  wire             D_op_rsvx51;\n  wire             D_op_rsvx55;\n  wire             D_op_rsvx56;\n  wire             D_op_rsvx60;\n  wire             D_op_rsvx63;\n  wire             D_op_sll;\n  wire             D_op_slli;\n  wire             D_op_sra;\n  wire             D_op_srai;\n  wire             D_op_srl;\n  wire             D_op_srli;\n  wire             D_op_stb;\n  wire             D_op_stbio;\n  wire             D_op_stc;\n  wire             D_op_sth;\n  wire             D_op_sthio;\n  wire             D_op_stw;\n  wire             D_op_stwio;\n  wire             D_op_sub;\n  wire             D_op_sync;\n  wire             D_op_trap;\n  wire             D_op_wrctl;\n  wire             D_op_wrprs;\n  wire             D_op_xor;\n  wire             D_op_xorhi;\n  wire             D_op_xori;\n  reg              D_valid;\n  wire    [ 55: 0] D_vinst;\n  wire             D_wr_dst_reg;\n  wire    [ 31: 0] E_alu_result;\n  reg              E_alu_sub;\n  wire    [ 32: 0] E_arith_result;\n  wire    [ 31: 0] E_arith_src1;\n  wire    [ 31: 0] E_arith_src2;\n  wire             E_ci_multi_stall;\n  wire    [ 31: 0] E_ci_result;\n  wire             E_cmp_result;\n  wire    [ 31: 0] E_control_rd_data;\n  wire             E_eq;\n  reg              E_invert_arith_src_msb;\n  wire             E_ld_stall;\n  wire    [ 31: 0] E_logic_result;\n  wire             E_logic_result_is_0;\n  wire             E_lt;\n  wire    [ 24: 0] E_mem_baddr;\n  wire    [  3: 0] E_mem_byte_en;\n  reg              E_new_inst;\n  reg     [  4: 0] E_shift_rot_cnt;\n  wire    [  4: 0] E_shift_rot_cnt_nxt;\n  wire             E_shift_rot_done;\n  wire             E_shift_rot_fill_bit;\n  reg     [ 31: 0] E_shift_rot_result;\n  wire    [ 31: 0] E_shift_rot_result_nxt;\n  wire             E_shift_rot_stall;\n  reg     [ 31: 0] E_src1;\n  reg     [ 31: 0] E_src2;\n  wire    [ 31: 0] E_st_data;\n  wire             E_st_stall;\n  wire             E_stall;\n  reg              E_valid;\n  wire    [ 55: 0] E_vinst;\n  wire             E_wrctl_bstatus;\n  wire             E_wrctl_estatus;\n  wire             E_wrctl_ienable;\n  wire             E_wrctl_status;\n  wire    [ 31: 0] F_av_iw;\n  wire    [  4: 0] F_av_iw_a;\n  wire    [  4: 0] F_av_iw_b;\n  wire    [  4: 0] F_av_iw_c;\n  wire    [  2: 0] F_av_iw_control_regnum;\n  wire    [  7: 0] F_av_iw_custom_n;\n  wire             F_av_iw_custom_readra;\n  wire             F_av_iw_custom_readrb;\n  wire             F_av_iw_custom_writerc;\n  wire    [ 15: 0] F_av_iw_imm16;\n  wire    [ 25: 0] F_av_iw_imm26;\n  wire    [  4: 0] F_av_iw_imm5;\n  wire    [  1: 0] F_av_iw_memsz;\n  wire    [  5: 0] F_av_iw_op;\n  wire    [  5: 0] F_av_iw_opx;\n  wire    [  4: 0] F_av_iw_shift_imm5;\n  wire    [  4: 0] F_av_iw_trap_break_imm5;\n  wire             F_av_mem16;\n  wire             F_av_mem32;\n  wire             F_av_mem8;\n  wire    [ 55: 0] F_inst;\n  wire    [ 31: 0] F_iw;\n  wire    [  4: 0] F_iw_a;\n  wire    [  4: 0] F_iw_b;\n  wire    [  4: 0] F_iw_c;\n  wire    [  2: 0] F_iw_control_regnum;\n  wire    [  7: 0] F_iw_custom_n;\n  wire             F_iw_custom_readra;\n  wire             F_iw_custom_readrb;\n  wire             F_iw_custom_writerc;\n  wire    [ 15: 0] F_iw_imm16;\n  wire    [ 25: 0] F_iw_imm26;\n  wire    [  4: 0] F_iw_imm5;\n  wire    [  1: 0] F_iw_memsz;\n  wire    [  5: 0] F_iw_op;\n  wire    [  5: 0] F_iw_opx;\n  wire    [  4: 0] F_iw_shift_imm5;\n  wire    [  4: 0] F_iw_trap_break_imm5;\n  wire             F_mem16;\n  wire             F_mem32;\n  wire             F_mem8;\n  wire             F_op_add;\n  wire             F_op_addi;\n  wire             F_op_and;\n  wire             F_op_andhi;\n  wire             F_op_andi;\n  wire             F_op_beq;\n  wire             F_op_bge;\n  wire             F_op_bgeu;\n  wire             F_op_blt;\n  wire             F_op_bltu;\n  wire             F_op_bne;\n  wire             F_op_br;\n  wire             F_op_break;\n  wire             F_op_bret;\n  wire             F_op_call;\n  wire             F_op_callr;\n  wire             F_op_cmpeq;\n  wire             F_op_cmpeqi;\n  wire             F_op_cmpge;\n  wire             F_op_cmpgei;\n  wire             F_op_cmpgeu;\n  wire             F_op_cmpgeui;\n  wire             F_op_cmplt;\n  wire             F_op_cmplti;\n  wire             F_op_cmpltu;\n  wire             F_op_cmpltui;\n  wire             F_op_cmpne;\n  wire             F_op_cmpnei;\n  wire             F_op_crst;\n  wire             F_op_custom;\n  wire             F_op_div;\n  wire             F_op_divu;\n  wire             F_op_eret;\n  wire             F_op_flushd;\n  wire             F_op_flushda;\n  wire             F_op_flushi;\n  wire             F_op_flushp;\n  wire             F_op_hbreak;\n  wire             F_op_initd;\n  wire             F_op_initda;\n  wire             F_op_initi;\n  wire             F_op_intr;\n  wire             F_op_jmp;\n  wire             F_op_jmpi;\n  wire             F_op_ldb;\n  wire             F_op_ldbio;\n  wire             F_op_ldbu;\n  wire             F_op_ldbuio;\n  wire             F_op_ldh;\n  wire             F_op_ldhio;\n  wire             F_op_ldhu;\n  wire             F_op_ldhuio;\n  wire             F_op_ldl;\n  wire             F_op_ldw;\n  wire             F_op_ldwio;\n  wire             F_op_mul;\n  wire             F_op_muli;\n  wire             F_op_mulxss;\n  wire             F_op_mulxsu;\n  wire             F_op_mulxuu;\n  wire             F_op_nextpc;\n  wire             F_op_nor;\n  wire             F_op_opx;\n  wire             F_op_or;\n  wire             F_op_orhi;\n  wire             F_op_ori;\n  wire             F_op_rdctl;\n  wire             F_op_rdprs;\n  wire             F_op_ret;\n  wire             F_op_rol;\n  wire             F_op_roli;\n  wire             F_op_ror;\n  wire             F_op_rsv02;\n  wire             F_op_rsv09;\n  wire             F_op_rsv10;\n  wire             F_op_rsv17;\n  wire             F_op_rsv18;\n  wire             F_op_rsv25;\n  wire             F_op_rsv26;\n  wire             F_op_rsv33;\n  wire             F_op_rsv34;\n  wire             F_op_rsv41;\n  wire             F_op_rsv42;\n  wire             F_op_rsv49;\n  wire             F_op_rsv57;\n  wire             F_op_rsv61;\n  wire             F_op_rsv62;\n  wire             F_op_rsv63;\n  wire             F_op_rsvx00;\n  wire             F_op_rsvx10;\n  wire             F_op_rsvx15;\n  wire             F_op_rsvx17;\n  wire             F_op_rsvx21;\n  wire             F_op_rsvx25;\n  wire             F_op_rsvx33;\n  wire             F_op_rsvx34;\n  wire             F_op_rsvx35;\n  wire             F_op_rsvx42;\n  wire             F_op_rsvx43;\n  wire             F_op_rsvx44;\n  wire             F_op_rsvx47;\n  wire             F_op_rsvx50;\n  wire             F_op_rsvx51;\n  wire             F_op_rsvx55;\n  wire             F_op_rsvx56;\n  wire             F_op_rsvx60;\n  wire             F_op_rsvx63;\n  wire             F_op_sll;\n  wire             F_op_slli;\n  wire             F_op_sra;\n  wire             F_op_srai;\n  wire             F_op_srl;\n  wire             F_op_srli;\n  wire             F_op_stb;\n  wire             F_op_stbio;\n  wire             F_op_stc;\n  wire             F_op_sth;\n  wire             F_op_sthio;\n  wire             F_op_stw;\n  wire             F_op_stwio;\n  wire             F_op_sub;\n  wire             F_op_sync;\n  wire             F_op_trap;\n  wire             F_op_wrctl;\n  wire             F_op_wrprs;\n  wire             F_op_xor;\n  wire             F_op_xorhi;\n  wire             F_op_xori;\n  reg     [ 22: 0] F_pc ;\n  wire             F_pc_en;\n  wire    [ 22: 0] F_pc_no_crst_nxt;\n  wire    [ 22: 0] F_pc_nxt;\n  wire    [ 22: 0] F_pc_plus_one;\n  wire    [  1: 0] F_pc_sel_nxt;\n  wire    [ 24: 0] F_pcb;\n  wire    [ 24: 0] F_pcb_nxt;\n  wire    [ 24: 0] F_pcb_plus_four;\n  wire             F_valid;\n  wire    [ 55: 0] F_vinst;\n  reg     [  1: 0] R_compare_op;\n  reg              R_ctrl_alu_force_xor;\n  wire             R_ctrl_alu_force_xor_nxt;\n  reg              R_ctrl_alu_signed_comparison;\n  wire             R_ctrl_alu_signed_comparison_nxt;\n  reg              R_ctrl_alu_subtract;\n  wire             R_ctrl_alu_subtract_nxt;\n  reg              R_ctrl_b_is_dst;\n  wire             R_ctrl_b_is_dst_nxt;\n  reg              R_ctrl_br;\n  reg              R_ctrl_br_cmp;\n  wire             R_ctrl_br_cmp_nxt;\n  wire             R_ctrl_br_nxt;\n  reg              R_ctrl_br_uncond;\n  wire             R_ctrl_br_uncond_nxt;\n  reg              R_ctrl_break;\n  wire             R_ctrl_break_nxt;\n  reg              R_ctrl_crst;\n  wire             R_ctrl_crst_nxt;\n  reg              R_ctrl_custom;\n  reg              R_ctrl_custom_multi;\n  wire             R_ctrl_custom_multi_nxt;\n  wire             R_ctrl_custom_nxt;\n  reg              R_ctrl_exception;\n  wire             R_ctrl_exception_nxt;\n  reg              R_ctrl_force_src2_zero;\n  wire             R_ctrl_force_src2_zero_nxt;\n  reg              R_ctrl_hi_imm16;\n  wire             R_ctrl_hi_imm16_nxt;\n  reg              R_ctrl_ignore_dst;\n  wire             R_ctrl_ignore_dst_nxt;\n  reg              R_ctrl_implicit_dst_eretaddr;\n  wire             R_ctrl_implicit_dst_eretaddr_nxt;\n  reg              R_ctrl_implicit_dst_retaddr;\n  wire             R_ctrl_implicit_dst_retaddr_nxt;\n  reg              R_ctrl_jmp_direct;\n  wire             R_ctrl_jmp_direct_nxt;\n  reg              R_ctrl_jmp_indirect;\n  wire             R_ctrl_jmp_indirect_nxt;\n  reg              R_ctrl_ld;\n  reg              R_ctrl_ld_io;\n  wire             R_ctrl_ld_io_nxt;\n  reg              R_ctrl_ld_non_io;\n  wire             R_ctrl_ld_non_io_nxt;\n  wire             R_ctrl_ld_nxt;\n  reg              R_ctrl_ld_signed;\n  wire             R_ctrl_ld_signed_nxt;\n  reg              R_ctrl_logic;\n  wire             R_ctrl_logic_nxt;\n  reg              R_ctrl_rdctl_inst;\n  wire             R_ctrl_rdctl_inst_nxt;\n  reg              R_ctrl_retaddr;\n  wire             R_ctrl_retaddr_nxt;\n  reg              R_ctrl_rot_right;\n  wire             R_ctrl_rot_right_nxt;\n  reg              R_ctrl_shift_logical;\n  wire             R_ctrl_shift_logical_nxt;\n  reg              R_ctrl_shift_right_arith;\n  wire             R_ctrl_shift_right_arith_nxt;\n  reg              R_ctrl_shift_rot;\n  wire             R_ctrl_shift_rot_nxt;\n  reg              R_ctrl_shift_rot_right;\n  wire             R_ctrl_shift_rot_right_nxt;\n  reg              R_ctrl_src2_choose_imm;\n  wire             R_ctrl_src2_choose_imm_nxt;\n  reg              R_ctrl_st;\n  wire             R_ctrl_st_nxt;\n  reg              R_ctrl_uncond_cti_non_br;\n  wire             R_ctrl_uncond_cti_non_br_nxt;\n  reg              R_ctrl_unsigned_lo_imm16;\n  wire             R_ctrl_unsigned_lo_imm16_nxt;\n  reg              R_ctrl_wrctl_inst;\n  wire             R_ctrl_wrctl_inst_nxt;\n  reg     [  4: 0] R_dst_regnum ;\n  wire             R_en;\n  reg     [  1: 0] R_logic_op;\n  wire    [ 31: 0] R_rf_a;\n  wire    [ 31: 0] R_rf_b;\n  wire    [ 31: 0] R_src1;\n  wire    [ 31: 0] R_src2;\n  wire    [ 15: 0] R_src2_hi;\n  wire    [ 15: 0] R_src2_lo;\n  reg              R_src2_use_imm;\n  wire    [  7: 0] R_stb_data;\n  wire    [ 15: 0] R_sth_data;\n  reg              R_valid;\n  wire    [ 55: 0] R_vinst;\n  reg              R_wr_dst_reg;\n  reg     [ 31: 0] W_alu_result;\n  wire             W_br_taken;\n  reg              W_bstatus_reg;\n  wire             W_bstatus_reg_inst_nxt;\n  wire             W_bstatus_reg_nxt;\n  reg              W_cmp_result;\n  reg     [ 31: 0] W_control_rd_data;\n  wire    [ 31: 0] W_cpuid_reg;\n  reg              W_estatus_reg;\n  wire             W_estatus_reg_inst_nxt;\n  wire             W_estatus_reg_nxt;\n  reg     [ 31: 0] W_ienable_reg;\n  wire    [ 31: 0] W_ienable_reg_nxt;\n  reg     [ 31: 0] W_ipending_reg;\n  wire    [ 31: 0] W_ipending_reg_nxt;\n  wire    [ 24: 0] W_mem_baddr;\n  wire    [ 31: 0] W_rf_wr_data;\n  wire             W_rf_wren;\n  wire             W_status_reg;\n  reg              W_status_reg_pie;\n  wire             W_status_reg_pie_inst_nxt;\n  wire             W_status_reg_pie_nxt;\n  reg              W_valid ;\n  wire    [ 55: 0] W_vinst;\n  wire    [ 31: 0] W_wr_data;\n  wire    [ 31: 0] W_wr_data_non_zero;\n  wire             av_fill_bit;\n  reg     [  1: 0] av_ld_align_cycle;\n  wire    [  1: 0] av_ld_align_cycle_nxt;\n  wire             av_ld_align_one_more_cycle;\n  reg              av_ld_aligning_data;\n  wire             av_ld_aligning_data_nxt;\n  reg     [  7: 0] av_ld_byte0_data;\n  wire    [  7: 0] av_ld_byte0_data_nxt;\n  reg     [  7: 0] av_ld_byte1_data;\n  wire             av_ld_byte1_data_en;\n  wire    [  7: 0] av_ld_byte1_data_nxt;\n  reg     [  7: 0] av_ld_byte2_data;\n  wire    [  7: 0] av_ld_byte2_data_nxt;\n  reg     [  7: 0] av_ld_byte3_data;\n  wire    [  7: 0] av_ld_byte3_data_nxt;\n  wire    [ 31: 0] av_ld_data_aligned_filtered;\n  wire    [ 31: 0] av_ld_data_aligned_unfiltered;\n  wire             av_ld_done;\n  wire             av_ld_extend;\n  wire             av_ld_getting_data;\n  wire             av_ld_rshift8;\n  reg              av_ld_waiting_for_data;\n  wire             av_ld_waiting_for_data_nxt;\n  wire             av_sign_bit;\n  wire    [ 24: 0] d_address;\n  reg     [  3: 0] d_byteenable;\n  reg              d_read;\n  wire             d_read_nxt;\n  reg              d_write;\n  wire             d_write_nxt;\n  reg     [ 31: 0] d_writedata;\n  reg              hbreak_enabled;\n  reg              hbreak_pending;\n  wire             hbreak_pending_nxt;\n  wire             hbreak_req;\n  wire    [ 24: 0] i_address;\n  reg              i_read;\n  wire             i_read_nxt;\n  wire    [ 31: 0] iactive;\n  wire             intr_req;\n  wire             jtag_debug_module_clk;\n  wire             jtag_debug_module_debugaccess_to_roms;\n  wire    [ 31: 0] jtag_debug_module_readdata;\n  wire             jtag_debug_module_reset;\n  wire             jtag_debug_module_resetrequest;\n  wire             jtag_debug_module_waitrequest;\n  wire             no_ci_readra;\n  wire             oci_hbreak_req;\n  wire    [ 31: 0] oci_ienable;\n  wire             oci_single_step_mode;\n  wire             oci_tb_hbreak_req;\n  wire             test_ending;\n  wire             test_has_ended;\n  reg              wait_for_one_post_bret_inst;\n  \n  CPU_cpu_test_bench the_CPU_cpu_test_bench\n    (\n      .D_iw                          (D_iw),\n      .D_iw_op                       (D_iw_op),\n      .D_iw_opx                      (D_iw_opx),\n      .D_valid                       (D_valid),\n      .E_valid                       (E_valid),\n      .F_pcb                         (F_pcb),\n      .F_valid                       (F_valid),\n      .R_ctrl_ld                     (R_ctrl_ld),\n      .R_ctrl_ld_non_io              (R_ctrl_ld_non_io),\n      .R_dst_regnum                  (R_dst_regnum),\n      .R_wr_dst_reg                  (R_wr_dst_reg),\n      .W_valid                       (W_valid),\n      .W_vinst                       (W_vinst),\n      .W_wr_data                     (W_wr_data),\n      .av_ld_data_aligned_filtered   (av_ld_data_aligned_filtered),\n      .av_ld_data_aligned_unfiltered (av_ld_data_aligned_unfiltered),\n      .clk                           (clk),\n      .d_address                     (d_address),\n      .d_byteenable                  (d_byteenable),\n      .d_read                        (d_read),\n      .d_write                       (d_write),\n      .i_address                     (i_address),\n      .i_read                        (i_read),\n      .i_readdata                    (i_readdata),\n      .i_waitrequest                 (i_waitrequest),\n      .reset_n                       (reset_n),\n      .test_has_ended                (test_has_ended)\n    );\n\n  assign F_av_iw_a = F_av_iw[31 : 27];\n  assign F_av_iw_b = F_av_iw[26 : 22];\n  assign F_av_iw_c = F_av_iw[21 : 17];\n  assign F_av_iw_custom_n = F_av_iw[13 : 6];\n  assign F_av_iw_custom_readra = F_av_iw[16];\n  assign F_av_iw_custom_readrb = F_av_iw[15];\n  assign F_av_iw_custom_writerc = F_av_iw[14];\n  assign F_av_iw_opx = F_av_iw[16 : 11];\n  assign F_av_iw_op = F_av_iw[5 : 0];\n  assign F_av_iw_shift_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_trap_break_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_imm16 = F_av_iw[21 : 6];\n  assign F_av_iw_imm26 = F_av_iw[31 : 6];\n  assign F_av_iw_memsz = F_av_iw[4 : 3];\n  assign F_av_iw_control_regnum = F_av_iw[8 : 6];\n  assign F_av_mem8 = F_av_iw_memsz == 2'b00;\n  assign F_av_mem16 = F_av_iw_memsz == 2'b01;\n  assign F_av_mem32 = F_av_iw_memsz[1] == 1'b1;\n  assign F_iw_a = F_iw[31 : 27];\n  assign F_iw_b = F_iw[26 : 22];\n  assign F_iw_c = F_iw[21 : 17];\n  assign F_iw_custom_n = F_iw[13 : 6];\n  assign F_iw_custom_readra = F_iw[16];\n  assign F_iw_custom_readrb = F_iw[15];\n  assign F_iw_custom_writerc = F_iw[14];\n  assign F_iw_opx = F_iw[16 : 11];\n  assign F_iw_op = F_iw[5 : 0];\n  assign F_iw_shift_imm5 = F_iw[10 : 6];\n  assign F_iw_trap_break_imm5 = F_iw[10 : 6];\n  assign F_iw_imm5 = F_iw[10 : 6];\n  assign F_iw_imm16 = F_iw[21 : 6];\n  assign F_iw_imm26 = F_iw[31 : 6];\n  assign F_iw_memsz = F_iw[4 : 3];\n  assign F_iw_control_regnum = F_iw[8 : 6];\n  assign F_mem8 = F_iw_memsz == 2'b00;\n  assign F_mem16 = F_iw_memsz == 2'b01;\n  assign F_mem32 = F_iw_memsz[1] == 1'b1;\n  assign D_iw_a = D_iw[31 : 27];\n  assign D_iw_b = D_iw[26 : 22];\n  assign D_iw_c = D_iw[21 : 17];\n  assign D_iw_custom_n = D_iw[13 : 6];\n  assign D_iw_custom_readra = D_iw[16];\n  assign D_iw_custom_readrb = D_iw[15];\n  assign D_iw_custom_writerc = D_iw[14];\n  assign D_iw_opx = D_iw[16 : 11];\n  assign D_iw_op = D_iw[5 : 0];\n  assign D_iw_shift_imm5 = D_iw[10 : 6];\n  assign D_iw_trap_break_imm5 = D_iw[10 : 6];\n  assign D_iw_imm5 = D_iw[10 : 6];\n  assign D_iw_imm16 = D_iw[21 : 6];\n  assign D_iw_imm26 = D_iw[31 : 6];\n  assign D_iw_memsz = D_iw[4 : 3];\n  assign D_iw_control_regnum = D_iw[8 : 6];\n  assign D_mem8 = D_iw_memsz == 2'b00;\n  assign D_mem16 = D_iw_memsz == 2'b01;\n  assign D_mem32 = D_iw_memsz[1] == 1'b1;\n  assign F_op_call = F_iw_op == 0;\n  assign F_op_jmpi = F_iw_op == 1;\n  assign F_op_ldbu = F_iw_op == 3;\n  assign F_op_addi = F_iw_op == 4;\n  assign F_op_stb = F_iw_op == 5;\n  assign F_op_br = F_iw_op == 6;\n  assign F_op_ldb = F_iw_op == 7;\n  assign F_op_cmpgei = F_iw_op == 8;\n  assign F_op_ldhu = F_iw_op == 11;\n  assign F_op_andi = F_iw_op == 12;\n  assign F_op_sth = F_iw_op == 13;\n  assign F_op_bge = F_iw_op == 14;\n  assign F_op_ldh = F_iw_op == 15;\n  assign F_op_cmplti = F_iw_op == 16;\n  assign F_op_initda = F_iw_op == 19;\n  assign F_op_ori = F_iw_op == 20;\n  assign F_op_stw = F_iw_op == 21;\n  assign F_op_blt = F_iw_op == 22;\n  assign F_op_ldw = F_iw_op == 23;\n  assign F_op_cmpnei = F_iw_op == 24;\n  assign F_op_flushda = F_iw_op == 27;\n  assign F_op_xori = F_iw_op == 28;\n  assign F_op_stc = F_iw_op == 29;\n  assign F_op_bne = F_iw_op == 30;\n  assign F_op_ldl = F_iw_op == 31;\n  assign F_op_cmpeqi = F_iw_op == 32;\n  assign F_op_ldbuio = F_iw_op == 35;\n  assign F_op_muli = F_iw_op == 36;\n  assign F_op_stbio = F_iw_op == 37;\n  assign F_op_beq = F_iw_op == 38;\n  assign F_op_ldbio = F_iw_op == 39;\n  assign F_op_cmpgeui = F_iw_op == 40;\n  assign F_op_ldhuio = F_iw_op == 43;\n  assign F_op_andhi = F_iw_op == 44;\n  assign F_op_sthio = F_iw_op == 45;\n  assign F_op_bgeu = F_iw_op == 46;\n  assign F_op_ldhio = F_iw_op == 47;\n  assign F_op_cmpltui = F_iw_op == 48;\n  assign F_op_initd = F_iw_op == 51;\n  assign F_op_orhi = F_iw_op == 52;\n  assign F_op_stwio = F_iw_op == 53;\n  assign F_op_bltu = F_iw_op == 54;\n  assign F_op_ldwio = F_iw_op == 55;\n  assign F_op_rdprs = F_iw_op == 56;\n  assign F_op_flushd = F_iw_op == 59;\n  assign F_op_xorhi = F_iw_op == 60;\n  assign F_op_rsv02 = F_iw_op == 2;\n  assign F_op_rsv09 = F_iw_op == 9;\n  assign F_op_rsv10 = F_iw_op == 10;\n  assign F_op_rsv17 = F_iw_op == 17;\n  assign F_op_rsv18 = F_iw_op == 18;\n  assign F_op_rsv25 = F_iw_op == 25;\n  assign F_op_rsv26 = F_iw_op == 26;\n  assign F_op_rsv33 = F_iw_op == 33;\n  assign F_op_rsv34 = F_iw_op == 34;\n  assign F_op_rsv41 = F_iw_op == 41;\n  assign F_op_rsv42 = F_iw_op == 42;\n  assign F_op_rsv49 = F_iw_op == 49;\n  assign F_op_rsv57 = F_iw_op == 57;\n  assign F_op_rsv61 = F_iw_op == 61;\n  assign F_op_rsv62 = F_iw_op == 62;\n  assign F_op_rsv63 = F_iw_op == 63;\n  assign F_op_eret = F_op_opx & (F_iw_opx == 1);\n  assign F_op_roli = F_op_opx & (F_iw_opx == 2);\n  assign F_op_rol = F_op_opx & (F_iw_opx == 3);\n  assign F_op_flushp = F_op_opx & (F_iw_opx == 4);\n  assign F_op_ret = F_op_opx & (F_iw_opx == 5);\n  assign F_op_nor = F_op_opx & (F_iw_opx == 6);\n  assign F_op_mulxuu = F_op_opx & (F_iw_opx == 7);\n  assign F_op_cmpge = F_op_opx & (F_iw_opx == 8);\n  assign F_op_bret = F_op_opx & (F_iw_opx == 9);\n  assign F_op_ror = F_op_opx & (F_iw_opx == 11);\n  assign F_op_flushi = F_op_opx & (F_iw_opx == 12);\n  assign F_op_jmp = F_op_opx & (F_iw_opx == 13);\n  assign F_op_and = F_op_opx & (F_iw_opx == 14);\n  assign F_op_cmplt = F_op_opx & (F_iw_opx == 16);\n  assign F_op_slli = F_op_opx & (F_iw_opx == 18);\n  assign F_op_sll = F_op_opx & (F_iw_opx == 19);\n  assign F_op_wrprs = F_op_opx & (F_iw_opx == 20);\n  assign F_op_or = F_op_opx & (F_iw_opx == 22);\n  assign F_op_mulxsu = F_op_opx & (F_iw_opx == 23);\n  assign F_op_cmpne = F_op_opx & (F_iw_opx == 24);\n  assign F_op_srli = F_op_opx & (F_iw_opx == 26);\n  assign F_op_srl = F_op_opx & (F_iw_opx == 27);\n  assign F_op_nextpc = F_op_opx & (F_iw_opx == 28);\n  assign F_op_callr = F_op_opx & (F_iw_opx == 29);\n  assign F_op_xor = F_op_opx & (F_iw_opx == 30);\n  assign F_op_mulxss = F_op_opx & (F_iw_opx == 31);\n  assign F_op_cmpeq = F_op_opx & (F_iw_opx == 32);\n  assign F_op_divu = F_op_opx & (F_iw_opx == 36);\n  assign F_op_div = F_op_opx & (F_iw_opx == 37);\n  assign F_op_rdctl = F_op_opx & (F_iw_opx == 38);\n  assign F_op_mul = F_op_opx & (F_iw_opx == 39);\n  assign F_op_cmpgeu = F_op_opx & (F_iw_opx == 40);\n  assign F_op_initi = F_op_opx & (F_iw_opx == 41);\n  assign F_op_trap = F_op_opx & (F_iw_opx == 45);\n  assign F_op_wrctl = F_op_opx & (F_iw_opx == 46);\n  assign F_op_cmpltu = F_op_opx & (F_iw_opx == 48);\n  assign F_op_add = F_op_opx & (F_iw_opx == 49);\n  assign F_op_break = F_op_opx & (F_iw_opx == 52);\n  assign F_op_hbreak = F_op_opx & (F_iw_opx == 53);\n  assign F_op_sync = F_op_opx & (F_iw_opx == 54);\n  assign F_op_sub = F_op_opx & (F_iw_opx == 57);\n  assign F_op_srai = F_op_opx & (F_iw_opx == 58);\n  assign F_op_sra = F_op_opx & (F_iw_opx == 59);\n  assign F_op_intr = F_op_opx & (F_iw_opx == 61);\n  assign F_op_crst = F_op_opx & (F_iw_opx == 62);\n  assign F_op_rsvx00 = F_op_opx & (F_iw_opx == 0);\n  assign F_op_rsvx10 = F_op_opx & (F_iw_opx == 10);\n  assign F_op_rsvx15 = F_op_opx & (F_iw_opx == 15);\n  assign F_op_rsvx17 = F_op_opx & (F_iw_opx == 17);\n  assign F_op_rsvx21 = F_op_opx & (F_iw_opx == 21);\n  assign F_op_rsvx25 = F_op_opx & (F_iw_opx == 25);\n  assign F_op_rsvx33 = F_op_opx & (F_iw_opx == 33);\n  assign F_op_rsvx34 = F_op_opx & (F_iw_opx == 34);\n  assign F_op_rsvx35 = F_op_opx & (F_iw_opx == 35);\n  assign F_op_rsvx42 = F_op_opx & (F_iw_opx == 42);\n  assign F_op_rsvx43 = F_op_opx & (F_iw_opx == 43);\n  assign F_op_rsvx44 = F_op_opx & (F_iw_opx == 44);\n  assign F_op_rsvx47 = F_op_opx & (F_iw_opx == 47);\n  assign F_op_rsvx50 = F_op_opx & (F_iw_opx == 50);\n  assign F_op_rsvx51 = F_op_opx & (F_iw_opx == 51);\n  assign F_op_rsvx55 = F_op_opx & (F_iw_opx == 55);\n  assign F_op_rsvx56 = F_op_opx & (F_iw_opx == 56);\n  assign F_op_rsvx60 = F_op_opx & (F_iw_opx == 60);\n  assign F_op_rsvx63 = F_op_opx & (F_iw_opx == 63);\n  assign F_op_opx = F_iw_op == 58;\n  assign F_op_custom = F_iw_op == 50;\n  assign D_op_call = D_iw_op == 0;\n  assign D_op_jmpi = D_iw_op == 1;\n  assign D_op_ldbu = D_iw_op == 3;\n  assign D_op_addi = D_iw_op == 4;\n  assign D_op_stb = D_iw_op == 5;\n  assign D_op_br = D_iw_op == 6;\n  assign D_op_ldb = D_iw_op == 7;\n  assign D_op_cmpgei = D_iw_op == 8;\n  assign D_op_ldhu = D_iw_op == 11;\n  assign D_op_andi = D_iw_op == 12;\n  assign D_op_sth = D_iw_op == 13;\n  assign D_op_bge = D_iw_op == 14;\n  assign D_op_ldh = D_iw_op == 15;\n  assign D_op_cmplti = D_iw_op == 16;\n  assign D_op_initda = D_iw_op == 19;\n  assign D_op_ori = D_iw_op == 20;\n  assign D_op_stw = D_iw_op == 21;\n  assign D_op_blt = D_iw_op == 22;\n  assign D_op_ldw = D_iw_op == 23;\n  assign D_op_cmpnei = D_iw_op == 24;\n  assign D_op_flushda = D_iw_op == 27;\n  assign D_op_xori = D_iw_op == 28;\n  assign D_op_stc = D_iw_op == 29;\n  assign D_op_bne = D_iw_op == 30;\n  assign D_op_ldl = D_iw_op == 31;\n  assign D_op_cmpeqi = D_iw_op == 32;\n  assign D_op_ldbuio = D_iw_op == 35;\n  assign D_op_muli = D_iw_op == 36;\n  assign D_op_stbio = D_iw_op == 37;\n  assign D_op_beq = D_iw_op == 38;\n  assign D_op_ldbio = D_iw_op == 39;\n  assign D_op_cmpgeui = D_iw_op == 40;\n  assign D_op_ldhuio = D_iw_op == 43;\n  assign D_op_andhi = D_iw_op == 44;\n  assign D_op_sthio = D_iw_op == 45;\n  assign D_op_bgeu = D_iw_op == 46;\n  assign D_op_ldhio = D_iw_op == 47;\n  assign D_op_cmpltui = D_iw_op == 48;\n  assign D_op_initd = D_iw_op == 51;\n  assign D_op_orhi = D_iw_op == 52;\n  assign D_op_stwio = D_iw_op == 53;\n  assign D_op_bltu = D_iw_op == 54;\n  assign D_op_ldwio = D_iw_op == 55;\n  assign D_op_rdprs = D_iw_op == 56;\n  assign D_op_flushd = D_iw_op == 59;\n  assign D_op_xorhi = D_iw_op == 60;\n  assign D_op_rsv02 = D_iw_op == 2;\n  assign D_op_rsv09 = D_iw_op == 9;\n  assign D_op_rsv10 = D_iw_op == 10;\n  assign D_op_rsv17 = D_iw_op == 17;\n  assign D_op_rsv18 = D_iw_op == 18;\n  assign D_op_rsv25 = D_iw_op == 25;\n  assign D_op_rsv26 = D_iw_op == 26;\n  assign D_op_rsv33 = D_iw_op == 33;\n  assign D_op_rsv34 = D_iw_op == 34;\n  assign D_op_rsv41 = D_iw_op == 41;\n  assign D_op_rsv42 = D_iw_op == 42;\n  assign D_op_rsv49 = D_iw_op == 49;\n  assign D_op_rsv57 = D_iw_op == 57;\n  assign D_op_rsv61 = D_iw_op == 61;\n  assign D_op_rsv62 = D_iw_op == 62;\n  assign D_op_rsv63 = D_iw_op == 63;\n  assign D_op_eret = D_op_opx & (D_iw_opx == 1);\n  assign D_op_roli = D_op_opx & (D_iw_opx == 2);\n  assign D_op_rol = D_op_opx & (D_iw_opx == 3);\n  assign D_op_flushp = D_op_opx & (D_iw_opx == 4);\n  assign D_op_ret = D_op_opx & (D_iw_opx == 5);\n  assign D_op_nor = D_op_opx & (D_iw_opx == 6);\n  assign D_op_mulxuu = D_op_opx & (D_iw_opx == 7);\n  assign D_op_cmpge = D_op_opx & (D_iw_opx == 8);\n  assign D_op_bret = D_op_opx & (D_iw_opx == 9);\n  assign D_op_ror = D_op_opx & (D_iw_opx == 11);\n  assign D_op_flushi = D_op_opx & (D_iw_opx == 12);\n  assign D_op_jmp = D_op_opx & (D_iw_opx == 13);\n  assign D_op_and = D_op_opx & (D_iw_opx == 14);\n  assign D_op_cmplt = D_op_opx & (D_iw_opx == 16);\n  assign D_op_slli = D_op_opx & (D_iw_opx == 18);\n  assign D_op_sll = D_op_opx & (D_iw_opx == 19);\n  assign D_op_wrprs = D_op_opx & (D_iw_opx == 20);\n  assign D_op_or = D_op_opx & (D_iw_opx == 22);\n  assign D_op_mulxsu = D_op_opx & (D_iw_opx == 23);\n  assign D_op_cmpne = D_op_opx & (D_iw_opx == 24);\n  assign D_op_srli = D_op_opx & (D_iw_opx == 26);\n  assign D_op_srl = D_op_opx & (D_iw_opx == 27);\n  assign D_op_nextpc = D_op_opx & (D_iw_opx == 28);\n  assign D_op_callr = D_op_opx & (D_iw_opx == 29);\n  assign D_op_xor = D_op_opx & (D_iw_opx == 30);\n  assign D_op_mulxss = D_op_opx & (D_iw_opx == 31);\n  assign D_op_cmpeq = D_op_opx & (D_iw_opx == 32);\n  assign D_op_divu = D_op_opx & (D_iw_opx == 36);\n  assign D_op_div = D_op_opx & (D_iw_opx == 37);\n  assign D_op_rdctl = D_op_opx & (D_iw_opx == 38);\n  assign D_op_mul = D_op_opx & (D_iw_opx == 39);\n  assign D_op_cmpgeu = D_op_opx & (D_iw_opx == 40);\n  assign D_op_initi = D_op_opx & (D_iw_opx == 41);\n  assign D_op_trap = D_op_opx & (D_iw_opx == 45);\n  assign D_op_wrctl = D_op_opx & (D_iw_opx == 46);\n  assign D_op_cmpltu = D_op_opx & (D_iw_opx == 48);\n  assign D_op_add = D_op_opx & (D_iw_opx == 49);\n  assign D_op_break = D_op_opx & (D_iw_opx == 52);\n  assign D_op_hbreak = D_op_opx & (D_iw_opx == 53);\n  assign D_op_sync = D_op_opx & (D_iw_opx == 54);\n  assign D_op_sub = D_op_opx & (D_iw_opx == 57);\n  assign D_op_srai = D_op_opx & (D_iw_opx == 58);\n  assign D_op_sra = D_op_opx & (D_iw_opx == 59);\n  assign D_op_intr = D_op_opx & (D_iw_opx == 61);\n  assign D_op_crst = D_op_opx & (D_iw_opx == 62);\n  assign D_op_rsvx00 = D_op_opx & (D_iw_opx == 0);\n  assign D_op_rsvx10 = D_op_opx & (D_iw_opx == 10);\n  assign D_op_rsvx15 = D_op_opx & (D_iw_opx == 15);\n  assign D_op_rsvx17 = D_op_opx & (D_iw_opx == 17);\n  assign D_op_rsvx21 = D_op_opx & (D_iw_opx == 21);\n  assign D_op_rsvx25 = D_op_opx & (D_iw_opx == 25);\n  assign D_op_rsvx33 = D_op_opx & (D_iw_opx == 33);\n  assign D_op_rsvx34 = D_op_opx & (D_iw_opx == 34);\n  assign D_op_rsvx35 = D_op_opx & (D_iw_opx == 35);\n  assign D_op_rsvx42 = D_op_opx & (D_iw_opx == 42);\n  assign D_op_rsvx43 = D_op_opx & (D_iw_opx == 43);\n  assign D_op_rsvx44 = D_op_opx & (D_iw_opx == 44);\n  assign D_op_rsvx47 = D_op_opx & (D_iw_opx == 47);\n  assign D_op_rsvx50 = D_op_opx & (D_iw_opx == 50);\n  assign D_op_rsvx51 = D_op_opx & (D_iw_opx == 51);\n  assign D_op_rsvx55 = D_op_opx & (D_iw_opx == 55);\n  assign D_op_rsvx56 = D_op_opx & (D_iw_opx == 56);\n  assign D_op_rsvx60 = D_op_opx & (D_iw_opx == 60);\n  assign D_op_rsvx63 = D_op_opx & (D_iw_opx == 63);\n  assign D_op_opx = D_iw_op == 58;\n  assign D_op_custom = D_iw_op == 50;\n  assign R_en = 1'b1;\n  assign E_ci_result = 0;\n  \n  assign no_ci_readra = 1'b0;\n  assign E_ci_multi_stall = 1'b0;\n  assign iactive = d_irq[31 : 0] & 32'b00000000000000000000000000000001;\n  assign F_pc_sel_nxt = R_ctrl_exception                          ? 2'b00 :\n    R_ctrl_break                              ? 2'b01 :\n    (W_br_taken | R_ctrl_uncond_cti_non_br)   ? 2'b10 :\n    2'b11;\n\n  assign F_pc_no_crst_nxt = (F_pc_sel_nxt == 2'b00)? 2097160 :\n    (F_pc_sel_nxt == 2'b01)? 4196872 :\n    (F_pc_sel_nxt == 2'b10)? E_arith_result[24 : 2] :\n    F_pc_plus_one;\n\n  assign F_pc_nxt = F_pc_no_crst_nxt;\n  assign F_pcb_nxt = {F_pc_nxt, 2'b00};\n  assign F_pc_en = W_valid;\n  assign F_pc_plus_one = F_pc + 1;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          F_pc <= 2097152;\n      else if (F_pc_en)\n          F_pc <= F_pc_nxt;\n    end\n\n\n  assign F_pcb = {F_pc, 2'b00};\n  assign F_pcb_plus_four = {F_pc_plus_one, 2'b00};\n  assign F_valid = i_read & ~i_waitrequest;\n  assign i_read_nxt = W_valid | (i_read & i_waitrequest);\n  assign i_address = {F_pc, 2'b00};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          i_read <= 1'b1;\n      else \n        i_read <= i_read_nxt;\n    end\n\n\n  assign oci_tb_hbreak_req = oci_hbreak_req;\n  assign hbreak_req = (oci_tb_hbreak_req | hbreak_pending) & hbreak_enabled &  ~(wait_for_one_post_bret_inst & ~W_valid);\n  assign hbreak_pending_nxt = hbreak_pending ? hbreak_enabled \n    : hbreak_req;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          wait_for_one_post_bret_inst <= 1'b0;\n      else \n        wait_for_one_post_bret_inst <= (~hbreak_enabled & oci_single_step_mode) ? 1'b1  : (F_valid | ~oci_single_step_mode) ? 1'b0  : wait_for_one_post_bret_inst;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          hbreak_pending <= 1'b0;\n      else \n        hbreak_pending <= hbreak_pending_nxt;\n    end\n\n\n  assign intr_req = W_status_reg_pie & (W_ipending_reg != 0);\n  assign F_av_iw = i_readdata;\n  assign F_iw = hbreak_req     ? 4040762 :\n    1'b0   ? 127034 :\n    intr_req       ? 3926074 : \n    F_av_iw;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          D_iw <= 0;\n      else if (F_valid)\n          D_iw <= F_iw;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          D_valid <= 0;\n      else \n        D_valid <= F_valid;\n    end\n\n\n  assign D_dst_regnum = D_ctrl_implicit_dst_retaddr    ? 5'd31 : \n    D_ctrl_implicit_dst_eretaddr   ? 5'd29 : \n    D_ctrl_b_is_dst                ? D_iw_b :\n    D_iw_c;\n\n  assign D_wr_dst_reg = (D_dst_regnum != 0) & ~D_ctrl_ignore_dst;\n  assign D_logic_op_raw = D_op_opx ? D_iw_opx[4 : 3] : \n    D_iw_op[4 : 3];\n\n  assign D_logic_op = D_ctrl_alu_force_xor ? 2'b11 : D_logic_op_raw;\n  assign D_compare_op = D_op_opx ? D_iw_opx[4 : 3] : \n    D_iw_op[4 : 3];\n\n  assign D_jmp_direct_target_waddr = D_iw[31 : 6];\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_valid <= 0;\n      else \n        R_valid <= D_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_wr_dst_reg <= 0;\n      else \n        R_wr_dst_reg <= D_wr_dst_reg;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_dst_regnum <= 0;\n      else \n        R_dst_regnum <= D_dst_regnum;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_logic_op <= 0;\n      else \n        R_logic_op <= D_logic_op;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_compare_op <= 0;\n      else \n        R_compare_op <= D_compare_op;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_src2_use_imm <= 0;\n      else \n        R_src2_use_imm <= D_ctrl_src2_choose_imm | (D_ctrl_br & R_valid);\n    end\n\n\n  assign W_rf_wren = (R_wr_dst_reg & W_valid) | ~reset_n;\n  assign W_rf_wr_data = R_ctrl_ld ? av_ld_data_aligned_filtered : W_wr_data;\n\nCPU_cpu_register_bank_a_module CPU_cpu_register_bank_a\n  (\n    .clock     (clk),\n    .data      (W_rf_wr_data),\n    .q         (R_rf_a),\n    .rdaddress (D_iw_a),\n    .wraddress (R_dst_regnum),\n    .wren      (W_rf_wren)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_register_bank_a.lpm_file = \"CPU_cpu_rf_ram_a.dat\";\n`else\ndefparam CPU_cpu_register_bank_a.lpm_file = \"CPU_cpu_rf_ram_a.hex\";\n`endif\n\n\n\n\n\nCPU_cpu_register_bank_b_module CPU_cpu_register_bank_b\n  (\n    .clock     (clk),\n    .data      (W_rf_wr_data),\n    .q         (R_rf_b),\n    .rdaddress (D_iw_b),\n    .wraddress (R_dst_regnum),\n    .wren      (W_rf_wren)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_register_bank_b.lpm_file = \"CPU_cpu_rf_ram_b.dat\";\n`else\ndefparam CPU_cpu_register_bank_b.lpm_file = \"CPU_cpu_rf_ram_b.hex\";\n`endif\n\n\n\n\n  assign R_src1 = (((R_ctrl_br & E_valid) | (R_ctrl_retaddr & R_valid)))? {F_pc_plus_one, 2'b00} :\n    ((R_ctrl_jmp_direct & E_valid))? {D_jmp_direct_target_waddr, 2'b00} :\n    R_rf_a;\n\n  assign R_src2_lo = ((R_ctrl_force_src2_zero|R_ctrl_hi_imm16))? 16'b0 :\n    (R_src2_use_imm)? D_iw_imm16 :\n    R_rf_b[15 : 0];\n\n  assign R_src2_hi = ((R_ctrl_force_src2_zero|R_ctrl_unsigned_lo_imm16))? 16'b0 :\n    (R_ctrl_hi_imm16)? D_iw_imm16 :\n    (R_src2_use_imm)? {16 {D_iw_imm16[15]}} :\n    R_rf_b[31 : 16];\n\n  assign R_src2 = {R_src2_hi, R_src2_lo};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_valid <= 0;\n      else \n        E_valid <= R_valid | E_stall;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_new_inst <= 0;\n      else \n        E_new_inst <= R_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_src1 <= 0;\n      else \n        E_src1 <= R_src1;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_src2 <= 0;\n      else \n        E_src2 <= R_src2;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_invert_arith_src_msb <= 0;\n      else \n        E_invert_arith_src_msb <= D_ctrl_alu_signed_comparison & R_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_alu_sub <= 0;\n      else \n        E_alu_sub <= D_ctrl_alu_subtract & R_valid;\n    end\n\n\n  assign E_stall = E_shift_rot_stall | E_ld_stall | E_st_stall | E_ci_multi_stall;\n  assign E_arith_src1 = { E_src1[31] ^ E_invert_arith_src_msb, \n    E_src1[30 : 0]};\n\n  assign E_arith_src2 = { E_src2[31] ^ E_invert_arith_src_msb, \n    E_src2[30 : 0]};\n\n  assign E_arith_result = E_alu_sub ?\n    E_arith_src1 - E_arith_src2 :\n    E_arith_src1 + E_arith_src2;\n\n  assign E_mem_baddr = E_arith_result[24 : 0];\n  assign E_logic_result = (R_logic_op == 2'b00)? (~(E_src1 | E_src2)) :\n    (R_logic_op == 2'b01)? (E_src1 & E_src2) :\n    (R_logic_op == 2'b10)? (E_src1 | E_src2) :\n    (E_src1 ^ E_src2);\n\n  assign E_logic_result_is_0 = E_logic_result == 0;\n  assign E_eq = E_logic_result_is_0;\n  assign E_lt = E_arith_result[32];\n  assign E_cmp_result = (R_compare_op == 2'b00)? E_eq :\n    (R_compare_op == 2'b01)? ~E_lt :\n    (R_compare_op == 2'b10)? E_lt :\n    ~E_eq;\n\n  assign E_shift_rot_cnt_nxt = E_new_inst ? E_src2[4 : 0] : E_shift_rot_cnt-1;\n  assign E_shift_rot_done = (E_shift_rot_cnt == 0) & ~E_new_inst;\n  assign E_shift_rot_stall = R_ctrl_shift_rot & E_valid & ~E_shift_rot_done;\n  assign E_shift_rot_fill_bit = R_ctrl_shift_logical ? 1'b0 :\n    (R_ctrl_rot_right ? E_shift_rot_result[0] : \n    E_shift_rot_result[31]);\n\n  assign E_shift_rot_result_nxt = (E_new_inst)? E_src1 :\n    (R_ctrl_shift_rot_right)? {E_shift_rot_fill_bit, E_shift_rot_result[31 : 1]} :\n    {E_shift_rot_result[30 : 0], E_shift_rot_fill_bit};\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_shift_rot_result <= 0;\n      else \n        E_shift_rot_result <= E_shift_rot_result_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_shift_rot_cnt <= 0;\n      else \n        E_shift_rot_cnt <= E_shift_rot_cnt_nxt;\n    end\n\n\n  assign E_control_rd_data = (D_iw_control_regnum == 3'd0)? W_status_reg :\n    (D_iw_control_regnum == 3'd1)? W_estatus_reg :\n    (D_iw_control_regnum == 3'd2)? W_bstatus_reg :\n    (D_iw_control_regnum == 3'd3)? W_ienable_reg :\n    (D_iw_control_regnum == 3'd4)? W_ipending_reg :\n    W_cpuid_reg;\n\n  assign E_alu_result = ((R_ctrl_br_cmp | R_ctrl_rdctl_inst))? 0 :\n    (R_ctrl_shift_rot)? E_shift_rot_result :\n    (R_ctrl_logic)? E_logic_result :\n    (R_ctrl_custom)? E_ci_result :\n    E_arith_result;\n\n  assign R_stb_data = R_rf_b[7 : 0];\n  assign R_sth_data = R_rf_b[15 : 0];\n  assign E_st_data = (D_mem8)? {R_stb_data, R_stb_data, R_stb_data, R_stb_data} :\n    (D_mem16)? {R_sth_data, R_sth_data} :\n    R_rf_b;\n\n  assign E_mem_byte_en = ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b00})? 4'b0001 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b01})? 4'b0010 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b10})? 4'b0100 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b11})? 4'b1000 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b00})? 4'b0011 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b01})? 4'b0011 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b10})? 4'b1100 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b11})? 4'b1100 :\n    4'b1111;\n\n  assign d_read_nxt = (R_ctrl_ld & E_new_inst) | (d_read & d_waitrequest);\n  assign E_ld_stall = R_ctrl_ld & ((E_valid & ~av_ld_done) | E_new_inst);\n  assign d_write_nxt = (R_ctrl_st & E_new_inst) | (d_write & d_waitrequest);\n  assign E_st_stall = d_write_nxt;\n  assign d_address = W_mem_baddr;\n  assign av_ld_getting_data = d_read & ~d_waitrequest;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_read <= 0;\n      else \n        d_read <= d_read_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_writedata <= 0;\n      else \n        d_writedata <= E_st_data;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_byteenable <= 0;\n      else \n        d_byteenable <= E_mem_byte_en;\n    end\n\n\n  assign av_ld_align_cycle_nxt = av_ld_getting_data ? 0 : (av_ld_align_cycle+1);\n  assign av_ld_align_one_more_cycle = av_ld_align_cycle == (D_mem16 ? 2 : 3);\n  assign av_ld_aligning_data_nxt = av_ld_aligning_data ? \n    ~av_ld_align_one_more_cycle : \n    (~D_mem32 & av_ld_getting_data);\n\n  assign av_ld_waiting_for_data_nxt = av_ld_waiting_for_data ? \n    ~av_ld_getting_data : \n    (R_ctrl_ld & E_new_inst);\n\n  assign av_ld_done = ~av_ld_waiting_for_data_nxt & (D_mem32 | ~av_ld_aligning_data_nxt);\n  assign av_ld_rshift8 = av_ld_aligning_data & \n    (av_ld_align_cycle < (W_mem_baddr[1 : 0]));\n\n  assign av_ld_extend = av_ld_aligning_data;\n  assign av_ld_byte0_data_nxt = av_ld_rshift8      ? av_ld_byte1_data :\n    av_ld_extend       ? av_ld_byte0_data :\n    d_readdata[7 : 0];\n\n  assign av_ld_byte1_data_nxt = av_ld_rshift8      ? av_ld_byte2_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[15 : 8];\n\n  assign av_ld_byte2_data_nxt = av_ld_rshift8      ? av_ld_byte3_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[23 : 16];\n\n  assign av_ld_byte3_data_nxt = av_ld_rshift8      ? av_ld_byte3_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[31 : 24];\n\n  assign av_ld_byte1_data_en = ~(av_ld_extend & D_mem16 & ~av_ld_rshift8);\n  assign av_ld_data_aligned_unfiltered = {av_ld_byte3_data, av_ld_byte2_data, \n    av_ld_byte1_data, av_ld_byte0_data};\n\n  assign av_sign_bit = D_mem16 ? av_ld_byte1_data[7] : av_ld_byte0_data[7];\n  assign av_fill_bit = av_sign_bit & R_ctrl_ld_signed;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_align_cycle <= 0;\n      else \n        av_ld_align_cycle <= av_ld_align_cycle_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_waiting_for_data <= 0;\n      else \n        av_ld_waiting_for_data <= av_ld_waiting_for_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_aligning_data <= 0;\n      else \n        av_ld_aligning_data <= av_ld_aligning_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte0_data <= 0;\n      else \n        av_ld_byte0_data <= av_ld_byte0_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte1_data <= 0;\n      else if (av_ld_byte1_data_en)\n          av_ld_byte1_data <= av_ld_byte1_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte2_data <= 0;\n      else \n        av_ld_byte2_data <= av_ld_byte2_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte3_data <= 0;\n      else \n        av_ld_byte3_data <= av_ld_byte3_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_valid <= 0;\n      else \n        W_valid <= E_valid & ~E_stall;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_control_rd_data <= 0;\n      else \n        W_control_rd_data <= E_control_rd_data;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_cmp_result <= 0;\n      else \n        W_cmp_result <= E_cmp_result;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_alu_result <= 0;\n      else \n        W_alu_result <= E_alu_result;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_status_reg_pie <= 0;\n      else \n        W_status_reg_pie <= W_status_reg_pie_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_estatus_reg <= 0;\n      else \n        W_estatus_reg <= W_estatus_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_bstatus_reg <= 0;\n      else \n        W_bstatus_reg <= W_bstatus_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_ienable_reg <= 0;\n      else \n        W_ienable_reg <= W_ienable_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_ipending_reg <= 0;\n      else \n        W_ipending_reg <= W_ipending_reg_nxt;\n    end\n\n\n  assign W_cpuid_reg = 0;\n  assign W_wr_data_non_zero = R_ctrl_br_cmp ? W_cmp_result :\n    R_ctrl_rdctl_inst       ? W_control_rd_data :\n    W_alu_result[31 : 0];\n\n  assign W_wr_data = W_wr_data_non_zero;\n  assign W_br_taken = R_ctrl_br & W_cmp_result;\n  assign W_mem_baddr = W_alu_result[24 : 0];\n  assign W_status_reg = W_status_reg_pie;\n  assign E_wrctl_status = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd0);\n\n  assign E_wrctl_estatus = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd1);\n\n  assign E_wrctl_bstatus = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd2);\n\n  assign E_wrctl_ienable = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd3);\n\n  assign W_status_reg_pie_inst_nxt = (R_ctrl_exception | R_ctrl_break | R_ctrl_crst) ? 1'b0 :\n    (D_op_eret)                     ? W_estatus_reg :\n    (D_op_bret)                     ? W_bstatus_reg :\n    (E_wrctl_status)                ? E_src1[0] :\n    W_status_reg_pie;\n\n  assign W_status_reg_pie_nxt = E_valid ? W_status_reg_pie_inst_nxt : W_status_reg_pie;\n  assign W_estatus_reg_inst_nxt = (R_ctrl_crst)        ? 0 :\n    (R_ctrl_exception)   ? W_status_reg :\n    (E_wrctl_estatus)    ? E_src1[0] :\n    W_estatus_reg;\n\n  assign W_estatus_reg_nxt = E_valid ? W_estatus_reg_inst_nxt : W_estatus_reg;\n  assign W_bstatus_reg_inst_nxt = (R_ctrl_break)       ? W_status_reg :\n    (E_wrctl_bstatus)    ? E_src1[0] :\n    W_bstatus_reg;\n\n  assign W_bstatus_reg_nxt = E_valid ? W_bstatus_reg_inst_nxt : W_bstatus_reg;\n  assign W_ienable_reg_nxt = ((E_wrctl_ienable & E_valid) ? \n    E_src1[31 : 0] : W_ienable_reg) & 32'b00000000000000000000000000000001;\n\n  assign W_ipending_reg_nxt = iactive & W_ienable_reg & oci_ienable & 32'b00000000000000000000000000000001;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          hbreak_enabled <= 1'b1;\n      else if (E_valid)\n          hbreak_enabled <= R_ctrl_break ? 1'b0 : D_op_bret ? 1'b1 : hbreak_enabled;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_write <= 0;\n      else \n        d_write <= d_write_nxt;\n    end\n\n\n  CPU_cpu_nios2_oci the_CPU_cpu_nios2_oci\n    (\n      .D_valid                               (D_valid),\n      .E_st_data                             (E_st_data),\n      .E_valid                               (E_valid),\n      .F_pc                                  (F_pc),\n      .address_nxt                           (jtag_debug_module_address),\n      .av_ld_data_aligned_filtered           (av_ld_data_aligned_filtered),\n      .byteenable_nxt                        (jtag_debug_module_byteenable),\n      .clk                                   (jtag_debug_module_clk),\n      .d_address                             (d_address),\n      .d_read                                (d_read),\n      .d_waitrequest                         (d_waitrequest),\n      .d_write                               (d_write),\n      .debugaccess_nxt                       (jtag_debug_module_debugaccess),\n      .hbreak_enabled                        (hbreak_enabled),\n      .jtag_debug_module_debugaccess_to_roms (jtag_debug_module_debugaccess_to_roms),\n      .oci_hbreak_req                        (oci_hbreak_req),\n      .oci_ienable                           (oci_ienable),\n      .oci_single_step_mode                  (oci_single_step_mode),\n      .read_nxt                              (jtag_debug_module_read),\n      .readdata                              (jtag_debug_module_readdata),\n      .reset                                 (jtag_debug_module_reset),\n      .reset_n                               (reset_n),\n      .reset_req                             (reset_req),\n      .resetrequest                          (jtag_debug_module_resetrequest),\n      .test_ending                           (test_ending),\n      .test_has_ended                        (test_has_ended),\n      .waitrequest                           (jtag_debug_module_waitrequest),\n      .write_nxt                             (jtag_debug_module_write),\n      .writedata_nxt                         (jtag_debug_module_writedata)\n    );\n\n  \n  assign jtag_debug_module_clk = clk;\n  assign jtag_debug_module_reset = ~reset_n;\n  assign D_ctrl_custom = 1'b0;\n  assign R_ctrl_custom_nxt = D_ctrl_custom;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_custom <= 0;\n      else if (R_en)\n          R_ctrl_custom <= R_ctrl_custom_nxt;\n    end\n\n\n  assign D_ctrl_custom_multi = 1'b0;\n  assign R_ctrl_custom_multi_nxt = D_ctrl_custom_multi;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_custom_multi <= 0;\n      else if (R_en)\n          R_ctrl_custom_multi <= R_ctrl_custom_multi_nxt;\n    end\n\n\n  assign D_ctrl_jmp_indirect = D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_callr;\n\n  assign R_ctrl_jmp_indirect_nxt = D_ctrl_jmp_indirect;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_jmp_indirect <= 0;\n      else if (R_en)\n          R_ctrl_jmp_indirect <= R_ctrl_jmp_indirect_nxt;\n    end\n\n\n  assign D_ctrl_jmp_direct = D_op_call|D_op_jmpi;\n  assign R_ctrl_jmp_direct_nxt = D_ctrl_jmp_direct;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_jmp_direct <= 0;\n      else if (R_en)\n          R_ctrl_jmp_direct <= R_ctrl_jmp_direct_nxt;\n    end\n\n\n  assign D_ctrl_implicit_dst_retaddr = D_op_call|D_op_rsv02;\n  assign R_ctrl_implicit_dst_retaddr_nxt = D_ctrl_implicit_dst_retaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_implicit_dst_retaddr <= 0;\n      else if (R_en)\n          R_ctrl_implicit_dst_retaddr <= R_ctrl_implicit_dst_retaddr_nxt;\n    end\n\n\n  assign D_ctrl_implicit_dst_eretaddr = D_op_div|D_op_divu|D_op_mul|D_op_muli|D_op_mulxss|D_op_mulxsu|D_op_mulxuu;\n  assign R_ctrl_implicit_dst_eretaddr_nxt = D_ctrl_implicit_dst_eretaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_implicit_dst_eretaddr <= 0;\n      else if (R_en)\n          R_ctrl_implicit_dst_eretaddr <= R_ctrl_implicit_dst_eretaddr_nxt;\n    end\n\n\n  assign D_ctrl_exception = D_op_trap|\n    D_op_rsvx44|\n    D_op_div|\n    D_op_divu|\n    D_op_mul|\n    D_op_muli|\n    D_op_mulxss|\n    D_op_mulxsu|\n    D_op_mulxuu|\n    D_op_intr|\n    D_op_rsvx60;\n\n  assign R_ctrl_exception_nxt = D_ctrl_exception;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_exception <= 0;\n      else if (R_en)\n          R_ctrl_exception <= R_ctrl_exception_nxt;\n    end\n\n\n  assign D_ctrl_break = D_op_break|D_op_hbreak;\n  assign R_ctrl_break_nxt = D_ctrl_break;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_break <= 0;\n      else if (R_en)\n          R_ctrl_break <= R_ctrl_break_nxt;\n    end\n\n\n  assign D_ctrl_crst = D_op_crst|D_op_rsvx63;\n  assign R_ctrl_crst_nxt = D_ctrl_crst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_crst <= 0;\n      else if (R_en)\n          R_ctrl_crst <= R_ctrl_crst_nxt;\n    end\n\n\n  assign D_ctrl_uncond_cti_non_br = D_op_call|\n    D_op_jmpi|\n    D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_callr;\n\n  assign R_ctrl_uncond_cti_non_br_nxt = D_ctrl_uncond_cti_non_br;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_uncond_cti_non_br <= 0;\n      else if (R_en)\n          R_ctrl_uncond_cti_non_br <= R_ctrl_uncond_cti_non_br_nxt;\n    end\n\n\n  assign D_ctrl_retaddr = D_op_call|\n    D_op_rsv02|\n    D_op_nextpc|\n    D_op_callr|\n    D_op_trap|\n    D_op_rsvx44|\n    D_op_div|\n    D_op_divu|\n    D_op_mul|\n    D_op_muli|\n    D_op_mulxss|\n    D_op_mulxsu|\n    D_op_mulxuu|\n    D_op_intr|\n    D_op_rsvx60|\n    D_op_break|\n    D_op_hbreak;\n\n  assign R_ctrl_retaddr_nxt = D_ctrl_retaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_retaddr <= 0;\n      else if (R_en)\n          R_ctrl_retaddr <= R_ctrl_retaddr_nxt;\n    end\n\n\n  assign D_ctrl_shift_logical = D_op_slli|D_op_sll|D_op_srli|D_op_srl;\n  assign R_ctrl_shift_logical_nxt = D_ctrl_shift_logical;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_logical <= 0;\n      else if (R_en)\n          R_ctrl_shift_logical <= R_ctrl_shift_logical_nxt;\n    end\n\n\n  assign D_ctrl_shift_right_arith = D_op_srai|D_op_sra;\n  assign R_ctrl_shift_right_arith_nxt = D_ctrl_shift_right_arith;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_right_arith <= 0;\n      else if (R_en)\n          R_ctrl_shift_right_arith <= R_ctrl_shift_right_arith_nxt;\n    end\n\n\n  assign D_ctrl_rot_right = D_op_rsvx10|D_op_ror|D_op_rsvx42|D_op_rsvx43;\n  assign R_ctrl_rot_right_nxt = D_ctrl_rot_right;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_rot_right <= 0;\n      else if (R_en)\n          R_ctrl_rot_right <= R_ctrl_rot_right_nxt;\n    end\n\n\n  assign D_ctrl_shift_rot_right = D_op_srli|\n    D_op_srl|\n    D_op_srai|\n    D_op_sra|\n    D_op_rsvx10|\n    D_op_ror|\n    D_op_rsvx42|\n    D_op_rsvx43;\n\n  assign R_ctrl_shift_rot_right_nxt = D_ctrl_shift_rot_right;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_rot_right <= 0;\n      else if (R_en)\n          R_ctrl_shift_rot_right <= R_ctrl_shift_rot_right_nxt;\n    end\n\n\n  assign D_ctrl_shift_rot = D_op_slli|\n    D_op_rsvx50|\n    D_op_sll|\n    D_op_rsvx51|\n    D_op_roli|\n    D_op_rsvx34|\n    D_op_rol|\n    D_op_rsvx35|\n    D_op_srli|\n    D_op_srl|\n    D_op_srai|\n    D_op_sra|\n    D_op_rsvx10|\n    D_op_ror|\n    D_op_rsvx42|\n    D_op_rsvx43;\n\n  assign R_ctrl_shift_rot_nxt = D_ctrl_shift_rot;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_rot <= 0;\n      else if (R_en)\n          R_ctrl_shift_rot <= R_ctrl_shift_rot_nxt;\n    end\n\n\n  assign D_ctrl_logic = D_op_and|\n    D_op_or|\n    D_op_xor|\n    D_op_nor|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori;\n\n  assign R_ctrl_logic_nxt = D_ctrl_logic;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_logic <= 0;\n      else if (R_en)\n          R_ctrl_logic <= R_ctrl_logic_nxt;\n    end\n\n\n  assign D_ctrl_hi_imm16 = D_op_andhi|D_op_orhi|D_op_xorhi;\n  assign R_ctrl_hi_imm16_nxt = D_ctrl_hi_imm16;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_hi_imm16 <= 0;\n      else if (R_en)\n          R_ctrl_hi_imm16 <= R_ctrl_hi_imm16_nxt;\n    end\n\n\n  assign D_ctrl_unsigned_lo_imm16 = D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_roli|\n    D_op_rsvx10|\n    D_op_slli|\n    D_op_srli|\n    D_op_rsvx34|\n    D_op_rsvx42|\n    D_op_rsvx50|\n    D_op_srai;\n\n  assign R_ctrl_unsigned_lo_imm16_nxt = D_ctrl_unsigned_lo_imm16;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_unsigned_lo_imm16 <= 0;\n      else if (R_en)\n          R_ctrl_unsigned_lo_imm16 <= R_ctrl_unsigned_lo_imm16_nxt;\n    end\n\n\n  assign D_ctrl_br_uncond = D_op_br|D_op_rsv02;\n  assign R_ctrl_br_uncond_nxt = D_ctrl_br_uncond;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br_uncond <= 0;\n      else if (R_en)\n          R_ctrl_br_uncond <= R_ctrl_br_uncond_nxt;\n    end\n\n\n  assign D_ctrl_br = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62;\n\n  assign R_ctrl_br_nxt = D_ctrl_br;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br <= 0;\n      else if (R_en)\n          R_ctrl_br <= R_ctrl_br_nxt;\n    end\n\n\n  assign D_ctrl_alu_subtract = D_op_sub|\n    D_op_rsvx25|\n    D_op_cmplti|\n    D_op_cmpltui|\n    D_op_cmplt|\n    D_op_cmpltu|\n    D_op_blt|\n    D_op_bltu|\n    D_op_cmpgei|\n    D_op_cmpgeui|\n    D_op_cmpge|\n    D_op_cmpgeu|\n    D_op_bge|\n    D_op_rsv10|\n    D_op_bgeu|\n    D_op_rsv42;\n\n  assign R_ctrl_alu_subtract_nxt = D_ctrl_alu_subtract;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_subtract <= 0;\n      else if (R_en)\n          R_ctrl_alu_subtract <= R_ctrl_alu_subtract_nxt;\n    end\n\n\n  assign D_ctrl_alu_signed_comparison = D_op_cmpge|D_op_cmpgei|D_op_cmplt|D_op_cmplti|D_op_bge|D_op_blt;\n  assign R_ctrl_alu_signed_comparison_nxt = D_ctrl_alu_signed_comparison;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_signed_comparison <= 0;\n      else if (R_en)\n          R_ctrl_alu_signed_comparison <= R_ctrl_alu_signed_comparison_nxt;\n    end\n\n\n  assign D_ctrl_br_cmp = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_rsvx00|\n    D_op_cmpge|\n    D_op_cmplt|\n    D_op_cmpne|\n    D_op_cmpgeu|\n    D_op_cmpltu|\n    D_op_cmpeq|\n    D_op_rsvx56;\n\n  assign R_ctrl_br_cmp_nxt = D_ctrl_br_cmp;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br_cmp <= 0;\n      else if (R_en)\n          R_ctrl_br_cmp <= R_ctrl_br_cmp_nxt;\n    end\n\n\n  assign D_ctrl_ld_signed = D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63;\n\n  assign R_ctrl_ld_signed_nxt = D_ctrl_ld_signed;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_signed <= 0;\n      else if (R_en)\n          R_ctrl_ld_signed <= R_ctrl_ld_signed_nxt;\n    end\n\n\n  assign D_ctrl_ld = D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio;\n\n  assign R_ctrl_ld_nxt = D_ctrl_ld;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld <= 0;\n      else if (R_en)\n          R_ctrl_ld <= R_ctrl_ld_nxt;\n    end\n\n\n  assign D_ctrl_ld_non_io = D_op_ldbu|D_op_ldhu|D_op_ldb|D_op_ldh|D_op_ldw|D_op_ldl;\n  assign R_ctrl_ld_non_io_nxt = D_ctrl_ld_non_io;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_non_io <= 0;\n      else if (R_en)\n          R_ctrl_ld_non_io <= R_ctrl_ld_non_io_nxt;\n    end\n\n\n  assign D_ctrl_st = D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61;\n\n  assign R_ctrl_st_nxt = D_ctrl_st;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_st <= 0;\n      else if (R_en)\n          R_ctrl_st <= R_ctrl_st_nxt;\n    end\n\n\n  assign D_ctrl_ld_io = D_op_ldbuio|D_op_ldhuio|D_op_ldbio|D_op_ldhio|D_op_ldwio|D_op_rsv63;\n  assign R_ctrl_ld_io_nxt = D_ctrl_ld_io;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_io <= 0;\n      else if (R_en)\n          R_ctrl_ld_io <= R_ctrl_ld_io_nxt;\n    end\n\n\n  assign D_ctrl_b_is_dst = D_op_addi|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_call|\n    D_op_rdprs|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57|\n    D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio|\n    D_op_initd|\n    D_op_initda|\n    D_op_flushd|\n    D_op_flushda;\n\n  assign R_ctrl_b_is_dst_nxt = D_ctrl_b_is_dst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_b_is_dst <= 0;\n      else if (R_en)\n          R_ctrl_b_is_dst <= R_ctrl_b_is_dst_nxt;\n    end\n\n\n  assign D_ctrl_ignore_dst = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62|\n    D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57;\n\n  assign R_ctrl_ignore_dst_nxt = D_ctrl_ignore_dst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ignore_dst <= 0;\n      else if (R_en)\n          R_ctrl_ignore_dst <= R_ctrl_ignore_dst_nxt;\n    end\n\n\n  assign D_ctrl_src2_choose_imm = D_op_addi|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_call|\n    D_op_rdprs|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57|\n    D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio|\n    D_op_initd|\n    D_op_initda|\n    D_op_flushd|\n    D_op_flushda|\n    D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61|\n    D_op_roli|\n    D_op_rsvx10|\n    D_op_slli|\n    D_op_srli|\n    D_op_rsvx34|\n    D_op_rsvx42|\n    D_op_rsvx50|\n    D_op_srai;\n\n  assign R_ctrl_src2_choose_imm_nxt = D_ctrl_src2_choose_imm;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_src2_choose_imm <= 0;\n      else if (R_en)\n          R_ctrl_src2_choose_imm <= R_ctrl_src2_choose_imm_nxt;\n    end\n\n\n  assign D_ctrl_wrctl_inst = D_op_wrctl;\n  assign R_ctrl_wrctl_inst_nxt = D_ctrl_wrctl_inst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_wrctl_inst <= 0;\n      else if (R_en)\n          R_ctrl_wrctl_inst <= R_ctrl_wrctl_inst_nxt;\n    end\n\n\n  assign D_ctrl_rdctl_inst = D_op_rdctl;\n  assign R_ctrl_rdctl_inst_nxt = D_ctrl_rdctl_inst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_rdctl_inst <= 0;\n      else if (R_en)\n          R_ctrl_rdctl_inst <= R_ctrl_rdctl_inst_nxt;\n    end\n\n\n  assign D_ctrl_force_src2_zero = D_op_call|\n    D_op_rsv02|\n    D_op_nextpc|\n    D_op_callr|\n    D_op_trap|\n    D_op_rsvx44|\n    D_op_intr|\n    D_op_rsvx60|\n    D_op_break|\n    D_op_hbreak|\n    D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_jmpi;\n\n  assign R_ctrl_force_src2_zero_nxt = D_ctrl_force_src2_zero;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_force_src2_zero <= 0;\n      else if (R_en)\n          R_ctrl_force_src2_zero <= R_ctrl_force_src2_zero_nxt;\n    end\n\n\n  assign D_ctrl_alu_force_xor = D_op_cmpgei|\n    D_op_cmpgeui|\n    D_op_cmpeqi|\n    D_op_cmpge|\n    D_op_cmpgeu|\n    D_op_cmpeq|\n    D_op_cmpnei|\n    D_op_cmpne|\n    D_op_bge|\n    D_op_rsv10|\n    D_op_bgeu|\n    D_op_rsv42|\n    D_op_beq|\n    D_op_rsv34|\n    D_op_bne|\n    D_op_rsv62|\n    D_op_br|\n    D_op_rsv02;\n\n  assign R_ctrl_alu_force_xor_nxt = D_ctrl_alu_force_xor;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_force_xor <= 0;\n      else if (R_en)\n          R_ctrl_alu_force_xor <= R_ctrl_alu_force_xor_nxt;\n    end\n\n\n  \n  \n\n\n\n  assign F_inst = (F_op_call)? 56'h20202063616c6c :\n    (F_op_jmpi)? 56'h2020206a6d7069 :\n    (F_op_ldbu)? 56'h2020206c646275 :\n    (F_op_addi)? 56'h20202061646469 :\n    (F_op_stb)? 56'h20202020737462 :\n    (F_op_br)? 56'h20202020206272 :\n    (F_op_ldb)? 56'h202020206c6462 :\n    (F_op_cmpgei)? 56'h20636d70676569 :\n    (F_op_ldhu)? 56'h2020206c646875 :\n    (F_op_andi)? 56'h202020616e6469 :\n    (F_op_sth)? 56'h20202020737468 :\n    (F_op_bge)? 56'h20202020626765 :\n    (F_op_ldh)? 56'h202020206c6468 :\n    (F_op_cmplti)? 56'h20636d706c7469 :\n    (F_op_initda)? 56'h20696e69746461 :\n    (F_op_ori)? 56'h202020206f7269 :\n    (F_op_stw)? 56'h20202020737477 :\n    (F_op_blt)? 56'h20202020626c74 :\n    (F_op_ldw)? 56'h202020206c6477 :\n    (F_op_cmpnei)? 56'h20636d706e6569 :\n    (F_op_flushda)? 56'h666c7573686461 :\n    (F_op_xori)? 56'h202020786f7269 :\n    (F_op_bne)? 56'h20202020626e65 :\n    (F_op_cmpeqi)? 56'h20636d70657169 :\n    (F_op_ldbuio)? 56'h206c646275696f :\n    (F_op_muli)? 56'h2020206d756c69 :\n    (F_op_stbio)? 56'h2020737462696f :\n    (F_op_beq)? 56'h20202020626571 :\n    (F_op_ldbio)? 56'h20206c6462696f :\n    (F_op_cmpgeui)? 56'h636d7067657569 :\n    (F_op_ldhuio)? 56'h206c646875696f :\n    (F_op_andhi)? 56'h2020616e646869 :\n    (F_op_sthio)? 56'h2020737468696f :\n    (F_op_bgeu)? 56'h20202062676575 :\n    (F_op_ldhio)? 56'h20206c6468696f :\n    (F_op_cmpltui)? 56'h636d706c747569 :\n    (F_op_initd)? 56'h2020696e697464 :\n    (F_op_orhi)? 56'h2020206f726869 :\n    (F_op_stwio)? 56'h2020737477696f :\n    (F_op_bltu)? 56'h202020626c7475 :\n    (F_op_ldwio)? 56'h20206c6477696f :\n    (F_op_flushd)? 56'h20666c75736864 :\n    (F_op_xorhi)? 56'h2020786f726869 :\n    (F_op_eret)? 56'h20202065726574 :\n    (F_op_roli)? 56'h202020726f6c69 :\n    (F_op_rol)? 56'h20202020726f6c :\n    (F_op_flushp)? 56'h20666c75736870 :\n    (F_op_ret)? 56'h20202020726574 :\n    (F_op_nor)? 56'h202020206e6f72 :\n    (F_op_mulxuu)? 56'h206d756c787575 :\n    (F_op_cmpge)? 56'h2020636d706765 :\n    (F_op_bret)? 56'h20202062726574 :\n    (F_op_ror)? 56'h20202020726f72 :\n    (F_op_flushi)? 56'h20666c75736869 :\n    (F_op_jmp)? 56'h202020206a6d70 :\n    (F_op_and)? 56'h20202020616e64 :\n    (F_op_cmplt)? 56'h2020636d706c74 :\n    (F_op_slli)? 56'h202020736c6c69 :\n    (F_op_sll)? 56'h20202020736c6c :\n    (F_op_or)? 56'h20202020206f72 :\n    (F_op_mulxsu)? 56'h206d756c787375 :\n    (F_op_cmpne)? 56'h2020636d706e65 :\n    (F_op_srli)? 56'h20202073726c69 :\n    (F_op_srl)? 56'h2020202073726c :\n    (F_op_nextpc)? 56'h206e6578747063 :\n    (F_op_callr)? 56'h202063616c6c72 :\n    (F_op_xor)? 56'h20202020786f72 :\n    (F_op_mulxss)? 56'h206d756c787373 :\n    (F_op_cmpeq)? 56'h2020636d706571 :\n    (F_op_divu)? 56'h20202064697675 :\n    (F_op_div)? 56'h20202020646976 :\n    (F_op_rdctl)? 56'h2020726463746c :\n    (F_op_mul)? 56'h202020206d756c :\n    (F_op_cmpgeu)? 56'h20636d70676575 :\n    (F_op_initi)? 56'h2020696e697469 :\n    (F_op_trap)? 56'h20202074726170 :\n    (F_op_wrctl)? 56'h2020777263746c :\n    (F_op_cmpltu)? 56'h20636d706c7475 :\n    (F_op_add)? 56'h20202020616464 :\n    (F_op_break)? 56'h2020627265616b :\n    (F_op_hbreak)? 56'h2068627265616b :\n    (F_op_sync)? 56'h20202073796e63 :\n    (F_op_sub)? 56'h20202020737562 :\n    (F_op_srai)? 56'h20202073726169 :\n    (F_op_sra)? 56'h20202020737261 :\n    (F_op_intr)? 56'h202020696e7472 :\n    56'h20202020424144;\n\n  assign D_inst = (D_op_call)? 56'h20202063616c6c :\n    (D_op_jmpi)? 56'h2020206a6d7069 :\n    (D_op_ldbu)? 56'h2020206c646275 :\n    (D_op_addi)? 56'h20202061646469 :\n    (D_op_stb)? 56'h20202020737462 :\n    (D_op_br)? 56'h20202020206272 :\n    (D_op_ldb)? 56'h202020206c6462 :\n    (D_op_cmpgei)? 56'h20636d70676569 :\n    (D_op_ldhu)? 56'h2020206c646875 :\n    (D_op_andi)? 56'h202020616e6469 :\n    (D_op_sth)? 56'h20202020737468 :\n    (D_op_bge)? 56'h20202020626765 :\n    (D_op_ldh)? 56'h202020206c6468 :\n    (D_op_cmplti)? 56'h20636d706c7469 :\n    (D_op_initda)? 56'h20696e69746461 :\n    (D_op_ori)? 56'h202020206f7269 :\n    (D_op_stw)? 56'h20202020737477 :\n    (D_op_blt)? 56'h20202020626c74 :\n    (D_op_ldw)? 56'h202020206c6477 :\n    (D_op_cmpnei)? 56'h20636d706e6569 :\n    (D_op_flushda)? 56'h666c7573686461 :\n    (D_op_xori)? 56'h202020786f7269 :\n    (D_op_bne)? 56'h20202020626e65 :\n    (D_op_cmpeqi)? 56'h20636d70657169 :\n    (D_op_ldbuio)? 56'h206c646275696f :\n    (D_op_muli)? 56'h2020206d756c69 :\n    (D_op_stbio)? 56'h2020737462696f :\n    (D_op_beq)? 56'h20202020626571 :\n    (D_op_ldbio)? 56'h20206c6462696f :\n    (D_op_cmpgeui)? 56'h636d7067657569 :\n    (D_op_ldhuio)? 56'h206c646875696f :\n    (D_op_andhi)? 56'h2020616e646869 :\n    (D_op_sthio)? 56'h2020737468696f :\n    (D_op_bgeu)? 56'h20202062676575 :\n    (D_op_ldhio)? 56'h20206c6468696f :\n    (D_op_cmpltui)? 56'h636d706c747569 :\n    (D_op_initd)? 56'h2020696e697464 :\n    (D_op_orhi)? 56'h2020206f726869 :\n    (D_op_stwio)? 56'h2020737477696f :\n    (D_op_bltu)? 56'h202020626c7475 :\n    (D_op_ldwio)? 56'h20206c6477696f :\n    (D_op_flushd)? 56'h20666c75736864 :\n    (D_op_xorhi)? 56'h2020786f726869 :\n    (D_op_eret)? 56'h20202065726574 :\n    (D_op_roli)? 56'h202020726f6c69 :\n    (D_op_rol)? 56'h20202020726f6c :\n    (D_op_flushp)? 56'h20666c75736870 :\n    (D_op_ret)? 56'h20202020726574 :\n    (D_op_nor)? 56'h202020206e6f72 :\n    (D_op_mulxuu)? 56'h206d756c787575 :\n    (D_op_cmpge)? 56'h2020636d706765 :\n    (D_op_bret)? 56'h20202062726574 :\n    (D_op_ror)? 56'h20202020726f72 :\n    (D_op_flushi)? 56'h20666c75736869 :\n    (D_op_jmp)? 56'h202020206a6d70 :\n    (D_op_and)? 56'h20202020616e64 :\n    (D_op_cmplt)? 56'h2020636d706c74 :\n    (D_op_slli)? 56'h202020736c6c69 :\n    (D_op_sll)? 56'h20202020736c6c :\n    (D_op_or)? 56'h20202020206f72 :\n    (D_op_mulxsu)? 56'h206d756c787375 :\n    (D_op_cmpne)? 56'h2020636d706e65 :\n    (D_op_srli)? 56'h20202073726c69 :\n    (D_op_srl)? 56'h2020202073726c :\n    (D_op_nextpc)? 56'h206e6578747063 :\n    (D_op_callr)? 56'h202063616c6c72 :\n    (D_op_xor)? 56'h20202020786f72 :\n    (D_op_mulxss)? 56'h206d756c787373 :\n    (D_op_cmpeq)? 56'h2020636d706571 :\n    (D_op_divu)? 56'h20202064697675 :\n    (D_op_div)? 56'h20202020646976 :\n    (D_op_rdctl)? 56'h2020726463746c :\n    (D_op_mul)? 56'h202020206d756c :\n    (D_op_cmpgeu)? 56'h20636d70676575 :\n    (D_op_initi)? 56'h2020696e697469 :\n    (D_op_trap)? 56'h20202074726170 :\n    (D_op_wrctl)? 56'h2020777263746c :\n    (D_op_cmpltu)? 56'h20636d706c7475 :\n    (D_op_add)? 56'h20202020616464 :\n    (D_op_break)? 56'h2020627265616b :\n    (D_op_hbreak)? 56'h2068627265616b :\n    (D_op_sync)? 56'h20202073796e63 :\n    (D_op_sub)? 56'h20202020737562 :\n    (D_op_srai)? 56'h20202073726169 :\n    (D_op_sra)? 56'h20202020737261 :\n    (D_op_intr)? 56'h202020696e7472 :\n    56'h20202020424144;\n\n  assign F_vinst = F_valid ? F_inst : {7{8'h2d}};\n  assign D_vinst = D_valid ? D_inst : {7{8'h2d}};\n  assign R_vinst = R_valid ? D_inst : {7{8'h2d}};\n  assign E_vinst = E_valid ? D_inst : {7{8'h2d}};\n  assign W_vinst = W_valid ? D_inst : {7{8'h2d}};\n\n\n\n\n\nendmodule\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: CPU_cpu. Module specification: This module implements the main CPU core for a NIOS II processor. It contains the key pipeline stages (fetch, decode, execute, memory, writeback) and associated control logic. The module handles instruction fetch, decoding, execution of arithmetic/logic operations, memory access, and writing results back to registers. It also includes logic for branch prediction, exception handling, and interfacing with other system components like memory and peripherals. Key input ports include clk (system clock), reset_n (active-low reset), d_irq (data memory interrupt request), and i_readdata (instruction read data). Output ports include d_address (data memory address), i_address (instruction memory address), and various control signals. Internal signals such as F_pc (fetch stage program counter), D_iw (decode stage instruction word), and E_alu_result (execute stage ALU result) are use"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: CPU_cpu\n\nExplanation: This module implements the main CPU core for a NIOS II processor. It contains the key pipeline stages (fetch, decode, execute, memory, writeback) and associated control logic. The module handles instruction fetch, decoding, execution of arithmetic/logic operations, memory access, and writing results back to registers. It also includes logic for branch prediction, exception handling, and interfacing with other system components like memory and peripherals. The module implements the NIOS II instruction set and manages the flow of instructions and data through the processor pipeline."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the CPU_cpu module, here are the input and output ports along with explanations:\n\nInput ports:\nclk, d_irq, d_readdata, d_waitrequest, i_readdata, i_waitrequest, jtag_debug_module_address, jtag_debug_module_byteenable, jtag_debug_module_debugaccess, jtag_debug_module_read, jtag_debug_module_write, jtag_debug_module_writedata, reset_n, reset_req\n\nExplanation:\n- clk: System clock input\n- d_irq: Data memory interrupt request\n- d_readdata: Data read from data memory\n- d_waitrequest: Data memory wait request signal\n- i_readdata: Instruction read from instruction memory\n- i_waitrequest: Instruction memory wait request signal\n- jtag_debug_module_*: Various signals for JTAG debug module interface\n- reset_n: Active-low reset signal\n- reset_req: Reset request signal\n\nOutput ports:\nd_address, d_byteenable, d_read, d_write, d_writedata, i_address, i_read, jtag_debug_module_debugaccess_to_roms, jtag_debug_module_readdata, jtag_debug_module_resetrequest, jtag_debug_module_waitrequest, no_ci_readra\n\nExplanation:\n- d_address: Data memory address output\n- d_byteenable: Data memory byte enable signals\n- d_read: Data memory read enable\n- d_write: Data memory write enable\n- d_writedata: Data to be written to data memory\n- i_address: Instruction memory address output\n- i_read: Instruction memory read enable\n- jtag_debug_module_*: Various signals for JTAG debug module interface\n- no_ci_readra: Custom instruction-related signal\n\nThese ports allow the CPU core to interact with memory, handle interrupts, support debugging, and interface with other system components."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nBased on the given code, here are the key internal signals and their explanations:\n\nInternal signals: F_pc, D_iw, E_valid, R_wr_dst_reg, W_status_reg_pie, W_estatus_reg, W_bstatus_reg, W_ienable_reg, W_ipending_reg, F_iw, R_ctrl_ld, E_logic_result, E_mem_byte_en, av_ld_data_aligned_filtered.\n\nExplanation:\n- F_pc: Fetch stage program counter\n- D_iw: Decode stage instruction word\n- E_valid: Execute stage valid signal\n- R_wr_dst_reg: Register file write destination register\n- W_status_reg_pie: Processor status register PIE (Processor Interrupt Enable) bit\n- W_estatus_reg: Exception status register\n- W_bstatus_reg: Break status register\n- W_ienable_reg: Interrupt enable register\n- W_ipending_reg: Interrupt pending register\n- F_iw: Fetch stage instruction word\n- R_ctrl_ld: Load instruction control signal\n- E_logic_result: Execute stage logic operation result\n- E_mem_byte_en: Memory byte enable signals\n- av_ld_data_aligned_filtered: Aligned and filtered load data\n\nThese signals represent various control and data elements used throughout the CPU pipeline stages for instruction processing, execution control, and status tracking."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_register_bank_a_module (\n                                        \n                                         clock,\n                                         data,\n                                         rdaddress,\n                                         wraddress,\n                                         wren,\n\n                                        \n                                         q\n                                      )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input            clock;\n  input   [ 31: 0] data;\n  input   [  4: 0] rdaddress;\n  input   [  4: 0] wraddress;\n  input            wren;\n\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_data;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign ram_data = data;\n  altsyncram the_altsyncram\n    (\n      .address_a (wraddress),\n      .address_b (rdaddress),\n      .clock0 (clock),\n      .data_a (ram_data),\n      .q_b (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.address_reg_b = \"CLOCK0\",\n           the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 32,\n           the_altsyncram.numwords_b = 32,\n           the_altsyncram.operation_mode = \"DUAL_PORT\",\n           the_altsyncram.outdata_reg_b = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.rdcontrol_reg_b = \"CLOCK0\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_b = 32,\n           the_altsyncram.widthad_a = 5,\n           the_altsyncram.widthad_b = 5;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_register_bank_b_module (\n                                        \n                                         clock,\n                                         data,\n                                         rdaddress,\n                                         wraddress,\n                                         wren,\n\n                                        \n                                         q\n                                      )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input            clock;\n  input   [ 31: 0] data;\n  input   [  4: 0] rdaddress;\n  input   [  4: 0] wraddress;\n  input            wren;\n\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_data;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign ram_data = data;\n  altsyncram the_altsyncram\n    (\n      .address_a (wraddress),\n      .address_b (rdaddress),\n      .clock0 (clock),\n      .data_a (ram_data),\n      .q_b (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.address_reg_b = \"CLOCK0\",\n           the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 32,\n           the_altsyncram.numwords_b = 32,\n           the_altsyncram.operation_mode = \"DUAL_PORT\",\n           the_altsyncram.outdata_reg_b = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.rdcontrol_reg_b = \"CLOCK0\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_b = 32,\n           the_altsyncram.widthad_a = 5,\n           the_altsyncram.widthad_b = 5;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_debug (\n                                 \n                                  clk,\n                                  dbrk_break,\n                                  debugreq,\n                                  hbreak_enabled,\n                                  jdo,\n                                  jrst_n,\n                                  ocireg_ers,\n                                  ocireg_mrs,\n                                  reset,\n                                  st_ready_test_idle,\n                                  take_action_ocimem_a,\n                                  take_action_ocireg,\n                                  xbrk_break,\n\n                                 \n                                  debugack,\n                                  monitor_error,\n                                  monitor_go,\n                                  monitor_ready,\n                                  oci_hbreak_req,\n                                  resetlatch,\n                                  resetrequest\n                               )\n;\n\n  output           debugack;\n  output           monitor_error;\n  output           monitor_go;\n  output           monitor_ready;\n  output           oci_hbreak_req;\n  output           resetlatch;\n  output           resetrequest;\n  input            clk;\n  input            dbrk_break;\n  input            debugreq;\n  input            hbreak_enabled;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            ocireg_ers;\n  input            ocireg_mrs;\n  input            reset;\n  input            st_ready_test_idle;\n  input            take_action_ocimem_a;\n  input            take_action_ocireg;\n  input            xbrk_break;\n\n  reg              break_on_reset ;\n  wire             debugack;\n  reg              jtag_break ;\n  reg              monitor_error ;\n  reg              monitor_go ;\n  reg              monitor_ready ;\n  wire             oci_hbreak_req;\n  wire             reset_sync;\n  reg              resetlatch ;\n  reg              resetrequest ;\n  wire             unxcomplemented_resetxx0;\n  assign unxcomplemented_resetxx0 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer\n    (\n      .clk (clk),\n      .din (reset),\n      .dout (reset_sync),\n      .reset_n (unxcomplemented_resetxx0)\n    );\n\n  defparam the_altera_std_synchronizer.depth = 2;\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          break_on_reset <= 1'b0;\n          resetrequest <= 1'b0;\n          jtag_break <= 1'b0;\n        end\n      else if (take_action_ocimem_a)\n        begin\n          resetrequest <= jdo[22];\n          jtag_break <= jdo[21]     ? 1 \n                    : jdo[20]  ? 0 \n                    : jtag_break;\n\n          break_on_reset <= jdo[19]     ? 1\n                    : jdo[18]  ? 0\n                    :  break_on_reset;\n\n          resetlatch <= jdo[24] ? 0 : resetlatch;\n        end\n      else if (reset_sync)\n        begin\n          jtag_break <= break_on_reset;\n          resetlatch <= 1;\n        end\n      else if (debugreq & ~debugack & break_on_reset)\n          jtag_break <= 1'b1;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          monitor_ready <= 1'b0;\n          monitor_error <= 1'b0;\n          monitor_go <= 1'b0;\n        end\n      else \n        begin\n          if (take_action_ocimem_a && jdo[25])\n              monitor_ready <= 1'b0;\n          else if (take_action_ocireg && ocireg_mrs)\n              monitor_ready <= 1'b1;\n          if (take_action_ocimem_a && jdo[25])\n              monitor_error <= 1'b0;\n          else if (take_action_ocireg && ocireg_ers)\n              monitor_error <= 1'b1;\n          if (take_action_ocimem_a && jdo[23])\n              monitor_go <= 1'b1;\n          else if (st_ready_test_idle)\n              monitor_go <= 1'b0;\n        end\n    end\n\n\n  assign oci_hbreak_req = jtag_break | dbrk_break | xbrk_break | debugreq;\n  assign debugack = ~hbreak_enabled;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_ociram_sp_ram_module (\n                                      \n                                       address,\n                                       byteenable,\n                                       clock,\n                                       data,\n                                       reset_req,\n                                       wren,\n\n                                      \n                                       q\n                                    )\n;\n\n  parameter lpm_file = \"UNUSED\";\n\n\n  output  [ 31: 0] q;\n  input   [  7: 0] address;\n  input   [  3: 0] byteenable;\n  input            clock;\n  input   [ 31: 0] data;\n  input            reset_req;\n  input            wren;\n\n  wire             clocken;\n  wire    [ 31: 0] q;\n  wire    [ 31: 0] ram_q;\n  assign q = ram_q;\n  assign clocken = ~reset_req;\n  altsyncram the_altsyncram\n    (\n      .address_a (address),\n      .byteena_a (byteenable),\n      .clock0 (clock),\n      .clocken0 (clocken),\n      .data_a (data),\n      .q_a (ram_q),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.init_file = lpm_file,\n           the_altsyncram.maximum_depth = 0,\n           the_altsyncram.numwords_a = 256,\n           the_altsyncram.operation_mode = \"SINGLE_PORT\",\n           the_altsyncram.outdata_reg_a = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_byteena_a = 4,\n           the_altsyncram.widthad_a = 8;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_ocimem (\n                              \n                               address,\n                               byteenable,\n                               clk,\n                               debugaccess,\n                               jdo,\n                               jrst_n,\n                               read,\n                               reset_req,\n                               take_action_ocimem_a,\n                               take_action_ocimem_b,\n                               take_no_action_ocimem_a,\n                               write,\n                               writedata,\n\n                              \n                               MonDReg,\n                               ociram_readdata,\n                               waitrequest\n                            )\n;\n\n  output  [ 31: 0] MonDReg;\n  output  [ 31: 0] ociram_readdata;\n  output           waitrequest;\n  input   [  8: 0] address;\n  input   [  3: 0] byteenable;\n  input            clk;\n  input            debugaccess;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            read;\n  input            reset_req;\n  input            take_action_ocimem_a;\n  input            take_action_ocimem_b;\n  input            take_no_action_ocimem_a;\n  input            write;\n  input   [ 31: 0] writedata;\n\n  reg     [ 10: 0] MonAReg ;\n  wire    [  8: 0] MonARegAddrInc;\n  wire             MonARegAddrIncAccessingRAM;\n  reg     [ 31: 0] MonDReg ;\n  reg              avalon_ociram_readdata_ready ;\n  wire             avalon_ram_wr;\n  wire    [ 31: 0] cfgrom_readdata;\n  reg              jtag_ram_access ;\n  reg              jtag_ram_rd ;\n  reg              jtag_ram_rd_d1 ;\n  reg              jtag_ram_wr ;\n  reg              jtag_rd ;\n  reg              jtag_rd_d1 ;\n  wire    [  7: 0] ociram_addr;\n  wire    [  3: 0] ociram_byteenable;\n  wire    [ 31: 0] ociram_readdata;\n  wire    [ 31: 0] ociram_wr_data;\n  wire             ociram_wr_en;\n  reg              waitrequest ;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          jtag_rd <= 1'b0;\n          jtag_rd_d1 <= 1'b0;\n          jtag_ram_wr <= 1'b0;\n          jtag_ram_rd <= 1'b0;\n          jtag_ram_rd_d1 <= 1'b0;\n          jtag_ram_access <= 1'b0;\n          MonAReg <= 0;\n          MonDReg <= 0;\n          waitrequest <= 1'b1;\n          avalon_ociram_readdata_ready <= 1'b0;\n        end\n      else \n        begin\n          if (take_no_action_ocimem_a)\n            begin\n              MonAReg[10 : 2] <= MonARegAddrInc;\n              jtag_rd <= 1'b1;\n              jtag_ram_rd <= MonARegAddrIncAccessingRAM;\n              jtag_ram_access <= MonARegAddrIncAccessingRAM;\n            end\n          else if (take_action_ocimem_a)\n            begin\n              MonAReg[10 : 2] <= { jdo[17],\n                            jdo[33 : 26] };\n\n              jtag_rd <= 1'b1;\n              jtag_ram_rd <= ~jdo[17];\n              jtag_ram_access <= ~jdo[17];\n            end\n          else if (take_action_ocimem_b)\n            begin\n              MonAReg[10 : 2] <= MonARegAddrInc;\n              MonDReg <= jdo[34 : 3];\n              jtag_ram_wr <= MonARegAddrIncAccessingRAM;\n              jtag_ram_access <= MonARegAddrIncAccessingRAM;\n            end\n          else \n            begin\n              jtag_rd <= 0;\n              jtag_ram_wr <= 0;\n              jtag_ram_rd <= 0;\n              jtag_ram_access <= 0;\n              if (jtag_rd_d1)\n                  MonDReg <= jtag_ram_rd_d1 ? ociram_readdata : cfgrom_readdata;\n            end\n          jtag_rd_d1 <= jtag_rd;\n          jtag_ram_rd_d1 <= jtag_ram_rd;\n          if (~waitrequest)\n            begin\n              waitrequest <= 1'b1;\n              avalon_ociram_readdata_ready <= 1'b0;\n            end\n          else if (write)\n              waitrequest <= ~address[8] & jtag_ram_access;\n          else if (read)\n            begin\n              avalon_ociram_readdata_ready <= ~(~address[8] & jtag_ram_access);\n              waitrequest <= ~avalon_ociram_readdata_ready;\n            end\n          else \n            begin\n              waitrequest <= 1'b1;\n              avalon_ociram_readdata_ready <= 1'b0;\n            end\n        end\n    end\n\n\n  assign MonARegAddrInc = MonAReg[10 : 2]+1;\n  assign MonARegAddrIncAccessingRAM = ~MonARegAddrInc[8];\n  assign avalon_ram_wr = write & ~address[8] & debugaccess;\n  assign ociram_addr = jtag_ram_access ? MonAReg[9 : 2] : address[7 : 0];\n  assign ociram_wr_data = jtag_ram_access ? MonDReg[31 : 0] : writedata;\n  assign ociram_byteenable = jtag_ram_access ? 4'b1111 : byteenable;\n  assign ociram_wr_en = jtag_ram_access ? jtag_ram_wr : avalon_ram_wr;\n\nCPU_cpu_ociram_sp_ram_module CPU_cpu_ociram_sp_ram\n  (\n    .address    (ociram_addr),\n    .byteenable (ociram_byteenable),\n    .clock      (clk),\n    .data       (ociram_wr_data),\n    .q          (ociram_readdata),\n    .reset_req  (reset_req),\n    .wren       (ociram_wr_en)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_ociram_sp_ram.lpm_file = \"CPU_cpu_ociram_default_contents.dat\";\n`else\ndefparam CPU_cpu_ociram_sp_ram.lpm_file = \"CPU_cpu_ociram_default_contents.hex\";\n`endif\n\n\n\n\n  assign cfgrom_readdata = (MonAReg[4 : 2] == 3'd0)? 32'h00800020 :\n    (MonAReg[4 : 2] == 3'd1)? 32'h00001919 :\n    (MonAReg[4 : 2] == 3'd2)? 32'h00040000 :\n    (MonAReg[4 : 2] == 3'd3)? 32'h00000100 :\n    (MonAReg[4 : 2] == 3'd4)? 32'h20000000 :\n    (MonAReg[4 : 2] == 3'd5)? 32'h00800000 :\n    (MonAReg[4 : 2] == 3'd6)? 32'h00000000 :\n    32'h00000000;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_avalon_reg (\n                                  \n                                   address,\n                                   clk,\n                                   debugaccess,\n                                   monitor_error,\n                                   monitor_go,\n                                   monitor_ready,\n                                   reset_n,\n                                   write,\n                                   writedata,\n\n                                  \n                                   oci_ienable,\n                                   oci_reg_readdata,\n                                   oci_single_step_mode,\n                                   ocireg_ers,\n                                   ocireg_mrs,\n                                   take_action_ocireg\n                                )\n;\n\n  output  [ 31: 0] oci_ienable;\n  output  [ 31: 0] oci_reg_readdata;\n  output           oci_single_step_mode;\n  output           ocireg_ers;\n  output           ocireg_mrs;\n  output           take_action_ocireg;\n  input   [  8: 0] address;\n  input            clk;\n  input            debugaccess;\n  input            monitor_error;\n  input            monitor_go;\n  input            monitor_ready;\n  input            reset_n;\n  input            write;\n  input   [ 31: 0] writedata;\n\n  reg     [ 31: 0] oci_ienable;\n  wire             oci_reg_00_addressed;\n  wire             oci_reg_01_addressed;\n  wire    [ 31: 0] oci_reg_readdata;\n  reg              oci_single_step_mode;\n  wire             ocireg_ers;\n  wire             ocireg_mrs;\n  wire             ocireg_sstep;\n  wire             take_action_oci_intr_mask_reg;\n  wire             take_action_ocireg;\n  wire             write_strobe;\n  assign oci_reg_00_addressed = address == 9'h100;\n  assign oci_reg_01_addressed = address == 9'h101;\n  assign write_strobe = write & debugaccess;\n  assign take_action_ocireg = write_strobe & oci_reg_00_addressed;\n  assign take_action_oci_intr_mask_reg = write_strobe & oci_reg_01_addressed;\n  assign ocireg_ers = writedata[1];\n  assign ocireg_mrs = writedata[0];\n  assign ocireg_sstep = writedata[3];\n  assign oci_reg_readdata = oci_reg_00_addressed ? {28'b0, oci_single_step_mode, monitor_go,\n    monitor_ready, monitor_error} : \n    oci_reg_01_addressed ?  oci_ienable :   \n    32'b0;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_single_step_mode <= 1'b0;\n      else if (take_action_ocireg)\n          oci_single_step_mode <= ocireg_sstep;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_ienable <= 32'b00000000000000000000000000000001;\n      else if (take_action_oci_intr_mask_reg)\n          oci_ienable <= writedata | ~(32'b00000000000000000000000000000001);\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_break (\n                                 \n                                  clk,\n                                  dbrk_break,\n                                  dbrk_goto0,\n                                  dbrk_goto1,\n                                  jdo,\n                                  jrst_n,\n                                  reset_n,\n                                  take_action_break_a,\n                                  take_action_break_b,\n                                  take_action_break_c,\n                                  take_no_action_break_a,\n                                  take_no_action_break_b,\n                                  take_no_action_break_c,\n                                  xbrk_goto0,\n                                  xbrk_goto1,\n\n                                 \n                                  break_readreg,\n                                  dbrk_hit0_latch,\n                                  dbrk_hit1_latch,\n                                  dbrk_hit2_latch,\n                                  dbrk_hit3_latch,\n                                  trigbrktype,\n                                  trigger_state_0,\n                                  trigger_state_1,\n                                  xbrk_ctrl0,\n                                  xbrk_ctrl1,\n                                  xbrk_ctrl2,\n                                  xbrk_ctrl3\n                               )\n;\n\n  output  [ 31: 0] break_readreg;\n  output           dbrk_hit0_latch;\n  output           dbrk_hit1_latch;\n  output           dbrk_hit2_latch;\n  output           dbrk_hit3_latch;\n  output           trigbrktype;\n  output           trigger_state_0;\n  output           trigger_state_1;\n  output  [  7: 0] xbrk_ctrl0;\n  output  [  7: 0] xbrk_ctrl1;\n  output  [  7: 0] xbrk_ctrl2;\n  output  [  7: 0] xbrk_ctrl3;\n  input            clk;\n  input            dbrk_break;\n  input            dbrk_goto0;\n  input            dbrk_goto1;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            reset_n;\n  input            take_action_break_a;\n  input            take_action_break_b;\n  input            take_action_break_c;\n  input            take_no_action_break_a;\n  input            take_no_action_break_b;\n  input            take_no_action_break_c;\n  input            xbrk_goto0;\n  input            xbrk_goto1;\n\n  wire    [  3: 0] break_a_wpr;\n  wire    [  1: 0] break_a_wpr_high_bits;\n  wire    [  1: 0] break_a_wpr_low_bits;\n  wire    [  1: 0] break_b_rr;\n  wire    [  1: 0] break_c_rr;\n  reg     [ 31: 0] break_readreg ;\n  wire             dbrk0_high_value;\n  wire             dbrk0_low_value;\n  wire             dbrk1_high_value;\n  wire             dbrk1_low_value;\n  wire             dbrk2_high_value;\n  wire             dbrk2_low_value;\n  wire             dbrk3_high_value;\n  wire             dbrk3_low_value;\n  wire             dbrk_hit0_latch;\n  wire             dbrk_hit1_latch;\n  wire             dbrk_hit2_latch;\n  wire             dbrk_hit3_latch;\n  wire             take_action_any_break;\n  reg              trigbrktype ;\n  reg              trigger_state;\n  wire             trigger_state_0;\n  wire             trigger_state_1;\n  wire    [ 31: 0] xbrk0_value;\n  wire    [ 31: 0] xbrk1_value;\n  wire    [ 31: 0] xbrk2_value;\n  wire    [ 31: 0] xbrk3_value;\n  reg     [  7: 0] xbrk_ctrl0 ;\n  reg     [  7: 0] xbrk_ctrl1 ;\n  reg     [  7: 0] xbrk_ctrl2 ;\n  reg     [  7: 0] xbrk_ctrl3 ;\n  assign break_a_wpr = jdo[35 : 32];\n  assign break_a_wpr_high_bits = break_a_wpr[3 : 2];\n  assign break_a_wpr_low_bits = break_a_wpr[1 : 0];\n  assign break_b_rr = jdo[33 : 32];\n  assign break_c_rr = jdo[33 : 32];\n  assign take_action_any_break = take_action_break_a | take_action_break_b | take_action_break_c;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          xbrk_ctrl0 <= 0;\n          xbrk_ctrl1 <= 0;\n          xbrk_ctrl2 <= 0;\n          xbrk_ctrl3 <= 0;\n          trigbrktype <= 0;\n        end\n      else \n        begin\n          if (take_action_any_break)\n              trigbrktype <= 0;\n          else if (dbrk_break)\n              trigbrktype <= 1;\n          if (take_action_break_b)\n            begin\n              if ((break_b_rr == 2'b00) && (0 >= 1))\n                begin\n                  xbrk_ctrl0[0] <= jdo[27];\n                  xbrk_ctrl0[1] <= jdo[28];\n                  xbrk_ctrl0[2] <= jdo[29];\n                  xbrk_ctrl0[3] <= jdo[30];\n                  xbrk_ctrl0[4] <= jdo[21];\n                  xbrk_ctrl0[5] <= jdo[20];\n                  xbrk_ctrl0[6] <= jdo[19];\n                  xbrk_ctrl0[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b01) && (0 >= 2))\n                begin\n                  xbrk_ctrl1[0] <= jdo[27];\n                  xbrk_ctrl1[1] <= jdo[28];\n                  xbrk_ctrl1[2] <= jdo[29];\n                  xbrk_ctrl1[3] <= jdo[30];\n                  xbrk_ctrl1[4] <= jdo[21];\n                  xbrk_ctrl1[5] <= jdo[20];\n                  xbrk_ctrl1[6] <= jdo[19];\n                  xbrk_ctrl1[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b10) && (0 >= 3))\n                begin\n                  xbrk_ctrl2[0] <= jdo[27];\n                  xbrk_ctrl2[1] <= jdo[28];\n                  xbrk_ctrl2[2] <= jdo[29];\n                  xbrk_ctrl2[3] <= jdo[30];\n                  xbrk_ctrl2[4] <= jdo[21];\n                  xbrk_ctrl2[5] <= jdo[20];\n                  xbrk_ctrl2[6] <= jdo[19];\n                  xbrk_ctrl2[7] <= jdo[18];\n                end\n              if ((break_b_rr == 2'b11) && (0 >= 4))\n                begin\n                  xbrk_ctrl3[0] <= jdo[27];\n                  xbrk_ctrl3[1] <= jdo[28];\n                  xbrk_ctrl3[2] <= jdo[29];\n                  xbrk_ctrl3[3] <= jdo[30];\n                  xbrk_ctrl3[4] <= jdo[21];\n                  xbrk_ctrl3[5] <= jdo[20];\n                  xbrk_ctrl3[6] <= jdo[19];\n                  xbrk_ctrl3[7] <= jdo[18];\n                end\n            end\n        end\n    end\n\n\n  assign dbrk_hit0_latch = 1'b0;\n  assign dbrk0_low_value = 0;\n  assign dbrk0_high_value = 0;\n  assign dbrk_hit1_latch = 1'b0;\n  assign dbrk1_low_value = 0;\n  assign dbrk1_high_value = 0;\n  assign dbrk_hit2_latch = 1'b0;\n  assign dbrk2_low_value = 0;\n  assign dbrk2_high_value = 0;\n  assign dbrk_hit3_latch = 1'b0;\n  assign dbrk3_low_value = 0;\n  assign dbrk3_high_value = 0;\n  assign xbrk0_value = 32'b0;\n  assign xbrk1_value = 32'b0;\n  assign xbrk2_value = 32'b0;\n  assign xbrk3_value = 32'b0;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          break_readreg <= 32'b0;\n      else if (take_action_any_break)\n          break_readreg <= jdo[31 : 0];\n      else if (take_no_action_break_a)\n          case (break_a_wpr_high_bits)\n          \n              2'd0: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= xbrk0_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= xbrk1_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= xbrk2_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= xbrk3_value;\n                      end \n                  \n                  endcase \n              end \n          \n              2'd1: begin\n                  break_readreg <= 32'b0;\n              end \n          \n              2'd2: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= dbrk0_low_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= dbrk1_low_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= dbrk2_low_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= dbrk3_low_value;\n                      end \n                  \n                  endcase \n              end \n          \n              2'd3: begin\n                  case (break_a_wpr_low_bits) \n                  \n                      2'd0: begin\n                          break_readreg <= dbrk0_high_value;\n                      end \n                  \n                      2'd1: begin\n                          break_readreg <= dbrk1_high_value;\n                      end \n                  \n                      2'd2: begin\n                          break_readreg <= dbrk2_high_value;\n                      end \n                  \n                      2'd3: begin\n                          break_readreg <= dbrk3_high_value;\n                      end \n                  \n                  endcase \n              end \n          \n          endcase \n      else if (take_no_action_break_b)\n          break_readreg <= jdo[31 : 0];\n      else if (take_no_action_break_c)\n          break_readreg <= jdo[31 : 0];\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          trigger_state <= 0;\n      else if (trigger_state_1 & (xbrk_goto0 | dbrk_goto0))\n          trigger_state <= 0;\n      else if (trigger_state_0 & (xbrk_goto1 | dbrk_goto1))\n          trigger_state <= -1;\n    end\n\n\n  assign trigger_state_0 = ~trigger_state;\n  assign trigger_state_1 = trigger_state;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_xbrk (\n                                \n                                 D_valid,\n                                 E_valid,\n                                 F_pc,\n                                 clk,\n                                 reset_n,\n                                 trigger_state_0,\n                                 trigger_state_1,\n                                 xbrk_ctrl0,\n                                 xbrk_ctrl1,\n                                 xbrk_ctrl2,\n                                 xbrk_ctrl3,\n\n                                \n                                 xbrk_break,\n                                 xbrk_goto0,\n                                 xbrk_goto1,\n                                 xbrk_traceoff,\n                                 xbrk_traceon,\n                                 xbrk_trigout\n                              )\n;\n\n  output           xbrk_break;\n  output           xbrk_goto0;\n  output           xbrk_goto1;\n  output           xbrk_traceoff;\n  output           xbrk_traceon;\n  output           xbrk_trigout;\n  input            D_valid;\n  input            E_valid;\n  input   [ 22: 0] F_pc;\n  input            clk;\n  input            reset_n;\n  input            trigger_state_0;\n  input            trigger_state_1;\n  input   [  7: 0] xbrk_ctrl0;\n  input   [  7: 0] xbrk_ctrl1;\n  input   [  7: 0] xbrk_ctrl2;\n  input   [  7: 0] xbrk_ctrl3;\n\n  wire             D_cpu_addr_en;\n  wire             E_cpu_addr_en;\n  reg              E_xbrk_goto0;\n  reg              E_xbrk_goto1;\n  reg              E_xbrk_traceoff;\n  reg              E_xbrk_traceon;\n  reg              E_xbrk_trigout;\n  wire    [ 24: 0] cpu_i_address;\n  wire             xbrk0_armed;\n  wire             xbrk0_break_hit;\n  wire             xbrk0_goto0_hit;\n  wire             xbrk0_goto1_hit;\n  wire             xbrk0_toff_hit;\n  wire             xbrk0_ton_hit;\n  wire             xbrk0_tout_hit;\n  wire             xbrk1_armed;\n  wire             xbrk1_break_hit;\n  wire             xbrk1_goto0_hit;\n  wire             xbrk1_goto1_hit;\n  wire             xbrk1_toff_hit;\n  wire             xbrk1_ton_hit;\n  wire             xbrk1_tout_hit;\n  wire             xbrk2_armed;\n  wire             xbrk2_break_hit;\n  wire             xbrk2_goto0_hit;\n  wire             xbrk2_goto1_hit;\n  wire             xbrk2_toff_hit;\n  wire             xbrk2_ton_hit;\n  wire             xbrk2_tout_hit;\n  wire             xbrk3_armed;\n  wire             xbrk3_break_hit;\n  wire             xbrk3_goto0_hit;\n  wire             xbrk3_goto1_hit;\n  wire             xbrk3_toff_hit;\n  wire             xbrk3_ton_hit;\n  wire             xbrk3_tout_hit;\n  reg              xbrk_break;\n  wire             xbrk_break_hit;\n  wire             xbrk_goto0;\n  wire             xbrk_goto0_hit;\n  wire             xbrk_goto1;\n  wire             xbrk_goto1_hit;\n  wire             xbrk_toff_hit;\n  wire             xbrk_ton_hit;\n  wire             xbrk_tout_hit;\n  wire             xbrk_traceoff;\n  wire             xbrk_traceon;\n  wire             xbrk_trigout;\n  assign cpu_i_address = {F_pc, 2'b00};\n  assign D_cpu_addr_en = D_valid;\n  assign E_cpu_addr_en = E_valid;\n  assign xbrk0_break_hit = 0;\n  assign xbrk0_ton_hit = 0;\n  assign xbrk0_toff_hit = 0;\n  assign xbrk0_tout_hit = 0;\n  assign xbrk0_goto0_hit = 0;\n  assign xbrk0_goto1_hit = 0;\n  assign xbrk1_break_hit = 0;\n  assign xbrk1_ton_hit = 0;\n  assign xbrk1_toff_hit = 0;\n  assign xbrk1_tout_hit = 0;\n  assign xbrk1_goto0_hit = 0;\n  assign xbrk1_goto1_hit = 0;\n  assign xbrk2_break_hit = 0;\n  assign xbrk2_ton_hit = 0;\n  assign xbrk2_toff_hit = 0;\n  assign xbrk2_tout_hit = 0;\n  assign xbrk2_goto0_hit = 0;\n  assign xbrk2_goto1_hit = 0;\n  assign xbrk3_break_hit = 0;\n  assign xbrk3_ton_hit = 0;\n  assign xbrk3_toff_hit = 0;\n  assign xbrk3_tout_hit = 0;\n  assign xbrk3_goto0_hit = 0;\n  assign xbrk3_goto1_hit = 0;\n  assign xbrk_break_hit = (xbrk0_break_hit) | (xbrk1_break_hit) | (xbrk2_break_hit) | (xbrk3_break_hit);\n  assign xbrk_ton_hit = (xbrk0_ton_hit) | (xbrk1_ton_hit) | (xbrk2_ton_hit) | (xbrk3_ton_hit);\n  assign xbrk_toff_hit = (xbrk0_toff_hit) | (xbrk1_toff_hit) | (xbrk2_toff_hit) | (xbrk3_toff_hit);\n  assign xbrk_tout_hit = (xbrk0_tout_hit) | (xbrk1_tout_hit) | (xbrk2_tout_hit) | (xbrk3_tout_hit);\n  assign xbrk_goto0_hit = (xbrk0_goto0_hit) | (xbrk1_goto0_hit) | (xbrk2_goto0_hit) | (xbrk3_goto0_hit);\n  assign xbrk_goto1_hit = (xbrk0_goto1_hit) | (xbrk1_goto1_hit) | (xbrk2_goto1_hit) | (xbrk3_goto1_hit);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          xbrk_break <= 0;\n      else if (E_cpu_addr_en)\n          xbrk_break <= xbrk_break_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_traceon <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_traceon <= xbrk_ton_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_traceoff <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_traceoff <= xbrk_toff_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_trigout <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_trigout <= xbrk_tout_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_goto0 <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_goto0 <= xbrk_goto0_hit;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_xbrk_goto1 <= 0;\n      else if (E_cpu_addr_en)\n          E_xbrk_goto1 <= xbrk_goto1_hit;\n    end\n\n\n  assign xbrk_traceon = 1'b0;\n  assign xbrk_traceoff = 1'b0;\n  assign xbrk_trigout = 1'b0;\n  assign xbrk_goto0 = 1'b0;\n  assign xbrk_goto1 = 1'b0;\n  assign xbrk0_armed = (xbrk_ctrl0[4] & trigger_state_0) ||\n    (xbrk_ctrl0[5] & trigger_state_1);\n\n  assign xbrk1_armed = (xbrk_ctrl1[4] & trigger_state_0) ||\n    (xbrk_ctrl1[5] & trigger_state_1);\n\n  assign xbrk2_armed = (xbrk_ctrl2[4] & trigger_state_0) ||\n    (xbrk_ctrl2[5] & trigger_state_1);\n\n  assign xbrk3_armed = (xbrk_ctrl3[4] & trigger_state_0) ||\n    (xbrk_ctrl3[5] & trigger_state_1);\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_dbrk (\n                                \n                                 E_st_data,\n                                 av_ld_data_aligned_filtered,\n                                 clk,\n                                 d_address,\n                                 d_read,\n                                 d_waitrequest,\n                                 d_write,\n                                 debugack,\n                                 reset_n,\n\n                                \n                                 cpu_d_address,\n                                 cpu_d_read,\n                                 cpu_d_readdata,\n                                 cpu_d_wait,\n                                 cpu_d_write,\n                                 cpu_d_writedata,\n                                 dbrk_break,\n                                 dbrk_goto0,\n                                 dbrk_goto1,\n                                 dbrk_traceme,\n                                 dbrk_traceoff,\n                                 dbrk_traceon,\n                                 dbrk_trigout\n                              )\n;\n\n  output  [ 24: 0] cpu_d_address;\n  output           cpu_d_read;\n  output  [ 31: 0] cpu_d_readdata;\n  output           cpu_d_wait;\n  output           cpu_d_write;\n  output  [ 31: 0] cpu_d_writedata;\n  output           dbrk_break;\n  output           dbrk_goto0;\n  output           dbrk_goto1;\n  output           dbrk_traceme;\n  output           dbrk_traceoff;\n  output           dbrk_traceon;\n  output           dbrk_trigout;\n  input   [ 31: 0] E_st_data;\n  input   [ 31: 0] av_ld_data_aligned_filtered;\n  input            clk;\n  input   [ 24: 0] d_address;\n  input            d_read;\n  input            d_waitrequest;\n  input            d_write;\n  input            debugack;\n  input            reset_n;\n\n  wire    [ 24: 0] cpu_d_address;\n  wire             cpu_d_read;\n  wire    [ 31: 0] cpu_d_readdata;\n  wire             cpu_d_wait;\n  wire             cpu_d_write;\n  wire    [ 31: 0] cpu_d_writedata;\n  wire             dbrk0_armed;\n  wire             dbrk0_break_pulse;\n  wire             dbrk0_goto0;\n  wire             dbrk0_goto1;\n  wire             dbrk0_traceme;\n  wire             dbrk0_traceoff;\n  wire             dbrk0_traceon;\n  wire             dbrk0_trigout;\n  wire             dbrk1_armed;\n  wire             dbrk1_break_pulse;\n  wire             dbrk1_goto0;\n  wire             dbrk1_goto1;\n  wire             dbrk1_traceme;\n  wire             dbrk1_traceoff;\n  wire             dbrk1_traceon;\n  wire             dbrk1_trigout;\n  wire             dbrk2_armed;\n  wire             dbrk2_break_pulse;\n  wire             dbrk2_goto0;\n  wire             dbrk2_goto1;\n  wire             dbrk2_traceme;\n  wire             dbrk2_traceoff;\n  wire             dbrk2_traceon;\n  wire             dbrk2_trigout;\n  wire             dbrk3_armed;\n  wire             dbrk3_break_pulse;\n  wire             dbrk3_goto0;\n  wire             dbrk3_goto1;\n  wire             dbrk3_traceme;\n  wire             dbrk3_traceoff;\n  wire             dbrk3_traceon;\n  wire             dbrk3_trigout;\n  reg              dbrk_break;\n  reg              dbrk_break_pulse;\n  wire    [ 31: 0] dbrk_data;\n  reg              dbrk_goto0;\n  reg              dbrk_goto1;\n  reg              dbrk_traceme;\n  reg              dbrk_traceoff;\n  reg              dbrk_traceon;\n  reg              dbrk_trigout;\n  assign cpu_d_address = d_address;\n  assign cpu_d_readdata = av_ld_data_aligned_filtered;\n  assign cpu_d_read = d_read;\n  assign cpu_d_writedata = E_st_data;\n  assign cpu_d_write = d_write;\n  assign cpu_d_wait = d_waitrequest;\n  assign dbrk_data = cpu_d_write ? cpu_d_writedata : cpu_d_readdata;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          dbrk_break <= 0;\n      else \n        dbrk_break <= dbrk_break   ? ~debugack   \n                : dbrk_break_pulse;\n\n    end\n\n\n  assign dbrk0_armed = 1'b0;\n  assign dbrk0_trigout = 1'b0;\n  assign dbrk0_break_pulse = 1'b0;\n  assign dbrk0_traceoff = 1'b0;\n  assign dbrk0_traceon = 1'b0;\n  assign dbrk0_traceme = 1'b0;\n  assign dbrk0_goto0 = 1'b0;\n  assign dbrk0_goto1 = 1'b0;\n  assign dbrk1_armed = 1'b0;\n  assign dbrk1_trigout = 1'b0;\n  assign dbrk1_break_pulse = 1'b0;\n  assign dbrk1_traceoff = 1'b0;\n  assign dbrk1_traceon = 1'b0;\n  assign dbrk1_traceme = 1'b0;\n  assign dbrk1_goto0 = 1'b0;\n  assign dbrk1_goto1 = 1'b0;\n  assign dbrk2_armed = 1'b0;\n  assign dbrk2_trigout = 1'b0;\n  assign dbrk2_break_pulse = 1'b0;\n  assign dbrk2_traceoff = 1'b0;\n  assign dbrk2_traceon = 1'b0;\n  assign dbrk2_traceme = 1'b0;\n  assign dbrk2_goto0 = 1'b0;\n  assign dbrk2_goto1 = 1'b0;\n  assign dbrk3_armed = 1'b0;\n  assign dbrk3_trigout = 1'b0;\n  assign dbrk3_break_pulse = 1'b0;\n  assign dbrk3_traceoff = 1'b0;\n  assign dbrk3_traceon = 1'b0;\n  assign dbrk3_traceme = 1'b0;\n  assign dbrk3_goto0 = 1'b0;\n  assign dbrk3_goto1 = 1'b0;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          dbrk_trigout <= 0;\n          dbrk_break_pulse <= 0;\n          dbrk_traceoff <= 0;\n          dbrk_traceon <= 0;\n          dbrk_traceme <= 0;\n          dbrk_goto0 <= 0;\n          dbrk_goto1 <= 0;\n        end\n      else \n        begin\n          dbrk_trigout <= dbrk0_trigout | dbrk1_trigout | dbrk2_trigout | dbrk3_trigout;\n          dbrk_break_pulse <= dbrk0_break_pulse | dbrk1_break_pulse | dbrk2_break_pulse | dbrk3_break_pulse;\n          dbrk_traceoff <= dbrk0_traceoff | dbrk1_traceoff | dbrk2_traceoff | dbrk3_traceoff;\n          dbrk_traceon <= dbrk0_traceon | dbrk1_traceon | dbrk2_traceon | dbrk3_traceon;\n          dbrk_traceme <= dbrk0_traceme | dbrk1_traceme | dbrk2_traceme | dbrk3_traceme;\n          dbrk_goto0 <= dbrk0_goto0 | dbrk1_goto0 | dbrk2_goto0 | dbrk3_goto0;\n          dbrk_goto1 <= dbrk0_goto1 | dbrk1_goto1 | dbrk2_goto1 | dbrk3_goto1;\n        end\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_itrace (\n                                  \n                                   clk,\n                                   dbrk_traceoff,\n                                   dbrk_traceon,\n                                   jdo,\n                                   jrst_n,\n                                   take_action_tracectrl,\n                                   trc_enb,\n                                   xbrk_traceoff,\n                                   xbrk_traceon,\n                                   xbrk_wrap_traceoff,\n\n                                  \n                                   dct_buffer,\n                                   dct_count,\n                                   itm,\n                                   trc_ctrl,\n                                   trc_on\n                                )\n;\n\n  output  [ 29: 0] dct_buffer;\n  output  [  3: 0] dct_count;\n  output  [ 35: 0] itm;\n  output  [ 15: 0] trc_ctrl;\n  output           trc_on;\n  input            clk;\n  input            dbrk_traceoff;\n  input            dbrk_traceon;\n  input   [ 15: 0] jdo;\n  input            jrst_n;\n  input            take_action_tracectrl;\n  input            trc_enb;\n  input            xbrk_traceoff;\n  input            xbrk_traceon;\n  input            xbrk_wrap_traceoff;\n\n  wire             advanced_exc_occured;\n  wire             curr_pid;\n  reg     [ 29: 0] dct_buffer ;\n  wire    [  1: 0] dct_code;\n  reg     [  3: 0] dct_count ;\n  wire             dct_is_taken;\n  wire    [ 31: 0] eic_addr;\n  wire    [ 31: 0] exc_addr;\n  wire             instr_retired;\n  wire             is_cond_dct;\n  wire             is_dct;\n  wire             is_exception_no_break;\n  wire             is_external_interrupt;\n  wire             is_fast_tlb_miss_exception;\n  wire             is_idct;\n  reg     [ 35: 0] itm ;\n  wire             not_in_debug_mode;\n  reg              pending_curr_pid ;\n  reg              pending_exc ;\n  reg     [ 31: 0] pending_exc_addr ;\n  reg     [ 31: 0] pending_exc_handler ;\n  reg              pending_exc_record_handler ;\n  reg     [  3: 0] pending_frametype ;\n  reg              pending_prev_pid ;\n  reg              prev_pid ;\n  reg              prev_pid_valid ;\n  wire             record_dct_outcome_in_sync;\n  wire             record_itrace;\n  wire    [ 31: 0] retired_pcb;\n  reg              snapped_curr_pid ;\n  reg              snapped_pid ;\n  reg              snapped_prev_pid ;\n  wire    [  1: 0] sync_code;\n  wire    [  6: 0] sync_interval;\n  reg     [  6: 0] sync_timer ;\n  wire    [  6: 0] sync_timer_next;\n  wire             sync_timer_reached_zero;\n  reg              trc_clear ;\n  wire    [ 15: 0] trc_ctrl;\n  reg     [ 10: 0] trc_ctrl_reg ;\n  wire             trc_on;\n  assign is_cond_dct = 1'b0;\n  assign is_dct = 1'b0;\n  assign dct_is_taken = 1'b0;\n  assign is_idct = 1'b0;\n  assign retired_pcb = 32'b0;\n  assign not_in_debug_mode = 1'b0;\n  assign instr_retired = 1'b0;\n  assign advanced_exc_occured = 1'b0;\n  assign is_exception_no_break = 1'b0;\n  assign is_external_interrupt = 1'b0;\n  assign is_fast_tlb_miss_exception = 1'b0;\n  assign curr_pid = 1'b0;\n  assign exc_addr = 32'b0;\n  assign eic_addr = 32'b0;\n  assign sync_code = trc_ctrl[3 : 2];\n  assign sync_interval = { sync_code[1] & sync_code[0], 1'b0, sync_code[1] & ~sync_code[0], 1'b0, ~sync_code[1] & sync_code[0], 2'b00 };\n  assign sync_timer_reached_zero = sync_timer == 0;\n  assign record_dct_outcome_in_sync = dct_is_taken & sync_timer_reached_zero;\n  assign sync_timer_next = sync_timer_reached_zero ? sync_timer : (sync_timer - 1);\n  assign record_itrace = trc_on & trc_ctrl[4];\n  assign dct_code = {is_cond_dct, dct_is_taken};\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          trc_clear <= 0;\n      else \n        trc_clear <= ~trc_enb & \n                take_action_tracectrl & jdo[4];\n\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          itm <= 0;\n          dct_buffer <= 0;\n          dct_count <= 0;\n          sync_timer <= 0;\n          pending_frametype <= 4'b0000;\n          pending_exc <= 0;\n          pending_exc_addr <= 0;\n          pending_exc_handler <= 0;\n          pending_exc_record_handler <= 0;\n          prev_pid <= 0;\n          prev_pid_valid <= 0;\n          snapped_pid <= 0;\n          snapped_curr_pid <= 0;\n          snapped_prev_pid <= 0;\n          pending_curr_pid <= 0;\n          pending_prev_pid <= 0;\n        end\n      else if (trc_clear || (!0 && !0))\n        begin\n          itm <= 0;\n          dct_buffer <= 0;\n          dct_count <= 0;\n          sync_timer <= 0;\n          pending_frametype <= 4'b0000;\n          pending_exc <= 0;\n          pending_exc_addr <= 0;\n          pending_exc_handler <= 0;\n          pending_exc_record_handler <= 0;\n          prev_pid <= 0;\n          prev_pid_valid <= 0;\n          snapped_pid <= 0;\n          snapped_curr_pid <= 0;\n          snapped_prev_pid <= 0;\n          pending_curr_pid <= 0;\n          pending_prev_pid <= 0;\n        end\n      else \n        begin\n          if (!prev_pid_valid)\n            begin\n              prev_pid <= curr_pid;\n              prev_pid_valid <= 1;\n            end\n          if ((curr_pid != prev_pid) & prev_pid_valid & !snapped_pid)\n            begin\n              snapped_pid <= 1;\n              snapped_curr_pid <= curr_pid;\n              snapped_prev_pid <= prev_pid;\n              prev_pid <= curr_pid;\n              prev_pid_valid <= 1;\n            end\n          if (instr_retired | advanced_exc_occured)\n            begin\n              if (~record_itrace)\n                  pending_frametype <= 4'b1010;\n              else if (is_exception_no_break)\n                begin\n                  pending_exc <= 1;\n                  pending_exc_addr <= exc_addr;\n                  pending_exc_record_handler <= 0;\n                  if (is_external_interrupt)\n                      pending_exc_handler <= eic_addr;\n                  else if (is_fast_tlb_miss_exception)\n                      pending_exc_handler <= 32'h0;\n                  else \n                    pending_exc_handler <= 32'h800020;\n                  pending_frametype <= 4'b0000;\n                end\n              else if (is_idct)\n                  pending_frametype <= 4'b1001;\n              else if (record_dct_outcome_in_sync)\n                  pending_frametype <= 4'b1000;\n              else if (!is_dct & snapped_pid)\n                begin\n                  pending_frametype <= 4'b0011;\n                  pending_curr_pid <= snapped_curr_pid;\n                  pending_prev_pid <= snapped_prev_pid;\n                  snapped_pid <= 0;\n                end\n              else \n                pending_frametype <= 4'b0000;\n              if ((dct_count != 0) & \n             (~record_itrace | \n              is_exception_no_break |\n              is_idct |\n              record_dct_outcome_in_sync |\n              (!is_dct & snapped_pid)))\n                begin\n                  itm <= {4'b0001, dct_buffer, 2'b00};\n                  dct_buffer <= 0;\n                  dct_count <= 0;\n                  sync_timer <= sync_timer_next;\n                end\n              else \n                begin\n                  if (record_itrace & (is_dct & (dct_count != 4'd15)) & ~record_dct_outcome_in_sync & ~advanced_exc_occured)\n                    begin\n                      dct_buffer <= {dct_code, dct_buffer[29 : 2]};\n                      dct_count <= dct_count + 1;\n                    end\n                  if (record_itrace & (\n                  (pending_frametype == 4'b1000) |\n                  (pending_frametype == 4'b1010) |\n                  (pending_frametype == 4'b1001)))\n                    begin\n                      itm <= {pending_frametype, retired_pcb};\n                      sync_timer <= sync_interval;\n                      if (0 &\n                      ((pending_frametype == 4'b1000) | (pending_frametype == 4'b1010)) &\n                      !snapped_pid & prev_pid_valid)\n                        begin\n                          snapped_pid <= 1;\n                          snapped_curr_pid <= curr_pid;\n                          snapped_prev_pid <= prev_pid;\n                        end\n                    end\n                  else if (record_itrace & \n                  0 & (pending_frametype == 4'b0011))\n                      itm <= {4'b0011, 2'b00, pending_prev_pid, 2'b00, pending_curr_pid};\n                  else if (record_itrace & is_dct)\n                    begin\n                      if (dct_count == 4'd15)\n                        begin\n                          itm <= {4'b0001, dct_code, dct_buffer};\n                          dct_buffer <= 0;\n                          dct_count <= 0;\n                          sync_timer <= sync_timer_next;\n                        end\n                      else \n                        itm <= 4'b0000;\n                    end\n                  else \n                    itm <= {4'b0000, 32'b0};\n                end\n            end\n          else if (record_itrace & pending_exc)\n            begin\n              if (pending_exc_record_handler)\n                begin\n                  itm <= {4'b0010, pending_exc_handler[31 : 1], 1'b1};\n                  pending_exc <= 1'b0;\n                  pending_exc_record_handler <= 1'b0;\n                end\n              else \n                begin\n                  itm <= {4'b0010, pending_exc_addr[31 : 1], 1'b0};\n                  pending_exc_record_handler <= 1'b1;\n                end\n            end\n          else \n            itm <= {4'b0000, 32'b0};\n        end\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          trc_ctrl_reg[0] <= 1'b0;\n          trc_ctrl_reg[1] <= 1'b0;\n          trc_ctrl_reg[3 : 2] <= 2'b00;\n          trc_ctrl_reg[4] <= 1'b0;\n          trc_ctrl_reg[7 : 5] <= 3'b000;\n          trc_ctrl_reg[8] <= 0;\n          trc_ctrl_reg[9] <= 1'b0;\n          trc_ctrl_reg[10] <= 1'b0;\n        end\n      else if (take_action_tracectrl)\n        begin\n          trc_ctrl_reg[0] <= jdo[5];\n          trc_ctrl_reg[1] <= jdo[6];\n          trc_ctrl_reg[3 : 2] <= jdo[8 : 7];\n          trc_ctrl_reg[4] <= jdo[9];\n          trc_ctrl_reg[9] <= jdo[14];\n          trc_ctrl_reg[10] <= jdo[2];\n          if (0)\n              trc_ctrl_reg[7 : 5] <= jdo[12 : 10];\n          if (0 & 0)\n              trc_ctrl_reg[8] <= jdo[13];\n        end\n      else if (xbrk_wrap_traceoff)\n        begin\n          trc_ctrl_reg[1] <= 0;\n          trc_ctrl_reg[0] <= 0;\n        end\n      else if (dbrk_traceoff | xbrk_traceoff)\n          trc_ctrl_reg[1] <= 0;\n      else if (trc_ctrl_reg[0] & \n                                  (dbrk_traceon | xbrk_traceon))\n          trc_ctrl_reg[1] <= 1;\n    end\n\n\n  assign trc_ctrl = (0 || 0) ? {6'b000000, trc_ctrl_reg} : 0;\n  assign trc_on = trc_ctrl[1] & (trc_ctrl[9] | not_in_debug_mode);\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_td_mode (\n                                   \n                                    ctrl,\n\n                                   \n                                    td_mode\n                                 )\n;\n\n  output  [  3: 0] td_mode;\n  input   [  8: 0] ctrl;\n\n  wire    [  2: 0] ctrl_bits_for_mux;\n  reg     [  3: 0] td_mode;\n  assign ctrl_bits_for_mux = ctrl[7 : 5];\n  always @(ctrl_bits_for_mux)\n    begin\n      case (ctrl_bits_for_mux)\n      \n          3'b000: begin\n              td_mode = 4'b0000;\n          end \n      \n          3'b001: begin\n              td_mode = 4'b1000;\n          end \n      \n          3'b010: begin\n              td_mode = 4'b0100;\n          end \n      \n          3'b011: begin\n              td_mode = 4'b1100;\n          end \n      \n          3'b100: begin\n              td_mode = 4'b0010;\n          end \n      \n          3'b101: begin\n              td_mode = 4'b1010;\n          end \n      \n          3'b110: begin\n              td_mode = 4'b0101;\n          end \n      \n          3'b111: begin\n              td_mode = 4'b1111;\n          end \n      \n      endcase \n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_dtrace (\n                                  \n                                   clk,\n                                   cpu_d_address,\n                                   cpu_d_read,\n                                   cpu_d_readdata,\n                                   cpu_d_wait,\n                                   cpu_d_write,\n                                   cpu_d_writedata,\n                                   jrst_n,\n                                   trc_ctrl,\n\n                                  \n                                   atm,\n                                   dtm\n                                )\n;\n\n  output  [ 35: 0] atm;\n  output  [ 35: 0] dtm;\n  input            clk;\n  input   [ 24: 0] cpu_d_address;\n  input            cpu_d_read;\n  input   [ 31: 0] cpu_d_readdata;\n  input            cpu_d_wait;\n  input            cpu_d_write;\n  input   [ 31: 0] cpu_d_writedata;\n  input            jrst_n;\n  input   [ 15: 0] trc_ctrl;\n\n  reg     [ 35: 0] atm ;\n  wire    [ 31: 0] cpu_d_address_0_padded;\n  wire    [ 31: 0] cpu_d_readdata_0_padded;\n  wire    [ 31: 0] cpu_d_writedata_0_padded;\n  reg     [ 35: 0] dtm ;\n  wire             record_load_addr;\n  wire             record_load_data;\n  wire             record_store_addr;\n  wire             record_store_data;\n  wire    [  3: 0] td_mode_trc_ctrl;\n  assign cpu_d_writedata_0_padded = cpu_d_writedata | 32'b0;\n  assign cpu_d_readdata_0_padded = cpu_d_readdata | 32'b0;\n  assign cpu_d_address_0_padded = cpu_d_address | 32'b0;\n  \n  CPU_cpu_nios2_oci_td_mode CPU_cpu_nios2_oci_trc_ctrl_td_mode\n    (\n      .ctrl    (trc_ctrl[8 : 0]),\n      .td_mode (td_mode_trc_ctrl)\n    );\n\n  assign {record_load_addr, record_store_addr,\n         record_load_data, record_store_data} = td_mode_trc_ctrl;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          atm <= 0;\n          dtm <= 0;\n        end\n      else if (0)\n        begin\n          if (cpu_d_write & ~cpu_d_wait & record_store_addr)\n              atm <= {4'b0101, cpu_d_address_0_padded};\n          else if (cpu_d_read & ~cpu_d_wait & record_load_addr)\n              atm <= {4'b0100, cpu_d_address_0_padded};\n          else \n            atm <= {4'b0000, cpu_d_address_0_padded};\n          if (cpu_d_write & ~cpu_d_wait & record_store_data)\n              dtm <= {4'b0111, cpu_d_writedata_0_padded};\n          else if (cpu_d_read & ~cpu_d_wait & record_load_data)\n              dtm <= {4'b0110, cpu_d_readdata_0_padded};\n          else \n            dtm <= {4'b0000, cpu_d_readdata_0_padded};\n        end\n      else \n        begin\n          atm <= 0;\n          dtm <= 0;\n        end\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_compute_input_tm_cnt (\n                                                \n                                                 atm_valid,\n                                                 dtm_valid,\n                                                 itm_valid,\n\n                                                \n                                                 compute_input_tm_cnt\n                                              )\n;\n\n  output  [  1: 0] compute_input_tm_cnt;\n  input            atm_valid;\n  input            dtm_valid;\n  input            itm_valid;\n\n  reg     [  1: 0] compute_input_tm_cnt;\n  wire    [  2: 0] switch_for_mux;\n  assign switch_for_mux = {itm_valid, atm_valid, dtm_valid};\n  always @(switch_for_mux)\n    begin\n      case (switch_for_mux)\n      \n          3'b000: begin\n              compute_input_tm_cnt = 0;\n          end \n      \n          3'b001: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b010: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b011: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b100: begin\n              compute_input_tm_cnt = 1;\n          end \n      \n          3'b101: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b110: begin\n              compute_input_tm_cnt = 2;\n          end \n      \n          3'b111: begin\n              compute_input_tm_cnt = 3;\n          end \n      \n      endcase \n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo_wrptr_inc (\n                                          \n                                           ge2_free,\n                                           ge3_free,\n                                           input_tm_cnt,\n\n                                          \n                                           fifo_wrptr_inc\n                                        )\n;\n\n  output  [  3: 0] fifo_wrptr_inc;\n  input            ge2_free;\n  input            ge3_free;\n  input   [  1: 0] input_tm_cnt;\n\n  reg     [  3: 0] fifo_wrptr_inc;\n  always @(ge2_free or ge3_free or input_tm_cnt)\n    begin\n      if (ge3_free & (input_tm_cnt == 3))\n          fifo_wrptr_inc = 3;\n      else if (ge2_free & (input_tm_cnt >= 2))\n          fifo_wrptr_inc = 2;\n      else if (input_tm_cnt >= 1)\n          fifo_wrptr_inc = 1;\n      else \n        fifo_wrptr_inc = 0;\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo_cnt_inc (\n                                        \n                                         empty,\n                                         ge2_free,\n                                         ge3_free,\n                                         input_tm_cnt,\n\n                                        \n                                         fifo_cnt_inc\n                                      )\n;\n\n  output  [  4: 0] fifo_cnt_inc;\n  input            empty;\n  input            ge2_free;\n  input            ge3_free;\n  input   [  1: 0] input_tm_cnt;\n\n  reg     [  4: 0] fifo_cnt_inc;\n  always @(empty or ge2_free or ge3_free or input_tm_cnt)\n    begin\n      if (empty)\n          fifo_cnt_inc = input_tm_cnt[1 : 0];\n      else if (ge3_free & (input_tm_cnt == 3))\n          fifo_cnt_inc = 2;\n      else if (ge2_free & (input_tm_cnt >= 2))\n          fifo_cnt_inc = 1;\n      else if (input_tm_cnt >= 1)\n          fifo_cnt_inc = 0;\n      else \n        fifo_cnt_inc = {5{1'b1}};\n    end\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_fifo (\n                                \n                                 atm,\n                                 clk,\n                                 dbrk_traceme,\n                                 dbrk_traceoff,\n                                 dbrk_traceon,\n                                 dct_buffer,\n                                 dct_count,\n                                 dtm,\n                                 itm,\n                                 jrst_n,\n                                 reset_n,\n                                 test_ending,\n                                 test_has_ended,\n                                 trc_on,\n\n                                \n                                 tw\n                              )\n;\n\n  output  [ 35: 0] tw;\n  input   [ 35: 0] atm;\n  input            clk;\n  input            dbrk_traceme;\n  input            dbrk_traceoff;\n  input            dbrk_traceon;\n  input   [ 29: 0] dct_buffer;\n  input   [  3: 0] dct_count;\n  input   [ 35: 0] dtm;\n  input   [ 35: 0] itm;\n  input            jrst_n;\n  input            reset_n;\n  input            test_ending;\n  input            test_has_ended;\n  input            trc_on;\n\n  wire             atm_valid;\n  wire    [  1: 0] compute_input_tm_cnt;\n  wire             dtm_valid;\n  wire             empty;\n  reg     [ 35: 0] fifo_0;\n  wire             fifo_0_enable;\n  wire    [ 35: 0] fifo_0_mux;\n  reg     [ 35: 0] fifo_1;\n  reg     [ 35: 0] fifo_10;\n  wire             fifo_10_enable;\n  wire    [ 35: 0] fifo_10_mux;\n  reg     [ 35: 0] fifo_11;\n  wire             fifo_11_enable;\n  wire    [ 35: 0] fifo_11_mux;\n  reg     [ 35: 0] fifo_12;\n  wire             fifo_12_enable;\n  wire    [ 35: 0] fifo_12_mux;\n  reg     [ 35: 0] fifo_13;\n  wire             fifo_13_enable;\n  wire    [ 35: 0] fifo_13_mux;\n  reg     [ 35: 0] fifo_14;\n  wire             fifo_14_enable;\n  wire    [ 35: 0] fifo_14_mux;\n  reg     [ 35: 0] fifo_15;\n  wire             fifo_15_enable;\n  wire    [ 35: 0] fifo_15_mux;\n  wire             fifo_1_enable;\n  wire    [ 35: 0] fifo_1_mux;\n  reg     [ 35: 0] fifo_2;\n  wire             fifo_2_enable;\n  wire    [ 35: 0] fifo_2_mux;\n  reg     [ 35: 0] fifo_3;\n  wire             fifo_3_enable;\n  wire    [ 35: 0] fifo_3_mux;\n  reg     [ 35: 0] fifo_4;\n  wire             fifo_4_enable;\n  wire    [ 35: 0] fifo_4_mux;\n  reg     [ 35: 0] fifo_5;\n  wire             fifo_5_enable;\n  wire    [ 35: 0] fifo_5_mux;\n  reg     [ 35: 0] fifo_6;\n  wire             fifo_6_enable;\n  wire    [ 35: 0] fifo_6_mux;\n  reg     [ 35: 0] fifo_7;\n  wire             fifo_7_enable;\n  wire    [ 35: 0] fifo_7_mux;\n  reg     [ 35: 0] fifo_8;\n  wire             fifo_8_enable;\n  wire    [ 35: 0] fifo_8_mux;\n  reg     [ 35: 0] fifo_9;\n  wire             fifo_9_enable;\n  wire    [ 35: 0] fifo_9_mux;\n  reg     [  4: 0] fifo_cnt ;\n  wire    [  4: 0] fifo_cnt_inc;\n  wire    [ 35: 0] fifo_head;\n  reg     [  3: 0] fifo_rdptr ;\n  wire    [ 35: 0] fifo_read_mux;\n  reg     [  3: 0] fifo_wrptr ;\n  wire    [  3: 0] fifo_wrptr_inc;\n  wire    [  3: 0] fifo_wrptr_plus1;\n  wire    [  3: 0] fifo_wrptr_plus2;\n  wire             ge2_free;\n  wire             ge3_free;\n  wire             input_ge1;\n  wire             input_ge2;\n  wire             input_ge3;\n  wire    [  1: 0] input_tm_cnt;\n  wire             itm_valid;\n  reg              overflow_pending ;\n  wire    [ 35: 0] overflow_pending_atm;\n  wire    [ 35: 0] overflow_pending_dtm;\n  wire             trc_this;\n  wire    [ 35: 0] tw;\n  assign trc_this = trc_on | (dbrk_traceon & ~dbrk_traceoff) | dbrk_traceme;\n  assign itm_valid = |itm[35 : 32];\n  assign atm_valid = |atm[35 : 32] & trc_this;\n  assign dtm_valid = |dtm[35 : 32] & trc_this;\n  assign ge2_free = ~fifo_cnt[4];\n  assign ge3_free = ge2_free & ~&fifo_cnt[3 : 0];\n  assign empty = ~|fifo_cnt;\n  assign fifo_wrptr_plus1 = fifo_wrptr + 1;\n  assign fifo_wrptr_plus2 = fifo_wrptr + 2;\n  CPU_cpu_nios2_oci_compute_input_tm_cnt the_CPU_cpu_nios2_oci_compute_input_tm_cnt\n    (\n      .atm_valid            (atm_valid),\n      .compute_input_tm_cnt (compute_input_tm_cnt),\n      .dtm_valid            (dtm_valid),\n      .itm_valid            (itm_valid)\n    );\n\n  assign input_tm_cnt = compute_input_tm_cnt;\n  CPU_cpu_nios2_oci_fifo_wrptr_inc the_CPU_cpu_nios2_oci_fifo_wrptr_inc\n    (\n      .fifo_wrptr_inc (fifo_wrptr_inc),\n      .ge2_free       (ge2_free),\n      .ge3_free       (ge3_free),\n      .input_tm_cnt   (input_tm_cnt)\n    );\n\n  CPU_cpu_nios2_oci_fifo_cnt_inc the_CPU_cpu_nios2_oci_fifo_cnt_inc\n    (\n      .empty        (empty),\n      .fifo_cnt_inc (fifo_cnt_inc),\n      .ge2_free     (ge2_free),\n      .ge3_free     (ge3_free),\n      .input_tm_cnt (input_tm_cnt)\n    );\n\n  CPU_cpu_oci_test_bench the_CPU_cpu_oci_test_bench\n    (\n      .dct_buffer     (dct_buffer),\n      .dct_count      (dct_count),\n      .test_ending    (test_ending),\n      .test_has_ended (test_has_ended)\n    );\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          fifo_rdptr <= 0;\n          fifo_wrptr <= 0;\n          fifo_cnt <= 0;\n          overflow_pending <= 1;\n        end\n      else \n        begin\n          fifo_wrptr <= fifo_wrptr + fifo_wrptr_inc;\n          fifo_cnt <= fifo_cnt + fifo_cnt_inc;\n          if (~empty)\n              fifo_rdptr <= fifo_rdptr + 1;\n          if (~trc_this || (~ge2_free & input_ge2) || (~ge3_free & input_ge3))\n              overflow_pending <= 1;\n          else if (atm_valid | dtm_valid)\n              overflow_pending <= 0;\n        end\n    end\n\n\n  assign fifo_head = fifo_read_mux;\n  assign tw = 0 ?  { (empty ? 4'h0 : fifo_head[35 : 32]),   fifo_head[31 : 0]}  : itm;\n  assign fifo_0_enable = ((fifo_wrptr == 4'd0) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd0) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd0) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_0 <= 0;\n      else if (fifo_0_enable)\n          fifo_0 <= fifo_0_mux;\n    end\n\n\n  assign fifo_0_mux = (((fifo_wrptr == 4'd0) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd0) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd0) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd0) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_1_enable = ((fifo_wrptr == 4'd1) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd1) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd1) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_1 <= 0;\n      else if (fifo_1_enable)\n          fifo_1 <= fifo_1_mux;\n    end\n\n\n  assign fifo_1_mux = (((fifo_wrptr == 4'd1) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd1) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd1) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd1) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_2_enable = ((fifo_wrptr == 4'd2) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd2) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd2) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_2 <= 0;\n      else if (fifo_2_enable)\n          fifo_2 <= fifo_2_mux;\n    end\n\n\n  assign fifo_2_mux = (((fifo_wrptr == 4'd2) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd2) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd2) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd2) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_3_enable = ((fifo_wrptr == 4'd3) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd3) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd3) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_3 <= 0;\n      else if (fifo_3_enable)\n          fifo_3 <= fifo_3_mux;\n    end\n\n\n  assign fifo_3_mux = (((fifo_wrptr == 4'd3) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd3) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd3) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd3) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_4_enable = ((fifo_wrptr == 4'd4) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd4) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd4) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_4 <= 0;\n      else if (fifo_4_enable)\n          fifo_4 <= fifo_4_mux;\n    end\n\n\n  assign fifo_4_mux = (((fifo_wrptr == 4'd4) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd4) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd4) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd4) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_5_enable = ((fifo_wrptr == 4'd5) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd5) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd5) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_5 <= 0;\n      else if (fifo_5_enable)\n          fifo_5 <= fifo_5_mux;\n    end\n\n\n  assign fifo_5_mux = (((fifo_wrptr == 4'd5) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd5) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd5) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd5) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_6_enable = ((fifo_wrptr == 4'd6) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd6) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd6) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_6 <= 0;\n      else if (fifo_6_enable)\n          fifo_6 <= fifo_6_mux;\n    end\n\n\n  assign fifo_6_mux = (((fifo_wrptr == 4'd6) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd6) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd6) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd6) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_7_enable = ((fifo_wrptr == 4'd7) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd7) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd7) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_7 <= 0;\n      else if (fifo_7_enable)\n          fifo_7 <= fifo_7_mux;\n    end\n\n\n  assign fifo_7_mux = (((fifo_wrptr == 4'd7) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd7) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd7) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd7) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_8_enable = ((fifo_wrptr == 4'd8) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd8) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd8) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_8 <= 0;\n      else if (fifo_8_enable)\n          fifo_8 <= fifo_8_mux;\n    end\n\n\n  assign fifo_8_mux = (((fifo_wrptr == 4'd8) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd8) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd8) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd8) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_9_enable = ((fifo_wrptr == 4'd9) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd9) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd9) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_9 <= 0;\n      else if (fifo_9_enable)\n          fifo_9 <= fifo_9_mux;\n    end\n\n\n  assign fifo_9_mux = (((fifo_wrptr == 4'd9) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd9) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd9) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd9) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_10_enable = ((fifo_wrptr == 4'd10) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd10) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd10) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_10 <= 0;\n      else if (fifo_10_enable)\n          fifo_10 <= fifo_10_mux;\n    end\n\n\n  assign fifo_10_mux = (((fifo_wrptr == 4'd10) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd10) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd10) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd10) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_11_enable = ((fifo_wrptr == 4'd11) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd11) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd11) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_11 <= 0;\n      else if (fifo_11_enable)\n          fifo_11 <= fifo_11_mux;\n    end\n\n\n  assign fifo_11_mux = (((fifo_wrptr == 4'd11) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd11) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd11) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd11) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_12_enable = ((fifo_wrptr == 4'd12) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd12) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd12) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_12 <= 0;\n      else if (fifo_12_enable)\n          fifo_12 <= fifo_12_mux;\n    end\n\n\n  assign fifo_12_mux = (((fifo_wrptr == 4'd12) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd12) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd12) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd12) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_13_enable = ((fifo_wrptr == 4'd13) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd13) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd13) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_13 <= 0;\n      else if (fifo_13_enable)\n          fifo_13 <= fifo_13_mux;\n    end\n\n\n  assign fifo_13_mux = (((fifo_wrptr == 4'd13) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd13) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd13) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd13) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_14_enable = ((fifo_wrptr == 4'd14) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd14) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd14) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_14 <= 0;\n      else if (fifo_14_enable)\n          fifo_14 <= fifo_14_mux;\n    end\n\n\n  assign fifo_14_mux = (((fifo_wrptr == 4'd14) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd14) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd14) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd14) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign fifo_15_enable = ((fifo_wrptr == 4'd15) && input_ge1)  || (ge2_free && (fifo_wrptr_plus1== 4'd15) && input_ge2)  ||(ge3_free && (fifo_wrptr_plus2== 4'd15) && input_ge3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          fifo_15 <= 0;\n      else if (fifo_15_enable)\n          fifo_15 <= fifo_15_mux;\n    end\n\n\n  assign fifo_15_mux = (((fifo_wrptr == 4'd15) && itm_valid))? itm :\n    (((fifo_wrptr == 4'd15) && atm_valid))? overflow_pending_atm :\n    (((fifo_wrptr == 4'd15) && dtm_valid))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & itm_valid & atm_valid)))? overflow_pending_atm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & itm_valid & dtm_valid)))? overflow_pending_dtm :\n    (((fifo_wrptr_plus1 == 4'd15) && (ge2_free & atm_valid & dtm_valid)))? overflow_pending_dtm :\n    overflow_pending_dtm;\n\n  assign input_ge1 = |input_tm_cnt;\n  assign input_ge2 = input_tm_cnt[1];\n  assign input_ge3 = &input_tm_cnt;\n  assign overflow_pending_atm = {overflow_pending, atm[34 : 0]};\n  assign overflow_pending_dtm = {overflow_pending, dtm[34 : 0]};\n  assign fifo_read_mux = (fifo_rdptr == 4'd0)? fifo_0 :\n    (fifo_rdptr == 4'd1)? fifo_1 :\n    (fifo_rdptr == 4'd2)? fifo_2 :\n    (fifo_rdptr == 4'd3)? fifo_3 :\n    (fifo_rdptr == 4'd4)? fifo_4 :\n    (fifo_rdptr == 4'd5)? fifo_5 :\n    (fifo_rdptr == 4'd6)? fifo_6 :\n    (fifo_rdptr == 4'd7)? fifo_7 :\n    (fifo_rdptr == 4'd8)? fifo_8 :\n    (fifo_rdptr == 4'd9)? fifo_9 :\n    (fifo_rdptr == 4'd10)? fifo_10 :\n    (fifo_rdptr == 4'd11)? fifo_11 :\n    (fifo_rdptr == 4'd12)? fifo_12 :\n    (fifo_rdptr == 4'd13)? fifo_13 :\n    (fifo_rdptr == 4'd14)? fifo_14 :\n    fifo_15;\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_pib (\n                               \n                                clk,\n                                clkx2,\n                                jrst_n,\n                                tw,\n\n                               \n                                tr_clk,\n                                tr_data\n                             )\n;\n\n  output           tr_clk;\n  output  [ 17: 0] tr_data;\n  input            clk;\n  input            clkx2;\n  input            jrst_n;\n  input   [ 35: 0] tw;\n\n  wire             phase;\n  wire             tr_clk;\n  reg              tr_clk_reg ;\n  wire    [ 17: 0] tr_data;\n  reg     [ 17: 0] tr_data_reg ;\n  reg              x1 ;\n  reg              x2 ;\n  assign phase = x1^x2;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          x1 <= 0;\n      else \n        x1 <= ~x1;\n    end\n\n\n  always @(posedge clkx2 or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          x2 <= 0;\n          tr_clk_reg <= 0;\n          tr_data_reg <= 0;\n        end\n      else \n        begin\n          x2 <= x1;\n          tr_clk_reg <= ~phase;\n          tr_data_reg <= phase ?   tw[17 : 0] :   tw[35 : 18];\n        end\n    end\n\n\n  assign tr_clk = 0 ? tr_clk_reg : 0;\n  assign tr_data = 0 ? tr_data_reg : 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci_im (\n                              \n                               clk,\n                               jdo,\n                               jrst_n,\n                               reset_n,\n                               take_action_tracectrl,\n                               take_action_tracemem_a,\n                               take_action_tracemem_b,\n                               take_no_action_tracemem_a,\n                               trc_ctrl,\n                               tw,\n\n                              \n                               tracemem_on,\n                               tracemem_trcdata,\n                               tracemem_tw,\n                               trc_enb,\n                               trc_im_addr,\n                               trc_wrap,\n                               xbrk_wrap_traceoff\n                            )\n;\n\n  output           tracemem_on;\n  output  [ 35: 0] tracemem_trcdata;\n  output           tracemem_tw;\n  output           trc_enb;\n  output  [  6: 0] trc_im_addr;\n  output           trc_wrap;\n  output           xbrk_wrap_traceoff;\n  input            clk;\n  input   [ 37: 0] jdo;\n  input            jrst_n;\n  input            reset_n;\n  input            take_action_tracectrl;\n  input            take_action_tracemem_a;\n  input            take_action_tracemem_b;\n  input            take_no_action_tracemem_a;\n  input   [ 15: 0] trc_ctrl;\n  input   [ 35: 0] tw;\n\n  wire             tracemem_on;\n  wire    [ 35: 0] tracemem_trcdata;\n  wire             tracemem_tw;\n  wire             trc_enb;\n  reg     [  6: 0] trc_im_addr ;\n  wire    [ 35: 0] trc_im_data;\n  reg     [ 16: 0] trc_jtag_addr ;\n  wire             trc_on_chip;\n  reg              trc_wrap ;\n  wire             tw_valid;\n  wire             xbrk_wrap_traceoff;\n  assign trc_im_data = tw;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n        begin\n          trc_im_addr <= 0;\n          trc_wrap <= 0;\n        end\n      else if (!0)\n        begin\n          trc_im_addr <= 0;\n          trc_wrap <= 0;\n        end\n      else if (take_action_tracectrl && \n                      (jdo[4] | jdo[3]))\n        begin\n          if (jdo[4])\n              trc_im_addr <= 0;\n          if (jdo[3])\n              trc_wrap <= 0;\n        end\n      else if (trc_enb & trc_on_chip & tw_valid)\n        begin\n          trc_im_addr <= trc_im_addr+1;\n          if (&trc_im_addr)\n              trc_wrap <= 1;\n        end\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          trc_jtag_addr <= 0;\n      else if (take_action_tracemem_a ||\n                take_no_action_tracemem_a || \n                take_action_tracemem_b)\n          trc_jtag_addr <= take_action_tracemem_a ? \n                    jdo[35 : 19] : \n                    trc_jtag_addr + 1;\n\n    end\n\n\n  assign trc_enb = trc_ctrl[0];\n  assign trc_on_chip = ~trc_ctrl[8];\n  assign tw_valid = |trc_im_data[35 : 32];\n  assign xbrk_wrap_traceoff = trc_ctrl[10] & trc_wrap;\n  assign tracemem_tw = trc_wrap;\n  assign tracemem_on = trc_enb;\n  assign tracemem_trcdata = 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_performance_monitors \n;\n\n\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu_nios2_oci (\n                           \n                            D_valid,\n                            E_st_data,\n                            E_valid,\n                            F_pc,\n                            address_nxt,\n                            av_ld_data_aligned_filtered,\n                            byteenable_nxt,\n                            clk,\n                            d_address,\n                            d_read,\n                            d_waitrequest,\n                            d_write,\n                            debugaccess_nxt,\n                            hbreak_enabled,\n                            read_nxt,\n                            reset,\n                            reset_n,\n                            reset_req,\n                            test_ending,\n                            test_has_ended,\n                            write_nxt,\n                            writedata_nxt,\n\n                           \n                            jtag_debug_module_debugaccess_to_roms,\n                            oci_hbreak_req,\n                            oci_ienable,\n                            oci_single_step_mode,\n                            readdata,\n                            resetrequest,\n                            waitrequest\n                         )\n;\n\n  output           jtag_debug_module_debugaccess_to_roms;\n  output           oci_hbreak_req;\n  output  [ 31: 0] oci_ienable;\n  output           oci_single_step_mode;\n  output  [ 31: 0] readdata;\n  output           resetrequest;\n  output           waitrequest;\n  input            D_valid;\n  input   [ 31: 0] E_st_data;\n  input            E_valid;\n  input   [ 22: 0] F_pc;\n  input   [  8: 0] address_nxt;\n  input   [ 31: 0] av_ld_data_aligned_filtered;\n  input   [  3: 0] byteenable_nxt;\n  input            clk;\n  input   [ 24: 0] d_address;\n  input            d_read;\n  input            d_waitrequest;\n  input            d_write;\n  input            debugaccess_nxt;\n  input            hbreak_enabled;\n  input            read_nxt;\n  input            reset;\n  input            reset_n;\n  input            reset_req;\n  input            test_ending;\n  input            test_has_ended;\n  input            write_nxt;\n  input   [ 31: 0] writedata_nxt;\n\n  wire    [ 31: 0] MonDReg;\n  reg     [  8: 0] address;\n  wire    [ 35: 0] atm;\n  wire    [ 31: 0] break_readreg;\n  reg     [  3: 0] byteenable;\n  wire             clkx2;\n  wire    [ 24: 0] cpu_d_address;\n  wire             cpu_d_read;\n  wire    [ 31: 0] cpu_d_readdata;\n  wire             cpu_d_wait;\n  wire             cpu_d_write;\n  wire    [ 31: 0] cpu_d_writedata;\n  wire             dbrk_break;\n  wire             dbrk_goto0;\n  wire             dbrk_goto1;\n  wire             dbrk_hit0_latch;\n  wire             dbrk_hit1_latch;\n  wire             dbrk_hit2_latch;\n  wire             dbrk_hit3_latch;\n  wire             dbrk_traceme;\n  wire             dbrk_traceoff;\n  wire             dbrk_traceon;\n  wire             dbrk_trigout;\n  wire    [ 29: 0] dct_buffer;\n  wire    [  3: 0] dct_count;\n  reg              debugaccess;\n  wire             debugack;\n  wire             debugreq;\n  wire    [ 35: 0] dtm;\n  wire             dummy_sink;\n  wire    [ 35: 0] itm;\n  wire    [ 37: 0] jdo;\n  wire             jrst_n;\n  wire             jtag_debug_module_debugaccess_to_roms;\n  wire             monitor_error;\n  wire             monitor_go;\n  wire             monitor_ready;\n  wire             oci_hbreak_req;\n  wire    [ 31: 0] oci_ienable;\n  wire    [ 31: 0] oci_reg_readdata;\n  wire             oci_single_step_mode;\n  wire    [ 31: 0] ociram_readdata;\n  wire             ocireg_ers;\n  wire             ocireg_mrs;\n  reg              read;\n  reg     [ 31: 0] readdata;\n  wire             resetlatch;\n  wire             resetrequest;\n  wire             st_ready_test_idle;\n  wire             take_action_break_a;\n  wire             take_action_break_b;\n  wire             take_action_break_c;\n  wire             take_action_ocimem_a;\n  wire             take_action_ocimem_b;\n  wire             take_action_ocireg;\n  wire             take_action_tracectrl;\n  wire             take_action_tracemem_a;\n  wire             take_action_tracemem_b;\n  wire             take_no_action_break_a;\n  wire             take_no_action_break_b;\n  wire             take_no_action_break_c;\n  wire             take_no_action_ocimem_a;\n  wire             take_no_action_tracemem_a;\n  wire             tr_clk;\n  wire    [ 17: 0] tr_data;\n  wire             tracemem_on;\n  wire    [ 35: 0] tracemem_trcdata;\n  wire             tracemem_tw;\n  wire    [ 15: 0] trc_ctrl;\n  wire             trc_enb;\n  wire    [  6: 0] trc_im_addr;\n  wire             trc_on;\n  wire             trc_wrap;\n  wire             trigbrktype;\n  wire             trigger_state_0;\n  wire             trigger_state_1;\n  wire             trigout;\n  wire    [ 35: 0] tw;\n  wire             waitrequest;\n  reg              write;\n  reg     [ 31: 0] writedata;\n  wire             xbrk_break;\n  wire    [  7: 0] xbrk_ctrl0;\n  wire    [  7: 0] xbrk_ctrl1;\n  wire    [  7: 0] xbrk_ctrl2;\n  wire    [  7: 0] xbrk_ctrl3;\n  wire             xbrk_goto0;\n  wire             xbrk_goto1;\n  wire             xbrk_traceoff;\n  wire             xbrk_traceon;\n  wire             xbrk_trigout;\n  wire             xbrk_wrap_traceoff;\n  CPU_cpu_nios2_oci_debug the_CPU_cpu_nios2_oci_debug\n    (\n      .clk                  (clk),\n      .dbrk_break           (dbrk_break),\n      .debugack             (debugack),\n      .debugreq             (debugreq),\n      .hbreak_enabled       (hbreak_enabled),\n      .jdo                  (jdo),\n      .jrst_n               (jrst_n),\n      .monitor_error        (monitor_error),\n      .monitor_go           (monitor_go),\n      .monitor_ready        (monitor_ready),\n      .oci_hbreak_req       (oci_hbreak_req),\n      .ocireg_ers           (ocireg_ers),\n      .ocireg_mrs           (ocireg_mrs),\n      .reset                (reset),\n      .resetlatch           (resetlatch),\n      .resetrequest         (resetrequest),\n      .st_ready_test_idle   (st_ready_test_idle),\n      .take_action_ocimem_a (take_action_ocimem_a),\n      .take_action_ocireg   (take_action_ocireg),\n      .xbrk_break           (xbrk_break)\n    );\n\n  CPU_cpu_nios2_ocimem the_CPU_cpu_nios2_ocimem\n    (\n      .MonDReg                 (MonDReg),\n      .address                 (address),\n      .byteenable              (byteenable),\n      .clk                     (clk),\n      .debugaccess             (debugaccess),\n      .jdo                     (jdo),\n      .jrst_n                  (jrst_n),\n      .ociram_readdata         (ociram_readdata),\n      .read                    (read),\n      .reset_req               (reset_req),\n      .take_action_ocimem_a    (take_action_ocimem_a),\n      .take_action_ocimem_b    (take_action_ocimem_b),\n      .take_no_action_ocimem_a (take_no_action_ocimem_a),\n      .waitrequest             (waitrequest),\n      .write                   (write),\n      .writedata               (writedata)\n    );\n\n  CPU_cpu_nios2_avalon_reg the_CPU_cpu_nios2_avalon_reg\n    (\n      .address              (address),\n      .clk                  (clk),\n      .debugaccess          (debugaccess),\n      .monitor_error        (monitor_error),\n      .monitor_go           (monitor_go),\n      .monitor_ready        (monitor_ready),\n      .oci_ienable          (oci_ienable),\n      .oci_reg_readdata     (oci_reg_readdata),\n      .oci_single_step_mode (oci_single_step_mode),\n      .ocireg_ers           (ocireg_ers),\n      .ocireg_mrs           (ocireg_mrs),\n      .reset_n              (reset_n),\n      .take_action_ocireg   (take_action_ocireg),\n      .write                (write),\n      .writedata            (writedata)\n    );\n\n  CPU_cpu_nios2_oci_break the_CPU_cpu_nios2_oci_break\n    (\n      .break_readreg          (break_readreg),\n      .clk                    (clk),\n      .dbrk_break             (dbrk_break),\n      .dbrk_goto0             (dbrk_goto0),\n      .dbrk_goto1             (dbrk_goto1),\n      .dbrk_hit0_latch        (dbrk_hit0_latch),\n      .dbrk_hit1_latch        (dbrk_hit1_latch),\n      .dbrk_hit2_latch        (dbrk_hit2_latch),\n      .dbrk_hit3_latch        (dbrk_hit3_latch),\n      .jdo                    (jdo),\n      .jrst_n                 (jrst_n),\n      .reset_n                (reset_n),\n      .take_action_break_a    (take_action_break_a),\n      .take_action_break_b    (take_action_break_b),\n      .take_action_break_c    (take_action_break_c),\n      .take_no_action_break_a (take_no_action_break_a),\n      .take_no_action_break_b (take_no_action_break_b),\n      .take_no_action_break_c (take_no_action_break_c),\n      .trigbrktype            (trigbrktype),\n      .trigger_state_0        (trigger_state_0),\n      .trigger_state_1        (trigger_state_1),\n      .xbrk_ctrl0             (xbrk_ctrl0),\n      .xbrk_ctrl1             (xbrk_ctrl1),\n      .xbrk_ctrl2             (xbrk_ctrl2),\n      .xbrk_ctrl3             (xbrk_ctrl3),\n      .xbrk_goto0             (xbrk_goto0),\n      .xbrk_goto1             (xbrk_goto1)\n    );\n\n  CPU_cpu_nios2_oci_xbrk the_CPU_cpu_nios2_oci_xbrk\n    (\n      .D_valid         (D_valid),\n      .E_valid         (E_valid),\n      .F_pc            (F_pc),\n      .clk             (clk),\n      .reset_n         (reset_n),\n      .trigger_state_0 (trigger_state_0),\n      .trigger_state_1 (trigger_state_1),\n      .xbrk_break      (xbrk_break),\n      .xbrk_ctrl0      (xbrk_ctrl0),\n      .xbrk_ctrl1      (xbrk_ctrl1),\n      .xbrk_ctrl2      (xbrk_ctrl2),\n      .xbrk_ctrl3      (xbrk_ctrl3),\n      .xbrk_goto0      (xbrk_goto0),\n      .xbrk_goto1      (xbrk_goto1),\n      .xbrk_traceoff   (xbrk_traceoff),\n      .xbrk_traceon    (xbrk_traceon),\n      .xbrk_trigout    (xbrk_trigout)\n    );\n\n  CPU_cpu_nios2_oci_dbrk the_CPU_cpu_nios2_oci_dbrk\n    (\n      .E_st_data                   (E_st_data),\n      .av_ld_data_aligned_filtered (av_ld_data_aligned_filtered),\n      .clk                         (clk),\n      .cpu_d_address               (cpu_d_address),\n      .cpu_d_read                  (cpu_d_read),\n      .cpu_d_readdata              (cpu_d_readdata),\n      .cpu_d_wait                  (cpu_d_wait),\n      .cpu_d_write                 (cpu_d_write),\n      .cpu_d_writedata             (cpu_d_writedata),\n      .d_address                   (d_address),\n      .d_read                      (d_read),\n      .d_waitrequest               (d_waitrequest),\n      .d_write                     (d_write),\n      .dbrk_break                  (dbrk_break),\n      .dbrk_goto0                  (dbrk_goto0),\n      .dbrk_goto1                  (dbrk_goto1),\n      .dbrk_traceme                (dbrk_traceme),\n      .dbrk_traceoff               (dbrk_traceoff),\n      .dbrk_traceon                (dbrk_traceon),\n      .dbrk_trigout                (dbrk_trigout),\n      .debugack                    (debugack),\n      .reset_n                     (reset_n)\n    );\n\n  CPU_cpu_nios2_oci_itrace the_CPU_cpu_nios2_oci_itrace\n    (\n      .clk                   (clk),\n      .dbrk_traceoff         (dbrk_traceoff),\n      .dbrk_traceon          (dbrk_traceon),\n      .dct_buffer            (dct_buffer),\n      .dct_count             (dct_count),\n      .itm                   (itm),\n      .jdo                   (jdo),\n      .jrst_n                (jrst_n),\n      .take_action_tracectrl (take_action_tracectrl),\n      .trc_ctrl              (trc_ctrl),\n      .trc_enb               (trc_enb),\n      .trc_on                (trc_on),\n      .xbrk_traceoff         (xbrk_traceoff),\n      .xbrk_traceon          (xbrk_traceon),\n      .xbrk_wrap_traceoff    (xbrk_wrap_traceoff)\n    );\n\n  CPU_cpu_nios2_oci_dtrace the_CPU_cpu_nios2_oci_dtrace\n    (\n      .atm             (atm),\n      .clk             (clk),\n      .cpu_d_address   (cpu_d_address),\n      .cpu_d_read      (cpu_d_read),\n      .cpu_d_readdata  (cpu_d_readdata),\n      .cpu_d_wait      (cpu_d_wait),\n      .cpu_d_write     (cpu_d_write),\n      .cpu_d_writedata (cpu_d_writedata),\n      .dtm             (dtm),\n      .jrst_n          (jrst_n),\n      .trc_ctrl        (trc_ctrl)\n    );\n\n  CPU_cpu_nios2_oci_fifo the_CPU_cpu_nios2_oci_fifo\n    (\n      .atm            (atm),\n      .clk            (clk),\n      .dbrk_traceme   (dbrk_traceme),\n      .dbrk_traceoff  (dbrk_traceoff),\n      .dbrk_traceon   (dbrk_traceon),\n      .dct_buffer     (dct_buffer),\n      .dct_count      (dct_count),\n      .dtm            (dtm),\n      .itm            (itm),\n      .jrst_n         (jrst_n),\n      .reset_n        (reset_n),\n      .test_ending    (test_ending),\n      .test_has_ended (test_has_ended),\n      .trc_on         (trc_on),\n      .tw             (tw)\n    );\n\n  CPU_cpu_nios2_oci_pib the_CPU_cpu_nios2_oci_pib\n    (\n      .clk     (clk),\n      .clkx2   (clkx2),\n      .jrst_n  (jrst_n),\n      .tr_clk  (tr_clk),\n      .tr_data (tr_data),\n      .tw      (tw)\n    );\n\n  CPU_cpu_nios2_oci_im the_CPU_cpu_nios2_oci_im\n    (\n      .clk                       (clk),\n      .jdo                       (jdo),\n      .jrst_n                    (jrst_n),\n      .reset_n                   (reset_n),\n      .take_action_tracectrl     (take_action_tracectrl),\n      .take_action_tracemem_a    (take_action_tracemem_a),\n      .take_action_tracemem_b    (take_action_tracemem_b),\n      .take_no_action_tracemem_a (take_no_action_tracemem_a),\n      .tracemem_on               (tracemem_on),\n      .tracemem_trcdata          (tracemem_trcdata),\n      .tracemem_tw               (tracemem_tw),\n      .trc_ctrl                  (trc_ctrl),\n      .trc_enb                   (trc_enb),\n      .trc_im_addr               (trc_im_addr),\n      .trc_wrap                  (trc_wrap),\n      .tw                        (tw),\n      .xbrk_wrap_traceoff        (xbrk_wrap_traceoff)\n    );\n\n  assign trigout = dbrk_trigout | xbrk_trigout;\n  assign jtag_debug_module_debugaccess_to_roms = debugack;\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          address <= 0;\n      else \n        address <= address_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          byteenable <= 0;\n      else \n        byteenable <= byteenable_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          writedata <= 0;\n      else \n        writedata <= writedata_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          debugaccess <= 0;\n      else \n        debugaccess <= debugaccess_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          read <= 0;\n      else \n        read <= read ? waitrequest : read_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          write <= 0;\n      else \n        write <= write ? waitrequest : write_nxt;\n    end\n\n\n  always @(posedge clk or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          readdata <= 0;\n      else \n        readdata <= address[8] ? oci_reg_readdata : ociram_readdata;\n    end\n\n\n  CPU_cpu_jtag_debug_module_wrapper the_CPU_cpu_jtag_debug_module_wrapper\n    (\n      .MonDReg                   (MonDReg),\n      .break_readreg             (break_readreg),\n      .clk                       (clk),\n      .dbrk_hit0_latch           (dbrk_hit0_latch),\n      .dbrk_hit1_latch           (dbrk_hit1_latch),\n      .dbrk_hit2_latch           (dbrk_hit2_latch),\n      .dbrk_hit3_latch           (dbrk_hit3_latch),\n      .debugack                  (debugack),\n      .jdo                       (jdo),\n      .jrst_n                    (jrst_n),\n      .monitor_error             (monitor_error),\n      .monitor_ready             (monitor_ready),\n      .reset_n                   (reset_n),\n      .resetlatch                (resetlatch),\n      .st_ready_test_idle        (st_ready_test_idle),\n      .take_action_break_a       (take_action_break_a),\n      .take_action_break_b       (take_action_break_b),\n      .take_action_break_c       (take_action_break_c),\n      .take_action_ocimem_a      (take_action_ocimem_a),\n      .take_action_ocimem_b      (take_action_ocimem_b),\n      .take_action_tracectrl     (take_action_tracectrl),\n      .take_action_tracemem_a    (take_action_tracemem_a),\n      .take_action_tracemem_b    (take_action_tracemem_b),\n      .take_no_action_break_a    (take_no_action_break_a),\n      .take_no_action_break_b    (take_no_action_break_b),\n      .take_no_action_break_c    (take_no_action_break_c),\n      .take_no_action_ocimem_a   (take_no_action_ocimem_a),\n      .take_no_action_tracemem_a (take_no_action_tracemem_a),\n      .tracemem_on               (tracemem_on),\n      .tracemem_trcdata          (tracemem_trcdata),\n      .tracemem_tw               (tracemem_tw),\n      .trc_im_addr               (trc_im_addr),\n      .trc_on                    (trc_on),\n      .trc_wrap                  (trc_wrap),\n      .trigbrktype               (trigbrktype),\n      .trigger_state_1           (trigger_state_1)\n    );\n\n  \n  assign dummy_sink = tr_clk |\n    tr_data |\n    trigout |\n    debugack;\n\n  assign debugreq = 0;\n  assign clkx2 = 0;\n\nendmodule\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule CPU_cpu (\n                 \n                  clk,\n                  d_irq,\n                  d_readdata,\n                  d_waitrequest,\n                  i_readdata,\n                  i_waitrequest,\n                  jtag_debug_module_address,\n                  jtag_debug_module_byteenable,\n                  jtag_debug_module_debugaccess,\n                  jtag_debug_module_read,\n                  jtag_debug_module_write,\n                  jtag_debug_module_writedata,\n                  reset_n,\n                  reset_req,\n\n                 \n                  d_address,\n                  d_byteenable,\n                  d_read,\n                  d_write,\n                  d_writedata,\n                  i_address,\n                  i_read,\n                  jtag_debug_module_debugaccess_to_roms,\n                  jtag_debug_module_readdata,\n                  jtag_debug_module_resetrequest,\n                  jtag_debug_module_waitrequest,\n                  no_ci_readra\n               )\n;\n\n  output  [ 24: 0] d_address;\n  output  [  3: 0] d_byteenable;\n  output           d_read;\n  output           d_write;\n  output  [ 31: 0] d_writedata;\n  output  [ 24: 0] i_address;\n  output           i_read;\n  output           jtag_debug_module_debugaccess_to_roms;\n  output  [ 31: 0] jtag_debug_module_readdata;\n  output           jtag_debug_module_resetrequest;\n  output           jtag_debug_module_waitrequest;\n  output           no_ci_readra;\n  input            clk;\n  input   [ 31: 0] d_irq;\n  input   [ 31: 0] d_readdata;\n  input            d_waitrequest;\n  input   [ 31: 0] i_readdata;\n  input            i_waitrequest;\n  input   [  8: 0] jtag_debug_module_address;\n  input   [  3: 0] jtag_debug_module_byteenable;\n  input            jtag_debug_module_debugaccess;\n  input            jtag_debug_module_read;\n  input            jtag_debug_module_write;\n  input   [ 31: 0] jtag_debug_module_writedata;\n  input            reset_n;\n  input            reset_req;\n\n  wire    [  1: 0] D_compare_op;\n  wire             D_ctrl_alu_force_xor;\n  wire             D_ctrl_alu_signed_comparison;\n  wire             D_ctrl_alu_subtract;\n  wire             D_ctrl_b_is_dst;\n  wire             D_ctrl_br;\n  wire             D_ctrl_br_cmp;\n  wire             D_ctrl_br_uncond;\n  wire             D_ctrl_break;\n  wire             D_ctrl_crst;\n  wire             D_ctrl_custom;\n  wire             D_ctrl_custom_multi;\n  wire             D_ctrl_exception;\n  wire             D_ctrl_force_src2_zero;\n  wire             D_ctrl_hi_imm16;\n  wire             D_ctrl_ignore_dst;\n  wire             D_ctrl_implicit_dst_eretaddr;\n  wire             D_ctrl_implicit_dst_retaddr;\n  wire             D_ctrl_jmp_direct;\n  wire             D_ctrl_jmp_indirect;\n  wire             D_ctrl_ld;\n  wire             D_ctrl_ld_io;\n  wire             D_ctrl_ld_non_io;\n  wire             D_ctrl_ld_signed;\n  wire             D_ctrl_logic;\n  wire             D_ctrl_rdctl_inst;\n  wire             D_ctrl_retaddr;\n  wire             D_ctrl_rot_right;\n  wire             D_ctrl_shift_logical;\n  wire             D_ctrl_shift_right_arith;\n  wire             D_ctrl_shift_rot;\n  wire             D_ctrl_shift_rot_right;\n  wire             D_ctrl_src2_choose_imm;\n  wire             D_ctrl_st;\n  wire             D_ctrl_uncond_cti_non_br;\n  wire             D_ctrl_unsigned_lo_imm16;\n  wire             D_ctrl_wrctl_inst;\n  wire    [  4: 0] D_dst_regnum;\n  wire    [ 55: 0] D_inst;\n  reg     [ 31: 0] D_iw ;\n  wire    [  4: 0] D_iw_a;\n  wire    [  4: 0] D_iw_b;\n  wire    [  4: 0] D_iw_c;\n  wire    [  2: 0] D_iw_control_regnum;\n  wire    [  7: 0] D_iw_custom_n;\n  wire             D_iw_custom_readra;\n  wire             D_iw_custom_readrb;\n  wire             D_iw_custom_writerc;\n  wire    [ 15: 0] D_iw_imm16;\n  wire    [ 25: 0] D_iw_imm26;\n  wire    [  4: 0] D_iw_imm5;\n  wire    [  1: 0] D_iw_memsz;\n  wire    [  5: 0] D_iw_op;\n  wire    [  5: 0] D_iw_opx;\n  wire    [  4: 0] D_iw_shift_imm5;\n  wire    [  4: 0] D_iw_trap_break_imm5;\n  wire    [ 22: 0] D_jmp_direct_target_waddr;\n  wire    [  1: 0] D_logic_op;\n  wire    [  1: 0] D_logic_op_raw;\n  wire             D_mem16;\n  wire             D_mem32;\n  wire             D_mem8;\n  wire             D_op_add;\n  wire             D_op_addi;\n  wire             D_op_and;\n  wire             D_op_andhi;\n  wire             D_op_andi;\n  wire             D_op_beq;\n  wire             D_op_bge;\n  wire             D_op_bgeu;\n  wire             D_op_blt;\n  wire             D_op_bltu;\n  wire             D_op_bne;\n  wire             D_op_br;\n  wire             D_op_break;\n  wire             D_op_bret;\n  wire             D_op_call;\n  wire             D_op_callr;\n  wire             D_op_cmpeq;\n  wire             D_op_cmpeqi;\n  wire             D_op_cmpge;\n  wire             D_op_cmpgei;\n  wire             D_op_cmpgeu;\n  wire             D_op_cmpgeui;\n  wire             D_op_cmplt;\n  wire             D_op_cmplti;\n  wire             D_op_cmpltu;\n  wire             D_op_cmpltui;\n  wire             D_op_cmpne;\n  wire             D_op_cmpnei;\n  wire             D_op_crst;\n  wire             D_op_custom;\n  wire             D_op_div;\n  wire             D_op_divu;\n  wire             D_op_eret;\n  wire             D_op_flushd;\n  wire             D_op_flushda;\n  wire             D_op_flushi;\n  wire             D_op_flushp;\n  wire             D_op_hbreak;\n  wire             D_op_initd;\n  wire             D_op_initda;\n  wire             D_op_initi;\n  wire             D_op_intr;\n  wire             D_op_jmp;\n  wire             D_op_jmpi;\n  wire             D_op_ldb;\n  wire             D_op_ldbio;\n  wire             D_op_ldbu;\n  wire             D_op_ldbuio;\n  wire             D_op_ldh;\n  wire             D_op_ldhio;\n  wire             D_op_ldhu;\n  wire             D_op_ldhuio;\n  wire             D_op_ldl;\n  wire             D_op_ldw;\n  wire             D_op_ldwio;\n  wire             D_op_mul;\n  wire             D_op_muli;\n  wire             D_op_mulxss;\n  wire             D_op_mulxsu;\n  wire             D_op_mulxuu;\n  wire             D_op_nextpc;\n  wire             D_op_nor;\n  wire             D_op_opx;\n  wire             D_op_or;\n  wire             D_op_orhi;\n  wire             D_op_ori;\n  wire             D_op_rdctl;\n  wire             D_op_rdprs;\n  wire             D_op_ret;\n  wire             D_op_rol;\n  wire             D_op_roli;\n  wire             D_op_ror;\n  wire             D_op_rsv02;\n  wire             D_op_rsv09;\n  wire             D_op_rsv10;\n  wire             D_op_rsv17;\n  wire             D_op_rsv18;\n  wire             D_op_rsv25;\n  wire             D_op_rsv26;\n  wire             D_op_rsv33;\n  wire             D_op_rsv34;\n  wire             D_op_rsv41;\n  wire             D_op_rsv42;\n  wire             D_op_rsv49;\n  wire             D_op_rsv57;\n  wire             D_op_rsv61;\n  wire             D_op_rsv62;\n  wire             D_op_rsv63;\n  wire             D_op_rsvx00;\n  wire             D_op_rsvx10;\n  wire             D_op_rsvx15;\n  wire             D_op_rsvx17;\n  wire             D_op_rsvx21;\n  wire             D_op_rsvx25;\n  wire             D_op_rsvx33;\n  wire             D_op_rsvx34;\n  wire             D_op_rsvx35;\n  wire             D_op_rsvx42;\n  wire             D_op_rsvx43;\n  wire             D_op_rsvx44;\n  wire             D_op_rsvx47;\n  wire             D_op_rsvx50;\n  wire             D_op_rsvx51;\n  wire             D_op_rsvx55;\n  wire             D_op_rsvx56;\n  wire             D_op_rsvx60;\n  wire             D_op_rsvx63;\n  wire             D_op_sll;\n  wire             D_op_slli;\n  wire             D_op_sra;\n  wire             D_op_srai;\n  wire             D_op_srl;\n  wire             D_op_srli;\n  wire             D_op_stb;\n  wire             D_op_stbio;\n  wire             D_op_stc;\n  wire             D_op_sth;\n  wire             D_op_sthio;\n  wire             D_op_stw;\n  wire             D_op_stwio;\n  wire             D_op_sub;\n  wire             D_op_sync;\n  wire             D_op_trap;\n  wire             D_op_wrctl;\n  wire             D_op_wrprs;\n  wire             D_op_xor;\n  wire             D_op_xorhi;\n  wire             D_op_xori;\n  reg              D_valid;\n  wire    [ 55: 0] D_vinst;\n  wire             D_wr_dst_reg;\n  wire    [ 31: 0] E_alu_result;\n  reg              E_alu_sub;\n  wire    [ 32: 0] E_arith_result;\n  wire    [ 31: 0] E_arith_src1;\n  wire    [ 31: 0] E_arith_src2;\n  wire             E_ci_multi_stall;\n  wire    [ 31: 0] E_ci_result;\n  wire             E_cmp_result;\n  wire    [ 31: 0] E_control_rd_data;\n  wire             E_eq;\n  reg              E_invert_arith_src_msb;\n  wire             E_ld_stall;\n  wire    [ 31: 0] E_logic_result;\n  wire             E_logic_result_is_0;\n  wire             E_lt;\n  wire    [ 24: 0] E_mem_baddr;\n  wire    [  3: 0] E_mem_byte_en;\n  reg              E_new_inst;\n  reg     [  4: 0] E_shift_rot_cnt;\n  wire    [  4: 0] E_shift_rot_cnt_nxt;\n  wire             E_shift_rot_done;\n  wire             E_shift_rot_fill_bit;\n  reg     [ 31: 0] E_shift_rot_result;\n  wire    [ 31: 0] E_shift_rot_result_nxt;\n  wire             E_shift_rot_stall;\n  reg     [ 31: 0] E_src1;\n  reg     [ 31: 0] E_src2;\n  wire    [ 31: 0] E_st_data;\n  wire             E_st_stall;\n  wire             E_stall;\n  reg              E_valid;\n  wire    [ 55: 0] E_vinst;\n  wire             E_wrctl_bstatus;\n  wire             E_wrctl_estatus;\n  wire             E_wrctl_ienable;\n  wire             E_wrctl_status;\n  wire    [ 31: 0] F_av_iw;\n  wire    [  4: 0] F_av_iw_a;\n  wire    [  4: 0] F_av_iw_b;\n  wire    [  4: 0] F_av_iw_c;\n  wire    [  2: 0] F_av_iw_control_regnum;\n  wire    [  7: 0] F_av_iw_custom_n;\n  wire             F_av_iw_custom_readra;\n  wire             F_av_iw_custom_readrb;\n  wire             F_av_iw_custom_writerc;\n  wire    [ 15: 0] F_av_iw_imm16;\n  wire    [ 25: 0] F_av_iw_imm26;\n  wire    [  4: 0] F_av_iw_imm5;\n  wire    [  1: 0] F_av_iw_memsz;\n  wire    [  5: 0] F_av_iw_op;\n  wire    [  5: 0] F_av_iw_opx;\n  wire    [  4: 0] F_av_iw_shift_imm5;\n  wire    [  4: 0] F_av_iw_trap_break_imm5;\n  wire             F_av_mem16;\n  wire             F_av_mem32;\n  wire             F_av_mem8;\n  wire    [ 55: 0] F_inst;\n  wire    [ 31: 0] F_iw;\n  wire    [  4: 0] F_iw_a;\n  wire    [  4: 0] F_iw_b;\n  wire    [  4: 0] F_iw_c;\n  wire    [  2: 0] F_iw_control_regnum;\n  wire    [  7: 0] F_iw_custom_n;\n  wire             F_iw_custom_readra;\n  wire             F_iw_custom_readrb;\n  wire             F_iw_custom_writerc;\n  wire    [ 15: 0] F_iw_imm16;\n  wire    [ 25: 0] F_iw_imm26;\n  wire    [  4: 0] F_iw_imm5;\n  wire    [  1: 0] F_iw_memsz;\n  wire    [  5: 0] F_iw_op;\n  wire    [  5: 0] F_iw_opx;\n  wire    [  4: 0] F_iw_shift_imm5;\n  wire    [  4: 0] F_iw_trap_break_imm5;\n  wire             F_mem16;\n  wire             F_mem32;\n  wire             F_mem8;\n  wire             F_op_add;\n  wire             F_op_addi;\n  wire             F_op_and;\n  wire             F_op_andhi;\n  wire             F_op_andi;\n  wire             F_op_beq;\n  wire             F_op_bge;\n  wire             F_op_bgeu;\n  wire             F_op_blt;\n  wire             F_op_bltu;\n  wire             F_op_bne;\n  wire             F_op_br;\n  wire             F_op_break;\n  wire             F_op_bret;\n  wire             F_op_call;\n  wire             F_op_callr;\n  wire             F_op_cmpeq;\n  wire             F_op_cmpeqi;\n  wire             F_op_cmpge;\n  wire             F_op_cmpgei;\n  wire             F_op_cmpgeu;\n  wire             F_op_cmpgeui;\n  wire             F_op_cmplt;\n  wire             F_op_cmplti;\n  wire             F_op_cmpltu;\n  wire             F_op_cmpltui;\n  wire             F_op_cmpne;\n  wire             F_op_cmpnei;\n  wire             F_op_crst;\n  wire             F_op_custom;\n  wire             F_op_div;\n  wire             F_op_divu;\n  wire             F_op_eret;\n  wire             F_op_flushd;\n  wire             F_op_flushda;\n  wire             F_op_flushi;\n  wire             F_op_flushp;\n  wire             F_op_hbreak;\n  wire             F_op_initd;\n  wire             F_op_initda;\n  wire             F_op_initi;\n  wire             F_op_intr;\n  wire             F_op_jmp;\n  wire             F_op_jmpi;\n  wire             F_op_ldb;\n  wire             F_op_ldbio;\n  wire             F_op_ldbu;\n  wire             F_op_ldbuio;\n  wire             F_op_ldh;\n  wire             F_op_ldhio;\n  wire             F_op_ldhu;\n  wire             F_op_ldhuio;\n  wire             F_op_ldl;\n  wire             F_op_ldw;\n  wire             F_op_ldwio;\n  wire             F_op_mul;\n  wire             F_op_muli;\n  wire             F_op_mulxss;\n  wire             F_op_mulxsu;\n  wire             F_op_mulxuu;\n  wire             F_op_nextpc;\n  wire             F_op_nor;\n  wire             F_op_opx;\n  wire             F_op_or;\n  wire             F_op_orhi;\n  wire             F_op_ori;\n  wire             F_op_rdctl;\n  wire             F_op_rdprs;\n  wire             F_op_ret;\n  wire             F_op_rol;\n  wire             F_op_roli;\n  wire             F_op_ror;\n  wire             F_op_rsv02;\n  wire             F_op_rsv09;\n  wire             F_op_rsv10;\n  wire             F_op_rsv17;\n  wire             F_op_rsv18;\n  wire             F_op_rsv25;\n  wire             F_op_rsv26;\n  wire             F_op_rsv33;\n  wire             F_op_rsv34;\n  wire             F_op_rsv41;\n  wire             F_op_rsv42;\n  wire             F_op_rsv49;\n  wire             F_op_rsv57;\n  wire             F_op_rsv61;\n  wire             F_op_rsv62;\n  wire             F_op_rsv63;\n  wire             F_op_rsvx00;\n  wire             F_op_rsvx10;\n  wire             F_op_rsvx15;\n  wire             F_op_rsvx17;\n  wire             F_op_rsvx21;\n  wire             F_op_rsvx25;\n  wire             F_op_rsvx33;\n  wire             F_op_rsvx34;\n  wire             F_op_rsvx35;\n  wire             F_op_rsvx42;\n  wire             F_op_rsvx43;\n  wire             F_op_rsvx44;\n  wire             F_op_rsvx47;\n  wire             F_op_rsvx50;\n  wire             F_op_rsvx51;\n  wire             F_op_rsvx55;\n  wire             F_op_rsvx56;\n  wire             F_op_rsvx60;\n  wire             F_op_rsvx63;\n  wire             F_op_sll;\n  wire             F_op_slli;\n  wire             F_op_sra;\n  wire             F_op_srai;\n  wire             F_op_srl;\n  wire             F_op_srli;\n  wire             F_op_stb;\n  wire             F_op_stbio;\n  wire             F_op_stc;\n  wire             F_op_sth;\n  wire             F_op_sthio;\n  wire             F_op_stw;\n  wire             F_op_stwio;\n  wire             F_op_sub;\n  wire             F_op_sync;\n  wire             F_op_trap;\n  wire             F_op_wrctl;\n  wire             F_op_wrprs;\n  wire             F_op_xor;\n  wire             F_op_xorhi;\n  wire             F_op_xori;\n  reg     [ 22: 0] F_pc ;\n  wire             F_pc_en;\n  wire    [ 22: 0] F_pc_no_crst_nxt;\n  wire    [ 22: 0] F_pc_nxt;\n  wire    [ 22: 0] F_pc_plus_one;\n  wire    [  1: 0] F_pc_sel_nxt;\n  wire    [ 24: 0] F_pcb;\n  wire    [ 24: 0] F_pcb_nxt;\n  wire    [ 24: 0] F_pcb_plus_four;\n  wire             F_valid;\n  wire    [ 55: 0] F_vinst;\n  reg     [  1: 0] R_compare_op;\n  reg              R_ctrl_alu_force_xor;\n  wire             R_ctrl_alu_force_xor_nxt;\n  reg              R_ctrl_alu_signed_comparison;\n  wire             R_ctrl_alu_signed_comparison_nxt;\n  reg              R_ctrl_alu_subtract;\n  wire             R_ctrl_alu_subtract_nxt;\n  reg              R_ctrl_b_is_dst;\n  wire             R_ctrl_b_is_dst_nxt;\n  reg              R_ctrl_br;\n  reg              R_ctrl_br_cmp;\n  wire             R_ctrl_br_cmp_nxt;\n  wire             R_ctrl_br_nxt;\n  reg              R_ctrl_br_uncond;\n  wire             R_ctrl_br_uncond_nxt;\n  reg              R_ctrl_break;\n  wire             R_ctrl_break_nxt;\n  reg              R_ctrl_crst;\n  wire             R_ctrl_crst_nxt;\n  reg              R_ctrl_custom;\n  reg              R_ctrl_custom_multi;\n  wire             R_ctrl_custom_multi_nxt;\n  wire             R_ctrl_custom_nxt;\n  reg              R_ctrl_exception;\n  wire             R_ctrl_exception_nxt;\n  reg              R_ctrl_force_src2_zero;\n  wire             R_ctrl_force_src2_zero_nxt;\n  reg              R_ctrl_hi_imm16;\n  wire             R_ctrl_hi_imm16_nxt;\n  reg              R_ctrl_ignore_dst;\n  wire             R_ctrl_ignore_dst_nxt;\n  reg              R_ctrl_implicit_dst_eretaddr;\n  wire             R_ctrl_implicit_dst_eretaddr_nxt;\n  reg              R_ctrl_implicit_dst_retaddr;\n  wire             R_ctrl_implicit_dst_retaddr_nxt;\n  reg              R_ctrl_jmp_direct;\n  wire             R_ctrl_jmp_direct_nxt;\n  reg              R_ctrl_jmp_indirect;\n  wire             R_ctrl_jmp_indirect_nxt;\n  reg              R_ctrl_ld;\n  reg              R_ctrl_ld_io;\n  wire             R_ctrl_ld_io_nxt;\n  reg              R_ctrl_ld_non_io;\n  wire             R_ctrl_ld_non_io_nxt;\n  wire             R_ctrl_ld_nxt;\n  reg              R_ctrl_ld_signed;\n  wire             R_ctrl_ld_signed_nxt;\n  reg              R_ctrl_logic;\n  wire             R_ctrl_logic_nxt;\n  reg              R_ctrl_rdctl_inst;\n  wire             R_ctrl_rdctl_inst_nxt;\n  reg              R_ctrl_retaddr;\n  wire             R_ctrl_retaddr_nxt;\n  reg              R_ctrl_rot_right;\n  wire             R_ctrl_rot_right_nxt;\n  reg              R_ctrl_shift_logical;\n  wire             R_ctrl_shift_logical_nxt;\n  reg              R_ctrl_shift_right_arith;\n  wire             R_ctrl_shift_right_arith_nxt;\n  reg              R_ctrl_shift_rot;\n  wire             R_ctrl_shift_rot_nxt;\n  reg              R_ctrl_shift_rot_right;\n  wire             R_ctrl_shift_rot_right_nxt;\n  reg              R_ctrl_src2_choose_imm;\n  wire             R_ctrl_src2_choose_imm_nxt;\n  reg              R_ctrl_st;\n  wire             R_ctrl_st_nxt;\n  reg              R_ctrl_uncond_cti_non_br;\n  wire             R_ctrl_uncond_cti_non_br_nxt;\n  reg              R_ctrl_unsigned_lo_imm16;\n  wire             R_ctrl_unsigned_lo_imm16_nxt;\n  reg              R_ctrl_wrctl_inst;\n  wire             R_ctrl_wrctl_inst_nxt;\n  reg     [  4: 0] R_dst_regnum ;\n  wire             R_en;\n  reg     [  1: 0] R_logic_op;\n  wire    [ 31: 0] R_rf_a;\n  wire    [ 31: 0] R_rf_b;\n  wire    [ 31: 0] R_src1;\n  wire    [ 31: 0] R_src2;\n  wire    [ 15: 0] R_src2_hi;\n  wire    [ 15: 0] R_src2_lo;\n  reg              R_src2_use_imm;\n  wire    [  7: 0] R_stb_data;\n  wire    [ 15: 0] R_sth_data;\n  reg              R_valid;\n  wire    [ 55: 0] R_vinst;\n  reg              R_wr_dst_reg;\n  reg     [ 31: 0] W_alu_result;\n  wire             W_br_taken;\n  reg              W_bstatus_reg;\n  wire             W_bstatus_reg_inst_nxt;\n  wire             W_bstatus_reg_nxt;\n  reg              W_cmp_result;\n  reg     [ 31: 0] W_control_rd_data;\n  wire    [ 31: 0] W_cpuid_reg;\n  reg              W_estatus_reg;\n  wire             W_estatus_reg_inst_nxt;\n  wire             W_estatus_reg_nxt;\n  reg     [ 31: 0] W_ienable_reg;\n  wire    [ 31: 0] W_ienable_reg_nxt;\n  reg     [ 31: 0] W_ipending_reg;\n  wire    [ 31: 0] W_ipending_reg_nxt;\n  wire    [ 24: 0] W_mem_baddr;\n  wire    [ 31: 0] W_rf_wr_data;\n  wire             W_rf_wren;\n  wire             W_status_reg;\n  reg              W_status_reg_pie;\n  wire             W_status_reg_pie_inst_nxt;\n  wire             W_status_reg_pie_nxt;\n  reg              W_valid ;\n  wire    [ 55: 0] W_vinst;\n  wire    [ 31: 0] W_wr_data;\n  wire    [ 31: 0] W_wr_data_non_zero;\n  wire             av_fill_bit;\n  reg     [  1: 0] av_ld_align_cycle;\n  wire    [  1: 0] av_ld_align_cycle_nxt;\n  wire             av_ld_align_one_more_cycle;\n  reg              av_ld_aligning_data;\n  wire             av_ld_aligning_data_nxt;\n  reg     [  7: 0] av_ld_byte0_data;\n  wire    [  7: 0] av_ld_byte0_data_nxt;\n  reg     [  7: 0] av_ld_byte1_data;\n  wire             av_ld_byte1_data_en;\n  wire    [  7: 0] av_ld_byte1_data_nxt;\n  reg     [  7: 0] av_ld_byte2_data;\n  wire    [  7: 0] av_ld_byte2_data_nxt;\n  reg     [  7: 0] av_ld_byte3_data;\n  wire    [  7: 0] av_ld_byte3_data_nxt;\n  wire    [ 31: 0] av_ld_data_aligned_filtered;\n  wire    [ 31: 0] av_ld_data_aligned_unfiltered;\n  wire             av_ld_done;\n  wire             av_ld_extend;\n  wire             av_ld_getting_data;\n  wire             av_ld_rshift8;\n  reg              av_ld_waiting_for_data;\n  wire             av_ld_waiting_for_data_nxt;\n  wire             av_sign_bit;\n  wire    [ 24: 0] d_address;\n  reg     [  3: 0] d_byteenable;\n  reg              d_read;\n  wire             d_read_nxt;\n  reg              d_write;\n  wire             d_write_nxt;\n  reg     [ 31: 0] d_writedata;\n  reg              hbreak_enabled;\n  reg              hbreak_pending;\n  wire             hbreak_pending_nxt;\n  wire             hbreak_req;\n  wire    [ 24: 0] i_address;\n  reg              i_read;\n  wire             i_read_nxt;\n  wire    [ 31: 0] iactive;\n  wire             intr_req;\n  wire             jtag_debug_module_clk;\n  wire             jtag_debug_module_debugaccess_to_roms;\n  wire    [ 31: 0] jtag_debug_module_readdata;\n  wire             jtag_debug_module_reset;\n  wire             jtag_debug_module_resetrequest;\n  wire             jtag_debug_module_waitrequest;\n  wire             no_ci_readra;\n  wire             oci_hbreak_req;\n  wire    [ 31: 0] oci_ienable;\n  wire             oci_single_step_mode;\n  wire             oci_tb_hbreak_req;\n  wire             test_ending;\n  wire             test_has_ended;\n  reg              wait_for_one_post_bret_inst;\n  \n  CPU_cpu_test_bench the_CPU_cpu_test_bench\n    (\n      .D_iw                          (D_iw),\n      .D_iw_op                       (D_iw_op),\n      .D_iw_opx                      (D_iw_opx),\n      .D_valid                       (D_valid),\n      .E_valid                       (E_valid),\n      .F_pcb                         (F_pcb),\n      .F_valid                       (F_valid),\n      .R_ctrl_ld                     (R_ctrl_ld),\n      .R_ctrl_ld_non_io              (R_ctrl_ld_non_io),\n      .R_dst_regnum                  (R_dst_regnum),\n      .R_wr_dst_reg                  (R_wr_dst_reg),\n      .W_valid                       (W_valid),\n      .W_vinst                       (W_vinst),\n      .W_wr_data                     (W_wr_data),\n      .av_ld_data_aligned_filtered   (av_ld_data_aligned_filtered),\n      .av_ld_data_aligned_unfiltered (av_ld_data_aligned_unfiltered),\n      .clk                           (clk),\n      .d_address                     (d_address),\n      .d_byteenable                  (d_byteenable),\n      .d_read                        (d_read),\n      .d_write                       (d_write),\n      .i_address                     (i_address),\n      .i_read                        (i_read),\n      .i_readdata                    (i_readdata),\n      .i_waitrequest                 (i_waitrequest),\n      .reset_n                       (reset_n),\n      .test_has_ended                (test_has_ended)\n    );\n\n  assign F_av_iw_a = F_av_iw[31 : 27];\n  assign F_av_iw_b = F_av_iw[26 : 22];\n  assign F_av_iw_c = F_av_iw[21 : 17];\n  assign F_av_iw_custom_n = F_av_iw[13 : 6];\n  assign F_av_iw_custom_readra = F_av_iw[16];\n  assign F_av_iw_custom_readrb = F_av_iw[15];\n  assign F_av_iw_custom_writerc = F_av_iw[14];\n  assign F_av_iw_opx = F_av_iw[16 : 11];\n  assign F_av_iw_op = F_av_iw[5 : 0];\n  assign F_av_iw_shift_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_trap_break_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_imm5 = F_av_iw[10 : 6];\n  assign F_av_iw_imm16 = F_av_iw[21 : 6];\n  assign F_av_iw_imm26 = F_av_iw[31 : 6];\n  assign F_av_iw_memsz = F_av_iw[4 : 3];\n  assign F_av_iw_control_regnum = F_av_iw[8 : 6];\n  assign F_av_mem8 = F_av_iw_memsz == 2'b00;\n  assign F_av_mem16 = F_av_iw_memsz == 2'b01;\n  assign F_av_mem32 = F_av_iw_memsz[1] == 1'b1;\n  assign F_iw_a = F_iw[31 : 27];\n  assign F_iw_b = F_iw[26 : 22];\n  assign F_iw_c = F_iw[21 : 17];\n  assign F_iw_custom_n = F_iw[13 : 6];\n  assign F_iw_custom_readra = F_iw[16];\n  assign F_iw_custom_readrb = F_iw[15];\n  assign F_iw_custom_writerc = F_iw[14];\n  assign F_iw_opx = F_iw[16 : 11];\n  assign F_iw_op = F_iw[5 : 0];\n  assign F_iw_shift_imm5 = F_iw[10 : 6];\n  assign F_iw_trap_break_imm5 = F_iw[10 : 6];\n  assign F_iw_imm5 = F_iw[10 : 6];\n  assign F_iw_imm16 = F_iw[21 : 6];\n  assign F_iw_imm26 = F_iw[31 : 6];\n  assign F_iw_memsz = F_iw[4 : 3];\n  assign F_iw_control_regnum = F_iw[8 : 6];\n  assign F_mem8 = F_iw_memsz == 2'b00;\n  assign F_mem16 = F_iw_memsz == 2'b01;\n  assign F_mem32 = F_iw_memsz[1] == 1'b1;\n  assign D_iw_a = D_iw[31 : 27];\n  assign D_iw_b = D_iw[26 : 22];\n  assign D_iw_c = D_iw[21 : 17];\n  assign D_iw_custom_n = D_iw[13 : 6];\n  assign D_iw_custom_readra = D_iw[16];\n  assign D_iw_custom_readrb = D_iw[15];\n  assign D_iw_custom_writerc = D_iw[14];\n  assign D_iw_opx = D_iw[16 : 11];\n  assign D_iw_op = D_iw[5 : 0];\n  assign D_iw_shift_imm5 = D_iw[10 : 6];\n  assign D_iw_trap_break_imm5 = D_iw[10 : 6];\n  assign D_iw_imm5 = D_iw[10 : 6];\n  assign D_iw_imm16 = D_iw[21 : 6];\n  assign D_iw_imm26 = D_iw[31 : 6];\n  assign D_iw_memsz = D_iw[4 : 3];\n  assign D_iw_control_regnum = D_iw[8 : 6];\n  assign D_mem8 = D_iw_memsz == 2'b00;\n  assign D_mem16 = D_iw_memsz == 2'b01;\n  assign D_mem32 = D_iw_memsz[1] == 1'b1;\n  assign F_op_call = F_iw_op == 0;\n  assign F_op_jmpi = F_iw_op == 1;\n  assign F_op_ldbu = F_iw_op == 3;\n  assign F_op_addi = F_iw_op == 4;\n  assign F_op_stb = F_iw_op == 5;\n  assign F_op_br = F_iw_op == 6;\n  assign F_op_ldb = F_iw_op == 7;\n  assign F_op_cmpgei = F_iw_op == 8;\n  assign F_op_ldhu = F_iw_op == 11;\n  assign F_op_andi = F_iw_op == 12;\n  assign F_op_sth = F_iw_op == 13;\n  assign F_op_bge = F_iw_op == 14;\n  assign F_op_ldh = F_iw_op == 15;\n  assign F_op_cmplti = F_iw_op == 16;\n  assign F_op_initda = F_iw_op == 19;\n  assign F_op_ori = F_iw_op == 20;\n  assign F_op_stw = F_iw_op == 21;\n  assign F_op_blt = F_iw_op == 22;\n  assign F_op_ldw = F_iw_op == 23;\n  assign F_op_cmpnei = F_iw_op == 24;\n  assign F_op_flushda = F_iw_op == 27;\n  assign F_op_xori = F_iw_op == 28;\n  assign F_op_stc = F_iw_op == 29;\n  assign F_op_bne = F_iw_op == 30;\n  assign F_op_ldl = F_iw_op == 31;\n  assign F_op_cmpeqi = F_iw_op == 32;\n  assign F_op_ldbuio = F_iw_op == 35;\n  assign F_op_muli = F_iw_op == 36;\n  assign F_op_stbio = F_iw_op == 37;\n  assign F_op_beq = F_iw_op == 38;\n  assign F_op_ldbio = F_iw_op == 39;\n  assign F_op_cmpgeui = F_iw_op == 40;\n  assign F_op_ldhuio = F_iw_op == 43;\n  assign F_op_andhi = F_iw_op == 44;\n  assign F_op_sthio = F_iw_op == 45;\n  assign F_op_bgeu = F_iw_op == 46;\n  assign F_op_ldhio = F_iw_op == 47;\n  assign F_op_cmpltui = F_iw_op == 48;\n  assign F_op_initd = F_iw_op == 51;\n  assign F_op_orhi = F_iw_op == 52;\n  assign F_op_stwio = F_iw_op == 53;\n  assign F_op_bltu = F_iw_op == 54;\n  assign F_op_ldwio = F_iw_op == 55;\n  assign F_op_rdprs = F_iw_op == 56;\n  assign F_op_flushd = F_iw_op == 59;\n  assign F_op_xorhi = F_iw_op == 60;\n  assign F_op_rsv02 = F_iw_op == 2;\n  assign F_op_rsv09 = F_iw_op == 9;\n  assign F_op_rsv10 = F_iw_op == 10;\n  assign F_op_rsv17 = F_iw_op == 17;\n  assign F_op_rsv18 = F_iw_op == 18;\n  assign F_op_rsv25 = F_iw_op == 25;\n  assign F_op_rsv26 = F_iw_op == 26;\n  assign F_op_rsv33 = F_iw_op == 33;\n  assign F_op_rsv34 = F_iw_op == 34;\n  assign F_op_rsv41 = F_iw_op == 41;\n  assign F_op_rsv42 = F_iw_op == 42;\n  assign F_op_rsv49 = F_iw_op == 49;\n  assign F_op_rsv57 = F_iw_op == 57;\n  assign F_op_rsv61 = F_iw_op == 61;\n  assign F_op_rsv62 = F_iw_op == 62;\n  assign F_op_rsv63 = F_iw_op == 63;\n  assign F_op_eret = F_op_opx & (F_iw_opx == 1);\n  assign F_op_roli = F_op_opx & (F_iw_opx == 2);\n  assign F_op_rol = F_op_opx & (F_iw_opx == 3);\n  assign F_op_flushp = F_op_opx & (F_iw_opx == 4);\n  assign F_op_ret = F_op_opx & (F_iw_opx == 5);\n  assign F_op_nor = F_op_opx & (F_iw_opx == 6);\n  assign F_op_mulxuu = F_op_opx & (F_iw_opx == 7);\n  assign F_op_cmpge = F_op_opx & (F_iw_opx == 8);\n  assign F_op_bret = F_op_opx & (F_iw_opx == 9);\n  assign F_op_ror = F_op_opx & (F_iw_opx == 11);\n  assign F_op_flushi = F_op_opx & (F_iw_opx == 12);\n  assign F_op_jmp = F_op_opx & (F_iw_opx == 13);\n  assign F_op_and = F_op_opx & (F_iw_opx == 14);\n  assign F_op_cmplt = F_op_opx & (F_iw_opx == 16);\n  assign F_op_slli = F_op_opx & (F_iw_opx == 18);\n  assign F_op_sll = F_op_opx & (F_iw_opx == 19);\n  assign F_op_wrprs = F_op_opx & (F_iw_opx == 20);\n  assign F_op_or = F_op_opx & (F_iw_opx == 22);\n  assign F_op_mulxsu = F_op_opx & (F_iw_opx == 23);\n  assign F_op_cmpne = F_op_opx & (F_iw_opx == 24);\n  assign F_op_srli = F_op_opx & (F_iw_opx == 26);\n  assign F_op_srl = F_op_opx & (F_iw_opx == 27);\n  assign F_op_nextpc = F_op_opx & (F_iw_opx == 28);\n  assign F_op_callr = F_op_opx & (F_iw_opx == 29);\n  assign F_op_xor = F_op_opx & (F_iw_opx == 30);\n  assign F_op_mulxss = F_op_opx & (F_iw_opx == 31);\n  assign F_op_cmpeq = F_op_opx & (F_iw_opx == 32);\n  assign F_op_divu = F_op_opx & (F_iw_opx == 36);\n  assign F_op_div = F_op_opx & (F_iw_opx == 37);\n  assign F_op_rdctl = F_op_opx & (F_iw_opx == 38);\n  assign F_op_mul = F_op_opx & (F_iw_opx == 39);\n  assign F_op_cmpgeu = F_op_opx & (F_iw_opx == 40);\n  assign F_op_initi = F_op_opx & (F_iw_opx == 41);\n  assign F_op_trap = F_op_opx & (F_iw_opx == 45);\n  assign F_op_wrctl = F_op_opx & (F_iw_opx == 46);\n  assign F_op_cmpltu = F_op_opx & (F_iw_opx == 48);\n  assign F_op_add = F_op_opx & (F_iw_opx == 49);\n  assign F_op_break = F_op_opx & (F_iw_opx == 52);\n  assign F_op_hbreak = F_op_opx & (F_iw_opx == 53);\n  assign F_op_sync = F_op_opx & (F_iw_opx == 54);\n  assign F_op_sub = F_op_opx & (F_iw_opx == 57);\n  assign F_op_srai = F_op_opx & (F_iw_opx == 58);\n  assign F_op_sra = F_op_opx & (F_iw_opx == 59);\n  assign F_op_intr = F_op_opx & (F_iw_opx == 61);\n  assign F_op_crst = F_op_opx & (F_iw_opx == 62);\n  assign F_op_rsvx00 = F_op_opx & (F_iw_opx == 0);\n  assign F_op_rsvx10 = F_op_opx & (F_iw_opx == 10);\n  assign F_op_rsvx15 = F_op_opx & (F_iw_opx == 15);\n  assign F_op_rsvx17 = F_op_opx & (F_iw_opx == 17);\n  assign F_op_rsvx21 = F_op_opx & (F_iw_opx == 21);\n  assign F_op_rsvx25 = F_op_opx & (F_iw_opx == 25);\n  assign F_op_rsvx33 = F_op_opx & (F_iw_opx == 33);\n  assign F_op_rsvx34 = F_op_opx & (F_iw_opx == 34);\n  assign F_op_rsvx35 = F_op_opx & (F_iw_opx == 35);\n  assign F_op_rsvx42 = F_op_opx & (F_iw_opx == 42);\n  assign F_op_rsvx43 = F_op_opx & (F_iw_opx == 43);\n  assign F_op_rsvx44 = F_op_opx & (F_iw_opx == 44);\n  assign F_op_rsvx47 = F_op_opx & (F_iw_opx == 47);\n  assign F_op_rsvx50 = F_op_opx & (F_iw_opx == 50);\n  assign F_op_rsvx51 = F_op_opx & (F_iw_opx == 51);\n  assign F_op_rsvx55 = F_op_opx & (F_iw_opx == 55);\n  assign F_op_rsvx56 = F_op_opx & (F_iw_opx == 56);\n  assign F_op_rsvx60 = F_op_opx & (F_iw_opx == 60);\n  assign F_op_rsvx63 = F_op_opx & (F_iw_opx == 63);\n  assign F_op_opx = F_iw_op == 58;\n  assign F_op_custom = F_iw_op == 50;\n  assign D_op_call = D_iw_op == 0;\n  assign D_op_jmpi = D_iw_op == 1;\n  assign D_op_ldbu = D_iw_op == 3;\n  assign D_op_addi = D_iw_op == 4;\n  assign D_op_stb = D_iw_op == 5;\n  assign D_op_br = D_iw_op == 6;\n  assign D_op_ldb = D_iw_op == 7;\n  assign D_op_cmpgei = D_iw_op == 8;\n  assign D_op_ldhu = D_iw_op == 11;\n  assign D_op_andi = D_iw_op == 12;\n  assign D_op_sth = D_iw_op == 13;\n  assign D_op_bge = D_iw_op == 14;\n  assign D_op_ldh = D_iw_op == 15;\n  assign D_op_cmplti = D_iw_op == 16;\n  assign D_op_initda = D_iw_op == 19;\n  assign D_op_ori = D_iw_op == 20;\n  assign D_op_stw = D_iw_op == 21;\n  assign D_op_blt = D_iw_op == 22;\n  assign D_op_ldw = D_iw_op == 23;\n  assign D_op_cmpnei = D_iw_op == 24;\n  assign D_op_flushda = D_iw_op == 27;\n  assign D_op_xori = D_iw_op == 28;\n  assign D_op_stc = D_iw_op == 29;\n  assign D_op_bne = D_iw_op == 30;\n  assign D_op_ldl = D_iw_op == 31;\n  assign D_op_cmpeqi = D_iw_op == 32;\n  assign D_op_ldbuio = D_iw_op == 35;\n  assign D_op_muli = D_iw_op == 36;\n  assign D_op_stbio = D_iw_op == 37;\n  assign D_op_beq = D_iw_op == 38;\n  assign D_op_ldbio = D_iw_op == 39;\n  assign D_op_cmpgeui = D_iw_op == 40;\n  assign D_op_ldhuio = D_iw_op == 43;\n  assign D_op_andhi = D_iw_op == 44;\n  assign D_op_sthio = D_iw_op == 45;\n  assign D_op_bgeu = D_iw_op == 46;\n  assign D_op_ldhio = D_iw_op == 47;\n  assign D_op_cmpltui = D_iw_op == 48;\n  assign D_op_initd = D_iw_op == 51;\n  assign D_op_orhi = D_iw_op == 52;\n  assign D_op_stwio = D_iw_op == 53;\n  assign D_op_bltu = D_iw_op == 54;\n  assign D_op_ldwio = D_iw_op == 55;\n  assign D_op_rdprs = D_iw_op == 56;\n  assign D_op_flushd = D_iw_op == 59;\n  assign D_op_xorhi = D_iw_op == 60;\n  assign D_op_rsv02 = D_iw_op == 2;\n  assign D_op_rsv09 = D_iw_op == 9;\n  assign D_op_rsv10 = D_iw_op == 10;\n  assign D_op_rsv17 = D_iw_op == 17;\n  assign D_op_rsv18 = D_iw_op == 18;\n  assign D_op_rsv25 = D_iw_op == 25;\n  assign D_op_rsv26 = D_iw_op == 26;\n  assign D_op_rsv33 = D_iw_op == 33;\n  assign D_op_rsv34 = D_iw_op == 34;\n  assign D_op_rsv41 = D_iw_op == 41;\n  assign D_op_rsv42 = D_iw_op == 42;\n  assign D_op_rsv49 = D_iw_op == 49;\n  assign D_op_rsv57 = D_iw_op == 57;\n  assign D_op_rsv61 = D_iw_op == 61;\n  assign D_op_rsv62 = D_iw_op == 62;\n  assign D_op_rsv63 = D_iw_op == 63;\n  assign D_op_eret = D_op_opx & (D_iw_opx == 1);\n  assign D_op_roli = D_op_opx & (D_iw_opx == 2);\n  assign D_op_rol = D_op_opx & (D_iw_opx == 3);\n  assign D_op_flushp = D_op_opx & (D_iw_opx == 4);\n  assign D_op_ret = D_op_opx & (D_iw_opx == 5);\n  assign D_op_nor = D_op_opx & (D_iw_opx == 6);\n  assign D_op_mulxuu = D_op_opx & (D_iw_opx == 7);\n  assign D_op_cmpge = D_op_opx & (D_iw_opx == 8);\n  assign D_op_bret = D_op_opx & (D_iw_opx == 9);\n  assign D_op_ror = D_op_opx & (D_iw_opx == 11);\n  assign D_op_flushi = D_op_opx & (D_iw_opx == 12);\n  assign D_op_jmp = D_op_opx & (D_iw_opx == 13);\n  assign D_op_and = D_op_opx & (D_iw_opx == 14);\n  assign D_op_cmplt = D_op_opx & (D_iw_opx == 16);\n  assign D_op_slli = D_op_opx & (D_iw_opx == 18);\n  assign D_op_sll = D_op_opx & (D_iw_opx == 19);\n  assign D_op_wrprs = D_op_opx & (D_iw_opx == 20);\n  assign D_op_or = D_op_opx & (D_iw_opx == 22);\n  assign D_op_mulxsu = D_op_opx & (D_iw_opx == 23);\n  assign D_op_cmpne = D_op_opx & (D_iw_opx == 24);\n  assign D_op_srli = D_op_opx & (D_iw_opx == 26);\n  assign D_op_srl = D_op_opx & (D_iw_opx == 27);\n  assign D_op_nextpc = D_op_opx & (D_iw_opx == 28);\n  assign D_op_callr = D_op_opx & (D_iw_opx == 29);\n  assign D_op_xor = D_op_opx & (D_iw_opx == 30);\n  assign D_op_mulxss = D_op_opx & (D_iw_opx == 31);\n  assign D_op_cmpeq = D_op_opx & (D_iw_opx == 32);\n  assign D_op_divu = D_op_opx & (D_iw_opx == 36);\n  assign D_op_div = D_op_opx & (D_iw_opx == 37);\n  assign D_op_rdctl = D_op_opx & (D_iw_opx == 38);\n  assign D_op_mul = D_op_opx & (D_iw_opx == 39);\n  assign D_op_cmpgeu = D_op_opx & (D_iw_opx == 40);\n  assign D_op_initi = D_op_opx & (D_iw_opx == 41);\n  assign D_op_trap = D_op_opx & (D_iw_opx == 45);\n  assign D_op_wrctl = D_op_opx & (D_iw_opx == 46);\n  assign D_op_cmpltu = D_op_opx & (D_iw_opx == 48);\n  assign D_op_add = D_op_opx & (D_iw_opx == 49);\n  assign D_op_break = D_op_opx & (D_iw_opx == 52);\n  assign D_op_hbreak = D_op_opx & (D_iw_opx == 53);\n  assign D_op_sync = D_op_opx & (D_iw_opx == 54);\n  assign D_op_sub = D_op_opx & (D_iw_opx == 57);\n  assign D_op_srai = D_op_opx & (D_iw_opx == 58);\n  assign D_op_sra = D_op_opx & (D_iw_opx == 59);\n  assign D_op_intr = D_op_opx & (D_iw_opx == 61);\n  assign D_op_crst = D_op_opx & (D_iw_opx == 62);\n  assign D_op_rsvx00 = D_op_opx & (D_iw_opx == 0);\n  assign D_op_rsvx10 = D_op_opx & (D_iw_opx == 10);\n  assign D_op_rsvx15 = D_op_opx & (D_iw_opx == 15);\n  assign D_op_rsvx17 = D_op_opx & (D_iw_opx == 17);\n  assign D_op_rsvx21 = D_op_opx & (D_iw_opx == 21);\n  assign D_op_rsvx25 = D_op_opx & (D_iw_opx == 25);\n  assign D_op_rsvx33 = D_op_opx & (D_iw_opx == 33);\n  assign D_op_rsvx34 = D_op_opx & (D_iw_opx == 34);\n  assign D_op_rsvx35 = D_op_opx & (D_iw_opx == 35);\n  assign D_op_rsvx42 = D_op_opx & (D_iw_opx == 42);\n  assign D_op_rsvx43 = D_op_opx & (D_iw_opx == 43);\n  assign D_op_rsvx44 = D_op_opx & (D_iw_opx == 44);\n  assign D_op_rsvx47 = D_op_opx & (D_iw_opx == 47);\n  assign D_op_rsvx50 = D_op_opx & (D_iw_opx == 50);\n  assign D_op_rsvx51 = D_op_opx & (D_iw_opx == 51);\n  assign D_op_rsvx55 = D_op_opx & (D_iw_opx == 55);\n  assign D_op_rsvx56 = D_op_opx & (D_iw_opx == 56);\n  assign D_op_rsvx60 = D_op_opx & (D_iw_opx == 60);\n  assign D_op_rsvx63 = D_op_opx & (D_iw_opx == 63);\n  assign D_op_opx = D_iw_op == 58;\n  assign D_op_custom = D_iw_op == 50;\n  assign R_en = 1'b1;\n  assign E_ci_result = 0;\n  \n  assign no_ci_readra = 1'b0;\n  assign E_ci_multi_stall = 1'b0;\n  assign iactive = d_irq[31 : 0] & 32'b00000000000000000000000000000001;\n  assign F_pc_sel_nxt = R_ctrl_exception                          ? 2'b00 :\n    R_ctrl_break                              ? 2'b01 :\n    (W_br_taken | R_ctrl_uncond_cti_non_br)   ? 2'b10 :\n    2'b11;\n\n  assign F_pc_no_crst_nxt = (F_pc_sel_nxt == 2'b00)? 2097160 :\n    (F_pc_sel_nxt == 2'b01)? 4196872 :\n    (F_pc_sel_nxt == 2'b10)? E_arith_result[24 : 2] :\n    F_pc_plus_one;\n\n  assign F_pc_nxt = F_pc_no_crst_nxt;\n  assign F_pcb_nxt = {F_pc_nxt, 2'b00};\n  assign F_pc_en = W_valid;\n  assign F_pc_plus_one = F_pc + 1;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          F_pc <= 2097152;\n      else if (F_pc_en)\n          F_pc <= F_pc_nxt;\n    end\n\n\n  assign F_pcb = {F_pc, 2'b00};\n  assign F_pcb_plus_four = {F_pc_plus_one, 2'b00};\n  assign F_valid = i_read & ~i_waitrequest;\n  assign i_read_nxt = W_valid | (i_read & i_waitrequest);\n  assign i_address = {F_pc, 2'b00};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          i_read <= 1'b1;\n      else \n        i_read <= i_read_nxt;\n    end\n\n\n  assign oci_tb_hbreak_req = oci_hbreak_req;\n  assign hbreak_req = (oci_tb_hbreak_req | hbreak_pending) & hbreak_enabled &  ~(wait_for_one_post_bret_inst & ~W_valid);\n  assign hbreak_pending_nxt = hbreak_pending ? hbreak_enabled \n    : hbreak_req;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          wait_for_one_post_bret_inst <= 1'b0;\n      else \n        wait_for_one_post_bret_inst <= (~hbreak_enabled & oci_single_step_mode) ? 1'b1  : (F_valid | ~oci_single_step_mode) ? 1'b0  : wait_for_one_post_bret_inst;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          hbreak_pending <= 1'b0;\n      else \n        hbreak_pending <= hbreak_pending_nxt;\n    end\n\n\n  assign intr_req = W_status_reg_pie & (W_ipending_reg != 0);\n  assign F_av_iw = i_readdata;\n  assign F_iw = hbreak_req     ? 4040762 :\n    1'b0   ? 127034 :\n    intr_req       ? 3926074 : \n    F_av_iw;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          D_iw <= 0;\n      else if (F_valid)\n          D_iw <= F_iw;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          D_valid <= 0;\n      else \n        D_valid <= F_valid;\n    end\n\n\n  assign D_dst_regnum = D_ctrl_implicit_dst_retaddr    ? 5'd31 : \n    D_ctrl_implicit_dst_eretaddr   ? 5'd29 : \n    D_ctrl_b_is_dst                ? D_iw_b :\n    D_iw_c;\n\n  assign D_wr_dst_reg = (D_dst_regnum != 0) & ~D_ctrl_ignore_dst;\n  assign D_logic_op_raw = D_op_opx ? D_iw_opx[4 : 3] : \n    D_iw_op[4 : 3];\n\n  assign D_logic_op = D_ctrl_alu_force_xor ? 2'b11 : D_logic_op_raw;\n  assign D_compare_op = D_op_opx ? D_iw_opx[4 : 3] : \n    D_iw_op[4 : 3];\n\n  assign D_jmp_direct_target_waddr = D_iw[31 : 6];\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_valid <= 0;\n      else \n        R_valid <= D_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_wr_dst_reg <= 0;\n      else \n        R_wr_dst_reg <= D_wr_dst_reg;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_dst_regnum <= 0;\n      else \n        R_dst_regnum <= D_dst_regnum;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_logic_op <= 0;\n      else \n        R_logic_op <= D_logic_op;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_compare_op <= 0;\n      else \n        R_compare_op <= D_compare_op;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_src2_use_imm <= 0;\n      else \n        R_src2_use_imm <= D_ctrl_src2_choose_imm | (D_ctrl_br & R_valid);\n    end\n\n\n  assign W_rf_wren = (R_wr_dst_reg & W_valid) | ~reset_n;\n  assign W_rf_wr_data = R_ctrl_ld ? av_ld_data_aligned_filtered : W_wr_data;\n\nCPU_cpu_register_bank_a_module CPU_cpu_register_bank_a\n  (\n    .clock     (clk),\n    .data      (W_rf_wr_data),\n    .q         (R_rf_a),\n    .rdaddress (D_iw_a),\n    .wraddress (R_dst_regnum),\n    .wren      (W_rf_wren)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_register_bank_a.lpm_file = \"CPU_cpu_rf_ram_a.dat\";\n`else\ndefparam CPU_cpu_register_bank_a.lpm_file = \"CPU_cpu_rf_ram_a.hex\";\n`endif\n\n\n\n\n\nCPU_cpu_register_bank_b_module CPU_cpu_register_bank_b\n  (\n    .clock     (clk),\n    .data      (W_rf_wr_data),\n    .q         (R_rf_b),\n    .rdaddress (D_iw_b),\n    .wraddress (R_dst_regnum),\n    .wren      (W_rf_wren)\n  );\n\n\n`ifdef NO_PLI\ndefparam CPU_cpu_register_bank_b.lpm_file = \"CPU_cpu_rf_ram_b.dat\";\n`else\ndefparam CPU_cpu_register_bank_b.lpm_file = \"CPU_cpu_rf_ram_b.hex\";\n`endif\n\n\n\n\n  assign R_src1 = (((R_ctrl_br & E_valid) | (R_ctrl_retaddr & R_valid)))? {F_pc_plus_one, 2'b00} :\n    ((R_ctrl_jmp_direct & E_valid))? {D_jmp_direct_target_waddr, 2'b00} :\n    R_rf_a;\n\n  assign R_src2_lo = ((R_ctrl_force_src2_zero|R_ctrl_hi_imm16))? 16'b0 :\n    (R_src2_use_imm)? D_iw_imm16 :\n    R_rf_b[15 : 0];\n\n  assign R_src2_hi = ((R_ctrl_force_src2_zero|R_ctrl_unsigned_lo_imm16))? 16'b0 :\n    (R_ctrl_hi_imm16)? D_iw_imm16 :\n    (R_src2_use_imm)? {16 {D_iw_imm16[15]}} :\n    R_rf_b[31 : 16];\n\n  assign R_src2 = {R_src2_hi, R_src2_lo};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_valid <= 0;\n      else \n        E_valid <= R_valid | E_stall;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_new_inst <= 0;\n      else \n        E_new_inst <= R_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_src1 <= 0;\n      else \n        E_src1 <= R_src1;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_src2 <= 0;\n      else \n        E_src2 <= R_src2;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_invert_arith_src_msb <= 0;\n      else \n        E_invert_arith_src_msb <= D_ctrl_alu_signed_comparison & R_valid;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_alu_sub <= 0;\n      else \n        E_alu_sub <= D_ctrl_alu_subtract & R_valid;\n    end\n\n\n  assign E_stall = E_shift_rot_stall | E_ld_stall | E_st_stall | E_ci_multi_stall;\n  assign E_arith_src1 = { E_src1[31] ^ E_invert_arith_src_msb, \n    E_src1[30 : 0]};\n\n  assign E_arith_src2 = { E_src2[31] ^ E_invert_arith_src_msb, \n    E_src2[30 : 0]};\n\n  assign E_arith_result = E_alu_sub ?\n    E_arith_src1 - E_arith_src2 :\n    E_arith_src1 + E_arith_src2;\n\n  assign E_mem_baddr = E_arith_result[24 : 0];\n  assign E_logic_result = (R_logic_op == 2'b00)? (~(E_src1 | E_src2)) :\n    (R_logic_op == 2'b01)? (E_src1 & E_src2) :\n    (R_logic_op == 2'b10)? (E_src1 | E_src2) :\n    (E_src1 ^ E_src2);\n\n  assign E_logic_result_is_0 = E_logic_result == 0;\n  assign E_eq = E_logic_result_is_0;\n  assign E_lt = E_arith_result[32];\n  assign E_cmp_result = (R_compare_op == 2'b00)? E_eq :\n    (R_compare_op == 2'b01)? ~E_lt :\n    (R_compare_op == 2'b10)? E_lt :\n    ~E_eq;\n\n  assign E_shift_rot_cnt_nxt = E_new_inst ? E_src2[4 : 0] : E_shift_rot_cnt-1;\n  assign E_shift_rot_done = (E_shift_rot_cnt == 0) & ~E_new_inst;\n  assign E_shift_rot_stall = R_ctrl_shift_rot & E_valid & ~E_shift_rot_done;\n  assign E_shift_rot_fill_bit = R_ctrl_shift_logical ? 1'b0 :\n    (R_ctrl_rot_right ? E_shift_rot_result[0] : \n    E_shift_rot_result[31]);\n\n  assign E_shift_rot_result_nxt = (E_new_inst)? E_src1 :\n    (R_ctrl_shift_rot_right)? {E_shift_rot_fill_bit, E_shift_rot_result[31 : 1]} :\n    {E_shift_rot_result[30 : 0], E_shift_rot_fill_bit};\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_shift_rot_result <= 0;\n      else \n        E_shift_rot_result <= E_shift_rot_result_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          E_shift_rot_cnt <= 0;\n      else \n        E_shift_rot_cnt <= E_shift_rot_cnt_nxt;\n    end\n\n\n  assign E_control_rd_data = (D_iw_control_regnum == 3'd0)? W_status_reg :\n    (D_iw_control_regnum == 3'd1)? W_estatus_reg :\n    (D_iw_control_regnum == 3'd2)? W_bstatus_reg :\n    (D_iw_control_regnum == 3'd3)? W_ienable_reg :\n    (D_iw_control_regnum == 3'd4)? W_ipending_reg :\n    W_cpuid_reg;\n\n  assign E_alu_result = ((R_ctrl_br_cmp | R_ctrl_rdctl_inst))? 0 :\n    (R_ctrl_shift_rot)? E_shift_rot_result :\n    (R_ctrl_logic)? E_logic_result :\n    (R_ctrl_custom)? E_ci_result :\n    E_arith_result;\n\n  assign R_stb_data = R_rf_b[7 : 0];\n  assign R_sth_data = R_rf_b[15 : 0];\n  assign E_st_data = (D_mem8)? {R_stb_data, R_stb_data, R_stb_data, R_stb_data} :\n    (D_mem16)? {R_sth_data, R_sth_data} :\n    R_rf_b;\n\n  assign E_mem_byte_en = ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b00})? 4'b0001 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b01})? 4'b0010 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b10})? 4'b0100 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b00, 2'b11})? 4'b1000 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b00})? 4'b0011 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b01})? 4'b0011 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b10})? 4'b1100 :\n    ({D_iw_memsz, E_mem_baddr[1 : 0]} == {2'b01, 2'b11})? 4'b1100 :\n    4'b1111;\n\n  assign d_read_nxt = (R_ctrl_ld & E_new_inst) | (d_read & d_waitrequest);\n  assign E_ld_stall = R_ctrl_ld & ((E_valid & ~av_ld_done) | E_new_inst);\n  assign d_write_nxt = (R_ctrl_st & E_new_inst) | (d_write & d_waitrequest);\n  assign E_st_stall = d_write_nxt;\n  assign d_address = W_mem_baddr;\n  assign av_ld_getting_data = d_read & ~d_waitrequest;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_read <= 0;\n      else \n        d_read <= d_read_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_writedata <= 0;\n      else \n        d_writedata <= E_st_data;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_byteenable <= 0;\n      else \n        d_byteenable <= E_mem_byte_en;\n    end\n\n\n  assign av_ld_align_cycle_nxt = av_ld_getting_data ? 0 : (av_ld_align_cycle+1);\n  assign av_ld_align_one_more_cycle = av_ld_align_cycle == (D_mem16 ? 2 : 3);\n  assign av_ld_aligning_data_nxt = av_ld_aligning_data ? \n    ~av_ld_align_one_more_cycle : \n    (~D_mem32 & av_ld_getting_data);\n\n  assign av_ld_waiting_for_data_nxt = av_ld_waiting_for_data ? \n    ~av_ld_getting_data : \n    (R_ctrl_ld & E_new_inst);\n\n  assign av_ld_done = ~av_ld_waiting_for_data_nxt & (D_mem32 | ~av_ld_aligning_data_nxt);\n  assign av_ld_rshift8 = av_ld_aligning_data & \n    (av_ld_align_cycle < (W_mem_baddr[1 : 0]));\n\n  assign av_ld_extend = av_ld_aligning_data;\n  assign av_ld_byte0_data_nxt = av_ld_rshift8      ? av_ld_byte1_data :\n    av_ld_extend       ? av_ld_byte0_data :\n    d_readdata[7 : 0];\n\n  assign av_ld_byte1_data_nxt = av_ld_rshift8      ? av_ld_byte2_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[15 : 8];\n\n  assign av_ld_byte2_data_nxt = av_ld_rshift8      ? av_ld_byte3_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[23 : 16];\n\n  assign av_ld_byte3_data_nxt = av_ld_rshift8      ? av_ld_byte3_data :\n    av_ld_extend       ? {8 {av_fill_bit}} :\n    d_readdata[31 : 24];\n\n  assign av_ld_byte1_data_en = ~(av_ld_extend & D_mem16 & ~av_ld_rshift8);\n  assign av_ld_data_aligned_unfiltered = {av_ld_byte3_data, av_ld_byte2_data, \n    av_ld_byte1_data, av_ld_byte0_data};\n\n  assign av_sign_bit = D_mem16 ? av_ld_byte1_data[7] : av_ld_byte0_data[7];\n  assign av_fill_bit = av_sign_bit & R_ctrl_ld_signed;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_align_cycle <= 0;\n      else \n        av_ld_align_cycle <= av_ld_align_cycle_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_waiting_for_data <= 0;\n      else \n        av_ld_waiting_for_data <= av_ld_waiting_for_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_aligning_data <= 0;\n      else \n        av_ld_aligning_data <= av_ld_aligning_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte0_data <= 0;\n      else \n        av_ld_byte0_data <= av_ld_byte0_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte1_data <= 0;\n      else if (av_ld_byte1_data_en)\n          av_ld_byte1_data <= av_ld_byte1_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte2_data <= 0;\n      else \n        av_ld_byte2_data <= av_ld_byte2_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          av_ld_byte3_data <= 0;\n      else \n        av_ld_byte3_data <= av_ld_byte3_data_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_valid <= 0;\n      else \n        W_valid <= E_valid & ~E_stall;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_control_rd_data <= 0;\n      else \n        W_control_rd_data <= E_control_rd_data;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_cmp_result <= 0;\n      else \n        W_cmp_result <= E_cmp_result;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_alu_result <= 0;\n      else \n        W_alu_result <= E_alu_result;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_status_reg_pie <= 0;\n      else \n        W_status_reg_pie <= W_status_reg_pie_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_estatus_reg <= 0;\n      else \n        W_estatus_reg <= W_estatus_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_bstatus_reg <= 0;\n      else \n        W_bstatus_reg <= W_bstatus_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_ienable_reg <= 0;\n      else \n        W_ienable_reg <= W_ienable_reg_nxt;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          W_ipending_reg <= 0;\n      else \n        W_ipending_reg <= W_ipending_reg_nxt;\n    end\n\n\n  assign W_cpuid_reg = 0;\n  assign W_wr_data_non_zero = R_ctrl_br_cmp ? W_cmp_result :\n    R_ctrl_rdctl_inst       ? W_control_rd_data :\n    W_alu_result[31 : 0];\n\n  assign W_wr_data = W_wr_data_non_zero;\n  assign W_br_taken = R_ctrl_br & W_cmp_result;\n  assign W_mem_baddr = W_alu_result[24 : 0];\n  assign W_status_reg = W_status_reg_pie;\n  assign E_wrctl_status = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd0);\n\n  assign E_wrctl_estatus = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd1);\n\n  assign E_wrctl_bstatus = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd2);\n\n  assign E_wrctl_ienable = R_ctrl_wrctl_inst & \n    (D_iw_control_regnum == 3'd3);\n\n  assign W_status_reg_pie_inst_nxt = (R_ctrl_exception | R_ctrl_break | R_ctrl_crst) ? 1'b0 :\n    (D_op_eret)                     ? W_estatus_reg :\n    (D_op_bret)                     ? W_bstatus_reg :\n    (E_wrctl_status)                ? E_src1[0] :\n    W_status_reg_pie;\n\n  assign W_status_reg_pie_nxt = E_valid ? W_status_reg_pie_inst_nxt : W_status_reg_pie;\n  assign W_estatus_reg_inst_nxt = (R_ctrl_crst)        ? 0 :\n    (R_ctrl_exception)   ? W_status_reg :\n    (E_wrctl_estatus)    ? E_src1[0] :\n    W_estatus_reg;\n\n  assign W_estatus_reg_nxt = E_valid ? W_estatus_reg_inst_nxt : W_estatus_reg;\n  assign W_bstatus_reg_inst_nxt = (R_ctrl_break)       ? W_status_reg :\n    (E_wrctl_bstatus)    ? E_src1[0] :\n    W_bstatus_reg;\n\n  assign W_bstatus_reg_nxt = E_valid ? W_bstatus_reg_inst_nxt : W_bstatus_reg;\n  assign W_ienable_reg_nxt = ((E_wrctl_ienable & E_valid) ? \n    E_src1[31 : 0] : W_ienable_reg) & 32'b00000000000000000000000000000001;\n\n  assign W_ipending_reg_nxt = iactive & W_ienable_reg & oci_ienable & 32'b00000000000000000000000000000001;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          hbreak_enabled <= 1'b1;\n      else if (E_valid)\n          hbreak_enabled <= R_ctrl_break ? 1'b0 : D_op_bret ? 1'b1 : hbreak_enabled;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          d_write <= 0;\n      else \n        d_write <= d_write_nxt;\n    end\n\n\n  CPU_cpu_nios2_oci the_CPU_cpu_nios2_oci\n    (\n      .D_valid                               (D_valid),\n      .E_st_data                             (E_st_data),\n      .E_valid                               (E_valid),\n      .F_pc                                  (F_pc),\n      .address_nxt                           (jtag_debug_module_address),\n      .av_ld_data_aligned_filtered           (av_ld_data_aligned_filtered),\n      .byteenable_nxt                        (jtag_debug_module_byteenable),\n      .clk                                   (jtag_debug_module_clk),\n      .d_address                             (d_address),\n      .d_read                                (d_read),\n      .d_waitrequest                         (d_waitrequest),\n      .d_write                               (d_write),\n      .debugaccess_nxt                       (jtag_debug_module_debugaccess),\n      .hbreak_enabled                        (hbreak_enabled),\n      .jtag_debug_module_debugaccess_to_roms (jtag_debug_module_debugaccess_to_roms),\n      .oci_hbreak_req                        (oci_hbreak_req),\n      .oci_ienable                           (oci_ienable),\n      .oci_single_step_mode                  (oci_single_step_mode),\n      .read_nxt                              (jtag_debug_module_read),\n      .readdata                              (jtag_debug_module_readdata),\n      .reset                                 (jtag_debug_module_reset),\n      .reset_n                               (reset_n),\n      .reset_req                             (reset_req),\n      .resetrequest                          (jtag_debug_module_resetrequest),\n      .test_ending                           (test_ending),\n      .test_has_ended                        (test_has_ended),\n      .waitrequest                           (jtag_debug_module_waitrequest),\n      .write_nxt                             (jtag_debug_module_write),\n      .writedata_nxt                         (jtag_debug_module_writedata)\n    );\n\n  \n  assign jtag_debug_module_clk = clk;\n  assign jtag_debug_module_reset = ~reset_n;\n  assign D_ctrl_custom = 1'b0;\n  assign R_ctrl_custom_nxt = D_ctrl_custom;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_custom <= 0;\n      else if (R_en)\n          R_ctrl_custom <= R_ctrl_custom_nxt;\n    end\n\n\n  assign D_ctrl_custom_multi = 1'b0;\n  assign R_ctrl_custom_multi_nxt = D_ctrl_custom_multi;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_custom_multi <= 0;\n      else if (R_en)\n          R_ctrl_custom_multi <= R_ctrl_custom_multi_nxt;\n    end\n\n\n  assign D_ctrl_jmp_indirect = D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_callr;\n\n  assign R_ctrl_jmp_indirect_nxt = D_ctrl_jmp_indirect;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_jmp_indirect <= 0;\n      else if (R_en)\n          R_ctrl_jmp_indirect <= R_ctrl_jmp_indirect_nxt;\n    end\n\n\n  assign D_ctrl_jmp_direct = D_op_call|D_op_jmpi;\n  assign R_ctrl_jmp_direct_nxt = D_ctrl_jmp_direct;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_jmp_direct <= 0;\n      else if (R_en)\n          R_ctrl_jmp_direct <= R_ctrl_jmp_direct_nxt;\n    end\n\n\n  assign D_ctrl_implicit_dst_retaddr = D_op_call|D_op_rsv02;\n  assign R_ctrl_implicit_dst_retaddr_nxt = D_ctrl_implicit_dst_retaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_implicit_dst_retaddr <= 0;\n      else if (R_en)\n          R_ctrl_implicit_dst_retaddr <= R_ctrl_implicit_dst_retaddr_nxt;\n    end\n\n\n  assign D_ctrl_implicit_dst_eretaddr = D_op_div|D_op_divu|D_op_mul|D_op_muli|D_op_mulxss|D_op_mulxsu|D_op_mulxuu;\n  assign R_ctrl_implicit_dst_eretaddr_nxt = D_ctrl_implicit_dst_eretaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_implicit_dst_eretaddr <= 0;\n      else if (R_en)\n          R_ctrl_implicit_dst_eretaddr <= R_ctrl_implicit_dst_eretaddr_nxt;\n    end\n\n\n  assign D_ctrl_exception = D_op_trap|\n    D_op_rsvx44|\n    D_op_div|\n    D_op_divu|\n    D_op_mul|\n    D_op_muli|\n    D_op_mulxss|\n    D_op_mulxsu|\n    D_op_mulxuu|\n    D_op_intr|\n    D_op_rsvx60;\n\n  assign R_ctrl_exception_nxt = D_ctrl_exception;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_exception <= 0;\n      else if (R_en)\n          R_ctrl_exception <= R_ctrl_exception_nxt;\n    end\n\n\n  assign D_ctrl_break = D_op_break|D_op_hbreak;\n  assign R_ctrl_break_nxt = D_ctrl_break;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_break <= 0;\n      else if (R_en)\n          R_ctrl_break <= R_ctrl_break_nxt;\n    end\n\n\n  assign D_ctrl_crst = D_op_crst|D_op_rsvx63;\n  assign R_ctrl_crst_nxt = D_ctrl_crst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_crst <= 0;\n      else if (R_en)\n          R_ctrl_crst <= R_ctrl_crst_nxt;\n    end\n\n\n  assign D_ctrl_uncond_cti_non_br = D_op_call|\n    D_op_jmpi|\n    D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_callr;\n\n  assign R_ctrl_uncond_cti_non_br_nxt = D_ctrl_uncond_cti_non_br;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_uncond_cti_non_br <= 0;\n      else if (R_en)\n          R_ctrl_uncond_cti_non_br <= R_ctrl_uncond_cti_non_br_nxt;\n    end\n\n\n  assign D_ctrl_retaddr = D_op_call|\n    D_op_rsv02|\n    D_op_nextpc|\n    D_op_callr|\n    D_op_trap|\n    D_op_rsvx44|\n    D_op_div|\n    D_op_divu|\n    D_op_mul|\n    D_op_muli|\n    D_op_mulxss|\n    D_op_mulxsu|\n    D_op_mulxuu|\n    D_op_intr|\n    D_op_rsvx60|\n    D_op_break|\n    D_op_hbreak;\n\n  assign R_ctrl_retaddr_nxt = D_ctrl_retaddr;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_retaddr <= 0;\n      else if (R_en)\n          R_ctrl_retaddr <= R_ctrl_retaddr_nxt;\n    end\n\n\n  assign D_ctrl_shift_logical = D_op_slli|D_op_sll|D_op_srli|D_op_srl;\n  assign R_ctrl_shift_logical_nxt = D_ctrl_shift_logical;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_logical <= 0;\n      else if (R_en)\n          R_ctrl_shift_logical <= R_ctrl_shift_logical_nxt;\n    end\n\n\n  assign D_ctrl_shift_right_arith = D_op_srai|D_op_sra;\n  assign R_ctrl_shift_right_arith_nxt = D_ctrl_shift_right_arith;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_right_arith <= 0;\n      else if (R_en)\n          R_ctrl_shift_right_arith <= R_ctrl_shift_right_arith_nxt;\n    end\n\n\n  assign D_ctrl_rot_right = D_op_rsvx10|D_op_ror|D_op_rsvx42|D_op_rsvx43;\n  assign R_ctrl_rot_right_nxt = D_ctrl_rot_right;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_rot_right <= 0;\n      else if (R_en)\n          R_ctrl_rot_right <= R_ctrl_rot_right_nxt;\n    end\n\n\n  assign D_ctrl_shift_rot_right = D_op_srli|\n    D_op_srl|\n    D_op_srai|\n    D_op_sra|\n    D_op_rsvx10|\n    D_op_ror|\n    D_op_rsvx42|\n    D_op_rsvx43;\n\n  assign R_ctrl_shift_rot_right_nxt = D_ctrl_shift_rot_right;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_rot_right <= 0;\n      else if (R_en)\n          R_ctrl_shift_rot_right <= R_ctrl_shift_rot_right_nxt;\n    end\n\n\n  assign D_ctrl_shift_rot = D_op_slli|\n    D_op_rsvx50|\n    D_op_sll|\n    D_op_rsvx51|\n    D_op_roli|\n    D_op_rsvx34|\n    D_op_rol|\n    D_op_rsvx35|\n    D_op_srli|\n    D_op_srl|\n    D_op_srai|\n    D_op_sra|\n    D_op_rsvx10|\n    D_op_ror|\n    D_op_rsvx42|\n    D_op_rsvx43;\n\n  assign R_ctrl_shift_rot_nxt = D_ctrl_shift_rot;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_shift_rot <= 0;\n      else if (R_en)\n          R_ctrl_shift_rot <= R_ctrl_shift_rot_nxt;\n    end\n\n\n  assign D_ctrl_logic = D_op_and|\n    D_op_or|\n    D_op_xor|\n    D_op_nor|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori;\n\n  assign R_ctrl_logic_nxt = D_ctrl_logic;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_logic <= 0;\n      else if (R_en)\n          R_ctrl_logic <= R_ctrl_logic_nxt;\n    end\n\n\n  assign D_ctrl_hi_imm16 = D_op_andhi|D_op_orhi|D_op_xorhi;\n  assign R_ctrl_hi_imm16_nxt = D_ctrl_hi_imm16;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_hi_imm16 <= 0;\n      else if (R_en)\n          R_ctrl_hi_imm16 <= R_ctrl_hi_imm16_nxt;\n    end\n\n\n  assign D_ctrl_unsigned_lo_imm16 = D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_roli|\n    D_op_rsvx10|\n    D_op_slli|\n    D_op_srli|\n    D_op_rsvx34|\n    D_op_rsvx42|\n    D_op_rsvx50|\n    D_op_srai;\n\n  assign R_ctrl_unsigned_lo_imm16_nxt = D_ctrl_unsigned_lo_imm16;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_unsigned_lo_imm16 <= 0;\n      else if (R_en)\n          R_ctrl_unsigned_lo_imm16 <= R_ctrl_unsigned_lo_imm16_nxt;\n    end\n\n\n  assign D_ctrl_br_uncond = D_op_br|D_op_rsv02;\n  assign R_ctrl_br_uncond_nxt = D_ctrl_br_uncond;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br_uncond <= 0;\n      else if (R_en)\n          R_ctrl_br_uncond <= R_ctrl_br_uncond_nxt;\n    end\n\n\n  assign D_ctrl_br = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62;\n\n  assign R_ctrl_br_nxt = D_ctrl_br;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br <= 0;\n      else if (R_en)\n          R_ctrl_br <= R_ctrl_br_nxt;\n    end\n\n\n  assign D_ctrl_alu_subtract = D_op_sub|\n    D_op_rsvx25|\n    D_op_cmplti|\n    D_op_cmpltui|\n    D_op_cmplt|\n    D_op_cmpltu|\n    D_op_blt|\n    D_op_bltu|\n    D_op_cmpgei|\n    D_op_cmpgeui|\n    D_op_cmpge|\n    D_op_cmpgeu|\n    D_op_bge|\n    D_op_rsv10|\n    D_op_bgeu|\n    D_op_rsv42;\n\n  assign R_ctrl_alu_subtract_nxt = D_ctrl_alu_subtract;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_subtract <= 0;\n      else if (R_en)\n          R_ctrl_alu_subtract <= R_ctrl_alu_subtract_nxt;\n    end\n\n\n  assign D_ctrl_alu_signed_comparison = D_op_cmpge|D_op_cmpgei|D_op_cmplt|D_op_cmplti|D_op_bge|D_op_blt;\n  assign R_ctrl_alu_signed_comparison_nxt = D_ctrl_alu_signed_comparison;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_signed_comparison <= 0;\n      else if (R_en)\n          R_ctrl_alu_signed_comparison <= R_ctrl_alu_signed_comparison_nxt;\n    end\n\n\n  assign D_ctrl_br_cmp = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_rsvx00|\n    D_op_cmpge|\n    D_op_cmplt|\n    D_op_cmpne|\n    D_op_cmpgeu|\n    D_op_cmpltu|\n    D_op_cmpeq|\n    D_op_rsvx56;\n\n  assign R_ctrl_br_cmp_nxt = D_ctrl_br_cmp;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_br_cmp <= 0;\n      else if (R_en)\n          R_ctrl_br_cmp <= R_ctrl_br_cmp_nxt;\n    end\n\n\n  assign D_ctrl_ld_signed = D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63;\n\n  assign R_ctrl_ld_signed_nxt = D_ctrl_ld_signed;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_signed <= 0;\n      else if (R_en)\n          R_ctrl_ld_signed <= R_ctrl_ld_signed_nxt;\n    end\n\n\n  assign D_ctrl_ld = D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio;\n\n  assign R_ctrl_ld_nxt = D_ctrl_ld;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld <= 0;\n      else if (R_en)\n          R_ctrl_ld <= R_ctrl_ld_nxt;\n    end\n\n\n  assign D_ctrl_ld_non_io = D_op_ldbu|D_op_ldhu|D_op_ldb|D_op_ldh|D_op_ldw|D_op_ldl;\n  assign R_ctrl_ld_non_io_nxt = D_ctrl_ld_non_io;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_non_io <= 0;\n      else if (R_en)\n          R_ctrl_ld_non_io <= R_ctrl_ld_non_io_nxt;\n    end\n\n\n  assign D_ctrl_st = D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61;\n\n  assign R_ctrl_st_nxt = D_ctrl_st;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_st <= 0;\n      else if (R_en)\n          R_ctrl_st <= R_ctrl_st_nxt;\n    end\n\n\n  assign D_ctrl_ld_io = D_op_ldbuio|D_op_ldhuio|D_op_ldbio|D_op_ldhio|D_op_ldwio|D_op_rsv63;\n  assign R_ctrl_ld_io_nxt = D_ctrl_ld_io;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ld_io <= 0;\n      else if (R_en)\n          R_ctrl_ld_io <= R_ctrl_ld_io_nxt;\n    end\n\n\n  assign D_ctrl_b_is_dst = D_op_addi|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_call|\n    D_op_rdprs|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57|\n    D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio|\n    D_op_initd|\n    D_op_initda|\n    D_op_flushd|\n    D_op_flushda;\n\n  assign R_ctrl_b_is_dst_nxt = D_ctrl_b_is_dst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_b_is_dst <= 0;\n      else if (R_en)\n          R_ctrl_b_is_dst <= R_ctrl_b_is_dst_nxt;\n    end\n\n\n  assign D_ctrl_ignore_dst = D_op_br|\n    D_op_bge|\n    D_op_blt|\n    D_op_bne|\n    D_op_beq|\n    D_op_bgeu|\n    D_op_bltu|\n    D_op_rsv62|\n    D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57;\n\n  assign R_ctrl_ignore_dst_nxt = D_ctrl_ignore_dst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_ignore_dst <= 0;\n      else if (R_en)\n          R_ctrl_ignore_dst <= R_ctrl_ignore_dst_nxt;\n    end\n\n\n  assign D_ctrl_src2_choose_imm = D_op_addi|\n    D_op_andhi|\n    D_op_orhi|\n    D_op_xorhi|\n    D_op_andi|\n    D_op_ori|\n    D_op_xori|\n    D_op_call|\n    D_op_rdprs|\n    D_op_cmpgei|\n    D_op_cmplti|\n    D_op_cmpnei|\n    D_op_cmpgeui|\n    D_op_cmpltui|\n    D_op_cmpeqi|\n    D_op_jmpi|\n    D_op_rsv09|\n    D_op_rsv17|\n    D_op_rsv25|\n    D_op_rsv33|\n    D_op_rsv41|\n    D_op_rsv49|\n    D_op_rsv57|\n    D_op_ldb|\n    D_op_ldh|\n    D_op_ldl|\n    D_op_ldw|\n    D_op_ldbio|\n    D_op_ldhio|\n    D_op_ldwio|\n    D_op_rsv63|\n    D_op_ldbu|\n    D_op_ldhu|\n    D_op_ldbuio|\n    D_op_ldhuio|\n    D_op_initd|\n    D_op_initda|\n    D_op_flushd|\n    D_op_flushda|\n    D_op_stb|\n    D_op_sth|\n    D_op_stw|\n    D_op_stc|\n    D_op_stbio|\n    D_op_sthio|\n    D_op_stwio|\n    D_op_rsv61|\n    D_op_roli|\n    D_op_rsvx10|\n    D_op_slli|\n    D_op_srli|\n    D_op_rsvx34|\n    D_op_rsvx42|\n    D_op_rsvx50|\n    D_op_srai;\n\n  assign R_ctrl_src2_choose_imm_nxt = D_ctrl_src2_choose_imm;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_src2_choose_imm <= 0;\n      else if (R_en)\n          R_ctrl_src2_choose_imm <= R_ctrl_src2_choose_imm_nxt;\n    end\n\n\n  assign D_ctrl_wrctl_inst = D_op_wrctl;\n  assign R_ctrl_wrctl_inst_nxt = D_ctrl_wrctl_inst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_wrctl_inst <= 0;\n      else if (R_en)\n          R_ctrl_wrctl_inst <= R_ctrl_wrctl_inst_nxt;\n    end\n\n\n  assign D_ctrl_rdctl_inst = D_op_rdctl;\n  assign R_ctrl_rdctl_inst_nxt = D_ctrl_rdctl_inst;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_rdctl_inst <= 0;\n      else if (R_en)\n          R_ctrl_rdctl_inst <= R_ctrl_rdctl_inst_nxt;\n    end\n\n\n  assign D_ctrl_force_src2_zero = D_op_call|\n    D_op_rsv02|\n    D_op_nextpc|\n    D_op_callr|\n    D_op_trap|\n    D_op_rsvx44|\n    D_op_intr|\n    D_op_rsvx60|\n    D_op_break|\n    D_op_hbreak|\n    D_op_eret|\n    D_op_bret|\n    D_op_rsvx17|\n    D_op_rsvx25|\n    D_op_ret|\n    D_op_jmp|\n    D_op_rsvx21|\n    D_op_jmpi;\n\n  assign R_ctrl_force_src2_zero_nxt = D_ctrl_force_src2_zero;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_force_src2_zero <= 0;\n      else if (R_en)\n          R_ctrl_force_src2_zero <= R_ctrl_force_src2_zero_nxt;\n    end\n\n\n  assign D_ctrl_alu_force_xor = D_op_cmpgei|\n    D_op_cmpgeui|\n    D_op_cmpeqi|\n    D_op_cmpge|\n    D_op_cmpgeu|\n    D_op_cmpeq|\n    D_op_cmpnei|\n    D_op_cmpne|\n    D_op_bge|\n    D_op_rsv10|\n    D_op_bgeu|\n    D_op_rsv42|\n    D_op_beq|\n    D_op_rsv34|\n    D_op_bne|\n    D_op_rsv62|\n    D_op_br|\n    D_op_rsv02;\n\n  assign R_ctrl_alu_force_xor_nxt = D_ctrl_alu_force_xor;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          R_ctrl_alu_force_xor <= 0;\n      else if (R_en)\n          R_ctrl_alu_force_xor <= R_ctrl_alu_force_xor_nxt;\n    end\n\n\n  \n  \n\n\n\n  assign F_inst = (F_op_call)? 56'h20202063616c6c :\n    (F_op_jmpi)? 56'h2020206a6d7069 :\n    (F_op_ldbu)? 56'h2020206c646275 :\n    (F_op_addi)? 56'h20202061646469 :\n    (F_op_stb)? 56'h20202020737462 :\n    (F_op_br)? 56'h20202020206272 :\n    (F_op_ldb)? 56'h202020206c6462 :\n    (F_op_cmpgei)? 56'h20636d70676569 :\n    (F_op_ldhu)? 56'h2020206c646875 :\n    (F_op_andi)? 56'h202020616e6469 :\n    (F_op_sth)? 56'h20202020737468 :\n    (F_op_bge)? 56'h20202020626765 :\n    (F_op_ldh)? 56'h202020206c6468 :\n    (F_op_cmplti)? 56'h20636d706c7469 :\n    (F_op_initda)? 56'h20696e69746461 :\n    (F_op_ori)? 56'h202020206f7269 :\n    (F_op_stw)? 56'h20202020737477 :\n    (F_op_blt)? 56'h20202020626c74 :\n    (F_op_ldw)? 56'h202020206c6477 :\n    (F_op_cmpnei)? 56'h20636d706e6569 :\n    (F_op_flushda)? 56'h666c7573686461 :\n    (F_op_xori)? 56'h202020786f7269 :\n    (F_op_bne)? 56'h20202020626e65 :\n    (F_op_cmpeqi)? 56'h20636d70657169 :\n    (F_op_ldbuio)? 56'h206c646275696f :\n    (F_op_muli)? 56'h2020206d756c69 :\n    (F_op_stbio)? 56'h2020737462696f :\n    (F_op_beq)? 56'h20202020626571 :\n    (F_op_ldbio)? 56'h20206c6462696f :\n    (F_op_cmpgeui)? 56'h636d7067657569 :\n    (F_op_ldhuio)? 56'h206c646875696f :\n    (F_op_andhi)? 56'h2020616e646869 :\n    (F_op_sthio)? 56'h2020737468696f :\n    (F_op_bgeu)? 56'h20202062676575 :\n    (F_op_ldhio)? 56'h20206c6468696f :\n    (F_op_cmpltui)? 56'h636d706c747569 :\n    (F_op_initd)? 56'h2020696e697464 :\n    (F_op_orhi)? 56'h2020206f726869 :\n    (F_op_stwio)? 56'h2020737477696f :\n    (F_op_bltu)? 56'h202020626c7475 :\n    (F_op_ldwio)? 56'h20206c6477696f :\n    (F_op_flushd)? 56'h20666c75736864 :\n    (F_op_xorhi)? 56'h2020786f726869 :\n    (F_op_eret)? 56'h20202065726574 :\n    (F_op_roli)? 56'h202020726f6c69 :\n    (F_op_rol)? 56'h20202020726f6c :\n    (F_op_flushp)? 56'h20666c75736870 :\n    (F_op_ret)? 56'h20202020726574 :\n    (F_op_nor)? 56'h202020206e6f72 :\n    (F_op_mulxuu)? 56'h206d756c787575 :\n    (F_op_cmpge)? 56'h2020636d706765 :\n    (F_op_bret)? 56'h20202062726574 :\n    (F_op_ror)? 56'h20202020726f72 :\n    (F_op_flushi)? 56'h20666c75736869 :\n    (F_op_jmp)? 56'h202020206a6d70 :\n    (F_op_and)? 56'h20202020616e64 :\n    (F_op_cmplt)? 56'h2020636d706c74 :\n    (F_op_slli)? 56'h202020736c6c69 :\n    (F_op_sll)? 56'h20202020736c6c :\n    (F_op_or)? 56'h20202020206f72 :\n    (F_op_mulxsu)? 56'h206d756c787375 :\n    (F_op_cmpne)? 56'h2020636d706e65 :\n    (F_op_srli)? 56'h20202073726c69 :\n    (F_op_srl)? 56'h2020202073726c :\n    (F_op_nextpc)? 56'h206e6578747063 :\n    (F_op_callr)? 56'h202063616c6c72 :\n    (F_op_xor)? 56'h20202020786f72 :\n    (F_op_mulxss)? 56'h206d756c787373 :\n    (F_op_cmpeq)? 56'h2020636d706571 :\n    (F_op_divu)? 56'h20202064697675 :\n    (F_op_div)? 56'h20202020646976 :\n    (F_op_rdctl)? 56'h2020726463746c :\n    (F_op_mul)? 56'h202020206d756c :\n    (F_op_cmpgeu)? 56'h20636d70676575 :\n    (F_op_initi)? 56'h2020696e697469 :\n    (F_op_trap)? 56'h20202074726170 :\n    (F_op_wrctl)? 56'h2020777263746c :\n    (F_op_cmpltu)? 56'h20636d706c7475 :\n    (F_op_add)? 56'h20202020616464 :\n    (F_op_break)? 56'h2020627265616b :\n    (F_op_hbreak)? 56'h2068627265616b :\n    (F_op_sync)? 56'h20202073796e63 :\n    (F_op_sub)? 56'h20202020737562 :\n    (F_op_srai)? 56'h20202073726169 :\n    (F_op_sra)? 56'h20202020737261 :\n    (F_op_intr)? 56'h202020696e7472 :\n    56'h20202020424144;\n\n  assign D_inst = (D_op_call)? 56'h20202063616c6c :\n    (D_op_jmpi)? 56'h2020206a6d7069 :\n    (D_op_ldbu)? 56'h2020206c646275 :\n    (D_op_addi)? 56'h20202061646469 :\n    (D_op_stb)? 56'h20202020737462 :\n    (D_op_br)? 56'h20202020206272 :\n    (D_op_ldb)? 56'h202020206c6462 :\n    (D_op_cmpgei)? 56'h20636d70676569 :\n    (D_op_ldhu)? 56'h2020206c646875 :\n    (D_op_andi)? 56'h202020616e6469 :\n    (D_op_sth)? 56'h20202020737468 :\n    (D_op_bge)? 56'h20202020626765 :\n    (D_op_ldh)? 56'h202020206c6468 :\n    (D_op_cmplti)? 56'h20636d706c7469 :\n    (D_op_initda)? 56'h20696e69746461 :\n    (D_op_ori)? 56'h202020206f7269 :\n    (D_op_stw)? 56'h20202020737477 :\n    (D_op_blt)? 56'h20202020626c74 :\n    (D_op_ldw)? 56'h202020206c6477 :\n    (D_op_cmpnei)? 56'h20636d706e6569 :\n    (D_op_flushda)? 56'h666c7573686461 :\n    (D_op_xori)? 56'h202020786f7269 :\n    (D_op_bne)? 56'h20202020626e65 :\n    (D_op_cmpeqi)? 56'h20636d70657169 :\n    (D_op_ldbuio)? 56'h206c646275696f :\n    (D_op_muli)? 56'h2020206d756c69 :\n    (D_op_stbio)? 56'h2020737462696f :\n    (D_op_beq)? 56'h20202020626571 :\n    (D_op_ldbio)? 56'h20206c6462696f :\n    (D_op_cmpgeui)? 56'h636d7067657569 :\n    (D_op_ldhuio)? 56'h206c646875696f :\n    (D_op_andhi)? 56'h2020616e646869 :\n    (D_op_sthio)? 56'h2020737468696f :\n    (D_op_bgeu)? 56'h20202062676575 :\n    (D_op_ldhio)? 56'h20206c6468696f :\n    (D_op_cmpltui)? 56'h636d706c747569 :\n    (D_op_initd)? 56'h2020696e697464 :\n    (D_op_orhi)? 56'h2020206f726869 :\n    (D_op_stwio)? 56'h2020737477696f :\n    (D_op_bltu)? 56'h202020626c7475 :\n    (D_op_ldwio)? 56'h20206c6477696f :\n    (D_op_flushd)? 56'h20666c75736864 :\n    (D_op_xorhi)? 56'h2020786f726869 :\n    (D_op_eret)? 56'h20202065726574 :\n    (D_op_roli)? 56'h202020726f6c69 :\n    (D_op_rol)? 56'h20202020726f6c :\n    (D_op_flushp)? 56'h20666c75736870 :\n    (D_op_ret)? 56'h20202020726574 :\n    (D_op_nor)? 56'h202020206e6f72 :\n    (D_op_mulxuu)? 56'h206d756c787575 :\n    (D_op_cmpge)? 56'h2020636d706765 :\n    (D_op_bret)? 56'h20202062726574 :\n    (D_op_ror)? 56'h20202020726f72 :\n    (D_op_flushi)? 56'h20666c75736869 :\n    (D_op_jmp)? 56'h202020206a6d70 :\n    (D_op_and)? 56'h20202020616e64 :\n    (D_op_cmplt)? 56'h2020636d706c74 :\n    (D_op_slli)? 56'h202020736c6c69 :\n    (D_op_sll)? 56'h20202020736c6c :\n    (D_op_or)? 56'h20202020206f72 :\n    (D_op_mulxsu)? 56'h206d756c787375 :\n    (D_op_cmpne)? 56'h2020636d706e65 :\n    (D_op_srli)? 56'h20202073726c69 :\n    (D_op_srl)? 56'h2020202073726c :\n    (D_op_nextpc)? 56'h206e6578747063 :\n    (D_op_callr)? 56'h202063616c6c72 :\n    (D_op_xor)? 56'h20202020786f72 :\n    (D_op_mulxss)? 56'h206d756c787373 :\n    (D_op_cmpeq)? 56'h2020636d706571 :\n    (D_op_divu)? 56'h20202064697675 :\n    (D_op_div)? 56'h20202020646976 :\n    (D_op_rdctl)? 56'h2020726463746c :\n    (D_op_mul)? 56'h202020206d756c :\n    (D_op_cmpgeu)? 56'h20636d70676575 :\n    (D_op_initi)? 56'h2020696e697469 :\n    (D_op_trap)? 56'h20202074726170 :\n    (D_op_wrctl)? 56'h2020777263746c :\n    (D_op_cmpltu)? 56'h20636d706c7475 :\n    (D_op_add)? 56'h20202020616464 :\n    (D_op_break)? 56'h2020627265616b :\n    (D_op_hbreak)? 56'h2068627265616b :\n    (D_op_sync)? 56'h20202073796e63 :\n    (D_op_sub)? 56'h20202020737562 :\n    (D_op_srai)? 56'h20202073726169 :\n    (D_op_sra)? 56'h20202020737261 :\n    (D_op_intr)? 56'h202020696e7472 :\n    56'h20202020424144;\n\n  assign F_vinst = F_valid ? F_inst : {7{8'h2d}};\n  assign D_vinst = D_valid ? D_inst : {7{8'h2d}};\n  assign R_vinst = R_valid ? D_inst : {7{8'h2d}};\n  assign E_vinst = E_valid ? D_inst : {7{8'h2d}};\n  assign W_vinst = W_valid ? D_inst : {7{8'h2d}};\n\n\n\n\n\nendmodule\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: CPU_cpu. Module specification: This module implements the main CPU core for a NIOS II processor. It contains the key pipeline stages (fetch, decode, execute, memory, writeback) and associated control logic. The module handles instruction fetch, decoding, execution of arithmetic/logic operations, memory access, and writing results back to registers. It also includes logic for branch prediction, exception handling, and interfacing with other system components like memory and peripherals. Key input ports include clk (system clock), reset_n (active-low reset), d_irq (data memory interrupt request), and i_readdata (instruction read data). Output ports include d_address (data memory address), i_address (instruction memory address), and various control signals. Internal signals such as F_pc (fetch stage program counter), D_iw (decode stage instruction word), and E_alu_result (execute stage ALU result) are use"
                }
            ]
        }
    ]
}