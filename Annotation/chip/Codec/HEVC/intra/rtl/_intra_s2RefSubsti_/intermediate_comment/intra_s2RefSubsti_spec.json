{
    "spec": "Module name: intra_s2RefSubsti. Module specification: This module performs reference sample substitution for intra prediction in video encoding. It processes 8 banks of 4 samples each in parallel, handling various block sizes and prediction modes. The module takes inputs such as pseuAdr (addressing information), isAbove/isLeft/isTopLeft (neighboring sample availability flags), tuSize (transform unit size), data (input samples), and various position and mode parameters. It outputs sub_data (substituted reference samples), sub_tl (substituted top-left sample), and substi_Opt (substitution options). Internal signals include srambank (input sample storage), sub_srambank (substituted sample storage), and various registers for processing and control. The module is divided into several sections: input processing, reference sample selection, substitution logic for different cases (e.g., unavailable samples, special modes), an",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: intra_s2RefSubsti\n\nExplanation: This module appears to be part of an intra prediction system for video encoding. It performs reference sample substitution for intra prediction. The module takes various input parameters related to the current block being processed, such as position, size, and neighboring sample information. It then applies a series of conditions and rules to determine how to substitute reference samples for intra prediction. The module handles different block sizes, prediction modes, and special cases for chroma components. It processes multiple samples in parallel (8 banks of 4 samples each) and outputs substituted reference samples for further use in the intra prediction process."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\n[pseuAdr, isAbove, isLeft, isTopLeft, tuSize, nMaxCUlog2, isBtBorder, isRtBorder, posBtBorderIn4, posRtBorderIn4, data, data_tl, horLevel_i, verLevel_i, verFlag, sub_data, sub_tl, partIdx, pre_tuSize, pre_xTb, pre_modeHor, xTb, xTbInCU, yTbInCU, byPa_P_A_2, byPa_P_A_2_cr, byPa_DW_A_3, bp_pos_1, bp_pos_2, bp_pos_3, order, clk, rst_n, arst_n, bStop, i_modiPosIn4, awkCnt, cIdx, by4_1_forStop, by4_1_forStop_cr, by4_1_forStop_pos, gp_bitDepth]\n\nExplanation:\n- pseuAdr, i_modiPosIn4: Addressing information for sample processing\n- isAbove, isLeft, isTopLeft, isBtBorder, isRtBorder: Flags indicating availability of neighboring samples\n- tuSize, nMaxCUlog2, pre_tuSize: Transform unit and coding unit size information\n- posBtBorderIn4, posRtBorderIn4: Border positions\n- data, data_tl: Input sample data\n- horLevel_i, verLevel_i, verFlag: Information about prediction directions\n- xTb, xTbInCU, yTbInCU, pre_xTb: Position information of the current block\n- byPa_P_A_2, byPa_P_A_2_cr, byPa_DW_A_3: Neighboring sample data\n- bp_pos_1, bp_pos_2, bp_pos_3: Bypass sample positions\n- order, partIdx, pre_modeHor: Information about prediction mode and partitioning\n- clk, rst_n, arst_n, bStop: Clock and reset signals\n- awkCnt, cIdx: Processing counters and component index\n- by4_1_forStop, by4_1_forStop_cr, by4_1_forStop_pos: Additional sample data for special cases\n- gp_bitDepth: Bit depth of samples\n\nOutput ports:\n[sub_data, sub_tl, substi_Opt]\n\nExplanation:\n- sub_data: Substituted reference samples for intra prediction\n- sub_tl: Substituted top-left sample\n- substi_Opt: Options or flags indicating the substitution method used"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: [srambank, sub_srambank, pixel_SRAM, pixel_32Reg_SRAM, sub_pixel, adr, temp_sub, r_l, r_t, r_b, r_rt, r_br01_4, r_br01_8, r_br01_16, r_br01_32, r_br01_64, r_br2_8, r_br2_16, r_br2_32, val_top0, val_left0, ankor_x, ankor_y, halfVal, horLevel, verLevel, r_TL, bp2_4samp, bp3_4samp, bp_stop_4samp, l1_xTb_gtP, l2_xTb_gtP, l1_pre_tuSize, l2_pre_tuSize, l3_pre_tuSize, l1_pre_modeHor, l2_pre_modeHor, bNull, nTBin4, yTbin4PlusnTBin4, yTbin4Plusn2TBin4, xTbin4PlusnTBin4, xTbInCUin4, yTbInCUin4, posIn4, bOnlyLeft, substi_Opt_].\n\nExplanation:\n- srambank, sub_srambank: Arrays to store input and substituted sample data\n- pixel_SRAM, pixel_32Reg_SRAM, sub_pixel: Arrays for sample processing and storage\n- adr: Array for addressing sample banks\n- temp_sub: Temporary array for substituted samples\n- r_l, r_t, r_b, r_rt: Reference samples (left, top, bottom, right-top)\n- r_br01_4/8/16/32/64, r_br2_8/16/32: Reference samples for different block sizes\n- val_top0, val_left0: Arrays to store top and left sample positions\n- ankor_x, ankor_y: Anchor positions for sample processing\n- halfVal: Half value based on bit depth\n- horLevel, verLevel: Arrays for horizontal and vertical prediction levels\n- r_TL: Top-left reference sample\n- bp2_4samp, bp3_4samp, bp_stop_4samp: Arrays for bypass and special case samples\n- l1/l2_xTb_gtP, l1/l2/l3_pre_tuSize, l1/l2_pre_modeHor: Pipeline registers for processing\n- bNull: Flag indicating no available reference samples\n- nTBin4, yTbin4PlusnTBin4, yTbin4Plusn2TBin4, xTbin4PlusnTBin4: Position calculations\n- xTbInCUin4, yTbInCUin4: Block positions within coding unit\n- posIn4: Array for sample positions\n- bOnlyLeft: Flag indicating only left samples are available\n- substi_Opt_: Array for substitution options\n\nThese internal signals are used for various calculations, temporary storage, and control logic within the module to perform the reference sample substitution process."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n`timescale 1ns/1ps\nmodule intra_s2RefSubsti(\n\tpseuAdr,\n\tisAbove,\n\tisLeft,\n\tisTopLeft,\n\ttuSize,\n\tnMaxCUlog2,\n\tisBtBorder,\n\tisRtBorder,\n\tposBtBorderIn4,\n\tposRtBorderIn4,\n\tdata,\n\tdata_tl,\n\thorLevel_i, \n\tverLevel_i,\n\tverFlag,\n\tsub_data,\n\tsub_tl,\n\tpartIdx,\n\tpre_tuSize,\n\tpre_xTb,\n\tpre_modeHor,\n\txTb,\n\txTbInCU,\n\tyTbInCU,\n\tbyPa_P_A_2,\n\tbyPa_P_A_2_cr,\n\tbyPa_DW_A_3,\n\tbp_pos_1,\n\tbp_pos_2,\n\tbp_pos_3,\n\torder,\n\tclk,\n\trst_n,\n\tarst_n,\n\tbStop,\n\ti_modiPosIn4,\n\tawkCnt,\n\tcIdx,\n\n\tby4_1_forStop,\n\tby4_1_forStop_cr,\n\tby4_1_forStop_pos,\n\tsubsti_Opt,\n\tgp_bitDepth\n);\n\n\tparameter\t\t\t\t\t\tisChroma =0;\n\tparameter \t\t \t\t\t\tbitDepth = 8;\n\tparameter\t\t\t\t\t\tnSRAMs \t\t=8;\n\tparameter\t\t\t\t\t\tSRAMDW      = bitDepth*4;\n\n\tinput\t\t\t\t\t\t\tclk,rst_n,arst_n,bStop;\n\tinput [nSRAMs*3-1:0]\t\t\tpseuAdr;\n\tinput \t\t\t\t\t\t\tisAbove;\n\tinput\t\t\t\t\t\t\tisLeft;\n\tinput\t\t\t\t\t\t\tisTopLeft;\n\tinput\t\t\t\t\t\t\tisBtBorder;\n\tinput\t\t\t\t\t\t\tisRtBorder;\n\tinput [4:0]\t\t\t\t\t\tposBtBorderIn4,posRtBorderIn4;\n\tinput [12:0]\t\t\t\t\txTb,pre_xTb;\n\tinput [2:0]\t\t\t\t\t\ttuSize,pre_tuSize;\n\tinput\t\t\t\t\t\t\tpre_modeHor;\n\tinput [bitDepth*32-1:0]\t\t\tdata;\n\tinput [bitDepth-1:0]\t\t\tdata_tl;\n\tinput [16*4-1:0]\t\t\t\thorLevel_i;\n\tinput [16*4-1:0]\t\t\t\tverLevel_i;\n\tinput [15:0]\t\t\t\t\tverFlag;\n\tinput [3:0]\t\t\t\t\t\tgp_bitDepth;\n\tinput [1:0]     \t\t\t\tpartIdx;\n\tinput [2:0]\t\t\t\t\t\torder;\n\tinput [6:0]      \t\t\t\txTbInCU ,yTbInCU;\n\tinput [bitDepth*16-1:0]       \tbyPa_P_A_2;\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tinput [bitDepth*11-1:0]       \tbyPa_P_A_2_cr;\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tinput [bitDepth*4-1:0] \t\t\tbyPa_DW_A_3;\t\t\t\n\tinput [5:0]\t\t\t\t\t\tbp_pos_1,bp_pos_2,bp_pos_3;\n\tinput [5*nSRAMs-1:0]\t\t\ti_modiPosIn4;\n\tinput [2:0]\t\t\t\t\t\tnMaxCUlog2;\n\tinput [2:0]\t\t\t\t\t\tawkCnt;\n\tinput [bitDepth*4-1:0]\t\t\tby4_1_forStop,by4_1_forStop_cr;\n\tinput [4:0]\t\t\t\t\t\tby4_1_forStop_pos;\n\tinput [1:0]\t\t\t\t\t\tcIdx;\n\t\n\t\n\twire [4:0]\t\t\t\t\t\tbypa_pos_1,bypa_pos_2,bypa_pos_3;\n\twire\t\t\t\t\t\t\tbp_f_1,bp_f_2,bp_f_3;\n\twire [6:0]\t\t\t\t\t\tnMaxCB = (1<<nMaxCUlog2);\n\twire [5:0]\t\t\t\t\t\tnMaxCBin4 = nMaxCB >>2;\n\twire [2:0]\t\t\t\t\t\tcnt_by2,cnt_by3;\n\twire \t\t\t\t\t\t\tcnt_by1= 0;\n\t\n\twire\t\t\t\t\t\t\tisTpInCB=(yTbInCU==0);\n\t\n\tassign bypa_pos_1 = bp_pos_1[4:0];\t\n\tassign bypa_pos_2 = bp_pos_2[4:0];\n\tassign bypa_pos_3 = bp_pos_3[4:0];\n\tassign bp_f_1 = bp_pos_1[5];\n\tassign bp_f_2 = bp_pos_2[5];\n\tassign bp_f_3 = bp_pos_3[5];\n\t\n\toutput reg [bitDepth*32-1:0]\tsub_data;\n\toutput reg [bitDepth-1:0]\t\tsub_tl;\n\t\n\toutput  reg [3*8+1:0]\t\t\tsubsti_Opt;\n\treg\t[2:0]\t\t\t\t\t\tsubsti_Opt_[7:0];\n\t\n\treg [bitDepth-1:0]\t\t\t\ttemp_tl;\n\treg [bitDepth*4-1:0] \t\t\tsrambank[7:0];\n\treg [bitDepth*4-1:0] \t\t\tsub_srambank[7:0];\n\treg [bitDepth-1:0] \t\t\t\tpixel_SRAM[7:0][3:0];\n\treg [bitDepth-1:0] \t\t\t\tpixel_32Reg_SRAM[7:0][3:0];\n\treg [bitDepth-1:0] \t\t\t\tsub_pixel[7:0][3:0];\n\treg [2:0]\t\t\t\t\t\tadr[7:0];\n\treg [bitDepth-1:0] \t\t\t\ttemp_sub[7:0][3:0]; \n\t\n\treg [bitDepth-1:0]\t\t\t\tr_l,r_t,r_b,r_rt;\n\treg [bitDepth-1:0]\t\t\t\tr_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br01_64;\n\treg [bitDepth-1:0]\t\t\t\tr_br2_8,r_br2_16,r_br2_32;\n\t\n\treg [4:0]\t\t\t\t\t\tval_top0[7:0],val_left0[7:0];\n\t\n\treg [5:0]\t\t\t\t\t\tankor_x,ankor_y;\n\t\n\treg [bitDepth:0]\t\t\t\thalfVal;\n\treg [4:0] \t\t\t\t\t\thorLevel[15:0];\n\treg [4:0] \t\t\t\t\t\tverLevel[15:0];\n\treg [bitDepth-1:0]\t\t\t\tr_TL;\t\t\t\n\t\n\treg [bitDepth-1:0]\t\t\t\tbp2_4samp[3:0];\n\treg [bitDepth-1:0]\t\t\t\tbp3_4samp[3:0];\n\treg [bitDepth-1:0]\t\t\t\tbp_stop_4samp[3:0];\n\treg \t\t\t\t\t\t\tl1_xTb_gtP,l2_xTb_gtP;\n\treg [2:0]\t\t\t\t\t\tl1_pre_tuSize,l2_pre_tuSize,l3_pre_tuSize;\n\treg \t\t\t\t\t\t\tl1_pre_modeHor,l2_pre_modeHor;\n\treg\t\t\t\t\t\t\t\tbNull;\n\treg [4:0]\t\t\t\t\t\tnTBin4;\n\treg [4:0]\t\t\t\t\t\tyTbin4PlusnTBin4,yTbin4Plusn2TBin4;\n\treg [4:0]\t\t\t\t\t\txTbin4PlusnTBin4;\n\n\treg [3:0]\t\t\t\t\t\txTbInCUin4,yTbInCUin4;\t\n\treg [4:0]\t\t\t\t\t\tposIn4[7:0];\n\treg \t\t\t\t\t\t\tbOnlyLeft;\n\treg \t\t\t\t\t\t\tb0,b02,b03,b04,b1,b12,b13,b2,b23;\n\t\t\n\twire\t\t\t\t\t\t\tis_topl_sub_s3;\n\twire\t\t\t\t\t\t\tchannel_Cr;\n\twire\t\t\t\t\t\t\txTb_ltP,xTb_gtP;\n\t\n\tgenerate \n\t\tgenvar t;\n\t\tfor(t=0;t<16;t=t+1)\tbegin: xt\n\t\t\talways @(*) begin\n\t\t\t\tverLevel[t]  =  verLevel_i[63-4*t:60-4*t];\n\t\t\t\thorLevel[t]\t =  horLevel_i[63-4*t:60-4*t];\n\t\t\t\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\tassign \t\t\t\t\t\txTb_ltP = xTb < pre_xTb;\n\tassign\t\t\t\t\t\txTb_gtP = xTb > pre_xTb;\n\t\n\talways  @ (*) begin\n\t\txTbInCUin4 = xTbInCU>>2;\n\t\tyTbInCUin4 = yTbInCU>>2;\n\t\tnTBin4 = (1<<tuSize)>>2;\n\t\tyTbin4PlusnTBin4 = yTbInCUin4+nTBin4;\n\t\tyTbin4Plusn2TBin4 = yTbin4PlusnTBin4+nTBin4;\n\t\txTbin4PlusnTBin4 = xTbInCUin4+nTBin4;\n\t\tankor_x = nTBin4-1+xTbInCUin4;\n\t\tankor_y = nTBin4-1+yTbInCUin4;\n\t\thalfVal = (1<<gp_bitDepth)>>1;\n\t\tbNull = !isAbove && !isLeft && !isTopLeft;\n\t\tbOnlyLeft = (!isAbove && !isTopLeft && isLeft);\n\t\t\n\t\tb0 = (tuSize!=2 && order==0);\n\t\tb02 = (b0 && pre_tuSize ==2);\n\t\tb03 = (b0 && pre_tuSize ==3);\n\t\tb04 = (b0 && pre_tuSize ==4);\n\t\tb1 = (tuSize!=2 && order==1);\n\t\tb12 = (b1 && l1_pre_tuSize ==2);\n\t\tb13 = (b1 && l1_pre_tuSize ==3);\n\t\tb2 = (tuSize!=2 && order==2);\n\t\tb23 = b2 && l2_pre_tuSize ==3;\n\t\t\t\n\t\t{bp3_4samp[0],bp3_4samp[1],bp3_4samp[2],bp3_4samp[3]} = byPa_DW_A_3;\n\tend\n\n\t\n\t\n\tgenerate\n\t\tgenvar e;\n\t\t\tfor(e=0;e<4;e=e+1)\tbegin:xe\n\t\t\t\talways@(*) begin\n\t\t\t\t\tif(cIdx[1]==0)\n\t\t\t\t\t\tbp_stop_4samp[e] = by4_1_forStop[bitDepth*4-1-bitDepth*e:  bitDepth*3 -  bitDepth*e];\t\n\t\t\t\t\telse\n\t\t\t\t\t\tbp_stop_4samp[e] = by4_1_forStop_cr[bitDepth*4-1-bitDepth*e:  bitDepth*3 -  bitDepth*e];\t\n\t\t\t\tend\n\t\t\tend\n\tendgenerate\n\t\n\t\n\t\n\talways @(*) begin\n\t\t{r_br01_64,bp2_4samp[0],bp2_4samp[1],bp2_4samp[2],bp2_4samp[3]} = 0;\n\t\tif(cIdx!=2)\n\t\t\t{r_l,r_t,r_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br01_64,r_br2_8,r_br2_16,r_br2_32,r_b,r_rt,bp2_4samp[0],bp2_4samp[1],bp2_4samp[2],bp2_4samp[3]} = byPa_P_A_2;\n\t\telse\tbegin\n\t\t\t{r_l,r_t,r_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br2_8,r_br2_16,r_br2_32,r_b,r_rt} = byPa_P_A_2_cr;\n\t\t\tend\n\t\t\t\n\tend\n\t\n\talways @(*)\tbegin\n\t\tif(!isAbove && !isLeft && !isTopLeft)\n\t\t\ttemp_tl = halfVal;\n\t\telse if (!isAbove && !isTopLeft)\t\t\n\t\t\ttemp_tl = r_t;\n\t\telse if (!isLeft && !isTopLeft)\t\n\t\t\ttemp_tl = r_l;\n\t\telse if(!isTopLeft) \n\t\t\ttemp_tl = r_t;\n\t\telse if(order==0)\n\t\t\ttemp_tl = data_tl;\n\t\telse \n\t\t\ttemp_tl = r_TL;\n\tend\n\t\n\treg [7:0]\t\t\tp1,p2,p3;\n\treg\t[7:0]\t\t\tc0,c1,c2,c3,c3_1,c3_2,c_tr,c4,c14_1,c5,c6,c7,c7_1,c8,c9,c9_1,\n\t\t\t\t\t\tc10,c11,c12,c13,c14,c14_a,c15,c16,c16_1,c17,c17_1,c18,c18_1,\n\t\t\t\t\t\tc_n2o0,c_n2o1,c_n2o2,c_2pIdx012,DR_substi,c1_2,c_cr1,c_cr2;\n\twire\t\tabove_null_by1_from_left = ((xTbInCUin4)%2==1 && tuSize==2) || (xTbInCUin4%4==2 && (pre_tuSize==3 && order==0))  ;\n\n\tassign\t\t\t\tis_topl_sub_s3  = \tbOnlyLeft &&  above_null_by1_from_left && !bNull && (pre_tuSize==2 || (pre_tuSize==3 && (xTb_gtP ^^ pre_modeHor))) && awkCnt> cnt_by1 && !isChroma;\t\t\n\tassign\t\t\t\tchannel_Cr \t=\tisChroma && cIdx==2;\n\talways @ (posedge clk or negedge arst_n) begin\n\t\tif(~arst_n)\tbegin\n\t\t\tr_TL <= 0;\n\t\t\tl1_xTb_gtP <= 0;\n\t\t\tl2_xTb_gtP <= 0;\n\t\t\tl1_pre_tuSize\t <= 0;\n\t\t\tl2_pre_tuSize\t <= 0;\n\t\t\tl3_pre_tuSize\t <= 0;\n\t\t\tl1_pre_modeHor\t <= 0;\n\t\t\tl2_pre_modeHor\t <= 0;\n\t\t\tsub_tl\t\t\t<=0;\n\t\t\tsubsti_Opt<=0;\n\t\tend\n\t\telse if(~rst_n)\tbegin\n\t\t\tr_TL <= 0;\n\t\t\tl1_xTb_gtP <= 0;\n\t\t\tl2_xTb_gtP <= 0;\n\t\t\tl1_pre_tuSize\t <= 0;\n\t\t\tl2_pre_tuSize\t <= 0;\n\t\t\tl3_pre_tuSize\t <= 0;\n\t\t\tl1_pre_modeHor\t <= 0;\n\t\t\tl2_pre_modeHor\t <= 0;\n\t\t\tsub_tl\t\t\t<=0;\n\t\t\tsubsti_Opt <=0;\n\t\tend\n\t\telse\tbegin\n\t\t\tif(!bStop) \tbegin\n\t\t\t\tif(order==0)\tbegin\n\t\t\t\t\tr_TL <= data_tl;\n\t\t\t\tend\n\t\t\t\tl1_xTb_gtP <= xTb_gtP;\t\t\n\t\t\t\tl2_xTb_gtP <=l1_xTb_gtP;\n\t\t\t\tl1_pre_tuSize\t <= pre_tuSize;\n\t\t\t\tl2_pre_tuSize\t <= l1_pre_tuSize;\n\t\t\t\tl3_pre_tuSize\t <= l2_pre_tuSize;\t\t\n\t\t\t\tl1_pre_modeHor\t <= pre_modeHor;\n\t\t\t\tl2_pre_modeHor\t <= l1_pre_modeHor;\t\t\n\t\t\t\tsub_tl\t\t\t<=\ttemp_tl;\n\t\t\t\t\n\t\t\t\tsubsti_Opt \t\t <= {channel_Cr,is_topl_sub_s3,substi_Opt_[0],substi_Opt_[1],substi_Opt_[2],substi_Opt_[3],substi_Opt_[4],substi_Opt_[5],substi_Opt_[6],substi_Opt_[7]};\n\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\n\n\tassign      cnt_by3 = 3'd2;\t\t\n\tassign      cnt_by2 = 3'd2;\t\t\n\n\t\n\t\n\tgenerate\n\t\tgenvar i,q;\n\t\t for(i=0;i<8;i=i+1)begin: xi\n\t\t\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif (~arst_n)\t\n\t\t\t\t\tsub_data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <= 0;\n\t\t\t\telse if(~rst_n)\n\t\t\t\t\tsub_data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <= 0;\n\t\t\t\telse \n\t\t\t\t\tsub_data [bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <=  bStop? sub_data [bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] : sub_srambank[i];\n\t\t\tend\n\t\t\talways @(*) begin\t\t\n\t\t\t\tposIn4[i]\t= i_modiPosIn4[nSRAMs*5-1-5*i:35-5*i];\n\t\t\t\tsrambank[i] = data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i];\t\t\t\n\t\t\t\tadr[i] = pseuAdr[23-3*i:21-3*i];\t\n\t\t\t\tsub_srambank [i]= {sub_pixel[i][0],sub_pixel[i][1],sub_pixel[i][2],sub_pixel[i][3]};\n\t\t\t\tif(adr[i][0]==0)\n\t\t\t\t\tval_top0 [i]= posIn4[i];\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tval_top0 [i]= 25;\n\t\t\t\t\t\n\t\t\t\tif(adr[i]!=7 && adr[i][0]==1)\n\t\t\t\t\tval_left0 [i] = posIn4[i];\n\t\t\t\telse\n\t\t\t\t\tval_left0 [i] = 25;\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc0[i] =\t!isLeft && !isTopLeft && adr[i][0]==1;\n\t\t\t\tc1[i] = (  adr[i][0]==1 &&    (verLevel[ankor_y] > verLevel[val_left0[i][3:0]] && partIdx == 1) \t );\t\t\n\t\t\t\tc1_2[i] =  (  adr[i][0]==1 && (partIdx[0]==0 && ((val_left0[i] >= nMaxCBin4 && val_left0[i]!=25)  ||  verLevel[ankor_y] != verLevel[val_left0[i][3:0]])    ) ) ;\n\t\t\t\tc2[i] = (adr[i][0]==1  && partIdx == 3 &&  ( (val_left0[i] >= nMaxCBin4 && val_left0[i]!=25)     ||  (verLevel[ankor_y] != verLevel[val_left0[i][3:0]]) ) );\t\n\t\t\t\tc3[i] = !isAbove && !isTopLeft && isLeft && adr[i][0]==0;\n\t\t\t\tc3_1[i] = adr[i][0]==1 && isBtBorder && val_left0[i]>=posBtBorderIn4 && val_left0[i]!=25 && partIdx != 1 && isLeft;\n\t\t\t\tc3_2[i] = adr[i][0]==0 && isRtBorder && val_top0[i]>=posRtBorderIn4 && isAbove;\n\t\t\t\tc_tr[i] = (adr[i][0]==0  && (  ((horLevel[ankor_x] != horLevel[val_top0[i][3:0]]) && yTbInCU!=0)|| (partIdx==3 && val_top0[i]>= nMaxCBin4 && val_left0[i]!=25) ) ) && !bStop\t; \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc6[i]\t= ( (xTb_ltP && pre_modeHor && val_top0 [i] == bypa_pos_1 && bp_f_1 ==0 && !isTpInCB) ) && b03 &&   awkCnt> cnt_by1 ; \n\t\t\t\tc14_1[i] = b03 && xTb_gtP && ( val_left0[i]== bypa_pos_1 && bp_f_1 ==1 &&  !pre_modeHor) && !bNull && awkCnt> cnt_by1 && isChroma==0;\t\t\n\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tc5[i]\t=\t(xTb_ltP && b03 && !pre_modeHor && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && !isTpInCB) && awkCnt> cnt_by2 ;\t\n\t\t\t\tc7[i]   = (xTb_gtP && (pre_modeHor && b03 ) && val_left0 [i] == bypa_pos_2 && bp_f_2 ==1)\t&& awkCnt> cnt_by2\t;\n\t\t\t\tc8[i]\t= !l1_xTb_gtP && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && b12  && awkCnt> cnt_by2 && !isTpInCB ;\t\t\n\t\t\t\tc10[i]\t= l1_xTb_gtP && val_left0 [i] == bypa_pos_2 && bp_f_2 ==1 && b12  && awkCnt> cnt_by2 ;\t\t\t\n\t\t\t\tc11[i]\t= ((!l1_xTb_gtP && l1_pre_modeHor && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && !isTpInCB)\t\n\t\t\t\t\t\t\t\t\t\t\t|| (l1_xTb_gtP && !l1_pre_modeHor && val_left0[i] == bypa_pos_2 && bp_f_2 ==1)  ) &&  b13 && awkCnt> cnt_by2 ;\t\t\n\t\t\t\tc14[i] \t= tuSize ==2 && partIdx ==0 && (val_left0[i]== bypa_pos_2 && bp_f_2 ==1 && (pre_tuSize==3 && pre_modeHor)) && awkCnt> cnt_by2  && !bNull && isChroma==0;  \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc7_1[i]   = (xTb_gtP &&  b03  && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1)\t&& awkCnt> cnt_by3\t;\n\t\t\t\n\t\t\t\n\t\t\t\tc4[i]\t= (xTb_ltP && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && (b02 || pre_tuSize==3)  && awkCnt> cnt_by3 && !isTpInCB) ;\t\t\n\t\t\t\tc12[i]\t= l2_pre_tuSize== 2 && !l2_xTb_gtP && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && b2  && awkCnt> cnt_by3 && !isTpInCB; \n\t\t\t\tc13[i]  = l2_pre_tuSize== 2 && l2_xTb_gtP && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1 && b2  && awkCnt> cnt_by3 ;\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tc9[i] =   b13  &&  val_left0 [i] == bypa_pos_3 && bp_f_3 ==1  && (l1_xTb_gtP && l1_pre_modeHor) &&   awkCnt> cnt_by3;\t\n\t\t\t\tc9_1[i] = b13  &&  val_top0 [i]  == bypa_pos_3 && bp_f_3 ==0  && (!l1_pre_modeHor && !l1_xTb_gtP) &&   awkCnt> cnt_by3 && !isTpInCB;\t\n\t\t\t\tc17[i]  = b23  && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1  &&  l2_xTb_gtP && !l2_pre_modeHor   && awkCnt> cnt_by3;\t\n\t\t\t\tc17_1[i] = b23  && val_top0 [i]  == bypa_pos_3 && bp_f_3 ==0  &&  !l2_xTb_gtP && l2_pre_modeHor   && awkCnt> cnt_by3 && !isTpInCB;\t\n\t\t\t\tc18[i] = order==0 && pre_tuSize==4 && xTb_gtP && !pre_modeHor && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1 && awkCnt> cnt_by3;\n\t\t\t\tc18_1[i] = order==0 && pre_tuSize==4 && xTb_ltP && pre_modeHor && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && awkCnt> cnt_by3 && !isTpInCB;\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tc14_a[i] \t= tuSize ==2 && partIdx ==0 && (val_left0[i]== bypa_pos_3 && bp_f_3 ==1 && pre_tuSize==3 ) && !bNull && isChroma==0 && awkCnt> cnt_by3;  \n\t\t\t\tc15[i]\t= tuSize==2 && partIdx== 1 && ((l2_pre_tuSize ==2 || l2_pre_tuSize==3 && l2_pre_modeHor) && val_top0[i] == bypa_pos_3 && bp_f_3 ==0 && !isTpInCB) && awkCnt> cnt_by3 && !bStop && !isChroma;\t\n\t\t\t\tc16[i]\t= val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && awkCnt> cnt_by3 && tuSize==2 && partIdx==2 && !bStop && isChroma==0;\t\t\t\n\t\t\t\t\n\t\t\t\tif(isChroma && ((pre_tuSize==2 && cIdx==1 ) || (l2_pre_tuSize[1]==1 && cIdx==2)))\tbegin\n\t\t\t\t\tc_cr1[i] =((xTb_ltP && val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(xTb>=pre_xTb && val_left0[i]== bypa_pos_3 && bp_f_3 ==1))  && !bNull ;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tc_cr1[i] = 0;\t\n\t\t\t\t\n\t\t\t\tif(isChroma && ((l2_pre_tuSize[1]==1 && cIdx==2)))\tbegin\n\t\t\t\t\tc_cr2[i] =((!l2_xTb_gtP && val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(l2_xTb_gtP && val_left0[i]== bypa_pos_3 && bp_f_3 ==1))  && !bNull ;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tc_cr2[i] = 0;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc16_1[i]  = val_top0[i]== by4_1_forStop_pos   && !bStop && tuSize==2 && partIdx==3;\n\t\t\t\t\t\n\t\t\t\tc_n2o0[i] =  ((   (c6[i]  || c7[i] || c7_1[i] ))  || ( (c4[i] || c5[i]) ) );\n\t\t\t\n\t\t\t\tc_n2o1[i] = (((c8[i] ||c10[i]) ) || ((c11[i] || c9[i] || c9_1[i]))) ;\n\t\t\t\t\n\t\t\t\tc_n2o2[i] = (c12[i] || c13[i] || c17[i] || c17_1[i]);\n\t\t\t\t\n\t\n\t\t\t\tDR_substi[i] = (p3[i] && isChroma) ||c_cr1[i] || c_cr2[i] || ( bNull || c0[i] || c3_1[i] || c3_2[i])|| ((c1[i] || c1_2[i] || c2[i] ) || (c3[i] || c_tr[i] || c14_1[i] || c16_1[i] || c18[i] || c18_1[i]) || ( c15[i]|| c16[i] ||c14[i] || c14_a[i])|| (adr[i]==7) )|| ((tuSize!=2 && !bNull && isChroma==0 && (c_n2o0[i]|| c_n2o1[i] || c_n2o2[i]))) ;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tp1[i] =((xTb_ltP && val_top0[i]== bypa_pos_1 && bp_f_1 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(xTb_gtP && val_left0[i]== bypa_pos_1 && bp_f_1 ==1))  && !bNull ;\n\t\t\t\n\t\t\t\tp2[i] = c3[i] && above_null_by1_from_left && !bNull && (pre_tuSize==2 || (pre_tuSize==3 && (xTb_gtP ^^ pre_modeHor))) && awkCnt> cnt_by1;\n\t\t\t\tp3[i] = (c1[i] || c2[i]) && pre_tuSize==2 && !bNull;\n\t\t\t\t\n\t\t\t\tsubsti_Opt_[i] = 0;\n\t\t\t\t\n\t\t\t\tif((p1[i] && pre_tuSize[1]==1 ) || (((c6[i] || c14_1[i] ) && tuSize!=2 && !bNull && isChroma==0)))\n\t\t\t\t\tsubsti_Opt_[i] = 1;\t\t\t\n\t\t\t\telse if(p2[i])\n\t\t\t\t\tsubsti_Opt_[i] = 2;\t\t\t\n\t\t\t\telse if(p3[i])\n\t\t\t\t\tsubsti_Opt_[i] = 3;\t\t\t\n\t\t\t\telse if((c3_1[i] || c3_2[i]) && pre_tuSize==2 && !isChroma)\t\t\n\t\t\t\t\tsubsti_Opt_[i] = c3_1[i]? 4:5;\t\t\t\n\t\t\n\t\t\n\t\t\t\tif(isChroma)\n\t\t\t\t\tsubsti_Opt_[i] = 0;\n\t\t\tend\n\t\t\tfor(q=0;q<4;q=q+1) begin: xq  \n\t\t\t\talways @(*) begin\t\n\t\t\t\t\n\t\t\t\t\tpixel_SRAM[i][q] =  srambank[i][SRAMDW-1-bitDepth*q:SRAMDW-bitDepth*(q+1)];\t\t\n\t\t\t\t\ttemp_sub[i][q] = 0; \n\t\t\t\t\tif(bNull)\tbegin\n\t\t\t\t\t\ttemp_sub[i][q] = halfVal; \n\t\t\t\t\tend\n\t\t\t\t\telse if(c3[i]) begin\t\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = r_t;\t\t\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\t\telse if (c0[i])\tbegin\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = r_l;\t\t\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\t\telse if(c3_1[i]) begin\n\t\t\t\t\t\ttemp_sub[i][q] = r_b;\n\t\t\t\t\tend\n\t\t\t\t\telse if(c3_2[i]) begin\n\t\t\t\t\t\ttemp_sub[i][q] = r_rt;\n\t\t\t\t\tend\n\t\t\t\t\telse if (c_tr[i])      \n\t\t\t\t\t\tif(yTbInCUin4%8==0)\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_32;\n\t\t\t\t\t\telse if(yTbInCUin4%4==0)\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_16;\n\t\t\t\t\t\telse if(yTbInCUin4%2==0)\t\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_8;\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_4;\n\t\t\t\t\telse if (c1[i] && tuSize!=2)\t\n\t\t\t\t\t\tcase (tuSize)\n\t\t\t\t\t\n\t\t\t\t\t\t3'd3 : temp_sub[i][q] = r_br01_8;\n\t\t\t\t\t\t3'd4 : temp_sub[i][q] = r_br01_16;\n\t\t\t\t\t\tdefault : temp_sub[i][q] = r_br01_32;\n\t\t\t\t\t\tendcase\n\t\t\t\t\telse if(c1_2[i])begin\n\t\t\t\t\t\tif(partIdx[1]==1)\tbegin\n\t\t\t\t\t\t\tif(yTbin4PlusnTBin4%16==0 && xTbInCUin4%16==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_64;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%8==0 && xTbInCUin4%8==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>3)%2==0)?r_br2_32:r_br01_32;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%4==0 && xTbInCUin4%4==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>2)%2==0)?r_br2_16:r_br01_16;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%2==0 && xTbInCUin4%2==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>1)%2==0)?r_br2_8:r_br01_8;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tif(yTbin4Plusn2TBin4%16==0 && xTbInCUin4%16==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_64;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%8==0 && xTbInCUin4%8==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>3)%2==0)?r_br2_32:r_br01_32;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%4==0 && xTbInCUin4%4==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>2)%2==0)?r_br2_16:r_br01_16;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%2==0 && xTbInCUin4%2==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>1)%2==0)?r_br2_8:r_br01_8;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\t\n\t\t\t\t\telse if(c2[i] && tuSize!=2) \n\t\t\t\t\t\tcase (tuSize)\n\t\t\t\t\t\t3'd3 : temp_sub[i][q] = r_br2_8;\n\t\t\t\t\t\t3'd4 : temp_sub[i][q] = r_br2_16;\n\t\t\t\t\t\tdefault : temp_sub[i][q] = r_br2_32;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((c5[i] || c7[i] || c8[i] || c10[i] || c11[i] || c14[i]) && !bNull && isChroma==0)\n\t\t\t\t\t\ttemp_sub[i][q] = bp2_4samp[q];\n\t\t\t\t\tif((  c4[i] || c7_1[i]  || c12[i] || c13[i] || c14_a[i] || c15[i] ||  c9[i] || c9_1[i] ||  c17[i] || c17_1[i] || c18[i] || c18_1[i]) && !bNull && isChroma==0 || c16[i] || c_cr1[i] || c_cr2[i] )\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = bp3_4samp[q];\t\t\t\t\t\t\t\n\t\t\t\t\tif(c16_1[i])\t\n\t\t\t\t\t\ttemp_sub[i][q] = bp_stop_4samp[q];\t\n\t\t\t\t\tif(isChroma && p3[i] && tuSize==2)\n\t\t\t\t\t\ttemp_sub[i][q] = bp3_4samp[3];\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif(DR_substi[i])\n\t\t\t\t\t\tsub_pixel[i][q] = temp_sub[i][q];\n\t\t\t\t\telse\t\n\t\t\t\t\t\tsub_pixel[i][q]=  pixel_SRAM[i][q];\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\t\n\nendmodule\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: intra_s2RefSubsti. Module specification: This module performs reference sample substitution for intra prediction in video encoding. It processes 8 banks of 4 samples each in parallel, handling various block sizes and prediction modes. The module takes inputs such as pseuAdr (addressing information), isAbove/isLeft/isTopLeft (neighboring sample availability flags), tuSize (transform unit size), data (input samples), and various position and mode parameters. It outputs sub_data (substituted reference samples), sub_tl (substituted top-left sample), and substi_Opt (substitution options). Internal signals include srambank (input sample storage), sub_srambank (substituted sample storage), and various registers for processing and control. The module is divided into several sections: input processing, reference sample selection, substitution logic for different cases (e.g., unavailable samples, special modes), an"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: intra_s2RefSubsti\n\nExplanation: This module appears to be part of an intra prediction system for video encoding. It performs reference sample substitution for intra prediction. The module takes various input parameters related to the current block being processed, such as position, size, and neighboring sample information. It then applies a series of conditions and rules to determine how to substitute reference samples for intra prediction. The module handles different block sizes, prediction modes, and special cases for chroma components. It processes multiple samples in parallel (8 banks of 4 samples each) and outputs substituted reference samples for further use in the intra prediction process."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\n[pseuAdr, isAbove, isLeft, isTopLeft, tuSize, nMaxCUlog2, isBtBorder, isRtBorder, posBtBorderIn4, posRtBorderIn4, data, data_tl, horLevel_i, verLevel_i, verFlag, sub_data, sub_tl, partIdx, pre_tuSize, pre_xTb, pre_modeHor, xTb, xTbInCU, yTbInCU, byPa_P_A_2, byPa_P_A_2_cr, byPa_DW_A_3, bp_pos_1, bp_pos_2, bp_pos_3, order, clk, rst_n, arst_n, bStop, i_modiPosIn4, awkCnt, cIdx, by4_1_forStop, by4_1_forStop_cr, by4_1_forStop_pos, gp_bitDepth]\n\nExplanation:\n- pseuAdr, i_modiPosIn4: Addressing information for sample processing\n- isAbove, isLeft, isTopLeft, isBtBorder, isRtBorder: Flags indicating availability of neighboring samples\n- tuSize, nMaxCUlog2, pre_tuSize: Transform unit and coding unit size information\n- posBtBorderIn4, posRtBorderIn4: Border positions\n- data, data_tl: Input sample data\n- horLevel_i, verLevel_i, verFlag: Information about prediction directions\n- xTb, xTbInCU, yTbInCU, pre_xTb: Position information of the current block\n- byPa_P_A_2, byPa_P_A_2_cr, byPa_DW_A_3: Neighboring sample data\n- bp_pos_1, bp_pos_2, bp_pos_3: Bypass sample positions\n- order, partIdx, pre_modeHor: Information about prediction mode and partitioning\n- clk, rst_n, arst_n, bStop: Clock and reset signals\n- awkCnt, cIdx: Processing counters and component index\n- by4_1_forStop, by4_1_forStop_cr, by4_1_forStop_pos: Additional sample data for special cases\n- gp_bitDepth: Bit depth of samples\n\nOutput ports:\n[sub_data, sub_tl, substi_Opt]\n\nExplanation:\n- sub_data: Substituted reference samples for intra prediction\n- sub_tl: Substituted top-left sample\n- substi_Opt: Options or flags indicating the substitution method used"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: [srambank, sub_srambank, pixel_SRAM, pixel_32Reg_SRAM, sub_pixel, adr, temp_sub, r_l, r_t, r_b, r_rt, r_br01_4, r_br01_8, r_br01_16, r_br01_32, r_br01_64, r_br2_8, r_br2_16, r_br2_32, val_top0, val_left0, ankor_x, ankor_y, halfVal, horLevel, verLevel, r_TL, bp2_4samp, bp3_4samp, bp_stop_4samp, l1_xTb_gtP, l2_xTb_gtP, l1_pre_tuSize, l2_pre_tuSize, l3_pre_tuSize, l1_pre_modeHor, l2_pre_modeHor, bNull, nTBin4, yTbin4PlusnTBin4, yTbin4Plusn2TBin4, xTbin4PlusnTBin4, xTbInCUin4, yTbInCUin4, posIn4, bOnlyLeft, substi_Opt_].\n\nExplanation:\n- srambank, sub_srambank: Arrays to store input and substituted sample data\n- pixel_SRAM, pixel_32Reg_SRAM, sub_pixel: Arrays for sample processing and storage\n- adr: Array for addressing sample banks\n- temp_sub: Temporary array for substituted samples\n- r_l, r_t, r_b, r_rt: Reference samples (left, top, bottom, right-top)\n- r_br01_4/8/16/32/64, r_br2_8/16/32: Reference samples for different block sizes\n- val_top0, val_left0: Arrays to store top and left sample positions\n- ankor_x, ankor_y: Anchor positions for sample processing\n- halfVal: Half value based on bit depth\n- horLevel, verLevel: Arrays for horizontal and vertical prediction levels\n- r_TL: Top-left reference sample\n- bp2_4samp, bp3_4samp, bp_stop_4samp: Arrays for bypass and special case samples\n- l1/l2_xTb_gtP, l1/l2/l3_pre_tuSize, l1/l2_pre_modeHor: Pipeline registers for processing\n- bNull: Flag indicating no available reference samples\n- nTBin4, yTbin4PlusnTBin4, yTbin4Plusn2TBin4, xTbin4PlusnTBin4: Position calculations\n- xTbInCUin4, yTbInCUin4: Block positions within coding unit\n- posIn4: Array for sample positions\n- bOnlyLeft: Flag indicating only left samples are available\n- substi_Opt_: Array for substitution options\n\nThese internal signals are used for various calculations, temporary storage, and control logic within the module to perform the reference sample substitution process."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>`timescale 1ns/1ps\nmodule intra_s2RefSubsti(\n\tpseuAdr,\n\tisAbove,\n\tisLeft,\n\tisTopLeft,\n\ttuSize,\n\tnMaxCUlog2,\n\tisBtBorder,\n\tisRtBorder,\n\tposBtBorderIn4,\n\tposRtBorderIn4,\n\tdata,\n\tdata_tl,\n\thorLevel_i, \n\tverLevel_i,\n\tverFlag,\n\tsub_data,\n\tsub_tl,\n\tpartIdx,\n\tpre_tuSize,\n\tpre_xTb,\n\tpre_modeHor,\n\txTb,\n\txTbInCU,\n\tyTbInCU,\n\tbyPa_P_A_2,\n\tbyPa_P_A_2_cr,\n\tbyPa_DW_A_3,\n\tbp_pos_1,\n\tbp_pos_2,\n\tbp_pos_3,\n\torder,\n\tclk,\n\trst_n,\n\tarst_n,\n\tbStop,\n\ti_modiPosIn4,\n\tawkCnt,\n\tcIdx,\n\n\tby4_1_forStop,\n\tby4_1_forStop_cr,\n\tby4_1_forStop_pos,\n\tsubsti_Opt,\n\tgp_bitDepth\n);\n\n\tparameter\t\t\t\t\t\tisChroma =0;\n\tparameter \t\t \t\t\t\tbitDepth = 8;\n\tparameter\t\t\t\t\t\tnSRAMs \t\t=8;\n\tparameter\t\t\t\t\t\tSRAMDW      = bitDepth*4;\n\n\tinput\t\t\t\t\t\t\tclk,rst_n,arst_n,bStop;\n\tinput [nSRAMs*3-1:0]\t\t\tpseuAdr;\n\tinput \t\t\t\t\t\t\tisAbove;\n\tinput\t\t\t\t\t\t\tisLeft;\n\tinput\t\t\t\t\t\t\tisTopLeft;\n\tinput\t\t\t\t\t\t\tisBtBorder;\n\tinput\t\t\t\t\t\t\tisRtBorder;\n\tinput [4:0]\t\t\t\t\t\tposBtBorderIn4,posRtBorderIn4;\n\tinput [12:0]\t\t\t\t\txTb,pre_xTb;\n\tinput [2:0]\t\t\t\t\t\ttuSize,pre_tuSize;\n\tinput\t\t\t\t\t\t\tpre_modeHor;\n\tinput [bitDepth*32-1:0]\t\t\tdata;\n\tinput [bitDepth-1:0]\t\t\tdata_tl;\n\tinput [16*4-1:0]\t\t\t\thorLevel_i;\n\tinput [16*4-1:0]\t\t\t\tverLevel_i;\n\tinput [15:0]\t\t\t\t\tverFlag;\n\tinput [3:0]\t\t\t\t\t\tgp_bitDepth;\n\tinput [1:0]     \t\t\t\tpartIdx;\n\tinput [2:0]\t\t\t\t\t\torder;\n\tinput [6:0]      \t\t\t\txTbInCU ,yTbInCU;\n\tinput [bitDepth*16-1:0]       \tbyPa_P_A_2;\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tinput [bitDepth*11-1:0]       \tbyPa_P_A_2_cr;\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tinput [bitDepth*4-1:0] \t\t\tbyPa_DW_A_3;\t\t\t\n\tinput [5:0]\t\t\t\t\t\tbp_pos_1,bp_pos_2,bp_pos_3;\n\tinput [5*nSRAMs-1:0]\t\t\ti_modiPosIn4;\n\tinput [2:0]\t\t\t\t\t\tnMaxCUlog2;\n\tinput [2:0]\t\t\t\t\t\tawkCnt;\n\tinput [bitDepth*4-1:0]\t\t\tby4_1_forStop,by4_1_forStop_cr;\n\tinput [4:0]\t\t\t\t\t\tby4_1_forStop_pos;\n\tinput [1:0]\t\t\t\t\t\tcIdx;\n\t\n\t\n\twire [4:0]\t\t\t\t\t\tbypa_pos_1,bypa_pos_2,bypa_pos_3;\n\twire\t\t\t\t\t\t\tbp_f_1,bp_f_2,bp_f_3;\n\twire [6:0]\t\t\t\t\t\tnMaxCB = (1<<nMaxCUlog2);\n\twire [5:0]\t\t\t\t\t\tnMaxCBin4 = nMaxCB >>2;\n\twire [2:0]\t\t\t\t\t\tcnt_by2,cnt_by3;\n\twire \t\t\t\t\t\t\tcnt_by1= 0;\n\t\n\twire\t\t\t\t\t\t\tisTpInCB=(yTbInCU==0);\n\t\n\tassign bypa_pos_1 = bp_pos_1[4:0];\t\n\tassign bypa_pos_2 = bp_pos_2[4:0];\n\tassign bypa_pos_3 = bp_pos_3[4:0];\n\tassign bp_f_1 = bp_pos_1[5];\n\tassign bp_f_2 = bp_pos_2[5];\n\tassign bp_f_3 = bp_pos_3[5];\n\t\n\toutput reg [bitDepth*32-1:0]\tsub_data;\n\toutput reg [bitDepth-1:0]\t\tsub_tl;\n\t\n\toutput  reg [3*8+1:0]\t\t\tsubsti_Opt;\n\treg\t[2:0]\t\t\t\t\t\tsubsti_Opt_[7:0];\n\t\n\treg [bitDepth-1:0]\t\t\t\ttemp_tl;\n\treg [bitDepth*4-1:0] \t\t\tsrambank[7:0];\n\treg [bitDepth*4-1:0] \t\t\tsub_srambank[7:0];\n\treg [bitDepth-1:0] \t\t\t\tpixel_SRAM[7:0][3:0];\n\treg [bitDepth-1:0] \t\t\t\tpixel_32Reg_SRAM[7:0][3:0];\n\treg [bitDepth-1:0] \t\t\t\tsub_pixel[7:0][3:0];\n\treg [2:0]\t\t\t\t\t\tadr[7:0];\n\treg [bitDepth-1:0] \t\t\t\ttemp_sub[7:0][3:0]; \n\t\n\treg [bitDepth-1:0]\t\t\t\tr_l,r_t,r_b,r_rt;\n\treg [bitDepth-1:0]\t\t\t\tr_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br01_64;\n\treg [bitDepth-1:0]\t\t\t\tr_br2_8,r_br2_16,r_br2_32;\n\t\n\treg [4:0]\t\t\t\t\t\tval_top0[7:0],val_left0[7:0];\n\t\n\treg [5:0]\t\t\t\t\t\tankor_x,ankor_y;\n\t\n\treg [bitDepth:0]\t\t\t\thalfVal;\n\treg [4:0] \t\t\t\t\t\thorLevel[15:0];\n\treg [4:0] \t\t\t\t\t\tverLevel[15:0];\n\treg [bitDepth-1:0]\t\t\t\tr_TL;\t\t\t\n\t\n\treg [bitDepth-1:0]\t\t\t\tbp2_4samp[3:0];\n\treg [bitDepth-1:0]\t\t\t\tbp3_4samp[3:0];\n\treg [bitDepth-1:0]\t\t\t\tbp_stop_4samp[3:0];\n\treg \t\t\t\t\t\t\tl1_xTb_gtP,l2_xTb_gtP;\n\treg [2:0]\t\t\t\t\t\tl1_pre_tuSize,l2_pre_tuSize,l3_pre_tuSize;\n\treg \t\t\t\t\t\t\tl1_pre_modeHor,l2_pre_modeHor;\n\treg\t\t\t\t\t\t\t\tbNull;\n\treg [4:0]\t\t\t\t\t\tnTBin4;\n\treg [4:0]\t\t\t\t\t\tyTbin4PlusnTBin4,yTbin4Plusn2TBin4;\n\treg [4:0]\t\t\t\t\t\txTbin4PlusnTBin4;\n\n\treg [3:0]\t\t\t\t\t\txTbInCUin4,yTbInCUin4;\t\n\treg [4:0]\t\t\t\t\t\tposIn4[7:0];\n\treg \t\t\t\t\t\t\tbOnlyLeft;\n\treg \t\t\t\t\t\t\tb0,b02,b03,b04,b1,b12,b13,b2,b23;\n\t\t\n\twire\t\t\t\t\t\t\tis_topl_sub_s3;\n\twire\t\t\t\t\t\t\tchannel_Cr;\n\twire\t\t\t\t\t\t\txTb_ltP,xTb_gtP;\n\t\n\tgenerate \n\t\tgenvar t;\n\t\tfor(t=0;t<16;t=t+1)\tbegin: xt\n\t\t\talways @(*) begin\n\t\t\t\tverLevel[t]  =  verLevel_i[63-4*t:60-4*t];\n\t\t\t\thorLevel[t]\t =  horLevel_i[63-4*t:60-4*t];\n\t\t\t\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\tassign \t\t\t\t\t\txTb_ltP = xTb < pre_xTb;\n\tassign\t\t\t\t\t\txTb_gtP = xTb > pre_xTb;\n\t\n\talways  @ (*) begin\n\t\txTbInCUin4 = xTbInCU>>2;\n\t\tyTbInCUin4 = yTbInCU>>2;\n\t\tnTBin4 = (1<<tuSize)>>2;\n\t\tyTbin4PlusnTBin4 = yTbInCUin4+nTBin4;\n\t\tyTbin4Plusn2TBin4 = yTbin4PlusnTBin4+nTBin4;\n\t\txTbin4PlusnTBin4 = xTbInCUin4+nTBin4;\n\t\tankor_x = nTBin4-1+xTbInCUin4;\n\t\tankor_y = nTBin4-1+yTbInCUin4;\n\t\thalfVal = (1<<gp_bitDepth)>>1;\n\t\tbNull = !isAbove && !isLeft && !isTopLeft;\n\t\tbOnlyLeft = (!isAbove && !isTopLeft && isLeft);\n\t\t\n\t\tb0 = (tuSize!=2 && order==0);\n\t\tb02 = (b0 && pre_tuSize ==2);\n\t\tb03 = (b0 && pre_tuSize ==3);\n\t\tb04 = (b0 && pre_tuSize ==4);\n\t\tb1 = (tuSize!=2 && order==1);\n\t\tb12 = (b1 && l1_pre_tuSize ==2);\n\t\tb13 = (b1 && l1_pre_tuSize ==3);\n\t\tb2 = (tuSize!=2 && order==2);\n\t\tb23 = b2 && l2_pre_tuSize ==3;\n\t\t\t\n\t\t{bp3_4samp[0],bp3_4samp[1],bp3_4samp[2],bp3_4samp[3]} = byPa_DW_A_3;\n\tend\n\n\t\n\t\n\tgenerate\n\t\tgenvar e;\n\t\t\tfor(e=0;e<4;e=e+1)\tbegin:xe\n\t\t\t\talways@(*) begin\n\t\t\t\t\tif(cIdx[1]==0)\n\t\t\t\t\t\tbp_stop_4samp[e] = by4_1_forStop[bitDepth*4-1-bitDepth*e:  bitDepth*3 -  bitDepth*e];\t\n\t\t\t\t\telse\n\t\t\t\t\t\tbp_stop_4samp[e] = by4_1_forStop_cr[bitDepth*4-1-bitDepth*e:  bitDepth*3 -  bitDepth*e];\t\n\t\t\t\tend\n\t\t\tend\n\tendgenerate\n\t\n\t\n\t\n\talways @(*) begin\n\t\t{r_br01_64,bp2_4samp[0],bp2_4samp[1],bp2_4samp[2],bp2_4samp[3]} = 0;\n\t\tif(cIdx!=2)\n\t\t\t{r_l,r_t,r_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br01_64,r_br2_8,r_br2_16,r_br2_32,r_b,r_rt,bp2_4samp[0],bp2_4samp[1],bp2_4samp[2],bp2_4samp[3]} = byPa_P_A_2;\n\t\telse\tbegin\n\t\t\t{r_l,r_t,r_br01_4,r_br01_8,r_br01_16,r_br01_32,r_br2_8,r_br2_16,r_br2_32,r_b,r_rt} = byPa_P_A_2_cr;\n\t\t\tend\n\t\t\t\n\tend\n\t\n\talways @(*)\tbegin\n\t\tif(!isAbove && !isLeft && !isTopLeft)\n\t\t\ttemp_tl = halfVal;\n\t\telse if (!isAbove && !isTopLeft)\t\t\n\t\t\ttemp_tl = r_t;\n\t\telse if (!isLeft && !isTopLeft)\t\n\t\t\ttemp_tl = r_l;\n\t\telse if(!isTopLeft) \n\t\t\ttemp_tl = r_t;\n\t\telse if(order==0)\n\t\t\ttemp_tl = data_tl;\n\t\telse \n\t\t\ttemp_tl = r_TL;\n\tend\n\t\n\treg [7:0]\t\t\tp1,p2,p3;\n\treg\t[7:0]\t\t\tc0,c1,c2,c3,c3_1,c3_2,c_tr,c4,c14_1,c5,c6,c7,c7_1,c8,c9,c9_1,\n\t\t\t\t\t\tc10,c11,c12,c13,c14,c14_a,c15,c16,c16_1,c17,c17_1,c18,c18_1,\n\t\t\t\t\t\tc_n2o0,c_n2o1,c_n2o2,c_2pIdx012,DR_substi,c1_2,c_cr1,c_cr2;\n\twire\t\tabove_null_by1_from_left = ((xTbInCUin4)%2==1 && tuSize==2) || (xTbInCUin4%4==2 && (pre_tuSize==3 && order==0))  ;\n\n\tassign\t\t\t\tis_topl_sub_s3  = \tbOnlyLeft &&  above_null_by1_from_left && !bNull && (pre_tuSize==2 || (pre_tuSize==3 && (xTb_gtP ^^ pre_modeHor))) && awkCnt> cnt_by1 && !isChroma;\t\t\n\tassign\t\t\t\tchannel_Cr \t=\tisChroma && cIdx==2;\n\talways @ (posedge clk or negedge arst_n) begin\n\t\tif(~arst_n)\tbegin\n\t\t\tr_TL <= 0;\n\t\t\tl1_xTb_gtP <= 0;\n\t\t\tl2_xTb_gtP <= 0;\n\t\t\tl1_pre_tuSize\t <= 0;\n\t\t\tl2_pre_tuSize\t <= 0;\n\t\t\tl3_pre_tuSize\t <= 0;\n\t\t\tl1_pre_modeHor\t <= 0;\n\t\t\tl2_pre_modeHor\t <= 0;\n\t\t\tsub_tl\t\t\t<=0;\n\t\t\tsubsti_Opt<=0;\n\t\tend\n\t\telse if(~rst_n)\tbegin\n\t\t\tr_TL <= 0;\n\t\t\tl1_xTb_gtP <= 0;\n\t\t\tl2_xTb_gtP <= 0;\n\t\t\tl1_pre_tuSize\t <= 0;\n\t\t\tl2_pre_tuSize\t <= 0;\n\t\t\tl3_pre_tuSize\t <= 0;\n\t\t\tl1_pre_modeHor\t <= 0;\n\t\t\tl2_pre_modeHor\t <= 0;\n\t\t\tsub_tl\t\t\t<=0;\n\t\t\tsubsti_Opt <=0;\n\t\tend\n\t\telse\tbegin\n\t\t\tif(!bStop) \tbegin\n\t\t\t\tif(order==0)\tbegin\n\t\t\t\t\tr_TL <= data_tl;\n\t\t\t\tend\n\t\t\t\tl1_xTb_gtP <= xTb_gtP;\t\t\n\t\t\t\tl2_xTb_gtP <=l1_xTb_gtP;\n\t\t\t\tl1_pre_tuSize\t <= pre_tuSize;\n\t\t\t\tl2_pre_tuSize\t <= l1_pre_tuSize;\n\t\t\t\tl3_pre_tuSize\t <= l2_pre_tuSize;\t\t\n\t\t\t\tl1_pre_modeHor\t <= pre_modeHor;\n\t\t\t\tl2_pre_modeHor\t <= l1_pre_modeHor;\t\t\n\t\t\t\tsub_tl\t\t\t<=\ttemp_tl;\n\t\t\t\t\n\t\t\t\tsubsti_Opt \t\t <= {channel_Cr,is_topl_sub_s3,substi_Opt_[0],substi_Opt_[1],substi_Opt_[2],substi_Opt_[3],substi_Opt_[4],substi_Opt_[5],substi_Opt_[6],substi_Opt_[7]};\n\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\n\n\tassign      cnt_by3 = 3'd2;\t\t\n\tassign      cnt_by2 = 3'd2;\t\t\n\n\t\n\t\n\tgenerate\n\t\tgenvar i,q;\n\t\t for(i=0;i<8;i=i+1)begin: xi\n\t\t\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif (~arst_n)\t\n\t\t\t\t\tsub_data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <= 0;\n\t\t\t\telse if(~rst_n)\n\t\t\t\t\tsub_data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <= 0;\n\t\t\t\telse \n\t\t\t\t\tsub_data [bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] <=  bStop? sub_data [bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i] : sub_srambank[i];\n\t\t\tend\n\t\t\talways @(*) begin\t\t\n\t\t\t\tposIn4[i]\t= i_modiPosIn4[nSRAMs*5-1-5*i:35-5*i];\n\t\t\t\tsrambank[i] = data[bitDepth*32-1-SRAMDW*i:bitDepth*28-SRAMDW*i];\t\t\t\n\t\t\t\tadr[i] = pseuAdr[23-3*i:21-3*i];\t\n\t\t\t\tsub_srambank [i]= {sub_pixel[i][0],sub_pixel[i][1],sub_pixel[i][2],sub_pixel[i][3]};\n\t\t\t\tif(adr[i][0]==0)\n\t\t\t\t\tval_top0 [i]= posIn4[i];\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tval_top0 [i]= 25;\n\t\t\t\t\t\n\t\t\t\tif(adr[i]!=7 && adr[i][0]==1)\n\t\t\t\t\tval_left0 [i] = posIn4[i];\n\t\t\t\telse\n\t\t\t\t\tval_left0 [i] = 25;\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc0[i] =\t!isLeft && !isTopLeft && adr[i][0]==1;\n\t\t\t\tc1[i] = (  adr[i][0]==1 &&    (verLevel[ankor_y] > verLevel[val_left0[i][3:0]] && partIdx == 1) \t );\t\t\n\t\t\t\tc1_2[i] =  (  adr[i][0]==1 && (partIdx[0]==0 && ((val_left0[i] >= nMaxCBin4 && val_left0[i]!=25)  ||  verLevel[ankor_y] != verLevel[val_left0[i][3:0]])    ) ) ;\n\t\t\t\tc2[i] = (adr[i][0]==1  && partIdx == 3 &&  ( (val_left0[i] >= nMaxCBin4 && val_left0[i]!=25)     ||  (verLevel[ankor_y] != verLevel[val_left0[i][3:0]]) ) );\t\n\t\t\t\tc3[i] = !isAbove && !isTopLeft && isLeft && adr[i][0]==0;\n\t\t\t\tc3_1[i] = adr[i][0]==1 && isBtBorder && val_left0[i]>=posBtBorderIn4 && val_left0[i]!=25 && partIdx != 1 && isLeft;\n\t\t\t\tc3_2[i] = adr[i][0]==0 && isRtBorder && val_top0[i]>=posRtBorderIn4 && isAbove;\n\t\t\t\tc_tr[i] = (adr[i][0]==0  && (  ((horLevel[ankor_x] != horLevel[val_top0[i][3:0]]) && yTbInCU!=0)|| (partIdx==3 && val_top0[i]>= nMaxCBin4 && val_left0[i]!=25) ) ) && !bStop\t; \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc6[i]\t= ( (xTb_ltP && pre_modeHor && val_top0 [i] == bypa_pos_1 && bp_f_1 ==0 && !isTpInCB) ) && b03 &&   awkCnt> cnt_by1 ; \n\t\t\t\tc14_1[i] = b03 && xTb_gtP && ( val_left0[i]== bypa_pos_1 && bp_f_1 ==1 &&  !pre_modeHor) && !bNull && awkCnt> cnt_by1 && isChroma==0;\t\t\n\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tc5[i]\t=\t(xTb_ltP && b03 && !pre_modeHor && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && !isTpInCB) && awkCnt> cnt_by2 ;\t\n\t\t\t\tc7[i]   = (xTb_gtP && (pre_modeHor && b03 ) && val_left0 [i] == bypa_pos_2 && bp_f_2 ==1)\t&& awkCnt> cnt_by2\t;\n\t\t\t\tc8[i]\t= !l1_xTb_gtP && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && b12  && awkCnt> cnt_by2 && !isTpInCB ;\t\t\n\t\t\t\tc10[i]\t= l1_xTb_gtP && val_left0 [i] == bypa_pos_2 && bp_f_2 ==1 && b12  && awkCnt> cnt_by2 ;\t\t\t\n\t\t\t\tc11[i]\t= ((!l1_xTb_gtP && l1_pre_modeHor && val_top0 [i] == bypa_pos_2 && bp_f_2 ==0 && !isTpInCB)\t\n\t\t\t\t\t\t\t\t\t\t\t|| (l1_xTb_gtP && !l1_pre_modeHor && val_left0[i] == bypa_pos_2 && bp_f_2 ==1)  ) &&  b13 && awkCnt> cnt_by2 ;\t\t\n\t\t\t\tc14[i] \t= tuSize ==2 && partIdx ==0 && (val_left0[i]== bypa_pos_2 && bp_f_2 ==1 && (pre_tuSize==3 && pre_modeHor)) && awkCnt> cnt_by2  && !bNull && isChroma==0;  \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc7_1[i]   = (xTb_gtP &&  b03  && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1)\t&& awkCnt> cnt_by3\t;\n\t\t\t\n\t\t\t\n\t\t\t\tc4[i]\t= (xTb_ltP && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && (b02 || pre_tuSize==3)  && awkCnt> cnt_by3 && !isTpInCB) ;\t\t\n\t\t\t\tc12[i]\t= l2_pre_tuSize== 2 && !l2_xTb_gtP && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && b2  && awkCnt> cnt_by3 && !isTpInCB; \n\t\t\t\tc13[i]  = l2_pre_tuSize== 2 && l2_xTb_gtP && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1 && b2  && awkCnt> cnt_by3 ;\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tc9[i] =   b13  &&  val_left0 [i] == bypa_pos_3 && bp_f_3 ==1  && (l1_xTb_gtP && l1_pre_modeHor) &&   awkCnt> cnt_by3;\t\n\t\t\t\tc9_1[i] = b13  &&  val_top0 [i]  == bypa_pos_3 && bp_f_3 ==0  && (!l1_pre_modeHor && !l1_xTb_gtP) &&   awkCnt> cnt_by3 && !isTpInCB;\t\n\t\t\t\tc17[i]  = b23  && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1  &&  l2_xTb_gtP && !l2_pre_modeHor   && awkCnt> cnt_by3;\t\n\t\t\t\tc17_1[i] = b23  && val_top0 [i]  == bypa_pos_3 && bp_f_3 ==0  &&  !l2_xTb_gtP && l2_pre_modeHor   && awkCnt> cnt_by3 && !isTpInCB;\t\n\t\t\t\tc18[i] = order==0 && pre_tuSize==4 && xTb_gtP && !pre_modeHor && val_left0 [i] == bypa_pos_3 && bp_f_3 ==1 && awkCnt> cnt_by3;\n\t\t\t\tc18_1[i] = order==0 && pre_tuSize==4 && xTb_ltP && pre_modeHor && val_top0 [i] == bypa_pos_3 && bp_f_3 ==0 && awkCnt> cnt_by3 && !isTpInCB;\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tc14_a[i] \t= tuSize ==2 && partIdx ==0 && (val_left0[i]== bypa_pos_3 && bp_f_3 ==1 && pre_tuSize==3 ) && !bNull && isChroma==0 && awkCnt> cnt_by3;  \n\t\t\t\tc15[i]\t= tuSize==2 && partIdx== 1 && ((l2_pre_tuSize ==2 || l2_pre_tuSize==3 && l2_pre_modeHor) && val_top0[i] == bypa_pos_3 && bp_f_3 ==0 && !isTpInCB) && awkCnt> cnt_by3 && !bStop && !isChroma;\t\n\t\t\t\tc16[i]\t= val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && awkCnt> cnt_by3 && tuSize==2 && partIdx==2 && !bStop && isChroma==0;\t\t\t\n\t\t\t\t\n\t\t\t\tif(isChroma && ((pre_tuSize==2 && cIdx==1 ) || (l2_pre_tuSize[1]==1 && cIdx==2)))\tbegin\n\t\t\t\t\tc_cr1[i] =((xTb_ltP && val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(xTb>=pre_xTb && val_left0[i]== bypa_pos_3 && bp_f_3 ==1))  && !bNull ;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tc_cr1[i] = 0;\t\n\t\t\t\t\n\t\t\t\tif(isChroma && ((l2_pre_tuSize[1]==1 && cIdx==2)))\tbegin\n\t\t\t\t\tc_cr2[i] =((!l2_xTb_gtP && val_top0[i]== bypa_pos_3 && bp_f_3 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(l2_xTb_gtP && val_left0[i]== bypa_pos_3 && bp_f_3 ==1))  && !bNull ;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tc_cr2[i] = 0;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tc16_1[i]  = val_top0[i]== by4_1_forStop_pos   && !bStop && tuSize==2 && partIdx==3;\n\t\t\t\t\t\n\t\t\t\tc_n2o0[i] =  ((   (c6[i]  || c7[i] || c7_1[i] ))  || ( (c4[i] || c5[i]) ) );\n\t\t\t\n\t\t\t\tc_n2o1[i] = (((c8[i] ||c10[i]) ) || ((c11[i] || c9[i] || c9_1[i]))) ;\n\t\t\t\t\n\t\t\t\tc_n2o2[i] = (c12[i] || c13[i] || c17[i] || c17_1[i]);\n\t\t\t\t\n\t\n\t\t\t\tDR_substi[i] = (p3[i] && isChroma) ||c_cr1[i] || c_cr2[i] || ( bNull || c0[i] || c3_1[i] || c3_2[i])|| ((c1[i] || c1_2[i] || c2[i] ) || (c3[i] || c_tr[i] || c14_1[i] || c16_1[i] || c18[i] || c18_1[i]) || ( c15[i]|| c16[i] ||c14[i] || c14_a[i])|| (adr[i]==7) )|| ((tuSize!=2 && !bNull && isChroma==0 && (c_n2o0[i]|| c_n2o1[i] || c_n2o2[i]))) ;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tp1[i] =((xTb_ltP && val_top0[i]== bypa_pos_1 && bp_f_1 ==0 && !isTpInCB)|| \n\t\t\t\t\t\t\t(xTb_gtP && val_left0[i]== bypa_pos_1 && bp_f_1 ==1))  && !bNull ;\n\t\t\t\n\t\t\t\tp2[i] = c3[i] && above_null_by1_from_left && !bNull && (pre_tuSize==2 || (pre_tuSize==3 && (xTb_gtP ^^ pre_modeHor))) && awkCnt> cnt_by1;\n\t\t\t\tp3[i] = (c1[i] || c2[i]) && pre_tuSize==2 && !bNull;\n\t\t\t\t\n\t\t\t\tsubsti_Opt_[i] = 0;\n\t\t\t\t\n\t\t\t\tif((p1[i] && pre_tuSize[1]==1 ) || (((c6[i] || c14_1[i] ) && tuSize!=2 && !bNull && isChroma==0)))\n\t\t\t\t\tsubsti_Opt_[i] = 1;\t\t\t\n\t\t\t\telse if(p2[i])\n\t\t\t\t\tsubsti_Opt_[i] = 2;\t\t\t\n\t\t\t\telse if(p3[i])\n\t\t\t\t\tsubsti_Opt_[i] = 3;\t\t\t\n\t\t\t\telse if((c3_1[i] || c3_2[i]) && pre_tuSize==2 && !isChroma)\t\t\n\t\t\t\t\tsubsti_Opt_[i] = c3_1[i]? 4:5;\t\t\t\n\t\t\n\t\t\n\t\t\t\tif(isChroma)\n\t\t\t\t\tsubsti_Opt_[i] = 0;\n\t\t\tend\n\t\t\tfor(q=0;q<4;q=q+1) begin: xq  \n\t\t\t\talways @(*) begin\t\n\t\t\t\t\n\t\t\t\t\tpixel_SRAM[i][q] =  srambank[i][SRAMDW-1-bitDepth*q:SRAMDW-bitDepth*(q+1)];\t\t\n\t\t\t\t\ttemp_sub[i][q] = 0; \n\t\t\t\t\tif(bNull)\tbegin\n\t\t\t\t\t\ttemp_sub[i][q] = halfVal; \n\t\t\t\t\tend\n\t\t\t\t\telse if(c3[i]) begin\t\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = r_t;\t\t\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\t\telse if (c0[i])\tbegin\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = r_l;\t\t\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\t\telse if(c3_1[i]) begin\n\t\t\t\t\t\ttemp_sub[i][q] = r_b;\n\t\t\t\t\tend\n\t\t\t\t\telse if(c3_2[i]) begin\n\t\t\t\t\t\ttemp_sub[i][q] = r_rt;\n\t\t\t\t\tend\n\t\t\t\t\telse if (c_tr[i])      \n\t\t\t\t\t\tif(yTbInCUin4%8==0)\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_32;\n\t\t\t\t\t\telse if(yTbInCUin4%4==0)\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_16;\n\t\t\t\t\t\telse if(yTbInCUin4%2==0)\t\n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_8;\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_4;\n\t\t\t\t\telse if (c1[i] && tuSize!=2)\t\n\t\t\t\t\t\tcase (tuSize)\n\t\t\t\t\t\n\t\t\t\t\t\t3'd3 : temp_sub[i][q] = r_br01_8;\n\t\t\t\t\t\t3'd4 : temp_sub[i][q] = r_br01_16;\n\t\t\t\t\t\tdefault : temp_sub[i][q] = r_br01_32;\n\t\t\t\t\t\tendcase\n\t\t\t\t\telse if(c1_2[i])begin\n\t\t\t\t\t\tif(partIdx[1]==1)\tbegin\n\t\t\t\t\t\t\tif(yTbin4PlusnTBin4%16==0 && xTbInCUin4%16==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_64;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%8==0 && xTbInCUin4%8==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>3)%2==0)?r_br2_32:r_br01_32;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%4==0 && xTbInCUin4%4==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>2)%2==0)?r_br2_16:r_br01_16;\n\t\t\t\t\t\t\telse if((yTbin4PlusnTBin4)%2==0 && xTbInCUin4%2==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4PlusnTBin4>>1)%2==0)?r_br2_8:r_br01_8;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tif(yTbin4Plusn2TBin4%16==0 && xTbInCUin4%16==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = r_br01_64;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%8==0 && xTbInCUin4%8==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>3)%2==0)?r_br2_32:r_br01_32;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%4==0 && xTbInCUin4%4==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>2)%2==0)?r_br2_16:r_br01_16;\n\t\t\t\t\t\t\telse if((yTbin4Plusn2TBin4)%2==0 && xTbInCUin4%2==0)\n\t\t\t\t\t\t\t\ttemp_sub[i][q] = ((yTbin4Plusn2TBin4>>1)%2==0)?r_br2_8:r_br01_8;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\t\n\t\t\t\t\telse if(c2[i] && tuSize!=2) \n\t\t\t\t\t\tcase (tuSize)\n\t\t\t\t\t\t3'd3 : temp_sub[i][q] = r_br2_8;\n\t\t\t\t\t\t3'd4 : temp_sub[i][q] = r_br2_16;\n\t\t\t\t\t\tdefault : temp_sub[i][q] = r_br2_32;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((c5[i] || c7[i] || c8[i] || c10[i] || c11[i] || c14[i]) && !bNull && isChroma==0)\n\t\t\t\t\t\ttemp_sub[i][q] = bp2_4samp[q];\n\t\t\t\t\tif((  c4[i] || c7_1[i]  || c12[i] || c13[i] || c14_a[i] || c15[i] ||  c9[i] || c9_1[i] ||  c17[i] || c17_1[i] || c18[i] || c18_1[i]) && !bNull && isChroma==0 || c16[i] || c_cr1[i] || c_cr2[i] )\t\t\n\t\t\t\t\t\ttemp_sub[i][q] = bp3_4samp[q];\t\t\t\t\t\t\t\n\t\t\t\t\tif(c16_1[i])\t\n\t\t\t\t\t\ttemp_sub[i][q] = bp_stop_4samp[q];\t\n\t\t\t\t\tif(isChroma && p3[i] && tuSize==2)\n\t\t\t\t\t\ttemp_sub[i][q] = bp3_4samp[3];\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif(DR_substi[i])\n\t\t\t\t\t\tsub_pixel[i][q] = temp_sub[i][q];\n\t\t\t\t\telse\t\n\t\t\t\t\t\tsub_pixel[i][q]=  pixel_SRAM[i][q];\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\t\n\nendmodule\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: intra_s2RefSubsti. Module specification: This module performs reference sample substitution for intra prediction in video encoding. It processes 8 banks of 4 samples each in parallel, handling various block sizes and prediction modes. The module takes inputs such as pseuAdr (addressing information), isAbove/isLeft/isTopLeft (neighboring sample availability flags), tuSize (transform unit size), data (input samples), and various position and mode parameters. It outputs sub_data (substituted reference samples), sub_tl (substituted top-left sample), and substi_Opt (substitution options). Internal signals include srambank (input sample storage), sub_srambank (substituted sample storage), and various registers for processing and control. The module is divided into several sections: input processing, reference sample selection, substitution logic for different cases (e.g., unavailable samples, special modes), an"
                }
            ]
        }
    ]
}