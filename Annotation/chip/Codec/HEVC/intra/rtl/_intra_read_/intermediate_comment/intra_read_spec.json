{
    "spec": "Module name: intra_read. Module specification: The intra_read module is designed for address generation and flag management in an intra prediction system for video coding. It processes input parameters such as block position, size, and coding unit information to generate read addresses for multiple SRAMs, manage horizontal and vertical flags, and handle special cases for different block sizes and positions. The module has inputs including clock (clk), reset signals (arst_n, rst_n), control signals (bStop, bStop_), block coordinates (xTb, yTb), transform unit size (tuSize), and various flags. Outputs include read addresses (r_addr, r_addr_TL), read enable signals (rE_n), horizontal and vertical flags and levels (horFlag, verFlag, verLevel_o, horLevel_o), and modified address information (o_modiPsAdr, o_modiPos",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: intra_read\n\nExplanation: This module appears to be part of an intra prediction system for video coding. It handles address generation and flag management for reading reference samples from memory. The module calculates various address offsets and flags based on input parameters such as block position, size, and coding unit information. It generates read addresses for multiple SRAMs, manages horizontal and vertical flags, and handles special cases for different block sizes and positions within a coding unit. The module also includes logic for handling chroma components and border conditions."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the intra_read module, here are the input and output ports along with their explanations:\n\nInput ports: clk, arst_n, rst_n, bStop, bStop_, pseuAdr, pIdx, X, Y, xTb, yTb, tuSize, isCalStage, nMaxCUlog2, isFirstCycInTb, cIdx, isRtBorder, isBtBorder, posRtBorderIn4, posBtBorderIn4.\n\nExplanation:\n- clk: Clock signal\n- arst_n, rst_n: Asynchronous and synchronous reset signals (active low)\n- bStop, bStop_: Control signals, likely for stopping operations\n- pseuAdr: Pseudo address input (24 bits)\n- pIdx: Prediction index (2 bits)\n- X, Y: Coordinates within the current block (3 bits each)\n- xTb, yTb: Block coordinates (13 bits each)\n- tuSize: Transform Unit size (3 bits)\n- isCalStage: Calculation stage flag\n- nMaxCUlog2: Log2 of maximum Coding Unit size (3 bits)\n- isFirstCycInTb: Flag for first cycle in Transform Block\n- cIdx: Color component index (2 bits)\n- isRtBorder, isBtBorder: Right and bottom border flags\n- posRtBorderIn4, posBtBorderIn4: Right and bottom border positions (5 bits each)\n\nOutput ports: r_addr, r_addr_TL, rE_n, horFlag, verFlag, verLevel_o, horLevel_o, o_modiPsAdr, o_modiPosIn4, o_ram_idx.\n\nExplanation:\n- r_addr: Read address for multiple SRAMs (64 bits)\n- r_addr_TL: Top-left read address (11 bits)\n- rE_n: Read enable signals for SRAMs (9 bits)\n- horFlag, verFlag: Horizontal and vertical flags (16 bits each)\n- verLevel_o, horLevel_o: Vertical and horizontal level outputs (64 bits each)\n- o_modiPsAdr: Modified pseudo address output (24 bits)\n- o_modiPosIn4: Modified position output (40 bits)\n- o_ram_idx: RAM index output (24 bits)"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nBased on the provided Verilog code for the intra_read module, here are the internal signals and their explanations:\n\nInternal signals: s_adr, modi_psAdr, adrVal, horLevel, verLevel, xTbModMaxCu, yTbModMaxCu, xTbModMaxCuRSft2, yTbModMaxCuRSft2, y_bar, x_bar, cor_x, cor_y, Xplus1sf2, Yplus1sf2, nTB, nMaxCU, nMaxCU4, isWhite, x_16, y_16, tu3Npid3, rela_tl_adr, base_tl_adr, adrShift, posIn4, modiPosIn4, ram_idx, s32.\n\nExplanation:\n- s_adr: Array storing pseudo address components (3 bits each)\n- modi_psAdr: Array storing modified pseudo addresses (3 bits each)\n- adrVal: Array storing calculated address values (8 bits each)\n- horLevel, verLevel: Arrays storing horizontal and vertical levels (5 bits each)\n- xTbModMaxCu, yTbModMaxCu: Transform block coordinates modulo max CU size (6 bits each)\n- xTbModMaxCuRSft2, yTbModMaxCuRSft2: Right-shifted versions of xTbModMaxCu and yTbModMaxCu (4 bits each)\n- y_bar, x_bar: Adjusted y and x coordinates within the CU (7 bits each)\n- cor_x, cor_y: Corrected x and y coordinates (6 bits each)\n- Xplus1sf2, Yplus1sf2: (X+1) and (Y+1) left-shifted by 2 (6 bits each)\n- nTB: Size of the transform block (7 bits)\n- nMaxCU: Maximum CU size (7 bits)\n- nMaxCU4: nMaxCU divided by 4 (5 bits)\n- isWhite: Flag for checkerboard pattern (1 bit)\n- x_16, y_16: x and y coordinates divided by 16 (2 bits each)\n- tu3Npid3: Special condition flag for certain transform unit sizes and prediction indices (1 bit)\n- rela_tl_adr: Relative top-left address (4 bits)\n- base_tl_adr: Base top-left address (11 bits)\n- adrShift: Array storing address shift values (8 bits each)\n- posIn4: Array storing positions in units of 4 pixels (5 bits each)\n- modiPosIn4: Array storing modified positions (5 bits each)\n- ram_idx: Array storing RAM indices (4 bits each)\n- s32: Array storing intermediate address calculation values (7 bits each)\n\nThese internal signals are used for various calculations, address generation, and control logic within the intra_read module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n`timescale 1ns/1ps\nmodule intra_read(\n\tclk,\n\tarst_n,\n\trst_n,\n\tbStop,\n\tbStop_,\n\tpseuAdr,\t\t\n\tpIdx,\n\tX,\n\tY,\n\txTb,\n\tyTb,\n\ttuSize,\n\tr_addr,\t\t\n\tr_addr_TL,\n\trE_n,\n\thorFlag,\n\tverFlag,\n\tverLevel_o,\n\thorLevel_o,\n\tisCalStage,\n\tnMaxCUlog2,\n\tisFirstCycInTb,\n\tcIdx,\n\tisRtBorder,\n\tisBtBorder,\n\to_modiPsAdr,\n\to_modiPosIn4,\n\to_ram_idx,\n\tposRtBorderIn4,\n\tposBtBorderIn4\n\t);\n\n\tparameter\t\t\t\t\t\tisChroma = 0;\n\tparameter AW = 8;\n\tparameter AW_TL = 11;\n\tparameter nSRAMs = 9;\n\t\n\tparameter \t\t\t\t\t\t\tPIC_WIDTH = 7680;\n\tparameter\t\t\t\t\t\t\tADR_BASE = PIC_WIDTH>>5;\t\t\n\tparameter\t\t\t\t\t\t\tADR_BASE_TL = PIC_WIDTH>>2;\t\t\n\t\n\tinput\t\t\t\t\t\t\tclk,rst_n,arst_n,bStop,bStop_;\n    input [8*3-1:0] \t\t\t\tpseuAdr;\n\tinput [1:0]\t\t\t\t\t\tpIdx; \n\tinput [12:0]   \t\t\t\t\txTb;\n\tinput [12:0]   \t\t\t\t\tyTb;\n\tinput [2:0]\t\t\t\t\t\tnMaxCUlog2;\n\tinput [2:0]\t\t\t\t\t\tX,Y;\t\n\tinput [2:0]\t\t\t\t\t\ttuSize;\n\tinput\t\t\t\t\t\t\tisCalStage;\n\tinput\t\t\t\t\t\t\tisFirstCycInTb;\n\tinput [1:0]\t\t\t\t\t\tcIdx;\n\tinput\t\t\t\t\t\t\tisRtBorder;\n\tinput\t\t\t\t\t\t\tisBtBorder;\n\tinput  [4:0]\t\t\t\t\tposRtBorderIn4,posBtBorderIn4;\n\t\n    \n    reg [2:0]   \t\t\t\t\ts_adr[7:0];\n\treg [2:0]   \t\t\t\t\tmodi_psAdr[7:0];\n\treg [AW-1:0]        \t\t\tadrVal[7:0];     \n\toutput reg [AW_TL-1:0]  \t\tr_addr_TL;\n\toutput reg [AW*8-1:0] \t\t\tr_addr;\n\toutput reg [nSRAMs-1:0]  \t\trE_n;\n\toutput reg [15:0]\t\t\t\thorFlag,verFlag;\n\toutput reg [16*4-1:0] \t\t\tverLevel_o,horLevel_o;\n\toutput reg [8*3-1:0] \t\t\to_modiPsAdr;\n\toutput reg [8*5-1:0]\t\t\to_modiPosIn4;\n\toutput reg [8*3-1:0]\t\t\to_ram_idx;\n\n\t\n\treg [4:0] \t\t\t\t\t\thorLevel[15:0];\n\treg [4:0] \t\t\t\t\t\tverLevel[15:0];\n\treg [5:0]\t\t\t\t\t\txTbModMaxCu,yTbModMaxCu;\n\treg [3:0]\t\t\t\t\t\txTbModMaxCuRSft2,yTbModMaxCuRSft2;\n\n\treg [6:0] \t\t\t\t\t\ty_bar,x_bar;\n\treg [5:0]\t\t\t\t\t\tcor_x,cor_y;\n\treg [5:0] \t\t\t\t\t\tXplus1sf2,Yplus1sf2;\n\treg [6:0]\t\t\t\t\t\tnTB,nMaxCU;\n\treg [4:0]\t\t\t\t\t\tnMaxCU4;\n\treg \t\t\t\t\t\t\tisWhite;\n\treg [1:0]\t\t\t\t\t\tx_16,y_16;\n\treg\t\t\t\t\t\t\t\ttu3Npid3;\n\n\talways @(*) begin\n\t\tXplus1sf2 = (X+1)<<2;\n\t\tYplus1sf2 = (Y+1)<<2;\t\n\t\tnTB = 1<<tuSize;\n\t\ty_bar = yTb%nMaxCU+Yplus1sf2;\n\t\tx_bar = xTb%nMaxCU+Xplus1sf2;\n\t\tcor_y = ((yTb%nMaxCU)>>2)+(nTB>>2);\n\t\tcor_x = ((xTb%nMaxCU)>>2)+(nTB>>2);\n\t\txTbModMaxCu = xTb%nMaxCU;\n\t\tyTbModMaxCu = yTb%nMaxCU;\n\t\tnMaxCU = (1<<nMaxCUlog2);\n\t\tnMaxCU4 = (nMaxCU>>2);\n\t\tx_16 = (xTbModMaxCu)>>4;\n\t\ty_16 = (yTbModMaxCu)>>4;\n\t\ttu3Npid3 = (tuSize==3 && pIdx ==3) || (tuSize==2 && (xTbModMaxCu>>3)%2==1 && (yTbModMaxCu>>3)%2==1 );\n\t\t\n\t\tisWhite = ((x_16-y_16)%2==0)?1:0;\n\t\t\n\t\txTbModMaxCuRSft2 = xTbModMaxCu>>2;\n\t\tyTbModMaxCuRSft2 = yTbModMaxCu>>2;\n\tend\n\t\n\treg [3:0] \t\t\trela_tl_adr;\n\treg [AW_TL-1:0]  \t\tbase_tl_adr;\n\t\n\talways @(*) begin\n\t\n\t\tif((isFirstCycInTb))\n\t\t\trE_n[8] = 0;\n\t\telse \n\t\t\trE_n[8] = 1;\n\t\t\n\t\tif(yTbModMaxCu==0)\tbegin\t\t\t\n\t\t\trela_tl_adr = 0;\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])?((xTb>>2)-1): ((ADR_BASE_TL>>1)-1+(xTb>>2));\t\t\n\t\t\tend\n\t\telse if( xTbModMaxCu==0  && ((xTb>>nMaxCUlog2)%2 == 1 || yTbModMaxCu!=(nMaxCU>>1) ))\tbegin\t\n\t\t\tbase_tl_adr = (!isChroma)? ADR_BASE_TL+16:(cIdx==1?ADR_BASE_TL+24:ADR_BASE_TL+16);\t\t\t\n\t\t\trela_tl_adr = (yTbModMaxCuRSft2-xTbModMaxCuRSft2);\n\t\t\tend\n\t\telse if( xTbModMaxCu==0 && yTbModMaxCu==(nMaxCU>>1) && (xTb>>nMaxCUlog2)%2==0)\tbegin\t\t\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+32:ADR_BASE_TL+48;\t\t\n\t\t\trela_tl_adr = 0;\n\t\t\tend\n\t\t\t\n\t\telse if ( (xTbModMaxCu >= yTbModMaxCu) && yTbModMaxCu!=0) \tbegin\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+1:ADR_BASE_TL+9;\t\t\n\t\t\trela_tl_adr = (xTbModMaxCuRSft2-yTbModMaxCuRSft2);\n\t\t\tend\n\t\telse if (xTbModMaxCu!=0 && (xTbModMaxCu < yTbModMaxCu) && xTbModMaxCu!=0)\t\tbegin\t\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+32:ADR_BASE_TL+41;\t\t\n\t\t\trela_tl_adr =(yTbModMaxCuRSft2-xTbModMaxCuRSft2);\n\t\t\tend\n\t\telse\tbegin\n\t\t\tbase_tl_adr = 0;\n\t\t\trela_tl_adr =0;\n\t\tend\n\t\t\n\t\t\n\t\tr_addr_TL = rela_tl_adr + base_tl_adr;\n\tend\n\t\n\t\n\treg [AW-1:0] \t\t\tadrShift[7:0];\n\treg [4:0]\t\t\t\tposIn4[7:0];\n\treg [4:0]\t\t\t\tmodiPosIn4[7:0];\n\treg [3:0]\t\t\t\tram_idx[7:0];\n\treg [6:0]\t\t\t\ts32[7:0];\n\tgenerate\n\t  genvar i;\n\t  for(i=0;i<8;i=i+1) begin\t:xi\n\t    always @(*) begin\n\t\t  \n\t\t  s_adr [i] = pseuAdr[(23-3*i):(21-3*i)];\n\t\t  if(s_adr[i][0] == 0)\n\t\t\tposIn4[i] = xTbModMaxCuRSft2+i+(s_adr[i][1]<<3);\n\t\t  else if(s_adr[i]!= 7)\n\t\t\tposIn4[i] = yTbModMaxCuRSft2+(7-i)+(s_adr[i][1]<<3);\n\t\t  else \n\t\t\tposIn4[i] = 25;\n\t\t\n\t\t  if(s_adr[i][0]==1 && s_adr[i]!= 7 && !(isWhite^tu3Npid3))\t\t\t\n\t\t\tram_idx[i] = ((7-posIn4[i]%8)+4)%8;\n\t\t  else if(s_adr[i][0]==1 && s_adr[i]!= 7 && (isWhite^tu3Npid3))\n\t\t\tram_idx[i] = (7-posIn4[i]%8);\n\t\t  else if(s_adr[i][0]==0)\n\t\t\tram_idx[i] = posIn4[i]%8;\n\t\t  else \n\t\t\tram_idx[i] = 10;\n\t\t\t\n\t\t\t\n\t\tcase ({ram_idx[7]==i,ram_idx[6]==i,ram_idx[5]==i,ram_idx[4]==i,ram_idx[3]==i,ram_idx[2]==i,ram_idx[1]==i,ram_idx[0]==i})\n\t\t8'b00000001:\tbegin\t\n\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[0][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[0] )>>3):((ADR_BASE>>1)+((posIn4[0] )>>3)); \t\n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[0] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[0][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\n\n\t\t\t\telse if(s_adr[0][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[0]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[0][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[0]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[0][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[0]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[0];\n\t\t\tmodiPosIn4[i] = posIn4[0];\n\t\t\t\t\n\t\tend\n\t\t8'b00000010:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[1][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[1] )>>3):((ADR_BASE>>1)+((posIn4[1] )>>3));  \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[1] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[1][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[1][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[1]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[1][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[1]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[1][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[1]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[1];\t\n\t\t\tmodiPosIn4[i] = posIn4[1];\n\t\t\t\t\n\t\tend\n\t\t8'b00000100:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[2][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[2] )>>3):((ADR_BASE>>1)+((posIn4[2] )>>3));  \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[2] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[2][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[2][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[2]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[2][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[2]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[2][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[2]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[2];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[2];\t\n\t\tend\n\t\t8'b00001000:begin\t\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[3][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[3] )>>3):((ADR_BASE>>1)+((posIn4[3] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[3] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[3][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[3][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[3]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[3][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[3]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[3][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[3]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[3];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[3];\t\n\t\tend\n\t\t8'b00010000:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[4][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[4] )>>3):((ADR_BASE>>1)+((posIn4[4] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[4] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[4][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\telse if(s_adr[4][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[4]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[4][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[4]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[4][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[4]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[4];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[4];\t\n\t\tend\n\t\t8'b00100000:begin\t\n\t\t\t\t\trE_n[i] = 0;\n\t\t\t\t\t\tif(s_adr[5][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[5] )>>3):((ADR_BASE>>1)+((posIn4[5] )>>3)); \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[5] )>>3):1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(s_adr[5][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\t\t\telse if(s_adr[5][0]==0)\t\t\t\t\t\n\t\t\t\t\t\t\tadrShift[i] = (horFlag[posIn4[5]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\t\t\n\t\t\t\t\t\telse if(s_adr[5][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[5]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse if(s_adr[5][0]==1 && !(isWhite^tu3Npid3))\t\t\t\t\n\t\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[5]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[5];\t\t\t\n\t\t\t\tmodiPosIn4[i] = posIn4[5];\t\t\n\t\t\t\tend\n\t\t8'b01000000:begin\trE_n[i] = 0;\n\t\t\t\t\tif(s_adr[6][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[6] )>>3):((ADR_BASE>>1)+((posIn4[6] )>>3)); \n\t\t\t\t\telse \n\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[6] )>>3):1;\n\t\t\t\t\t\t\n\t\t\t\t\tif(s_adr[6][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\t\telse if(s_adr[6][0]==0)\t\t\t\t\t\n\t\t\t\t\t\tadrShift[i] = (horFlag[posIn4[6]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\t\n\t\t\t\t\telse if(s_adr[6][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[6]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\t\n\t\t\t\t\telse if(s_adr[6][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[6]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[6];\t\t\n\t\t\t\tmodiPosIn4[i] = posIn4[6];\t\n\t\t\t\tend\n\t\t8'b10000000:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[7][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[7] )>>3):((ADR_BASE>>1)+((posIn4[7] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[7] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[7][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[7][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[7]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[7][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[7]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[7][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[7]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[7];\t\n\t\t\t\tmodiPosIn4[i] = posIn4[7];\n\t\t\t\tend\n\t\t\t\t\t\n\t\tdefault :  begin \n\t\t\t\t\ts32[i] = 0;\n\t\t\t\t\tmodiPosIn4[i] = 0;\n\t\t\t\t\tadrShift[i] = ADR_BASE+1;\n\t\t\t\t\trE_n[i] = 1;\n\t\t\t\t\tmodi_psAdr[i] = 7;\n\t\t\t\t\tend\n\t\t\n\t\tendcase\t\t\n\t\t\n\t\t\n\t\t  adrVal[i] = adrShift[i]+s32[i];\n\t\t  r_addr [(8*AW-1-AW*i):(7*AW-AW*i)] = adrVal[i];\n\t\t  \n\t\t end\n\t end\n    endgenerate\n\t\t\n\t\t\n\t\n\t\n\t\n\t\n\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif(~arst_n)\tbegin\n\t\t\t\t\to_modiPsAdr <= 0;\n\t\t\t\t\to_modiPosIn4 <= 0;\n\t\t\t\t\to_ram_idx <= 0;\n\t\t\t\tend\n\t\t\t\telse if(~rst_n)\tbegin\n\t\t\t\t\to_modiPsAdr <= 0;\n\t\t\t\t\to_modiPosIn4 <= 0;\n\t\t\t\t\to_ram_idx <= 0;\n\t\t\t\tend\n\t\t\t\telse\tbegin\n\t\t\t\t\tif(!bStop_) begin\n\t\t\t\t\t\to_modiPsAdr <= {modi_psAdr[0],modi_psAdr[1],modi_psAdr[2],modi_psAdr[3],modi_psAdr[4],modi_psAdr[5],modi_psAdr[6],modi_psAdr[7]};\n\t\t\t\t\t\to_modiPosIn4 <= {modiPosIn4[0],modiPosIn4[1],modiPosIn4[2],modiPosIn4[3],modiPosIn4[4],modiPosIn4[5],modiPosIn4[6],modiPosIn4[7]};\n\t\t\t\t\t\to_ram_idx <= {ram_idx[0][2:0],ram_idx[1][2:0],ram_idx[2][2:0],ram_idx[3][2:0],ram_idx[4][2:0],ram_idx[5][2:0],ram_idx[6][2:0],ram_idx[7][2:0]};\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\tend\n\t\t\n\twire \t\t\tbBt,bRt;\n\tassign    bBt =   isBtBorder && yTbModMaxCuRSft2+(nTB>>2) == posBtBorderIn4;\n\tassign    bRt =    (isRtBorder && xTbModMaxCuRSft2+(nTB>>2)==posRtBorderIn4);\n\t\t\n\tgenerate \n\t\tgenvar v;\n\t\tfor(v=0;v<16;v=v+1)\tbegin\t:xv\n\t\t\talways @(*) begin\n\t\t\t\tverLevel_o [63-4*v:60-4*v] =  verLevel[v];\n\t\t\t\thorLevel_o [63-4*v:60-4*v] =  horLevel[v];\n\t\t\tend\n\t\t\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif(~arst_n)\tbegin\n\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\tverFlag[v] <= 0; \n\t\t\t\t\tverLevel[v] <= 0;\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\t\telse if(~rst_n)\tbegin\n\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\tverFlag[v] <= 0; \n\t\t\t\t\tverLevel[v] <= 0;\n\t\t\t\tend \n\t\t\t\telse\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\n\t\t\t\tif(!cIdx[0] && !bStop)\tbegin\t\t\n\t\t\t\t\t\tif(Y==0 && X==0 && ((((y_bar==x_bar) || bBt) && x_bar+nTB==nMaxCU+4) ||  (bRt && y_bar+nTB==nMaxCU+4) ||  (bRt && bBt)   ))\tbegin\n\t\t\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\t\t\tverLevel[v] <=  0; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if(Y==0 && X==0 && isCalStage)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(v>=xTbModMaxCuRSft2 && v< (xTbModMaxCuRSft2+((nTB>>2))))\tbegin\n\t\t\t\t\t\t\t\t\thorFlag[v] <= !horFlag[v]; \n\t\t\t\t\t\t\t\t\thorLevel[v] <= ( horLevel[v]+(nTB>>2)); \n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(v>=yTbModMaxCuRSft2 && v< (yTbModMaxCuRSft2+((nTB>>2))))\tbegin\n\t\t\t\t\t\t\t\t\tverLevel[v] <=(verLevel[v]+(nTB>>2)); \n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(Y==0 && X==0 && (bRt && (y_bar+nTB==nMaxCU+4 || bBt)))\tbegin\n\t\t\t\t\t\t\tverFlag[v] <=  0; \n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if(Y==0 && X==0 && isCalStage)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(v>=yTbModMaxCuRSft2 && v< (yTbModMaxCuRSft2+((nTB>>2))))\t\n\t\t\t\t\t\t\t\t\tverFlag[v] <= !verFlag[v]; \t\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\t\t\n\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\t\n\t\n\t\nendmodule```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: intra_read. Module specification: The intra_read module is designed for address generation and flag management in an intra prediction system for video coding. It processes input parameters such as block position, size, and coding unit information to generate read addresses for multiple SRAMs, manage horizontal and vertical flags, and handle special cases for different block sizes and positions. The module has inputs including clock (clk), reset signals (arst_n, rst_n), control signals (bStop, bStop_), block coordinates (xTb, yTb), transform unit size (tuSize), and various flags. Outputs include read addresses (r_addr, r_addr_TL), read enable signals (rE_n), horizontal and vertical flags and levels (horFlag, verFlag, verLevel_o, horLevel_o), and modified address information (o_modiPsAdr, o_modiPos"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: intra_read\n\nExplanation: This module appears to be part of an intra prediction system for video coding. It handles address generation and flag management for reading reference samples from memory. The module calculates various address offsets and flags based on input parameters such as block position, size, and coding unit information. It generates read addresses for multiple SRAMs, manages horizontal and vertical flags, and handles special cases for different block sizes and positions within a coding unit. The module also includes logic for handling chroma components and border conditions."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the intra_read module, here are the input and output ports along with their explanations:\n\nInput ports: clk, arst_n, rst_n, bStop, bStop_, pseuAdr, pIdx, X, Y, xTb, yTb, tuSize, isCalStage, nMaxCUlog2, isFirstCycInTb, cIdx, isRtBorder, isBtBorder, posRtBorderIn4, posBtBorderIn4.\n\nExplanation:\n- clk: Clock signal\n- arst_n, rst_n: Asynchronous and synchronous reset signals (active low)\n- bStop, bStop_: Control signals, likely for stopping operations\n- pseuAdr: Pseudo address input (24 bits)\n- pIdx: Prediction index (2 bits)\n- X, Y: Coordinates within the current block (3 bits each)\n- xTb, yTb: Block coordinates (13 bits each)\n- tuSize: Transform Unit size (3 bits)\n- isCalStage: Calculation stage flag\n- nMaxCUlog2: Log2 of maximum Coding Unit size (3 bits)\n- isFirstCycInTb: Flag for first cycle in Transform Block\n- cIdx: Color component index (2 bits)\n- isRtBorder, isBtBorder: Right and bottom border flags\n- posRtBorderIn4, posBtBorderIn4: Right and bottom border positions (5 bits each)\n\nOutput ports: r_addr, r_addr_TL, rE_n, horFlag, verFlag, verLevel_o, horLevel_o, o_modiPsAdr, o_modiPosIn4, o_ram_idx.\n\nExplanation:\n- r_addr: Read address for multiple SRAMs (64 bits)\n- r_addr_TL: Top-left read address (11 bits)\n- rE_n: Read enable signals for SRAMs (9 bits)\n- horFlag, verFlag: Horizontal and vertical flags (16 bits each)\n- verLevel_o, horLevel_o: Vertical and horizontal level outputs (64 bits each)\n- o_modiPsAdr: Modified pseudo address output (24 bits)\n- o_modiPosIn4: Modified position output (40 bits)\n- o_ram_idx: RAM index output (24 bits)"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nBased on the provided Verilog code for the intra_read module, here are the internal signals and their explanations:\n\nInternal signals: s_adr, modi_psAdr, adrVal, horLevel, verLevel, xTbModMaxCu, yTbModMaxCu, xTbModMaxCuRSft2, yTbModMaxCuRSft2, y_bar, x_bar, cor_x, cor_y, Xplus1sf2, Yplus1sf2, nTB, nMaxCU, nMaxCU4, isWhite, x_16, y_16, tu3Npid3, rela_tl_adr, base_tl_adr, adrShift, posIn4, modiPosIn4, ram_idx, s32.\n\nExplanation:\n- s_adr: Array storing pseudo address components (3 bits each)\n- modi_psAdr: Array storing modified pseudo addresses (3 bits each)\n- adrVal: Array storing calculated address values (8 bits each)\n- horLevel, verLevel: Arrays storing horizontal and vertical levels (5 bits each)\n- xTbModMaxCu, yTbModMaxCu: Transform block coordinates modulo max CU size (6 bits each)\n- xTbModMaxCuRSft2, yTbModMaxCuRSft2: Right-shifted versions of xTbModMaxCu and yTbModMaxCu (4 bits each)\n- y_bar, x_bar: Adjusted y and x coordinates within the CU (7 bits each)\n- cor_x, cor_y: Corrected x and y coordinates (6 bits each)\n- Xplus1sf2, Yplus1sf2: (X+1) and (Y+1) left-shifted by 2 (6 bits each)\n- nTB: Size of the transform block (7 bits)\n- nMaxCU: Maximum CU size (7 bits)\n- nMaxCU4: nMaxCU divided by 4 (5 bits)\n- isWhite: Flag for checkerboard pattern (1 bit)\n- x_16, y_16: x and y coordinates divided by 16 (2 bits each)\n- tu3Npid3: Special condition flag for certain transform unit sizes and prediction indices (1 bit)\n- rela_tl_adr: Relative top-left address (4 bits)\n- base_tl_adr: Base top-left address (11 bits)\n- adrShift: Array storing address shift values (8 bits each)\n- posIn4: Array storing positions in units of 4 pixels (5 bits each)\n- modiPosIn4: Array storing modified positions (5 bits each)\n- ram_idx: Array storing RAM indices (4 bits each)\n- s32: Array storing intermediate address calculation values (7 bits each)\n\nThese internal signals are used for various calculations, address generation, and control logic within the intra_read module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>`timescale 1ns/1ps\nmodule intra_read(\n\tclk,\n\tarst_n,\n\trst_n,\n\tbStop,\n\tbStop_,\n\tpseuAdr,\t\t\n\tpIdx,\n\tX,\n\tY,\n\txTb,\n\tyTb,\n\ttuSize,\n\tr_addr,\t\t\n\tr_addr_TL,\n\trE_n,\n\thorFlag,\n\tverFlag,\n\tverLevel_o,\n\thorLevel_o,\n\tisCalStage,\n\tnMaxCUlog2,\n\tisFirstCycInTb,\n\tcIdx,\n\tisRtBorder,\n\tisBtBorder,\n\to_modiPsAdr,\n\to_modiPosIn4,\n\to_ram_idx,\n\tposRtBorderIn4,\n\tposBtBorderIn4\n\t);\n\n\tparameter\t\t\t\t\t\tisChroma = 0;\n\tparameter AW = 8;\n\tparameter AW_TL = 11;\n\tparameter nSRAMs = 9;\n\t\n\tparameter \t\t\t\t\t\t\tPIC_WIDTH = 7680;\n\tparameter\t\t\t\t\t\t\tADR_BASE = PIC_WIDTH>>5;\t\t\n\tparameter\t\t\t\t\t\t\tADR_BASE_TL = PIC_WIDTH>>2;\t\t\n\t\n\tinput\t\t\t\t\t\t\tclk,rst_n,arst_n,bStop,bStop_;\n    input [8*3-1:0] \t\t\t\tpseuAdr;\n\tinput [1:0]\t\t\t\t\t\tpIdx; \n\tinput [12:0]   \t\t\t\t\txTb;\n\tinput [12:0]   \t\t\t\t\tyTb;\n\tinput [2:0]\t\t\t\t\t\tnMaxCUlog2;\n\tinput [2:0]\t\t\t\t\t\tX,Y;\t\n\tinput [2:0]\t\t\t\t\t\ttuSize;\n\tinput\t\t\t\t\t\t\tisCalStage;\n\tinput\t\t\t\t\t\t\tisFirstCycInTb;\n\tinput [1:0]\t\t\t\t\t\tcIdx;\n\tinput\t\t\t\t\t\t\tisRtBorder;\n\tinput\t\t\t\t\t\t\tisBtBorder;\n\tinput  [4:0]\t\t\t\t\tposRtBorderIn4,posBtBorderIn4;\n\t\n    \n    reg [2:0]   \t\t\t\t\ts_adr[7:0];\n\treg [2:0]   \t\t\t\t\tmodi_psAdr[7:0];\n\treg [AW-1:0]        \t\t\tadrVal[7:0];     \n\toutput reg [AW_TL-1:0]  \t\tr_addr_TL;\n\toutput reg [AW*8-1:0] \t\t\tr_addr;\n\toutput reg [nSRAMs-1:0]  \t\trE_n;\n\toutput reg [15:0]\t\t\t\thorFlag,verFlag;\n\toutput reg [16*4-1:0] \t\t\tverLevel_o,horLevel_o;\n\toutput reg [8*3-1:0] \t\t\to_modiPsAdr;\n\toutput reg [8*5-1:0]\t\t\to_modiPosIn4;\n\toutput reg [8*3-1:0]\t\t\to_ram_idx;\n\n\t\n\treg [4:0] \t\t\t\t\t\thorLevel[15:0];\n\treg [4:0] \t\t\t\t\t\tverLevel[15:0];\n\treg [5:0]\t\t\t\t\t\txTbModMaxCu,yTbModMaxCu;\n\treg [3:0]\t\t\t\t\t\txTbModMaxCuRSft2,yTbModMaxCuRSft2;\n\n\treg [6:0] \t\t\t\t\t\ty_bar,x_bar;\n\treg [5:0]\t\t\t\t\t\tcor_x,cor_y;\n\treg [5:0] \t\t\t\t\t\tXplus1sf2,Yplus1sf2;\n\treg [6:0]\t\t\t\t\t\tnTB,nMaxCU;\n\treg [4:0]\t\t\t\t\t\tnMaxCU4;\n\treg \t\t\t\t\t\t\tisWhite;\n\treg [1:0]\t\t\t\t\t\tx_16,y_16;\n\treg\t\t\t\t\t\t\t\ttu3Npid3;\n\n\talways @(*) begin\n\t\tXplus1sf2 = (X+1)<<2;\n\t\tYplus1sf2 = (Y+1)<<2;\t\n\t\tnTB = 1<<tuSize;\n\t\ty_bar = yTb%nMaxCU+Yplus1sf2;\n\t\tx_bar = xTb%nMaxCU+Xplus1sf2;\n\t\tcor_y = ((yTb%nMaxCU)>>2)+(nTB>>2);\n\t\tcor_x = ((xTb%nMaxCU)>>2)+(nTB>>2);\n\t\txTbModMaxCu = xTb%nMaxCU;\n\t\tyTbModMaxCu = yTb%nMaxCU;\n\t\tnMaxCU = (1<<nMaxCUlog2);\n\t\tnMaxCU4 = (nMaxCU>>2);\n\t\tx_16 = (xTbModMaxCu)>>4;\n\t\ty_16 = (yTbModMaxCu)>>4;\n\t\ttu3Npid3 = (tuSize==3 && pIdx ==3) || (tuSize==2 && (xTbModMaxCu>>3)%2==1 && (yTbModMaxCu>>3)%2==1 );\n\t\t\n\t\tisWhite = ((x_16-y_16)%2==0)?1:0;\n\t\t\n\t\txTbModMaxCuRSft2 = xTbModMaxCu>>2;\n\t\tyTbModMaxCuRSft2 = yTbModMaxCu>>2;\n\tend\n\t\n\treg [3:0] \t\t\trela_tl_adr;\n\treg [AW_TL-1:0]  \t\tbase_tl_adr;\n\t\n\talways @(*) begin\n\t\n\t\tif((isFirstCycInTb))\n\t\t\trE_n[8] = 0;\n\t\telse \n\t\t\trE_n[8] = 1;\n\t\t\n\t\tif(yTbModMaxCu==0)\tbegin\t\t\t\n\t\t\trela_tl_adr = 0;\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])?((xTb>>2)-1): ((ADR_BASE_TL>>1)-1+(xTb>>2));\t\t\n\t\t\tend\n\t\telse if( xTbModMaxCu==0  && ((xTb>>nMaxCUlog2)%2 == 1 || yTbModMaxCu!=(nMaxCU>>1) ))\tbegin\t\n\t\t\tbase_tl_adr = (!isChroma)? ADR_BASE_TL+16:(cIdx==1?ADR_BASE_TL+24:ADR_BASE_TL+16);\t\t\t\n\t\t\trela_tl_adr = (yTbModMaxCuRSft2-xTbModMaxCuRSft2);\n\t\t\tend\n\t\telse if( xTbModMaxCu==0 && yTbModMaxCu==(nMaxCU>>1) && (xTb>>nMaxCUlog2)%2==0)\tbegin\t\t\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+32:ADR_BASE_TL+48;\t\t\n\t\t\trela_tl_adr = 0;\n\t\t\tend\n\t\t\t\n\t\telse if ( (xTbModMaxCu >= yTbModMaxCu) && yTbModMaxCu!=0) \tbegin\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+1:ADR_BASE_TL+9;\t\t\n\t\t\trela_tl_adr = (xTbModMaxCuRSft2-yTbModMaxCuRSft2);\n\t\t\tend\n\t\telse if (xTbModMaxCu!=0 && (xTbModMaxCu < yTbModMaxCu) && xTbModMaxCu!=0)\t\tbegin\t\t\n\t\t\tbase_tl_adr = (!isChroma || !cIdx[1])? ADR_BASE_TL+32:ADR_BASE_TL+41;\t\t\n\t\t\trela_tl_adr =(yTbModMaxCuRSft2-xTbModMaxCuRSft2);\n\t\t\tend\n\t\telse\tbegin\n\t\t\tbase_tl_adr = 0;\n\t\t\trela_tl_adr =0;\n\t\tend\n\t\t\n\t\t\n\t\tr_addr_TL = rela_tl_adr + base_tl_adr;\n\tend\n\t\n\t\n\treg [AW-1:0] \t\t\tadrShift[7:0];\n\treg [4:0]\t\t\t\tposIn4[7:0];\n\treg [4:0]\t\t\t\tmodiPosIn4[7:0];\n\treg [3:0]\t\t\t\tram_idx[7:0];\n\treg [6:0]\t\t\t\ts32[7:0];\n\tgenerate\n\t  genvar i;\n\t  for(i=0;i<8;i=i+1) begin\t:xi\n\t    always @(*) begin\n\t\t  \n\t\t  s_adr [i] = pseuAdr[(23-3*i):(21-3*i)];\n\t\t  if(s_adr[i][0] == 0)\n\t\t\tposIn4[i] = xTbModMaxCuRSft2+i+(s_adr[i][1]<<3);\n\t\t  else if(s_adr[i]!= 7)\n\t\t\tposIn4[i] = yTbModMaxCuRSft2+(7-i)+(s_adr[i][1]<<3);\n\t\t  else \n\t\t\tposIn4[i] = 25;\n\t\t\n\t\t  if(s_adr[i][0]==1 && s_adr[i]!= 7 && !(isWhite^tu3Npid3))\t\t\t\n\t\t\tram_idx[i] = ((7-posIn4[i]%8)+4)%8;\n\t\t  else if(s_adr[i][0]==1 && s_adr[i]!= 7 && (isWhite^tu3Npid3))\n\t\t\tram_idx[i] = (7-posIn4[i]%8);\n\t\t  else if(s_adr[i][0]==0)\n\t\t\tram_idx[i] = posIn4[i]%8;\n\t\t  else \n\t\t\tram_idx[i] = 10;\n\t\t\t\n\t\t\t\n\t\tcase ({ram_idx[7]==i,ram_idx[6]==i,ram_idx[5]==i,ram_idx[4]==i,ram_idx[3]==i,ram_idx[2]==i,ram_idx[1]==i,ram_idx[0]==i})\n\t\t8'b00000001:\tbegin\t\n\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[0][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[0] )>>3):((ADR_BASE>>1)+((posIn4[0] )>>3)); \t\n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[0] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[0][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\n\n\t\t\t\telse if(s_adr[0][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[0]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[0][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[0]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[0][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[0]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[0];\n\t\t\tmodiPosIn4[i] = posIn4[0];\n\t\t\t\t\n\t\tend\n\t\t8'b00000010:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[1][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[1] )>>3):((ADR_BASE>>1)+((posIn4[1] )>>3));  \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[1] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[1][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[1][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[1]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[1][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[1]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[1][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[1]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[1];\t\n\t\t\tmodiPosIn4[i] = posIn4[1];\n\t\t\t\t\n\t\tend\n\t\t8'b00000100:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[2][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[2] )>>3):((ADR_BASE>>1)+((posIn4[2] )>>3));  \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[2] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[2][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[2][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[2]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[2][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[2]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[2][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[2]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[2];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[2];\t\n\t\tend\n\t\t8'b00001000:begin\t\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[3][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[3] )>>3):((ADR_BASE>>1)+((posIn4[3] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[3] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[3][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[3][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[3]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[3][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[3]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[3][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[3]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[3];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[3];\t\n\t\tend\n\t\t8'b00010000:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[4][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[4] )>>3):((ADR_BASE>>1)+((posIn4[4] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[4] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[4][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\telse if(s_adr[4][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[4]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[4][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[4]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[4][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[4]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\tmodi_psAdr[i] = s_adr[4];\t\t\n\t\t\tmodiPosIn4[i] = posIn4[4];\t\n\t\tend\n\t\t8'b00100000:begin\t\n\t\t\t\t\trE_n[i] = 0;\n\t\t\t\t\t\tif(s_adr[5][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[5] )>>3):((ADR_BASE>>1)+((posIn4[5] )>>3)); \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[5] )>>3):1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(s_adr[5][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\t\t\telse if(s_adr[5][0]==0)\t\t\t\t\t\n\t\t\t\t\t\t\tadrShift[i] = (horFlag[posIn4[5]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\t\t\n\t\t\t\t\t\telse if(s_adr[5][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[5]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse if(s_adr[5][0]==1 && !(isWhite^tu3Npid3))\t\t\t\t\n\t\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[5]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[5];\t\t\t\n\t\t\t\tmodiPosIn4[i] = posIn4[5];\t\t\n\t\t\t\tend\n\t\t8'b01000000:begin\trE_n[i] = 0;\n\t\t\t\t\tif(s_adr[6][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[6] )>>3):((ADR_BASE>>1)+((posIn4[6] )>>3)); \n\t\t\t\t\telse \n\t\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[6] )>>3):1;\n\t\t\t\t\t\t\n\t\t\t\t\tif(s_adr[6][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t \n\n\t\t\t\t\telse if(s_adr[6][0]==0)\t\t\t\t\t\n\t\t\t\t\t\tadrShift[i] = (horFlag[posIn4[6]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\t\n\t\t\t\t\telse if(s_adr[6][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[6]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\t\n\t\t\t\t\telse if(s_adr[6][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\t\tadrShift[i] = (verFlag[posIn4[6]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[6];\t\t\n\t\t\t\tmodiPosIn4[i] = posIn4[6];\t\n\t\t\t\tend\n\t\t8'b10000000:begin\t\n\t\t\t\trE_n[i] = 0;\n\t\t\t\tif(s_adr[7][0]==0 && yTbModMaxCu==0)\n\t\t\t\t\ts32[i] =  (!isChroma || !cIdx[1])?((posIn4[7] )>>3):((ADR_BASE>>1)+((posIn4[7] )>>3)); \n\t\t\t\telse \n\t\t\t\t\ts32[i] = (!isChroma || !cIdx[1])?((posIn4[7] )>>3):1;\n\t\t\t\t\t\n\t\t\t\tif(s_adr[7][0]== 0 && yTbModMaxCu==0 )\t\n\t\t\t\t\tadrShift[i] = (((xTb>>nMaxCUlog2)<<nMaxCUlog2)>>5);\t\n\n\t\t\t\telse if(s_adr[7][0]==0)\t\t\t\t\t\n\t\t\t\t\tadrShift[i] = (horFlag[posIn4[7]%nMaxCU4]==1)?(ADR_BASE+4 ):(ADR_BASE+8);\n\t\t\t\n\t\t\t\telse if(s_adr[7][0]==1 && (isWhite^tu3Npid3))\t\t\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[7]%nMaxCU4]==1)? (ADR_BASE+6):(ADR_BASE+2);\n\t\t\t\t\t\n\t\t\t\telse if(s_adr[7][0]==1 && !(isWhite^tu3Npid3))\n\t\t\t\t\tadrShift[i] = (verFlag[posIn4[7]%nMaxCU4]==1)? (ADR_BASE+12):(ADR_BASE+10);\n\t\t\t\t\t\n\t\t\t\telse \n\t\t\t\t\tadrShift[i] = 0;\t\t\t\t\n\t\t\t\tmodi_psAdr[i] = s_adr[7];\t\n\t\t\t\tmodiPosIn4[i] = posIn4[7];\n\t\t\t\tend\n\t\t\t\t\t\n\t\tdefault :  begin \n\t\t\t\t\ts32[i] = 0;\n\t\t\t\t\tmodiPosIn4[i] = 0;\n\t\t\t\t\tadrShift[i] = ADR_BASE+1;\n\t\t\t\t\trE_n[i] = 1;\n\t\t\t\t\tmodi_psAdr[i] = 7;\n\t\t\t\t\tend\n\t\t\n\t\tendcase\t\t\n\t\t\n\t\t\n\t\t  adrVal[i] = adrShift[i]+s32[i];\n\t\t  r_addr [(8*AW-1-AW*i):(7*AW-AW*i)] = adrVal[i];\n\t\t  \n\t\t end\n\t end\n    endgenerate\n\t\t\n\t\t\n\t\n\t\n\t\n\t\n\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif(~arst_n)\tbegin\n\t\t\t\t\to_modiPsAdr <= 0;\n\t\t\t\t\to_modiPosIn4 <= 0;\n\t\t\t\t\to_ram_idx <= 0;\n\t\t\t\tend\n\t\t\t\telse if(~rst_n)\tbegin\n\t\t\t\t\to_modiPsAdr <= 0;\n\t\t\t\t\to_modiPosIn4 <= 0;\n\t\t\t\t\to_ram_idx <= 0;\n\t\t\t\tend\n\t\t\t\telse\tbegin\n\t\t\t\t\tif(!bStop_) begin\n\t\t\t\t\t\to_modiPsAdr <= {modi_psAdr[0],modi_psAdr[1],modi_psAdr[2],modi_psAdr[3],modi_psAdr[4],modi_psAdr[5],modi_psAdr[6],modi_psAdr[7]};\n\t\t\t\t\t\to_modiPosIn4 <= {modiPosIn4[0],modiPosIn4[1],modiPosIn4[2],modiPosIn4[3],modiPosIn4[4],modiPosIn4[5],modiPosIn4[6],modiPosIn4[7]};\n\t\t\t\t\t\to_ram_idx <= {ram_idx[0][2:0],ram_idx[1][2:0],ram_idx[2][2:0],ram_idx[3][2:0],ram_idx[4][2:0],ram_idx[5][2:0],ram_idx[6][2:0],ram_idx[7][2:0]};\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\tend\n\t\t\n\twire \t\t\tbBt,bRt;\n\tassign    bBt =   isBtBorder && yTbModMaxCuRSft2+(nTB>>2) == posBtBorderIn4;\n\tassign    bRt =    (isRtBorder && xTbModMaxCuRSft2+(nTB>>2)==posRtBorderIn4);\n\t\t\n\tgenerate \n\t\tgenvar v;\n\t\tfor(v=0;v<16;v=v+1)\tbegin\t:xv\n\t\t\talways @(*) begin\n\t\t\t\tverLevel_o [63-4*v:60-4*v] =  verLevel[v];\n\t\t\t\thorLevel_o [63-4*v:60-4*v] =  horLevel[v];\n\t\t\tend\n\t\t\talways @(posedge clk or negedge arst_n)\tbegin\n\t\t\t\tif(~arst_n)\tbegin\n\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\tverFlag[v] <= 0; \n\t\t\t\t\tverLevel[v] <= 0;\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\t\telse if(~rst_n)\tbegin\n\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\tverFlag[v] <= 0; \n\t\t\t\t\tverLevel[v] <= 0;\n\t\t\t\tend \n\t\t\t\telse\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\n\t\t\t\tif(!cIdx[0] && !bStop)\tbegin\t\t\n\t\t\t\t\t\tif(Y==0 && X==0 && ((((y_bar==x_bar) || bBt) && x_bar+nTB==nMaxCU+4) ||  (bRt && y_bar+nTB==nMaxCU+4) ||  (bRt && bBt)   ))\tbegin\n\t\t\t\t\t\t\thorFlag[v] <= 0; \n\t\t\t\t\t\t\thorLevel[v] <= 0;\n\t\t\t\t\t\t\tverLevel[v] <=  0; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if(Y==0 && X==0 && isCalStage)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(v>=xTbModMaxCuRSft2 && v< (xTbModMaxCuRSft2+((nTB>>2))))\tbegin\n\t\t\t\t\t\t\t\t\thorFlag[v] <= !horFlag[v]; \n\t\t\t\t\t\t\t\t\thorLevel[v] <= ( horLevel[v]+(nTB>>2)); \n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(v>=yTbModMaxCuRSft2 && v< (yTbModMaxCuRSft2+((nTB>>2))))\tbegin\n\t\t\t\t\t\t\t\t\tverLevel[v] <=(verLevel[v]+(nTB>>2)); \n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(Y==0 && X==0 && (bRt && (y_bar+nTB==nMaxCU+4 || bBt)))\tbegin\n\t\t\t\t\t\t\tverFlag[v] <=  0; \n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if(Y==0 && X==0 && isCalStage)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(v>=yTbModMaxCuRSft2 && v< (yTbModMaxCuRSft2+((nTB>>2))))\t\n\t\t\t\t\t\t\t\t\tverFlag[v] <= !verFlag[v]; \t\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\t\t\n\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendgenerate\n\t\n\t\n\t\n\t\nendmodule</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: intra_read. Module specification: The intra_read module is designed for address generation and flag management in an intra prediction system for video coding. It processes input parameters such as block position, size, and coding unit information to generate read addresses for multiple SRAMs, manage horizontal and vertical flags, and handle special cases for different block sizes and positions. The module has inputs including clock (clk), reset signals (arst_n, rst_n), control signals (bStop, bStop_), block coordinates (xTb, yTb), transform unit size (tuSize), and various flags. Outputs include read addresses (r_addr, r_addr_TL), read enable signals (rE_n), horizontal and vertical flags and levels (horFlag, verFlag, verLevel_o, horLevel_o), and modified address information (o_modiPsAdr, o_modiPos"
                }
            ]
        }
    ]
}