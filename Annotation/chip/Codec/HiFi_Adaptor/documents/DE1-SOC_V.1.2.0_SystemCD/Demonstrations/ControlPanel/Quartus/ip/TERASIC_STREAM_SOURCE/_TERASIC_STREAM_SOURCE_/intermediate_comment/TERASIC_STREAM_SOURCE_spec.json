{
    "spec": "Module name: TERASIC_STREAM_SOURCE. Module specification: The TERASIC_STREAM_SOURCE module is designed for generating a video data stream based on selectable patterns and scales, primarily used in video streaming simulations within hardware designs. The input ports include `clk` (system clock), `reset_n` (active low module reset), signals `s_cs`, `s_read`, `s_write` and `s_writedata` for managing read/write operations to control registers, `src_ready` indicating downstream readiness for new data, and `user_mode` allowing dynamic pattern changes. The output ports consist of `s_readdata` delivering data read from the module, `src_valid` signalling video data validity, `src_data` carrying the video pixel data, `src_sop` indicating the start of data packet, and `src_eop` signalling the end of a packet. Internal signals include `stream_active` managing the video streaming state, `pat_id` storing selected pattern ID, position tracking registers `x` and `y`, and `is_send_video_data` controlling the data sending status. The module has key sections: setting pattern ID and stream activation, pixel position management, data output control, and pattern-based color generation for pixel data. Each section is aimed at coordinating frame sequencing, pattern generation, and interfacing with external controls and downstream modules, ensuring the dynamic and adjustable video streaming based on predefined or user-selected patterns.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: TERASIC_STREAM_SOURCE.\nExplanation: The module generates a stream of video data based on different predefined patterns or scales. It processes input control signals to dictate whether the streaming is active, which pattern to use, and the pattern color mode set by the user. The module incorporates parameters to set video dimensions, and through sequential logic, it determines the current x and y position in the frame. Video data gets generated pixel by pixel, where each pixel's data depends on the selected pattern. The output indicates video stream validity, the start and end of a packet, and outputs the pixel data accordingly. This module is typically used for simulating video streaming with configurable patterns in a hardware design."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: clk, reset_n, s_cs, s_read, s_write, s_writedata, src_ready, user_mode.\nExplanation:\n- `clk`: This is the clock input for the module, used to synchronize all sequential operations within the circuit.\n- `reset_n`: Active low reset signal, used to initialize or reset the system to a known state.\n- `s_cs`: Chip select signal, used to enable the access of the control registers, allowing the module to process write or read commands.\n- `s_read`: Read signal indicating when data is requested to be read from the module.\n- `s_write`: Write signal indicating when data is being written into the module.\n- `s_writedata`: Data bus for input data that is being written into the module to control pattern ID and streaming activity.\n- `src_ready`: Signal from a downstream module indicating readiness to accept new video data, controlling the pacing of the data stream.\n- `user_mode`: User input that is used to optionally override the pattern generation mode, allowing dynamic changes to the video pattern.\n\nOutput ports: s_readdata, src_valid, src_data, src_sop, src_eop.\nExplanation:\n- `s_readdata`: Output data bus for data that has been read from the module, typically returning the current state or configuration such as the pattern ID and streaming status.\n- `src_valid`: Signal that indicates whether the video data being outputted is valid. This is used by downstream modules to know when valid data is present on the other outputs.\n- `src_data`: This holds the actual video data output, which represents a pixel's color value based on the currently selected pattern.\n- `src_sop`: Start of packet signal, indicating the beginning of a new frame or video packet.\n- `src_eop`: End of packet signal, indicates that the current pixel is the last in the current packet or frame."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: stream_active, pat_id, x, y, next_xy, disp_pat, is_send_video_data, is_last_pixel.\n\nExplanation:\n- `stream_active`: This register keeps track of whether the video data streaming is currently active or not. It's controlled by input write signals and affects the start and stop of video data streaming.\n- `pat_id`: This register stores the current pattern ID that determines the visual pattern to be used in the video output. It can be set externally via an input write or overridden by the user_mode.\n- `x`: This register is used to keep track of the current horizontal pixel position within the video frame.\n- `y`: This register is used to maintain the vertical pixel position within the video frame. Together with `x`, it manages the positioning over the frame grid.\n- `next_xy`: A wire that evaluates to true when it's time to move to the next pixel position (`x`, `y`), driven by the `src_ready` input and `is_send_video_data` control.\n- `disp_pat`: This wire determines the final pattern used for displaying video data. It selects either `pat_id` or `user_mode` based on a signal within `user_mode`, allowing external on-the-fly changes to the pattern.\n- `is_send_video_data`: This register controls whether the module is currently in the process of sending out video data. It gets set at the beginning of new data transmission and is turned off after the end of a packet.\n- `is_last_pixel`: A wire that checks if the current pixel coordinates (`x`, `y`) correspond to the end of the video frame, used to manage frame boundaries and signaling."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\nmodule TERASIC_STREAM_SOURCE(\n\t\n\tclk,\n\treset_n,\n\t\n\t\n\ts_cs,\n\ts_read,\n\ts_write,\n\ts_readdata,\n\ts_writedata,\n\t\n\t\n\t\n\tsrc_ready,\n\tsrc_valid,\n\tsrc_data,\n\tsrc_sop,\n\tsrc_eop,\n\t\n\tuser_mode\n\t\n\t\n);\n\nparameter VIDEO_W\t= 800;\nparameter VIDEO_H\t= 600;\n\n\n\t\ninput\t\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\t\treset_n;\n\n\n\n\t\ninput\t\t\t\t\t\t\ts_cs;\ninput\t\t\t\t\t\t\ts_read;\ninput\t\t\t\t\t\t\ts_write;\noutput\treg\t[7:0]\t\ts_readdata;\ninput\t\t[7:0]\t\t\t\ts_writedata;\n\n\t\n\t\ninput\t\t\t\t\t\t\tsrc_ready;\noutput\treg\t\t\t\tsrc_valid;\noutput\treg [23:0]\t\tsrc_data;\noutput\treg\t\t\t\tsrc_sop;\noutput\treg\t\t\t\tsrc_eop;\n\n\t\ninput\t\t[7:0]\t\t\t\tuser_mode;\n\n\n`define\tPAT_SCALE\t\t\t7'd0\n`define\tPAT_RED\t\t\t\t7'd1\n`define\tPAT_GREEN\t\t\t7'd2\n`define\tPAT_BLUE\t\t\t\t7'd3\n`define\tPAT_WHITE\t\t\t7'd4\n`define\tPAT_BLACK\t\t\t7'd5\n`define\tPAT_RED_SCALE\t\t7'd6\n`define\tPAT_GREEN_SCALE\t7'd7\n`define\tPAT_BLUE_SCALE\t\t7'd8\n\n\n\n\n\n\nreg \t\t stream_active;\nreg [6:0] pat_id;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\t\n\tif (~reset_n)\n\tbegin\n\t\tpat_id <= 0;\n\t\tstream_active <= 1'b1; \n\tend\n\telse if (s_cs & s_write)\n\t\t{pat_id, stream_active} <= s_writedata;\n\telse if (s_cs & s_read)\n\t\ts_readdata <= {pat_id, stream_active};\nend\n\n\n\nreg [9:0] x;\nreg [9:0] y;\n\n\nwire next_xy;\nassign next_xy = src_ready & is_send_video_data;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\tbegin\n\t\tx <= 0;\n\t\ty <= 0;\n\tend\n\telse if (next_xy) \n\tbegin\n\t\tif (x+1 < VIDEO_W)\n\t\t\tx <= x + 1;\n\t\telse if (y+1 < VIDEO_H)\n\t\tbegin\n\t\t\ty <= y + 1;\n\t\t\tx <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tx <= 0;\n\t\t\ty <= 0;\n\t\tend\n\tend\nend\n\n\n\nwire [6:0] disp_pat;\nassign disp_pat = user_mode[0]?user_mode[7:1]:pat_id;\n\n\n\n\nreg is_send_video_data;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\t\tsrc_valid <= 1'b0;\n\telse\n\t\tsrc_valid <= src_ready;\nend\n\nwire is_last_pixel;\nassign is_last_pixel = ( ((x+1)==VIDEO_W) && ((y+1) == VIDEO_H) )?1'b1:1'b0;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\tbegin\n\t\tis_send_video_data <= 1'b0; \n\t\tsrc_sop <= 1'b0;\n\t\tsrc_eop <= 1'b0;\n\t\tsrc_data <= 0;\n\tend\n\telse if (src_ready)\n\tbegin\n\t\tif (~is_send_video_data)\n\t\tbegin \n\t\t\tis_send_video_data <= 1'b1;\n\t\t\tsrc_sop <= 1'b1;\n\t\t\tsrc_eop <= 1'b0;\n\t\t\tsrc_data <= 0; \n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsrc_sop <= 1'b0;\n\t\t\tsrc_eop <= is_last_pixel;\n\t\t\tif (is_last_pixel)\n\t\t\t\tis_send_video_data <= 1'b0; \n\n\t\t\t\n\t\t\tif (disp_pat == `PAT_SCALE)\n\t\t\tbegin\n\t\t\t\tif (y < VIDEO_H/4)\n\t\t\t\t\tsrc_data <= {8'h00, 8'h00, x[7:0]}; \n\t\t\t\telse if (y < VIDEO_H/2)\n\t\t\t\t\tsrc_data <= {8'h00, x[7:0], 8'h00}; \n\t\t\t\telse if (y < VIDEO_H*3/4)\n\t\t\t\t\tsrc_data <= {x[7:0], 8'h00, 8'h00}; \n\t\t\t\telse\n\t\t\t\t\tsrc_data <= {x[7:0], x[7:0], x[7:0]}; \n\t\t\tend\n\t\t\telse if (disp_pat == `PAT_RED)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, 8'hff};\n\t\t\telse if (disp_pat == `PAT_GREEN)\n\t\t\t\tsrc_data <= {8'h00, 8'hff, 8'h00};\n\t\t\telse if (disp_pat == `PAT_BLUE)\n\t\t\t\tsrc_data <= {8'hff, 8'h00, 8'h00};\n\t\t\telse if (disp_pat == `PAT_WHITE)\n\t\t\t\tsrc_data <= {8'hff, 8'hff, 8'hff};\n\t\t\telse if (disp_pat == `PAT_BLACK)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, 8'h00};\n\t\t\telse if (disp_pat == `PAT_RED_SCALE)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, x[7:0]};\n\t\t\telse if (disp_pat == `PAT_GREEN_SCALE)\n\t\t\t\tsrc_data <= {8'h00, x[7:0], 8'h00};\n\t\t\telse if (disp_pat == `PAT_BLUE_SCALE)\n\t\t\t\tsrc_data <= {x[7:0], 8'h00, 8'h00};\n\t\tend\n\tend\n\t\t\nend\n\n\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: TERASIC_STREAM_SOURCE. Module specification: The TERASIC_STREAM_SOURCE module is designed for generating a video data stream based on selectable patterns and scales, primarily used in video streaming simulations within hardware designs. The input ports include `clk` (system clock), `reset_n` (active low module reset), signals `s_cs`, `s_read`, `s_write` and `s_writedata` for managing read/write operations to control registers, `src_ready` indicating downstream readiness for new data, and `user_mode` allowing dynamic pattern changes. The output ports consist of `s_readdata` delivering data read from the module, `src_valid` signalling video data validity, `src_data` carrying the video pixel data, `src_sop` indicating the start of data packet, and `src_eop` signalling the end of a packet. Internal signals include `stream_active` managing the video streaming state, `pat_id` storing selected pattern ID, position tracking registers `x` and `y`, and `is_send_video_data` controlling the data sending status. The module has key sections: setting pattern ID and stream activation, pixel position management, data output control, and pattern-based color generation for pixel data. Each section is aimed at coordinating frame sequencing, pattern generation, and interfacing with external controls and downstream modules, ensuring the dynamic and adjustable video streaming based on predefined or user-selected patterns."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: TERASIC_STREAM_SOURCE.\nExplanation: The module generates a stream of video data based on different predefined patterns or scales. It processes input control signals to dictate whether the streaming is active, which pattern to use, and the pattern color mode set by the user. The module incorporates parameters to set video dimensions, and through sequential logic, it determines the current x and y position in the frame. Video data gets generated pixel by pixel, where each pixel's data depends on the selected pattern. The output indicates video stream validity, the start and end of a packet, and outputs the pixel data accordingly. This module is typically used for simulating video streaming with configurable patterns in a hardware design."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: clk, reset_n, s_cs, s_read, s_write, s_writedata, src_ready, user_mode.\nExplanation:\n- `clk`: This is the clock input for the module, used to synchronize all sequential operations within the circuit.\n- `reset_n`: Active low reset signal, used to initialize or reset the system to a known state.\n- `s_cs`: Chip select signal, used to enable the access of the control registers, allowing the module to process write or read commands.\n- `s_read`: Read signal indicating when data is requested to be read from the module.\n- `s_write`: Write signal indicating when data is being written into the module.\n- `s_writedata`: Data bus for input data that is being written into the module to control pattern ID and streaming activity.\n- `src_ready`: Signal from a downstream module indicating readiness to accept new video data, controlling the pacing of the data stream.\n- `user_mode`: User input that is used to optionally override the pattern generation mode, allowing dynamic changes to the video pattern.\n\nOutput ports: s_readdata, src_valid, src_data, src_sop, src_eop.\nExplanation:\n- `s_readdata`: Output data bus for data that has been read from the module, typically returning the current state or configuration such as the pattern ID and streaming status.\n- `src_valid`: Signal that indicates whether the video data being outputted is valid. This is used by downstream modules to know when valid data is present on the other outputs.\n- `src_data`: This holds the actual video data output, which represents a pixel's color value based on the currently selected pattern.\n- `src_sop`: Start of packet signal, indicating the beginning of a new frame or video packet.\n- `src_eop`: End of packet signal, indicates that the current pixel is the last in the current packet or frame."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: stream_active, pat_id, x, y, next_xy, disp_pat, is_send_video_data, is_last_pixel.\n\nExplanation:\n- `stream_active`: This register keeps track of whether the video data streaming is currently active or not. It's controlled by input write signals and affects the start and stop of video data streaming.\n- `pat_id`: This register stores the current pattern ID that determines the visual pattern to be used in the video output. It can be set externally via an input write or overridden by the user_mode.\n- `x`: This register is used to keep track of the current horizontal pixel position within the video frame.\n- `y`: This register is used to maintain the vertical pixel position within the video frame. Together with `x`, it manages the positioning over the frame grid.\n- `next_xy`: A wire that evaluates to true when it's time to move to the next pixel position (`x`, `y`), driven by the `src_ready` input and `is_send_video_data` control.\n- `disp_pat`: This wire determines the final pattern used for displaying video data. It selects either `pat_id` or `user_mode` based on a signal within `user_mode`, allowing external on-the-fly changes to the pattern.\n- `is_send_video_data`: This register controls whether the module is currently in the process of sending out video data. It gets set at the beginning of new data transmission and is turned off after the end of a packet.\n- `is_last_pixel`: A wire that checks if the current pixel coordinates (`x`, `y`) correspond to the end of the video frame, used to manage frame boundaries and signaling."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\nmodule TERASIC_STREAM_SOURCE(\n\t\n\tclk,\n\treset_n,\n\t\n\t\n\ts_cs,\n\ts_read,\n\ts_write,\n\ts_readdata,\n\ts_writedata,\n\t\n\t\n\t\n\tsrc_ready,\n\tsrc_valid,\n\tsrc_data,\n\tsrc_sop,\n\tsrc_eop,\n\t\n\tuser_mode\n\t\n\t\n);\n\nparameter VIDEO_W\t= 800;\nparameter VIDEO_H\t= 600;\n\n\n\t\ninput\t\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\t\treset_n;\n\n\n\n\t\ninput\t\t\t\t\t\t\ts_cs;\ninput\t\t\t\t\t\t\ts_read;\ninput\t\t\t\t\t\t\ts_write;\noutput\treg\t[7:0]\t\ts_readdata;\ninput\t\t[7:0]\t\t\t\ts_writedata;\n\n\t\n\t\ninput\t\t\t\t\t\t\tsrc_ready;\noutput\treg\t\t\t\tsrc_valid;\noutput\treg [23:0]\t\tsrc_data;\noutput\treg\t\t\t\tsrc_sop;\noutput\treg\t\t\t\tsrc_eop;\n\n\t\ninput\t\t[7:0]\t\t\t\tuser_mode;\n\n\n`define\tPAT_SCALE\t\t\t7'd0\n`define\tPAT_RED\t\t\t\t7'd1\n`define\tPAT_GREEN\t\t\t7'd2\n`define\tPAT_BLUE\t\t\t\t7'd3\n`define\tPAT_WHITE\t\t\t7'd4\n`define\tPAT_BLACK\t\t\t7'd5\n`define\tPAT_RED_SCALE\t\t7'd6\n`define\tPAT_GREEN_SCALE\t7'd7\n`define\tPAT_BLUE_SCALE\t\t7'd8\n\n\n\n\n\n\nreg \t\t stream_active;\nreg [6:0] pat_id;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\t\n\tif (~reset_n)\n\tbegin\n\t\tpat_id <= 0;\n\t\tstream_active <= 1'b1; \n\tend\n\telse if (s_cs & s_write)\n\t\t{pat_id, stream_active} <= s_writedata;\n\telse if (s_cs & s_read)\n\t\ts_readdata <= {pat_id, stream_active};\nend\n\n\n\nreg [9:0] x;\nreg [9:0] y;\n\n\nwire next_xy;\nassign next_xy = src_ready & is_send_video_data;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\tbegin\n\t\tx <= 0;\n\t\ty <= 0;\n\tend\n\telse if (next_xy) \n\tbegin\n\t\tif (x+1 < VIDEO_W)\n\t\t\tx <= x + 1;\n\t\telse if (y+1 < VIDEO_H)\n\t\tbegin\n\t\t\ty <= y + 1;\n\t\t\tx <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tx <= 0;\n\t\t\ty <= 0;\n\t\tend\n\tend\nend\n\n\n\nwire [6:0] disp_pat;\nassign disp_pat = user_mode[0]?user_mode[7:1]:pat_id;\n\n\n\n\nreg is_send_video_data;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\t\tsrc_valid <= 1'b0;\n\telse\n\t\tsrc_valid <= src_ready;\nend\n\nwire is_last_pixel;\nassign is_last_pixel = ( ((x+1)==VIDEO_W) && ((y+1) == VIDEO_H) )?1'b1:1'b0;\n\nalways @ (posedge clk or negedge reset_n)\nbegin\n\tif (~reset_n)\n\tbegin\n\t\tis_send_video_data <= 1'b0; \n\t\tsrc_sop <= 1'b0;\n\t\tsrc_eop <= 1'b0;\n\t\tsrc_data <= 0;\n\tend\n\telse if (src_ready)\n\tbegin\n\t\tif (~is_send_video_data)\n\t\tbegin \n\t\t\tis_send_video_data <= 1'b1;\n\t\t\tsrc_sop <= 1'b1;\n\t\t\tsrc_eop <= 1'b0;\n\t\t\tsrc_data <= 0; \n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsrc_sop <= 1'b0;\n\t\t\tsrc_eop <= is_last_pixel;\n\t\t\tif (is_last_pixel)\n\t\t\t\tis_send_video_data <= 1'b0; \n\n\t\t\t\n\t\t\tif (disp_pat == `PAT_SCALE)\n\t\t\tbegin\n\t\t\t\tif (y < VIDEO_H/4)\n\t\t\t\t\tsrc_data <= {8'h00, 8'h00, x[7:0]}; \n\t\t\t\telse if (y < VIDEO_H/2)\n\t\t\t\t\tsrc_data <= {8'h00, x[7:0], 8'h00}; \n\t\t\t\telse if (y < VIDEO_H*3/4)\n\t\t\t\t\tsrc_data <= {x[7:0], 8'h00, 8'h00}; \n\t\t\t\telse\n\t\t\t\t\tsrc_data <= {x[7:0], x[7:0], x[7:0]}; \n\t\t\tend\n\t\t\telse if (disp_pat == `PAT_RED)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, 8'hff};\n\t\t\telse if (disp_pat == `PAT_GREEN)\n\t\t\t\tsrc_data <= {8'h00, 8'hff, 8'h00};\n\t\t\telse if (disp_pat == `PAT_BLUE)\n\t\t\t\tsrc_data <= {8'hff, 8'h00, 8'h00};\n\t\t\telse if (disp_pat == `PAT_WHITE)\n\t\t\t\tsrc_data <= {8'hff, 8'hff, 8'hff};\n\t\t\telse if (disp_pat == `PAT_BLACK)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, 8'h00};\n\t\t\telse if (disp_pat == `PAT_RED_SCALE)\n\t\t\t\tsrc_data <= {8'h00, 8'h00, x[7:0]};\n\t\t\telse if (disp_pat == `PAT_GREEN_SCALE)\n\t\t\t\tsrc_data <= {8'h00, x[7:0], 8'h00};\n\t\t\telse if (disp_pat == `PAT_BLUE_SCALE)\n\t\t\t\tsrc_data <= {x[7:0], 8'h00, 8'h00};\n\t\tend\n\tend\n\t\t\nend\n\n\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: TERASIC_STREAM_SOURCE. Module specification: The TERASIC_STREAM_SOURCE module is designed for generating a video data stream based on selectable patterns and scales, primarily used in video streaming simulations within hardware designs. The input ports include `clk` (system clock), `reset_n` (active low module reset), signals `s_cs`, `s_read`, `s_write` and `s_writedata` for managing read/write operations to control registers, `src_ready` indicating downstream readiness for new data, and `user_mode` allowing dynamic pattern changes. The output ports consist of `s_readdata` delivering data read from the module, `src_valid` signalling video data validity, `src_data` carrying the video pixel data, `src_sop` indicating the start of data packet, and `src_eop` signalling the end of a packet. Internal signals include `stream_active` managing the video streaming state, `pat_id` storing selected pattern ID, position tracking registers `x` and `y`, and `is_send_video_data` controlling the data sending status. The module has key sections: setting pattern ID and stream activation, pixel position management, data output control, and pattern-based color generation for pixel data. Each section is aimed at coordinating frame sequencing, pattern generation, and interfacing with external controls and downstream modules, ensuring the dynamic and adjustable video streaming based on predefined or user-selected patterns."
                }
            ]
        }
    ]
}