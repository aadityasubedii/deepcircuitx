{
    "spec": "Module name: alt_vipcti130_Vid2IS. Module specification: The alt_vipcti130_Vid2IS module is a video interface converter that transforms video input streams into internal streams (IS) based on specific configuration parameters. It handles functionalities such as sync extraction, resolution detection, signal conversions, and managing various input and output controls. The module accepts input signals including reset (rst), video clock (vid_clk), video data (vid_data), data enable (vid_de), sync signals (vid_v_sync, vid_h_sync), and others. It produces output signals like internal stream clock (is_clk), data (is_data), start/end of packet (is_sop, is_eop), and various status signals. Internally, it utilizes signals for FIFO management, overflow detection, synchronization, and data conversion. The module is composed of several key blocks: a control",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti130_Vid2IS.\n\nExplanation: The module \"alt_vipcti130_Vid2IS\" functions as a video interface that converts video input streams into internal streams (IS) according to specific configuration parameters. It supports functionalities such as sync extraction, resolution detection, signal conversions, and the handling of various input and output controls. Additionally, this module can work with both embedded syncing signals within the video stream or use separate sync signals depending on the configuration. It also incorporates mechanisms to handle overflow conditions and to synchronize video output to specific standards, ensuring the video data is correctly aligned and formatted for further processing or display."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n### Input Ports:\n\n1. **rst**: Reset signal. This active-high signal resets the module's internal registers and logic to an initial state.\n2. **vid_clk**: Video clock input. This clock synchronizes the video input stream data and control signals.\n3. **vid_data**: Video data input. This multi-bit port carries the pixel data of the video input stream.\n4. **vid_de**: Data enable signal for the video input. This signal indicates when the `vid_data` is valid.\n5. **vid_datavalid**: Signal indicating that the current video data input is valid and should be processed.\n6. **vid_locked**: Signal indicating whether the video input stream is stable and locked.\n7. **vid_f**: Frame signal for the video input. It distinguishes between different frames in the video stream.\n8. **vid_v_sync**: Vertical sync signal for video input. It indicates the start of a new video frame.\n9. **vid_h_sync**: Horizontal sync signal for video input. It indicates the start of a new line within the video frame.\n10. **vid_hd_sdn**: Signal used in synchronization, particularly for distinguishing HD video standards or down-scaling.\n11. **vid_std**: Video standard identifier. This multi-bit signal indicates the video standard of the incoming stream (e.g., resolution, refresh rate).\n12. **is_clk**: Internal stream clock. This clock synchronizes the output internal stream data.\n13. **is_ready**: Signal from downstream logic indicating that it is ready to accept more data from the internal stream.\n14. **av_address**, **av_read**, **av_write**, **av_writedata**: These ports are part of an Avalon interface for reading from and writing to control registers within the module.\n    \n### Output Ports:\n\n1. **is_valid**: Signal indicating that the output internal stream data is valid.\n2. **is_data**: Data of the output internal stream. This multi-bit port carries the pixel data.\n3. **is_sop**: Start of packet signal. Indicates the beginning of a video packet in the internal stream.\n4. **is_eop**: End of packet signal. Indicates the end of a video packet in the internal stream.\n5. **av_readdata**: Data read from the module's control registers, part of the Avalon interface.\n6. **sof**: Start of frame signal. Indicates the beginning of a new frame in the internal stream.\n7. **sof_locked**: Signal indicating whether the start of frame signal is locked and stable.\n8. **refclk_div**: Reference clock divider value. Used for synchronizing video output to a specific standard.\n9. **status_update_int**: Status update signal. Indicates when there has been a change in the module's status.\n10. **overflow**: Signal indicating that an overflow condition occurred, signaling that the internal buffers are full and data may have been lost.\n\nEach input and output port plays a specific role in acquiring video input, processing or transforming this input according to the module's configuration, and then outputting a synchronized internal stream suitable for further processing or display."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n\n1. **alt_clogb2**: A function that calculates the ceiling of the base-2 logarithm of its argument.\n2. **CONVERT_SEQ_TO_PAR**: Determines whether sequential color plane inputs must be converted to parallel.\n3. **DATA_WIDTH**: The width of the data buses inside the module, derived from parameters.\n4. **NUMBER_OF_COLOUR_PLANES_IN_PARALLEL**: The number of color planes fed in parallel.\n5. **BASE**: Adjusts sync polarity based on BPS parameter.\n6. **LOG2_NUMBER_OF_COLOUR_PLANES**: Base-2 logarithm of the number of color planes.\n7. **COLOUR_PLANES_IN_SEQUENCE**: Indicates if color planes are provided in sequence.\n8. **FIFO_DEPTH_INT**: The depth of the internal FIFO, adjusted for color planes and additional storage.\n9. **USED_WORDS_WIDTH**: The width of the word count for the used space in FIFO.\n10. **vid_data_input**: Buffered version of the `vid_data` input signal.\n11. **vid_datavalid_input**: Buffered version of the `vid_datavalid` input signal.\n12. **vid_f_input**: Buffered version of the `vid_f` input signal.\n13. **vid_v_sync_input**: Buffered version of the `vid_v_sync` input signal.\n14. **vid_h_sync_input**: Buffered version of the `vid_h_sync` input signal.\n15. **vid_hd_sdn_input**: Buffered version of the `vid_hd_sdn` input signal.\n16. **rdreq**: Read request signal for the FIFO.\n17. **wrreq**: Write request signal for the FIFO.\n18. **wrreq_pre_swap**: Intermediate write request prior to data format conversion.\n19. **data**: Intermediate video data signal.\n20. **full**: Indicates that the FIFO is full.\n21. **enable**: Control signal to enable the module.\n22. **usedw**: Counter for the used words in FIFO.\n23. **overflow_nxt**: Next-state logic for the overflow condition.\n24. **overflow_reg**: Registers the overflow condition.\n25. **overflow_sticky**: Maintains the overflow status until cleared.\n26. **enable_synced**: Indicates when the output can be enabled, synchronized with vid_clk.\n27. **rst_vid_clk**: Reset signal synchronized to vid_clk.\n28. **ap**: Active pixel signal indicating active video data.\n29. **f**: Frame signal for synchronization purposes.\n30. **start_of_vsync**: Indicates the start of the vertical sync period.\n31. **sync_count**: Counter used to synchronize internal logic with input video sync signals.\n32. **locked**: Indicates the synchronized and stable state of the input stream.\n33. **h_sync, v_sync**: Buffered versions of the `vid_h_sync` and `vid_v_sync` input signals.\n34. **packet**: Indicates whether the current operation constitutes a full packet of data.\n35. **start_of_hsync**: Indicates the start of the horizontal sync period.\n36. **lost_vid_locked**: Indicates the transition from a locked to an unlocked state of the input video.\n37. **overflowed**: Signals if the FIFO overflowed.\n38. **early_eop**: Early indication of the end of packet condition.\n39. **eop**: Signals the end of a packet.\n40. **active_sample_count, active_line_count_f0, ...**: Counters used to detect active video region sizes.\n41. **is_interlaced**: Signal to indicate if the output stream is interlaced.\n42. **sof_sample, sof_subsample, sof_line**: Start-of-frame counters for samples and lines.\n43. **refclk_divider_value**: Configuration value used in sync generation.\n44. **genlock_enable**: Signal that enables synchronization to a genlock source.\n45. **update_sync1, resolution_change_sync1, etc.**: Synchronization signals, ensuring proper timing relations between signals affected by clock domain crossings.\n46. **vid_std_sync1**: Synchronized version of the `vid_std` input signal.\n47. **valid_nxt, valid_reg**: Logic to keep track of the validity of the current data.\n48. **data_reg**: Register holding the video data to be processed.\n49. **vid_f_reg, vid_h_sync_reg, vid_v_sync_reg, vid_datavalid_reg, vid_anc_valid_reg**: Registers for synchronization signals.\n50. **convert**: Flag to start conversion of data from sequential to parallel.\n51. **frame_synch**: Frame synchronization signal that triggers with the end of vsync.\n52. **field_prediction, field_prediction_nxt**: Logic for interlaced signal prediction.\n53. **last_sample**: Indicates the last data sample within the current packet.\n\nExplanation: \n\nThese internal signals serve different roles, like controlling the flow of data through the module, buffering incoming signals to align with internal clocks, providing synchronization between different clock domains, and maintaining state across various cycles of operation. They are instrumental in managing operations such as reading from and writing to FIFOs, signal conversion between sequential and parallel formats, syncing video data to external references, handling overflow conditions, and determining the active video windows for proper video stream processing."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\nmodule alt_vipcti130_Vid2IS(\n    rst,\n    \n    \n    vid_clk,\n    vid_data,\n    vid_de,\n    vid_datavalid,\n    vid_locked,\n    \n    \n    vid_f,\n    vid_v_sync,\n    vid_h_sync,\n    vid_hd_sdn,\n    vid_std,\n    \n    \n    is_clk,\n    is_ready,\n    is_valid,\n    is_data,\n    is_sop,\n    is_eop,\n    \n    \n    av_address,\n    av_read,\n    av_readdata,\n    av_write,\n    av_writedata,\n    \n    \n    sof,\n    sof_locked,\n    refclk_div,\n    \n    \n    status_update_int,\n    \n    \n    overflow) ;\n    \n\n\n\nfunction integer alt_clogb2;\n  input [31:0] value;\n  integer i;\n  begin\n    alt_clogb2 = 32;\n    for (i=31; i>0; i=i-1) begin\n      if (2**i>=value)\n        alt_clogb2 = i;\n    end\n  end\nendfunction\n\nparameter BPS = 10;\nparameter NUMBER_OF_COLOUR_PLANES = 2;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 1;\nparameter FIFO_DEPTH = 1920;\nparameter USE_EMBEDDED_SYNCS = 1;\nparameter ADD_DATA_ENABLE_SIGNAL = 0;\nparameter CLOCKS_ARE_SAME = 0;\nparameter USE_CONTROL = 1;\nparameter INTERLACED = 1;\nparameter H_ACTIVE_PIXELS_F0 = 1920;\nparameter V_ACTIVE_LINES_F0 = 540;\nparameter H_ACTIVE_PIXELS_F1 = 1920;\nparameter V_ACTIVE_LINES_F1 = 540;\nparameter SYNC_TO = 2;\nparameter ACCEPT_COLOURS_IN_SEQ = 1;\nparameter USE_STD = 1;\nparameter STD_WIDTH = 3;\nparameter GENERATE_SYNC = 1;\nparameter GENERATE_ANC = 0;\n\nlocalparam CONVERT_SEQ_TO_PAR = COLOUR_PLANES_ARE_IN_PARALLEL == 1 && ACCEPT_COLOURS_IN_SEQ != 0 && NUMBER_OF_COLOUR_PLANES > 1;\nlocalparam DATA_WIDTH = (COLOUR_PLANES_ARE_IN_PARALLEL) ? BPS * NUMBER_OF_COLOUR_PLANES : BPS;\nlocalparam NUMBER_OF_COLOUR_PLANES_IN_PARALLEL = (COLOUR_PLANES_ARE_IN_PARALLEL) ? NUMBER_OF_COLOUR_PLANES : 1;\nlocalparam BASE = (BPS >= 10) ? 2 : 0;\nlocalparam LOG2_NUMBER_OF_COLOUR_PLANES = alt_clogb2(NUMBER_OF_COLOUR_PLANES);\nlocalparam COLOUR_PLANES_IN_SEQUENCE = (COLOUR_PLANES_ARE_IN_PARALLEL && !CONVERT_SEQ_TO_PAR) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam COLOUR_PLANES_IN_SEQUENCE_FIFO = (COLOUR_PLANES_ARE_IN_PARALLEL) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam FIFO_WIDTH = DATA_WIDTH + 1;\nlocalparam FIFO_DEPTH_INT = (FIFO_DEPTH * COLOUR_PLANES_IN_SEQUENCE_FIFO) + 4;\nlocalparam USED_WORDS_WIDTH = alt_clogb2(FIFO_DEPTH_INT);\n\ninput rst;\n\n\ninput vid_clk;\ninput [DATA_WIDTH-1:0] vid_data;\ninput vid_de;\ninput vid_datavalid;\ninput vid_locked;\n\n\ninput vid_f;\ninput vid_v_sync;\ninput vid_h_sync;\ninput vid_hd_sdn;\ninput [STD_WIDTH-1:0] vid_std;\n\n\ninput is_clk;\ninput is_ready;\noutput is_valid;\noutput [DATA_WIDTH-1:0] is_data;\noutput is_sop;\noutput is_eop;\n\n\ninput [3:0] av_address;\ninput av_read;\noutput [15:0] av_readdata;\ninput av_write;\ninput [15:0] av_writedata;\n\n\noutput sof;\noutput sof_locked;\noutput refclk_div;\n\n\noutput status_update_int;\n\n\noutput overflow;\n\nreg [DATA_WIDTH-1:0] vid_data_input;\nreg vid_datavalid_input;\nreg vid_f_input;\nreg vid_v_sync_input;\nreg vid_h_sync_input;\nreg vid_hd_sdn_input;\n\nwire [DATA_WIDTH-1:0] is_data;\nwire is_valid;\nwire is_sop;\nwire is_eop;\n\nwire rdreq;\nwire wrreq;\nwire wrreq_pre_swap;\nwire [DATA_WIDTH-1:0] data;\nwire full;\nwire enable;\nwire [USED_WORDS_WIDTH-1:0] usedw;\n\nwire overflow_nxt;\nreg overflow_reg;\nreg overflow_sticky;\nwire overflow_sticky_sync1;\n\nreg enable_synced;\n\nwire rst_vid_clk;\nwire ap;\nwire f;\nwire start_of_vsync;\nreg [1:0] sync_count;\nreg locked;\nwire h_sync, v_sync;\nreg h_sync_reg, v_sync_reg;\nwire packet;\nwire start_of_hsync;\nwire lost_vid_locked;\nwire overflowed;\nwire early_eop;\nwire eop;\nwire [14:0] active_sample_count;\nwire [13:0] active_line_count_f0;\nwire [13:0] active_line_count_f1;\nwire [14:0] total_sample_count;\nwire [13:0] total_line_count_f0;\nwire [13:0] total_line_count_f1;\nwire [13:0] total_line_count;\nwire is_interlaced;\nwire [16:0] is_active_sample_count;\nwire [16:0] is_active_line_count_f0;\nwire [16:0] is_active_line_count_f1;\nwire [13:0] sof_sample;\nwire [1:0] sof_subsample;\nwire [12:0] sof_line;\nwire [13:0] refclk_divider_value;\nwire genlock_enable;\nwire update_sync1;\nwire resolution_change;\nwire resolution_change_sync1;\nwire update;\nwire [STD_WIDTH-1:0] vid_std_sync1;\nreg ap_reg;\nwire end_of_vsync;\nwire interlaced;\nwire start_of_ap;\nwire [1:0] sync_count_next;\nwire locked_next;\nwire stable;\nwire resolution_valid;\nwire wrreq_pre_enable;\nreg vid_locked_reg;\nwire clear_overflow_sticky;\nwire is_output_enable;\nwire frame_synch;\nwire field_prediction_nxt;\nreg field_prediction;\nwire vid_clk_int;\nwire last_sample;\nreg f_reg;\n\ngenerate begin : clocks_are_same_generate\n     if(CLOCKS_ARE_SAME) begin\n         assign rst_vid_clk = rst;\n         assign vid_clk_int = is_clk;\n     end else begin\n         reg rst_vid_clk_reg;\n         reg rst_vid_clk_reg2;\n         \n         always @ (posedge rst or posedge vid_clk_int) begin\n             if(rst) begin\n                rst_vid_clk_reg <= 1'b1;\n                rst_vid_clk_reg2 <= 1'b1;\n             end else begin\n                rst_vid_clk_reg <= 1'b0;\n                rst_vid_clk_reg2 <= rst_vid_clk_reg;\n             end\n         end\n         assign rst_vid_clk = rst_vid_clk_reg2;\n         assign vid_clk_int = vid_clk;\n     end\nend endgenerate\n\n\nalt_vipcti130_Vid2IS_control control(\n    .rst(rst),\n    .clk(is_clk),\n\n    \n    .usedw(usedw),\n    .overflow_sticky(overflow_sticky_sync1),\n    .is_output_enable(is_output_enable), \n    \n    \n    .update(update_sync1),\n    .resolution_change(resolution_change_sync1),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .vid_std(vid_std_sync1), \n    \n    \n    .enable(enable),\n    .clear_overflow_sticky(clear_overflow_sticky),\n    .is_interlaced(is_interlaced),\n    .is_active_sample_count(is_active_sample_count),\n    .is_active_line_count_f0(is_active_line_count_f0),\n    .is_active_line_count_f1(is_active_line_count_f1),\n    .sof_sample(sof_sample),\n    .sof_line(sof_line),\n    .sof_subsample(sof_subsample),\n    .refclk_divider_value(refclk_divider_value),\n    .genlock_enable(genlock_enable),\n    \n    \n    .av_address(av_address),\n    .av_read(av_read),\n    .av_readdata(av_readdata),\n    .av_write(av_write),\n    .av_writedata(av_writedata),\n    \n    .status_update_int(status_update_int));\n    \ndefparam control.USE_CONTROL = USE_CONTROL,\n         control.INTERLACED = INTERLACED,\n         control.H_ACTIVE_PIXELS_F0 = H_ACTIVE_PIXELS_F0,\n         control.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         control.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         control.USED_WORDS_WIDTH = USED_WORDS_WIDTH,\n         control.STD_WIDTH = STD_WIDTH;\n         \n\ngenerate begin : use_std_generate\n    if(USE_STD) begin\n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME, STD_WIDTH) vid_std_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(vid_std),\n            .data_out(vid_std_sync1));\n    end else begin\n        assign vid_std_sync1 = {STD_WIDTH{1'b0}};\n    end\nend endgenerate\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) overflow_sticky_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(overflow_sticky),\n    .data_out(overflow_sticky_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) update_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(update),\n    .data_out(update_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) resolution_change_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(resolution_change),\n    .data_out(resolution_change_sync1));\n\n\nwire enable_sync1;\nwire clear_overflow_sticky_sync1;\nwire genlock_enable_sync1;\nwire [13:0] refclk_divider_value_sync1;\nwire [13:0] sof_sample_sync1;\nwire [12:0] sof_line_sync1;\nwire [1:0] sof_subsample_sync1;\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(enable),\n    .data_out(enable_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) clear_overflow_sticky_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(clear_overflow_sticky),\n    .data_out(clear_overflow_sticky_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) genlock_enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(genlock_enable),\n    .data_out(genlock_enable_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 14) refclk_divider_value_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(refclk_divider_value),\n    .data_out(refclk_divider_value_sync1));\n  \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 14) sof_sample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_sample),\n    .data_out(sof_sample_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 13) sof_line_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_line),\n    .data_out(sof_line_sync1));\n \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 2) sof_subsample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_subsample),\n    .data_out(sof_subsample_sync1));\n    \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if (rst_vid_clk) begin\n        vid_data_input <= {DATA_WIDTH{1'b0}};\n        vid_datavalid_input <= 1'b0;\n        vid_f_input <= 1'b0;\n        vid_v_sync_input <= 1'b0;\n        vid_h_sync_input <= 1'b0;\n        vid_hd_sdn_input <= 1'b0;\n    end else begin\n        vid_data_input <= vid_data;\n        if (~USE_EMBEDDED_SYNCS && ADD_DATA_ENABLE_SIGNAL)\n            vid_datavalid_input <= vid_de;\n        else\n            vid_datavalid_input <= vid_datavalid;\n        vid_f_input <= vid_f;\n        vid_v_sync_input <= vid_v_sync;\n        vid_h_sync_input <= vid_h_sync;\n        if(CONVERT_SEQ_TO_PAR)\n            vid_hd_sdn_input <= vid_hd_sdn;\n        else\n            vid_hd_sdn_input <= COLOUR_PLANES_ARE_IN_PARALLEL;\n    end\nend\n\n\nwire vid_enable_int;\nwire vid_f_int;\nwire vid_h_sync_int;\nwire vid_v_sync_int;\nwire vid_datavalid_int;\nwire vid_anc_valid_int;\nwire [DATA_WIDTH-1:0] vid_data_int;\n\ngenerate begin : use_embedded_syncs_generate\n    if(USE_EMBEDDED_SYNCS) begin\n        assign vid_enable_int = vid_datavalid_input;  \n                                                      \n        \n        alt_vipcti130_Vid2IS_embedded_sync_extractor#(\n                .DATA_WIDTH(DATA_WIDTH),\n                .BPS(BPS),\n                .BASE(BASE),\n                .GENERATE_ANC(GENERATE_ANC))\n            sync_extractor(\n                .rst(rst_vid_clk),\n                .clk(vid_clk_int),\n    \n                \n                .vid_locked(vid_locked),\n                .vid_enable(vid_enable_int),\n                .vid_hd_sdn(vid_hd_sdn_input),\n                .vid_data_in(vid_data_input),\n    \n                \n                .vid_f(vid_f_int),\n                .vid_h_sync(vid_h_sync_int),\n                .vid_v_sync(vid_v_sync_int),\n                .vid_datavalid(vid_datavalid_int),\n                .vid_anc_valid(vid_anc_valid_int),\n                .vid_data_out(vid_data_int));\n    end else begin\n        assign vid_enable_int = (ADD_DATA_ENABLE_SIGNAL==1) ? vid_datavalid : 1'b1;\n    \n        alt_vipcti130_Vid2IS_sync_polarity_convertor hsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_h_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_h_sync_int));\n            \n        alt_vipcti130_Vid2IS_sync_polarity_convertor vsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_v_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_v_sync_int));\n            \n        assign vid_f_int = vid_f_input;\n        assign vid_datavalid_int = vid_datavalid_input;\n        assign vid_anc_valid_int = 1'b0;\n        assign vid_data_int = vid_data_input;\n    end\nend endgenerate\n\n\nwire valid_nxt;\nreg valid_reg;\nreg [DATA_WIDTH-1:0] data_reg;\nreg vid_f_reg;\nreg vid_h_sync_reg;\nreg vid_v_sync_reg;\nreg vid_datavalid_reg;\nreg vid_anc_valid_reg;\nreg convert;\n\nassign valid_nxt = vid_enable_int & (vid_datavalid_int | vid_anc_valid_int); \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        valid_reg <= 1'b0;\n        convert <= 1'b0;\n        data_reg <= {DATA_WIDTH{1'b0}};\n        vid_f_reg <= 1'b0;\n        vid_h_sync_reg <= 1'b0;\n        vid_v_sync_reg <= 1'b0;\n        vid_datavalid_reg <= 1'b0;\n        vid_anc_valid_reg <= 1'b0;\n    end else begin\n        if(overflow_nxt) begin \n                               \n            valid_reg <= valid_reg;\n            convert <= convert;\n        end else begin\n            valid_reg <= (valid_nxt | valid_reg) & ~eop;\n            convert <= ((vid_enable_int & vid_datavalid_int) | convert) & ~eop;   \n        end\n        data_reg <= (valid_nxt) ? vid_data_int : data_reg;\n        \n        if(vid_enable_int) begin\n            vid_f_reg <= vid_f_int;\n            vid_h_sync_reg <= vid_h_sync_int;\n            vid_v_sync_reg <= vid_v_sync_int;\n            vid_datavalid_reg <= vid_datavalid_int;\n            vid_anc_valid_reg <= vid_anc_valid_int;\n        end\n    end\nend\n\nassign wrreq_pre_enable = valid_nxt | eop; \nassign data = (valid_nxt & ~valid_reg) ? (vid_datavalid_int) ? 0 : 13 : \n                                         data_reg;\nassign f = vid_f_reg;\nassign h_sync = vid_h_sync_reg;\nassign v_sync = vid_v_sync_reg;\nassign ap = vid_datavalid_reg;\nassign last_sample = valid_reg & (start_of_vsync | end_of_vsync);\n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        sync_count <= 2'b01;\n        locked <= 1'b0;\n\t    enable_synced <= 1'b0;\n        \n        overflow_reg <= 1'b0;\n        overflow_sticky <= 1'b0;\n        vid_locked_reg <= 1'b0;\n        \n        h_sync_reg <= 1'b0;\n        v_sync_reg <= 1'b0;\n        ap_reg <= 1'b0;\n        \n        f_reg <= 1'b0;\n        field_prediction <= 1'b0;\n    end else begin\n        if(~vid_locked | lost_vid_locked | overflowed) begin\n            sync_count <= 2'b01;\n            locked <= 1'b0;\n            enable_synced <= 1'b0;\n        end else begin\n            sync_count <= sync_count_next;\n            locked <= locked_next;\n            enable_synced <= (frame_synch) ? enable_sync1 & locked_next : enable_synced;\n        end\n        \n        h_sync_reg <= h_sync;\n        v_sync_reg <= v_sync;\n        ap_reg <= ap;\n        \n        overflow_reg <= overflow_nxt;\n        overflow_sticky <= (overflow_nxt | overflow_sticky) & ~clear_overflow_sticky_sync1;\n        vid_locked_reg <= vid_locked;\n        \n        f_reg <= f;\n        field_prediction <= field_prediction_nxt;\n    end\nend\n\nassign field_prediction_nxt = (~interlaced | end_of_vsync) ? f_reg : (start_of_vsync) ? ~f_reg : field_prediction;\n    \nassign overflow = overflow_sticky; \n                                   \nassign overflow_nxt = (wrreq | overflow_reg) & full;\nassign lost_vid_locked = (~vid_locked & vid_locked_reg);\nassign overflowed = (~full & overflow_reg);\n\nassign wrreq = wrreq_pre_enable & enable_synced;\nassign wrreq_pre_swap = wrreq & ~full;\nassign start_of_ap = ap & ~ap_reg;\nassign end_of_vsync = ~v_sync & v_sync_reg;\nassign start_of_vsync = v_sync & ~v_sync_reg;\nassign start_of_hsync = h_sync & ~h_sync_reg;\nassign early_eop = valid_reg & (lost_vid_locked | overflowed);\nassign eop =  last_sample | early_eop;\nassign packet = last_sample | early_eop;\nassign sync_count_next = (start_of_hsync) ? sync_count - 2'b01 : sync_count;\nassign locked_next = ~|sync_count_next | locked;\n\ngenerate begin : sync_to_generate\n    if(SYNC_TO == 0) begin\n        assign frame_synch = end_of_vsync & ~f;\n    end else if(SYNC_TO == 1) begin\n        assign frame_synch = end_of_vsync & f;\n    end else begin\n        assign frame_synch = end_of_vsync;\n    end\nend endgenerate\n\n\nalt_vipcti130_Vid2IS_resolution_detection resolution_detection(\n    .rst(rst_vid_clk),\n    .clk(vid_clk_int),\n    \n    \n    .count_cycle(vid_enable_int),\n    .ap(ap),\n    .hd_sdn(vid_hd_sdn_input),\n    .start_new_line(start_of_hsync),\n    .start_new_field(start_of_vsync),\n    .end_of_vsync(end_of_vsync),\n    .f(f),\n    .vid_locked(vid_locked),\n    \n    \n    .update(update),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .total_line_count(total_line_count),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .resolution_change(resolution_change));\n    \ndefparam resolution_detection.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         resolution_detection.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.H_ACTIVE_PIXELS = H_ACTIVE_PIXELS_F0,\n         resolution_detection.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         resolution_detection.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         resolution_detection.INTERLACED = INTERLACED;\n\n\ngenerate begin : sync_generation_generate\n    if(GENERATE_SYNC > 0) begin\n        alt_vipcti130_common_sync_generation sync_generation(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .clear_enable(1'b0),\n            .enable_count(vid_enable_int),\n            .hd_sdn(vid_hd_sdn_input),\n            .start_of_vsync(start_of_vsync),\n            .field_prediction(field_prediction_nxt),\n            .interlaced(interlaced),\n            .total_sample_count(total_sample_count[14:1]),\n            .total_sample_count_valid(total_sample_count[0]),\n            .total_line_count(total_line_count[13:1]),\n            .total_line_count_valid(total_line_count[0]),\n            .stable(stable),\n            \n            .divider_value(refclk_divider_value_sync1),\n            .sof_sample(sof_sample_sync1),\n            .sof_line(sof_line_sync1),\n            .sof_subsample(sof_subsample_sync1),\n            \n            .output_enable(genlock_enable_sync1),\n            .sof(sof),\n            .sof_locked(sof_locked),\n            .div(refclk_div));\n\n            defparam sync_generation.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n                     sync_generation.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.TOTALS_MINUS_ONE = 0;\n    end else begin\n        assign sof = 1'b0;\n        assign sof_locked = 1'b0;\n    end\nend endgenerate\n\n\n\ngenerate begin : avalon_st_output\n    if(GENERATE_SYNC < 2) begin\n        wire wrreq_post_swap;\n        wire [DATA_WIDTH-1:0] data_post_swap;\n        wire packet_post_swap;\n        \n        \n        if(CONVERT_SEQ_TO_PAR) begin\n            alt_vipcti130_Vid2IS_write_buffer #(\n                    .DATA_WIDTH(DATA_WIDTH),\n                    .NUMBER_OF_COLOUR_PLANES(NUMBER_OF_COLOUR_PLANES),\n                    .BPS(BPS))\n                write_buffer(\n                    .rst(rst_vid_clk),\n                    .clk(vid_clk_int),\n                    \n                    .convert(convert),\n                    .hd_sdn(vid_hd_sdn_input),\n                    .early_eop(early_eop),\n                    \n                    .wrreq_in(wrreq_pre_swap),\n                    .data_in(data),\n                    .packet_in(packet),\n                    \n                    .wrreq_out(wrreq_post_swap),\n                    .data_out(data_post_swap),\n                    .packet_out(packet_post_swap));\n        end else begin\n            assign data_post_swap = data;\n            assign wrreq_post_swap = wrreq_pre_swap;\n            assign packet_post_swap = packet;\n        end\n        \n        wire [FIFO_WIDTH-1:0] q;\n        wire empty;\n        \n        alt_vipcti130_common_fifo #(\n                .DATA_WIDTH(FIFO_WIDTH),\n                .CLOCKS_ARE_SAME(CLOCKS_ARE_SAME),\n                .FIFO_DEPTH(FIFO_DEPTH_INT))\n            input_fifo(\n                .wrclk(vid_clk_int),\n                .rdreq(rdreq),\n                .aclr(rst_vid_clk),\n                .rdclk(is_clk),\n                .wrreq(wrreq_post_swap),\n                .data({data_post_swap, packet_post_swap}),\n                .rdusedw(usedw),\n                .rdempty(empty),\n                .wrfull(full),\n                .q(q));\n         \n        wire enable_resync1;\n        wire is_field_prediction;\n        \n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME) field_prediction_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(field_prediction),\n            .data_out(is_field_prediction));\n\n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME) enable_resync_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(enable_synced),\n            .data_out(enable_resync1));\n         \n        \n        \n        \n        alt_vipcti130_Vid2IS_av_st_output #(\n                .FIFO_WIDTH(FIFO_WIDTH),\n                .DATA_WIDTH(DATA_WIDTH),\n                .NUMBER_OF_COLOUR_PLANES_IN_PARALLEL(NUMBER_OF_COLOUR_PLANES_IN_PARALLEL),\n                .BPS(BPS))\n            av_st_output(\n                .rst(rst),\n                \n                .enable(enable_resync1),\n                .q(q),\n                .rdreq(rdreq),\n                .empty(empty),\n                .is_interlaced(is_interlaced),\n                .is_sync_to(2'b10),\n                .is_field_prediction(is_field_prediction),\n                .is_active_sample_count(is_active_sample_count),\n                .is_active_line_count_f0(is_active_line_count_f0),\n                .is_active_line_count_f1(is_active_line_count_f1),\n                \n                .is_clk(is_clk),\n                .is_ready(is_ready),\n                .is_valid(is_valid),\n                .is_data(is_data),\n                .is_sop(is_sop),\n                .is_eop(is_eop),\n                \n                .is_output_enable(is_output_enable));\n    end else begin\n        assign is_valid = 1'b0;\n        assign is_sop = 1'b0;\n        assign is_eop = 1'b0;\n        assign is_data = {DATA_WIDTH{1'b0}};\n    end\nend endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: alt_vipcti130_Vid2IS. Module specification: The alt_vipcti130_Vid2IS module is a video interface converter that transforms video input streams into internal streams (IS) based on specific configuration parameters. It handles functionalities such as sync extraction, resolution detection, signal conversions, and managing various input and output controls. The module accepts input signals including reset (rst), video clock (vid_clk), video data (vid_data), data enable (vid_de), sync signals (vid_v_sync, vid_h_sync), and others. It produces output signals like internal stream clock (is_clk), data (is_data), start/end of packet (is_sop, is_eop), and various status signals. Internally, it utilizes signals for FIFO management, overflow detection, synchronization, and data conversion. The module is composed of several key blocks: a control"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti130_Vid2IS.\n\nExplanation: The module \"alt_vipcti130_Vid2IS\" functions as a video interface that converts video input streams into internal streams (IS) according to specific configuration parameters. It supports functionalities such as sync extraction, resolution detection, signal conversions, and the handling of various input and output controls. Additionally, this module can work with both embedded syncing signals within the video stream or use separate sync signals depending on the configuration. It also incorporates mechanisms to handle overflow conditions and to synchronize video output to specific standards, ensuring the video data is correctly aligned and formatted for further processing or display."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n### Input Ports:\n\n1. **rst**: Reset signal. This active-high signal resets the module's internal registers and logic to an initial state.\n2. **vid_clk**: Video clock input. This clock synchronizes the video input stream data and control signals.\n3. **vid_data**: Video data input. This multi-bit port carries the pixel data of the video input stream.\n4. **vid_de**: Data enable signal for the video input. This signal indicates when the `vid_data` is valid.\n5. **vid_datavalid**: Signal indicating that the current video data input is valid and should be processed.\n6. **vid_locked**: Signal indicating whether the video input stream is stable and locked.\n7. **vid_f**: Frame signal for the video input. It distinguishes between different frames in the video stream.\n8. **vid_v_sync**: Vertical sync signal for video input. It indicates the start of a new video frame.\n9. **vid_h_sync**: Horizontal sync signal for video input. It indicates the start of a new line within the video frame.\n10. **vid_hd_sdn**: Signal used in synchronization, particularly for distinguishing HD video standards or down-scaling.\n11. **vid_std**: Video standard identifier. This multi-bit signal indicates the video standard of the incoming stream (e.g., resolution, refresh rate).\n12. **is_clk**: Internal stream clock. This clock synchronizes the output internal stream data.\n13. **is_ready**: Signal from downstream logic indicating that it is ready to accept more data from the internal stream.\n14. **av_address**, **av_read**, **av_write**, **av_writedata**: These ports are part of an Avalon interface for reading from and writing to control registers within the module.\n    \n### Output Ports:\n\n1. **is_valid**: Signal indicating that the output internal stream data is valid.\n2. **is_data**: Data of the output internal stream. This multi-bit port carries the pixel data.\n3. **is_sop**: Start of packet signal. Indicates the beginning of a video packet in the internal stream.\n4. **is_eop**: End of packet signal. Indicates the end of a video packet in the internal stream.\n5. **av_readdata**: Data read from the module's control registers, part of the Avalon interface.\n6. **sof**: Start of frame signal. Indicates the beginning of a new frame in the internal stream.\n7. **sof_locked**: Signal indicating whether the start of frame signal is locked and stable.\n8. **refclk_div**: Reference clock divider value. Used for synchronizing video output to a specific standard.\n9. **status_update_int**: Status update signal. Indicates when there has been a change in the module's status.\n10. **overflow**: Signal indicating that an overflow condition occurred, signaling that the internal buffers are full and data may have been lost.\n\nEach input and output port plays a specific role in acquiring video input, processing or transforming this input according to the module's configuration, and then outputting a synchronized internal stream suitable for further processing or display."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n\n1. **alt_clogb2**: A function that calculates the ceiling of the base-2 logarithm of its argument.\n2. **CONVERT_SEQ_TO_PAR**: Determines whether sequential color plane inputs must be converted to parallel.\n3. **DATA_WIDTH**: The width of the data buses inside the module, derived from parameters.\n4. **NUMBER_OF_COLOUR_PLANES_IN_PARALLEL**: The number of color planes fed in parallel.\n5. **BASE**: Adjusts sync polarity based on BPS parameter.\n6. **LOG2_NUMBER_OF_COLOUR_PLANES**: Base-2 logarithm of the number of color planes.\n7. **COLOUR_PLANES_IN_SEQUENCE**: Indicates if color planes are provided in sequence.\n8. **FIFO_DEPTH_INT**: The depth of the internal FIFO, adjusted for color planes and additional storage.\n9. **USED_WORDS_WIDTH**: The width of the word count for the used space in FIFO.\n10. **vid_data_input**: Buffered version of the `vid_data` input signal.\n11. **vid_datavalid_input**: Buffered version of the `vid_datavalid` input signal.\n12. **vid_f_input**: Buffered version of the `vid_f` input signal.\n13. **vid_v_sync_input**: Buffered version of the `vid_v_sync` input signal.\n14. **vid_h_sync_input**: Buffered version of the `vid_h_sync` input signal.\n15. **vid_hd_sdn_input**: Buffered version of the `vid_hd_sdn` input signal.\n16. **rdreq**: Read request signal for the FIFO.\n17. **wrreq**: Write request signal for the FIFO.\n18. **wrreq_pre_swap**: Intermediate write request prior to data format conversion.\n19. **data**: Intermediate video data signal.\n20. **full**: Indicates that the FIFO is full.\n21. **enable**: Control signal to enable the module.\n22. **usedw**: Counter for the used words in FIFO.\n23. **overflow_nxt**: Next-state logic for the overflow condition.\n24. **overflow_reg**: Registers the overflow condition.\n25. **overflow_sticky**: Maintains the overflow status until cleared.\n26. **enable_synced**: Indicates when the output can be enabled, synchronized with vid_clk.\n27. **rst_vid_clk**: Reset signal synchronized to vid_clk.\n28. **ap**: Active pixel signal indicating active video data.\n29. **f**: Frame signal for synchronization purposes.\n30. **start_of_vsync**: Indicates the start of the vertical sync period.\n31. **sync_count**: Counter used to synchronize internal logic with input video sync signals.\n32. **locked**: Indicates the synchronized and stable state of the input stream.\n33. **h_sync, v_sync**: Buffered versions of the `vid_h_sync` and `vid_v_sync` input signals.\n34. **packet**: Indicates whether the current operation constitutes a full packet of data.\n35. **start_of_hsync**: Indicates the start of the horizontal sync period.\n36. **lost_vid_locked**: Indicates the transition from a locked to an unlocked state of the input video.\n37. **overflowed**: Signals if the FIFO overflowed.\n38. **early_eop**: Early indication of the end of packet condition.\n39. **eop**: Signals the end of a packet.\n40. **active_sample_count, active_line_count_f0, ...**: Counters used to detect active video region sizes.\n41. **is_interlaced**: Signal to indicate if the output stream is interlaced.\n42. **sof_sample, sof_subsample, sof_line**: Start-of-frame counters for samples and lines.\n43. **refclk_divider_value**: Configuration value used in sync generation.\n44. **genlock_enable**: Signal that enables synchronization to a genlock source.\n45. **update_sync1, resolution_change_sync1, etc.**: Synchronization signals, ensuring proper timing relations between signals affected by clock domain crossings.\n46. **vid_std_sync1**: Synchronized version of the `vid_std` input signal.\n47. **valid_nxt, valid_reg**: Logic to keep track of the validity of the current data.\n48. **data_reg**: Register holding the video data to be processed.\n49. **vid_f_reg, vid_h_sync_reg, vid_v_sync_reg, vid_datavalid_reg, vid_anc_valid_reg**: Registers for synchronization signals.\n50. **convert**: Flag to start conversion of data from sequential to parallel.\n51. **frame_synch**: Frame synchronization signal that triggers with the end of vsync.\n52. **field_prediction, field_prediction_nxt**: Logic for interlaced signal prediction.\n53. **last_sample**: Indicates the last data sample within the current packet.\n\nExplanation: \n\nThese internal signals serve different roles, like controlling the flow of data through the module, buffering incoming signals to align with internal clocks, providing synchronization between different clock domains, and maintaining state across various cycles of operation. They are instrumental in managing operations such as reading from and writing to FIFOs, signal conversion between sequential and parallel formats, syncing video data to external references, handling overflow conditions, and determining the active video windows for proper video stream processing."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>module alt_vipcti130_Vid2IS(\n    rst,\n    \n    \n    vid_clk,\n    vid_data,\n    vid_de,\n    vid_datavalid,\n    vid_locked,\n    \n    \n    vid_f,\n    vid_v_sync,\n    vid_h_sync,\n    vid_hd_sdn,\n    vid_std,\n    \n    \n    is_clk,\n    is_ready,\n    is_valid,\n    is_data,\n    is_sop,\n    is_eop,\n    \n    \n    av_address,\n    av_read,\n    av_readdata,\n    av_write,\n    av_writedata,\n    \n    \n    sof,\n    sof_locked,\n    refclk_div,\n    \n    \n    status_update_int,\n    \n    \n    overflow) ;\n    \n\n\n\nfunction integer alt_clogb2;\n  input [31:0] value;\n  integer i;\n  begin\n    alt_clogb2 = 32;\n    for (i=31; i>0; i=i-1) begin\n      if (2**i>=value)\n        alt_clogb2 = i;\n    end\n  end\nendfunction\n\nparameter BPS = 10;\nparameter NUMBER_OF_COLOUR_PLANES = 2;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 1;\nparameter FIFO_DEPTH = 1920;\nparameter USE_EMBEDDED_SYNCS = 1;\nparameter ADD_DATA_ENABLE_SIGNAL = 0;\nparameter CLOCKS_ARE_SAME = 0;\nparameter USE_CONTROL = 1;\nparameter INTERLACED = 1;\nparameter H_ACTIVE_PIXELS_F0 = 1920;\nparameter V_ACTIVE_LINES_F0 = 540;\nparameter H_ACTIVE_PIXELS_F1 = 1920;\nparameter V_ACTIVE_LINES_F1 = 540;\nparameter SYNC_TO = 2;\nparameter ACCEPT_COLOURS_IN_SEQ = 1;\nparameter USE_STD = 1;\nparameter STD_WIDTH = 3;\nparameter GENERATE_SYNC = 1;\nparameter GENERATE_ANC = 0;\n\nlocalparam CONVERT_SEQ_TO_PAR = COLOUR_PLANES_ARE_IN_PARALLEL == 1 && ACCEPT_COLOURS_IN_SEQ != 0 && NUMBER_OF_COLOUR_PLANES > 1;\nlocalparam DATA_WIDTH = (COLOUR_PLANES_ARE_IN_PARALLEL) ? BPS * NUMBER_OF_COLOUR_PLANES : BPS;\nlocalparam NUMBER_OF_COLOUR_PLANES_IN_PARALLEL = (COLOUR_PLANES_ARE_IN_PARALLEL) ? NUMBER_OF_COLOUR_PLANES : 1;\nlocalparam BASE = (BPS >= 10) ? 2 : 0;\nlocalparam LOG2_NUMBER_OF_COLOUR_PLANES = alt_clogb2(NUMBER_OF_COLOUR_PLANES);\nlocalparam COLOUR_PLANES_IN_SEQUENCE = (COLOUR_PLANES_ARE_IN_PARALLEL && !CONVERT_SEQ_TO_PAR) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam COLOUR_PLANES_IN_SEQUENCE_FIFO = (COLOUR_PLANES_ARE_IN_PARALLEL) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam FIFO_WIDTH = DATA_WIDTH + 1;\nlocalparam FIFO_DEPTH_INT = (FIFO_DEPTH * COLOUR_PLANES_IN_SEQUENCE_FIFO) + 4;\nlocalparam USED_WORDS_WIDTH = alt_clogb2(FIFO_DEPTH_INT);\n\ninput rst;\n\n\ninput vid_clk;\ninput [DATA_WIDTH-1:0] vid_data;\ninput vid_de;\ninput vid_datavalid;\ninput vid_locked;\n\n\ninput vid_f;\ninput vid_v_sync;\ninput vid_h_sync;\ninput vid_hd_sdn;\ninput [STD_WIDTH-1:0] vid_std;\n\n\ninput is_clk;\ninput is_ready;\noutput is_valid;\noutput [DATA_WIDTH-1:0] is_data;\noutput is_sop;\noutput is_eop;\n\n\ninput [3:0] av_address;\ninput av_read;\noutput [15:0] av_readdata;\ninput av_write;\ninput [15:0] av_writedata;\n\n\noutput sof;\noutput sof_locked;\noutput refclk_div;\n\n\noutput status_update_int;\n\n\noutput overflow;\n\nreg [DATA_WIDTH-1:0] vid_data_input;\nreg vid_datavalid_input;\nreg vid_f_input;\nreg vid_v_sync_input;\nreg vid_h_sync_input;\nreg vid_hd_sdn_input;\n\nwire [DATA_WIDTH-1:0] is_data;\nwire is_valid;\nwire is_sop;\nwire is_eop;\n\nwire rdreq;\nwire wrreq;\nwire wrreq_pre_swap;\nwire [DATA_WIDTH-1:0] data;\nwire full;\nwire enable;\nwire [USED_WORDS_WIDTH-1:0] usedw;\n\nwire overflow_nxt;\nreg overflow_reg;\nreg overflow_sticky;\nwire overflow_sticky_sync1;\n\nreg enable_synced;\n\nwire rst_vid_clk;\nwire ap;\nwire f;\nwire start_of_vsync;\nreg [1:0] sync_count;\nreg locked;\nwire h_sync, v_sync;\nreg h_sync_reg, v_sync_reg;\nwire packet;\nwire start_of_hsync;\nwire lost_vid_locked;\nwire overflowed;\nwire early_eop;\nwire eop;\nwire [14:0] active_sample_count;\nwire [13:0] active_line_count_f0;\nwire [13:0] active_line_count_f1;\nwire [14:0] total_sample_count;\nwire [13:0] total_line_count_f0;\nwire [13:0] total_line_count_f1;\nwire [13:0] total_line_count;\nwire is_interlaced;\nwire [16:0] is_active_sample_count;\nwire [16:0] is_active_line_count_f0;\nwire [16:0] is_active_line_count_f1;\nwire [13:0] sof_sample;\nwire [1:0] sof_subsample;\nwire [12:0] sof_line;\nwire [13:0] refclk_divider_value;\nwire genlock_enable;\nwire update_sync1;\nwire resolution_change;\nwire resolution_change_sync1;\nwire update;\nwire [STD_WIDTH-1:0] vid_std_sync1;\nreg ap_reg;\nwire end_of_vsync;\nwire interlaced;\nwire start_of_ap;\nwire [1:0] sync_count_next;\nwire locked_next;\nwire stable;\nwire resolution_valid;\nwire wrreq_pre_enable;\nreg vid_locked_reg;\nwire clear_overflow_sticky;\nwire is_output_enable;\nwire frame_synch;\nwire field_prediction_nxt;\nreg field_prediction;\nwire vid_clk_int;\nwire last_sample;\nreg f_reg;\n\ngenerate begin : clocks_are_same_generate\n     if(CLOCKS_ARE_SAME) begin\n         assign rst_vid_clk = rst;\n         assign vid_clk_int = is_clk;\n     end else begin\n         reg rst_vid_clk_reg;\n         reg rst_vid_clk_reg2;\n         \n         always @ (posedge rst or posedge vid_clk_int) begin\n             if(rst) begin\n                rst_vid_clk_reg <= 1'b1;\n                rst_vid_clk_reg2 <= 1'b1;\n             end else begin\n                rst_vid_clk_reg <= 1'b0;\n                rst_vid_clk_reg2 <= rst_vid_clk_reg;\n             end\n         end\n         assign rst_vid_clk = rst_vid_clk_reg2;\n         assign vid_clk_int = vid_clk;\n     end\nend endgenerate\n\n\nalt_vipcti130_Vid2IS_control control(\n    .rst(rst),\n    .clk(is_clk),\n\n    \n    .usedw(usedw),\n    .overflow_sticky(overflow_sticky_sync1),\n    .is_output_enable(is_output_enable), \n    \n    \n    .update(update_sync1),\n    .resolution_change(resolution_change_sync1),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .vid_std(vid_std_sync1), \n    \n    \n    .enable(enable),\n    .clear_overflow_sticky(clear_overflow_sticky),\n    .is_interlaced(is_interlaced),\n    .is_active_sample_count(is_active_sample_count),\n    .is_active_line_count_f0(is_active_line_count_f0),\n    .is_active_line_count_f1(is_active_line_count_f1),\n    .sof_sample(sof_sample),\n    .sof_line(sof_line),\n    .sof_subsample(sof_subsample),\n    .refclk_divider_value(refclk_divider_value),\n    .genlock_enable(genlock_enable),\n    \n    \n    .av_address(av_address),\n    .av_read(av_read),\n    .av_readdata(av_readdata),\n    .av_write(av_write),\n    .av_writedata(av_writedata),\n    \n    .status_update_int(status_update_int));\n    \ndefparam control.USE_CONTROL = USE_CONTROL,\n         control.INTERLACED = INTERLACED,\n         control.H_ACTIVE_PIXELS_F0 = H_ACTIVE_PIXELS_F0,\n         control.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         control.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         control.USED_WORDS_WIDTH = USED_WORDS_WIDTH,\n         control.STD_WIDTH = STD_WIDTH;\n         \n\ngenerate begin : use_std_generate\n    if(USE_STD) begin\n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME, STD_WIDTH) vid_std_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(vid_std),\n            .data_out(vid_std_sync1));\n    end else begin\n        assign vid_std_sync1 = {STD_WIDTH{1'b0}};\n    end\nend endgenerate\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) overflow_sticky_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(overflow_sticky),\n    .data_out(overflow_sticky_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) update_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(update),\n    .data_out(update_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) resolution_change_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(resolution_change),\n    .data_out(resolution_change_sync1));\n\n\nwire enable_sync1;\nwire clear_overflow_sticky_sync1;\nwire genlock_enable_sync1;\nwire [13:0] refclk_divider_value_sync1;\nwire [13:0] sof_sample_sync1;\nwire [12:0] sof_line_sync1;\nwire [1:0] sof_subsample_sync1;\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(enable),\n    .data_out(enable_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) clear_overflow_sticky_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(clear_overflow_sticky),\n    .data_out(clear_overflow_sticky_sync1));\n\nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME) genlock_enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(genlock_enable),\n    .data_out(genlock_enable_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 14) refclk_divider_value_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(refclk_divider_value),\n    .data_out(refclk_divider_value_sync1));\n  \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 14) sof_sample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_sample),\n    .data_out(sof_sample_sync1));\n    \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 13) sof_line_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_line),\n    .data_out(sof_line_sync1));\n \nalt_vipcti130_common_sync #(CLOCKS_ARE_SAME, 2) sof_subsample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_subsample),\n    .data_out(sof_subsample_sync1));\n    \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if (rst_vid_clk) begin\n        vid_data_input <= {DATA_WIDTH{1'b0}};\n        vid_datavalid_input <= 1'b0;\n        vid_f_input <= 1'b0;\n        vid_v_sync_input <= 1'b0;\n        vid_h_sync_input <= 1'b0;\n        vid_hd_sdn_input <= 1'b0;\n    end else begin\n        vid_data_input <= vid_data;\n        if (~USE_EMBEDDED_SYNCS && ADD_DATA_ENABLE_SIGNAL)\n            vid_datavalid_input <= vid_de;\n        else\n            vid_datavalid_input <= vid_datavalid;\n        vid_f_input <= vid_f;\n        vid_v_sync_input <= vid_v_sync;\n        vid_h_sync_input <= vid_h_sync;\n        if(CONVERT_SEQ_TO_PAR)\n            vid_hd_sdn_input <= vid_hd_sdn;\n        else\n            vid_hd_sdn_input <= COLOUR_PLANES_ARE_IN_PARALLEL;\n    end\nend\n\n\nwire vid_enable_int;\nwire vid_f_int;\nwire vid_h_sync_int;\nwire vid_v_sync_int;\nwire vid_datavalid_int;\nwire vid_anc_valid_int;\nwire [DATA_WIDTH-1:0] vid_data_int;\n\ngenerate begin : use_embedded_syncs_generate\n    if(USE_EMBEDDED_SYNCS) begin\n        assign vid_enable_int = vid_datavalid_input;  \n                                                      \n        \n        alt_vipcti130_Vid2IS_embedded_sync_extractor#(\n                .DATA_WIDTH(DATA_WIDTH),\n                .BPS(BPS),\n                .BASE(BASE),\n                .GENERATE_ANC(GENERATE_ANC))\n            sync_extractor(\n                .rst(rst_vid_clk),\n                .clk(vid_clk_int),\n    \n                \n                .vid_locked(vid_locked),\n                .vid_enable(vid_enable_int),\n                .vid_hd_sdn(vid_hd_sdn_input),\n                .vid_data_in(vid_data_input),\n    \n                \n                .vid_f(vid_f_int),\n                .vid_h_sync(vid_h_sync_int),\n                .vid_v_sync(vid_v_sync_int),\n                .vid_datavalid(vid_datavalid_int),\n                .vid_anc_valid(vid_anc_valid_int),\n                .vid_data_out(vid_data_int));\n    end else begin\n        assign vid_enable_int = (ADD_DATA_ENABLE_SIGNAL==1) ? vid_datavalid : 1'b1;\n    \n        alt_vipcti130_Vid2IS_sync_polarity_convertor hsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_h_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_h_sync_int));\n            \n        alt_vipcti130_Vid2IS_sync_polarity_convertor vsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_v_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_v_sync_int));\n            \n        assign vid_f_int = vid_f_input;\n        assign vid_datavalid_int = vid_datavalid_input;\n        assign vid_anc_valid_int = 1'b0;\n        assign vid_data_int = vid_data_input;\n    end\nend endgenerate\n\n\nwire valid_nxt;\nreg valid_reg;\nreg [DATA_WIDTH-1:0] data_reg;\nreg vid_f_reg;\nreg vid_h_sync_reg;\nreg vid_v_sync_reg;\nreg vid_datavalid_reg;\nreg vid_anc_valid_reg;\nreg convert;\n\nassign valid_nxt = vid_enable_int & (vid_datavalid_int | vid_anc_valid_int); \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        valid_reg <= 1'b0;\n        convert <= 1'b0;\n        data_reg <= {DATA_WIDTH{1'b0}};\n        vid_f_reg <= 1'b0;\n        vid_h_sync_reg <= 1'b0;\n        vid_v_sync_reg <= 1'b0;\n        vid_datavalid_reg <= 1'b0;\n        vid_anc_valid_reg <= 1'b0;\n    end else begin\n        if(overflow_nxt) begin \n                               \n            valid_reg <= valid_reg;\n            convert <= convert;\n        end else begin\n            valid_reg <= (valid_nxt | valid_reg) & ~eop;\n            convert <= ((vid_enable_int & vid_datavalid_int) | convert) & ~eop;   \n        end\n        data_reg <= (valid_nxt) ? vid_data_int : data_reg;\n        \n        if(vid_enable_int) begin\n            vid_f_reg <= vid_f_int;\n            vid_h_sync_reg <= vid_h_sync_int;\n            vid_v_sync_reg <= vid_v_sync_int;\n            vid_datavalid_reg <= vid_datavalid_int;\n            vid_anc_valid_reg <= vid_anc_valid_int;\n        end\n    end\nend\n\nassign wrreq_pre_enable = valid_nxt | eop; \nassign data = (valid_nxt & ~valid_reg) ? (vid_datavalid_int) ? 0 : 13 : \n                                         data_reg;\nassign f = vid_f_reg;\nassign h_sync = vid_h_sync_reg;\nassign v_sync = vid_v_sync_reg;\nassign ap = vid_datavalid_reg;\nassign last_sample = valid_reg & (start_of_vsync | end_of_vsync);\n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        sync_count <= 2'b01;\n        locked <= 1'b0;\n\t    enable_synced <= 1'b0;\n        \n        overflow_reg <= 1'b0;\n        overflow_sticky <= 1'b0;\n        vid_locked_reg <= 1'b0;\n        \n        h_sync_reg <= 1'b0;\n        v_sync_reg <= 1'b0;\n        ap_reg <= 1'b0;\n        \n        f_reg <= 1'b0;\n        field_prediction <= 1'b0;\n    end else begin\n        if(~vid_locked | lost_vid_locked | overflowed) begin\n            sync_count <= 2'b01;\n            locked <= 1'b0;\n            enable_synced <= 1'b0;\n        end else begin\n            sync_count <= sync_count_next;\n            locked <= locked_next;\n            enable_synced <= (frame_synch) ? enable_sync1 & locked_next : enable_synced;\n        end\n        \n        h_sync_reg <= h_sync;\n        v_sync_reg <= v_sync;\n        ap_reg <= ap;\n        \n        overflow_reg <= overflow_nxt;\n        overflow_sticky <= (overflow_nxt | overflow_sticky) & ~clear_overflow_sticky_sync1;\n        vid_locked_reg <= vid_locked;\n        \n        f_reg <= f;\n        field_prediction <= field_prediction_nxt;\n    end\nend\n\nassign field_prediction_nxt = (~interlaced | end_of_vsync) ? f_reg : (start_of_vsync) ? ~f_reg : field_prediction;\n    \nassign overflow = overflow_sticky; \n                                   \nassign overflow_nxt = (wrreq | overflow_reg) & full;\nassign lost_vid_locked = (~vid_locked & vid_locked_reg);\nassign overflowed = (~full & overflow_reg);\n\nassign wrreq = wrreq_pre_enable & enable_synced;\nassign wrreq_pre_swap = wrreq & ~full;\nassign start_of_ap = ap & ~ap_reg;\nassign end_of_vsync = ~v_sync & v_sync_reg;\nassign start_of_vsync = v_sync & ~v_sync_reg;\nassign start_of_hsync = h_sync & ~h_sync_reg;\nassign early_eop = valid_reg & (lost_vid_locked | overflowed);\nassign eop =  last_sample | early_eop;\nassign packet = last_sample | early_eop;\nassign sync_count_next = (start_of_hsync) ? sync_count - 2'b01 : sync_count;\nassign locked_next = ~|sync_count_next | locked;\n\ngenerate begin : sync_to_generate\n    if(SYNC_TO == 0) begin\n        assign frame_synch = end_of_vsync & ~f;\n    end else if(SYNC_TO == 1) begin\n        assign frame_synch = end_of_vsync & f;\n    end else begin\n        assign frame_synch = end_of_vsync;\n    end\nend endgenerate\n\n\nalt_vipcti130_Vid2IS_resolution_detection resolution_detection(\n    .rst(rst_vid_clk),\n    .clk(vid_clk_int),\n    \n    \n    .count_cycle(vid_enable_int),\n    .ap(ap),\n    .hd_sdn(vid_hd_sdn_input),\n    .start_new_line(start_of_hsync),\n    .start_new_field(start_of_vsync),\n    .end_of_vsync(end_of_vsync),\n    .f(f),\n    .vid_locked(vid_locked),\n    \n    \n    .update(update),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .total_line_count(total_line_count),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .resolution_change(resolution_change));\n    \ndefparam resolution_detection.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         resolution_detection.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.H_ACTIVE_PIXELS = H_ACTIVE_PIXELS_F0,\n         resolution_detection.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         resolution_detection.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         resolution_detection.INTERLACED = INTERLACED;\n\n\ngenerate begin : sync_generation_generate\n    if(GENERATE_SYNC > 0) begin\n        alt_vipcti130_common_sync_generation sync_generation(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .clear_enable(1'b0),\n            .enable_count(vid_enable_int),\n            .hd_sdn(vid_hd_sdn_input),\n            .start_of_vsync(start_of_vsync),\n            .field_prediction(field_prediction_nxt),\n            .interlaced(interlaced),\n            .total_sample_count(total_sample_count[14:1]),\n            .total_sample_count_valid(total_sample_count[0]),\n            .total_line_count(total_line_count[13:1]),\n            .total_line_count_valid(total_line_count[0]),\n            .stable(stable),\n            \n            .divider_value(refclk_divider_value_sync1),\n            .sof_sample(sof_sample_sync1),\n            .sof_line(sof_line_sync1),\n            .sof_subsample(sof_subsample_sync1),\n            \n            .output_enable(genlock_enable_sync1),\n            .sof(sof),\n            .sof_locked(sof_locked),\n            .div(refclk_div));\n\n            defparam sync_generation.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n                     sync_generation.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.TOTALS_MINUS_ONE = 0;\n    end else begin\n        assign sof = 1'b0;\n        assign sof_locked = 1'b0;\n    end\nend endgenerate\n\n\n\ngenerate begin : avalon_st_output\n    if(GENERATE_SYNC < 2) begin\n        wire wrreq_post_swap;\n        wire [DATA_WIDTH-1:0] data_post_swap;\n        wire packet_post_swap;\n        \n        \n        if(CONVERT_SEQ_TO_PAR) begin\n            alt_vipcti130_Vid2IS_write_buffer #(\n                    .DATA_WIDTH(DATA_WIDTH),\n                    .NUMBER_OF_COLOUR_PLANES(NUMBER_OF_COLOUR_PLANES),\n                    .BPS(BPS))\n                write_buffer(\n                    .rst(rst_vid_clk),\n                    .clk(vid_clk_int),\n                    \n                    .convert(convert),\n                    .hd_sdn(vid_hd_sdn_input),\n                    .early_eop(early_eop),\n                    \n                    .wrreq_in(wrreq_pre_swap),\n                    .data_in(data),\n                    .packet_in(packet),\n                    \n                    .wrreq_out(wrreq_post_swap),\n                    .data_out(data_post_swap),\n                    .packet_out(packet_post_swap));\n        end else begin\n            assign data_post_swap = data;\n            assign wrreq_post_swap = wrreq_pre_swap;\n            assign packet_post_swap = packet;\n        end\n        \n        wire [FIFO_WIDTH-1:0] q;\n        wire empty;\n        \n        alt_vipcti130_common_fifo #(\n                .DATA_WIDTH(FIFO_WIDTH),\n                .CLOCKS_ARE_SAME(CLOCKS_ARE_SAME),\n                .FIFO_DEPTH(FIFO_DEPTH_INT))\n            input_fifo(\n                .wrclk(vid_clk_int),\n                .rdreq(rdreq),\n                .aclr(rst_vid_clk),\n                .rdclk(is_clk),\n                .wrreq(wrreq_post_swap),\n                .data({data_post_swap, packet_post_swap}),\n                .rdusedw(usedw),\n                .rdempty(empty),\n                .wrfull(full),\n                .q(q));\n         \n        wire enable_resync1;\n        wire is_field_prediction;\n        \n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME) field_prediction_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(field_prediction),\n            .data_out(is_field_prediction));\n\n        alt_vipcti130_common_sync #(CLOCKS_ARE_SAME) enable_resync_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(enable_synced),\n            .data_out(enable_resync1));\n         \n        \n        \n        \n        alt_vipcti130_Vid2IS_av_st_output #(\n                .FIFO_WIDTH(FIFO_WIDTH),\n                .DATA_WIDTH(DATA_WIDTH),\n                .NUMBER_OF_COLOUR_PLANES_IN_PARALLEL(NUMBER_OF_COLOUR_PLANES_IN_PARALLEL),\n                .BPS(BPS))\n            av_st_output(\n                .rst(rst),\n                \n                .enable(enable_resync1),\n                .q(q),\n                .rdreq(rdreq),\n                .empty(empty),\n                .is_interlaced(is_interlaced),\n                .is_sync_to(2'b10),\n                .is_field_prediction(is_field_prediction),\n                .is_active_sample_count(is_active_sample_count),\n                .is_active_line_count_f0(is_active_line_count_f0),\n                .is_active_line_count_f1(is_active_line_count_f1),\n                \n                .is_clk(is_clk),\n                .is_ready(is_ready),\n                .is_valid(is_valid),\n                .is_data(is_data),\n                .is_sop(is_sop),\n                .is_eop(is_eop),\n                \n                .is_output_enable(is_output_enable));\n    end else begin\n        assign is_valid = 1'b0;\n        assign is_sop = 1'b0;\n        assign is_eop = 1'b0;\n        assign is_data = {DATA_WIDTH{1'b0}};\n    end\nend endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: alt_vipcti130_Vid2IS. Module specification: The alt_vipcti130_Vid2IS module is a video interface converter that transforms video input streams into internal streams (IS) based on specific configuration parameters. It handles functionalities such as sync extraction, resolution detection, signal conversions, and managing various input and output controls. The module accepts input signals including reset (rst), video clock (vid_clk), video data (vid_data), data enable (vid_de), sync signals (vid_v_sync, vid_h_sync), and others. It produces output signals like internal stream clock (is_clk), data (is_data), start/end of packet (is_sop, is_eop), and various status signals. Internally, it utilizes signals for FIFO management, overflow detection, synchronization, and data conversion. The module is composed of several key blocks: a control"
                }
            ]
        }
    ]
}