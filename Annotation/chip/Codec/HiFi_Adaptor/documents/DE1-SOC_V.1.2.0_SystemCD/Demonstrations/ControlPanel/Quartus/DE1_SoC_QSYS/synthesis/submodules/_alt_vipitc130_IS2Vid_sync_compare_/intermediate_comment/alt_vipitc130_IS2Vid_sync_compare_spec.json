{
    "spec": "Module name: alt_vipitc130_IS2Vid_sync_compare. Module specification: This module performs synchronization comparison for video processing, primarily for genlock functionality. It compares input (CVI) and output (CVO) video signals, managing start-of-frame synchronization, line and sample counts, and generating control signals for synchronization adjustments. The module uses input ports such as rst (reset), clk (clock), genlock_enable, serial_output, h_total_minus_one, restart_count, divider_value, sof_cvi, sof_cvi_locked, sof_cvo, and sof_cvo_locked to control its operation. Output ports include sync_lines, sync_samples, remove_repeatn, sync_compare_h_reset, sync_compare_v_reset, and genlocked, which provide synchronization status and control signals.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: alt_vipitc130_IS2Vid_sync_compare\n\nExplanation: This module appears to be a synchronization comparison unit for video processing. It compares the synchronization between input (CVI) and output (CVO) video signals, likely for the purpose of genlock (generator locking) in video systems. The module tracks start-of-frame signals, counts lines and samples, and generates control signals to adjust synchronization. It manages different states (IDLE, CVI, CVO) based on the incoming start-of-frame signals, and calculates whether to add or remove lines and samples to achieve synchronization. The module also outputs signals indicating whether the system is genlocked and provides reset values for horizontal and vertical synchronization comparisons."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nrst, clk, genlock_enable, serial_output, h_total_minus_one, restart_count, divider_value, sof_cvi, sof_cvi_locked, sof_cvo, sof_cvo_locked.\n\nExplanation:\n- rst: Reset signal\n- clk: Clock signal\n- genlock_enable: 2-bit signal to enable genlock functionality\n- serial_output: Indicates if output is serial\n- h_total_minus_one: Total horizontal pixels minus one\n- restart_count: Signal to restart counting\n- divider_value: Used for comparison in synchronization\n- sof_cvi: Start of frame signal for input video\n- sof_cvi_locked: Indicates if input video is locked\n- sof_cvo: Start of frame signal for output video\n- sof_cvo_locked: Indicates if output video is locked\n\nOutput ports:\nsync_lines, sync_samples, remove_repeatn, sync_compare_h_reset, sync_compare_v_reset, genlocked.\n\nExplanation:\n- sync_lines: Indicates synchronization of lines\n- sync_samples: Indicates synchronization of samples\n- remove_repeatn: Signal to remove repeated samples\n- sync_compare_h_reset: Horizontal reset value for synchronization comparison\n- sync_compare_v_reset: Vertical reset value for synchronization comparison\n- genlocked: Indicates if the system is generator locked"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nsof_cvi_int, sof_cvo_int, sof_cvi_reg, sof_cvo_reg, enable, sclr, sclr_frame_counter, sclr_state, h_count_repeat, h_count_remove, v_count_repeat, v_count_remove, next_state, state, h_count, v_count, remove_lines_next, sync_compare_v_reset_next, sync_compare_h_reset_next, valid, v_count_remove_valid, v_count_repeat_valid, syncing_lines, remove_samples_next.\n\nExplanation:\n1. sof_cvi_int, sof_cvo_int: Detect rising edges of start-of-frame signals for input and output video.\n2. sof_cvi_reg, sof_cvo_reg: Store previous states of start-of-frame signals for edge detection.\n3. enable: Indicates when genlock is enabled and both input and output videos are locked.\n4. sclr, sclr_frame_counter, sclr_state: Various clear signals for resetting counters and state.\n5. h_count_repeat, h_count_remove: Store horizontal count values for repeating or removing samples.\n6. v_count_repeat, v_count_remove: Store vertical count values for repeating or removing lines.\n7. next_state, state: Current and next state of the module's state machine.\n8. h_count, v_count: Current horizontal and vertical count from the frame counter.\n9. remove_lines_next, remove_samples_next: Indicate whether to remove lines or samples in the next cycle.\n10. sync_compare_v_reset_next, sync_compare_h_reset_next: Next values for vertical and horizontal synchronization reset.\n11. valid: Indicates when both vertical count values are valid.\n12. v_count_remove_valid, v_count_repeat_valid: Validity flags for vertical count values.\n13. syncing_lines: Indicates when line synchronization is in progress.\n\nThese signals work together to manage the synchronization process, track video frame positions, and determine necessary adjustments for genlock operation."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n`define SC_IDLE 2'b00\n`define SC_CVI 2'b01\n`define SC_CVO 2'b10\n\nmodule alt_vipitc130_IS2Vid_sync_compare(\n    input wire rst,\n    input wire clk,\n    \n    \n    input wire [1:0] genlock_enable,\n    input wire serial_output,\n    input wire [13:0] h_total_minus_one,\n    input wire restart_count,\n    input wire [13:0] divider_value,\n    \n    \n    output reg  sync_lines,\n    output reg  sync_samples,\n    output reg  remove_repeatn,\n    output reg  [12:0] sync_compare_h_reset,\n    output reg  [12:0] sync_compare_v_reset,\n    output reg  genlocked,\n    \n    \n    input wire sof_cvi,\n    input wire sof_cvi_locked,\n    \n    \n    input wire sof_cvo,\n    input wire sof_cvo_locked);\n\nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\n\nwire sof_cvi_int;\nwire sof_cvo_int;\nreg sof_cvi_reg;\nreg sof_cvo_reg;\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        sof_cvi_reg <= 1'b0;\n        sof_cvo_reg <= 1'b0;\n    end else begin\n        sof_cvi_reg <= sof_cvi;\n        sof_cvo_reg <= sof_cvo;\n    end\nend\n\nassign sof_cvi_int = sof_cvi & ~sof_cvi_reg;\nassign sof_cvo_int = sof_cvo & ~sof_cvo_reg;\n\nwire enable;\nwire sclr;\nwire sclr_frame_counter;\nwire sclr_state;\n\nassign enable = sof_cvi_locked & sof_cvo_locked & genlock_enable[1] & genlock_enable[0];\nassign sclr = ~enable | restart_count;\nassign sclr_frame_counter = sclr | sof_cvi_int | sof_cvo_int;\nassign sclr_state = (sof_cvi_int & sof_cvo_int);\n\nreg [13:0] h_count_repeat;\nreg [13:0] h_count_remove;\nreg [12:0] v_count_repeat;\nreg [12:0] v_count_remove;\nreg [1:0] next_state;\nreg [1:0] state;\nwire [13:0] h_count;\nwire [12:0] v_count;\nwire remove_lines_next;\nwire [12:0] sync_compare_v_reset_next;\nwire [12:0] sync_compare_h_reset_next;\nwire valid;\nreg v_count_remove_valid;\nreg v_count_repeat_valid;\nwire syncing_lines;\nwire remove_samples_next;\n\n\nreg sync_lines0;\nreg sync_samples0;\nreg remove_repeatn0;\nreg [13:0] sync_compare_h_reset0;\nreg [12:0] sync_compare_v_reset0;\nreg genlocked0;\n\nreg sync_lines1;\nreg sync_samples1;\nreg remove_repeatn1;\nreg [13:0] sync_compare_h_reset1;\nreg [12:0] sync_compare_v_reset1;\nreg genlocked1;\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        h_count_repeat <= 14'd0;\n        h_count_remove <= 14'd0;\n        v_count_repeat <= 13'd0;\n        v_count_repeat_valid <= 1'b0;\n        v_count_remove <= 13'd0;\n        v_count_remove_valid <= 1'b0;\n        state <= `SC_IDLE;\n        sync_lines0 <= 1'b0;\n        sync_samples0 <= 1'b0;\n        sync_compare_v_reset0 <= 13'd0;\n        sync_compare_h_reset0 <= 14'd0;\n        remove_repeatn0 <= 1'b0;\n        genlocked0 <= 1'b0;\n\t\t  sync_lines1 <= 1'b0;\n        sync_samples1 <= 1'b0;\n        sync_compare_v_reset1 <= 13'd0;\n        sync_compare_h_reset1 <= 14'd0;\n        remove_repeatn1 <= 1'b0;\n        genlocked1 <= 1'b0;\n\t\t  sync_lines <= 1'b0;\n        sync_samples <= 1'b0;\n        sync_compare_v_reset <= 13'd0;\n        sync_compare_h_reset <= 14'd0;\n        remove_repeatn <= 1'b0;\n        genlocked <= 1'b0;\n    end else begin\n        if(sclr) begin\n            h_count_repeat <= 14'd0;\n            h_count_remove <= 14'd0;\n            v_count_repeat <= 13'd0;\n            v_count_repeat_valid <= 1'b0;\n            v_count_remove <= 13'd0;\n            v_count_remove_valid <= 1'b0;\n            state <= `SC_IDLE;\n        end else begin\n            if(sclr_state) begin\n                h_count_repeat <= 14'd0;\n                h_count_remove <= 14'd0;\n                v_count_repeat <= 13'd0;\n                v_count_repeat_valid <= (14'd0 == h_count_repeat) && (13'd0 == v_count_repeat);\n                v_count_remove <= 13'd0;\n                v_count_remove_valid <= (14'd0 == h_count_remove) && (13'd0 == v_count_remove);\n            end else begin\n                if(state == `SC_CVI && next_state == `SC_CVO) begin\n                    h_count_remove <= h_count;\n                    v_count_remove <= v_count;\n                    v_count_remove_valid <= (h_count == h_count_remove) && (v_count == v_count_remove);\n                end\n                if(state == `SC_CVO && next_state == `SC_CVI) begin\n                    h_count_repeat <= h_count;\n                    v_count_repeat <= v_count;\n                    v_count_repeat_valid <= (h_count == h_count_repeat) && (v_count == v_count_repeat);\n                end\n            end\n        \n            state <= next_state;\n        end\n        \n        if(sclr | ~valid) begin\n            sync_lines0 <= 1'b0;\n            sync_samples0 <= 1'b0;\n            sync_compare_v_reset0 <= 13'd0;\n            sync_compare_h_reset0 <= 14'd0;\n            genlocked0 <= 1'b0;\n        end else begin\n            if(syncing_lines) begin\n                sync_compare_v_reset0 <= sync_compare_v_reset_next;\n                sync_lines0 <= 1'b1;\n                \n                sync_compare_h_reset0 <= sync_compare_h_reset_next;\n                sync_samples0 <= 1'b1;\n                \n                genlocked0 <= 1'b0;\n            end else begin\n                sync_compare_v_reset0 <= 13'd0;\n                sync_lines0 <= 1'b0;\n                \n                if(sync_compare_h_reset_next > divider_value) begin\n                    sync_compare_h_reset0 <= sync_compare_h_reset_next;\n                    sync_samples0 <= 1'b1;\n                    \n                    genlocked0 <= 1'b0;\n                end else begin\n                    sync_compare_h_reset0 <= 14'd0;\n                    sync_samples0 <= 1'b0;\n                    \n                    genlocked0 <= 1'b1;\n                end\n            end\n            \n        end\n        \n        remove_repeatn0 <= remove_samples_next;\n\t\t  \n\t\t  sync_lines1 <= sync_lines0;\n\t\t  sync_samples1 <= sync_samples0;\n        remove_repeatn1 <= remove_repeatn0;\n        sync_compare_h_reset1 <= sync_compare_h_reset0;\n        sync_compare_v_reset1 <= sync_compare_v_reset0;\n        genlocked1 <= genlocked0;\n\t\t  \n\t\t  sync_lines <= sync_lines1;\n\t\t  sync_samples <= sync_samples1;\n        remove_repeatn <= remove_repeatn1;\n        sync_compare_h_reset <= sync_compare_h_reset1;\n        sync_compare_v_reset <= sync_compare_v_reset1;\n        genlocked <= genlocked1;\n    end\nend\n\nassign valid = v_count_remove_valid & v_count_repeat_valid;\nassign remove_lines_next = v_count_remove < v_count_repeat;\nassign sync_compare_v_reset_next = (remove_lines_next) ? v_count_remove : v_count_repeat;\nassign syncing_lines = sync_compare_v_reset_next > 13'd0;\n\nassign remove_samples_next = (syncing_lines) ? remove_lines_next : h_count_remove < h_count_repeat;\nassign sync_compare_h_reset_next = (remove_lines_next) ? h_count_remove : h_count_repeat;\n\nalways @ (state or sof_cvi_int or sof_cvo_int) begin\n    next_state = state;\n    case(state)\n        `SC_CVI: begin\n            if(sof_cvo_int & sof_cvi_int)\n                next_state = `SC_IDLE;\n            else if(sof_cvo_int)\n                next_state = `SC_CVO;\n        end\n        `SC_CVO: begin\n             if(sof_cvi_int & sof_cvo_int)\n                 next_state = `SC_IDLE;\n             else if(sof_cvi_int)\n                 next_state = `SC_CVI;\n        end\n        default: begin\n            if(sof_cvi_int & ~sof_cvo_int)\n                next_state = `SC_CVI;\n            else if(~sof_cvi_int & sof_cvo_int)\n                next_state = `SC_CVO;\n        end\n    endcase\nend\n\nalt_vipitc130_common_frame_counter frame_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(sclr_frame_counter),\n    \n    .enable(enable),\n    .hd_sdn(~serial_output),\n    \n    .h_total(h_total_minus_one),\n    .v_total({13{1'b1}}),\n    \n    .h_reset(14'd0),\n    .v_reset(13'd0),\n    \n    .h_count(h_count),\n    .v_count(v_count));\n\ndefparam frame_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         frame_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         frame_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         frame_counter.TOTALS_MINUS_ONE = 1;\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: alt_vipitc130_IS2Vid_sync_compare. Module specification: This module performs synchronization comparison for video processing, primarily for genlock functionality. It compares input (CVI) and output (CVO) video signals, managing start-of-frame synchronization, line and sample counts, and generating control signals for synchronization adjustments. The module uses input ports such as rst (reset), clk (clock), genlock_enable, serial_output, h_total_minus_one, restart_count, divider_value, sof_cvi, sof_cvi_locked, sof_cvo, and sof_cvo_locked to control its operation. Output ports include sync_lines, sync_samples, remove_repeatn, sync_compare_h_reset, sync_compare_v_reset, and genlocked, which provide synchronization status and control signals."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: alt_vipitc130_IS2Vid_sync_compare\n\nExplanation: This module appears to be a synchronization comparison unit for video processing. It compares the synchronization between input (CVI) and output (CVO) video signals, likely for the purpose of genlock (generator locking) in video systems. The module tracks start-of-frame signals, counts lines and samples, and generates control signals to adjust synchronization. It manages different states (IDLE, CVI, CVO) based on the incoming start-of-frame signals, and calculates whether to add or remove lines and samples to achieve synchronization. The module also outputs signals indicating whether the system is genlocked and provides reset values for horizontal and vertical synchronization comparisons."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nrst, clk, genlock_enable, serial_output, h_total_minus_one, restart_count, divider_value, sof_cvi, sof_cvi_locked, sof_cvo, sof_cvo_locked.\n\nExplanation:\n- rst: Reset signal\n- clk: Clock signal\n- genlock_enable: 2-bit signal to enable genlock functionality\n- serial_output: Indicates if output is serial\n- h_total_minus_one: Total horizontal pixels minus one\n- restart_count: Signal to restart counting\n- divider_value: Used for comparison in synchronization\n- sof_cvi: Start of frame signal for input video\n- sof_cvi_locked: Indicates if input video is locked\n- sof_cvo: Start of frame signal for output video\n- sof_cvo_locked: Indicates if output video is locked\n\nOutput ports:\nsync_lines, sync_samples, remove_repeatn, sync_compare_h_reset, sync_compare_v_reset, genlocked.\n\nExplanation:\n- sync_lines: Indicates synchronization of lines\n- sync_samples: Indicates synchronization of samples\n- remove_repeatn: Signal to remove repeated samples\n- sync_compare_h_reset: Horizontal reset value for synchronization comparison\n- sync_compare_v_reset: Vertical reset value for synchronization comparison\n- genlocked: Indicates if the system is generator locked"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nsof_cvi_int, sof_cvo_int, sof_cvi_reg, sof_cvo_reg, enable, sclr, sclr_frame_counter, sclr_state, h_count_repeat, h_count_remove, v_count_repeat, v_count_remove, next_state, state, h_count, v_count, remove_lines_next, sync_compare_v_reset_next, sync_compare_h_reset_next, valid, v_count_remove_valid, v_count_repeat_valid, syncing_lines, remove_samples_next.\n\nExplanation:\n1. sof_cvi_int, sof_cvo_int: Detect rising edges of start-of-frame signals for input and output video.\n2. sof_cvi_reg, sof_cvo_reg: Store previous states of start-of-frame signals for edge detection.\n3. enable: Indicates when genlock is enabled and both input and output videos are locked.\n4. sclr, sclr_frame_counter, sclr_state: Various clear signals for resetting counters and state.\n5. h_count_repeat, h_count_remove: Store horizontal count values for repeating or removing samples.\n6. v_count_repeat, v_count_remove: Store vertical count values for repeating or removing lines.\n7. next_state, state: Current and next state of the module's state machine.\n8. h_count, v_count: Current horizontal and vertical count from the frame counter.\n9. remove_lines_next, remove_samples_next: Indicate whether to remove lines or samples in the next cycle.\n10. sync_compare_v_reset_next, sync_compare_h_reset_next: Next values for vertical and horizontal synchronization reset.\n11. valid: Indicates when both vertical count values are valid.\n12. v_count_remove_valid, v_count_repeat_valid: Validity flags for vertical count values.\n13. syncing_lines: Indicates when line synchronization is in progress.\n\nThese signals work together to manage the synchronization process, track video frame positions, and determine necessary adjustments for genlock operation."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>`define SC_IDLE 2'b00\n`define SC_CVI 2'b01\n`define SC_CVO 2'b10\n\nmodule alt_vipitc130_IS2Vid_sync_compare(\n    input wire rst,\n    input wire clk,\n    \n    \n    input wire [1:0] genlock_enable,\n    input wire serial_output,\n    input wire [13:0] h_total_minus_one,\n    input wire restart_count,\n    input wire [13:0] divider_value,\n    \n    \n    output reg  sync_lines,\n    output reg  sync_samples,\n    output reg  remove_repeatn,\n    output reg  [12:0] sync_compare_h_reset,\n    output reg  [12:0] sync_compare_v_reset,\n    output reg  genlocked,\n    \n    \n    input wire sof_cvi,\n    input wire sof_cvi_locked,\n    \n    \n    input wire sof_cvo,\n    input wire sof_cvo_locked);\n\nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\n\nwire sof_cvi_int;\nwire sof_cvo_int;\nreg sof_cvi_reg;\nreg sof_cvo_reg;\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        sof_cvi_reg <= 1'b0;\n        sof_cvo_reg <= 1'b0;\n    end else begin\n        sof_cvi_reg <= sof_cvi;\n        sof_cvo_reg <= sof_cvo;\n    end\nend\n\nassign sof_cvi_int = sof_cvi & ~sof_cvi_reg;\nassign sof_cvo_int = sof_cvo & ~sof_cvo_reg;\n\nwire enable;\nwire sclr;\nwire sclr_frame_counter;\nwire sclr_state;\n\nassign enable = sof_cvi_locked & sof_cvo_locked & genlock_enable[1] & genlock_enable[0];\nassign sclr = ~enable | restart_count;\nassign sclr_frame_counter = sclr | sof_cvi_int | sof_cvo_int;\nassign sclr_state = (sof_cvi_int & sof_cvo_int);\n\nreg [13:0] h_count_repeat;\nreg [13:0] h_count_remove;\nreg [12:0] v_count_repeat;\nreg [12:0] v_count_remove;\nreg [1:0] next_state;\nreg [1:0] state;\nwire [13:0] h_count;\nwire [12:0] v_count;\nwire remove_lines_next;\nwire [12:0] sync_compare_v_reset_next;\nwire [12:0] sync_compare_h_reset_next;\nwire valid;\nreg v_count_remove_valid;\nreg v_count_repeat_valid;\nwire syncing_lines;\nwire remove_samples_next;\n\n\nreg sync_lines0;\nreg sync_samples0;\nreg remove_repeatn0;\nreg [13:0] sync_compare_h_reset0;\nreg [12:0] sync_compare_v_reset0;\nreg genlocked0;\n\nreg sync_lines1;\nreg sync_samples1;\nreg remove_repeatn1;\nreg [13:0] sync_compare_h_reset1;\nreg [12:0] sync_compare_v_reset1;\nreg genlocked1;\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        h_count_repeat <= 14'd0;\n        h_count_remove <= 14'd0;\n        v_count_repeat <= 13'd0;\n        v_count_repeat_valid <= 1'b0;\n        v_count_remove <= 13'd0;\n        v_count_remove_valid <= 1'b0;\n        state <= `SC_IDLE;\n        sync_lines0 <= 1'b0;\n        sync_samples0 <= 1'b0;\n        sync_compare_v_reset0 <= 13'd0;\n        sync_compare_h_reset0 <= 14'd0;\n        remove_repeatn0 <= 1'b0;\n        genlocked0 <= 1'b0;\n\t\t  sync_lines1 <= 1'b0;\n        sync_samples1 <= 1'b0;\n        sync_compare_v_reset1 <= 13'd0;\n        sync_compare_h_reset1 <= 14'd0;\n        remove_repeatn1 <= 1'b0;\n        genlocked1 <= 1'b0;\n\t\t  sync_lines <= 1'b0;\n        sync_samples <= 1'b0;\n        sync_compare_v_reset <= 13'd0;\n        sync_compare_h_reset <= 14'd0;\n        remove_repeatn <= 1'b0;\n        genlocked <= 1'b0;\n    end else begin\n        if(sclr) begin\n            h_count_repeat <= 14'd0;\n            h_count_remove <= 14'd0;\n            v_count_repeat <= 13'd0;\n            v_count_repeat_valid <= 1'b0;\n            v_count_remove <= 13'd0;\n            v_count_remove_valid <= 1'b0;\n            state <= `SC_IDLE;\n        end else begin\n            if(sclr_state) begin\n                h_count_repeat <= 14'd0;\n                h_count_remove <= 14'd0;\n                v_count_repeat <= 13'd0;\n                v_count_repeat_valid <= (14'd0 == h_count_repeat) && (13'd0 == v_count_repeat);\n                v_count_remove <= 13'd0;\n                v_count_remove_valid <= (14'd0 == h_count_remove) && (13'd0 == v_count_remove);\n            end else begin\n                if(state == `SC_CVI && next_state == `SC_CVO) begin\n                    h_count_remove <= h_count;\n                    v_count_remove <= v_count;\n                    v_count_remove_valid <= (h_count == h_count_remove) && (v_count == v_count_remove);\n                end\n                if(state == `SC_CVO && next_state == `SC_CVI) begin\n                    h_count_repeat <= h_count;\n                    v_count_repeat <= v_count;\n                    v_count_repeat_valid <= (h_count == h_count_repeat) && (v_count == v_count_repeat);\n                end\n            end\n        \n            state <= next_state;\n        end\n        \n        if(sclr | ~valid) begin\n            sync_lines0 <= 1'b0;\n            sync_samples0 <= 1'b0;\n            sync_compare_v_reset0 <= 13'd0;\n            sync_compare_h_reset0 <= 14'd0;\n            genlocked0 <= 1'b0;\n        end else begin\n            if(syncing_lines) begin\n                sync_compare_v_reset0 <= sync_compare_v_reset_next;\n                sync_lines0 <= 1'b1;\n                \n                sync_compare_h_reset0 <= sync_compare_h_reset_next;\n                sync_samples0 <= 1'b1;\n                \n                genlocked0 <= 1'b0;\n            end else begin\n                sync_compare_v_reset0 <= 13'd0;\n                sync_lines0 <= 1'b0;\n                \n                if(sync_compare_h_reset_next > divider_value) begin\n                    sync_compare_h_reset0 <= sync_compare_h_reset_next;\n                    sync_samples0 <= 1'b1;\n                    \n                    genlocked0 <= 1'b0;\n                end else begin\n                    sync_compare_h_reset0 <= 14'd0;\n                    sync_samples0 <= 1'b0;\n                    \n                    genlocked0 <= 1'b1;\n                end\n            end\n            \n        end\n        \n        remove_repeatn0 <= remove_samples_next;\n\t\t  \n\t\t  sync_lines1 <= sync_lines0;\n\t\t  sync_samples1 <= sync_samples0;\n        remove_repeatn1 <= remove_repeatn0;\n        sync_compare_h_reset1 <= sync_compare_h_reset0;\n        sync_compare_v_reset1 <= sync_compare_v_reset0;\n        genlocked1 <= genlocked0;\n\t\t  \n\t\t  sync_lines <= sync_lines1;\n\t\t  sync_samples <= sync_samples1;\n        remove_repeatn <= remove_repeatn1;\n        sync_compare_h_reset <= sync_compare_h_reset1;\n        sync_compare_v_reset <= sync_compare_v_reset1;\n        genlocked <= genlocked1;\n    end\nend\n\nassign valid = v_count_remove_valid & v_count_repeat_valid;\nassign remove_lines_next = v_count_remove < v_count_repeat;\nassign sync_compare_v_reset_next = (remove_lines_next) ? v_count_remove : v_count_repeat;\nassign syncing_lines = sync_compare_v_reset_next > 13'd0;\n\nassign remove_samples_next = (syncing_lines) ? remove_lines_next : h_count_remove < h_count_repeat;\nassign sync_compare_h_reset_next = (remove_lines_next) ? h_count_remove : h_count_repeat;\n\nalways @ (state or sof_cvi_int or sof_cvo_int) begin\n    next_state = state;\n    case(state)\n        `SC_CVI: begin\n            if(sof_cvo_int & sof_cvi_int)\n                next_state = `SC_IDLE;\n            else if(sof_cvo_int)\n                next_state = `SC_CVO;\n        end\n        `SC_CVO: begin\n             if(sof_cvi_int & sof_cvo_int)\n                 next_state = `SC_IDLE;\n             else if(sof_cvi_int)\n                 next_state = `SC_CVI;\n        end\n        default: begin\n            if(sof_cvi_int & ~sof_cvo_int)\n                next_state = `SC_CVI;\n            else if(~sof_cvi_int & sof_cvo_int)\n                next_state = `SC_CVO;\n        end\n    endcase\nend\n\nalt_vipitc130_common_frame_counter frame_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(sclr_frame_counter),\n    \n    .enable(enable),\n    .hd_sdn(~serial_output),\n    \n    .h_total(h_total_minus_one),\n    .v_total({13{1'b1}}),\n    \n    .h_reset(14'd0),\n    .v_reset(13'd0),\n    \n    .h_count(h_count),\n    .v_count(v_count));\n\ndefparam frame_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         frame_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         frame_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         frame_counter.TOTALS_MINUS_ONE = 1;\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: alt_vipitc130_IS2Vid_sync_compare. Module specification: This module performs synchronization comparison for video processing, primarily for genlock functionality. It compares input (CVI) and output (CVO) video signals, managing start-of-frame synchronization, line and sample counts, and generating control signals for synchronization adjustments. The module uses input ports such as rst (reset), clk (clock), genlock_enable, serial_output, h_total_minus_one, restart_count, divider_value, sof_cvi, sof_cvi_locked, sof_cvo, and sof_cvo_locked to control its operation. Output ports include sync_lines, sync_samples, remove_repeatn, sync_compare_h_reset, sync_compare_v_reset, and genlocked, which provide synchronization status and control signals."
                }
            ]
        }
    ]
}