{
    "spec": "Module name: alt_vipcti131_Vid2IS. Module specification: The alt_vipcti131_Vid2IS module is designed to convert video data from a format with embedded synchronization signals to a format suitable for components requiring explicit control signals like start of packet (SOP) and end of packet (EOP). It accepts input video data (vid_data) along with various synchronization and control signals (vid_clk, vid_de, vid_datavalid, vid_locked, vid_f, vid_v_sync, vid_h_sync, vid_hd_sdn, vid_std) and produces output data (is_data) with associated control signals (is_valid, is_sop, is_eop). The module uses internal signals for synchronization (sync_count, locked), data processing (wrreq, data, full), and status tracking (overflow_reg, overflow_sticky",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti131_Vid2IS\n\nExplanation:\nThe module 'alt_vipcti131_Vid2IS' appears designed to convert video data from a format possibly including embedded synchronization signals to a format suitable for use by other components that require explicitly separated control signals like start of packet (SOP) and end of packet (EOP) alongside the video data. This Verilog module is likely used in FPGA designs where video data interfaces need specific framing and synchronization handling. It supports handling various video input parameters, synchronization of control signals, and the setup of module parameters through Avalon-ST protocol. Additionally, it includes resolving interlaced video signals and supports video data reformatting based on whether the color planes are handled in sequence or parallel. It operates with a clear structure to synchronize, extract, convert, and output video data under controlled conditions acknowledging flow control and overflow scenarios to ensure reliable video data processing."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- rst\n- vid_clk\n- vid_data\n- vid_de\n- vid_datavalid\n- vid_locked\n- vid_f\n- vid_v_sync\n- vid_h_sync\n- vid_hd_sdn\n- vid_std\n- is_clk\n- is_ready\n- av_address\n- av_read\n- av_write\n- av_writedata\n\n**Explanation:**\n- **rst**: Reset signal, used to reset the internal states and registers of the module.\n- **vid_clk**: Clock signal for the video input data.\n- **vid_data**: Video data input that the module processes.\n- **vid_de**: Data enable signal, used to indicate valid video data (used if embedded syncs are not used).\n- **vid_datavalid**: Signal that indicates whether the video data is valid.\n- **vid_locked**: Indicates that the incoming video signal is stable and locked.\n- **vid_f**: Field signal indicating whether the current video frame is the first or second field in interlaced formats.\n- **vid_v_sync**: Vertical synchronization signal for the video input.\n- **vid_h_sync**: Horizontal synchronization signal for the video input.\n- **vid_hd_sdn**: Additional control signal, possibly related to sync or color plane handling in sequential/parallel format.\n- **vid_std**: Standard of the input video data (resolution, frame rate, etc).\n- **is_clk**: Clock signal for the output interface.\n- **is_ready**: Ready signal from downstream component, indicating it can accept data.\n- **av_address**, **av_read**, **av_write**, **av_writedata**: Avalon-ST protocol signals for configuring module parameters and state.\n\n**Output ports:**\n- is_valid\n- is_data\n- is_sop\n- is_eop\n- av_readdata\n- sof\n- sof_locked\n- refclk_div\n- status_update_int\n- overflow\n\n**Explanation:**\n- **is_valid**: Indicates the output data is valid.\n- **is_data**: Output video data after processing.\n- **is_sop**: Start of packet signal for output data, marks the beginning of a video packet.\n- **is_eop**: End of packet signal for output data, marks the end of a video packet.\n- **av_readdata**: Data read from the module in response to Avalon-ST read requests.\n- **sof**: Start of Frame signal, used for synchronization and indicating the beginning of a frame.\n- **sof_locked**: Indicates the Start of Frame signal is stable and locked.\n- **refclk_div**: Reference clock divider output, might be used for timing adjustments or synchronization purposes.\n- **status_update_int**: Status update interrupt, possibly used to signal other components or software about a change in status.\n- **overflow**: Indicates an overflow condition where data may be lost, showing the inability to process incoming data fast enough."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n1. wrreq\n2. wrreq_pre_swap\n3. data\n4. full\n5. enable\n6. overflow_nxt\n7. overflow_reg\n8. overflow_sticky\n9. enable_synced\n10. vid_enable_int\n11. vid_f_int\n12. vid_h_sync_int\n13. vid_v_sync_int\n14. vid_datavalid_int\n15. vid_anc_valid_int\n16. vid_data_int\n17. valid_nxt\n18. valid_reg\n19. data_reg\n20. vid_f_reg\n21. vid_h_sync_reg\n22. vid_v_sync_reg\n23. vid_datavalid_reg\n24. vid_anc_valid_reg\n25. convert\n26. sync_count\n27. locked\n28. vid_locked_reg\n29. f_reg\n30. field_prediction\n\n**Explanation:**\n- **wrreq**: Write request control signal indicating when data write to the FIFO or buffer should occur.\n- **wrreq_pre_swap**: Precondition write request control signal, ensuring data conditions are met for writing.\n- **data**: The processed video data ready to be written after conversion/handling.\n- **full**: Indicates if the FIFO/buffer for output data storage is full.\n- **enable**: A control signal that enables processing in certain module components when active.\n- **overflow_nxt**: Next state logic for managing an overflow condition, helping to track changes and update overflow status.\n- **overflow_reg**: Register to maintain the state of an overflow condition between processing cycles.\n- **overflow_sticky**: Sticky overflow status flag ensuring that overflow status is preserved until acknowledged and cleared.\n- **enable_synced**: Synchronized version of the `enable` signal, aligned with appropriate clock domain.\n- **vid_enable_int**: Internal processed signal indicating if video input is enabled and should be processed.\n- **vid_f_int**: Represents internally handled field signal after possibly synchronization or modification.\n- **vid_h_sync_int**: Internally synchronized or converted horizontal sync signal.\n- **vid_v_sync_int**: Internally synchronized or converted vertical sync signal.\n- **vid_datavalid_int**: Indicates internally handled validation state of video data.\n- **vid_anc_valid_int**: Internally processed ancillary data validity indicator.\n- **vid_data_int**: Video data after being processed by internal logic, possibly including synchronization extraction.\n- **valid_nxt**: Next state logic for determining the validity of data processing state.\n- **valid_reg**: Register maintaining valid state information across processing cycles.\n- **data_reg**: Register holding the processed data before being sent to output.\n- **vid_f_reg**: Register for the field indicator state over processing cycles.\n- **vid_h_sync_reg**: Register for the horizontal sync state over processing cycles.\n- **vid_v_sync_reg**: Register for the vertical sync state over processing cycles.\n- **vid_datavalid_reg**: Register to maintain the data valid state of the video throughout the process.\n- **vid_anc_valid_reg**: Ancillary data validity status register.\n- **convert**: Flag/controller for data type conversion operations (e.g., from sequential to parallel).\n- **sync_count**: Counter used for managing synchronization and determining locked status.\n- **locked**: Status boolean indicating whether the incoming video signal and processing are in sync and locked.\n- **vid_locked_reg**: Register keep tracking of the locked state of the video signal.\n- **f_reg**: Register for storing the frame indication signal state.\n- **field_prediction**: Internal logic to predict field changes in an interlaced video processing scenario."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\nmodule alt_vipcti131_Vid2IS(\n    rst,\n    \n    \n    vid_clk,\n    vid_data,\n    vid_de,\n    vid_datavalid,\n    vid_locked,\n    \n    \n    vid_f,\n    vid_v_sync,\n    vid_h_sync,\n    vid_hd_sdn,\n    vid_std,\n    \n    \n    is_clk,\n    is_ready,\n    is_valid,\n    is_data,\n    is_sop,\n    is_eop,\n    \n    \n    av_address,\n    av_read,\n    av_readdata,\n    av_write,\n    av_writedata,\n    \n    \n    sof,\n    sof_locked,\n    refclk_div,\n    \n    \n    status_update_int,\n    \n    \n    overflow) ;\n    \n\n\n\nfunction integer alt_clogb2;\n  input [31:0] value;\n  integer i;\n  begin\n    alt_clogb2 = 32;\n    for (i=31; i>0; i=i-1) begin\n      if (2**i>=value)\n        alt_clogb2 = i;\n    end\n  end\nendfunction\n\nparameter BPS = 10;\nparameter NUMBER_OF_COLOUR_PLANES = 2;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 1;\nparameter FIFO_DEPTH = 1920;\nparameter USE_EMBEDDED_SYNCS = 1;\nparameter ADD_DATA_ENABLE_SIGNAL = 0;\nparameter CLOCKS_ARE_SAME = 0;\nparameter USE_CONTROL = 1;\nparameter INTERLACED = 1;\nparameter H_ACTIVE_PIXELS_F0 = 1920;\nparameter V_ACTIVE_LINES_F0 = 540;\nparameter H_ACTIVE_PIXELS_F1 = 1920;\nparameter V_ACTIVE_LINES_F1 = 540;\nparameter SYNC_TO = 2;\nparameter ACCEPT_COLOURS_IN_SEQ = 1;\nparameter USE_STD = 1;\nparameter STD_WIDTH = 3;\nparameter GENERATE_SYNC = 1;\nparameter GENERATE_ANC = 0;\n\nlocalparam CONVERT_SEQ_TO_PAR = COLOUR_PLANES_ARE_IN_PARALLEL == 1 && ACCEPT_COLOURS_IN_SEQ != 0 && NUMBER_OF_COLOUR_PLANES > 1;\nlocalparam DATA_WIDTH = (COLOUR_PLANES_ARE_IN_PARALLEL) ? BPS * NUMBER_OF_COLOUR_PLANES : BPS;\nlocalparam NUMBER_OF_COLOUR_PLANES_IN_PARALLEL = (COLOUR_PLANES_ARE_IN_PARALLEL) ? NUMBER_OF_COLOUR_PLANES : 1;\nlocalparam BASE = (BPS >= 10) ? 2 : 0;\nlocalparam LOG2_NUMBER_OF_COLOUR_PLANES = alt_clogb2(NUMBER_OF_COLOUR_PLANES);\nlocalparam COLOUR_PLANES_IN_SEQUENCE = (COLOUR_PLANES_ARE_IN_PARALLEL && !CONVERT_SEQ_TO_PAR) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam COLOUR_PLANES_IN_SEQUENCE_FIFO = (COLOUR_PLANES_ARE_IN_PARALLEL) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam FIFO_WIDTH = DATA_WIDTH + 1;\nlocalparam FIFO_DEPTH_INT = (FIFO_DEPTH * COLOUR_PLANES_IN_SEQUENCE_FIFO) + 4;\nlocalparam USED_WORDS_WIDTH = alt_clogb2(FIFO_DEPTH_INT);\n\ninput rst;\n\n\ninput vid_clk;\ninput [DATA_WIDTH-1:0] vid_data;\ninput vid_de;\ninput vid_datavalid;\ninput vid_locked;\n\n\ninput vid_f;\ninput vid_v_sync;\ninput vid_h_sync;\ninput vid_hd_sdn;\ninput [STD_WIDTH-1:0] vid_std;\n\n\ninput is_clk;\ninput is_ready;\noutput is_valid;\noutput [DATA_WIDTH-1:0] is_data;\noutput is_sop;\noutput is_eop;\n\n\ninput [3:0] av_address;\ninput av_read;\noutput [15:0] av_readdata;\ninput av_write;\ninput [15:0] av_writedata;\n\n\noutput sof;\noutput sof_locked;\noutput refclk_div;\n\n\noutput status_update_int;\n\n\noutput overflow;\n\nreg [DATA_WIDTH-1:0] vid_data_input;\nreg vid_datavalid_input;\nreg vid_f_input;\nreg vid_v_sync_input;\nreg vid_h_sync_input;\nreg vid_hd_sdn_input;\n\nwire [DATA_WIDTH-1:0] is_data;\nwire is_valid;\nwire is_sop;\nwire is_eop;\n\nwire rdreq;\nwire wrreq;\nwire wrreq_pre_swap;\nwire [DATA_WIDTH-1:0] data;\nwire full;\nwire enable;\nwire [USED_WORDS_WIDTH-1:0] usedw;\n\nwire overflow_nxt;\nreg overflow_reg;\nreg overflow_sticky;\nwire overflow_sticky_sync1;\n\nreg enable_synced;\n\nwire rst_vid_clk;\nwire ap;\nwire f;\nwire start_of_vsync;\nreg [1:0] sync_count;\nreg locked;\nwire h_sync, v_sync;\nreg h_sync_reg, v_sync_reg;\nwire packet;\nwire start_of_hsync;\nwire lost_vid_locked;\nwire overflowed;\nwire early_eop;\nwire eop;\nwire [14:0] active_sample_count;\nwire [13:0] active_line_count_f0;\nwire [13:0] active_line_count_f1;\nwire [14:0] total_sample_count;\nwire [13:0] total_line_count_f0;\nwire [13:0] total_line_count_f1;\nwire [13:0] total_line_count;\nwire is_interlaced;\nwire [16:0] is_active_sample_count;\nwire [16:0] is_active_line_count_f0;\nwire [16:0] is_active_line_count_f1;\nwire [13:0] sof_sample;\nwire [1:0] sof_subsample;\nwire [12:0] sof_line;\nwire [13:0] refclk_divider_value;\nwire genlock_enable;\nwire update_sync1;\nwire resolution_change;\nwire resolution_change_sync1;\nwire update;\nwire [STD_WIDTH-1:0] vid_std_sync1;\nreg ap_reg;\nwire end_of_vsync;\nwire interlaced;\nwire start_of_ap;\nwire [1:0] sync_count_next;\nwire locked_next;\nwire stable;\nwire resolution_valid;\nwire wrreq_pre_enable;\nreg vid_locked_reg;\nwire clear_overflow_sticky;\nwire is_output_enable;\nwire frame_synch;\nwire field_prediction_nxt;\nreg field_prediction;\nwire vid_clk_int;\nwire last_sample;\nreg f_reg;\n\ngenerate begin : clocks_are_same_generate\n     if(CLOCKS_ARE_SAME) begin\n         assign rst_vid_clk = rst;\n         assign vid_clk_int = is_clk;\n     end else begin\n         reg rst_vid_clk_reg;\n         reg rst_vid_clk_reg2;\n         \n         always @ (posedge rst or posedge vid_clk_int) begin\n             if(rst) begin\n                rst_vid_clk_reg <= 1'b1;\n                rst_vid_clk_reg2 <= 1'b1;\n             end else begin\n                rst_vid_clk_reg <= 1'b0;\n                rst_vid_clk_reg2 <= rst_vid_clk_reg;\n             end\n         end\n         assign rst_vid_clk = rst_vid_clk_reg2;\n         assign vid_clk_int = vid_clk;\n     end\nend endgenerate\n\n\nalt_vipcti131_Vid2IS_control control(\n    .rst(rst),\n    .clk(is_clk),\n\n    \n    .usedw(usedw),\n    .overflow_sticky(overflow_sticky_sync1),\n    .is_output_enable(is_output_enable), \n    \n    \n    .update(update_sync1),\n    .resolution_change(resolution_change_sync1),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .vid_std(vid_std_sync1), \n    \n    \n    .enable(enable),\n    .clear_overflow_sticky(clear_overflow_sticky),\n    .is_interlaced(is_interlaced),\n    .is_active_sample_count(is_active_sample_count),\n    .is_active_line_count_f0(is_active_line_count_f0),\n    .is_active_line_count_f1(is_active_line_count_f1),\n    .sof_sample(sof_sample),\n    .sof_line(sof_line),\n    .sof_subsample(sof_subsample),\n    .refclk_divider_value(refclk_divider_value),\n    .genlock_enable(genlock_enable),\n    \n    \n    .av_address(av_address),\n    .av_read(av_read),\n    .av_readdata(av_readdata),\n    .av_write(av_write),\n    .av_writedata(av_writedata),\n    \n    .status_update_int(status_update_int));\n    \ndefparam control.USE_CONTROL = USE_CONTROL,\n         control.INTERLACED = INTERLACED,\n         control.H_ACTIVE_PIXELS_F0 = H_ACTIVE_PIXELS_F0,\n         control.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         control.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         control.USED_WORDS_WIDTH = USED_WORDS_WIDTH,\n         control.STD_WIDTH = STD_WIDTH;\n         \n\ngenerate begin : use_std_generate\n    if(USE_STD) begin\n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME, STD_WIDTH) vid_std_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(vid_std),\n            .data_out(vid_std_sync1));\n    end else begin\n        assign vid_std_sync1 = {STD_WIDTH{1'b0}};\n    end\nend endgenerate\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) overflow_sticky_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(overflow_sticky),\n    .data_out(overflow_sticky_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) update_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(update),\n    .data_out(update_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) resolution_change_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(resolution_change),\n    .data_out(resolution_change_sync1));\n\n\nwire enable_sync1;\nwire clear_overflow_sticky_sync1;\nwire genlock_enable_sync1;\nwire [13:0] refclk_divider_value_sync1;\nwire [13:0] sof_sample_sync1;\nwire [12:0] sof_line_sync1;\nwire [1:0] sof_subsample_sync1;\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(enable),\n    .data_out(enable_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) clear_overflow_sticky_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(clear_overflow_sticky),\n    .data_out(clear_overflow_sticky_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) genlock_enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(genlock_enable),\n    .data_out(genlock_enable_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 14) refclk_divider_value_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(refclk_divider_value),\n    .data_out(refclk_divider_value_sync1));\n  \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 14) sof_sample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_sample),\n    .data_out(sof_sample_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 13) sof_line_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_line),\n    .data_out(sof_line_sync1));\n \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 2) sof_subsample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_subsample),\n    .data_out(sof_subsample_sync1));\n    \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if (rst_vid_clk) begin\n        vid_data_input <= {DATA_WIDTH{1'b0}};\n        vid_datavalid_input <= 1'b0;\n        vid_f_input <= 1'b0;\n        vid_v_sync_input <= 1'b0;\n        vid_h_sync_input <= 1'b0;\n        vid_hd_sdn_input <= 1'b0;\n    end else begin\n        vid_data_input <= vid_data;\n        if (~USE_EMBEDDED_SYNCS && ADD_DATA_ENABLE_SIGNAL)\n            vid_datavalid_input <= vid_de;\n        else\n            vid_datavalid_input <= vid_datavalid;\n        vid_f_input <= vid_f;\n        vid_v_sync_input <= vid_v_sync;\n        vid_h_sync_input <= vid_h_sync;\n        if(CONVERT_SEQ_TO_PAR)\n            vid_hd_sdn_input <= vid_hd_sdn;\n        else\n            vid_hd_sdn_input <= COLOUR_PLANES_ARE_IN_PARALLEL;\n    end\nend\n\n\nwire vid_enable_int;\nwire vid_f_int;\nwire vid_h_sync_int;\nwire vid_v_sync_int;\nwire vid_datavalid_int;\nwire vid_anc_valid_int;\nwire [DATA_WIDTH-1:0] vid_data_int;\n\ngenerate begin : use_embedded_syncs_generate\n    if(USE_EMBEDDED_SYNCS) begin\n        assign vid_enable_int = vid_datavalid_input;  \n                                                      \n        \n        alt_vipcti131_Vid2IS_embedded_sync_extractor#(\n                .DATA_WIDTH(DATA_WIDTH),\n                .BPS(BPS),\n                .BASE(BASE),\n                .GENERATE_ANC(GENERATE_ANC))\n            sync_extractor(\n                .rst(rst_vid_clk),\n                .clk(vid_clk_int),\n    \n                \n                .vid_locked(vid_locked),\n                .vid_enable(vid_enable_int),\n                .vid_hd_sdn(vid_hd_sdn_input),\n                .vid_data_in(vid_data_input),\n    \n                \n                .vid_f(vid_f_int),\n                .vid_h_sync(vid_h_sync_int),\n                .vid_v_sync(vid_v_sync_int),\n                .vid_datavalid(vid_datavalid_int),\n                .vid_anc_valid(vid_anc_valid_int),\n                .vid_data_out(vid_data_int));\n    end else begin\n        assign vid_enable_int = (ADD_DATA_ENABLE_SIGNAL==1) ? vid_datavalid : 1'b1;\n    \n        alt_vipcti131_Vid2IS_sync_polarity_convertor hsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_h_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_h_sync_int));\n            \n        alt_vipcti131_Vid2IS_sync_polarity_convertor vsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_v_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_v_sync_int));\n            \n        assign vid_f_int = vid_f_input;\n        assign vid_datavalid_int = vid_datavalid_input;\n        assign vid_anc_valid_int = 1'b0;\n        assign vid_data_int = vid_data_input;\n    end\nend endgenerate\n\n\nwire valid_nxt;\nreg valid_reg;\nreg [DATA_WIDTH-1:0] data_reg;\nreg vid_f_reg;\nreg vid_h_sync_reg;\nreg vid_v_sync_reg;\nreg vid_datavalid_reg;\nreg vid_anc_valid_reg;\nreg convert;\n\nassign valid_nxt = vid_enable_int & (vid_datavalid_int | vid_anc_valid_int); \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        valid_reg <= 1'b0;\n        convert <= 1'b0;\n        data_reg <= {DATA_WIDTH{1'b0}};\n        vid_f_reg <= 1'b0;\n        vid_h_sync_reg <= 1'b0;\n        vid_v_sync_reg <= 1'b0;\n        vid_datavalid_reg <= 1'b0;\n        vid_anc_valid_reg <= 1'b0;\n    end else begin\n        if(overflow_nxt) begin \n                               \n            valid_reg <= valid_reg;\n            convert <= convert;\n        end else begin\n            valid_reg <= (valid_nxt | valid_reg) & ~eop;\n            convert <= ((vid_enable_int & vid_datavalid_int) | convert) & ~eop;   \n        end\n        data_reg <= (valid_nxt) ? vid_data_int : data_reg;\n        \n        if(vid_enable_int) begin\n            vid_f_reg <= vid_f_int;\n            vid_h_sync_reg <= vid_h_sync_int;\n            vid_v_sync_reg <= vid_v_sync_int;\n            vid_datavalid_reg <= vid_datavalid_int;\n            vid_anc_valid_reg <= vid_anc_valid_int;\n        end\n    end\nend\n\nassign wrreq_pre_enable = valid_nxt | eop; \nassign data = (valid_nxt & ~valid_reg) ? (vid_datavalid_int) ? 0 : 13 : \n                                         data_reg;\nassign f = vid_f_reg;\nassign h_sync = vid_h_sync_reg;\nassign v_sync = vid_v_sync_reg;\nassign ap = vid_datavalid_reg;\nassign last_sample = valid_reg & (start_of_vsync | end_of_vsync);\n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        sync_count <= 2'b01;\n        locked <= 1'b0;\n\t    enable_synced <= 1'b0;\n        \n        overflow_reg <= 1'b0;\n        overflow_sticky <= 1'b0;\n        vid_locked_reg <= 1'b0;\n        \n        h_sync_reg <= 1'b0;\n        v_sync_reg <= 1'b0;\n        ap_reg <= 1'b0;\n        \n        f_reg <= 1'b0;\n        field_prediction <= 1'b0;\n    end else begin\n        if(~vid_locked | lost_vid_locked | overflowed) begin\n            sync_count <= 2'b01;\n            locked <= 1'b0;\n            enable_synced <= 1'b0;\n        end else begin\n            sync_count <= sync_count_next;\n            locked <= locked_next;\n            enable_synced <= (frame_synch) ? enable_sync1 & locked_next : enable_synced;\n        end\n        \n        h_sync_reg <= h_sync;\n        v_sync_reg <= v_sync;\n        ap_reg <= ap;\n        \n        overflow_reg <= overflow_nxt;\n        overflow_sticky <= (overflow_nxt | overflow_sticky) & ~clear_overflow_sticky_sync1;\n        vid_locked_reg <= vid_locked;\n        \n        f_reg <= f;\n        field_prediction <= field_prediction_nxt;\n    end\nend\n\nassign field_prediction_nxt = (~interlaced | end_of_vsync) ? f_reg : (start_of_vsync) ? ~f_reg : field_prediction;\n    \nassign overflow = overflow_sticky; \n                                   \nassign overflow_nxt = (wrreq | overflow_reg) & full;\nassign lost_vid_locked = (~vid_locked & vid_locked_reg);\nassign overflowed = (~full & overflow_reg);\n\nassign wrreq = wrreq_pre_enable & enable_synced;\nassign wrreq_pre_swap = wrreq & ~full;\nassign start_of_ap = ap & ~ap_reg;\nassign end_of_vsync = ~v_sync & v_sync_reg;\nassign start_of_vsync = v_sync & ~v_sync_reg;\nassign start_of_hsync = h_sync & ~h_sync_reg;\nassign early_eop = valid_reg & (lost_vid_locked | overflowed);\nassign eop =  last_sample | early_eop;\nassign packet = last_sample | early_eop;\nassign sync_count_next = (start_of_hsync) ? sync_count - 2'b01 : sync_count;\nassign locked_next = ~|sync_count_next | locked;\n\ngenerate begin : sync_to_generate\n    if(SYNC_TO == 0) begin\n        assign frame_synch = end_of_vsync & ~f;\n    end else if(SYNC_TO == 1) begin\n        assign frame_synch = end_of_vsync & f;\n    end else begin\n        assign frame_synch = end_of_vsync;\n    end\nend endgenerate\n\n\nalt_vipcti131_Vid2IS_resolution_detection resolution_detection(\n    .rst(rst_vid_clk),\n    .clk(vid_clk_int),\n    \n    \n    .count_cycle(vid_enable_int),\n    .ap(ap),\n    .hd_sdn(vid_hd_sdn_input),\n    .start_new_line(start_of_hsync),\n    .start_new_field(start_of_vsync),\n    .end_of_vsync(end_of_vsync),\n    .f(f),\n    .vid_locked(vid_locked),\n    \n    \n    .update(update),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .total_line_count(total_line_count),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .resolution_change(resolution_change));\n    \ndefparam resolution_detection.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         resolution_detection.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.H_ACTIVE_PIXELS = H_ACTIVE_PIXELS_F0,\n         resolution_detection.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         resolution_detection.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         resolution_detection.INTERLACED = INTERLACED;\n\n\ngenerate begin : sync_generation_generate\n    if(GENERATE_SYNC > 0) begin\n        alt_vipcti131_common_sync_generation sync_generation(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .clear_enable(1'b0),\n            .enable_count(vid_enable_int),\n            .hd_sdn(vid_hd_sdn_input),\n            .start_of_vsync(start_of_vsync),\n            .field_prediction(field_prediction_nxt),\n            .interlaced(interlaced),\n            .total_sample_count(total_sample_count[14:1]),\n            .total_sample_count_valid(total_sample_count[0]),\n            .total_line_count(total_line_count[13:1]),\n            .total_line_count_valid(total_line_count[0]),\n            .stable(stable),\n            \n            .divider_value(refclk_divider_value_sync1),\n            .sof_sample(sof_sample_sync1),\n            .sof_line(sof_line_sync1),\n            .sof_subsample(sof_subsample_sync1),\n            \n            .output_enable(genlock_enable_sync1),\n            .sof(sof),\n            .sof_locked(sof_locked),\n            .div(refclk_div));\n\n            defparam sync_generation.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n                     sync_generation.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.TOTALS_MINUS_ONE = 0;\n    end else begin\n        assign sof = 1'b0;\n        assign sof_locked = 1'b0;\n    end\nend endgenerate\n\n\n\ngenerate begin : avalon_st_output\n    if(GENERATE_SYNC < 2) begin\n        wire wrreq_post_swap;\n        wire [DATA_WIDTH-1:0] data_post_swap;\n        wire packet_post_swap;\n        \n        \n        if(CONVERT_SEQ_TO_PAR) begin\n            alt_vipcti131_Vid2IS_write_buffer #(\n                    .DATA_WIDTH(DATA_WIDTH),\n                    .NUMBER_OF_COLOUR_PLANES(NUMBER_OF_COLOUR_PLANES),\n                    .BPS(BPS))\n                write_buffer(\n                    .rst(rst_vid_clk),\n                    .clk(vid_clk_int),\n                    \n                    .convert(convert),\n                    .hd_sdn(vid_hd_sdn_input),\n                    .early_eop(early_eop),\n                    \n                    .wrreq_in(wrreq_pre_swap),\n                    .data_in(data),\n                    .packet_in(packet),\n                    \n                    .wrreq_out(wrreq_post_swap),\n                    .data_out(data_post_swap),\n                    .packet_out(packet_post_swap));\n        end else begin\n            assign data_post_swap = data;\n            assign wrreq_post_swap = wrreq_pre_swap;\n            assign packet_post_swap = packet;\n        end\n        \n        wire [FIFO_WIDTH-1:0] q;\n        wire empty;\n        \n        alt_vipcti131_common_fifo #(\n                .DATA_WIDTH(FIFO_WIDTH),\n                .CLOCKS_ARE_SAME(CLOCKS_ARE_SAME),\n                .FIFO_DEPTH(FIFO_DEPTH_INT))\n            input_fifo(\n                .wrclk(vid_clk_int),\n                .rdreq(rdreq),\n                .aclr(rst_vid_clk),\n                .rdclk(is_clk),\n                .wrreq(wrreq_post_swap),\n                .data({data_post_swap, packet_post_swap}),\n                .rdusedw(usedw),\n                .rdempty(empty),\n                .wrfull(full),\n                .q(q));\n         \n        wire enable_resync1;\n        wire is_field_prediction;\n        \n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME) field_prediction_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(field_prediction),\n            .data_out(is_field_prediction));\n\n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME) enable_resync_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(enable_synced),\n            .data_out(enable_resync1));\n         \n        \n        \n        \n        alt_vipcti131_Vid2IS_av_st_output #(\n                .FIFO_WIDTH(FIFO_WIDTH),\n                .DATA_WIDTH(DATA_WIDTH),\n                .NUMBER_OF_COLOUR_PLANES_IN_PARALLEL(NUMBER_OF_COLOUR_PLANES_IN_PARALLEL),\n                .BPS(BPS))\n            av_st_output(\n                .rst(rst),\n                \n                .enable(enable_resync1),\n                .q(q),\n                .rdreq(rdreq),\n                .empty(empty),\n                .is_interlaced(is_interlaced),\n                .is_sync_to(2'b10),\n                .is_field_prediction(is_field_prediction),\n                .is_active_sample_count(is_active_sample_count),\n                .is_active_line_count_f0(is_active_line_count_f0),\n                .is_active_line_count_f1(is_active_line_count_f1),\n                \n                .is_clk(is_clk),\n                .is_ready(is_ready),\n                .is_valid(is_valid),\n                .is_data(is_data),\n                .is_sop(is_sop),\n                .is_eop(is_eop),\n                \n                .is_output_enable(is_output_enable));\n    end else begin\n        assign is_valid = 1'b0;\n        assign is_sop = 1'b0;\n        assign is_eop = 1'b0;\n        assign is_data = {DATA_WIDTH{1'b0}};\n    end\nend endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: alt_vipcti131_Vid2IS. Module specification: The alt_vipcti131_Vid2IS module is designed to convert video data from a format with embedded synchronization signals to a format suitable for components requiring explicit control signals like start of packet (SOP) and end of packet (EOP). It accepts input video data (vid_data) along with various synchronization and control signals (vid_clk, vid_de, vid_datavalid, vid_locked, vid_f, vid_v_sync, vid_h_sync, vid_hd_sdn, vid_std) and produces output data (is_data) with associated control signals (is_valid, is_sop, is_eop). The module uses internal signals for synchronization (sync_count, locked), data processing (wrreq, data, full), and status tracking (overflow_reg, overflow_sticky"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti131_Vid2IS\n\nExplanation:\nThe module 'alt_vipcti131_Vid2IS' appears designed to convert video data from a format possibly including embedded synchronization signals to a format suitable for use by other components that require explicitly separated control signals like start of packet (SOP) and end of packet (EOP) alongside the video data. This Verilog module is likely used in FPGA designs where video data interfaces need specific framing and synchronization handling. It supports handling various video input parameters, synchronization of control signals, and the setup of module parameters through Avalon-ST protocol. Additionally, it includes resolving interlaced video signals and supports video data reformatting based on whether the color planes are handled in sequence or parallel. It operates with a clear structure to synchronize, extract, convert, and output video data under controlled conditions acknowledging flow control and overflow scenarios to ensure reliable video data processing."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- rst\n- vid_clk\n- vid_data\n- vid_de\n- vid_datavalid\n- vid_locked\n- vid_f\n- vid_v_sync\n- vid_h_sync\n- vid_hd_sdn\n- vid_std\n- is_clk\n- is_ready\n- av_address\n- av_read\n- av_write\n- av_writedata\n\n**Explanation:**\n- **rst**: Reset signal, used to reset the internal states and registers of the module.\n- **vid_clk**: Clock signal for the video input data.\n- **vid_data**: Video data input that the module processes.\n- **vid_de**: Data enable signal, used to indicate valid video data (used if embedded syncs are not used).\n- **vid_datavalid**: Signal that indicates whether the video data is valid.\n- **vid_locked**: Indicates that the incoming video signal is stable and locked.\n- **vid_f**: Field signal indicating whether the current video frame is the first or second field in interlaced formats.\n- **vid_v_sync**: Vertical synchronization signal for the video input.\n- **vid_h_sync**: Horizontal synchronization signal for the video input.\n- **vid_hd_sdn**: Additional control signal, possibly related to sync or color plane handling in sequential/parallel format.\n- **vid_std**: Standard of the input video data (resolution, frame rate, etc).\n- **is_clk**: Clock signal for the output interface.\n- **is_ready**: Ready signal from downstream component, indicating it can accept data.\n- **av_address**, **av_read**, **av_write**, **av_writedata**: Avalon-ST protocol signals for configuring module parameters and state.\n\n**Output ports:**\n- is_valid\n- is_data\n- is_sop\n- is_eop\n- av_readdata\n- sof\n- sof_locked\n- refclk_div\n- status_update_int\n- overflow\n\n**Explanation:**\n- **is_valid**: Indicates the output data is valid.\n- **is_data**: Output video data after processing.\n- **is_sop**: Start of packet signal for output data, marks the beginning of a video packet.\n- **is_eop**: End of packet signal for output data, marks the end of a video packet.\n- **av_readdata**: Data read from the module in response to Avalon-ST read requests.\n- **sof**: Start of Frame signal, used for synchronization and indicating the beginning of a frame.\n- **sof_locked**: Indicates the Start of Frame signal is stable and locked.\n- **refclk_div**: Reference clock divider output, might be used for timing adjustments or synchronization purposes.\n- **status_update_int**: Status update interrupt, possibly used to signal other components or software about a change in status.\n- **overflow**: Indicates an overflow condition where data may be lost, showing the inability to process incoming data fast enough."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n1. wrreq\n2. wrreq_pre_swap\n3. data\n4. full\n5. enable\n6. overflow_nxt\n7. overflow_reg\n8. overflow_sticky\n9. enable_synced\n10. vid_enable_int\n11. vid_f_int\n12. vid_h_sync_int\n13. vid_v_sync_int\n14. vid_datavalid_int\n15. vid_anc_valid_int\n16. vid_data_int\n17. valid_nxt\n18. valid_reg\n19. data_reg\n20. vid_f_reg\n21. vid_h_sync_reg\n22. vid_v_sync_reg\n23. vid_datavalid_reg\n24. vid_anc_valid_reg\n25. convert\n26. sync_count\n27. locked\n28. vid_locked_reg\n29. f_reg\n30. field_prediction\n\n**Explanation:**\n- **wrreq**: Write request control signal indicating when data write to the FIFO or buffer should occur.\n- **wrreq_pre_swap**: Precondition write request control signal, ensuring data conditions are met for writing.\n- **data**: The processed video data ready to be written after conversion/handling.\n- **full**: Indicates if the FIFO/buffer for output data storage is full.\n- **enable**: A control signal that enables processing in certain module components when active.\n- **overflow_nxt**: Next state logic for managing an overflow condition, helping to track changes and update overflow status.\n- **overflow_reg**: Register to maintain the state of an overflow condition between processing cycles.\n- **overflow_sticky**: Sticky overflow status flag ensuring that overflow status is preserved until acknowledged and cleared.\n- **enable_synced**: Synchronized version of the `enable` signal, aligned with appropriate clock domain.\n- **vid_enable_int**: Internal processed signal indicating if video input is enabled and should be processed.\n- **vid_f_int**: Represents internally handled field signal after possibly synchronization or modification.\n- **vid_h_sync_int**: Internally synchronized or converted horizontal sync signal.\n- **vid_v_sync_int**: Internally synchronized or converted vertical sync signal.\n- **vid_datavalid_int**: Indicates internally handled validation state of video data.\n- **vid_anc_valid_int**: Internally processed ancillary data validity indicator.\n- **vid_data_int**: Video data after being processed by internal logic, possibly including synchronization extraction.\n- **valid_nxt**: Next state logic for determining the validity of data processing state.\n- **valid_reg**: Register maintaining valid state information across processing cycles.\n- **data_reg**: Register holding the processed data before being sent to output.\n- **vid_f_reg**: Register for the field indicator state over processing cycles.\n- **vid_h_sync_reg**: Register for the horizontal sync state over processing cycles.\n- **vid_v_sync_reg**: Register for the vertical sync state over processing cycles.\n- **vid_datavalid_reg**: Register to maintain the data valid state of the video throughout the process.\n- **vid_anc_valid_reg**: Ancillary data validity status register.\n- **convert**: Flag/controller for data type conversion operations (e.g., from sequential to parallel).\n- **sync_count**: Counter used for managing synchronization and determining locked status.\n- **locked**: Status boolean indicating whether the incoming video signal and processing are in sync and locked.\n- **vid_locked_reg**: Register keep tracking of the locked state of the video signal.\n- **f_reg**: Register for storing the frame indication signal state.\n- **field_prediction**: Internal logic to predict field changes in an interlaced video processing scenario."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>module alt_vipcti131_Vid2IS(\n    rst,\n    \n    \n    vid_clk,\n    vid_data,\n    vid_de,\n    vid_datavalid,\n    vid_locked,\n    \n    \n    vid_f,\n    vid_v_sync,\n    vid_h_sync,\n    vid_hd_sdn,\n    vid_std,\n    \n    \n    is_clk,\n    is_ready,\n    is_valid,\n    is_data,\n    is_sop,\n    is_eop,\n    \n    \n    av_address,\n    av_read,\n    av_readdata,\n    av_write,\n    av_writedata,\n    \n    \n    sof,\n    sof_locked,\n    refclk_div,\n    \n    \n    status_update_int,\n    \n    \n    overflow) ;\n    \n\n\n\nfunction integer alt_clogb2;\n  input [31:0] value;\n  integer i;\n  begin\n    alt_clogb2 = 32;\n    for (i=31; i>0; i=i-1) begin\n      if (2**i>=value)\n        alt_clogb2 = i;\n    end\n  end\nendfunction\n\nparameter BPS = 10;\nparameter NUMBER_OF_COLOUR_PLANES = 2;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 1;\nparameter FIFO_DEPTH = 1920;\nparameter USE_EMBEDDED_SYNCS = 1;\nparameter ADD_DATA_ENABLE_SIGNAL = 0;\nparameter CLOCKS_ARE_SAME = 0;\nparameter USE_CONTROL = 1;\nparameter INTERLACED = 1;\nparameter H_ACTIVE_PIXELS_F0 = 1920;\nparameter V_ACTIVE_LINES_F0 = 540;\nparameter H_ACTIVE_PIXELS_F1 = 1920;\nparameter V_ACTIVE_LINES_F1 = 540;\nparameter SYNC_TO = 2;\nparameter ACCEPT_COLOURS_IN_SEQ = 1;\nparameter USE_STD = 1;\nparameter STD_WIDTH = 3;\nparameter GENERATE_SYNC = 1;\nparameter GENERATE_ANC = 0;\n\nlocalparam CONVERT_SEQ_TO_PAR = COLOUR_PLANES_ARE_IN_PARALLEL == 1 && ACCEPT_COLOURS_IN_SEQ != 0 && NUMBER_OF_COLOUR_PLANES > 1;\nlocalparam DATA_WIDTH = (COLOUR_PLANES_ARE_IN_PARALLEL) ? BPS * NUMBER_OF_COLOUR_PLANES : BPS;\nlocalparam NUMBER_OF_COLOUR_PLANES_IN_PARALLEL = (COLOUR_PLANES_ARE_IN_PARALLEL) ? NUMBER_OF_COLOUR_PLANES : 1;\nlocalparam BASE = (BPS >= 10) ? 2 : 0;\nlocalparam LOG2_NUMBER_OF_COLOUR_PLANES = alt_clogb2(NUMBER_OF_COLOUR_PLANES);\nlocalparam COLOUR_PLANES_IN_SEQUENCE = (COLOUR_PLANES_ARE_IN_PARALLEL && !CONVERT_SEQ_TO_PAR) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam COLOUR_PLANES_IN_SEQUENCE_FIFO = (COLOUR_PLANES_ARE_IN_PARALLEL) ? 1 : NUMBER_OF_COLOUR_PLANES;\nlocalparam FIFO_WIDTH = DATA_WIDTH + 1;\nlocalparam FIFO_DEPTH_INT = (FIFO_DEPTH * COLOUR_PLANES_IN_SEQUENCE_FIFO) + 4;\nlocalparam USED_WORDS_WIDTH = alt_clogb2(FIFO_DEPTH_INT);\n\ninput rst;\n\n\ninput vid_clk;\ninput [DATA_WIDTH-1:0] vid_data;\ninput vid_de;\ninput vid_datavalid;\ninput vid_locked;\n\n\ninput vid_f;\ninput vid_v_sync;\ninput vid_h_sync;\ninput vid_hd_sdn;\ninput [STD_WIDTH-1:0] vid_std;\n\n\ninput is_clk;\ninput is_ready;\noutput is_valid;\noutput [DATA_WIDTH-1:0] is_data;\noutput is_sop;\noutput is_eop;\n\n\ninput [3:0] av_address;\ninput av_read;\noutput [15:0] av_readdata;\ninput av_write;\ninput [15:0] av_writedata;\n\n\noutput sof;\noutput sof_locked;\noutput refclk_div;\n\n\noutput status_update_int;\n\n\noutput overflow;\n\nreg [DATA_WIDTH-1:0] vid_data_input;\nreg vid_datavalid_input;\nreg vid_f_input;\nreg vid_v_sync_input;\nreg vid_h_sync_input;\nreg vid_hd_sdn_input;\n\nwire [DATA_WIDTH-1:0] is_data;\nwire is_valid;\nwire is_sop;\nwire is_eop;\n\nwire rdreq;\nwire wrreq;\nwire wrreq_pre_swap;\nwire [DATA_WIDTH-1:0] data;\nwire full;\nwire enable;\nwire [USED_WORDS_WIDTH-1:0] usedw;\n\nwire overflow_nxt;\nreg overflow_reg;\nreg overflow_sticky;\nwire overflow_sticky_sync1;\n\nreg enable_synced;\n\nwire rst_vid_clk;\nwire ap;\nwire f;\nwire start_of_vsync;\nreg [1:0] sync_count;\nreg locked;\nwire h_sync, v_sync;\nreg h_sync_reg, v_sync_reg;\nwire packet;\nwire start_of_hsync;\nwire lost_vid_locked;\nwire overflowed;\nwire early_eop;\nwire eop;\nwire [14:0] active_sample_count;\nwire [13:0] active_line_count_f0;\nwire [13:0] active_line_count_f1;\nwire [14:0] total_sample_count;\nwire [13:0] total_line_count_f0;\nwire [13:0] total_line_count_f1;\nwire [13:0] total_line_count;\nwire is_interlaced;\nwire [16:0] is_active_sample_count;\nwire [16:0] is_active_line_count_f0;\nwire [16:0] is_active_line_count_f1;\nwire [13:0] sof_sample;\nwire [1:0] sof_subsample;\nwire [12:0] sof_line;\nwire [13:0] refclk_divider_value;\nwire genlock_enable;\nwire update_sync1;\nwire resolution_change;\nwire resolution_change_sync1;\nwire update;\nwire [STD_WIDTH-1:0] vid_std_sync1;\nreg ap_reg;\nwire end_of_vsync;\nwire interlaced;\nwire start_of_ap;\nwire [1:0] sync_count_next;\nwire locked_next;\nwire stable;\nwire resolution_valid;\nwire wrreq_pre_enable;\nreg vid_locked_reg;\nwire clear_overflow_sticky;\nwire is_output_enable;\nwire frame_synch;\nwire field_prediction_nxt;\nreg field_prediction;\nwire vid_clk_int;\nwire last_sample;\nreg f_reg;\n\ngenerate begin : clocks_are_same_generate\n     if(CLOCKS_ARE_SAME) begin\n         assign rst_vid_clk = rst;\n         assign vid_clk_int = is_clk;\n     end else begin\n         reg rst_vid_clk_reg;\n         reg rst_vid_clk_reg2;\n         \n         always @ (posedge rst or posedge vid_clk_int) begin\n             if(rst) begin\n                rst_vid_clk_reg <= 1'b1;\n                rst_vid_clk_reg2 <= 1'b1;\n             end else begin\n                rst_vid_clk_reg <= 1'b0;\n                rst_vid_clk_reg2 <= rst_vid_clk_reg;\n             end\n         end\n         assign rst_vid_clk = rst_vid_clk_reg2;\n         assign vid_clk_int = vid_clk;\n     end\nend endgenerate\n\n\nalt_vipcti131_Vid2IS_control control(\n    .rst(rst),\n    .clk(is_clk),\n\n    \n    .usedw(usedw),\n    .overflow_sticky(overflow_sticky_sync1),\n    .is_output_enable(is_output_enable), \n    \n    \n    .update(update_sync1),\n    .resolution_change(resolution_change_sync1),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .vid_std(vid_std_sync1), \n    \n    \n    .enable(enable),\n    .clear_overflow_sticky(clear_overflow_sticky),\n    .is_interlaced(is_interlaced),\n    .is_active_sample_count(is_active_sample_count),\n    .is_active_line_count_f0(is_active_line_count_f0),\n    .is_active_line_count_f1(is_active_line_count_f1),\n    .sof_sample(sof_sample),\n    .sof_line(sof_line),\n    .sof_subsample(sof_subsample),\n    .refclk_divider_value(refclk_divider_value),\n    .genlock_enable(genlock_enable),\n    \n    \n    .av_address(av_address),\n    .av_read(av_read),\n    .av_readdata(av_readdata),\n    .av_write(av_write),\n    .av_writedata(av_writedata),\n    \n    .status_update_int(status_update_int));\n    \ndefparam control.USE_CONTROL = USE_CONTROL,\n         control.INTERLACED = INTERLACED,\n         control.H_ACTIVE_PIXELS_F0 = H_ACTIVE_PIXELS_F0,\n         control.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         control.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         control.USED_WORDS_WIDTH = USED_WORDS_WIDTH,\n         control.STD_WIDTH = STD_WIDTH;\n         \n\ngenerate begin : use_std_generate\n    if(USE_STD) begin\n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME, STD_WIDTH) vid_std_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(vid_std),\n            .data_out(vid_std_sync1));\n    end else begin\n        assign vid_std_sync1 = {STD_WIDTH{1'b0}};\n    end\nend endgenerate\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) overflow_sticky_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(overflow_sticky),\n    .data_out(overflow_sticky_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) update_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(update),\n    .data_out(update_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) resolution_change_sync(\n    .rst(rst),\n    .sync_clock(is_clk),\n    .data_in(resolution_change),\n    .data_out(resolution_change_sync1));\n\n\nwire enable_sync1;\nwire clear_overflow_sticky_sync1;\nwire genlock_enable_sync1;\nwire [13:0] refclk_divider_value_sync1;\nwire [13:0] sof_sample_sync1;\nwire [12:0] sof_line_sync1;\nwire [1:0] sof_subsample_sync1;\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(enable),\n    .data_out(enable_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) clear_overflow_sticky_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(clear_overflow_sticky),\n    .data_out(clear_overflow_sticky_sync1));\n\nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME) genlock_enable_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(genlock_enable),\n    .data_out(genlock_enable_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 14) refclk_divider_value_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(refclk_divider_value),\n    .data_out(refclk_divider_value_sync1));\n  \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 14) sof_sample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_sample),\n    .data_out(sof_sample_sync1));\n    \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 13) sof_line_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_line),\n    .data_out(sof_line_sync1));\n \nalt_vipcti131_common_sync #(CLOCKS_ARE_SAME, 2) sof_subsample_sync(\n    .rst(rst_vid_clk),\n    .sync_clock(vid_clk_int),\n    .data_in(sof_subsample),\n    .data_out(sof_subsample_sync1));\n    \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if (rst_vid_clk) begin\n        vid_data_input <= {DATA_WIDTH{1'b0}};\n        vid_datavalid_input <= 1'b0;\n        vid_f_input <= 1'b0;\n        vid_v_sync_input <= 1'b0;\n        vid_h_sync_input <= 1'b0;\n        vid_hd_sdn_input <= 1'b0;\n    end else begin\n        vid_data_input <= vid_data;\n        if (~USE_EMBEDDED_SYNCS && ADD_DATA_ENABLE_SIGNAL)\n            vid_datavalid_input <= vid_de;\n        else\n            vid_datavalid_input <= vid_datavalid;\n        vid_f_input <= vid_f;\n        vid_v_sync_input <= vid_v_sync;\n        vid_h_sync_input <= vid_h_sync;\n        if(CONVERT_SEQ_TO_PAR)\n            vid_hd_sdn_input <= vid_hd_sdn;\n        else\n            vid_hd_sdn_input <= COLOUR_PLANES_ARE_IN_PARALLEL;\n    end\nend\n\n\nwire vid_enable_int;\nwire vid_f_int;\nwire vid_h_sync_int;\nwire vid_v_sync_int;\nwire vid_datavalid_int;\nwire vid_anc_valid_int;\nwire [DATA_WIDTH-1:0] vid_data_int;\n\ngenerate begin : use_embedded_syncs_generate\n    if(USE_EMBEDDED_SYNCS) begin\n        assign vid_enable_int = vid_datavalid_input;  \n                                                      \n        \n        alt_vipcti131_Vid2IS_embedded_sync_extractor#(\n                .DATA_WIDTH(DATA_WIDTH),\n                .BPS(BPS),\n                .BASE(BASE),\n                .GENERATE_ANC(GENERATE_ANC))\n            sync_extractor(\n                .rst(rst_vid_clk),\n                .clk(vid_clk_int),\n    \n                \n                .vid_locked(vid_locked),\n                .vid_enable(vid_enable_int),\n                .vid_hd_sdn(vid_hd_sdn_input),\n                .vid_data_in(vid_data_input),\n    \n                \n                .vid_f(vid_f_int),\n                .vid_h_sync(vid_h_sync_int),\n                .vid_v_sync(vid_v_sync_int),\n                .vid_datavalid(vid_datavalid_int),\n                .vid_anc_valid(vid_anc_valid_int),\n                .vid_data_out(vid_data_int));\n    end else begin\n        assign vid_enable_int = (ADD_DATA_ENABLE_SIGNAL==1) ? vid_datavalid : 1'b1;\n    \n        alt_vipcti131_Vid2IS_sync_polarity_convertor hsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_h_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_h_sync_int));\n            \n        alt_vipcti131_Vid2IS_sync_polarity_convertor vsync_convertor(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .sync_in(vid_v_sync_input),\n            .datavalid(vid_datavalid_input),\n            .sync_out(vid_v_sync_int));\n            \n        assign vid_f_int = vid_f_input;\n        assign vid_datavalid_int = vid_datavalid_input;\n        assign vid_anc_valid_int = 1'b0;\n        assign vid_data_int = vid_data_input;\n    end\nend endgenerate\n\n\nwire valid_nxt;\nreg valid_reg;\nreg [DATA_WIDTH-1:0] data_reg;\nreg vid_f_reg;\nreg vid_h_sync_reg;\nreg vid_v_sync_reg;\nreg vid_datavalid_reg;\nreg vid_anc_valid_reg;\nreg convert;\n\nassign valid_nxt = vid_enable_int & (vid_datavalid_int | vid_anc_valid_int); \n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        valid_reg <= 1'b0;\n        convert <= 1'b0;\n        data_reg <= {DATA_WIDTH{1'b0}};\n        vid_f_reg <= 1'b0;\n        vid_h_sync_reg <= 1'b0;\n        vid_v_sync_reg <= 1'b0;\n        vid_datavalid_reg <= 1'b0;\n        vid_anc_valid_reg <= 1'b0;\n    end else begin\n        if(overflow_nxt) begin \n                               \n            valid_reg <= valid_reg;\n            convert <= convert;\n        end else begin\n            valid_reg <= (valid_nxt | valid_reg) & ~eop;\n            convert <= ((vid_enable_int & vid_datavalid_int) | convert) & ~eop;   \n        end\n        data_reg <= (valid_nxt) ? vid_data_int : data_reg;\n        \n        if(vid_enable_int) begin\n            vid_f_reg <= vid_f_int;\n            vid_h_sync_reg <= vid_h_sync_int;\n            vid_v_sync_reg <= vid_v_sync_int;\n            vid_datavalid_reg <= vid_datavalid_int;\n            vid_anc_valid_reg <= vid_anc_valid_int;\n        end\n    end\nend\n\nassign wrreq_pre_enable = valid_nxt | eop; \nassign data = (valid_nxt & ~valid_reg) ? (vid_datavalid_int) ? 0 : 13 : \n                                         data_reg;\nassign f = vid_f_reg;\nassign h_sync = vid_h_sync_reg;\nassign v_sync = vid_v_sync_reg;\nassign ap = vid_datavalid_reg;\nassign last_sample = valid_reg & (start_of_vsync | end_of_vsync);\n\nalways @ (posedge rst_vid_clk or posedge vid_clk_int) begin\n    if(rst_vid_clk) begin\n        sync_count <= 2'b01;\n        locked <= 1'b0;\n\t    enable_synced <= 1'b0;\n        \n        overflow_reg <= 1'b0;\n        overflow_sticky <= 1'b0;\n        vid_locked_reg <= 1'b0;\n        \n        h_sync_reg <= 1'b0;\n        v_sync_reg <= 1'b0;\n        ap_reg <= 1'b0;\n        \n        f_reg <= 1'b0;\n        field_prediction <= 1'b0;\n    end else begin\n        if(~vid_locked | lost_vid_locked | overflowed) begin\n            sync_count <= 2'b01;\n            locked <= 1'b0;\n            enable_synced <= 1'b0;\n        end else begin\n            sync_count <= sync_count_next;\n            locked <= locked_next;\n            enable_synced <= (frame_synch) ? enable_sync1 & locked_next : enable_synced;\n        end\n        \n        h_sync_reg <= h_sync;\n        v_sync_reg <= v_sync;\n        ap_reg <= ap;\n        \n        overflow_reg <= overflow_nxt;\n        overflow_sticky <= (overflow_nxt | overflow_sticky) & ~clear_overflow_sticky_sync1;\n        vid_locked_reg <= vid_locked;\n        \n        f_reg <= f;\n        field_prediction <= field_prediction_nxt;\n    end\nend\n\nassign field_prediction_nxt = (~interlaced | end_of_vsync) ? f_reg : (start_of_vsync) ? ~f_reg : field_prediction;\n    \nassign overflow = overflow_sticky; \n                                   \nassign overflow_nxt = (wrreq | overflow_reg) & full;\nassign lost_vid_locked = (~vid_locked & vid_locked_reg);\nassign overflowed = (~full & overflow_reg);\n\nassign wrreq = wrreq_pre_enable & enable_synced;\nassign wrreq_pre_swap = wrreq & ~full;\nassign start_of_ap = ap & ~ap_reg;\nassign end_of_vsync = ~v_sync & v_sync_reg;\nassign start_of_vsync = v_sync & ~v_sync_reg;\nassign start_of_hsync = h_sync & ~h_sync_reg;\nassign early_eop = valid_reg & (lost_vid_locked | overflowed);\nassign eop =  last_sample | early_eop;\nassign packet = last_sample | early_eop;\nassign sync_count_next = (start_of_hsync) ? sync_count - 2'b01 : sync_count;\nassign locked_next = ~|sync_count_next | locked;\n\ngenerate begin : sync_to_generate\n    if(SYNC_TO == 0) begin\n        assign frame_synch = end_of_vsync & ~f;\n    end else if(SYNC_TO == 1) begin\n        assign frame_synch = end_of_vsync & f;\n    end else begin\n        assign frame_synch = end_of_vsync;\n    end\nend endgenerate\n\n\nalt_vipcti131_Vid2IS_resolution_detection resolution_detection(\n    .rst(rst_vid_clk),\n    .clk(vid_clk_int),\n    \n    \n    .count_cycle(vid_enable_int),\n    .ap(ap),\n    .hd_sdn(vid_hd_sdn_input),\n    .start_new_line(start_of_hsync),\n    .start_new_field(start_of_vsync),\n    .end_of_vsync(end_of_vsync),\n    .f(f),\n    .vid_locked(vid_locked),\n    \n    \n    .update(update),\n    .interlaced(interlaced),\n    .active_sample_count(active_sample_count),\n    .active_line_count_f0(active_line_count_f0),\n    .active_line_count_f1(active_line_count_f1),\n    .total_sample_count(total_sample_count),\n    .total_line_count_f0(total_line_count_f0),\n    .total_line_count_f1(total_line_count_f1),\n    .total_line_count(total_line_count),\n    .stable(stable),\n    .resolution_valid(resolution_valid),\n    .resolution_change(resolution_change));\n    \ndefparam resolution_detection.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         resolution_detection.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n         resolution_detection.H_ACTIVE_PIXELS = H_ACTIVE_PIXELS_F0,\n         resolution_detection.V_ACTIVE_LINES_F0 = V_ACTIVE_LINES_F0,\n         resolution_detection.V_ACTIVE_LINES_F1 = V_ACTIVE_LINES_F1,\n         resolution_detection.INTERLACED = INTERLACED;\n\n\ngenerate begin : sync_generation_generate\n    if(GENERATE_SYNC > 0) begin\n        alt_vipcti131_common_sync_generation sync_generation(\n            .rst(rst_vid_clk),\n            .clk(vid_clk_int),\n            \n            .clear_enable(1'b0),\n            .enable_count(vid_enable_int),\n            .hd_sdn(vid_hd_sdn_input),\n            .start_of_vsync(start_of_vsync),\n            .field_prediction(field_prediction_nxt),\n            .interlaced(interlaced),\n            .total_sample_count(total_sample_count[14:1]),\n            .total_sample_count_valid(total_sample_count[0]),\n            .total_line_count(total_line_count[13:1]),\n            .total_line_count_valid(total_line_count[0]),\n            .stable(stable),\n            \n            .divider_value(refclk_divider_value_sync1),\n            .sof_sample(sof_sample_sync1),\n            .sof_line(sof_line_sync1),\n            .sof_subsample(sof_subsample_sync1),\n            \n            .output_enable(genlock_enable_sync1),\n            .sof(sof),\n            .sof_locked(sof_locked),\n            .div(refclk_div));\n\n            defparam sync_generation.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n                     sync_generation.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES,\n                     sync_generation.TOTALS_MINUS_ONE = 0;\n    end else begin\n        assign sof = 1'b0;\n        assign sof_locked = 1'b0;\n    end\nend endgenerate\n\n\n\ngenerate begin : avalon_st_output\n    if(GENERATE_SYNC < 2) begin\n        wire wrreq_post_swap;\n        wire [DATA_WIDTH-1:0] data_post_swap;\n        wire packet_post_swap;\n        \n        \n        if(CONVERT_SEQ_TO_PAR) begin\n            alt_vipcti131_Vid2IS_write_buffer #(\n                    .DATA_WIDTH(DATA_WIDTH),\n                    .NUMBER_OF_COLOUR_PLANES(NUMBER_OF_COLOUR_PLANES),\n                    .BPS(BPS))\n                write_buffer(\n                    .rst(rst_vid_clk),\n                    .clk(vid_clk_int),\n                    \n                    .convert(convert),\n                    .hd_sdn(vid_hd_sdn_input),\n                    .early_eop(early_eop),\n                    \n                    .wrreq_in(wrreq_pre_swap),\n                    .data_in(data),\n                    .packet_in(packet),\n                    \n                    .wrreq_out(wrreq_post_swap),\n                    .data_out(data_post_swap),\n                    .packet_out(packet_post_swap));\n        end else begin\n            assign data_post_swap = data;\n            assign wrreq_post_swap = wrreq_pre_swap;\n            assign packet_post_swap = packet;\n        end\n        \n        wire [FIFO_WIDTH-1:0] q;\n        wire empty;\n        \n        alt_vipcti131_common_fifo #(\n                .DATA_WIDTH(FIFO_WIDTH),\n                .CLOCKS_ARE_SAME(CLOCKS_ARE_SAME),\n                .FIFO_DEPTH(FIFO_DEPTH_INT))\n            input_fifo(\n                .wrclk(vid_clk_int),\n                .rdreq(rdreq),\n                .aclr(rst_vid_clk),\n                .rdclk(is_clk),\n                .wrreq(wrreq_post_swap),\n                .data({data_post_swap, packet_post_swap}),\n                .rdusedw(usedw),\n                .rdempty(empty),\n                .wrfull(full),\n                .q(q));\n         \n        wire enable_resync1;\n        wire is_field_prediction;\n        \n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME) field_prediction_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(field_prediction),\n            .data_out(is_field_prediction));\n\n        alt_vipcti131_common_sync #(CLOCKS_ARE_SAME) enable_resync_sync(\n            .rst(rst),\n            .sync_clock(is_clk),\n            .data_in(enable_synced),\n            .data_out(enable_resync1));\n         \n        \n        \n        \n        alt_vipcti131_Vid2IS_av_st_output #(\n                .FIFO_WIDTH(FIFO_WIDTH),\n                .DATA_WIDTH(DATA_WIDTH),\n                .NUMBER_OF_COLOUR_PLANES_IN_PARALLEL(NUMBER_OF_COLOUR_PLANES_IN_PARALLEL),\n                .BPS(BPS))\n            av_st_output(\n                .rst(rst),\n                \n                .enable(enable_resync1),\n                .q(q),\n                .rdreq(rdreq),\n                .empty(empty),\n                .is_interlaced(is_interlaced),\n                .is_sync_to(2'b10),\n                .is_field_prediction(is_field_prediction),\n                .is_active_sample_count(is_active_sample_count),\n                .is_active_line_count_f0(is_active_line_count_f0),\n                .is_active_line_count_f1(is_active_line_count_f1),\n                \n                .is_clk(is_clk),\n                .is_ready(is_ready),\n                .is_valid(is_valid),\n                .is_data(is_data),\n                .is_sop(is_sop),\n                .is_eop(is_eop),\n                \n                .is_output_enable(is_output_enable));\n    end else begin\n        assign is_valid = 1'b0;\n        assign is_sop = 1'b0;\n        assign is_eop = 1'b0;\n        assign is_data = {DATA_WIDTH{1'b0}};\n    end\nend endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: alt_vipcti131_Vid2IS. Module specification: The alt_vipcti131_Vid2IS module is designed to convert video data from a format with embedded synchronization signals to a format suitable for components requiring explicit control signals like start of packet (SOP) and end of packet (EOP). It accepts input video data (vid_data) along with various synchronization and control signals (vid_clk, vid_de, vid_datavalid, vid_locked, vid_f, vid_v_sync, vid_h_sync, vid_hd_sdn, vid_std) and produces output data (is_data) with associated control signals (is_valid, is_sop, is_eop). The module uses internal signals for synchronization (sync_count, locked), data processing (wrreq, data, full), and status tracking (overflow_reg, overflow_sticky"
                }
            ]
        }
    ]
}