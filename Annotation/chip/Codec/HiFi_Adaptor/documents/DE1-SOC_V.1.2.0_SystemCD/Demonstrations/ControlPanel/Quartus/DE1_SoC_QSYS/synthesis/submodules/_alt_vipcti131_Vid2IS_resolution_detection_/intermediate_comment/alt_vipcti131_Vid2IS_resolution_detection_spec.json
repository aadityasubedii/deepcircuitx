{
    "spec": "Module name: `alt_vipcti131_Vid2IS_resolution_detection`.\nModule specification: The `alt_vipcti131_Vid2IS_resolution_detection` module detects video resolution for potentially interlaced video streams by analyzing the count of active and total samples and lines across fields. It operates on input signals such as a reset (`rst`), a clock signal (`clk`), counting enable (`count_cycle`), and several others related to video stream processing like active picture detection (`ap`), horizontal drive synchronization (`hd_sdn`), along with signals for starting new lines or fields, and video lock indication (`vid_locked`). Outputs from the module include flags indicating update occurrences, interlaced video detection, active and total sample and line counts for differing fields, and other status indicators including stability and resolution validity or changes. Internally, the module integrates a sub-module for sample counting (`alt_vipcti131_common_sample_counter`) with assigned parameters handling different configurations like color planes. It manages numerous intermediate signals such as counters for samples and lines, flags for active video processing, field identification, and counters resets, alongside logic to determine resolution stability and validity. Notable sections in the code handle initialization and synchronous state updates based on video locking and line or field transitions, ensuring accurate resolution counting and change detection. This forms a robust system for real-time monitoring and analytics of video resolution characteristics suited to various signal input conditions, iteratively adjusting to match the active video feed.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: `alt_vipcti131_Vid2IS_resolution_detection`.\n\nExplanation: This module seems to be responsible for detecting the resolution of a video input stream in terms of active sample count and active line count for interlaced video frames. It identifies and provides flags for resolution changes, the stability of the detected resolution, and whether the video signal is interlaced. The module processes incoming synchronization signals and video active periods, counts the number of samples and lines, and determines if there's been a change in the video resolution, specifically catering to scenarios where the video might have alternating lines in the case of interlaced signals (field 0 and field 1). The module generates outputs that include current active sample and line counts, total sample and line counts, and control signals like `update`, `interlaced`, `stable`, `resolution_valid`, and `resolution_change`. It uses parameters to handle different configurations relating to color planes and expected active pixels and lines per field, as well as a sub-module (`alt_vipcti131_common_sample_counter`) for counting samples based on the configuration defined by `defparam` directives. The internal logic ensures that various edge cases, like loss of video lock or starting new fields or lines, are handled appropriately to maintain an accurate detection of the video resolution."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n- `rst`: Reset signal.\n- `clk`: Clock signal.\n- `count_cycle`: Enable signal for counting cycles.\n- `ap`: Active picture signal indicating active video data.\n- `hd_sdn`: Horizontal drive signal (usually sync).\n- `start_new_line`: Signal to indicate the start of a new line.\n- `start_new_field`: Signal to indicate the start of a new field in interlaced video.\n- `end_of_vsync`: Signal to indicate the end of vertical sync period.\n- `f`: Field flag to differentiate between two fields in interlaced video.\n- `vid_locked`: Signal that indicates stable video input.\n\nExplanation:\n- `rst`: Used to reset the internal state of the module.\n- `clk`: Used to drive the module's synchronous operations.\n- `count_cycle`: Activates the sample counter within a cycle.\n- `ap`: This signal helps identify active video data portions for processing.\n- `hd_sdn`: Typically used for synchronization; in this context, it might assist with sample counting.\n- `start_new_line`: Used in resetting and updating line counters at the start of each new line.\n- `start_new_field`: Used for defining the boundaries and processing of video fields in interlaced content.\n- `end_of_vsync`: Marks the transition period at the end of vertical sync pulses, used for field logic enforcement.\n- `f`: Differentiates field 0 and field 1 in interlaced video modes.\n- `vid_locked`: Ensures only stable video signals are processed for proper resolution detection.\n\nOutput ports: \n- `update`: General flag for update operations.\n- `interlaced`: Indicates if the video is interlaced.\n- `active_sample_count`: The count of active samples per line.\n- `active_line_count_f0`: Active line count for field 0.\n- `active_line_count_f1`: Active line count for field 1.\n- `total_sample_count`: Total sample count including inactive regions.\n- `total_line_count_f0`: Total line count for field 0.\n- `total_line_count_f1`: Total line count for field 1.\n- `total_line_count`: Total line count for both fields combined.\n- `stable`: Indicates if detected video parameters are stable.\n- `resolution_valid`: Indicates if the detected resolution is considered valid.\n- `resolution_change`: Flag to indicate a change in resolution detection.\n\nExplanation:\n- `update`: Signal to indicate that status or internal data has been updated.\n- `interlaced`: Shows whether the detected resolution works in an interlaced manner, affecting how lines are counted.\n- `active_sample_count`: Provides the count of active video samples which correlates with the horizontal resolution.\n- `active_line_count_f0` & `active_line_count_f1`: Count active lines in each respective field, important for vertical resolution in interlaced modes.\n- `total_sample_count`: Reflects the total samples per line, accommodating considerations beyond just active video regions.\n- `total_line_count_f0` & `total_line_count_f1`: Line counts including non-picture lines for each field.\n- `total_line_count`: Summation of total lines, useful for overall vertical resolution accounting in interlaced formats.\n- `stable`: Serves as an indication of stable resolution detection over time without fluctuations.\n- `resolution_valid`: Verifies if currently detected resolution parameters meet expected validity criteria.\n- `resolution_change`: Alerts to any transition or alteration in video resolution as detected by the module."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal Signals:\n- `count_sample`\n- `ap_plus_1`\n- `active_line`\n- `end_of_active_line`\n- `current_field`\n- `prev_field`\n- `start_new_field_sticky`\n- `reset_line_count`\n- `reset_line_count_nxt`\n- `stable_next`\n- `stable_reg`\n- `first_start_of_line`\n- `first_start_new_field`\n- `lines_next`\n- `lines`\n- `next_active_sample_count`\n- `next_active_line_count`\n- `next_total_sample_count`\n- `next_total_line_count`\n- `active_sample_count_nxt`\n- `active_line_count_f0_nxt`\n- `active_line_count_f1_nxt`\n- `total_sample_count_nxt`\n- `total_line_count_f0_nxt`\n- `total_line_count_f1_nxt`\n- `reset_sample`\n- `reset_f0`\n- `reset_f1`\n- `reset_total_sample`\n- `reset_total_f0`\n- `reset_total_f1`\n- `update_active_line_f1`\n- `update_active_sample`\n- `update_active_line_f0`\n- `update_total_sample`\n- `update_total_line_f0`\n- `update_total_line_f1`\n- `field_update`\n- `stable_update`\n- `resolution_valid_update`\n- `field_0`\n- `field_1`\n- `update_sample`\n- `interlaced_valid`\n- `resolution_valid_nxt`\n- `resolution_valid_reg`\n- `second_active_line`\n\nExplanation:\n- `count_sample`: Signal to indicate when to count samples; used as input to the common sample counter instance.\n- `ap_plus_1`: Signal indicating an active pixel and sample count increment condition.\n- `active_line`: Signal to keep track of whether the current line being processed is active video data.\n- `end_of_active_line`: Signal to indicate the end of an active line, triggering counts and updates.\n- `current_field`: Register to hold the state of the current field being processed in interlaced mode.\n- `prev_field`: Register to hold the state of the previous field information, crucial for interlaced mode detection.\n- `start_new_field_sticky`: Sticky bit to indicate that a new field has started until the next line begins.\n- `reset_line_count`: Signal to reset line count registers.\n- `reset_line_count_nxt`: Next state logic for line count reset signal.\n- `stable_next`: Determines the next state value of the `stable` signal.\n- `stable_reg`: Helps in debouncing the stability detection.\n- `first_start_of_line`: A flag to mark the occurrence of the first start-of-line condition for stable edge detection.\n- `first_start_new_field`: A flag to mark the first occurrence of new field detection, used for update signal generation.\n- `lines_next`: Next value of the `lines` three-bit register that holds the state of line updates.\n- `lines`: A register to track the last three updates related to line status.\n- `next_active_sample_count`: Signal that holds the value for the next active sample count state.\n- `next_active_line_count`: Signal that holds the value for the next active line count state.\n- `next_total_sample_count`: Holds the value for the next total sample count state.\n- `next_total_line_count`: Holds the value for the next total line count state.\n- `active_sample_count_nxt`: Indicates the next state for the active sample count register.\n- `active_line_count_f0_nxt`: Indicates the next state for the active line count in field 0 register.\n- `active_line_count_f1_nxt`: Indicates the next state for the active line count in field 1 register.\n- `total_sample_count_nxt`: Indicates the next state for the total sample count register.\n- `total_line_count_f0_nxt`: Indicates the next state for the total line count in field 0 register.\n- `total_line_count_f1_nxt`: Indicates the next state for the total line count in field 1 register.\n- `reset_sample`: Determines whether to reset the active sample counter.\n- `reset_f0`: Determines whether to reset field 0's active line counter.\n- `reset_f1`: Determines whether to reset field 1's active line counter.\n- `reset_total_sample`: Determines whether to reset the total sample counter.\n- `reset_total_f0`: Determines whether to reset the total line count for field 0.\n- `reset_total_f1`: Determines whether to reset the total line count for field 1.\n- `update_active_line_f1`: Signal that triggers an update to the active line count for field 1.\n- `update_active_sample`: Signal that triggers an update to the active sample count.\n- `update_active_line_f0`: Signal that triggers an update to the active line count for field 0.\n- `update_total_sample`: Signal that triggers an update to the total sample count.\n- `update_total_line_f0`: Signal that triggers an update to the total line count for field 0.\n- `update_total_line_f1`: Signal that triggers an update to the total line count for field 1.\n- `field_update`: Signal determining whether any field-related counts have been updated.\n- `stable_update`: Signal for determining if the `stable` status has changed.\n- `resolution_valid_update`: Flag that signals a change in resolution validity status.\n- `field_0`: Determines the active field when resetting line count.\n- `field_1`: Determines the active field when resetting line count.\n- `update_sample`: Computes the condition for updating sample counters.\n- `interlaced_valid`: Determines whether the interlaced signal value is valid, based on the field states.\n- `resolution_valid_nxt`: Next state value for the resolution valid flag.\n- `resolution_valid_reg`: Helps in determining resolution validity change over time.\n- `second_active_line`: A flag that keeps track whether a second active line has been encountered before updating total counts."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\nmodule alt_vipcti131_Vid2IS_resolution_detection(\n    input wire rst,\n    input wire clk,\n    \n    input wire count_cycle,\n    input wire ap,\n    input wire hd_sdn,\n    input wire start_new_line,\n    input wire start_new_field,\n    input wire end_of_vsync,\n    input wire f,\n    input wire vid_locked,\n    \n    output reg update,\n    output reg interlaced,\n    output reg [14:0] active_sample_count,\n    output reg [13:0] active_line_count_f0,\n    output reg [13:0] active_line_count_f1,\n    output reg [14:0] total_sample_count,\n    output reg [13:0] total_line_count_f0,\n    output reg [13:0] total_line_count_f1,\n    output reg [13:0] total_line_count,\n    output reg stable,\n    output reg resolution_valid,\n    output reg resolution_change);\n    \nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\nparameter H_ACTIVE_PIXELS = 0;\nparameter V_ACTIVE_LINES_F0 = 0;\nparameter V_ACTIVE_LINES_F1 = 0;\nparameter INTERLACED = 0;\n\nwire count_sample;\nwire ap_plus_1;\nreg active_line;\nwire end_of_active_line;\n\nalt_vipcti131_common_sample_counter sample_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(1'b0),\n    .hd_sdn(hd_sdn),\n    .count_cycle(count_cycle),\n    .count_sample(count_sample));\n    \ndefparam sample_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         sample_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         sample_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES;\n\nassign ap_plus_1 = count_sample & ap;\nassign end_of_active_line = start_new_line & active_line;\n\nreg [1:0] current_field;\nreg [1:0] prev_field;\nreg start_new_field_sticky;\nreg reset_line_count;\nwire reset_line_count_nxt;\nwire stable_next;\nreg stable_reg;\nreg first_start_of_line;\nreg first_start_new_field;\nwire [2:0] lines_next;\nreg [2:0] lines;\nreg [13:0] next_active_sample_count;    \nreg [12:0] next_active_line_count;      \nreg [13:0] next_total_sample_count;\nreg [12:0] next_total_line_count;\nwire [14:0] active_sample_count_nxt;\nwire [13:0] active_line_count_f0_nxt;\nwire [13:0] active_line_count_f1_nxt;\nwire [14:0] total_sample_count_nxt;\nwire [13:0] total_line_count_f0_nxt;\nwire [13:0] total_line_count_f1_nxt;\nwire reset_sample;\nwire reset_f0;\nwire reset_f1;\nwire reset_total_sample;\nwire reset_total_f0;\nwire reset_total_f1;\nwire update_active_line_f1;\nwire update_active_sample;\nwire update_active_line_f0;\nwire update_total_sample;\nwire update_total_line_f0;\nwire update_total_line_f1;\nwire field_update;\nwire stable_update;\nwire resolution_valid_update;\nwire field_0;\nwire field_1;\nwire update_sample;\nreg interlaced_valid;\nwire resolution_valid_nxt;\nreg resolution_valid_reg;\nreg second_active_line;\n\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        current_field <= {INTERLACED, 1'b0};\n        prev_field <= 2'b00;\n        interlaced <= 1'b0;\n        interlaced_valid <= 1'b0;\n        start_new_field_sticky <= 1'b0;\n        reset_line_count <= 1'b0;\n        \n        lines <= 3'b000;\n        stable <= 1'b0;\n        stable_reg <= 1'b0;\n        \n        active_line <= 1'b0;\n        next_active_sample_count <= 14'd0;\n        next_active_line_count <= 13'd0;\n        next_total_sample_count <= 14'd0;\n        next_total_line_count <= 13'd0;\n        active_sample_count <= {H_ACTIVE_PIXELS, 1'b1};\n        active_line_count_f0 <= {V_ACTIVE_LINES_F0, 1'b1};\n        active_line_count_f1 <= (INTERLACED) ? {V_ACTIVE_LINES_F1, 1'b1} : 17'd0;\n        total_sample_count <= 15'd0;\n        total_line_count_f0 <= 14'd0;\n        total_line_count_f1 <= 14'd0;\n        total_line_count <= 14'd0;\n        \n        update <= 1'b0;\n        first_start_new_field <= 1'b0;\n        first_start_of_line <= 1'b0;\n        second_active_line <= 1'b0;\n        \n        resolution_valid <= 1'b0;\n        resolution_valid_reg <= 1'b0;\n        resolution_change <= 1'b0;\n    end else begin\n        \n        \n        current_field <= (~vid_locked) ? {current_field[1], 1'b0} : (end_of_vsync) ? {f, 1'b1} : current_field;\n        prev_field <= (~vid_locked) ? {prev_field[1], 1'b0} : (end_of_vsync) ? current_field : prev_field;\n        interlaced <= current_field[1] | prev_field[1];\n        interlaced_valid <= current_field[0] & prev_field[0];\n        start_new_field_sticky <= (start_new_field | start_new_field_sticky) & ~start_new_line;\n        reset_line_count <= reset_line_count_nxt;\n        \n        \n        lines <= lines_next;\n        stable <= stable_next;\n        stable_reg <= stable;\n        \n        active_line <= (ap | active_line) & ~start_new_line;\n        next_active_sample_count <= (end_of_active_line) ? 14'd0 : (ap_plus_1) ? next_active_sample_count + 14'd1 : next_active_sample_count;\n        next_active_line_count <= (reset_line_count) ? 13'd0 : (end_of_active_line) ? next_active_line_count + 13'd1 : next_active_line_count;\n        next_total_sample_count <= (start_new_line) ? {13'd0, count_sample} : (count_sample) ? next_total_sample_count + 14'd1 : next_total_sample_count;\n        next_total_line_count <= (reset_line_count) ? 13'd0 : (start_new_line) ? next_total_line_count + 13'd1 : next_total_line_count;\n        \n        \n        active_sample_count <= active_sample_count_nxt;\n        active_line_count_f0 <= active_line_count_f0_nxt;\n        active_line_count_f1 <= active_line_count_f1_nxt;\n        total_sample_count <= total_sample_count_nxt;\n        total_line_count_f0 <= total_line_count_f0_nxt;\n        total_line_count_f1 <= total_line_count_f1_nxt;\n        total_line_count[13:1] <= (~interlaced) ? total_line_count_f0_nxt[13:1] : total_line_count_f0_nxt[13:1] + total_line_count_f1_nxt[13:1];\n        total_line_count[0] <= total_line_count_f0_nxt[0] & (~interlaced | total_line_count_f1_nxt[0]);\n        \n        update <= update ^ (field_update | stable_update | resolution_valid_update);\n        first_start_of_line <= (start_new_line | first_start_of_line) & vid_locked;\n        first_start_new_field <= (reset_line_count | first_start_new_field) & vid_locked;\n        second_active_line <= (end_of_active_line | (second_active_line & ~start_new_line)) & vid_locked;  \n                                                                                                           \n        \n        resolution_valid <= resolution_valid_nxt;\n        resolution_valid_reg <= resolution_valid;\n        resolution_change <= resolution_change ^ ((resolution_valid & resolution_valid_nxt & field_update) | (resolution_valid & ~resolution_valid_reg));\n    end\nend\n\nassign reset_line_count_nxt = start_new_line & (start_new_field | start_new_field_sticky);\n\nassign lines_next = (~vid_locked) ? 3'b000 : (start_new_line) ? {lines[1:0], ~update_sample} : lines;\nassign stable_next = vid_locked & first_start_of_line & ((lines_next[0] & lines_next[1]) | (lines_next[0] & lines_next[2]) | (lines_next[1] & lines_next[2]));\n\nassign resolution_valid_nxt = active_sample_count_nxt[0] & total_sample_count_nxt[0] &\n                              active_line_count_f0_nxt[0] & total_line_count_f0_nxt[0] &\n                              ((active_line_count_f1_nxt[0] & total_line_count_f1_nxt[0]) | ~interlaced) &\n                              interlaced_valid;\n\nassign active_sample_count_nxt = (update_active_sample) ? {next_active_sample_count, 1'b1} : active_sample_count;\nassign active_line_count_f0_nxt = (reset_f0) ? {active_line_count_f0[13:1], 1'b0} : (update_active_line_f0) ? {next_active_line_count, 1'b1} : active_line_count_f0;\nassign active_line_count_f1_nxt = (reset_f1) ? {active_line_count_f1[13:1], 1'b0} : (update_active_line_f1) ? {next_active_line_count, 1'b1} : active_line_count_f1;\nassign total_sample_count_nxt = (update_total_sample) ? {next_total_sample_count, 1'b1} : total_sample_count;\nassign total_line_count_f0_nxt = (reset_total_f0) ? {total_line_count_f0[13:1], 1'b0} : (update_total_line_f0) ? {next_total_line_count, 1'b1} : total_line_count_f0;\nassign total_line_count_f1_nxt = (reset_total_f1) ? {total_line_count_f1[13:1], 1'b0} : (update_total_line_f1) ? {next_total_line_count, 1'b1} : total_line_count_f1;\n\nassign field_update = (update_active_sample | update_active_line_f0 | update_active_line_f1 |\n                       update_total_sample | update_total_line_f0 | update_total_line_f1);\nassign stable_update = stable_next ^ stable;\nassign resolution_valid_update = resolution_valid_nxt ^ resolution_valid;\n\n\nassign reset_sample = (update_active_sample & active_sample_count[0]);\nassign reset_f0 = reset_sample | (update_active_line_f1 & active_line_count_f1[0]);\nassign reset_f1 = reset_sample | (update_active_line_f0 & active_line_count_f0[0]);\n\nassign reset_total_sample = (update_total_sample & total_sample_count[0]);\nassign reset_total_f0 = reset_total_sample | (update_total_line_f1 & total_line_count_f1[0]);\nassign reset_total_f1 = reset_total_sample | (update_total_line_f0 & total_line_count_f0[0]);\n\nassign field_0 = reset_line_count & ~f;\nassign field_1 = reset_line_count & f;\n\nassign update_active_sample = (end_of_active_line) && (next_active_sample_count != active_sample_count[14:1] || !active_sample_count[0]) && first_start_of_line;\nassign update_active_line_f0 = field_0 && (next_active_line_count != active_line_count_f0[13:1] || !active_line_count_f0[0]) && first_start_new_field;\nassign update_active_line_f1 = field_1 && (next_active_line_count != active_line_count_f1[13:1] || !active_line_count_f1[0]) && first_start_new_field;\n\nassign update_total_sample = (end_of_active_line && second_active_line) && (next_total_sample_count != total_sample_count[14:1] || !total_sample_count[0]) && first_start_of_line;\nassign update_total_line_f0 = field_0 && (next_total_line_count != total_line_count_f0[13:1] || !total_line_count_f0[0]) && first_start_new_field;\nassign update_total_line_f1 = field_1 && (next_total_line_count != total_line_count_f1[13:1] || !total_line_count_f1[0]) && first_start_new_field;\n\nassign update_sample = update_active_sample & update_total_sample;\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: `alt_vipcti131_Vid2IS_resolution_detection`.\nModule specification: The `alt_vipcti131_Vid2IS_resolution_detection` module detects video resolution for potentially interlaced video streams by analyzing the count of active and total samples and lines across fields. It operates on input signals such as a reset (`rst`), a clock signal (`clk`), counting enable (`count_cycle`), and several others related to video stream processing like active picture detection (`ap`), horizontal drive synchronization (`hd_sdn`), along with signals for starting new lines or fields, and video lock indication (`vid_locked`). Outputs from the module include flags indicating update occurrences, interlaced video detection, active and total sample and line counts for differing fields, and other status indicators including stability and resolution validity or changes. Internally, the module integrates a sub-module for sample counting (`alt_vipcti131_common_sample_counter`) with assigned parameters handling different configurations like color planes. It manages numerous intermediate signals such as counters for samples and lines, flags for active video processing, field identification, and counters resets, alongside logic to determine resolution stability and validity. Notable sections in the code handle initialization and synchronous state updates based on video locking and line or field transitions, ensuring accurate resolution counting and change detection. This forms a robust system for real-time monitoring and analytics of video resolution characteristics suited to various signal input conditions, iteratively adjusting to match the active video feed."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: `alt_vipcti131_Vid2IS_resolution_detection`.\n\nExplanation: This module seems to be responsible for detecting the resolution of a video input stream in terms of active sample count and active line count for interlaced video frames. It identifies and provides flags for resolution changes, the stability of the detected resolution, and whether the video signal is interlaced. The module processes incoming synchronization signals and video active periods, counts the number of samples and lines, and determines if there's been a change in the video resolution, specifically catering to scenarios where the video might have alternating lines in the case of interlaced signals (field 0 and field 1). The module generates outputs that include current active sample and line counts, total sample and line counts, and control signals like `update`, `interlaced`, `stable`, `resolution_valid`, and `resolution_change`. It uses parameters to handle different configurations relating to color planes and expected active pixels and lines per field, as well as a sub-module (`alt_vipcti131_common_sample_counter`) for counting samples based on the configuration defined by `defparam` directives. The internal logic ensures that various edge cases, like loss of video lock or starting new fields or lines, are handled appropriately to maintain an accurate detection of the video resolution."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n- `rst`: Reset signal.\n- `clk`: Clock signal.\n- `count_cycle`: Enable signal for counting cycles.\n- `ap`: Active picture signal indicating active video data.\n- `hd_sdn`: Horizontal drive signal (usually sync).\n- `start_new_line`: Signal to indicate the start of a new line.\n- `start_new_field`: Signal to indicate the start of a new field in interlaced video.\n- `end_of_vsync`: Signal to indicate the end of vertical sync period.\n- `f`: Field flag to differentiate between two fields in interlaced video.\n- `vid_locked`: Signal that indicates stable video input.\n\nExplanation:\n- `rst`: Used to reset the internal state of the module.\n- `clk`: Used to drive the module's synchronous operations.\n- `count_cycle`: Activates the sample counter within a cycle.\n- `ap`: This signal helps identify active video data portions for processing.\n- `hd_sdn`: Typically used for synchronization; in this context, it might assist with sample counting.\n- `start_new_line`: Used in resetting and updating line counters at the start of each new line.\n- `start_new_field`: Used for defining the boundaries and processing of video fields in interlaced content.\n- `end_of_vsync`: Marks the transition period at the end of vertical sync pulses, used for field logic enforcement.\n- `f`: Differentiates field 0 and field 1 in interlaced video modes.\n- `vid_locked`: Ensures only stable video signals are processed for proper resolution detection.\n\nOutput ports: \n- `update`: General flag for update operations.\n- `interlaced`: Indicates if the video is interlaced.\n- `active_sample_count`: The count of active samples per line.\n- `active_line_count_f0`: Active line count for field 0.\n- `active_line_count_f1`: Active line count for field 1.\n- `total_sample_count`: Total sample count including inactive regions.\n- `total_line_count_f0`: Total line count for field 0.\n- `total_line_count_f1`: Total line count for field 1.\n- `total_line_count`: Total line count for both fields combined.\n- `stable`: Indicates if detected video parameters are stable.\n- `resolution_valid`: Indicates if the detected resolution is considered valid.\n- `resolution_change`: Flag to indicate a change in resolution detection.\n\nExplanation:\n- `update`: Signal to indicate that status or internal data has been updated.\n- `interlaced`: Shows whether the detected resolution works in an interlaced manner, affecting how lines are counted.\n- `active_sample_count`: Provides the count of active video samples which correlates with the horizontal resolution.\n- `active_line_count_f0` & `active_line_count_f1`: Count active lines in each respective field, important for vertical resolution in interlaced modes.\n- `total_sample_count`: Reflects the total samples per line, accommodating considerations beyond just active video regions.\n- `total_line_count_f0` & `total_line_count_f1`: Line counts including non-picture lines for each field.\n- `total_line_count`: Summation of total lines, useful for overall vertical resolution accounting in interlaced formats.\n- `stable`: Serves as an indication of stable resolution detection over time without fluctuations.\n- `resolution_valid`: Verifies if currently detected resolution parameters meet expected validity criteria.\n- `resolution_change`: Alerts to any transition or alteration in video resolution as detected by the module."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal Signals:\n- `count_sample`\n- `ap_plus_1`\n- `active_line`\n- `end_of_active_line`\n- `current_field`\n- `prev_field`\n- `start_new_field_sticky`\n- `reset_line_count`\n- `reset_line_count_nxt`\n- `stable_next`\n- `stable_reg`\n- `first_start_of_line`\n- `first_start_new_field`\n- `lines_next`\n- `lines`\n- `next_active_sample_count`\n- `next_active_line_count`\n- `next_total_sample_count`\n- `next_total_line_count`\n- `active_sample_count_nxt`\n- `active_line_count_f0_nxt`\n- `active_line_count_f1_nxt`\n- `total_sample_count_nxt`\n- `total_line_count_f0_nxt`\n- `total_line_count_f1_nxt`\n- `reset_sample`\n- `reset_f0`\n- `reset_f1`\n- `reset_total_sample`\n- `reset_total_f0`\n- `reset_total_f1`\n- `update_active_line_f1`\n- `update_active_sample`\n- `update_active_line_f0`\n- `update_total_sample`\n- `update_total_line_f0`\n- `update_total_line_f1`\n- `field_update`\n- `stable_update`\n- `resolution_valid_update`\n- `field_0`\n- `field_1`\n- `update_sample`\n- `interlaced_valid`\n- `resolution_valid_nxt`\n- `resolution_valid_reg`\n- `second_active_line`\n\nExplanation:\n- `count_sample`: Signal to indicate when to count samples; used as input to the common sample counter instance.\n- `ap_plus_1`: Signal indicating an active pixel and sample count increment condition.\n- `active_line`: Signal to keep track of whether the current line being processed is active video data.\n- `end_of_active_line`: Signal to indicate the end of an active line, triggering counts and updates.\n- `current_field`: Register to hold the state of the current field being processed in interlaced mode.\n- `prev_field`: Register to hold the state of the previous field information, crucial for interlaced mode detection.\n- `start_new_field_sticky`: Sticky bit to indicate that a new field has started until the next line begins.\n- `reset_line_count`: Signal to reset line count registers.\n- `reset_line_count_nxt`: Next state logic for line count reset signal.\n- `stable_next`: Determines the next state value of the `stable` signal.\n- `stable_reg`: Helps in debouncing the stability detection.\n- `first_start_of_line`: A flag to mark the occurrence of the first start-of-line condition for stable edge detection.\n- `first_start_new_field`: A flag to mark the first occurrence of new field detection, used for update signal generation.\n- `lines_next`: Next value of the `lines` three-bit register that holds the state of line updates.\n- `lines`: A register to track the last three updates related to line status.\n- `next_active_sample_count`: Signal that holds the value for the next active sample count state.\n- `next_active_line_count`: Signal that holds the value for the next active line count state.\n- `next_total_sample_count`: Holds the value for the next total sample count state.\n- `next_total_line_count`: Holds the value for the next total line count state.\n- `active_sample_count_nxt`: Indicates the next state for the active sample count register.\n- `active_line_count_f0_nxt`: Indicates the next state for the active line count in field 0 register.\n- `active_line_count_f1_nxt`: Indicates the next state for the active line count in field 1 register.\n- `total_sample_count_nxt`: Indicates the next state for the total sample count register.\n- `total_line_count_f0_nxt`: Indicates the next state for the total line count in field 0 register.\n- `total_line_count_f1_nxt`: Indicates the next state for the total line count in field 1 register.\n- `reset_sample`: Determines whether to reset the active sample counter.\n- `reset_f0`: Determines whether to reset field 0's active line counter.\n- `reset_f1`: Determines whether to reset field 1's active line counter.\n- `reset_total_sample`: Determines whether to reset the total sample counter.\n- `reset_total_f0`: Determines whether to reset the total line count for field 0.\n- `reset_total_f1`: Determines whether to reset the total line count for field 1.\n- `update_active_line_f1`: Signal that triggers an update to the active line count for field 1.\n- `update_active_sample`: Signal that triggers an update to the active sample count.\n- `update_active_line_f0`: Signal that triggers an update to the active line count for field 0.\n- `update_total_sample`: Signal that triggers an update to the total sample count.\n- `update_total_line_f0`: Signal that triggers an update to the total line count for field 0.\n- `update_total_line_f1`: Signal that triggers an update to the total line count for field 1.\n- `field_update`: Signal determining whether any field-related counts have been updated.\n- `stable_update`: Signal for determining if the `stable` status has changed.\n- `resolution_valid_update`: Flag that signals a change in resolution validity status.\n- `field_0`: Determines the active field when resetting line count.\n- `field_1`: Determines the active field when resetting line count.\n- `update_sample`: Computes the condition for updating sample counters.\n- `interlaced_valid`: Determines whether the interlaced signal value is valid, based on the field states.\n- `resolution_valid_nxt`: Next state value for the resolution valid flag.\n- `resolution_valid_reg`: Helps in determining resolution validity change over time.\n- `second_active_line`: A flag that keeps track whether a second active line has been encountered before updating total counts."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>module alt_vipcti131_Vid2IS_resolution_detection(\n    input wire rst,\n    input wire clk,\n    \n    input wire count_cycle,\n    input wire ap,\n    input wire hd_sdn,\n    input wire start_new_line,\n    input wire start_new_field,\n    input wire end_of_vsync,\n    input wire f,\n    input wire vid_locked,\n    \n    output reg update,\n    output reg interlaced,\n    output reg [14:0] active_sample_count,\n    output reg [13:0] active_line_count_f0,\n    output reg [13:0] active_line_count_f1,\n    output reg [14:0] total_sample_count,\n    output reg [13:0] total_line_count_f0,\n    output reg [13:0] total_line_count_f1,\n    output reg [13:0] total_line_count,\n    output reg stable,\n    output reg resolution_valid,\n    output reg resolution_change);\n    \nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\nparameter H_ACTIVE_PIXELS = 0;\nparameter V_ACTIVE_LINES_F0 = 0;\nparameter V_ACTIVE_LINES_F1 = 0;\nparameter INTERLACED = 0;\n\nwire count_sample;\nwire ap_plus_1;\nreg active_line;\nwire end_of_active_line;\n\nalt_vipcti131_common_sample_counter sample_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(1'b0),\n    .hd_sdn(hd_sdn),\n    .count_cycle(count_cycle),\n    .count_sample(count_sample));\n    \ndefparam sample_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         sample_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         sample_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES;\n\nassign ap_plus_1 = count_sample & ap;\nassign end_of_active_line = start_new_line & active_line;\n\nreg [1:0] current_field;\nreg [1:0] prev_field;\nreg start_new_field_sticky;\nreg reset_line_count;\nwire reset_line_count_nxt;\nwire stable_next;\nreg stable_reg;\nreg first_start_of_line;\nreg first_start_new_field;\nwire [2:0] lines_next;\nreg [2:0] lines;\nreg [13:0] next_active_sample_count;    \nreg [12:0] next_active_line_count;      \nreg [13:0] next_total_sample_count;\nreg [12:0] next_total_line_count;\nwire [14:0] active_sample_count_nxt;\nwire [13:0] active_line_count_f0_nxt;\nwire [13:0] active_line_count_f1_nxt;\nwire [14:0] total_sample_count_nxt;\nwire [13:0] total_line_count_f0_nxt;\nwire [13:0] total_line_count_f1_nxt;\nwire reset_sample;\nwire reset_f0;\nwire reset_f1;\nwire reset_total_sample;\nwire reset_total_f0;\nwire reset_total_f1;\nwire update_active_line_f1;\nwire update_active_sample;\nwire update_active_line_f0;\nwire update_total_sample;\nwire update_total_line_f0;\nwire update_total_line_f1;\nwire field_update;\nwire stable_update;\nwire resolution_valid_update;\nwire field_0;\nwire field_1;\nwire update_sample;\nreg interlaced_valid;\nwire resolution_valid_nxt;\nreg resolution_valid_reg;\nreg second_active_line;\n\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        current_field <= {INTERLACED, 1'b0};\n        prev_field <= 2'b00;\n        interlaced <= 1'b0;\n        interlaced_valid <= 1'b0;\n        start_new_field_sticky <= 1'b0;\n        reset_line_count <= 1'b0;\n        \n        lines <= 3'b000;\n        stable <= 1'b0;\n        stable_reg <= 1'b0;\n        \n        active_line <= 1'b0;\n        next_active_sample_count <= 14'd0;\n        next_active_line_count <= 13'd0;\n        next_total_sample_count <= 14'd0;\n        next_total_line_count <= 13'd0;\n        active_sample_count <= {H_ACTIVE_PIXELS, 1'b1};\n        active_line_count_f0 <= {V_ACTIVE_LINES_F0, 1'b1};\n        active_line_count_f1 <= (INTERLACED) ? {V_ACTIVE_LINES_F1, 1'b1} : 17'd0;\n        total_sample_count <= 15'd0;\n        total_line_count_f0 <= 14'd0;\n        total_line_count_f1 <= 14'd0;\n        total_line_count <= 14'd0;\n        \n        update <= 1'b0;\n        first_start_new_field <= 1'b0;\n        first_start_of_line <= 1'b0;\n        second_active_line <= 1'b0;\n        \n        resolution_valid <= 1'b0;\n        resolution_valid_reg <= 1'b0;\n        resolution_change <= 1'b0;\n    end else begin\n        \n        \n        current_field <= (~vid_locked) ? {current_field[1], 1'b0} : (end_of_vsync) ? {f, 1'b1} : current_field;\n        prev_field <= (~vid_locked) ? {prev_field[1], 1'b0} : (end_of_vsync) ? current_field : prev_field;\n        interlaced <= current_field[1] | prev_field[1];\n        interlaced_valid <= current_field[0] & prev_field[0];\n        start_new_field_sticky <= (start_new_field | start_new_field_sticky) & ~start_new_line;\n        reset_line_count <= reset_line_count_nxt;\n        \n        \n        lines <= lines_next;\n        stable <= stable_next;\n        stable_reg <= stable;\n        \n        active_line <= (ap | active_line) & ~start_new_line;\n        next_active_sample_count <= (end_of_active_line) ? 14'd0 : (ap_plus_1) ? next_active_sample_count + 14'd1 : next_active_sample_count;\n        next_active_line_count <= (reset_line_count) ? 13'd0 : (end_of_active_line) ? next_active_line_count + 13'd1 : next_active_line_count;\n        next_total_sample_count <= (start_new_line) ? {13'd0, count_sample} : (count_sample) ? next_total_sample_count + 14'd1 : next_total_sample_count;\n        next_total_line_count <= (reset_line_count) ? 13'd0 : (start_new_line) ? next_total_line_count + 13'd1 : next_total_line_count;\n        \n        \n        active_sample_count <= active_sample_count_nxt;\n        active_line_count_f0 <= active_line_count_f0_nxt;\n        active_line_count_f1 <= active_line_count_f1_nxt;\n        total_sample_count <= total_sample_count_nxt;\n        total_line_count_f0 <= total_line_count_f0_nxt;\n        total_line_count_f1 <= total_line_count_f1_nxt;\n        total_line_count[13:1] <= (~interlaced) ? total_line_count_f0_nxt[13:1] : total_line_count_f0_nxt[13:1] + total_line_count_f1_nxt[13:1];\n        total_line_count[0] <= total_line_count_f0_nxt[0] & (~interlaced | total_line_count_f1_nxt[0]);\n        \n        update <= update ^ (field_update | stable_update | resolution_valid_update);\n        first_start_of_line <= (start_new_line | first_start_of_line) & vid_locked;\n        first_start_new_field <= (reset_line_count | first_start_new_field) & vid_locked;\n        second_active_line <= (end_of_active_line | (second_active_line & ~start_new_line)) & vid_locked;  \n                                                                                                           \n        \n        resolution_valid <= resolution_valid_nxt;\n        resolution_valid_reg <= resolution_valid;\n        resolution_change <= resolution_change ^ ((resolution_valid & resolution_valid_nxt & field_update) | (resolution_valid & ~resolution_valid_reg));\n    end\nend\n\nassign reset_line_count_nxt = start_new_line & (start_new_field | start_new_field_sticky);\n\nassign lines_next = (~vid_locked) ? 3'b000 : (start_new_line) ? {lines[1:0], ~update_sample} : lines;\nassign stable_next = vid_locked & first_start_of_line & ((lines_next[0] & lines_next[1]) | (lines_next[0] & lines_next[2]) | (lines_next[1] & lines_next[2]));\n\nassign resolution_valid_nxt = active_sample_count_nxt[0] & total_sample_count_nxt[0] &\n                              active_line_count_f0_nxt[0] & total_line_count_f0_nxt[0] &\n                              ((active_line_count_f1_nxt[0] & total_line_count_f1_nxt[0]) | ~interlaced) &\n                              interlaced_valid;\n\nassign active_sample_count_nxt = (update_active_sample) ? {next_active_sample_count, 1'b1} : active_sample_count;\nassign active_line_count_f0_nxt = (reset_f0) ? {active_line_count_f0[13:1], 1'b0} : (update_active_line_f0) ? {next_active_line_count, 1'b1} : active_line_count_f0;\nassign active_line_count_f1_nxt = (reset_f1) ? {active_line_count_f1[13:1], 1'b0} : (update_active_line_f1) ? {next_active_line_count, 1'b1} : active_line_count_f1;\nassign total_sample_count_nxt = (update_total_sample) ? {next_total_sample_count, 1'b1} : total_sample_count;\nassign total_line_count_f0_nxt = (reset_total_f0) ? {total_line_count_f0[13:1], 1'b0} : (update_total_line_f0) ? {next_total_line_count, 1'b1} : total_line_count_f0;\nassign total_line_count_f1_nxt = (reset_total_f1) ? {total_line_count_f1[13:1], 1'b0} : (update_total_line_f1) ? {next_total_line_count, 1'b1} : total_line_count_f1;\n\nassign field_update = (update_active_sample | update_active_line_f0 | update_active_line_f1 |\n                       update_total_sample | update_total_line_f0 | update_total_line_f1);\nassign stable_update = stable_next ^ stable;\nassign resolution_valid_update = resolution_valid_nxt ^ resolution_valid;\n\n\nassign reset_sample = (update_active_sample & active_sample_count[0]);\nassign reset_f0 = reset_sample | (update_active_line_f1 & active_line_count_f1[0]);\nassign reset_f1 = reset_sample | (update_active_line_f0 & active_line_count_f0[0]);\n\nassign reset_total_sample = (update_total_sample & total_sample_count[0]);\nassign reset_total_f0 = reset_total_sample | (update_total_line_f1 & total_line_count_f1[0]);\nassign reset_total_f1 = reset_total_sample | (update_total_line_f0 & total_line_count_f0[0]);\n\nassign field_0 = reset_line_count & ~f;\nassign field_1 = reset_line_count & f;\n\nassign update_active_sample = (end_of_active_line) && (next_active_sample_count != active_sample_count[14:1] || !active_sample_count[0]) && first_start_of_line;\nassign update_active_line_f0 = field_0 && (next_active_line_count != active_line_count_f0[13:1] || !active_line_count_f0[0]) && first_start_new_field;\nassign update_active_line_f1 = field_1 && (next_active_line_count != active_line_count_f1[13:1] || !active_line_count_f1[0]) && first_start_new_field;\n\nassign update_total_sample = (end_of_active_line && second_active_line) && (next_total_sample_count != total_sample_count[14:1] || !total_sample_count[0]) && first_start_of_line;\nassign update_total_line_f0 = field_0 && (next_total_line_count != total_line_count_f0[13:1] || !total_line_count_f0[0]) && first_start_new_field;\nassign update_total_line_f1 = field_1 && (next_total_line_count != total_line_count_f1[13:1] || !total_line_count_f1[0]) && first_start_new_field;\n\nassign update_sample = update_active_sample & update_total_sample;\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: `alt_vipcti131_Vid2IS_resolution_detection`.\nModule specification: The `alt_vipcti131_Vid2IS_resolution_detection` module detects video resolution for potentially interlaced video streams by analyzing the count of active and total samples and lines across fields. It operates on input signals such as a reset (`rst`), a clock signal (`clk`), counting enable (`count_cycle`), and several others related to video stream processing like active picture detection (`ap`), horizontal drive synchronization (`hd_sdn`), along with signals for starting new lines or fields, and video lock indication (`vid_locked`). Outputs from the module include flags indicating update occurrences, interlaced video detection, active and total sample and line counts for differing fields, and other status indicators including stability and resolution validity or changes. Internally, the module integrates a sub-module for sample counting (`alt_vipcti131_common_sample_counter`) with assigned parameters handling different configurations like color planes. It manages numerous intermediate signals such as counters for samples and lines, flags for active video processing, field identification, and counters resets, alongside logic to determine resolution stability and validity. Notable sections in the code handle initialization and synchronous state updates based on video locking and line or field transitions, ensuring accurate resolution counting and change detection. This forms a robust system for real-time monitoring and analytics of video resolution characteristics suited to various signal input conditions, iteratively adjusting to match the active video feed."
                }
            ]
        }
    ]
}