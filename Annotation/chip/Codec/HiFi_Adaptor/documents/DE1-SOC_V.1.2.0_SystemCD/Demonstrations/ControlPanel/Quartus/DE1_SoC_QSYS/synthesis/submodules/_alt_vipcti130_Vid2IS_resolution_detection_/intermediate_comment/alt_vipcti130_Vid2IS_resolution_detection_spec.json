{
    "spec": "Module name: alt_vipcti130_Vid2IS_resolution_detection.\n\nModule specification: The alt_vipcti130_Vid2IS_resolution_detection module is designed to detect the resolution of video input signals by analyzing active video samples and lines per video frame. The module uses input ports including rst (reset), clk (clock), count_cycle (valid video cycle for counting samples), ap (active video signal), hd_sdn (high-definition shutdown), start_new_line, start_new_field, end_of_vsync, f (field indicator), and vid_locked (video signal stability indicator). The outputs include update (signal update indicator), interlaced (video interlace status), active_sample_count, active_line_count_f0, active_line_count_f1, total_sample_count, total_line_count_f0, total_line_count_f1, total_line_count, stable (stability status), resolution_valid, and resolution_change (resolution change indication). Key internal signals like count_sample (conditioned count_cycle), ap_plus_1 (active pixel and counting condition), and end_of_active_line (end of active video line) among others help in the internal computation of sample and line counts. The module comprises several blocks, including instantiation of a common sample counter, signal assignments for line and field management, and always blocks handling dynamic updates of counts and status outputs. There are detailed checks and balances for video signal stability, resolution validation, and interlace detection to ensure accurate resolution output as expected for downstream processing tasks in video systems.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti130_Vid2IS_resolution_detection.\n\nExplanation: This module is designed for detecting the resolution of video input signals by counting the active video samples and lines per video frame. It interlaces and updates various counters for the total number of sample counts, active sample counts, total line counts across two fields (F0, F1), and active line counts in both fields. It handles changes in video field starting, syncs on new lines or fields, and identifies video resolution changes based on synchronized counters. Furthermore, it outputs whether the input resolution is stable and valid. The module also considers different scenarios such as locked/unlocked video signals and interlaced/non-interlaced video formats. This detection operation assists in adapting processing modules downstream according to the detected video resolution dynamically."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: rst, clk, count_cycle, ap, hd_sdn, start_new_line, start_new_field, end_of_vsync, f, vid_locked.\nExplanation:\n- rst: Reset signal to initialize the module's internal registers and behaviour.\n- clk: Clock signal to drive the sequential logic inside the module.\n- count_cycle: Signal indicating a valid video cycle for counting samples.\n- ap: Active video signal, used to detect valid video data during active video periods.\n- hd_sdn: High-definition shutdown signal, possibly used for configuration or power management.\n- start_new_line: Indicates the start of a new line in the video frame.\n- start_new_field: Indicates the start of a new field in an interlaced video frame.\n- end_of_vsync: Used to detect the end of the vertical synchronization period, indicating the transition between frames or fields.\n- f: Field indicator signal, used to determine the current field (F0 or F1) in an interlaced video.\n- vid_locked: Signal indicating whether the video input signal is stable and locked.\n\nOutput ports: update, interlaced, active_sample_count, active_line_count_f0, active_line_count_f1, total_sample_count, total_line_count_f0, total_line_count_f1, total_line_count, stable, resolution_valid, resolution_change.\nExplanation:\n- update: Signal to indicate that there is an update in the module's calculated values, possibly new resolution data.\n- interlaced: Indicates whether the video is interlaced, derived from the field timing.\n- active_sample_count: Count of active samples per line or field, used to determine resolution.\n- active_line_count_f0: Count of active lines in the first field (F0) of an interlaced frame.\n- active_line_count_f1: Count of active lines in the second field (F1) of an interlaced frame.\n- total_sample_count: Total number of samples throughout a complete frame or field cycle.\n- total_line_count_f0: Total lines counted in the first field (F0) of the frame.\n- total_line_count_f1: Total lines counted in the second field (F1) of the frame.\n- total_line_count: Combined total lines across both fields for a complete frame, adjusted for interlaced mode.\n- stable: Output indicating if the detected resolution is stable over time.\n- resolution_valid: Indicates whether the detected resolution and video signal are valid and coherent.\n- resolution_change: Flag to indicate a change in resolution, suggesting the need for adaptive processing or alerting downstream modules."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: count_sample, ap_plus_1, active_line, end_of_active_line, current_field, prev_field, start_new_field_sticky, reset_line_count, reset_line_count_nxt, stable_next, stable_reg, first_start_of_line, first_start_new_field, lines_next, lines, next_active_sample_count, next_active_line_count, next_total_sample_count, next_total_line_count, active_sample_count_nxt, active_line_count_f0_nxt, active_line_count_f1_nxt, total_sample_count_nxt, total_line_count_f0_nxt, total_line_count_f1_nxt, reset_sample, reset_f0, reset_f1, reset_total_sample, reset_total_f0, reset_total_f1, field_update, stable_update, resolution_valid_update, resolution_valid_nxt, interlaced_valid, resolution_valid_reg, second_active_line, update_total_sample, update_total_line_f0, update_total_line_f1, update_active_sample, update_active_line_f0, update_active_line_f1, field_0, field_1, update_sample.\n\nExplanation:\n- count_sample: Conditioned signal from the external count_cycle input, used in the sample counting process.\n- ap_plus_1: Indicates the presence of an active pixel and active count cycle; used to increment active sample counts.\n- active_line: Maintains the 'active' state across several cycles to manage line counting effectively during active periods.\n- end_of_active_line: Signal indicating the termination of an active line, based on start_new_line and active_line status.\n- current_field, prev_field: Store and manage information about the current and previous video fields to handle interlacing.\n- start_new_field_sticky: Ensures the new field signal is retained long enough for stable processing, unaffected by immediate transitions.\n- reset_line_count, reset_line_count_nxt: Manage line counting resets at the start of new lines and fields.\n- stable_next, stable_reg: Flags used to manage and store the stability of the incoming video signal, ensuring consistent resolution detection.\n- first_start_of_line, first_start_new_field, second_active_line: Utilized to manage the processing logic's timing concerning new lines and fields.\n- lines_next, lines: Maintain and update a history or pattern of line starts for determining signal stability.\n- next_active_sample_count, next_active_line_count, next_total_sample_count, next_total_line_count: Temporarily store the next computed values for sample and line counts, preparing them for potential updates.\n- active_sample_count_nxt, active_line_count_f0_nxt, active_line_count_f1_nxt, total_sample_count_nxt, total_line_count_f0_nxt, total_line_count_f1_nxt: Conditionally update the respective counts based on internal conditions and flags.\n- reset_sample, reset_f0, reset_f1, reset_total_sample, reset_total_f0, reset_total_f1: Manage reset conditions for counts, ensuring they are properly reinitialized when specific field or sample update conditions occur.\n- field_update, stable_update, resolution_valid_update: Flags signaling updates necessary to reflect changes in the field timing, system stability, or resolution validity.\n- resolution_valid_nxt, interlaced_valid, resolution_valid_reg: Manage the detection and acknowledgment of valid resolution and whether the video is interlaced.\n- update_total_sample, update_total_line_f0, update_total_line_f1, update_active_sample, update_active_line_f0, update_active_line_f1: Determine whether updates to respective counts should occur based on changes and new line/field detections.\n- field_0, field_1, update_sample: Utilized within conditional logic to update counts and manage interlaced field calculations appropriately."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\nmodule alt_vipcti130_Vid2IS_resolution_detection(\n    input wire rst,\n    input wire clk,\n    \n    input wire count_cycle,\n    input wire ap,\n    input wire hd_sdn,\n    input wire start_new_line,\n    input wire start_new_field,\n    input wire end_of_vsync,\n    input wire f,\n    input wire vid_locked,\n    \n    output reg update,\n    output reg interlaced,\n    output reg [14:0] active_sample_count,\n    output reg [13:0] active_line_count_f0,\n    output reg [13:0] active_line_count_f1,\n    output reg [14:0] total_sample_count,\n    output reg [13:0] total_line_count_f0,\n    output reg [13:0] total_line_count_f1,\n    output reg [13:0] total_line_count,\n    output reg stable,\n    output reg resolution_valid,\n    output reg resolution_change);\n    \nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\nparameter H_ACTIVE_PIXELS = 0;\nparameter V_ACTIVE_LINES_F0 = 0;\nparameter V_ACTIVE_LINES_F1 = 0;\nparameter INTERLACED = 0;\n\nwire count_sample;\nwire ap_plus_1;\nreg active_line;\nwire end_of_active_line;\n\nalt_vipcti130_common_sample_counter sample_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(1'b0),\n    .hd_sdn(hd_sdn),\n    .count_cycle(count_cycle),\n    .count_sample(count_sample));\n    \ndefparam sample_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         sample_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         sample_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES;\n\nassign ap_plus_1 = count_sample & ap;\nassign end_of_active_line = start_new_line & active_line;\n\nreg [1:0] current_field;\nreg [1:0] prev_field;\nreg start_new_field_sticky;\nreg reset_line_count;\nwire reset_line_count_nxt;\nwire stable_next;\nreg stable_reg;\nreg first_start_of_line;\nreg first_start_new_field;\nwire [2:0] lines_next;\nreg [2:0] lines;\nreg [13:0] next_active_sample_count;    \nreg [12:0] next_active_line_count;      \nreg [13:0] next_total_sample_count;\nreg [12:0] next_total_line_count;\nwire [14:0] active_sample_count_nxt;\nwire [13:0] active_line_count_f0_nxt;\nwire [13:0] active_line_count_f1_nxt;\nwire [14:0] total_sample_count_nxt;\nwire [13:0] total_line_count_f0_nxt;\nwire [13:0] total_line_count_f1_nxt;\nwire reset_sample;\nwire reset_f0;\nwire reset_f1;\nwire reset_total_sample;\nwire reset_total_f0;\nwire reset_total_f1;\nwire update_active_line_f1;\nwire update_active_sample;\nwire update_active_line_f0;\nwire update_total_sample;\nwire update_total_line_f0;\nwire update_total_line_f1;\nwire field_update;\nwire stable_update;\nwire resolution_valid_update;\nwire field_0;\nwire field_1;\nwire update_sample;\nreg interlaced_valid;\nwire resolution_valid_nxt;\nreg resolution_valid_reg;\nreg second_active_line;\n\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        current_field <= {INTERLACED, 1'b0};\n        prev_field <= 2'b00;\n        interlaced <= 1'b0;\n        interlaced_valid <= 1'b0;\n        start_new_field_sticky <= 1'b0;\n        reset_line_count <= 1'b0;\n        \n        lines <= 3'b000;\n        stable <= 1'b0;\n        stable_reg <= 1'b0;\n        \n        active_line <= 1'b0;\n        next_active_sample_count <= 14'd0;\n        next_active_line_count <= 13'd0;\n        next_total_sample_count <= 14'd0;\n        next_total_line_count <= 13'd0;\n        active_sample_count <= {H_ACTIVE_PIXELS, 1'b1};\n        active_line_count_f0 <= {V_ACTIVE_LINES_F0, 1'b1};\n        active_line_count_f1 <= (INTERLACED) ? {V_ACTIVE_LINES_F1, 1'b1} : 17'd0;\n        total_sample_count <= 15'd0;\n        total_line_count_f0 <= 14'd0;\n        total_line_count_f1 <= 14'd0;\n        total_line_count <= 14'd0;\n        \n        update <= 1'b0;\n        first_start_new_field <= 1'b0;\n        first_start_of_line <= 1'b0;\n        second_active_line <= 1'b0;\n        \n        resolution_valid <= 1'b0;\n        resolution_valid_reg <= 1'b0;\n        resolution_change <= 1'b0;\n    end else begin\n        \n        \n        current_field <= (~vid_locked) ? {current_field[1], 1'b0} : (end_of_vsync) ? {f, 1'b1} : current_field;\n        prev_field <= (~vid_locked) ? {prev_field[1], 1'b0} : (end_of_vsync) ? current_field : prev_field;\n        interlaced <= current_field[1] | prev_field[1];\n        interlaced_valid <= current_field[0] & prev_field[0];\n        start_new_field_sticky <= (start_new_field | start_new_field_sticky) & ~start_new_line;\n        reset_line_count <= reset_line_count_nxt;\n        \n        \n        lines <= lines_next;\n        stable <= stable_next;\n        stable_reg <= stable;\n        \n        active_line <= (ap | active_line) & ~start_new_line;\n        next_active_sample_count <= (end_of_active_line) ? 14'd0 : (ap_plus_1) ? next_active_sample_count + 14'd1 : next_active_sample_count;\n        next_active_line_count <= (reset_line_count) ? 13'd0 : (end_of_active_line) ? next_active_line_count + 13'd1 : next_active_line_count;\n        next_total_sample_count <= (start_new_line) ? {13'd0, count_sample} : (count_sample) ? next_total_sample_count + 14'd1 : next_total_sample_count;\n        next_total_line_count <= (reset_line_count) ? 13'd0 : (start_new_line) ? next_total_line_count + 13'd1 : next_total_line_count;\n        \n        \n        active_sample_count <= active_sample_count_nxt;\n        active_line_count_f0 <= active_line_count_f0_nxt;\n        active_line_count_f1 <= active_line_count_f1_nxt;\n        total_sample_count <= total_sample_count_nxt;\n        total_line_count_f0 <= total_line_count_f0_nxt;\n        total_line_count_f1 <= total_line_count_f1_nxt;\n        total_line_count[13:1] <= (~interlaced) ? total_line_count_f0_nxt[13:1] : total_line_count_f0_nxt[13:1] + total_line_count_f1_nxt[13:1];\n        total_line_count[0] <= total_line_count_f0_nxt[0] & (~interlaced | total_line_count_f1_nxt[0]);\n        \n        update <= update ^ (field_update | stable_update | resolution_valid_update);\n        first_start_of_line <= (start_new_line | first_start_of_line) & vid_locked;\n        first_start_new_field <= (reset_line_count | first_start_new_field) & vid_locked;\n        second_active_line <= (end_of_active_line | (second_active_line & ~start_new_line)) & vid_locked;  \n                                                                                                           \n        \n        resolution_valid <= resolution_valid_nxt;\n        resolution_valid_reg <= resolution_valid;\n        resolution_change <= resolution_change ^ ((resolution_valid & resolution_valid_nxt & field_update) | (resolution_valid & ~resolution_valid_reg));\n    end\nend\n\nassign reset_line_count_nxt = start_new_line & (start_new_field | start_new_field_sticky);\n\nassign lines_next = (~vid_locked) ? 3'b000 : (start_new_line) ? {lines[1:0], ~update_sample} : lines;\nassign stable_next = vid_locked & first_start_of_line & ((lines_next[0] & lines_next[1]) | (lines_next[0] & lines_next[2]) | (lines_next[1] & lines_next[2]));\n\nassign resolution_valid_nxt = active_sample_count_nxt[0] & total_sample_count_nxt[0] &\n                              active_line_count_f0_nxt[0] & total_line_count_f0_nxt[0] &\n                              ((active_line_count_f1_nxt[0] & total_line_count_f1_nxt[0]) | ~interlaced) &\n                              interlaced_valid;\n\nassign active_sample_count_nxt = (update_active_sample) ? {next_active_sample_count, 1'b1} : active_sample_count;\nassign active_line_count_f0_nxt = (reset_f0) ? {active_line_count_f0[13:1], 1'b0} : (update_active_line_f0) ? {next_active_line_count, 1'b1} : active_line_count_f0;\nassign active_line_count_f1_nxt = (reset_f1) ? {active_line_count_f1[13:1], 1'b0} : (update_active_line_f1) ? {next_active_line_count, 1'b1} : active_line_count_f1;\nassign total_sample_count_nxt = (update_total_sample) ? {next_total_sample_count, 1'b1} : total_sample_count;\nassign total_line_count_f0_nxt = (reset_total_f0) ? {total_line_count_f0[13:1], 1'b0} : (update_total_line_f0) ? {next_total_line_count, 1'b1} : total_line_count_f0;\nassign total_line_count_f1_nxt = (reset_total_f1) ? {total_line_count_f1[13:1], 1'b0} : (update_total_line_f1) ? {next_total_line_count, 1'b1} : total_line_count_f1;\n\nassign field_update = (update_active_sample | update_active_line_f0 | update_active_line_f1 |\n                       update_total_sample | update_total_line_f0 | update_total_line_f1);\nassign stable_update = stable_next ^ stable;\nassign resolution_valid_update = resolution_valid_nxt ^ resolution_valid;\n\n\nassign reset_sample = (update_active_sample & active_sample_count[0]);\nassign reset_f0 = reset_sample | (update_active_line_f1 & active_line_count_f1[0]);\nassign reset_f1 = reset_sample | (update_active_line_f0 & active_line_count_f0[0]);\n\nassign reset_total_sample = (update_total_sample & total_sample_count[0]);\nassign reset_total_f0 = reset_total_sample | (update_total_line_f1 & total_line_count_f1[0]);\nassign reset_total_f1 = reset_total_sample | (update_total_line_f0 & total_line_count_f0[0]);\n\nassign field_0 = reset_line_count & ~f;\nassign field_1 = reset_line_count & f;\n\nassign update_active_sample = (end_of_active_line) && (next_active_sample_count != active_sample_count[14:1] || !active_sample_count[0]) && first_start_of_line;\nassign update_active_line_f0 = field_0 && (next_active_line_count != active_line_count_f0[13:1] || !active_line_count_f0[0]) && first_start_new_field;\nassign update_active_line_f1 = field_1 && (next_active_line_count != active_line_count_f1[13:1] || !active_line_count_f1[0]) && first_start_new_field;\n\nassign update_total_sample = (end_of_active_line && second_active_line) && (next_total_sample_count != total_sample_count[14:1] || !total_sample_count[0]) && first_start_of_line;\nassign update_total_line_f0 = field_0 && (next_total_line_count != total_line_count_f0[13:1] || !total_line_count_f0[0]) && first_start_new_field;\nassign update_total_line_f1 = field_1 && (next_total_line_count != total_line_count_f1[13:1] || !total_line_count_f1[0]) && first_start_new_field;\n\nassign update_sample = update_active_sample & update_total_sample;\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: alt_vipcti130_Vid2IS_resolution_detection.\n\nModule specification: The alt_vipcti130_Vid2IS_resolution_detection module is designed to detect the resolution of video input signals by analyzing active video samples and lines per video frame. The module uses input ports including rst (reset), clk (clock), count_cycle (valid video cycle for counting samples), ap (active video signal), hd_sdn (high-definition shutdown), start_new_line, start_new_field, end_of_vsync, f (field indicator), and vid_locked (video signal stability indicator). The outputs include update (signal update indicator), interlaced (video interlace status), active_sample_count, active_line_count_f0, active_line_count_f1, total_sample_count, total_line_count_f0, total_line_count_f1, total_line_count, stable (stability status), resolution_valid, and resolution_change (resolution change indication). Key internal signals like count_sample (conditioned count_cycle), ap_plus_1 (active pixel and counting condition), and end_of_active_line (end of active video line) among others help in the internal computation of sample and line counts. The module comprises several blocks, including instantiation of a common sample counter, signal assignments for line and field management, and always blocks handling dynamic updates of counts and status outputs. There are detailed checks and balances for video signal stability, resolution validation, and interlace detection to ensure accurate resolution output as expected for downstream processing tasks in video systems."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: alt_vipcti130_Vid2IS_resolution_detection.\n\nExplanation: This module is designed for detecting the resolution of video input signals by counting the active video samples and lines per video frame. It interlaces and updates various counters for the total number of sample counts, active sample counts, total line counts across two fields (F0, F1), and active line counts in both fields. It handles changes in video field starting, syncs on new lines or fields, and identifies video resolution changes based on synchronized counters. Furthermore, it outputs whether the input resolution is stable and valid. The module also considers different scenarios such as locked/unlocked video signals and interlaced/non-interlaced video formats. This detection operation assists in adapting processing modules downstream according to the detected video resolution dynamically."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: rst, clk, count_cycle, ap, hd_sdn, start_new_line, start_new_field, end_of_vsync, f, vid_locked.\nExplanation:\n- rst: Reset signal to initialize the module's internal registers and behaviour.\n- clk: Clock signal to drive the sequential logic inside the module.\n- count_cycle: Signal indicating a valid video cycle for counting samples.\n- ap: Active video signal, used to detect valid video data during active video periods.\n- hd_sdn: High-definition shutdown signal, possibly used for configuration or power management.\n- start_new_line: Indicates the start of a new line in the video frame.\n- start_new_field: Indicates the start of a new field in an interlaced video frame.\n- end_of_vsync: Used to detect the end of the vertical synchronization period, indicating the transition between frames or fields.\n- f: Field indicator signal, used to determine the current field (F0 or F1) in an interlaced video.\n- vid_locked: Signal indicating whether the video input signal is stable and locked.\n\nOutput ports: update, interlaced, active_sample_count, active_line_count_f0, active_line_count_f1, total_sample_count, total_line_count_f0, total_line_count_f1, total_line_count, stable, resolution_valid, resolution_change.\nExplanation:\n- update: Signal to indicate that there is an update in the module's calculated values, possibly new resolution data.\n- interlaced: Indicates whether the video is interlaced, derived from the field timing.\n- active_sample_count: Count of active samples per line or field, used to determine resolution.\n- active_line_count_f0: Count of active lines in the first field (F0) of an interlaced frame.\n- active_line_count_f1: Count of active lines in the second field (F1) of an interlaced frame.\n- total_sample_count: Total number of samples throughout a complete frame or field cycle.\n- total_line_count_f0: Total lines counted in the first field (F0) of the frame.\n- total_line_count_f1: Total lines counted in the second field (F1) of the frame.\n- total_line_count: Combined total lines across both fields for a complete frame, adjusted for interlaced mode.\n- stable: Output indicating if the detected resolution is stable over time.\n- resolution_valid: Indicates whether the detected resolution and video signal are valid and coherent.\n- resolution_change: Flag to indicate a change in resolution, suggesting the need for adaptive processing or alerting downstream modules."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: count_sample, ap_plus_1, active_line, end_of_active_line, current_field, prev_field, start_new_field_sticky, reset_line_count, reset_line_count_nxt, stable_next, stable_reg, first_start_of_line, first_start_new_field, lines_next, lines, next_active_sample_count, next_active_line_count, next_total_sample_count, next_total_line_count, active_sample_count_nxt, active_line_count_f0_nxt, active_line_count_f1_nxt, total_sample_count_nxt, total_line_count_f0_nxt, total_line_count_f1_nxt, reset_sample, reset_f0, reset_f1, reset_total_sample, reset_total_f0, reset_total_f1, field_update, stable_update, resolution_valid_update, resolution_valid_nxt, interlaced_valid, resolution_valid_reg, second_active_line, update_total_sample, update_total_line_f0, update_total_line_f1, update_active_sample, update_active_line_f0, update_active_line_f1, field_0, field_1, update_sample.\n\nExplanation:\n- count_sample: Conditioned signal from the external count_cycle input, used in the sample counting process.\n- ap_plus_1: Indicates the presence of an active pixel and active count cycle; used to increment active sample counts.\n- active_line: Maintains the 'active' state across several cycles to manage line counting effectively during active periods.\n- end_of_active_line: Signal indicating the termination of an active line, based on start_new_line and active_line status.\n- current_field, prev_field: Store and manage information about the current and previous video fields to handle interlacing.\n- start_new_field_sticky: Ensures the new field signal is retained long enough for stable processing, unaffected by immediate transitions.\n- reset_line_count, reset_line_count_nxt: Manage line counting resets at the start of new lines and fields.\n- stable_next, stable_reg: Flags used to manage and store the stability of the incoming video signal, ensuring consistent resolution detection.\n- first_start_of_line, first_start_new_field, second_active_line: Utilized to manage the processing logic's timing concerning new lines and fields.\n- lines_next, lines: Maintain and update a history or pattern of line starts for determining signal stability.\n- next_active_sample_count, next_active_line_count, next_total_sample_count, next_total_line_count: Temporarily store the next computed values for sample and line counts, preparing them for potential updates.\n- active_sample_count_nxt, active_line_count_f0_nxt, active_line_count_f1_nxt, total_sample_count_nxt, total_line_count_f0_nxt, total_line_count_f1_nxt: Conditionally update the respective counts based on internal conditions and flags.\n- reset_sample, reset_f0, reset_f1, reset_total_sample, reset_total_f0, reset_total_f1: Manage reset conditions for counts, ensuring they are properly reinitialized when specific field or sample update conditions occur.\n- field_update, stable_update, resolution_valid_update: Flags signaling updates necessary to reflect changes in the field timing, system stability, or resolution validity.\n- resolution_valid_nxt, interlaced_valid, resolution_valid_reg: Manage the detection and acknowledgment of valid resolution and whether the video is interlaced.\n- update_total_sample, update_total_line_f0, update_total_line_f1, update_active_sample, update_active_line_f0, update_active_line_f1: Determine whether updates to respective counts should occur based on changes and new line/field detections.\n- field_0, field_1, update_sample: Utilized within conditional logic to update counts and manage interlaced field calculations appropriately."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>module alt_vipcti130_Vid2IS_resolution_detection(\n    input wire rst,\n    input wire clk,\n    \n    input wire count_cycle,\n    input wire ap,\n    input wire hd_sdn,\n    input wire start_new_line,\n    input wire start_new_field,\n    input wire end_of_vsync,\n    input wire f,\n    input wire vid_locked,\n    \n    output reg update,\n    output reg interlaced,\n    output reg [14:0] active_sample_count,\n    output reg [13:0] active_line_count_f0,\n    output reg [13:0] active_line_count_f1,\n    output reg [14:0] total_sample_count,\n    output reg [13:0] total_line_count_f0,\n    output reg [13:0] total_line_count_f1,\n    output reg [13:0] total_line_count,\n    output reg stable,\n    output reg resolution_valid,\n    output reg resolution_change);\n    \nparameter NUMBER_OF_COLOUR_PLANES = 0;\nparameter COLOUR_PLANES_ARE_IN_PARALLEL = 0;\nparameter LOG2_NUMBER_OF_COLOUR_PLANES = 0;\nparameter H_ACTIVE_PIXELS = 0;\nparameter V_ACTIVE_LINES_F0 = 0;\nparameter V_ACTIVE_LINES_F1 = 0;\nparameter INTERLACED = 0;\n\nwire count_sample;\nwire ap_plus_1;\nreg active_line;\nwire end_of_active_line;\n\nalt_vipcti130_common_sample_counter sample_counter(\n    .rst(rst),\n    .clk(clk),\n    .sclr(1'b0),\n    .hd_sdn(hd_sdn),\n    .count_cycle(count_cycle),\n    .count_sample(count_sample));\n    \ndefparam sample_counter.NUMBER_OF_COLOUR_PLANES = NUMBER_OF_COLOUR_PLANES,\n         sample_counter.COLOUR_PLANES_ARE_IN_PARALLEL = COLOUR_PLANES_ARE_IN_PARALLEL,\n         sample_counter.LOG2_NUMBER_OF_COLOUR_PLANES = LOG2_NUMBER_OF_COLOUR_PLANES;\n\nassign ap_plus_1 = count_sample & ap;\nassign end_of_active_line = start_new_line & active_line;\n\nreg [1:0] current_field;\nreg [1:0] prev_field;\nreg start_new_field_sticky;\nreg reset_line_count;\nwire reset_line_count_nxt;\nwire stable_next;\nreg stable_reg;\nreg first_start_of_line;\nreg first_start_new_field;\nwire [2:0] lines_next;\nreg [2:0] lines;\nreg [13:0] next_active_sample_count;    \nreg [12:0] next_active_line_count;      \nreg [13:0] next_total_sample_count;\nreg [12:0] next_total_line_count;\nwire [14:0] active_sample_count_nxt;\nwire [13:0] active_line_count_f0_nxt;\nwire [13:0] active_line_count_f1_nxt;\nwire [14:0] total_sample_count_nxt;\nwire [13:0] total_line_count_f0_nxt;\nwire [13:0] total_line_count_f1_nxt;\nwire reset_sample;\nwire reset_f0;\nwire reset_f1;\nwire reset_total_sample;\nwire reset_total_f0;\nwire reset_total_f1;\nwire update_active_line_f1;\nwire update_active_sample;\nwire update_active_line_f0;\nwire update_total_sample;\nwire update_total_line_f0;\nwire update_total_line_f1;\nwire field_update;\nwire stable_update;\nwire resolution_valid_update;\nwire field_0;\nwire field_1;\nwire update_sample;\nreg interlaced_valid;\nwire resolution_valid_nxt;\nreg resolution_valid_reg;\nreg second_active_line;\n\n\nalways @ (posedge rst or posedge clk) begin\n    if(rst) begin\n        current_field <= {INTERLACED, 1'b0};\n        prev_field <= 2'b00;\n        interlaced <= 1'b0;\n        interlaced_valid <= 1'b0;\n        start_new_field_sticky <= 1'b0;\n        reset_line_count <= 1'b0;\n        \n        lines <= 3'b000;\n        stable <= 1'b0;\n        stable_reg <= 1'b0;\n        \n        active_line <= 1'b0;\n        next_active_sample_count <= 14'd0;\n        next_active_line_count <= 13'd0;\n        next_total_sample_count <= 14'd0;\n        next_total_line_count <= 13'd0;\n        active_sample_count <= {H_ACTIVE_PIXELS, 1'b1};\n        active_line_count_f0 <= {V_ACTIVE_LINES_F0, 1'b1};\n        active_line_count_f1 <= (INTERLACED) ? {V_ACTIVE_LINES_F1, 1'b1} : 17'd0;\n        total_sample_count <= 15'd0;\n        total_line_count_f0 <= 14'd0;\n        total_line_count_f1 <= 14'd0;\n        total_line_count <= 14'd0;\n        \n        update <= 1'b0;\n        first_start_new_field <= 1'b0;\n        first_start_of_line <= 1'b0;\n        second_active_line <= 1'b0;\n        \n        resolution_valid <= 1'b0;\n        resolution_valid_reg <= 1'b0;\n        resolution_change <= 1'b0;\n    end else begin\n        \n        \n        current_field <= (~vid_locked) ? {current_field[1], 1'b0} : (end_of_vsync) ? {f, 1'b1} : current_field;\n        prev_field <= (~vid_locked) ? {prev_field[1], 1'b0} : (end_of_vsync) ? current_field : prev_field;\n        interlaced <= current_field[1] | prev_field[1];\n        interlaced_valid <= current_field[0] & prev_field[0];\n        start_new_field_sticky <= (start_new_field | start_new_field_sticky) & ~start_new_line;\n        reset_line_count <= reset_line_count_nxt;\n        \n        \n        lines <= lines_next;\n        stable <= stable_next;\n        stable_reg <= stable;\n        \n        active_line <= (ap | active_line) & ~start_new_line;\n        next_active_sample_count <= (end_of_active_line) ? 14'd0 : (ap_plus_1) ? next_active_sample_count + 14'd1 : next_active_sample_count;\n        next_active_line_count <= (reset_line_count) ? 13'd0 : (end_of_active_line) ? next_active_line_count + 13'd1 : next_active_line_count;\n        next_total_sample_count <= (start_new_line) ? {13'd0, count_sample} : (count_sample) ? next_total_sample_count + 14'd1 : next_total_sample_count;\n        next_total_line_count <= (reset_line_count) ? 13'd0 : (start_new_line) ? next_total_line_count + 13'd1 : next_total_line_count;\n        \n        \n        active_sample_count <= active_sample_count_nxt;\n        active_line_count_f0 <= active_line_count_f0_nxt;\n        active_line_count_f1 <= active_line_count_f1_nxt;\n        total_sample_count <= total_sample_count_nxt;\n        total_line_count_f0 <= total_line_count_f0_nxt;\n        total_line_count_f1 <= total_line_count_f1_nxt;\n        total_line_count[13:1] <= (~interlaced) ? total_line_count_f0_nxt[13:1] : total_line_count_f0_nxt[13:1] + total_line_count_f1_nxt[13:1];\n        total_line_count[0] <= total_line_count_f0_nxt[0] & (~interlaced | total_line_count_f1_nxt[0]);\n        \n        update <= update ^ (field_update | stable_update | resolution_valid_update);\n        first_start_of_line <= (start_new_line | first_start_of_line) & vid_locked;\n        first_start_new_field <= (reset_line_count | first_start_new_field) & vid_locked;\n        second_active_line <= (end_of_active_line | (second_active_line & ~start_new_line)) & vid_locked;  \n                                                                                                           \n        \n        resolution_valid <= resolution_valid_nxt;\n        resolution_valid_reg <= resolution_valid;\n        resolution_change <= resolution_change ^ ((resolution_valid & resolution_valid_nxt & field_update) | (resolution_valid & ~resolution_valid_reg));\n    end\nend\n\nassign reset_line_count_nxt = start_new_line & (start_new_field | start_new_field_sticky);\n\nassign lines_next = (~vid_locked) ? 3'b000 : (start_new_line) ? {lines[1:0], ~update_sample} : lines;\nassign stable_next = vid_locked & first_start_of_line & ((lines_next[0] & lines_next[1]) | (lines_next[0] & lines_next[2]) | (lines_next[1] & lines_next[2]));\n\nassign resolution_valid_nxt = active_sample_count_nxt[0] & total_sample_count_nxt[0] &\n                              active_line_count_f0_nxt[0] & total_line_count_f0_nxt[0] &\n                              ((active_line_count_f1_nxt[0] & total_line_count_f1_nxt[0]) | ~interlaced) &\n                              interlaced_valid;\n\nassign active_sample_count_nxt = (update_active_sample) ? {next_active_sample_count, 1'b1} : active_sample_count;\nassign active_line_count_f0_nxt = (reset_f0) ? {active_line_count_f0[13:1], 1'b0} : (update_active_line_f0) ? {next_active_line_count, 1'b1} : active_line_count_f0;\nassign active_line_count_f1_nxt = (reset_f1) ? {active_line_count_f1[13:1], 1'b0} : (update_active_line_f1) ? {next_active_line_count, 1'b1} : active_line_count_f1;\nassign total_sample_count_nxt = (update_total_sample) ? {next_total_sample_count, 1'b1} : total_sample_count;\nassign total_line_count_f0_nxt = (reset_total_f0) ? {total_line_count_f0[13:1], 1'b0} : (update_total_line_f0) ? {next_total_line_count, 1'b1} : total_line_count_f0;\nassign total_line_count_f1_nxt = (reset_total_f1) ? {total_line_count_f1[13:1], 1'b0} : (update_total_line_f1) ? {next_total_line_count, 1'b1} : total_line_count_f1;\n\nassign field_update = (update_active_sample | update_active_line_f0 | update_active_line_f1 |\n                       update_total_sample | update_total_line_f0 | update_total_line_f1);\nassign stable_update = stable_next ^ stable;\nassign resolution_valid_update = resolution_valid_nxt ^ resolution_valid;\n\n\nassign reset_sample = (update_active_sample & active_sample_count[0]);\nassign reset_f0 = reset_sample | (update_active_line_f1 & active_line_count_f1[0]);\nassign reset_f1 = reset_sample | (update_active_line_f0 & active_line_count_f0[0]);\n\nassign reset_total_sample = (update_total_sample & total_sample_count[0]);\nassign reset_total_f0 = reset_total_sample | (update_total_line_f1 & total_line_count_f1[0]);\nassign reset_total_f1 = reset_total_sample | (update_total_line_f0 & total_line_count_f0[0]);\n\nassign field_0 = reset_line_count & ~f;\nassign field_1 = reset_line_count & f;\n\nassign update_active_sample = (end_of_active_line) && (next_active_sample_count != active_sample_count[14:1] || !active_sample_count[0]) && first_start_of_line;\nassign update_active_line_f0 = field_0 && (next_active_line_count != active_line_count_f0[13:1] || !active_line_count_f0[0]) && first_start_new_field;\nassign update_active_line_f1 = field_1 && (next_active_line_count != active_line_count_f1[13:1] || !active_line_count_f1[0]) && first_start_new_field;\n\nassign update_total_sample = (end_of_active_line && second_active_line) && (next_total_sample_count != total_sample_count[14:1] || !total_sample_count[0]) && first_start_of_line;\nassign update_total_line_f0 = field_0 && (next_total_line_count != total_line_count_f0[13:1] || !total_line_count_f0[0]) && first_start_new_field;\nassign update_total_line_f1 = field_1 && (next_total_line_count != total_line_count_f1[13:1] || !total_line_count_f1[0]) && first_start_new_field;\n\nassign update_sample = update_active_sample & update_total_sample;\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: alt_vipcti130_Vid2IS_resolution_detection.\n\nModule specification: The alt_vipcti130_Vid2IS_resolution_detection module is designed to detect the resolution of video input signals by analyzing active video samples and lines per video frame. The module uses input ports including rst (reset), clk (clock), count_cycle (valid video cycle for counting samples), ap (active video signal), hd_sdn (high-definition shutdown), start_new_line, start_new_field, end_of_vsync, f (field indicator), and vid_locked (video signal stability indicator). The outputs include update (signal update indicator), interlaced (video interlace status), active_sample_count, active_line_count_f0, active_line_count_f1, total_sample_count, total_line_count_f0, total_line_count_f1, total_line_count, stable (stability status), resolution_valid, and resolution_change (resolution change indication). Key internal signals like count_sample (conditioned count_cycle), ap_plus_1 (active pixel and counting condition), and end_of_active_line (end of active video line) among others help in the internal computation of sample and line counts. The module comprises several blocks, including instantiation of a common sample counter, signal assignments for line and field management, and always blocks handling dynamic updates of counts and status outputs. There are detailed checks and balances for video signal stability, resolution validation, and interlace detection to ensure accurate resolution output as expected for downstream processing tasks in video systems."
                }
            ]
        }
    ]
}