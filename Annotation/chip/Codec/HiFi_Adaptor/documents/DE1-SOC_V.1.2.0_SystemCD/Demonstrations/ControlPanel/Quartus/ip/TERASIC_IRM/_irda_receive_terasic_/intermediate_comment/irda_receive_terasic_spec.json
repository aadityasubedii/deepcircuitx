{
    "spec": "Module name: IRDA_RECEIVE_Terasic. \nModule specification: The IRDA_RECEIVE_Terasic module is designed for receiving and decoding IRDA (Infrared Data Association) signals. It processes these signals through state transitions: IDLE, GUIDANCE, and DATAREAD, to detect, synchronize, and decode the incoming data packets based on signal durations. Input ports include iCLK (clock input), iRST_n (active low reset), iIRDA (IRDA data input), and iREAD (data read command). Output ports comprise oDATA_REAY (indicates data readiness), and oDATA (32-bit output data port). Internally, the module utilizes signals such as DATA_REAY (signals data readiness), idle_count and state_count (counters for measuring signal durations in respective states), data_count (counter for data bits duration), bitcount (bit counter for the data packet), and state (tracks the current state of the machine). The module's operations are orchestrated across various blocks handling resets, state transitions, data reading and output generation, where each block manipulates specific counters and flags to control the flow and decoding of IRDA signals, ensuring synchronized data processing and output readiness based on input conditions and internally tracked state.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: IRDA_RECEIVE_Terasic.\n\nExplanation: The module is designed to receive and process IRDA (Infrared Data Association) signals. It operates through different states, namely IDLE, GUIDANCE, and DATAREAD, to detect, synchronize, and decode the incoming IRDA data packets. The module monitors the duration of high and low signals to transition between these states, decoding the data when in the DATAREAD state. It validates the received data byte by checking it against a complementary half stored within the byte, and if valid, the data is passed to an output register, indicating that the data is ready. The module also handles reset conditions and read commands to manage and output the final decoded data."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: iCLK, iRST_n, iIRDA, iREAD.\nExplanation: \n- iCLK: This is the clock input, used to synchronize the operations within the module.\n- iRST_n: This is the active low reset input, used to initialize or reset the module's internal states and counters to their default settings.\n- iIRDA: This is the IRDA input signal, representing the infrared data received. The module uses this signal to decode the IRDA data.\n- iREAD: This input is used to indicate whether the IRDA data that has been processed and stored should be read and outputted from the module.\n\nOutput ports: oDATA_REAY, oDATA.\nExplanation:\n- oDATA_REAY: This is the data ready output signal. It indicates whether the decoded data is ready to be read, which is used externally to determine when to read the data from the output port.\n- oDATA: This is the output data port, which provides the final decoded IRDA data. This port outputs the data when it is signalled as ready through the oDATA_REAY signal and a read command is received via iREAD."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: DATA_REAY, idle_count, idle_count_flag, state_count, state_count_flag, data_count, data_count_flag, bitcount, state, DATA, DATA_BUF, oDATA.\n\nExplanation:\n- DATA_REAY: This signal indicates whether the data is ready to be sent out. It becomes '1' when a complete byte is successfully received and verified, ready to be transferred to the oDATA output when requested.\n- idle_count: This is a counter used to measure the duration of the idle (high) state in the IR signal, helping to transition to the GUIDANCE state if the duration matches specific conditions.\n- idle_count_flag: This flag controls the idle_count. It enables the counter when the system is in the IDLE state and the IRDA signal is low.\n- state_count: A counter used within different states (specifically GUIDANCE) to measure the duration of certain conditions and aid transitions between states.\n- state_count_flag: This flag governs the state_count functionality, enabling or disabling counting based on current conditions aligned with state transitions.\n- data_count: This counter is used in the DATAREAD state to track the duration of the data bits being read.\n- data_count_flag: This flag enables the data_count when the module is in the DATAREAD state and the condition of the incoming data signal requires counting.\n- bitcount: This register counts the number of bits that have been processed in the current packet during the DATAREAD state. It helps determine when a complete data packet has been read.\n- state: This register holds the current state of the machine. The system can be in IDLE, GUIDANCE, or DATAREAD states, controlling the behavior of the module based on the received IRDA signals.\n- DATA: This is a shift register that captures the incoming data bits in the DATAREAD state.\n- DATA_BUF: This buffer stores the validated data byte once a complete byte is read and its complement is verified as correct.\n- oDATA: It's an output register that holds the data to be pushed out through the oDATA port when a read command is issued and the data is available as indicated by DATA_REAY."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule IRDA_RECEIVE_Terasic(\n\t\t\t\t\tiCLK,         \n\t\t\t\t\tiRST_n,       \n\t\t\t\t\t\n\t\t\t\t\tiIRDA,        \n\t\t\t\t\tiREAD,        \n\t\t\t\t\t\n\t\t\t\t\toDATA_REAY,\t  \n\t\t\t\t\toDATA         \n\t\t\t\t\t);\n\t\t\t\t\t\n\nparameter IDLE = 2'b00;           \nparameter GUIDANCE = 2'b01;       \nparameter DATAREAD = 2'b10;       \n\nparameter IDLE_HIGH_DUR      =  262143;  \nparameter GUIDE_LOW_DUR      =  230000;  \nparameter GUIDE_HIGH_DUR     =  210000;  \nparameter DATA_HIGH_DUR      =  41500;\t \nparameter BIT_AVAILABLE_DUR  = 20000;    \n\n\ninput iCLK;    \ninput iRST_n;  \ninput iIRDA;   \ninput iREAD;   \n\noutput  oDATA_REAY;  \noutput [31:0] oDATA; \n\n\n\nreg DATA_REAY;             \n\nreg [17:0] idle_count;     \nreg idle_count_flag;       \n\nreg [17:0] state_count;    \nreg state_count_flag;      \n\nreg [17:0] data_count;     \nreg data_count_flag;       \n\n\nreg [5:0] bitcount;        \nreg [1:0] state;           \nreg [31:0] DATA;           \nreg [31:0] DATA_BUF;       \nreg [31:0] oDATA;          \n\n\n\ninitial\n\tbegin \n\t\tstate =  IDLE;     \n\t\tDATA_REAY = 1'b0;  \n\t\tbitcount = 0;      \n\t\tDATA = 0;          \n\t\tDATA_BUF = 0;      \n\t\tstate_count = 0;   \n\t\tdata_count = 0;    \n\t\tidle_count = 0;    \n\tend\n\t\nassign oDATA_REAY = DATA_REAY;\n\n\nalways @(negedge iRST_n or  posedge iCLK )\t\n   begin\n\t  if(!iRST_n)\n\t\t idle_count <= 0;   \n\t  else\t\t \n\t\t begin\n\t\t    if( idle_count_flag )    \n\t\t\t\tidle_count <= idle_count + 1'b1;\n\t\t\telse  \n\t\t\t\tidle_count <= 0;\t  \n\t\t end\n   end\n\n\n\nalways @( negedge iRST_n  or  posedge iCLK)\t\n   begin\n\t  if( !iRST_n )\n\t\t idle_count_flag <= 1'b0;   \n\t   else\n\t     \n\t     begin\n\t\t\t   if((state == IDLE) &&(!iIRDA))       \n\t\t\t\t\tidle_count_flag <= 1'b1;        \n\t\t\t\telse                                \n\t\t\t\t\tidle_count_flag <= 1'b0;\t\t\n\t\t end\t  \n   end  \n\nalways @(negedge iRST_n or  posedge iCLK )\t\n   begin\n\t  if(!iRST_n)\n\t\t state_count <= 0;   \n\t  else\t\t \n\t\t begin\n\t\t    if( state_count_flag )    \n\t\t\t\tstate_count <= state_count + 1'b1;\n\t\t\telse  \n\t\t\t\tstate_count <= 0;\t  \n\t\t end\n   end\t\n\n\n\nalways @( negedge iRST_n  or  posedge iCLK)\t\n   begin\n\t  if( !iRST_n )\n\t\t state_count_flag <= 1'b0; \n\t   else\n\t     \n\t     begin\n\t\t\t   if((state == GUIDANCE) &&(iIRDA))     \n\t\t\t\t\tstate_count_flag <= 1'b1;       \n\t\t\t\telse   \n\t\t\t\t\tstate_count_flag <= 1'b0;\t\t\n\t\t end\t  \n   end  \n\n\nalways @(negedge iRST_n or posedge iCLK ) \n   begin\n\t   if(!iRST_n)\t     \n\t      state <= IDLE;    \n\t   else \n\t      \n\t      begin\n\t\t\t\tif( (state == IDLE) &&(idle_count > GUIDE_LOW_DUR))  \n\t\t\t\t   state <= GUIDANCE;           \n\t\t\t\telse if ( state == GUIDANCE )      \n\t\t\t\t       begin \n\t\t\t\t         if( state_count > GUIDE_HIGH_DUR )\n\t\t\t\t             state <= DATAREAD;\n\t\t\t\t       end\n\t\t\t\t     else if(state == DATAREAD)    \n\t\t\t\t            begin\n\t\t\t\t\t\t\t\tif( (data_count >= IDLE_HIGH_DUR ) || (bitcount>= 6'b100001) )\n\t\t\t\t\t\t\t\t     state <= IDLE;\n\t                        end\n\t                       else\n\t                          state <= IDLE; \n\t\t\t    \t\t\t\n\t      end\n\t       \n   end\n\n\nalways @(negedge iRST_n or  posedge iCLK)\t\n   begin\n\t  if(!iRST_n)\n\t\t data_count <= 1'b0;  \n\t  else\n\t\t \n\t\t begin\n\t\t    if(data_count_flag)\n\t\t\t\tdata_count <= data_count + 1'b1;\n\t\t\telse \n\t\t\t\tdata_count <= 1'b0;  \n\t\t end\n   end\n\t\t\t\t\t\n\nalways @(negedge iRST_n  or posedge iCLK  )\n\tbegin\n\t   if(!iRST_n) \n\t\t    data_count_flag <= 0;\t\t       \n\t   else\n\t     \t\n\t     \tbegin\n\t\t\t if(state == DATAREAD)\n\t\t\t   begin\n\t\t\t\t if(iIRDA)                 \n\t\t\t\t     data_count_flag <= 1'b1;  \n\t\t\t\t else\n\t\t\t\t     data_count_flag <= 1'b0;  \n\t\t\t   end\n\t\t\t else \n\t\t\t   data_count_flag <= 1'b0;        \n\t     end\n\tend\t\n\n\nalways @(negedge iRST_n or posedge iCLK )\n\tbegin\n\t    if( (!iRST_n) )\n\t        DATA <= 0;      \n\t\telse\n\t\t\t\n\t\t\tbegin \n\t         if (state == DATAREAD )\n\t\t\t  begin\n\t\t\t     if(data_count >= DATA_HIGH_DUR )\n\t\t\t        DATA[bitcount-1'b1] <= 1'b1; \n\t\t\t\t else\t\t\t\t\t\n\t\t\t\t    begin\n\t\t\t\t    if(DATA[bitcount-1'b1]==1)\n\t\t\t\t\t\tDATA[bitcount-1'b1] <= DATA[bitcount-1'b1]; \n\t\t\t\t\telse\n\t\t\t\t\t    DATA[bitcount-1'b1] <= 1'b0;\n\t\t\t\t\tend\n\t\t\t  end\n\t\t\t else\n\t\t\t     DATA <= 0;\n\t\t   end\t\n\tend\t\n\t\n\nalways @(negedge iRST_n or posedge iCLK )\nbegin\n    if (!iRST_n)\n      bitcount <= 1'b0;  \n\telse\n\t  \n\t  begin\n\t    if(state == DATAREAD)\n\t\t\tbegin\n\t\t\t\tif( data_count == 20000 )\n\t\t\t\t\tbitcount <= bitcount + 1'b1; \n\t\t\tend   \n\t    else\n\t       bitcount <= 1'b0;\n\t  end\nend   \n\n\nalways @(negedge iRST_n or posedge iCLK) \nbegin\n\tif(!iRST_n)\n\t   DATA_REAY <=1'b0 ; \n    else\n       \n       begin\n\t\tif(bitcount == 6'b100000)   \n\t\t    begin\n\t\t\t\tif( DATA[31:24]== ~DATA[23:16])\n\t\t\t\t  begin\t\t\n\t\t\t\t\tDATA_BUF <= DATA;   \n\t\t\t\t \tDATA_REAY <= 1'b1;  \n\t\t\t\t  end\t\n\t\t\t\telse\n\t\t\t\t    DATA_REAY <=1'b0 ;  \n\t\t    end\n\t\telse\n\t\t    DATA_REAY <=1'b0 ;          \n\t   end\t\nend\t\n\nalways @(negedge iRST_n or posedge iCLK)\nbegin\n\tif(!iRST_n)\n\t\toDATA <= 32'b0000; \n\t else\n\t begin   \n\t    if(iREAD && DATA_REAY)\n\t       oDATA <= DATA_BUF;  \n\t end\t \nend\t\n\t\t\t\t\t\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: IRDA_RECEIVE_Terasic. \nModule specification: The IRDA_RECEIVE_Terasic module is designed for receiving and decoding IRDA (Infrared Data Association) signals. It processes these signals through state transitions: IDLE, GUIDANCE, and DATAREAD, to detect, synchronize, and decode the incoming data packets based on signal durations. Input ports include iCLK (clock input), iRST_n (active low reset), iIRDA (IRDA data input), and iREAD (data read command). Output ports comprise oDATA_REAY (indicates data readiness), and oDATA (32-bit output data port). Internally, the module utilizes signals such as DATA_REAY (signals data readiness), idle_count and state_count (counters for measuring signal durations in respective states), data_count (counter for data bits duration), bitcount (bit counter for the data packet), and state (tracks the current state of the machine). The module's operations are orchestrated across various blocks handling resets, state transitions, data reading and output generation, where each block manipulates specific counters and flags to control the flow and decoding of IRDA signals, ensuring synchronized data processing and output readiness based on input conditions and internally tracked state."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: IRDA_RECEIVE_Terasic.\n\nExplanation: The module is designed to receive and process IRDA (Infrared Data Association) signals. It operates through different states, namely IDLE, GUIDANCE, and DATAREAD, to detect, synchronize, and decode the incoming IRDA data packets. The module monitors the duration of high and low signals to transition between these states, decoding the data when in the DATAREAD state. It validates the received data byte by checking it against a complementary half stored within the byte, and if valid, the data is passed to an output register, indicating that the data is ready. The module also handles reset conditions and read commands to manage and output the final decoded data."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: iCLK, iRST_n, iIRDA, iREAD.\nExplanation: \n- iCLK: This is the clock input, used to synchronize the operations within the module.\n- iRST_n: This is the active low reset input, used to initialize or reset the module's internal states and counters to their default settings.\n- iIRDA: This is the IRDA input signal, representing the infrared data received. The module uses this signal to decode the IRDA data.\n- iREAD: This input is used to indicate whether the IRDA data that has been processed and stored should be read and outputted from the module.\n\nOutput ports: oDATA_REAY, oDATA.\nExplanation:\n- oDATA_REAY: This is the data ready output signal. It indicates whether the decoded data is ready to be read, which is used externally to determine when to read the data from the output port.\n- oDATA: This is the output data port, which provides the final decoded IRDA data. This port outputs the data when it is signalled as ready through the oDATA_REAY signal and a read command is received via iREAD."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: DATA_REAY, idle_count, idle_count_flag, state_count, state_count_flag, data_count, data_count_flag, bitcount, state, DATA, DATA_BUF, oDATA.\n\nExplanation:\n- DATA_REAY: This signal indicates whether the data is ready to be sent out. It becomes '1' when a complete byte is successfully received and verified, ready to be transferred to the oDATA output when requested.\n- idle_count: This is a counter used to measure the duration of the idle (high) state in the IR signal, helping to transition to the GUIDANCE state if the duration matches specific conditions.\n- idle_count_flag: This flag controls the idle_count. It enables the counter when the system is in the IDLE state and the IRDA signal is low.\n- state_count: A counter used within different states (specifically GUIDANCE) to measure the duration of certain conditions and aid transitions between states.\n- state_count_flag: This flag governs the state_count functionality, enabling or disabling counting based on current conditions aligned with state transitions.\n- data_count: This counter is used in the DATAREAD state to track the duration of the data bits being read.\n- data_count_flag: This flag enables the data_count when the module is in the DATAREAD state and the condition of the incoming data signal requires counting.\n- bitcount: This register counts the number of bits that have been processed in the current packet during the DATAREAD state. It helps determine when a complete data packet has been read.\n- state: This register holds the current state of the machine. The system can be in IDLE, GUIDANCE, or DATAREAD states, controlling the behavior of the module based on the received IRDA signals.\n- DATA: This is a shift register that captures the incoming data bits in the DATAREAD state.\n- DATA_BUF: This buffer stores the validated data byte once a complete byte is read and its complement is verified as correct.\n- oDATA: It's an output register that holds the data to be pushed out through the oDATA port when a read command is issued and the data is available as indicated by DATA_REAY."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule IRDA_RECEIVE_Terasic(\n\t\t\t\t\tiCLK,         \n\t\t\t\t\tiRST_n,       \n\t\t\t\t\t\n\t\t\t\t\tiIRDA,        \n\t\t\t\t\tiREAD,        \n\t\t\t\t\t\n\t\t\t\t\toDATA_REAY,\t  \n\t\t\t\t\toDATA         \n\t\t\t\t\t);\n\t\t\t\t\t\n\nparameter IDLE = 2'b00;           \nparameter GUIDANCE = 2'b01;       \nparameter DATAREAD = 2'b10;       \n\nparameter IDLE_HIGH_DUR      =  262143;  \nparameter GUIDE_LOW_DUR      =  230000;  \nparameter GUIDE_HIGH_DUR     =  210000;  \nparameter DATA_HIGH_DUR      =  41500;\t \nparameter BIT_AVAILABLE_DUR  = 20000;    \n\n\ninput iCLK;    \ninput iRST_n;  \ninput iIRDA;   \ninput iREAD;   \n\noutput  oDATA_REAY;  \noutput [31:0] oDATA; \n\n\n\nreg DATA_REAY;             \n\nreg [17:0] idle_count;     \nreg idle_count_flag;       \n\nreg [17:0] state_count;    \nreg state_count_flag;      \n\nreg [17:0] data_count;     \nreg data_count_flag;       \n\n\nreg [5:0] bitcount;        \nreg [1:0] state;           \nreg [31:0] DATA;           \nreg [31:0] DATA_BUF;       \nreg [31:0] oDATA;          \n\n\n\ninitial\n\tbegin \n\t\tstate =  IDLE;     \n\t\tDATA_REAY = 1'b0;  \n\t\tbitcount = 0;      \n\t\tDATA = 0;          \n\t\tDATA_BUF = 0;      \n\t\tstate_count = 0;   \n\t\tdata_count = 0;    \n\t\tidle_count = 0;    \n\tend\n\t\nassign oDATA_REAY = DATA_REAY;\n\n\nalways @(negedge iRST_n or  posedge iCLK )\t\n   begin\n\t  if(!iRST_n)\n\t\t idle_count <= 0;   \n\t  else\t\t \n\t\t begin\n\t\t    if( idle_count_flag )    \n\t\t\t\tidle_count <= idle_count + 1'b1;\n\t\t\telse  \n\t\t\t\tidle_count <= 0;\t  \n\t\t end\n   end\n\n\n\nalways @( negedge iRST_n  or  posedge iCLK)\t\n   begin\n\t  if( !iRST_n )\n\t\t idle_count_flag <= 1'b0;   \n\t   else\n\t     \n\t     begin\n\t\t\t   if((state == IDLE) &&(!iIRDA))       \n\t\t\t\t\tidle_count_flag <= 1'b1;        \n\t\t\t\telse                                \n\t\t\t\t\tidle_count_flag <= 1'b0;\t\t\n\t\t end\t  \n   end  \n\nalways @(negedge iRST_n or  posedge iCLK )\t\n   begin\n\t  if(!iRST_n)\n\t\t state_count <= 0;   \n\t  else\t\t \n\t\t begin\n\t\t    if( state_count_flag )    \n\t\t\t\tstate_count <= state_count + 1'b1;\n\t\t\telse  \n\t\t\t\tstate_count <= 0;\t  \n\t\t end\n   end\t\n\n\n\nalways @( negedge iRST_n  or  posedge iCLK)\t\n   begin\n\t  if( !iRST_n )\n\t\t state_count_flag <= 1'b0; \n\t   else\n\t     \n\t     begin\n\t\t\t   if((state == GUIDANCE) &&(iIRDA))     \n\t\t\t\t\tstate_count_flag <= 1'b1;       \n\t\t\t\telse   \n\t\t\t\t\tstate_count_flag <= 1'b0;\t\t\n\t\t end\t  \n   end  \n\n\nalways @(negedge iRST_n or posedge iCLK ) \n   begin\n\t   if(!iRST_n)\t     \n\t      state <= IDLE;    \n\t   else \n\t      \n\t      begin\n\t\t\t\tif( (state == IDLE) &&(idle_count > GUIDE_LOW_DUR))  \n\t\t\t\t   state <= GUIDANCE;           \n\t\t\t\telse if ( state == GUIDANCE )      \n\t\t\t\t       begin \n\t\t\t\t         if( state_count > GUIDE_HIGH_DUR )\n\t\t\t\t             state <= DATAREAD;\n\t\t\t\t       end\n\t\t\t\t     else if(state == DATAREAD)    \n\t\t\t\t            begin\n\t\t\t\t\t\t\t\tif( (data_count >= IDLE_HIGH_DUR ) || (bitcount>= 6'b100001) )\n\t\t\t\t\t\t\t\t     state <= IDLE;\n\t                        end\n\t                       else\n\t                          state <= IDLE; \n\t\t\t    \t\t\t\n\t      end\n\t       \n   end\n\n\nalways @(negedge iRST_n or  posedge iCLK)\t\n   begin\n\t  if(!iRST_n)\n\t\t data_count <= 1'b0;  \n\t  else\n\t\t \n\t\t begin\n\t\t    if(data_count_flag)\n\t\t\t\tdata_count <= data_count + 1'b1;\n\t\t\telse \n\t\t\t\tdata_count <= 1'b0;  \n\t\t end\n   end\n\t\t\t\t\t\n\nalways @(negedge iRST_n  or posedge iCLK  )\n\tbegin\n\t   if(!iRST_n) \n\t\t    data_count_flag <= 0;\t\t       \n\t   else\n\t     \t\n\t     \tbegin\n\t\t\t if(state == DATAREAD)\n\t\t\t   begin\n\t\t\t\t if(iIRDA)                 \n\t\t\t\t     data_count_flag <= 1'b1;  \n\t\t\t\t else\n\t\t\t\t     data_count_flag <= 1'b0;  \n\t\t\t   end\n\t\t\t else \n\t\t\t   data_count_flag <= 1'b0;        \n\t     end\n\tend\t\n\n\nalways @(negedge iRST_n or posedge iCLK )\n\tbegin\n\t    if( (!iRST_n) )\n\t        DATA <= 0;      \n\t\telse\n\t\t\t\n\t\t\tbegin \n\t         if (state == DATAREAD )\n\t\t\t  begin\n\t\t\t     if(data_count >= DATA_HIGH_DUR )\n\t\t\t        DATA[bitcount-1'b1] <= 1'b1; \n\t\t\t\t else\t\t\t\t\t\n\t\t\t\t    begin\n\t\t\t\t    if(DATA[bitcount-1'b1]==1)\n\t\t\t\t\t\tDATA[bitcount-1'b1] <= DATA[bitcount-1'b1]; \n\t\t\t\t\telse\n\t\t\t\t\t    DATA[bitcount-1'b1] <= 1'b0;\n\t\t\t\t\tend\n\t\t\t  end\n\t\t\t else\n\t\t\t     DATA <= 0;\n\t\t   end\t\n\tend\t\n\t\n\nalways @(negedge iRST_n or posedge iCLK )\nbegin\n    if (!iRST_n)\n      bitcount <= 1'b0;  \n\telse\n\t  \n\t  begin\n\t    if(state == DATAREAD)\n\t\t\tbegin\n\t\t\t\tif( data_count == 20000 )\n\t\t\t\t\tbitcount <= bitcount + 1'b1; \n\t\t\tend   \n\t    else\n\t       bitcount <= 1'b0;\n\t  end\nend   \n\n\nalways @(negedge iRST_n or posedge iCLK) \nbegin\n\tif(!iRST_n)\n\t   DATA_REAY <=1'b0 ; \n    else\n       \n       begin\n\t\tif(bitcount == 6'b100000)   \n\t\t    begin\n\t\t\t\tif( DATA[31:24]== ~DATA[23:16])\n\t\t\t\t  begin\t\t\n\t\t\t\t\tDATA_BUF <= DATA;   \n\t\t\t\t \tDATA_REAY <= 1'b1;  \n\t\t\t\t  end\t\n\t\t\t\telse\n\t\t\t\t    DATA_REAY <=1'b0 ;  \n\t\t    end\n\t\telse\n\t\t    DATA_REAY <=1'b0 ;          \n\t   end\t\nend\t\n\nalways @(negedge iRST_n or posedge iCLK)\nbegin\n\tif(!iRST_n)\n\t\toDATA <= 32'b0000; \n\t else\n\t begin   \n\t    if(iREAD && DATA_REAY)\n\t       oDATA <= DATA_BUF;  \n\t end\t \nend\t\n\t\t\t\t\t\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: IRDA_RECEIVE_Terasic. \nModule specification: The IRDA_RECEIVE_Terasic module is designed for receiving and decoding IRDA (Infrared Data Association) signals. It processes these signals through state transitions: IDLE, GUIDANCE, and DATAREAD, to detect, synchronize, and decode the incoming data packets based on signal durations. Input ports include iCLK (clock input), iRST_n (active low reset), iIRDA (IRDA data input), and iREAD (data read command). Output ports comprise oDATA_REAY (indicates data readiness), and oDATA (32-bit output data port). Internally, the module utilizes signals such as DATA_REAY (signals data readiness), idle_count and state_count (counters for measuring signal durations in respective states), data_count (counter for data bits duration), bitcount (bit counter for the data packet), and state (tracks the current state of the machine). The module's operations are orchestrated across various blocks handling resets, state transitions, data reading and output generation, where each block manipulates specific counters and flags to control the flow and decoding of IRDA signals, ensuring synchronized data processing and output readiness based on input conditions and internally tracked state."
                }
            ]
        }
    ]
}