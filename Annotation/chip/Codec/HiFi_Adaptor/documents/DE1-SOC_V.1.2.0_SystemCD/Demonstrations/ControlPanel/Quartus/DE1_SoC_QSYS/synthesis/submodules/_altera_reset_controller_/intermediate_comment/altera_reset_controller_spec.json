{
    "spec": "Module name: altera_reset_controller. \nModule specification: The 'altera_reset_controller' is a Verilog module designed to manage and synchronize multiple reset signals across different clock domains or reset conditions within digital systems. The functionality includes handling up to 16 reset inputs (`reset_in0` to `reset_in15`) and optionally 16 reset request inputs (`reset_req_in0` to `reset_req_in15`), conditioned by parameters. It also processes these signals to generate a single, system-wide reset output (`reset_out`) and a reset request output (`reset_req`). Internally, the module uses signals such as `merged_reset` and `merged_reset_req_in` to combine incoming reset signals and requests. It employs synchronization chains (`altera_reset_synchronizer_int_chain`, `r_sync_rst_chain`) to manage the timing and stability of the reset signals, ensuring they are free from glitches and are stable. The module also features conditional generation blocks and adaptation of reset signals based on configurations set by parameters such as `SYNC_DEPTH` and `RESET_REQUEST_PRESENT`. This allows for flexible integration into various system designs requiring robust reset management.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller.\nExplanation: The module 'altera_reset_controller' is designed to handle multiple reset inputs and manage reset synchronization across different clock domains or reset conditions within a digital system. It supports combining several reset request signals and determining the overall system reset state. The parameters allow configuration for the number of reset inputs, specific behaviors like reset request handling, synchronization depth, and timings related to asserting or deasserting resets. The module generates outputs that are synchronized resets based on the logic defined in the code, considering the parameters set and the state of input reset signals and clock. This helps in managing the reset orchestration more reliably in complex FPGA or ASIC designs."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n- reset_in0 to reset_in15, \n- reset_req_in0 to reset_req_in15, \n- clk. \n\nExplanation: \n- `reset_in0` to `reset_in15` are reset input signals from various sources or conditions in the system. These inputs allow the module to monitor multiple reset signals and react accordingly.\n- `reset_req_in0` to `reset_req_in15` are optional reset request inputs. These are used to signal a need for additional reset processing, based on certain conditions specific to the use case. The usage of these signals is optional and controlled by module parameters (`USE_RESET_REQUEST_INx`).\n- `clk` is the clock input for the module. It is used to drive the synchronization of reset signals so that the output reset signals are phase-aligned or adapted to the clock domain in which they will be active.\n\nOutput ports: \n- reset_out, \n- reset_req.\n\nExplanation: \n- `reset_out` is the output reset signal that results from synchronized and optionally combined multiple input reset signals. It is to be connected to other parts of the system that require a clean, debounced, and synchronized reset signal.\n- `reset_req` is the output reset request signal which conditionally behaves based on internal module logic involving input reset requests and sync conditions. This output signal can be used to trigger specific reset related actions or alerts in the system, depending on the design requirements."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n- merged_reset,\n- merged_reset_req_in,\n- reset_out_pre,\n- reset_req_pre,\n- altera_reset_synchronizer_int_chain,\n- r_sync_rst_chain,\n- r_sync_rst,\n- r_early_rst.\n\nExplanation:\n- `merged_reset` is a wire signal that combines all the active reset inputs (`reset_in0` to `reset_in15`) through a logical OR operation. This signal represents a unified view of all reset conditions being monitored by the module.\n- `merged_reset_req_in` is a wire signal that merges all activateable reset request inputs (`reset_req_in0` to `reset_req_in15`) based on the module parameters (`USE_RESET_REQUEST_INx`). It uses logical OR operation conditioned by these parameters to create a singular reset request signal from potentially multiple request sources.\n- `reset_out_pre` and `reset_req_pre` are wire signals used to hold the intermediate states of the reset output and reset request output, respectively. These signals are processed through synchronization logic before being assigned to the final output ports `reset_out` and `reset_req`.\n- `altera_reset_synchronizer_int_chain` is a register array used in the synchronizing mechanism. It holds the delayed states of previous reset inputs to aid in stabilizing the outputs against glitches or metastabilities.\n- `r_sync_rst_chain` is another register array acting similar to a shift register, used to delay the effects of reset synchronization, ensuring that the reset is maintained for a sufficient duration governed by module parameters and internal logic.\n- `r_sync_rst` is a register that holds the state of the synchronized reset based on conditions defined from the shift register outputs and metastable considerations within the module's logic.\n- `r_early_rst` is a register used to determine the final state of the early reset request based on internal module conditions and the processed reset request signals, balancing between immediate needs and stabilized reset signals.\n  \nThese internal signals play crucial roles in managing the timing, stability, and logical conditions required for generating reliable and usable reset signals within digital systems."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_reset_controller. \nModule specification: The 'altera_reset_controller' is a Verilog module designed to manage and synchronize multiple reset signals across different clock domains or reset conditions within digital systems. The functionality includes handling up to 16 reset inputs (`reset_in0` to `reset_in15`) and optionally 16 reset request inputs (`reset_req_in0` to `reset_req_in15`), conditioned by parameters. It also processes these signals to generate a single, system-wide reset output (`reset_out`) and a reset request output (`reset_req`). Internally, the module uses signals such as `merged_reset` and `merged_reset_req_in` to combine incoming reset signals and requests. It employs synchronization chains (`altera_reset_synchronizer_int_chain`, `r_sync_rst_chain`) to manage the timing and stability of the reset signals, ensuring they are free from glitches and are stable. The module also features conditional generation blocks and adaptation of reset signals based on configurations set by parameters such as `SYNC_DEPTH` and `RESET_REQUEST_PRESENT`. This allows for flexible integration into various system designs requiring robust reset management."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller.\nExplanation: The module 'altera_reset_controller' is designed to handle multiple reset inputs and manage reset synchronization across different clock domains or reset conditions within a digital system. It supports combining several reset request signals and determining the overall system reset state. The parameters allow configuration for the number of reset inputs, specific behaviors like reset request handling, synchronization depth, and timings related to asserting or deasserting resets. The module generates outputs that are synchronized resets based on the logic defined in the code, considering the parameters set and the state of input reset signals and clock. This helps in managing the reset orchestration more reliably in complex FPGA or ASIC designs."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n- reset_in0 to reset_in15, \n- reset_req_in0 to reset_req_in15, \n- clk. \n\nExplanation: \n- `reset_in0` to `reset_in15` are reset input signals from various sources or conditions in the system. These inputs allow the module to monitor multiple reset signals and react accordingly.\n- `reset_req_in0` to `reset_req_in15` are optional reset request inputs. These are used to signal a need for additional reset processing, based on certain conditions specific to the use case. The usage of these signals is optional and controlled by module parameters (`USE_RESET_REQUEST_INx`).\n- `clk` is the clock input for the module. It is used to drive the synchronization of reset signals so that the output reset signals are phase-aligned or adapted to the clock domain in which they will be active.\n\nOutput ports: \n- reset_out, \n- reset_req.\n\nExplanation: \n- `reset_out` is the output reset signal that results from synchronized and optionally combined multiple input reset signals. It is to be connected to other parts of the system that require a clean, debounced, and synchronized reset signal.\n- `reset_req` is the output reset request signal which conditionally behaves based on internal module logic involving input reset requests and sync conditions. This output signal can be used to trigger specific reset related actions or alerts in the system, depending on the design requirements."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n- merged_reset,\n- merged_reset_req_in,\n- reset_out_pre,\n- reset_req_pre,\n- altera_reset_synchronizer_int_chain,\n- r_sync_rst_chain,\n- r_sync_rst,\n- r_early_rst.\n\nExplanation:\n- `merged_reset` is a wire signal that combines all the active reset inputs (`reset_in0` to `reset_in15`) through a logical OR operation. This signal represents a unified view of all reset conditions being monitored by the module.\n- `merged_reset_req_in` is a wire signal that merges all activateable reset request inputs (`reset_req_in0` to `reset_req_in15`) based on the module parameters (`USE_RESET_REQUEST_INx`). It uses logical OR operation conditioned by these parameters to create a singular reset request signal from potentially multiple request sources.\n- `reset_out_pre` and `reset_req_pre` are wire signals used to hold the intermediate states of the reset output and reset request output, respectively. These signals are processed through synchronization logic before being assigned to the final output ports `reset_out` and `reset_req`.\n- `altera_reset_synchronizer_int_chain` is a register array used in the synchronizing mechanism. It holds the delayed states of previous reset inputs to aid in stabilizing the outputs against glitches or metastabilities.\n- `r_sync_rst_chain` is another register array acting similar to a shift register, used to delay the effects of reset synchronization, ensuring that the reset is maintained for a sufficient duration governed by module parameters and internal logic.\n- `r_sync_rst` is a register that holds the state of the synchronized reset based on conditions defined from the shift register outputs and metastable considerations within the module's logic.\n- `r_early_rst` is a register used to determine the final state of the early reset request based on internal module conditions and the processed reset request signals, balancing between immediate needs and stabilized reset signals.\n  \nThese internal signals play crucial roles in managing the timing, stability, and logical conditions required for generating reliable and usable reset signals within digital systems."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_reset_controller. \nModule specification: The 'altera_reset_controller' is a Verilog module designed to manage and synchronize multiple reset signals across different clock domains or reset conditions within digital systems. The functionality includes handling up to 16 reset inputs (`reset_in0` to `reset_in15`) and optionally 16 reset request inputs (`reset_req_in0` to `reset_req_in15`), conditioned by parameters. It also processes these signals to generate a single, system-wide reset output (`reset_out`) and a reset request output (`reset_req`). Internally, the module uses signals such as `merged_reset` and `merged_reset_req_in` to combine incoming reset signals and requests. It employs synchronization chains (`altera_reset_synchronizer_int_chain`, `r_sync_rst_chain`) to manage the timing and stability of the reset signals, ensuring they are free from glitches and are stable. The module also features conditional generation blocks and adaptation of reset signals based on configurations set by parameters such as `SYNC_DEPTH` and `RESET_REQUEST_PRESENT`. This allows for flexible integration into various system designs requiring robust reset management."
                }
            ]
        }
    ]
}