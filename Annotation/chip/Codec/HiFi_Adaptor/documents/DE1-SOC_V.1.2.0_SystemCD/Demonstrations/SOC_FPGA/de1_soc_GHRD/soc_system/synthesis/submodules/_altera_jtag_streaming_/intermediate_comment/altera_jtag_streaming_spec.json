{
    "spec": "Module name: altera_jtag_streaming. \n\nModule specification: The \"altera_jtag_streaming\" module facilitates JTAG-based data streaming operations by handling various JTAG transactions using internal state machines, synchronizers, and data processors. This module interacts with input ports such as `tck` (JTAG clock), `reset_n` (active-low reset), `sink_data` (input data from JTAG data register), `sink_valid` (indicates if input data is valid), `clock_to_sample` (alternative sampling clock), `reset_to_sample` (reset for the sampling clock), and `ir_in` (instruction register input which guides the module's operation). The output ports include `tck` (mirrored input JTAG clock), `source_data` (processed output data), `source_valid` (indicates if output data is valid), `sink_ready` (indicates readiness to receive more data), `resetrequest` (can request a system-wide reset), `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data` which pertain to management functionalities activated by the `MGMT_CHANNEL_WIDTH` parameter. Internal signals such as `ir_out`, `tdo`, and `tdi` facilitate JTAG interfacing, while signals like `write_state`, `read_state`, and `scan_length_byte_counter` manage data handling states and byte counts. The module implements blocks for idle data insertion and removal, clock domain synchronization, and optionally, management extensions where management functionalities get triggered by specific JTAG instructions. These functionalities collectively manage JTAG data streaming effectively, making the module suitable for applications requiring robust JTAG transaction handling.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\nExplanation: The module facilitates JTAG-based data streaming operations, particularly handling various JTAG data transactions through its internal state machines and synchronizers. It processes data received over JTAG and handles different transaction types indicated by the JTAG instruction register (ir_in) such as bypass, data, loopback, debug, info, control, and management operations. The module includes mechanisms to sync signals across different clock domains and to process data streams, inserting or removing idle data as necessary. Interfaces to sync clocks and manage reset signals are provided to maintain robust operation in synchronous digital systems. It supports additional management functionalities if a specific parameter (MGMT_CHANNEL_WIDTH) is set greater than zero, allowing more complex management tasks through JTAG."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\n- `tck`: Test Clock Input. Explanation: This is the clock signal for the JTAG interface, used to synchronize data transfer and internal operations within JTAG protocol.\n- `reset_n`: Active Low Reset. Explanation: This signal is used to reset the internal state of the module to an initial state. It ensures the module starts correctly on power-up or after a reset command.\n- `sink_data`: Sink Data Input. Explanation: This port receives data from the JTAG data register, which is then processed based on the current JTAG instruction.\n- `sink_valid`: Sink Data Valid. Explanation: Indicates if the data on the `sink_data` input is valid and should be considered by the module.\n- `clock_to_sample`: Clock for Sampling. Explanation: This external clock signal can be used for operations where the JTAG clock (`tck`) isn't suitable, allowing operations to be synced to another clock domain.\n- `reset_to_sample`: Reset for Sampling Clock. Explanation: This reset signal is used specifically for operations synchronized to the `clock_to_sample` clock, ensuring those elements reset correctly.\n- `ir_in`: Instruction Register Input. Explanation: Holds the current JTAG instruction that guides the operations and state transitions of the module.\n\nOutput ports:\n- `tck`: Test Clock Output. Explanation: Mirrors the input `tck` as an output, potentially for further chaining of JTAG devices.\n- `source_data`: Source Data Output. Explanation: Output data prepared by the module, ready to be sent out to other components or systems.\n- `source_valid`: Source Data Valid. Explanation: Indicates if the data on the `source_data` output port is valid and ready to be consumed by external systems.\n- `sink_ready`: Sink Data Ready. Explanation: Indicates the module is ready to receive more data from the JTAG data register.\n- `resetrequest`: Reset Request Output. Explanation: An optional output that can be used to request a system-wide reset based on specific conditions detected during JTAG operations.\n- `debug_reset`: Debug Reset Signal. Explanation: Used to control or indicate a reset state specifically for debugging purposes, managed by the JTAG management operations if `MGMT_CHANNEL_WIDTH` is configured.\n- `mgmt_valid`: Management Valid Signal. Explanation: Indicates that the management data is valid; used when `MGMT_CHANNEL_WIDTH` is greater than zero for extended management functionalities.\n- `mgmt_channel`: Management Channel Output. Explanation: Specifies the channel or type of management operation being commanded or queried, active with a valid management operation.\n- `mgmt_data`: Management Data Output. Explanation: Carries data related to management operations, used concurrently with `mgmt_valid` and `mgmt_channel` to execute or report management tasks."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n1. `ir_out`\n2. `tdo`\n3. `tdi`\n4. `sdr`\n5. `cdr`\n6. `udr`\n7. `write_state`\n8. `read_state`\n9. `dr_data_in`\n10. `dr_data_out`\n11. `dr_loopback`\n12. `dr_debug`\n13. `dr_info`\n14. `dr_control`\n15. `dr_mgmt`\n16. `padded_bit_counter`\n17. `bypass_bit_counter`\n18. `write_data_bit_counter`\n19. `read_data_bit_counter`\n20. `header_in_bit_counter`\n21. `header_out_bit_counter`\n22. `scan_length_byte_counter`\n23. `valid_write_data_length_byte_counter`\n24. `write_data_valid`\n25. `read_data_valid`\n26. `read_data_all_valid`\n27. `decode_header_1`\n28. `decode_header_2`\n29. `write_data_byte_aligned`\n30. `read_data_byte_aligned`\n31. `padded_bit_byte_aligned`\n32. `bytestream_end`\n33. `offset`\n34. `header_in`\n35. `scan_length`\n36. `read_data_length`\n37. `write_data_length`\n38. `idle_inserter_sink_data`\n39. `idle_inserter_sink_valid`\n40. `idle_inserter_sink_ready`\n41. `idle_inserter_source_data`\n42. `idle_inserter_source_ready`\n43. `idle_remover_sink_data`\n44. `idle_remover_sink_valid`\n45. `idle_remover_source_data`\n46. `idle_remover_source_valid`\n47. `clock_sensor`\n48. `clock_to_sample_div2`\n49. `clock_sense_reset_n`\n50. `data_available`\n51. `decoded_scan_length`\n52. `decoded_write_data_length`\n53. `decoded_read_data_length`\n54. `clock_sensor_sync`\n55. `reset_to_sample_sync`\n56. `clock_to_sample_div2_sync`\n57. `clock_sense_reset_n_sync`\n58. `mgmt_out`\n59. `mgmt_toggle`\n60. `mgmt_toggle_sync`\n61. `mgmt_toggle_prev`\n\n**Explanation:**\n1-6. JTAG protocol interface signals for communication and state control.\n7-8. State machines for managing write and read operations.\n9-15. Data registers for holding various types of data processed or to be transmitted.\n16-32. Counters and state indicators for data flow, header processing, ensuring byte alignment and monitoring the end of data streams.\n33-37. Registers and indicators used for managing headers, data lengths and offsets during data processing.\n38-45. Intermediate signals for stages of data insertion and removal, ensuring control over data flow in and out of the module.\n46-57. Sensing and synchronization signals for working with multiple clock domains, ensuring stable operations across different clock rates.\n58-61. Management operation specific signals, used only when `MGMT_CHANNEL_WIDTH > 0`, for handling management functionalities and synchronizing state changes. \n\nThese signals collectively manage the module's functionality, handle internal state transitions, sync with external devices, and ensure robust JTAG operations."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming (\n    tck,\n    reset_n,\n    \n    source_data,\n    source_valid,\n    \n    sink_data,\n    sink_valid,\n    sink_ready,\n    \n    clock_to_sample,\n    reset_to_sample,\n    \n    resetrequest,\n    \n    debug_reset,\n    mgmt_valid,\n    mgmt_channel,\n    mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    \n    \n    \n    \n    \n    \n    \n    \n    parameter PURPOSE = 0;\n    parameter UPSTREAM_FIFO_SIZE = 0;\n    parameter DOWNSTREAM_FIFO_SIZE = 0;\n    parameter MGMT_CHANNEL_WIDTH = -1;\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    output tck;\n    input  reset_n;\n    output [7:0] source_data;\n    output       source_valid;\n    input [7:0] sink_data;\n    input       sink_valid;\n    output      sink_ready;\n    input clock_to_sample;\n    input reset_to_sample;\n    output reg resetrequest = 1'b0;\n    output wire debug_reset;\n    output reg mgmt_valid;\n    output reg [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n    output reg mgmt_data;\n\n    \n    wire [IRWIDTH - 1 : 0] ir_out;\n    wire [IRWIDTH - 1 : 0] ir_in;\n    reg tdo = 0;\n    wire tdi;\n    wire sdr;\n    wire cdr;\n    wire udr;\n\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (cdr) begin\n                dr_control <= 'b0; \n            end\n            if (sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_jtag_sld_node node (\n        .ir_out             (ir_out),\n        .tdo                (tdo),\n        .ir_in              (ir_in),\n        .tck                (tck),\n        .tdi                (tdi),\n        .virtual_state_cdr  (cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (sdr),\n        .virtual_state_udr  (udr),\n        .virtual_state_uir  ()\n    );\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_jtag_streaming. \n\nModule specification: The \"altera_jtag_streaming\" module facilitates JTAG-based data streaming operations by handling various JTAG transactions using internal state machines, synchronizers, and data processors. This module interacts with input ports such as `tck` (JTAG clock), `reset_n` (active-low reset), `sink_data` (input data from JTAG data register), `sink_valid` (indicates if input data is valid), `clock_to_sample` (alternative sampling clock), `reset_to_sample` (reset for the sampling clock), and `ir_in` (instruction register input which guides the module's operation). The output ports include `tck` (mirrored input JTAG clock), `source_data` (processed output data), `source_valid` (indicates if output data is valid), `sink_ready` (indicates readiness to receive more data), `resetrequest` (can request a system-wide reset), `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data` which pertain to management functionalities activated by the `MGMT_CHANNEL_WIDTH` parameter. Internal signals such as `ir_out`, `tdo`, and `tdi` facilitate JTAG interfacing, while signals like `write_state`, `read_state`, and `scan_length_byte_counter` manage data handling states and byte counts. The module implements blocks for idle data insertion and removal, clock domain synchronization, and optionally, management extensions where management functionalities get triggered by specific JTAG instructions. These functionalities collectively manage JTAG data streaming effectively, making the module suitable for applications requiring robust JTAG transaction handling."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\nExplanation: The module facilitates JTAG-based data streaming operations, particularly handling various JTAG data transactions through its internal state machines and synchronizers. It processes data received over JTAG and handles different transaction types indicated by the JTAG instruction register (ir_in) such as bypass, data, loopback, debug, info, control, and management operations. The module includes mechanisms to sync signals across different clock domains and to process data streams, inserting or removing idle data as necessary. Interfaces to sync clocks and manage reset signals are provided to maintain robust operation in synchronous digital systems. It supports additional management functionalities if a specific parameter (MGMT_CHANNEL_WIDTH) is set greater than zero, allowing more complex management tasks through JTAG."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\n- `tck`: Test Clock Input. Explanation: This is the clock signal for the JTAG interface, used to synchronize data transfer and internal operations within JTAG protocol.\n- `reset_n`: Active Low Reset. Explanation: This signal is used to reset the internal state of the module to an initial state. It ensures the module starts correctly on power-up or after a reset command.\n- `sink_data`: Sink Data Input. Explanation: This port receives data from the JTAG data register, which is then processed based on the current JTAG instruction.\n- `sink_valid`: Sink Data Valid. Explanation: Indicates if the data on the `sink_data` input is valid and should be considered by the module.\n- `clock_to_sample`: Clock for Sampling. Explanation: This external clock signal can be used for operations where the JTAG clock (`tck`) isn't suitable, allowing operations to be synced to another clock domain.\n- `reset_to_sample`: Reset for Sampling Clock. Explanation: This reset signal is used specifically for operations synchronized to the `clock_to_sample` clock, ensuring those elements reset correctly.\n- `ir_in`: Instruction Register Input. Explanation: Holds the current JTAG instruction that guides the operations and state transitions of the module.\n\nOutput ports:\n- `tck`: Test Clock Output. Explanation: Mirrors the input `tck` as an output, potentially for further chaining of JTAG devices.\n- `source_data`: Source Data Output. Explanation: Output data prepared by the module, ready to be sent out to other components or systems.\n- `source_valid`: Source Data Valid. Explanation: Indicates if the data on the `source_data` output port is valid and ready to be consumed by external systems.\n- `sink_ready`: Sink Data Ready. Explanation: Indicates the module is ready to receive more data from the JTAG data register.\n- `resetrequest`: Reset Request Output. Explanation: An optional output that can be used to request a system-wide reset based on specific conditions detected during JTAG operations.\n- `debug_reset`: Debug Reset Signal. Explanation: Used to control or indicate a reset state specifically for debugging purposes, managed by the JTAG management operations if `MGMT_CHANNEL_WIDTH` is configured.\n- `mgmt_valid`: Management Valid Signal. Explanation: Indicates that the management data is valid; used when `MGMT_CHANNEL_WIDTH` is greater than zero for extended management functionalities.\n- `mgmt_channel`: Management Channel Output. Explanation: Specifies the channel or type of management operation being commanded or queried, active with a valid management operation.\n- `mgmt_data`: Management Data Output. Explanation: Carries data related to management operations, used concurrently with `mgmt_valid` and `mgmt_channel` to execute or report management tasks."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n1. `ir_out`\n2. `tdo`\n3. `tdi`\n4. `sdr`\n5. `cdr`\n6. `udr`\n7. `write_state`\n8. `read_state`\n9. `dr_data_in`\n10. `dr_data_out`\n11. `dr_loopback`\n12. `dr_debug`\n13. `dr_info`\n14. `dr_control`\n15. `dr_mgmt`\n16. `padded_bit_counter`\n17. `bypass_bit_counter`\n18. `write_data_bit_counter`\n19. `read_data_bit_counter`\n20. `header_in_bit_counter`\n21. `header_out_bit_counter`\n22. `scan_length_byte_counter`\n23. `valid_write_data_length_byte_counter`\n24. `write_data_valid`\n25. `read_data_valid`\n26. `read_data_all_valid`\n27. `decode_header_1`\n28. `decode_header_2`\n29. `write_data_byte_aligned`\n30. `read_data_byte_aligned`\n31. `padded_bit_byte_aligned`\n32. `bytestream_end`\n33. `offset`\n34. `header_in`\n35. `scan_length`\n36. `read_data_length`\n37. `write_data_length`\n38. `idle_inserter_sink_data`\n39. `idle_inserter_sink_valid`\n40. `idle_inserter_sink_ready`\n41. `idle_inserter_source_data`\n42. `idle_inserter_source_ready`\n43. `idle_remover_sink_data`\n44. `idle_remover_sink_valid`\n45. `idle_remover_source_data`\n46. `idle_remover_source_valid`\n47. `clock_sensor`\n48. `clock_to_sample_div2`\n49. `clock_sense_reset_n`\n50. `data_available`\n51. `decoded_scan_length`\n52. `decoded_write_data_length`\n53. `decoded_read_data_length`\n54. `clock_sensor_sync`\n55. `reset_to_sample_sync`\n56. `clock_to_sample_div2_sync`\n57. `clock_sense_reset_n_sync`\n58. `mgmt_out`\n59. `mgmt_toggle`\n60. `mgmt_toggle_sync`\n61. `mgmt_toggle_prev`\n\n**Explanation:**\n1-6. JTAG protocol interface signals for communication and state control.\n7-8. State machines for managing write and read operations.\n9-15. Data registers for holding various types of data processed or to be transmitted.\n16-32. Counters and state indicators for data flow, header processing, ensuring byte alignment and monitoring the end of data streams.\n33-37. Registers and indicators used for managing headers, data lengths and offsets during data processing.\n38-45. Intermediate signals for stages of data insertion and removal, ensuring control over data flow in and out of the module.\n46-57. Sensing and synchronization signals for working with multiple clock domains, ensuring stable operations across different clock rates.\n58-61. Management operation specific signals, used only when `MGMT_CHANNEL_WIDTH > 0`, for handling management functionalities and synchronizing state changes. \n\nThese signals collectively manage the module's functionality, handle internal state transitions, sync with external devices, and ensure robust JTAG operations."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming (\n    tck,\n    reset_n,\n    \n    source_data,\n    source_valid,\n    \n    sink_data,\n    sink_valid,\n    sink_ready,\n    \n    clock_to_sample,\n    reset_to_sample,\n    \n    resetrequest,\n    \n    debug_reset,\n    mgmt_valid,\n    mgmt_channel,\n    mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    \n    \n    \n    \n    \n    \n    \n    \n    parameter PURPOSE = 0;\n    parameter UPSTREAM_FIFO_SIZE = 0;\n    parameter DOWNSTREAM_FIFO_SIZE = 0;\n    parameter MGMT_CHANNEL_WIDTH = -1;\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    output tck;\n    input  reset_n;\n    output [7:0] source_data;\n    output       source_valid;\n    input [7:0] sink_data;\n    input       sink_valid;\n    output      sink_ready;\n    input clock_to_sample;\n    input reset_to_sample;\n    output reg resetrequest = 1'b0;\n    output wire debug_reset;\n    output reg mgmt_valid;\n    output reg [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n    output reg mgmt_data;\n\n    \n    wire [IRWIDTH - 1 : 0] ir_out;\n    wire [IRWIDTH - 1 : 0] ir_in;\n    reg tdo = 0;\n    wire tdi;\n    wire sdr;\n    wire cdr;\n    wire udr;\n\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (cdr) begin\n                dr_control <= 'b0; \n            end\n            if (sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_jtag_sld_node node (\n        .ir_out             (ir_out),\n        .tdo                (tdo),\n        .ir_in              (ir_in),\n        .tck                (tck),\n        .tdi                (tdi),\n        .virtual_state_cdr  (cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (sdr),\n        .virtual_state_udr  (udr),\n        .virtual_state_uir  ()\n    );\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_jtag_streaming. \n\nModule specification: The \"altera_jtag_streaming\" module facilitates JTAG-based data streaming operations by handling various JTAG transactions using internal state machines, synchronizers, and data processors. This module interacts with input ports such as `tck` (JTAG clock), `reset_n` (active-low reset), `sink_data` (input data from JTAG data register), `sink_valid` (indicates if input data is valid), `clock_to_sample` (alternative sampling clock), `reset_to_sample` (reset for the sampling clock), and `ir_in` (instruction register input which guides the module's operation). The output ports include `tck` (mirrored input JTAG clock), `source_data` (processed output data), `source_valid` (indicates if output data is valid), `sink_ready` (indicates readiness to receive more data), `resetrequest` (can request a system-wide reset), `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data` which pertain to management functionalities activated by the `MGMT_CHANNEL_WIDTH` parameter. Internal signals such as `ir_out`, `tdo`, and `tdi` facilitate JTAG interfacing, while signals like `write_state`, `read_state`, and `scan_length_byte_counter` manage data handling states and byte counts. The module implements blocks for idle data insertion and removal, clock domain synchronization, and optionally, management extensions where management functionalities get triggered by specific JTAG instructions. These functionalities collectively manage JTAG data streaming effectively, making the module suitable for applications requiring robust JTAG transaction handling."
                }
            ]
        }
    ]
}