{
    "spec": "Module name: altera_jtag_dc_streaming. \nModule specification: The altera_jtag_dc_streaming module serves as an interface between JTAG-related data streams and system logic, including elements for synchronization and control. It manages streaming data, handles clock domain crossings between JTAG and system clocks, manages reset and debug signals, and accommodates for management data and channel control. The input ports include `clk` (system clock), `reset_n` (active-low reset), `sink_data` (data from system to JTAG), `sink_valid` (validity of sink data), and `sink_ready` (readiness of the JTAG to receive data). The output ports encompass `source_data` and `source_valid` (data and its validity flag from JTAG to the system), `resetrequest`, `debug_reset` (reset control for debugging), and `mgmt_data`, `mgmt_valid`, `mgmt_channel` (management data and signals). Internal signals such as `jtag_clock`, `jtag_clock_reset_n`, `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` facilitate operations within different clock domains and synchronization purposes. The module consists of several internal blocks: synchronizers and crossers (like `altera_std_synchronizer`, `altera_jtag_streaming`, `altera_avalon_st_clock_crosser`, `altera_jtag_src_crosser`) to manage the safe crossing of data between asynchronous clock domains and to ensure the integrity and stability of the data transmitted across these interfaces.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_dc_streaming.\nExplanation: This module interfaces JTAG-related data streams with system logic, ensuring proper synchronization and control. It includes functionality for streaming data, managing reset and debug signals, and handling clock domain crossings between JTAG and system clocks. The module uses nested sub-modules such as synchronizers and clock crossers to effectively manage timing and data integrity across different clock domains, making it suitable for applications that require reliable data exchange between JTAG and system environments, while also providing management and debug capabilities."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\n- `clk`: This is the system clock input.\n- `reset_n`: This is the active-low system reset input.\n- `sink_data`: This is the input data from the system to the JTAG.\n- `sink_valid`: This is the valid signal for the `sink_data`.\n- `sink_ready`: This is the ready signal from JTAG to accept the `sink_data`.\n\nExplanation:\n- `clk` provides the main timing reference for the module's operations inside the system clock domain.\n- `reset_n` is used to initialize or reset the system logic and synchronizers to a known state when asserted.\n- `sink_data` represents the data being sent from the system to the JTAG interface.\n- `sink_valid` indicates when the `sink_data` is valid and ready to be processed.\n- `sink_ready` indicates the readiness of the JTAG interface to receive data.\n\nOutput ports:\n- `source_data`: This is the output data from the JTAG to the system.\n- `source_valid`: This is the valid signal for the `source_data`.\n- `resetrequest`: This is the reset request signal generated based on JTAG interaction.\n- `debug_reset`: This is the debug reset signal controlled via JTAG for debugging purposes.\n- `mgmt_valid`: This indicates the validity of management data and control signals.\n- `mgmt_data`: This carries specific management data or control signals.\n- `mgmt_channel`: This is a channel or identifier for management data.\n\nExplanation:\n- `source_data` carries data from the JTAG to the system, completing the data interaction cycle.\n- `source_valid` signals the validity of the `source_data` being sent to the system.\n- `resetrequest` allows the module to request a system reset based on conditions derived from JTAG.\n- `debug_reset` provides a mechanism to reset system components for debugging purposes.\n- `mgmt_valid` asserts the validity of the management data or signals being sent.\n- `mgmt_data` and `mgmt_channel` are used for passing management-specific data and identifying the management channels respectively, facilitating enhanced control and monitoring via JTAG."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n- `jtag_clock`\n- `jtag_clock_reset_n`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_data`\n- `jtag_sink_valid`\n- `jtag_sink_ready`\n\nExplanation:\n- `jtag_clock`: This is an internal signal likely used as the clock for the JTAG-related operations. Its role is crucial as it might be derived or related to the JTAG operations clock, potentially different from the system clock `clk`.\n- `jtag_clock_reset_n`: This signal serves as the reset for the JTAG clock domain, synchronized from the system reset `reset_n`. Its purpose is to ensure that all operations within the JTAG clock domain start in a known state.\n- `jtag_source_data`: This holds the data being sourced from JTAG to the system. It is a key component in transferring data out of the JTAG domain.\n- `jtag_source_valid`: Acts as a validity flag for `jtag_source_data`, signaling when the data is valid and should be processed by the receiving system.\n- `jtag_sink_data`: This carries the data destined for JTAG from the system. It is crucial for delivering system-side data into the JTAG domain for processing or response.\n- `jtag_sink_valid`: Signals that `jtag_sink_data` is valid and ready for the JTAG domain to process.\n- `jtag_sink_ready`: Provides feedback on the readiness of the JTAG domain to accept data, managing the flow control of data from the system to JTAG."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_jtag_control_signal_crosser (\n   clk,\n   reset_n,\n   async_control_signal,\n   sense_pos_edge,\n   sync_control_signal\n);\n   input  clk;\n   input  reset_n;\n   input  async_control_signal;\n   input  sense_pos_edge;\n   output sync_control_signal;\n\n   parameter SYNC_DEPTH = 3; \n\n   reg sync_control_signal;\n\n   wire synchronized_raw_signal;\n   reg  edge_detector_register;\n\n   altera_std_synchronizer #(.depth(SYNC_DEPTH)) synchronizer (\n       .clk(clk),\n       .reset_n(reset_n),\n       .din(async_control_signal),\n       .dout(synchronized_raw_signal)\n   );\n\n  always @ (posedge clk or negedge reset_n)\n    if (~reset_n)\n      edge_detector_register <= 1'b0;\n    else\n      edge_detector_register <= synchronized_raw_signal;\n\n  always @* begin\n    if (sense_pos_edge)\n      sync_control_signal <= ~edge_detector_register & synchronized_raw_signal;\n    else\n      sync_control_signal <= edge_detector_register & ~synchronized_raw_signal;\n  end\nendmodule\n\n\nmodule altera_jtag_src_crosser (\n   sink_clk,\n   sink_reset_n,\n   sink_valid,\n   sink_data,\n   src_clk,\n   src_reset_n,\n   src_valid,\n   src_data\n);\n   parameter WIDTH = 8;\n   parameter SYNC_DEPTH = 3; \n\n   input              sink_clk;\n   input              sink_reset_n;\n   input              sink_valid;\n   input [WIDTH-1:0]  sink_data;\n   input              src_clk;\n   input              src_reset_n;\n   output             src_valid;\n   output [WIDTH-1:0] src_data;\n\n   reg              sink_valid_buffer;\n   reg [WIDTH-1:0]  sink_data_buffer;\n\n   reg              src_valid;\n   reg [WIDTH-1:0]  src_data ;\n\n   wire synchronized_valid;\n\n   altera_jtag_control_signal_crosser #(\n     .SYNC_DEPTH(SYNC_DEPTH)\n   ) crosser (\n       .clk(src_clk),\n       .reset_n(src_reset_n),\n       .async_control_signal(sink_valid_buffer),\n       .sense_pos_edge(1'b1),\n       .sync_control_signal(synchronized_valid)\n   );\n   always @ (posedge sink_clk or negedge sink_reset_n) begin\n      if (~sink_reset_n) begin\n         sink_valid_buffer <= 1'b0;\n         sink_data_buffer <= 'b0;\n      end else begin\n         sink_valid_buffer <= sink_valid;\n         if (sink_valid) begin\n           sink_data_buffer <= sink_data;\n         end\n      end \n   end \n\n   always @ (posedge src_clk or negedge src_reset_n) begin\n      if (~src_reset_n) begin\n     src_valid <= 1'b0;\n     src_data <= {WIDTH{1'b0}};\n      end else begin\n     src_valid <= synchronized_valid;\n     src_data <= synchronized_valid ? sink_data_buffer : src_data;\n      end\n   end\n\nendmodule\n\nmodule altera_jtag_dc_streaming (\n                 clk,\n                 reset_n,\n                 source_data,\n                 source_valid,\n                 sink_data,\n                 sink_valid,\n                 sink_ready,\n                 resetrequest,\n\t\t\t\t debug_reset,\n\t\t\t\t mgmt_valid,\n\t\t\t\t mgmt_channel,\n\t\t\t\t mgmt_data\n                 );\n   input        clk;\n   input        reset_n;\n   output [7:0] source_data;\n   output       source_valid;\n   input [7:0]  sink_data;\n   input        sink_valid;\n   output       sink_ready;\n   output       resetrequest;\n   output       debug_reset;\n   output       mgmt_valid;\n   output       mgmt_data;\n\n   parameter PURPOSE = 0; \n   parameter UPSTREAM_FIFO_SIZE = 0;\n   parameter DOWNSTREAM_FIFO_SIZE = 0;\n   parameter MGMT_CHANNEL_WIDTH = -1;\n   \n   \n   \n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   \n   \n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n   output [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n   \n   \n   wire       jtag_clock;\n   wire       jtag_clock_reset_n; \n   wire [7:0] jtag_source_data;\n   wire       jtag_source_valid;\n   wire [7:0] jtag_sink_data;\n   wire       jtag_sink_valid;\n   wire       jtag_sink_ready;\n\n   \n\n\n\n\n\n\n\n\n\n   altera_std_synchronizer #(\n       .depth(SYSCLK_TO_TCK_SYNC_DEPTH)\n   ) synchronizer (\n       .clk(jtag_clock),\n       .reset_n(reset_n),\n       .din(1'b1),\n       .dout(jtag_clock_reset_n)\n   );\n\n   altera_jtag_streaming #(\n       .PURPOSE(PURPOSE),\n       .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n       .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n       .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n   ) jtag_streaming (\n       .tck(jtag_clock),\n       .reset_n(jtag_clock_reset_n),\n       .source_data(jtag_source_data),\n       .source_valid(jtag_source_valid),\n       .sink_data(jtag_sink_data),\n       .sink_valid(jtag_sink_valid),\n       .sink_ready(jtag_sink_ready),\n       .clock_to_sample(clk),\n       .reset_to_sample(reset_n),\n       .resetrequest(resetrequest),\n       .debug_reset(debug_reset),\n       .mgmt_valid(mgmt_valid),\n       .mgmt_channel(mgmt_channel),\n       .mgmt_data(mgmt_data)\n    );\n\n   \n\n   altera_avalon_st_clock_crosser #(\n       .SYMBOLS_PER_BEAT(1),\n       .BITS_PER_SYMBOL(8),\n       .FORWARD_SYNC_DEPTH(SYSCLK_TO_TCK_SYNC_DEPTH),\n       .BACKWARD_SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) sink_crosser (\n       .in_clk(clk),\n       .in_reset(~reset_n),\n       .in_data(sink_data),\n       .in_ready(sink_ready),\n       .in_valid(sink_valid),\n       .out_clk(jtag_clock),\n       .out_reset(~jtag_clock_reset_n),\n       .out_data(jtag_sink_data),\n       .out_ready(jtag_sink_ready),\n       .out_valid(jtag_sink_valid)\n   );\n\n   altera_jtag_src_crosser #(\n       .SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) source_crosser (\n       .sink_clk(jtag_clock),\n       .sink_reset_n(jtag_clock_reset_n),\n       .sink_valid(jtag_source_valid),\n       .sink_data(jtag_source_data),\n       .src_clk(clk),\n       .src_reset_n(reset_n),\n       .src_valid(source_valid),\n       .src_data(source_data)\n   );\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_jtag_dc_streaming. \nModule specification: The altera_jtag_dc_streaming module serves as an interface between JTAG-related data streams and system logic, including elements for synchronization and control. It manages streaming data, handles clock domain crossings between JTAG and system clocks, manages reset and debug signals, and accommodates for management data and channel control. The input ports include `clk` (system clock), `reset_n` (active-low reset), `sink_data` (data from system to JTAG), `sink_valid` (validity of sink data), and `sink_ready` (readiness of the JTAG to receive data). The output ports encompass `source_data` and `source_valid` (data and its validity flag from JTAG to the system), `resetrequest`, `debug_reset` (reset control for debugging), and `mgmt_data`, `mgmt_valid`, `mgmt_channel` (management data and signals). Internal signals such as `jtag_clock`, `jtag_clock_reset_n`, `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` facilitate operations within different clock domains and synchronization purposes. The module consists of several internal blocks: synchronizers and crossers (like `altera_std_synchronizer`, `altera_jtag_streaming`, `altera_avalon_st_clock_crosser`, `altera_jtag_src_crosser`) to manage the safe crossing of data between asynchronous clock domains and to ensure the integrity and stability of the data transmitted across these interfaces."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_dc_streaming.\nExplanation: This module interfaces JTAG-related data streams with system logic, ensuring proper synchronization and control. It includes functionality for streaming data, managing reset and debug signals, and handling clock domain crossings between JTAG and system clocks. The module uses nested sub-modules such as synchronizers and clock crossers to effectively manage timing and data integrity across different clock domains, making it suitable for applications that require reliable data exchange between JTAG and system environments, while also providing management and debug capabilities."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\n- `clk`: This is the system clock input.\n- `reset_n`: This is the active-low system reset input.\n- `sink_data`: This is the input data from the system to the JTAG.\n- `sink_valid`: This is the valid signal for the `sink_data`.\n- `sink_ready`: This is the ready signal from JTAG to accept the `sink_data`.\n\nExplanation:\n- `clk` provides the main timing reference for the module's operations inside the system clock domain.\n- `reset_n` is used to initialize or reset the system logic and synchronizers to a known state when asserted.\n- `sink_data` represents the data being sent from the system to the JTAG interface.\n- `sink_valid` indicates when the `sink_data` is valid and ready to be processed.\n- `sink_ready` indicates the readiness of the JTAG interface to receive data.\n\nOutput ports:\n- `source_data`: This is the output data from the JTAG to the system.\n- `source_valid`: This is the valid signal for the `source_data`.\n- `resetrequest`: This is the reset request signal generated based on JTAG interaction.\n- `debug_reset`: This is the debug reset signal controlled via JTAG for debugging purposes.\n- `mgmt_valid`: This indicates the validity of management data and control signals.\n- `mgmt_data`: This carries specific management data or control signals.\n- `mgmt_channel`: This is a channel or identifier for management data.\n\nExplanation:\n- `source_data` carries data from the JTAG to the system, completing the data interaction cycle.\n- `source_valid` signals the validity of the `source_data` being sent to the system.\n- `resetrequest` allows the module to request a system reset based on conditions derived from JTAG.\n- `debug_reset` provides a mechanism to reset system components for debugging purposes.\n- `mgmt_valid` asserts the validity of the management data or signals being sent.\n- `mgmt_data` and `mgmt_channel` are used for passing management-specific data and identifying the management channels respectively, facilitating enhanced control and monitoring via JTAG."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n- `jtag_clock`\n- `jtag_clock_reset_n`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_data`\n- `jtag_sink_valid`\n- `jtag_sink_ready`\n\nExplanation:\n- `jtag_clock`: This is an internal signal likely used as the clock for the JTAG-related operations. Its role is crucial as it might be derived or related to the JTAG operations clock, potentially different from the system clock `clk`.\n- `jtag_clock_reset_n`: This signal serves as the reset for the JTAG clock domain, synchronized from the system reset `reset_n`. Its purpose is to ensure that all operations within the JTAG clock domain start in a known state.\n- `jtag_source_data`: This holds the data being sourced from JTAG to the system. It is a key component in transferring data out of the JTAG domain.\n- `jtag_source_valid`: Acts as a validity flag for `jtag_source_data`, signaling when the data is valid and should be processed by the receiving system.\n- `jtag_sink_data`: This carries the data destined for JTAG from the system. It is crucial for delivering system-side data into the JTAG domain for processing or response.\n- `jtag_sink_valid`: Signals that `jtag_sink_data` is valid and ready for the JTAG domain to process.\n- `jtag_sink_ready`: Provides feedback on the readiness of the JTAG domain to accept data, managing the flow control of data from the system to JTAG."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_jtag_control_signal_crosser (\n   clk,\n   reset_n,\n   async_control_signal,\n   sense_pos_edge,\n   sync_control_signal\n);\n   input  clk;\n   input  reset_n;\n   input  async_control_signal;\n   input  sense_pos_edge;\n   output sync_control_signal;\n\n   parameter SYNC_DEPTH = 3; \n\n   reg sync_control_signal;\n\n   wire synchronized_raw_signal;\n   reg  edge_detector_register;\n\n   altera_std_synchronizer #(.depth(SYNC_DEPTH)) synchronizer (\n       .clk(clk),\n       .reset_n(reset_n),\n       .din(async_control_signal),\n       .dout(synchronized_raw_signal)\n   );\n\n  always @ (posedge clk or negedge reset_n)\n    if (~reset_n)\n      edge_detector_register <= 1'b0;\n    else\n      edge_detector_register <= synchronized_raw_signal;\n\n  always @* begin\n    if (sense_pos_edge)\n      sync_control_signal <= ~edge_detector_register & synchronized_raw_signal;\n    else\n      sync_control_signal <= edge_detector_register & ~synchronized_raw_signal;\n  end\nendmodule\n\n\nmodule altera_jtag_src_crosser (\n   sink_clk,\n   sink_reset_n,\n   sink_valid,\n   sink_data,\n   src_clk,\n   src_reset_n,\n   src_valid,\n   src_data\n);\n   parameter WIDTH = 8;\n   parameter SYNC_DEPTH = 3; \n\n   input              sink_clk;\n   input              sink_reset_n;\n   input              sink_valid;\n   input [WIDTH-1:0]  sink_data;\n   input              src_clk;\n   input              src_reset_n;\n   output             src_valid;\n   output [WIDTH-1:0] src_data;\n\n   reg              sink_valid_buffer;\n   reg [WIDTH-1:0]  sink_data_buffer;\n\n   reg              src_valid;\n   reg [WIDTH-1:0]  src_data ;\n\n   wire synchronized_valid;\n\n   altera_jtag_control_signal_crosser #(\n     .SYNC_DEPTH(SYNC_DEPTH)\n   ) crosser (\n       .clk(src_clk),\n       .reset_n(src_reset_n),\n       .async_control_signal(sink_valid_buffer),\n       .sense_pos_edge(1'b1),\n       .sync_control_signal(synchronized_valid)\n   );\n   always @ (posedge sink_clk or negedge sink_reset_n) begin\n      if (~sink_reset_n) begin\n         sink_valid_buffer <= 1'b0;\n         sink_data_buffer <= 'b0;\n      end else begin\n         sink_valid_buffer <= sink_valid;\n         if (sink_valid) begin\n           sink_data_buffer <= sink_data;\n         end\n      end \n   end \n\n   always @ (posedge src_clk or negedge src_reset_n) begin\n      if (~src_reset_n) begin\n     src_valid <= 1'b0;\n     src_data <= {WIDTH{1'b0}};\n      end else begin\n     src_valid <= synchronized_valid;\n     src_data <= synchronized_valid ? sink_data_buffer : src_data;\n      end\n   end\n\nendmodule\n\nmodule altera_jtag_dc_streaming (\n                 clk,\n                 reset_n,\n                 source_data,\n                 source_valid,\n                 sink_data,\n                 sink_valid,\n                 sink_ready,\n                 resetrequest,\n\t\t\t\t debug_reset,\n\t\t\t\t mgmt_valid,\n\t\t\t\t mgmt_channel,\n\t\t\t\t mgmt_data\n                 );\n   input        clk;\n   input        reset_n;\n   output [7:0] source_data;\n   output       source_valid;\n   input [7:0]  sink_data;\n   input        sink_valid;\n   output       sink_ready;\n   output       resetrequest;\n   output       debug_reset;\n   output       mgmt_valid;\n   output       mgmt_data;\n\n   parameter PURPOSE = 0; \n   parameter UPSTREAM_FIFO_SIZE = 0;\n   parameter DOWNSTREAM_FIFO_SIZE = 0;\n   parameter MGMT_CHANNEL_WIDTH = -1;\n   \n   \n   \n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   \n   \n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n   output [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n   \n   \n   wire       jtag_clock;\n   wire       jtag_clock_reset_n; \n   wire [7:0] jtag_source_data;\n   wire       jtag_source_valid;\n   wire [7:0] jtag_sink_data;\n   wire       jtag_sink_valid;\n   wire       jtag_sink_ready;\n\n   \n\n\n\n\n\n\n\n\n\n   altera_std_synchronizer #(\n       .depth(SYSCLK_TO_TCK_SYNC_DEPTH)\n   ) synchronizer (\n       .clk(jtag_clock),\n       .reset_n(reset_n),\n       .din(1'b1),\n       .dout(jtag_clock_reset_n)\n   );\n\n   altera_jtag_streaming #(\n       .PURPOSE(PURPOSE),\n       .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n       .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n       .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n   ) jtag_streaming (\n       .tck(jtag_clock),\n       .reset_n(jtag_clock_reset_n),\n       .source_data(jtag_source_data),\n       .source_valid(jtag_source_valid),\n       .sink_data(jtag_sink_data),\n       .sink_valid(jtag_sink_valid),\n       .sink_ready(jtag_sink_ready),\n       .clock_to_sample(clk),\n       .reset_to_sample(reset_n),\n       .resetrequest(resetrequest),\n       .debug_reset(debug_reset),\n       .mgmt_valid(mgmt_valid),\n       .mgmt_channel(mgmt_channel),\n       .mgmt_data(mgmt_data)\n    );\n\n   \n\n   altera_avalon_st_clock_crosser #(\n       .SYMBOLS_PER_BEAT(1),\n       .BITS_PER_SYMBOL(8),\n       .FORWARD_SYNC_DEPTH(SYSCLK_TO_TCK_SYNC_DEPTH),\n       .BACKWARD_SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) sink_crosser (\n       .in_clk(clk),\n       .in_reset(~reset_n),\n       .in_data(sink_data),\n       .in_ready(sink_ready),\n       .in_valid(sink_valid),\n       .out_clk(jtag_clock),\n       .out_reset(~jtag_clock_reset_n),\n       .out_data(jtag_sink_data),\n       .out_ready(jtag_sink_ready),\n       .out_valid(jtag_sink_valid)\n   );\n\n   altera_jtag_src_crosser #(\n       .SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) source_crosser (\n       .sink_clk(jtag_clock),\n       .sink_reset_n(jtag_clock_reset_n),\n       .sink_valid(jtag_source_valid),\n       .sink_data(jtag_source_data),\n       .src_clk(clk),\n       .src_reset_n(reset_n),\n       .src_valid(source_valid),\n       .src_data(source_data)\n   );\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_jtag_dc_streaming. \nModule specification: The altera_jtag_dc_streaming module serves as an interface between JTAG-related data streams and system logic, including elements for synchronization and control. It manages streaming data, handles clock domain crossings between JTAG and system clocks, manages reset and debug signals, and accommodates for management data and channel control. The input ports include `clk` (system clock), `reset_n` (active-low reset), `sink_data` (data from system to JTAG), `sink_valid` (validity of sink data), and `sink_ready` (readiness of the JTAG to receive data). The output ports encompass `source_data` and `source_valid` (data and its validity flag from JTAG to the system), `resetrequest`, `debug_reset` (reset control for debugging), and `mgmt_data`, `mgmt_valid`, `mgmt_channel` (management data and signals). Internal signals such as `jtag_clock`, `jtag_clock_reset_n`, `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` facilitate operations within different clock domains and synchronization purposes. The module consists of several internal blocks: synchronizers and crossers (like `altera_std_synchronizer`, `altera_jtag_streaming`, `altera_avalon_st_clock_crosser`, `altera_jtag_src_crosser`) to manage the safe crossing of data between asynchronous clock domains and to ensure the integrity and stability of the data transmitted across these interfaces."
                }
            ]
        }
    ]
}