{
    "spec": "Module name: altera_jtag_streaming. \nModule specification: The `altera_jtag_streaming` module manages JTAG streaming for coordination of data transfers between JTAG and system logic, aimed at debug transports or data communication paths. It handles various operations such as data encoding/decoding, managing FIFO buffer sizes, and adapting to JTAG operation standards. Input ports include `tck` (Test Clock), `reset_n` (active low reset), `sink_data` (data input from a source for JTAG), `sink_valid` (validity of sink_data), `sink_ready` (readiness to accept data), `clock_to_sample`, and `reset_to_sample`. Output ports are `tck`, `source_data` (processed data output), `source_valid` (validity of source data), `sink_ready`, `resetrequest`, `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data`. Internally, the module uses a diverse range of signals such as `ir_out`, `ir_in`, `tdo`, `tdi`, `sdr`, `cdr`, `udr` for managing JTAG TAP states, and others like `write_state`, `read_state` for tracking current operational states. The internal counters and flags manage data alignment, transmission readiness, and protocol adherence. Key blocks include the JTAG SLD node, idle data inserters and removers to manage idle frames in data streams, and synchronization blocks to maintain signal integrity across different clock domains. Enhanced features like management data handling are conditionally included based on parameter settings, facilitated through conditional generation. This module is fundamental in establishing a robust communication interface leveraging JTAG standards for system debugging and management data transfer.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\n\nExplanation: This module appears to manage JTAG streaming, solving coordinated data transfers between JTAG and system logic such as debug transports or data communication paths. The module engages in various operations such as data encoding/decoding and managing FIFO buffers size specifications using function `flog2`. It maintains different operational states (e.g., handling data, loopback, debug, etc.) controlled through a state machine, adapting to JTAG operation standards. There are synchronizers and condition checks for data validity, also managing data under JTAG test access conditions like capture, shift, update, and others, emphasizing interactions with tck (test clock) and tdi (test data in) signals. The module extended functionalities include debugging, data management via FIFO buffers, and ensuring data alignment and transmission readiness, real-time adjusting via dynamic state transitions based on JTAG standard instructions and operations."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- tck\n- reset_n\n- source_data\n- source_valid\n- sink_data\n- sink_valid\n- sink_ready\n- clock_to_sample\n- reset_to_sample\n\n**Explanation:**\n- `tck`: Test Clock input used for timing JTAG operations, synchronizing the state machine transitions within the JTAG standard.\n- `reset_n`: Active low reset signal that initializes the module and clears certain internal states and counters when asserted.\n- `sink_data`: Data input from a source, typically where JTAG streamed data is received.\n- `sink_valid`: Indicates if the data on the `sink_data` line is valid and can be processed.\n- `sink_ready`: Signals the readiness to accept data on the sink interface, controlling back pressure.\n- `clock_to_sample`: System clock used to sample incoming data to align with system timing requirements.\n- `reset_to_sample`: Reset signal associated specifically with the sample clock domain, ensuring proper initialization in that context.\n\n**Output ports:**\n- tck\n- source_data\n- source_valid\n- sink_ready\n- resetrequest\n- debug_reset\n- mgmt_valid\n- mgmt_channel\n- mgmt_data\n\n**Explanation:**\n- `tck`: Often connected internally or handled in specific JTAG devices, it can be a mirrored output for synchronous designs.\n- `source_data`: Data output that transmits processed or managed data to an external sink or next stage in a system.\n- `source_valid`: Indicates whether the data on `source_data` is valid, ensuring downstream logic only processes valid data.\n- `sink_ready`: Output signal propagating readiness to receive data, used in handshaking with data producers to manage flow control.\n- `resetrequest`: Request a system-wide or specific domain reset based on JTAG interactions or internal state machine decisions.\n- `debug_reset`: Signals a reset in the debug or management context, typically as a reaction to specific JTAG commands or configurations.\n- `mgmt_valid`: Indicates valid management or control data is available on the management interface.\n- `mgmt_channel`: Specifies the active channel for management data, used when multiple management paths or types of information are handled.\n- `mgmt_data`: Carries management or control information dictated by the module's state machine or the JTAG interface's necessities."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n- ir_out\n- ir_in\n- tdo\n- tdi\n- sdr\n- cdr\n- udr\n- write_state\n- read_state\n- dr_data_in\n- dr_data_out\n- dr_loopback\n- dr_debug\n- dr_info\n- dr_control\n- dr_mgmt\n- padded_bit_counter\n- bypass_bit_counter\n- write_data_bit_counter\n- read_data_bit_counter\n- header_in_bit_counter\n- header_out_bit_counter\n- scan_length_byte_counter\n- valid_write_data_length_byte_counter\n- write_data_valid\n- read_data_valid\n- read_data_all_valid\n- decode_header_1\n- decode_header_2\n- write_data_byte_aligned\n- read_data_byte_aligned\n- padded_bit_byte_aligned\n- bytestream_end\n- offset\n- header_in\n- scan_length\n- read_data_length\n- write_data_length\n- idle_inserter_sink_data\n- idle_inserter_sink_valid\n- idle_inserter_sink_ready\n- idle_inserter_source_data\n- idle_inserter_source_ready\n- idle_remover_sink_data\n- idle_remover_sink_valid\n- idle_remover_source_data\n- idle_remover_source_valid\n- clock_sensor\n- clock_to_sample_div2\n- clock_sense_reset_n\n- data_available\n- decoded_scan_length\n- decoded_write_data_length\n- decoded_read_data_length\n- clock_sensor_sync\n- reset_to_sample_sync\n- clock_to_sample_div2_sync\n- clock_sense_reset_n_sync\n\n**Explanation:**\n- `ir_out`, `ir_in`: Input and output for the instruction register, determining the JTAG instruction's context.\n- `tdo`, `tdi`: 'Test Data Out' and 'Test Data In' respectively, for serial data communication in JTAG.\n- `sdr`, `cdr`, `udr`: Signals indicating different JTAG test access port (TAP) states: Shift-DR, Capture-DR, Update-DR.\n- `write_state`, `read_state`: Current states of write and read processes, managed via state machines.\n- `dr_data_in`, `dr_data_out`: Data registers for input and output operations in JTAG interactions.\n- `dr_loopback`: Loopback data storage during specific test or debug operations.\n- `dr_debug`, `dr_info`, `dr_control`: Registers holding specific debug, informational, or control data respectively.\n- `dr_mgmt`: Management data register used when additional management is active.\n- `padded_bit_counter`, `bypass_bit_counter`: Counters for managing bit positions during data padding and bypass operations.\n- `write_data_bit_counter`, `read_data_bit_counter`: Counters for bit positions in write and read data processes.\n- `header_in_bit_counter`, `header_out_bit_counter`: Counters for bit positions during header processing in input and output operations.\n- `scan_length_byte_counter`, `valid_write_data_length_byte_counter`: Counters to handle byte count during scans and valid data lengths.\n- `write_data_valid`, `read_data_valid`, `read_data_all_valid`: Validation flags for write and read data handling, indicating when data is valid.\n- `decode_header_1`, `decode_header_2`: Flags to indicate stages of header decoding process.\n- `write_data_byte_aligned`, `read_data_byte_aligned`, `padded_bit_byte_aligned`: Alignment indicators for data handling in bytes.\n- `bytestream_end`: Flag indicating the end of a data bytestream during processing.\n- `offset`, `header_in`: Intermediate storage for handling data offsets and incoming headers.\n- `scan_length`, `read_data_length`, `write_data_length`: Storage for length parameters associated with scanning and reading/writing operations.\n- `idle_inserter_sink_data`, `idle_inserter_sink_valid`, `idle_inserter_sink_ready`, `idle_inserter_source_data`, `idle_inserter_source_ready`: Handles inserting and managing idle frames in data streams.\n- `idle_remover_sink_data`, `idle_remover_sink_valid`, `idle_remover_source_data`, `idle_remover_source_valid`: Manages removal of idle frames from data streams.\n- `clock_sensor`, `clock_to_sample_div2`, `clock_sense_reset_n`: Clock management signals used for sensing and frequency division.\n- `data_available`: Indicates if data is available for processing.\n- `decoded_scan_length`, `decoded_write_data_length`, `decoded_read_data_length`: Decoded lengths for scan, write, and read operations.\n- `clock_sensor_sync`, `reset_to_sample_sync`, `clock_to_sample_div2_sync`, `clock_sense_reset_n_sync`: Synchronized signals ensuring stability across different clock domains."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming (\n    tck,\n    reset_n,\n    \n    source_data,\n    source_valid,\n    \n    sink_data,\n    sink_valid,\n    sink_ready,\n    \n    clock_to_sample,\n    reset_to_sample,\n    \n    resetrequest,\n    \n    debug_reset,\n    mgmt_valid,\n    mgmt_channel,\n    mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    \n    \n    \n    \n    \n    \n    \n    \n    parameter PURPOSE = 0;\n    parameter UPSTREAM_FIFO_SIZE = 0;\n    parameter DOWNSTREAM_FIFO_SIZE = 0;\n    parameter MGMT_CHANNEL_WIDTH = -1;\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    output tck;\n    input  reset_n;\n    output [7:0] source_data;\n    output       source_valid;\n    input [7:0] sink_data;\n    input       sink_valid;\n    output      sink_ready;\n    input clock_to_sample;\n    input reset_to_sample;\n    output reg resetrequest = 1'b0;\n    output wire debug_reset;\n    output reg mgmt_valid;\n    output reg [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n    output reg mgmt_data;\n\n    \n    wire [IRWIDTH - 1 : 0] ir_out;\n    wire [IRWIDTH - 1 : 0] ir_in;\n    reg tdo = 0;\n    wire tdi;\n    wire sdr;\n    wire cdr;\n    wire udr;\n\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (cdr) begin\n                dr_control <= 'b0; \n            end\n            if (sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_jtag_sld_node node (\n        .ir_out             (ir_out),\n        .tdo                (tdo),\n        .ir_in              (ir_in),\n        .tck                (tck),\n        .tdi                (tdi),\n        .virtual_state_cdr  (cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (sdr),\n        .virtual_state_udr  (udr),\n        .virtual_state_uir  ()\n    );\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_jtag_streaming. \nModule specification: The `altera_jtag_streaming` module manages JTAG streaming for coordination of data transfers between JTAG and system logic, aimed at debug transports or data communication paths. It handles various operations such as data encoding/decoding, managing FIFO buffer sizes, and adapting to JTAG operation standards. Input ports include `tck` (Test Clock), `reset_n` (active low reset), `sink_data` (data input from a source for JTAG), `sink_valid` (validity of sink_data), `sink_ready` (readiness to accept data), `clock_to_sample`, and `reset_to_sample`. Output ports are `tck`, `source_data` (processed data output), `source_valid` (validity of source data), `sink_ready`, `resetrequest`, `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data`. Internally, the module uses a diverse range of signals such as `ir_out`, `ir_in`, `tdo`, `tdi`, `sdr`, `cdr`, `udr` for managing JTAG TAP states, and others like `write_state`, `read_state` for tracking current operational states. The internal counters and flags manage data alignment, transmission readiness, and protocol adherence. Key blocks include the JTAG SLD node, idle data inserters and removers to manage idle frames in data streams, and synchronization blocks to maintain signal integrity across different clock domains. Enhanced features like management data handling are conditionally included based on parameter settings, facilitated through conditional generation. This module is fundamental in establishing a robust communication interface leveraging JTAG standards for system debugging and management data transfer."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\n\nExplanation: This module appears to manage JTAG streaming, solving coordinated data transfers between JTAG and system logic such as debug transports or data communication paths. The module engages in various operations such as data encoding/decoding and managing FIFO buffers size specifications using function `flog2`. It maintains different operational states (e.g., handling data, loopback, debug, etc.) controlled through a state machine, adapting to JTAG operation standards. There are synchronizers and condition checks for data validity, also managing data under JTAG test access conditions like capture, shift, update, and others, emphasizing interactions with tck (test clock) and tdi (test data in) signals. The module extended functionalities include debugging, data management via FIFO buffers, and ensuring data alignment and transmission readiness, real-time adjusting via dynamic state transitions based on JTAG standard instructions and operations."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- tck\n- reset_n\n- source_data\n- source_valid\n- sink_data\n- sink_valid\n- sink_ready\n- clock_to_sample\n- reset_to_sample\n\n**Explanation:**\n- `tck`: Test Clock input used for timing JTAG operations, synchronizing the state machine transitions within the JTAG standard.\n- `reset_n`: Active low reset signal that initializes the module and clears certain internal states and counters when asserted.\n- `sink_data`: Data input from a source, typically where JTAG streamed data is received.\n- `sink_valid`: Indicates if the data on the `sink_data` line is valid and can be processed.\n- `sink_ready`: Signals the readiness to accept data on the sink interface, controlling back pressure.\n- `clock_to_sample`: System clock used to sample incoming data to align with system timing requirements.\n- `reset_to_sample`: Reset signal associated specifically with the sample clock domain, ensuring proper initialization in that context.\n\n**Output ports:**\n- tck\n- source_data\n- source_valid\n- sink_ready\n- resetrequest\n- debug_reset\n- mgmt_valid\n- mgmt_channel\n- mgmt_data\n\n**Explanation:**\n- `tck`: Often connected internally or handled in specific JTAG devices, it can be a mirrored output for synchronous designs.\n- `source_data`: Data output that transmits processed or managed data to an external sink or next stage in a system.\n- `source_valid`: Indicates whether the data on `source_data` is valid, ensuring downstream logic only processes valid data.\n- `sink_ready`: Output signal propagating readiness to receive data, used in handshaking with data producers to manage flow control.\n- `resetrequest`: Request a system-wide or specific domain reset based on JTAG interactions or internal state machine decisions.\n- `debug_reset`: Signals a reset in the debug or management context, typically as a reaction to specific JTAG commands or configurations.\n- `mgmt_valid`: Indicates valid management or control data is available on the management interface.\n- `mgmt_channel`: Specifies the active channel for management data, used when multiple management paths or types of information are handled.\n- `mgmt_data`: Carries management or control information dictated by the module's state machine or the JTAG interface's necessities."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n**Internal Signals:**\n- ir_out\n- ir_in\n- tdo\n- tdi\n- sdr\n- cdr\n- udr\n- write_state\n- read_state\n- dr_data_in\n- dr_data_out\n- dr_loopback\n- dr_debug\n- dr_info\n- dr_control\n- dr_mgmt\n- padded_bit_counter\n- bypass_bit_counter\n- write_data_bit_counter\n- read_data_bit_counter\n- header_in_bit_counter\n- header_out_bit_counter\n- scan_length_byte_counter\n- valid_write_data_length_byte_counter\n- write_data_valid\n- read_data_valid\n- read_data_all_valid\n- decode_header_1\n- decode_header_2\n- write_data_byte_aligned\n- read_data_byte_aligned\n- padded_bit_byte_aligned\n- bytestream_end\n- offset\n- header_in\n- scan_length\n- read_data_length\n- write_data_length\n- idle_inserter_sink_data\n- idle_inserter_sink_valid\n- idle_inserter_sink_ready\n- idle_inserter_source_data\n- idle_inserter_source_ready\n- idle_remover_sink_data\n- idle_remover_sink_valid\n- idle_remover_source_data\n- idle_remover_source_valid\n- clock_sensor\n- clock_to_sample_div2\n- clock_sense_reset_n\n- data_available\n- decoded_scan_length\n- decoded_write_data_length\n- decoded_read_data_length\n- clock_sensor_sync\n- reset_to_sample_sync\n- clock_to_sample_div2_sync\n- clock_sense_reset_n_sync\n\n**Explanation:**\n- `ir_out`, `ir_in`: Input and output for the instruction register, determining the JTAG instruction's context.\n- `tdo`, `tdi`: 'Test Data Out' and 'Test Data In' respectively, for serial data communication in JTAG.\n- `sdr`, `cdr`, `udr`: Signals indicating different JTAG test access port (TAP) states: Shift-DR, Capture-DR, Update-DR.\n- `write_state`, `read_state`: Current states of write and read processes, managed via state machines.\n- `dr_data_in`, `dr_data_out`: Data registers for input and output operations in JTAG interactions.\n- `dr_loopback`: Loopback data storage during specific test or debug operations.\n- `dr_debug`, `dr_info`, `dr_control`: Registers holding specific debug, informational, or control data respectively.\n- `dr_mgmt`: Management data register used when additional management is active.\n- `padded_bit_counter`, `bypass_bit_counter`: Counters for managing bit positions during data padding and bypass operations.\n- `write_data_bit_counter`, `read_data_bit_counter`: Counters for bit positions in write and read data processes.\n- `header_in_bit_counter`, `header_out_bit_counter`: Counters for bit positions during header processing in input and output operations.\n- `scan_length_byte_counter`, `valid_write_data_length_byte_counter`: Counters to handle byte count during scans and valid data lengths.\n- `write_data_valid`, `read_data_valid`, `read_data_all_valid`: Validation flags for write and read data handling, indicating when data is valid.\n- `decode_header_1`, `decode_header_2`: Flags to indicate stages of header decoding process.\n- `write_data_byte_aligned`, `read_data_byte_aligned`, `padded_bit_byte_aligned`: Alignment indicators for data handling in bytes.\n- `bytestream_end`: Flag indicating the end of a data bytestream during processing.\n- `offset`, `header_in`: Intermediate storage for handling data offsets and incoming headers.\n- `scan_length`, `read_data_length`, `write_data_length`: Storage for length parameters associated with scanning and reading/writing operations.\n- `idle_inserter_sink_data`, `idle_inserter_sink_valid`, `idle_inserter_sink_ready`, `idle_inserter_source_data`, `idle_inserter_source_ready`: Handles inserting and managing idle frames in data streams.\n- `idle_remover_sink_data`, `idle_remover_sink_valid`, `idle_remover_source_data`, `idle_remover_source_valid`: Manages removal of idle frames from data streams.\n- `clock_sensor`, `clock_to_sample_div2`, `clock_sense_reset_n`: Clock management signals used for sensing and frequency division.\n- `data_available`: Indicates if data is available for processing.\n- `decoded_scan_length`, `decoded_write_data_length`, `decoded_read_data_length`: Decoded lengths for scan, write, and read operations.\n- `clock_sensor_sync`, `reset_to_sample_sync`, `clock_to_sample_div2_sync`, `clock_sense_reset_n_sync`: Synchronized signals ensuring stability across different clock domains."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming (\n    tck,\n    reset_n,\n    \n    source_data,\n    source_valid,\n    \n    sink_data,\n    sink_valid,\n    sink_ready,\n    \n    clock_to_sample,\n    reset_to_sample,\n    \n    resetrequest,\n    \n    debug_reset,\n    mgmt_valid,\n    mgmt_channel,\n    mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    \n    \n    \n    \n    \n    \n    \n    \n    parameter PURPOSE = 0;\n    parameter UPSTREAM_FIFO_SIZE = 0;\n    parameter DOWNSTREAM_FIFO_SIZE = 0;\n    parameter MGMT_CHANNEL_WIDTH = -1;\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n   parameter TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   parameter SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    output tck;\n    input  reset_n;\n    output [7:0] source_data;\n    output       source_valid;\n    input [7:0] sink_data;\n    input       sink_valid;\n    output      sink_ready;\n    input clock_to_sample;\n    input reset_to_sample;\n    output reg resetrequest = 1'b0;\n    output wire debug_reset;\n    output reg mgmt_valid;\n    output reg [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel;\n    output reg mgmt_data;\n\n    \n    wire [IRWIDTH - 1 : 0] ir_out;\n    wire [IRWIDTH - 1 : 0] ir_in;\n    reg tdo = 0;\n    wire tdi;\n    wire sdr;\n    wire cdr;\n    wire udr;\n\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (cdr) begin\n                dr_control <= 'b0; \n            end\n            if (sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_jtag_sld_node node (\n        .ir_out             (ir_out),\n        .tdo                (tdo),\n        .ir_in              (ir_in),\n        .tck                (tck),\n        .tdi                (tdi),\n        .virtual_state_cdr  (cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (sdr),\n        .virtual_state_udr  (udr),\n        .virtual_state_uir  ()\n    );\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_jtag_streaming. \nModule specification: The `altera_jtag_streaming` module manages JTAG streaming for coordination of data transfers between JTAG and system logic, aimed at debug transports or data communication paths. It handles various operations such as data encoding/decoding, managing FIFO buffer sizes, and adapting to JTAG operation standards. Input ports include `tck` (Test Clock), `reset_n` (active low reset), `sink_data` (data input from a source for JTAG), `sink_valid` (validity of sink_data), `sink_ready` (readiness to accept data), `clock_to_sample`, and `reset_to_sample`. Output ports are `tck`, `source_data` (processed data output), `source_valid` (validity of source data), `sink_ready`, `resetrequest`, `debug_reset`, `mgmt_valid`, `mgmt_channel`, and `mgmt_data`. Internally, the module uses a diverse range of signals such as `ir_out`, `ir_in`, `tdo`, `tdi`, `sdr`, `cdr`, `udr` for managing JTAG TAP states, and others like `write_state`, `read_state` for tracking current operational states. The internal counters and flags manage data alignment, transmission readiness, and protocol adherence. Key blocks include the JTAG SLD node, idle data inserters and removers to manage idle frames in data streams, and synchronization blocks to maintain signal integrity across different clock domains. Enhanced features like management data handling are conditionally included based on parameter settings, facilitated through conditional generation. This module is fundamental in establishing a robust communication interface leveraging JTAG standards for system debugging and management data transfer."
                }
            ]
        }
    ]
}