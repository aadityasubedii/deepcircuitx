{
    "spec": "Module name: IR_RECEIVE. \n\nModule specification: The IR_RECEIVE module is responsible for receiving and decoding infrared (IR) signals, specifically handling the synchronization, processing, and output of decoded 32-bit data packets. It utilizes a state machine approach with three primary states: IDLE, GUIDANCE, and DATAREAD. Various input ports include iCLK (clock input for synchronization), iRST_n (active-low reset for initialization and error recovery), and iIRDA (IR data input). Output ports comprise oDATA_READY (indicates data availability) and oDATA (holds the 32-bit decoded data packet). Internally, the module leverages several signals like idle_count, state_count, and data_count to track different durations critical for state transitions and data decoding, while state signals manage the current machine state. Flags such as idle_count_flag, state_count_flag, and data_count_flag help enable respective counters based on state and input conditions. The bitcount signal counts the number of bits received to ensure a complete data packet. The module reacts in real-time to changes, utilizing always blocks to change states based on conditions like reaching specific duration thresholds or completing bit counts. Each always block is meticulously designed to reset states and counters on reset, handle transitions between states based on the duration of signals, serialize data bit by bit into a temporary register, and check for data correctness before setting data as ready. This structured design ensures accurate reception and processing of IR data, tailored to specific signal timing requirements.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: IR_RECEIVE.\n\nExplanation: The IR_RECEIVE module is designed to receive and decode data transmitted via an infrared (IR) signal. It operates through a state machine with three states\u2014IDLE, GUIDANCE, and DATAREAD. The IDLE state waits for a signal, transitioning to GUIDANCE when it detects a continuous low IR signal exceeding a certain duration. GUIDANCE waits for a high signal of specified duration to switch to the DATAREAD where actual data bits are read and serialized. Each data bit's timing determines its value (1 or 0). The module counts these bits, checking for errors (by comparing two sections of the received data for complementarity). When all 32 bits are correctly received, the data is confirmed, stored in a buffer, and an indication that the data is ready is outputted. The system operates synchronously with a clock and has reset functionality."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: iCLK, iRST_n, iIRDA.\nExplanation:\n- iCLK: This is the clock input. It provides the timing signal for the module, synchronizing all operations like state transitions and data processing within the module.\n- iRST_n: This is the active-low reset input. It initializes or reset the module to a known state whenever it is pulled low.\n- iIRDA: This is the input receiving the IR signal. It is the digital representation of the IR data signal being decoded by the module.\n\nOutput ports: oDATA_READY, oDATA.\nExplanation:\n- oDATA_READY: This is a flag output indicating that the received data is ready and valid. It becomes high when a complete and correct 32-bit data packet has been received and validated, signaling to external systems that the data can be read.\n- oDATA: This is the output data port that holds the validated 32-bit data packet received via the IR signal. The data is presented here when oDATA_READY is high, making it available for other parts of the system to utilize."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: idle_count, idle_count_flag, state_count, state_count_flag, data_count, data_count_flag, bitcount, state, data, data_buf, data_ready.\n\nExplanation:\n- idle_count: This counter keeps track of the duration for which the IR signal remains low when the state machine is in the IDLE state. It helps in determining when to transition to the GUIDANCE state.\n- idle_count_flag: This flag enables the idle_count counter. It is set when in the IDLE state and the IR signal is low, signaling the start of potentially valid IR communication.\n- state_count: This counter measures the duration for which the IR signal remains high in the GUIDANCE state. It is used to determine the transition from the GUIDANCE to the DATAREAD state.\n- state_count_flag: This flag enables the state_count counter. It is set when the state machine is in the GUIDANCE state and the IR signal is high.\n- data_count: This counts the duration for which the IR signal stays high during data bit detection in the DATAREAD state, aiding in the binary decoding of the IR signal.\n- data_count_flag: This flag activates the data_count counter and is set when the state machine is in the DATAREAD state and receives an IR signal.\n- bitcount: It counts the number of data bits read and stored during the DATAREAD state. This counter helps ensure that 32 bits are read to form a complete data message.\n- state: This is a state register that holds the current state of the state machine (IDLE, GUIDANCE, or DATAREAD). It determines the next operations based on IR signal conditions.\n- data: This is a temporary register where the individual bits of the incoming data are stored serially as they are decoded.\n- data_buf: This buffer holds the fully received and validated 32-bit data ready for output. It is used to store the data temporarily until it can be passed to the output port oDATA.\n- data_ready: A flag signal that indicates when the received data is completely ready and validated. It drives the output signal oDATA_READY to signal external components that data reception and validation are complete."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule IR_RECEIVE(\n\t\t\t\t\tiCLK,         \n\t\t\t\t\tiRST_n,       \n\t\t\t\t\tiIRDA,        \n\t\t\t\t\toDATA_READY,  \n\t\t\t\t\toDATA         \n\t\t\t\t\t);\n\n\n\n\n\nparameter IDLE               = 2'b00;    \nparameter GUIDANCE           = 2'b01;    \nparameter DATAREAD           = 2'b10;    \n\nparameter IDLE_HIGH_DUR      =  262143;  \nparameter GUIDE_LOW_DUR      =  230000;  \nparameter GUIDE_HIGH_DUR     =  210000;  \nparameter DATA_HIGH_DUR      =  41500;\t \nparameter BIT_AVAILABLE_DUR  =  20000;   \n\n\n\n\n\ninput         iCLK;        \ninput         iRST_n;      \ninput         iIRDA;       \noutput        oDATA_READY; \noutput [31:0] oDATA;       \n\n\n\n\n\nreg    [31:0] oDATA;                 \nreg    [17:0] idle_count;            \nreg           idle_count_flag;       \n\nreg    [17:0] state_count;           \nreg           state_count_flag;      \nreg    [17:0] data_count;            \nreg           data_count_flag;       \nreg     [5:0] bitcount;              \nreg     [1:0] state;                 \nreg    [31:0] data;                  \nreg    [31:0] data_buf;              \nreg           data_ready;            \n\n\n\n\n\nassign oDATA_READY = data_ready;\n\n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   idle_count <= 0;\n\t  else if (idle_count_flag)    \n\t\t\t idle_count <= idle_count + 1'b1;\n\t\telse  \n\t\t\t idle_count <= 0;\t         \n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   idle_count_flag <= 1'b0;\n\t  else if ((state == IDLE) && !iIRDA)\n\t\t\t idle_count_flag <= 1'b1;\n\t\telse                           \n\t\t\t idle_count_flag <= 1'b0;\t\t     \t\t \t\n      \n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   state_count <= 0;\n\t  else if (state_count_flag)    \n\t\t\t state_count <= state_count + 1'b1;\n\t\telse  \n\t\t\t state_count <= 0;\t        \n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   state_count_flag <= 1'b0;\n\t  else if ((state == GUIDANCE) && iIRDA)\n\t\t\t state_count_flag <= 1'b1;\n\t\telse  \n\t\t\t state_count_flag <= 1'b0;     \t\t \t\n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   data_count <= 1'b0;\n\t  else if(data_count_flag)      \n\t\t\t data_count <= data_count + 1'b1;\n\t\telse \n\t\t\t data_count <= 1'b0;        \n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n) \n\t\t   data_count_flag <= 0;\t\n\t  else if ((state == DATAREAD) && iIRDA)\n\t\t\t data_count_flag <= 1'b1;  \n\t\telse\n\t\t\t data_count_flag <= 1'b0; \n\n\nalways @(posedge iCLK or negedge iRST_n)\n    if (!iRST_n)\n       bitcount <= 6'b0;\n\t  else if (state == DATAREAD)\n\t\tbegin\n\t\t\tif (data_count == 20000)\n\t\t\t\t\tbitcount <= bitcount + 1'b1; \n\t\tend   \n\t  else\n\t     bitcount <= 6'b0;\n\n\nalways @(posedge iCLK or negedge iRST_n) \n\t  if (!iRST_n)\t     \n\t     state <= IDLE;\n\t  else \n\t\t\t case (state)\n \t\t\t    IDLE     : if (idle_count > GUIDE_LOW_DUR)  \n\t\t\t  \t              state <= GUIDANCE; \n\t\t\t    GUIDANCE : if (state_count > GUIDE_HIGH_DUR)\n\t\t\t  \t              state <= DATAREAD;\n\t\t\t    DATAREAD : if ((data_count >= IDLE_HIGH_DUR) || (bitcount >= 33))\n\t\t\t  \t\t\t\t\t      state <= IDLE;\n\t        default  : state <= IDLE; \n\t\t\t endcase\n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n)\n\t     data <= 0;\n\t\telse if (state == DATAREAD)\n\t\tbegin\n\t\t\t if (data_count >= DATA_HIGH_DUR) \n\t\t\t    data[bitcount-1'b1] <= 1'b1;  \n\t\tend\n\t\telse\n\t\t\t data <= 0;\n\t\n\nalways @(posedge iCLK or negedge iRST_n) \n\t  if (!iRST_n)\n\t     data_ready <= 1'b0;\n    else if (bitcount == 32)   \n\t\tbegin\n\t\t\t if (data[31:24] == ~data[23:16])\n\t\t\t begin\t\t\n\t\t\t\t\tdata_buf <= data;     \n\t\t\t\t  data_ready <= 1'b1;   \n\t\t\t end\t\n\t\t\t else\n\t\t\t\t  data_ready <= 1'b0 ;  \n\t\tend\n\t\telse\n\t\t   data_ready <= 1'b0 ;\n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n)\n\t\t   oDATA <= 32'b0000;\n\t  else if (data_ready)\n\t     oDATA <= data_buf;  \n\t\t\t\t\t\nendmodule```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: IR_RECEIVE. \n\nModule specification: The IR_RECEIVE module is responsible for receiving and decoding infrared (IR) signals, specifically handling the synchronization, processing, and output of decoded 32-bit data packets. It utilizes a state machine approach with three primary states: IDLE, GUIDANCE, and DATAREAD. Various input ports include iCLK (clock input for synchronization), iRST_n (active-low reset for initialization and error recovery), and iIRDA (IR data input). Output ports comprise oDATA_READY (indicates data availability) and oDATA (holds the 32-bit decoded data packet). Internally, the module leverages several signals like idle_count, state_count, and data_count to track different durations critical for state transitions and data decoding, while state signals manage the current machine state. Flags such as idle_count_flag, state_count_flag, and data_count_flag help enable respective counters based on state and input conditions. The bitcount signal counts the number of bits received to ensure a complete data packet. The module reacts in real-time to changes, utilizing always blocks to change states based on conditions like reaching specific duration thresholds or completing bit counts. Each always block is meticulously designed to reset states and counters on reset, handle transitions between states based on the duration of signals, serialize data bit by bit into a temporary register, and check for data correctness before setting data as ready. This structured design ensures accurate reception and processing of IR data, tailored to specific signal timing requirements."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: IR_RECEIVE.\n\nExplanation: The IR_RECEIVE module is designed to receive and decode data transmitted via an infrared (IR) signal. It operates through a state machine with three states\u2014IDLE, GUIDANCE, and DATAREAD. The IDLE state waits for a signal, transitioning to GUIDANCE when it detects a continuous low IR signal exceeding a certain duration. GUIDANCE waits for a high signal of specified duration to switch to the DATAREAD where actual data bits are read and serialized. Each data bit's timing determines its value (1 or 0). The module counts these bits, checking for errors (by comparing two sections of the received data for complementarity). When all 32 bits are correctly received, the data is confirmed, stored in a buffer, and an indication that the data is ready is outputted. The system operates synchronously with a clock and has reset functionality."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: iCLK, iRST_n, iIRDA.\nExplanation:\n- iCLK: This is the clock input. It provides the timing signal for the module, synchronizing all operations like state transitions and data processing within the module.\n- iRST_n: This is the active-low reset input. It initializes or reset the module to a known state whenever it is pulled low.\n- iIRDA: This is the input receiving the IR signal. It is the digital representation of the IR data signal being decoded by the module.\n\nOutput ports: oDATA_READY, oDATA.\nExplanation:\n- oDATA_READY: This is a flag output indicating that the received data is ready and valid. It becomes high when a complete and correct 32-bit data packet has been received and validated, signaling to external systems that the data can be read.\n- oDATA: This is the output data port that holds the validated 32-bit data packet received via the IR signal. The data is presented here when oDATA_READY is high, making it available for other parts of the system to utilize."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: idle_count, idle_count_flag, state_count, state_count_flag, data_count, data_count_flag, bitcount, state, data, data_buf, data_ready.\n\nExplanation:\n- idle_count: This counter keeps track of the duration for which the IR signal remains low when the state machine is in the IDLE state. It helps in determining when to transition to the GUIDANCE state.\n- idle_count_flag: This flag enables the idle_count counter. It is set when in the IDLE state and the IR signal is low, signaling the start of potentially valid IR communication.\n- state_count: This counter measures the duration for which the IR signal remains high in the GUIDANCE state. It is used to determine the transition from the GUIDANCE to the DATAREAD state.\n- state_count_flag: This flag enables the state_count counter. It is set when the state machine is in the GUIDANCE state and the IR signal is high.\n- data_count: This counts the duration for which the IR signal stays high during data bit detection in the DATAREAD state, aiding in the binary decoding of the IR signal.\n- data_count_flag: This flag activates the data_count counter and is set when the state machine is in the DATAREAD state and receives an IR signal.\n- bitcount: It counts the number of data bits read and stored during the DATAREAD state. This counter helps ensure that 32 bits are read to form a complete data message.\n- state: This is a state register that holds the current state of the state machine (IDLE, GUIDANCE, or DATAREAD). It determines the next operations based on IR signal conditions.\n- data: This is a temporary register where the individual bits of the incoming data are stored serially as they are decoded.\n- data_buf: This buffer holds the fully received and validated 32-bit data ready for output. It is used to store the data temporarily until it can be passed to the output port oDATA.\n- data_ready: A flag signal that indicates when the received data is completely ready and validated. It drives the output signal oDATA_READY to signal external components that data reception and validation are complete."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule IR_RECEIVE(\n\t\t\t\t\tiCLK,         \n\t\t\t\t\tiRST_n,       \n\t\t\t\t\tiIRDA,        \n\t\t\t\t\toDATA_READY,  \n\t\t\t\t\toDATA         \n\t\t\t\t\t);\n\n\n\n\n\nparameter IDLE               = 2'b00;    \nparameter GUIDANCE           = 2'b01;    \nparameter DATAREAD           = 2'b10;    \n\nparameter IDLE_HIGH_DUR      =  262143;  \nparameter GUIDE_LOW_DUR      =  230000;  \nparameter GUIDE_HIGH_DUR     =  210000;  \nparameter DATA_HIGH_DUR      =  41500;\t \nparameter BIT_AVAILABLE_DUR  =  20000;   \n\n\n\n\n\ninput         iCLK;        \ninput         iRST_n;      \ninput         iIRDA;       \noutput        oDATA_READY; \noutput [31:0] oDATA;       \n\n\n\n\n\nreg    [31:0] oDATA;                 \nreg    [17:0] idle_count;            \nreg           idle_count_flag;       \n\nreg    [17:0] state_count;           \nreg           state_count_flag;      \nreg    [17:0] data_count;            \nreg           data_count_flag;       \nreg     [5:0] bitcount;              \nreg     [1:0] state;                 \nreg    [31:0] data;                  \nreg    [31:0] data_buf;              \nreg           data_ready;            \n\n\n\n\n\nassign oDATA_READY = data_ready;\n\n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   idle_count <= 0;\n\t  else if (idle_count_flag)    \n\t\t\t idle_count <= idle_count + 1'b1;\n\t\telse  \n\t\t\t idle_count <= 0;\t         \n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   idle_count_flag <= 1'b0;\n\t  else if ((state == IDLE) && !iIRDA)\n\t\t\t idle_count_flag <= 1'b1;\n\t\telse                           \n\t\t\t idle_count_flag <= 1'b0;\t\t     \t\t \t\n      \n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   state_count <= 0;\n\t  else if (state_count_flag)    \n\t\t\t state_count <= state_count + 1'b1;\n\t\telse  \n\t\t\t state_count <= 0;\t        \n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   state_count_flag <= 1'b0;\n\t  else if ((state == GUIDANCE) && iIRDA)\n\t\t\t state_count_flag <= 1'b1;\n\t\telse  \n\t\t\t state_count_flag <= 1'b0;     \t\t \t\n\n\nalways @(posedge iCLK or negedge iRST_n)\t\n\t  if (!iRST_n)\n\t\t   data_count <= 1'b0;\n\t  else if(data_count_flag)      \n\t\t\t data_count <= data_count + 1'b1;\n\t\telse \n\t\t\t data_count <= 1'b0;        \n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n) \n\t\t   data_count_flag <= 0;\t\n\t  else if ((state == DATAREAD) && iIRDA)\n\t\t\t data_count_flag <= 1'b1;  \n\t\telse\n\t\t\t data_count_flag <= 1'b0; \n\n\nalways @(posedge iCLK or negedge iRST_n)\n    if (!iRST_n)\n       bitcount <= 6'b0;\n\t  else if (state == DATAREAD)\n\t\tbegin\n\t\t\tif (data_count == 20000)\n\t\t\t\t\tbitcount <= bitcount + 1'b1; \n\t\tend   \n\t  else\n\t     bitcount <= 6'b0;\n\n\nalways @(posedge iCLK or negedge iRST_n) \n\t  if (!iRST_n)\t     \n\t     state <= IDLE;\n\t  else \n\t\t\t case (state)\n \t\t\t    IDLE     : if (idle_count > GUIDE_LOW_DUR)  \n\t\t\t  \t              state <= GUIDANCE; \n\t\t\t    GUIDANCE : if (state_count > GUIDE_HIGH_DUR)\n\t\t\t  \t              state <= DATAREAD;\n\t\t\t    DATAREAD : if ((data_count >= IDLE_HIGH_DUR) || (bitcount >= 33))\n\t\t\t  \t\t\t\t\t      state <= IDLE;\n\t        default  : state <= IDLE; \n\t\t\t endcase\n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n)\n\t     data <= 0;\n\t\telse if (state == DATAREAD)\n\t\tbegin\n\t\t\t if (data_count >= DATA_HIGH_DUR) \n\t\t\t    data[bitcount-1'b1] <= 1'b1;  \n\t\tend\n\t\telse\n\t\t\t data <= 0;\n\t\n\nalways @(posedge iCLK or negedge iRST_n) \n\t  if (!iRST_n)\n\t     data_ready <= 1'b0;\n    else if (bitcount == 32)   \n\t\tbegin\n\t\t\t if (data[31:24] == ~data[23:16])\n\t\t\t begin\t\t\n\t\t\t\t\tdata_buf <= data;     \n\t\t\t\t  data_ready <= 1'b1;   \n\t\t\t end\t\n\t\t\t else\n\t\t\t\t  data_ready <= 1'b0 ;  \n\t\tend\n\t\telse\n\t\t   data_ready <= 1'b0 ;\n\n\nalways @(posedge iCLK or negedge iRST_n)\n\t  if (!iRST_n)\n\t\t   oDATA <= 32'b0000;\n\t  else if (data_ready)\n\t     oDATA <= data_buf;  \n\t\t\t\t\t\nendmodule</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: IR_RECEIVE. \n\nModule specification: The IR_RECEIVE module is responsible for receiving and decoding infrared (IR) signals, specifically handling the synchronization, processing, and output of decoded 32-bit data packets. It utilizes a state machine approach with three primary states: IDLE, GUIDANCE, and DATAREAD. Various input ports include iCLK (clock input for synchronization), iRST_n (active-low reset for initialization and error recovery), and iIRDA (IR data input). Output ports comprise oDATA_READY (indicates data availability) and oDATA (holds the 32-bit decoded data packet). Internally, the module leverages several signals like idle_count, state_count, and data_count to track different durations critical for state transitions and data decoding, while state signals manage the current machine state. Flags such as idle_count_flag, state_count_flag, and data_count_flag help enable respective counters based on state and input conditions. The bitcount signal counts the number of bits received to ensure a complete data packet. The module reacts in real-time to changes, utilizing always blocks to change states based on conditions like reaching specific duration thresholds or completing bit counts. Each always block is meticulously designed to reset states and counters on reset, handle transitions between states based on the duration of signals, serialize data bit by bit into a temporary register, and check for data correctness before setting data as ready. This structured design ensures accurate reception and processing of IR data, tailored to specific signal timing requirements."
                }
            ]
        }
    ]
}