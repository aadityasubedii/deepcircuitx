{
    "spec": "Module name: altera_avalon_packets_to_master. Module specification: This module is a packet-to-master converter for Altera Avalon interfaces, designed to receive packet data through an input interface, process it, and convert it into Avalon master read/write transactions. It supports two operational modes: a fast version using separate submodules (packets_to_fifo, fifo_to_packet, and fifo_buffer) for packet conversion and buffering, and a standard version using a single packets_to_master module for direct conversion. The module handles various command types for read and write operations, supporting both incrementing and non-incrementing address modes. Input ports include clk, reset_n, in_valid, in_data, in_startofpacket, in_endofpacket, out_ready, readdata, waitrequest, and readdatavalid, while output ports include",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_avalon_packets_to_master\n\nExplanation: This module appears to be a packet-to-master converter for Altera Avalon interfaces. It receives packet data through an input interface, processes it, and converts it into Avalon master read/write transactions. The module can operate in two modes:\n\n1. Fast version: Uses separate submodules (packets_to_fifo, fifo_to_packet, and fifo_buffer) to handle packet conversion and buffering.\n2. Standard version: Uses a single packets_to_master module for direct packet-to-master conversion.\n\nThe module supports various command types for read and write operations, with both incrementing and non-incrementing address modes. It handles packet framing, address decoding, and data buffering to facilitate the conversion between packet-based communication and Avalon master transactions."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, reset_n, in_valid, in_data, in_startofpacket, in_endofpacket, out_ready, readdata, waitrequest, readdatavalid\n\nExplanation:\n- clk: System clock input\n- reset_n: Active-low reset input\n- in_valid: Input data valid signal\n- in_data: 8-bit input data\n- in_startofpacket: Start of packet indicator for input\n- in_endofpacket: End of packet indicator for input\n- out_ready: Downstream module ready to accept output\n- readdata: 32-bit data input for read operations\n- waitrequest: Wait request signal from Avalon slave\n- readdatavalid: Read data valid signal from Avalon slave\n\nOutput ports:\nin_ready, out_valid, out_data, out_startofpacket, out_endofpacket, address, read, write, byteenable, writedata\n\nExplanation:\n- in_ready: Module ready to accept input data\n- out_valid: Output data valid signal\n- out_data: 8-bit output data\n- out_startofpacket: Start of packet indicator for output\n- out_endofpacket: End of packet indicator for output\n- address: 32-bit address for Avalon master transactions\n- read: Read request signal for Avalon master\n- write: Write request signal for Avalon master\n- byteenable: 4-bit byte enable signal for Avalon master\n- writedata: 32-bit data output for write operations"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nBased on the provided Verilog code for the altera_avalon_packets_to_master module, here are the internal signals and their explanations:\n\nInternal signals: fifo_readdata, fifo_read, fifo_empty, fifo_writedata, fifo_write, fifo_write_waitrequest.\n\nExplanation:\n1. fifo_readdata [35:0]: Data output from the FIFO buffer, containing packet information and payload.\n2. fifo_read: Control signal to read data from the FIFO buffer.\n3. fifo_empty: Status signal indicating whether the FIFO buffer is empty.\n4. fifo_writedata [35:0]: Data input to the FIFO buffer, containing packet information and payload.\n5. fifo_write: Control signal to write data to the FIFO buffer.\n6. fifo_write_waitrequest: Status signal indicating whether the FIFO buffer is ready to accept new data.\n\nThese internal signals are used to interface between the packets_to_fifo, fifo_to_packet, and fifo_buffer submodules when the fast version of the converter is used. They facilitate the buffering and transfer of packet data between the input interface and the Avalon master interface."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n`timescale 1ns / 100ps\n\n\n\nmodule altera_avalon_packets_to_master (\n    \n      input wire             clk,\n      input wire             reset_n,\n      \n      output wire         in_ready,\n      input  wire         in_valid,\n      input  wire [ 7: 0] in_data,\n      input  wire         in_startofpacket,\n      input  wire         in_endofpacket,\n\n      \n      input  wire         out_ready,\n      output wire         out_valid,\n      output wire [ 7: 0] out_data,\n      output wire         out_startofpacket,\n      output wire         out_endofpacket,\n\n      \n      output wire [31: 0] address,\n      input  wire [31: 0] readdata,\n      output wire         read,\n      output wire         write,\n      output wire [ 3: 0] byteenable,\n      output wire [31: 0] writedata,\n      input  wire         waitrequest,\n      input  wire         readdatavalid\n);\n\n    wire [ 35: 0] fifo_readdata;\n    wire          fifo_read;\n    wire          fifo_empty;\n    wire [ 35: 0] fifo_writedata;\n    wire          fifo_write;\n    wire          fifo_write_waitrequest;\n    \n   \n   \n   \n   parameter EXPORT_MASTER_SIGNALS = 0;\n   parameter FIFO_DEPTHS           = 2;\n   parameter FIFO_WIDTHU           = 1;\n   parameter FAST_VER              = 0;\n   \n   generate\n       if (FAST_VER) begin\n            packets_to_fifo p2f (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .in_ready            (in_ready),\n                .in_valid            (in_valid),\n                .in_data             (in_data),\n                .in_startofpacket    (in_startofpacket),\n                .in_endofpacket      (in_endofpacket),\n                .address             (address),\n                .readdata            (readdata),\n                .read                (read),\n                .write               (write),\n                .byteenable          (byteenable),\n                .writedata           (writedata),\n                .waitrequest         (waitrequest),\n                .readdatavalid       (readdatavalid),\n                .fifo_writedata      (fifo_writedata),\n                .fifo_write          (fifo_write),\n                .fifo_write_waitrequest (fifo_write_waitrequest)\n            );\n            \n            fifo_to_packet f2p (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .out_ready           (out_ready),\n                .out_valid           (out_valid),\n                .out_data            (out_data),\n                .out_startofpacket   (out_startofpacket),\n                .out_endofpacket     (out_endofpacket),\n                .fifo_readdata       (fifo_readdata),\n                .fifo_read           (fifo_read),\n                .fifo_empty          (fifo_empty)\n            );\n            \n            fifo_buffer #(\n                .FIFO_DEPTHS(FIFO_DEPTHS),\n                .FIFO_WIDTHU(FIFO_WIDTHU)\n            ) fb (\n                .wrclock                          (clk),\n                .reset_n                          (reset_n),\n                .avalonmm_write_slave_writedata   (fifo_writedata),  \n                .avalonmm_write_slave_write       (fifo_write),      \n                .avalonmm_write_slave_waitrequest (fifo_write_waitrequest),\n                .avalonmm_read_slave_readdata     (fifo_readdata),  \n                .avalonmm_read_slave_read         (fifo_read),      \n                .avalonmm_read_slave_waitrequest  (fifo_empty)\n            );\n       end else begin\n           packets_to_master p2m (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .in_ready            (in_ready),\n                .in_valid            (in_valid),\n                .in_data             (in_data),\n                .in_startofpacket    (in_startofpacket),\n                .in_endofpacket      (in_endofpacket),\n                .address             (address),\n                .readdata            (readdata),\n                .read                (read),\n                .write               (write),\n                .byteenable          (byteenable),\n                .writedata           (writedata),\n                .waitrequest         (waitrequest),\n                .readdatavalid       (readdatavalid),\n                .out_ready           (out_ready),\n                .out_valid           (out_valid),\n                .out_data            (out_data),\n                .out_startofpacket   (out_startofpacket),\n                .out_endofpacket     (out_endofpacket)\n            );\n       end\n   endgenerate\nendmodule\n\nmodule packets_to_fifo (\n\n      \n      input              clk,\n      input              reset_n,\n      \n      output reg         in_ready,\n      input              in_valid,\n      input      [ 7: 0] in_data,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      \n      output reg [31: 0] address,\n      input      [31: 0] readdata,\n      output reg         read,\n      output reg         write,\n      output reg [ 3: 0] byteenable,\n      output reg [31: 0] writedata,\n      input              waitrequest,\n      input              readdatavalid,\n      \n      \n      \n      \n      output reg [ 35: 0] fifo_writedata,\n      output reg        fifo_write,\n      input wire        fifo_write_waitrequest\n);\n\n   \n   \n   \n   localparam CMD_WRITE_NON_INCR = 8'h00;\n   localparam CMD_WRITE_INCR     = 8'h04;\n   localparam CMD_READ_NON_INCR  = 8'h10;\n   localparam CMD_READ_INCR      = 8'h14;\n   \n   \n   \n   \n\n   reg  [ 3: 0]  state;\n   reg  [ 7: 0]  command;\n   reg  [ 1: 0]  current_byte, byte_avail;\n   reg  [ 15: 0] counter;\n   reg  [ 31: 0] read_data_buffer;\n   reg  [ 31: 0] fifo_data_buffer;\n   reg           in_ready_0;\n   reg           first_trans, last_trans, fifo_sop;\n   reg  [ 3: 0]  unshifted_byteenable;\n   wire enable;\n\n   localparam READY           = 4'b0000,\n              GET_EXTRA       = 4'b0001,\n              GET_SIZE1       = 4'b0010,\n              GET_SIZE2       = 4'b0011,\n              GET_ADDR1       = 4'b0100,\n              GET_ADDR2       = 4'b0101,\n              GET_ADDR3       = 4'b0110,\n              GET_ADDR4       = 4'b0111,\n              GET_WRITE_DATA  = 4'b1000,\n              WRITE_WAIT      = 4'b1001,\n              READ_ASSERT     = 4'b1010,\n              READ_CMD_WAIT   = 4'b1011,\n              READ_DATA_WAIT  = 4'b1100,\n              PUSH_FIFO       = 4'b1101,\n              PUSH_FIFO_WAIT  = 4'b1110,\n              FIFO_CMD_WAIT   = 4'b1111;\n   \n   \n   \n\n   assign enable = (in_ready & in_valid);\n\n   always @* begin\n      in_ready = in_ready_0;      \n   end\n   \n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n            in_ready_0          <= 1'b0;\n            fifo_writedata      <=  'b0;\n            fifo_write          <= 1'b0;\n            fifo_sop            <= 1'b0;\n            read                <= 1'b0;\n            write               <= 1'b0;\n            byteenable          <=  'b0;\n            writedata           <=  'b0;\n            address             <=  'b0;\n            counter             <=  'b0;\n            command             <=  'b0;\n            first_trans         <= 1'b0;\n            last_trans          <= 1'b0;\n            state               <=  'b0;\n            current_byte        <=  'b0;\n            read_data_buffer    <=  'b0;\n            unshifted_byteenable <= 'b0;\n            byte_avail          <=  'b0;\n            fifo_data_buffer    <=  'b0;\n      end else begin\n            address[1:0]      <= 'b0;\n            in_ready_0 <= 1'b0;\n            \n            if (counter > 3)       unshifted_byteenable <= 4'b1111;\n            else if (counter == 3) unshifted_byteenable <= 4'b0111;\n            else if (counter == 2) unshifted_byteenable <= 4'b0011;\n            else if (counter == 1) unshifted_byteenable <= 4'b0001;\n\n            case (state)\n              READY : begin\n                   in_ready_0        <= !fifo_write_waitrequest;\n                   fifo_write        <= 1'b0;\n              end\n              GET_EXTRA : begin\n                   in_ready_0        <= 1'b1;\n                   byteenable        <=  'b0;\n                   if (enable) state <= GET_SIZE1;\n              end\n\n              GET_SIZE1 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[15:8]     <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_SIZE2;\n              end\n\n              GET_SIZE2 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[7:0]      <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_ADDR1;\n              end\n              \n              GET_ADDR1 : begin\n                in_ready_0        <= 1'b1;\n                first_trans       <= 1'b1;\n                last_trans        <= 1'b0;\n                address[31:24]    <= in_data;\n                if (enable) state <= GET_ADDR2;\n              end\n\n              GET_ADDR2 : begin\n                in_ready_0        <= 1'b1;\n                address[23:16]    <= in_data;\n                if (enable) state <= GET_ADDR3;\n              end\n\n              GET_ADDR3 : begin\n                in_ready_0        <= 1'b1;\n                address[15:8]     <= in_data;\n                if (enable) state <= GET_ADDR4;\n              end\n\n              GET_ADDR4 : begin\n                in_ready_0        <= 1'b1;\n                address[7:2]      <= in_data[7:2];\n                current_byte      <= in_data[1:0];\n                if (enable) begin\n                      if (command == CMD_WRITE_NON_INCR | command == CMD_WRITE_INCR) begin\n                        state <= GET_WRITE_DATA; \n                        in_ready_0 <= 1'b1;\n                      end\n                      else if (command == CMD_READ_NON_INCR | command == CMD_READ_INCR) begin\n                        state   <= READ_ASSERT; \n                        in_ready_0 <= 1'b0;\n                      end\n                      else begin\n                        \n                        \n                        in_ready_0          <= 1'b0;\n                        state <= FIFO_CMD_WAIT; \n                        \n                        \n                        fifo_writedata[7:0] <= (8'h80 | command);\n                        fifo_writedata[35:8]<= {4'b1111,counter[7:0],counter[15:8],8'b0};\n                        fifo_write          <= 1'b1;    \n                        counter             <= 0;\n                      end\n                end\n              end\n\n              GET_WRITE_DATA : begin\n                        in_ready_0 <= 1'b1; \n                        if (enable) begin\n                          counter <= counter + 1'b1;\n                          \n                          current_byte <= current_byte + 1'b1;\n                          if (in_endofpacket || current_byte == 3) \n                          begin\n                             in_ready_0 <= 1'b0;\n                             write      <= 1'b1;\n                             state      <= WRITE_WAIT;\n                          end\n                        end\n                        if (in_endofpacket) begin\n                          last_trans <= 1'b1;\n                        end\n                        \n                        \n                        case (current_byte)\n                          0: begin\n                            writedata[7:0]   <= in_data;\n                            byteenable[0]    <= 1'b1;\n                          end\n                          1: begin\n                            writedata[15:8]  <= in_data;\n                            byteenable[1]    <= 1'b1;\n                          end\n                          2: begin\n                            writedata[23:16] <= in_data;\n                            byteenable[2]    <= 1'b1;\n                          end\n                          3: begin\n                            writedata[31:24] <= in_data;\n                            byteenable[3]    <= 1'b1;\n                          end\n                        endcase\n              end\n              WRITE_WAIT : begin\n                        in_ready_0 <= 1'b0;\n                        write      <= 1'b1;\n                        if (~waitrequest) begin\n                           write <= 1'b0;\n                           state <= GET_WRITE_DATA;\n                           in_ready_0 <= 1'b1;\n                           byteenable <= 'b0;\n                           if (command[2] == 1'b1) begin\n                              \n                              address[31:2] <= (address[31:2] + 1'b1);\n                           end\n                           if (last_trans) begin\n                               in_ready_0         <= 1'b0;\n                               state <= FIFO_CMD_WAIT;\n                               \n                               \n                               fifo_writedata[7:0] <= (8'h80 | command);\n                               fifo_writedata[35:8]<= {4'b1111,counter[7:0],counter[15:8],8'b0};\n                               fifo_write          <= 1'b1;\n                               counter             <= 0;\n                           end\n                        end\n              end\n              READ_ASSERT : begin\n                            if (current_byte == 3) byteenable <= unshifted_byteenable << 3;\n                            if (current_byte == 2) byteenable <= unshifted_byteenable << 2;\n                            if (current_byte == 1) byteenable <= unshifted_byteenable << 1;\n                            if (current_byte == 0) byteenable <= unshifted_byteenable;\n                            read             <= 1'b1;\n                            fifo_write       <= 1'b0;\n                            state            <= READ_CMD_WAIT;\n              end\n              READ_CMD_WAIT : begin\n                        \n                        case (byteenable)\n                            4'b0000 : byte_avail <= 1'b0;\n                            4'b0001 : byte_avail <= 1'b0;\n                            4'b0010 : byte_avail <= 1'b0;\n                            4'b0100 : byte_avail <= 1'b0;\n                            4'b1000 : byte_avail <= 1'b0;\n                            4'b0011 : byte_avail <= 1'b1;\n                            4'b0110 : byte_avail <= 1'b1;\n                            4'b1100 : byte_avail <= 1'b1;\n                            4'b0111 : byte_avail <= 2'h2;\n                            4'b1110 : byte_avail <= 2'h2;\n                            default : byte_avail <= 2'h3;\n                        endcase\n                        read_data_buffer <= readdata;\n                        read             <= 1; \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        if (readdatavalid) begin\n                           state <= PUSH_FIFO;\n                           read <= 0;\n                        end else begin\n                           if (~waitrequest) begin\n                               state <= READ_DATA_WAIT;\n                               read <= 0;\n                           end\n                        end\n              end\n              READ_DATA_WAIT : begin\n                        read_data_buffer <= readdata;\n                        if (readdatavalid) begin\n                            state <= PUSH_FIFO;\n                        end\n              end              \n              PUSH_FIFO : begin\n                        fifo_write <= 1'b0;\n                        fifo_sop   <= 1'b0;\n                        if (first_trans) begin\n                            first_trans <= 1'b0;\n                            fifo_sop    <= 1'b1;\n                        end\n                        case (current_byte)\n                            3 : begin\n                                fifo_data_buffer <= read_data_buffer >> 24;\n                                counter <= counter - 1'b1;\n                            end\n                            2 : begin\n                                fifo_data_buffer <= read_data_buffer >> 16;\n                                if (counter == 1) counter <= 0;\n                                else counter <= counter - 2'h2;\n                            end\n                            1 : begin\n                                fifo_data_buffer <= read_data_buffer >> 8;\n                                if (counter < 3) counter <= 0;\n                                else counter <= counter - 2'h3;\n                            end\n                            default : begin\n                                fifo_data_buffer <= read_data_buffer;\n                                if (counter < 4) counter <= 0;\n                                else counter <= counter - 3'h4;\n                            end\n                        endcase\n                        current_byte <= 0;\n                        state <= PUSH_FIFO_WAIT;\n              end\n              PUSH_FIFO_WAIT : begin\n                            \n                            fifo_write     <= 1'b1;\n                            fifo_writedata <= {fifo_sop,(counter == 0)?1'b1:1'b0,byte_avail,fifo_data_buffer};\n                            \n                            \n                            \n                            \n                            \n                            \n                            if (counter == 0) begin\n                                state <= FIFO_CMD_WAIT;\n                            end else if (command[2]== 1'b1) begin\n                                    \n                                    state <= FIFO_CMD_WAIT;\n                                    address[31:2] <= (address[31:2] + 1'b1);\n                            end\n              end\n              FIFO_CMD_WAIT : begin\n                        \n                        if (!fifo_write_waitrequest) begin\n                            if (counter == 0) begin\n                                state       <= READY;\n                            end else begin\n                                state <= READ_ASSERT;\n                            end\n                            fifo_write  <= 1'b0;\n                        end\n              end\n           endcase\n           if (enable & in_startofpacket) begin\n              state      <= GET_EXTRA;\n              command    <= in_data;\n              in_ready_0 <= !fifo_write_waitrequest;\n           end\n      end  \n   end  \nendmodule\n\n\n\n\n\n\n\n\nmodule fifo_buffer_single_clock_fifo (\n                                                   \n                                                    aclr,\n                                                    clock,\n                                                    data,\n                                                    rdreq,\n                                                    wrreq,\n\n                                                   \n                                                    empty,\n                                                    full,\n                                                    q\n                                                 )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n\n  output           empty;\n  output           full;\n  output  [ 35: 0] q;\n  input            aclr;\n  input            clock;\n  input   [ 35: 0] data;\n  input            rdreq;\n  input            wrreq;\n\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  scfifo single_clock_fifo\n    (\n      .aclr (aclr),\n      .clock (clock),\n      .data (data),\n      .empty (empty),\n      .full (full),\n      .q (q),\n      .rdreq (rdreq),\n      .wrreq (wrreq)\n    );\n\n  defparam single_clock_fifo.add_ram_output_register = \"OFF\",\n           single_clock_fifo.lpm_numwords = FIFO_DEPTHS,\n           single_clock_fifo.lpm_showahead = \"OFF\",\n           single_clock_fifo.lpm_type = \"scfifo\",\n           single_clock_fifo.lpm_width = 36,\n           single_clock_fifo.lpm_widthu = FIFO_WIDTHU,\n           single_clock_fifo.overflow_checking = \"ON\",\n           single_clock_fifo.underflow_checking = \"ON\",\n           single_clock_fifo.use_eab = \"OFF\";\n\n\nendmodule\n\n\n\n\n\n\n\nmodule fifo_buffer_scfifo_with_controls (\n                                                      \n                                                       clock,\n                                                       data,\n                                                       rdreq,\n                                                       reset_n,\n                                                       wrreq,\n\n                                                      \n                                                       empty,\n                                                       full,\n                                                       q\n                                                    )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n  \n  output           empty;\n  output           full;\n  output  [ 35: 0] q;\n  input            clock;\n  input   [ 35: 0] data;\n  input            rdreq;\n  input            reset_n;\n  input            wrreq;\n\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  wire             wrreq_valid;\n  \n  fifo_buffer_single_clock_fifo #(\n            .FIFO_DEPTHS(FIFO_DEPTHS),\n            .FIFO_WIDTHU(FIFO_WIDTHU)\n  ) the_scfifo (\n      .aclr  (~reset_n),\n      .clock (clock),\n      .data  (data),\n      .empty (empty),\n      .full  (full),\n      .q     (q),\n      .rdreq (rdreq),\n      .wrreq (wrreq_valid)\n    );\n\n  assign wrreq_valid = wrreq & ~full;\n\nendmodule\n\n\n\n\n\nmodule fifo_buffer (\n                                 \n                                  avalonmm_read_slave_read,\n                                  avalonmm_write_slave_write,\n                                  avalonmm_write_slave_writedata,\n                                  reset_n,\n                                  wrclock,\n\n                                 \n                                  avalonmm_read_slave_readdata,\n                                  avalonmm_read_slave_waitrequest,\n                                  avalonmm_write_slave_waitrequest\n                               )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n\n\n  output  [ 35: 0] avalonmm_read_slave_readdata;\n  output           avalonmm_read_slave_waitrequest;\n  output           avalonmm_write_slave_waitrequest;\n  input            avalonmm_read_slave_read;\n  input            avalonmm_write_slave_write;\n  input   [ 35: 0] avalonmm_write_slave_writedata;\n  input            reset_n;\n  input            wrclock;\n\n  wire    [ 35: 0] avalonmm_read_slave_readdata;\n  wire             avalonmm_read_slave_waitrequest;\n  wire             avalonmm_write_slave_waitrequest;\n  wire             clock;\n  wire    [ 35: 0] data;\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  wire             rdreq;\n  wire             wrreq;\n  \n  fifo_buffer_scfifo_with_controls #(\n      .FIFO_DEPTHS(FIFO_DEPTHS),\n      .FIFO_WIDTHU(FIFO_WIDTHU)\n  ) the_scfifo_with_controls\n    (\n      .clock   (clock),\n      .data    (data),\n      .empty   (empty),\n      .full    (full),\n      .q       (q),\n      .rdreq   (rdreq),\n      .reset_n (reset_n),\n      .wrreq   (wrreq)\n    );\n\n  \n  \n  assign data = avalonmm_write_slave_writedata;\n  assign wrreq = avalonmm_write_slave_write;\n  assign avalonmm_read_slave_readdata = q;\n  assign rdreq = avalonmm_read_slave_read;\n  assign clock = wrclock;\n  assign avalonmm_write_slave_waitrequest = full;\n  assign avalonmm_read_slave_waitrequest = empty;\n\nendmodule\n\n\n\n\n\nmodule fifo_to_packet (\n\n      \n      input              clk,\n      input              reset_n,\n\n      \n      input              out_ready,\n      output reg         out_valid,\n      output reg [ 7: 0] out_data,\n      output reg         out_startofpacket,\n      output reg         out_endofpacket,\n\n      \n      input  [ 35: 0]    fifo_readdata,\n      output reg         fifo_read,\n      input              fifo_empty \n);\n\nreg [ 1: 0]     state;\nreg             enable, sent_all;\nreg [ 1: 0]     current_byte, byte_end;\nreg             first_trans, last_trans;\nreg [ 23:0]     fifo_data_buffer;\n\nlocalparam    POP_FIFO        = 2'b00,\n              POP_FIFO_WAIT   = 2'b01,\n              FIFO_DATA_WAIT  = 2'b10,\n              READ_SEND_ISSUE = 2'b11;\n\nalways @* begin\n      enable = (!fifo_empty & sent_all);\nend\n          \nalways @(posedge clk or negedge reset_n) begin\n          if (!reset_n) begin\n                fifo_data_buffer  <=  'b0;\n                out_startofpacket <= 1'b0;\n                out_endofpacket   <= 1'b0;\n                out_valid         <= 1'b0;\n                out_data          <=  'b0;\n                state             <=  'b0;\n                fifo_read         <= 1'b0;\n                current_byte      <=  'b0;\n                byte_end          <=  'b0;\n                first_trans       <= 1'b0;\n                last_trans        <= 1'b0;\n                sent_all          <= 1'b1;\n          end else begin\n                if (out_ready) begin\n                  out_startofpacket <= 1'b0;\n                  out_endofpacket   <= 1'b0;\n                end\n                \n                case (state)\n                  POP_FIFO : begin\n                            if (out_ready) begin\n                                out_startofpacket   <= 1'b0;\n                                out_endofpacket     <= 1'b0;\n                                out_valid           <= 1'b0;\n                                first_trans         <= 1'b0;\n                                last_trans          <= 1'b0;\n                                byte_end            <=  'b0;\n                                fifo_read           <= 1'b0;\n                                sent_all            <= 1'b1;\n                            end\n                            \n                            if (enable) begin   \n                                fifo_read       <= 1'b1;\n                                out_valid       <= 1'b0;\n                                state           <= POP_FIFO_WAIT;\n                            end\n                  end\n                  POP_FIFO_WAIT : begin\n                  \n                                fifo_read               <= 1'b0;\n                                state                   <= FIFO_DATA_WAIT;\n                  end\n                  FIFO_DATA_WAIT : begin\n                                sent_all                <= 1'b0;\n                                first_trans             <= fifo_readdata[35];\n                                last_trans              <= fifo_readdata[34];\n                                out_data                <= fifo_readdata[7:0];\n                                fifo_data_buffer        <= fifo_readdata[31:8];\n                                byte_end                <= fifo_readdata[33:32];\n                                current_byte            <= 1'b1;\n                                out_valid               <= 1'b1;\n                                \n                                \n                                if (fifo_readdata[35] & fifo_readdata[34] & (fifo_readdata[33:32] == 0)) begin\n                                    first_trans         <= 1'b0;\n                                    last_trans          <= 1'b0;\n                                    out_startofpacket   <= 1'b1;\n                                    out_endofpacket     <= 1'b1;\n                                    state <= POP_FIFO;\n                                end else if (fifo_readdata[35] & (fifo_readdata[33:32] == 0)) begin\n                                    first_trans         <= 1'b0;\n                                    out_startofpacket   <= 1'b1;\n                                    state               <= POP_FIFO;\n                                end else if (fifo_readdata[35]) begin\n                                   first_trans          <= 1'b0;\n                                   out_startofpacket    <= 1'b1;\n                                   state <= READ_SEND_ISSUE;\n                                end else if (fifo_readdata[34] & (fifo_readdata[33:32] == 0)) begin\n                                    last_trans          <= 1'b0;\n                                    out_endofpacket     <= 1'b1;\n                                    state               <= POP_FIFO;\n                                end else begin\n                                    state               <= READ_SEND_ISSUE;\n                                end\n                                \n                  end\n                  READ_SEND_ISSUE : begin\n                            out_valid         <= 1'b1;\n                            sent_all          <= 1'b0;\n                            \n                            if (out_ready) begin\n                                out_startofpacket <= 1'b0;\n                                \n                                if (last_trans & (current_byte == byte_end)) begin\n                                        last_trans      <= 1'b0;\n                                        out_endofpacket <= 1'b1;\n                                        state           <= POP_FIFO;\n                                end\n                                case (current_byte)\n                                       3: begin\n                                          out_data <= fifo_data_buffer[23:16];\n                                       end\n                                       2: begin\n                                          out_data <= fifo_data_buffer[15:8];\n                                       end\n                                       1: begin\n                                          out_data <= fifo_data_buffer[7:0];\n                                       end\n                                       default: begin\n                                          \n                                       end\n                                endcase\n                                current_byte <= current_byte + 1'b1;\n                                if (current_byte == byte_end) begin\n                                    state <= POP_FIFO;\n                                end else begin\n                                    state <= READ_SEND_ISSUE;\n                                end\n                            end\n                  end\n                endcase\n          end\n    end\nendmodule\n\n\n\n\nmodule packets_to_master (\n\n      \n      input              clk,\n      input              reset_n,\n      \n      output reg         in_ready,\n      input              in_valid,\n      input      [ 7: 0] in_data,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      \n      input              out_ready,\n      output reg         out_valid,\n      output reg [ 7: 0] out_data,\n      output reg         out_startofpacket,\n      output reg         out_endofpacket,\n\n      \n      output reg [31: 0] address,\n      input      [31: 0] readdata,\n      output reg         read,\n      output reg         write,\n      output reg [ 3: 0] byteenable,\n      output reg [31: 0] writedata,\n      input              waitrequest,\n      input              readdatavalid\n      \n);\n\n   \n   \n   \n   parameter EXPORT_MASTER_SIGNALS = 0;\n\n   \n   \n   \n   localparam CMD_WRITE_NON_INCR = 8'h00;\n   localparam CMD_WRITE_INCR     = 8'h04;\n   localparam CMD_READ_NON_INCR  = 8'h10;\n   localparam CMD_READ_INCR      = 8'h14;\n   \n   \n   \n   \n\n   reg  [ 3: 0]  state;\n   reg  [ 7: 0]  command;\n   reg  [ 1: 0]  current_byte; \n   reg  [ 15: 0] counter;\n   reg  [ 23: 0] read_data_buffer;\n   reg           in_ready_0;\n   reg           first_trans, last_trans;\n   reg  [ 3: 0]  unshifted_byteenable;\n   wire enable;\n\n   localparam READY          = 4'b0000, \n              GET_EXTRA      = 4'b0001,\n              GET_SIZE1      = 4'b0010,\n              GET_SIZE2      = 4'b0011,\n              GET_ADDR1      = 4'b0100,\n              GET_ADDR2      = 4'b0101,\n              GET_ADDR3      = 4'b0110,\n              GET_ADDR4      = 4'b0111,\n              GET_WRITE_DATA = 4'b1000,      \n              WRITE_WAIT     = 4'b1001,\n              RETURN_PACKET  = 4'b1010,\n              READ_ASSERT    = 4'b1011,\n              READ_CMD_WAIT  = 4'b1100,\n              READ_DATA_WAIT = 4'b1101,\n              READ_SEND_ISSUE= 4'b1110,\n              READ_SEND_WAIT = 4'b1111;\n   \n   \n   \n   \n   \n\n   assign enable = (in_ready & in_valid);\n\n   always @*\n\n      in_ready = in_ready_0;\n   \n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n            in_ready_0        <= 1'b0;\n            out_startofpacket <= 1'b0;\n            out_endofpacket   <= 1'b0;\n            out_valid         <= 1'b0;\n            out_data          <=  'b0;\n            read              <= 1'b0;\n            write             <= 1'b0;\n            byteenable        <=  'b0;\n            writedata         <=  'b0;\n            address           <=  'b0;\n            counter           <=  'b0;\n            command           <=  'b0;\n            first_trans       <= 1'b0;\n            last_trans        <= 1'b0;\n            state             <= 'b0;\n            current_byte      <= 'b0;\n          \n            read_data_buffer  <= 'b0;\n            unshifted_byteenable <= 'b0;\n      end else begin\n            address[1:0]      <= 'b0;\n \n            if (out_ready) begin\n              out_startofpacket <= 1'b0;\n              out_endofpacket   <= 1'b0;\n              out_valid         <= 1'b0;\n            end\n            in_ready_0 <= 1'b0;\n            \n            if (counter >= 3)      unshifted_byteenable <= 4'b1111;\n            else if (counter == 3) unshifted_byteenable <= 4'b0111;\n            else if (counter == 2) unshifted_byteenable <= 4'b0011;\n            else if (counter == 1) unshifted_byteenable <= 4'b0001;\n\n            case (state)\n              READY : begin\n                   out_valid         <= 1'b0;\n                   in_ready_0        <= 1'b1;\n              end\n              GET_EXTRA : begin\n                   in_ready_0        <= 1'b1;\n                   byteenable        <=  'b0;\n                   if (enable) state <= GET_SIZE1;\n              end\n\n              GET_SIZE1 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[15:8]     <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_SIZE2;\n              end\n\n              GET_SIZE2 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[7:0]      <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_ADDR1;\n              end\n              \n              GET_ADDR1 : begin\n                in_ready_0        <= 1'b1;\n                first_trans       <= 1'b1;\n                last_trans        <= 1'b0;\n                address[31:24]    <= in_data;\n                if (enable) state <= GET_ADDR2;\n              end\n\n              GET_ADDR2 : begin\n                in_ready_0        <= 1'b1;\n                address[23:16]    <= in_data;\n                if (enable) state <= GET_ADDR3;\n              end\n\n              GET_ADDR3 : begin\n                in_ready_0        <= 1'b1;\n                address[15:8]     <= in_data;\n                if (enable) state <= GET_ADDR4;\n              end\n\n              GET_ADDR4 : begin\n                in_ready_0        <= 1'b1;\n                address[7:2]      <= in_data[7:2];\n                current_byte      <= in_data[1:0];\n                if (enable) begin\n                      if (command == CMD_WRITE_NON_INCR | command == CMD_WRITE_INCR) begin\n                        state <= GET_WRITE_DATA; \n                        in_ready_0 <= 1'b1;\n                      end\n                      else if (command == CMD_READ_NON_INCR | command == CMD_READ_INCR) begin\n                        state   <= READ_ASSERT; \n                        in_ready_0 <= 1'b0;\n                      end\n                      else begin\n                        \n                        \n                        state <= RETURN_PACKET; \n                        out_startofpacket <= 1'b1;\n                        out_data <= (8'h80 | command);\n                        out_valid <= 1'b1;\n                        current_byte <= 'h0;\n                        in_ready_0 <= 1'b0;\n                      end\n                end\n              end\n\n              GET_WRITE_DATA : begin\n                        in_ready_0 <= 1; \n                        if (enable) begin\n                          counter <= counter + 1'b1;\n                          \n                          current_byte <= current_byte + 1'b1;\n                          if (in_endofpacket || current_byte == 3) \n                          begin\n                             in_ready_0 <= 0;\n                             write      <= 1'b1;\n                             state      <= WRITE_WAIT;\n                          end\n                        end\n                        if (in_endofpacket) begin\n                          last_trans <= 1'b1;\n                        end\n                        \n                        \n                        case (current_byte)\n                          0: begin\n                            writedata[7:0]   <= in_data;\n                            byteenable[0]    <= 1;\n                          end\n                          1: begin\n                            writedata[15:8]  <= in_data;\n                            byteenable[1]    <= 1;\n                          end\n                          2: begin\n                            writedata[23:16] <= in_data;\n                            byteenable[2]    <= 1;\n                          end\n                          3: begin\n                            writedata[31:24] <= in_data;\n                            byteenable[3]    <= 1;\n                          end\n                        endcase\n              end\n\n              WRITE_WAIT : begin\n                        in_ready_0 <= 0;\n                        write      <= 1'b1;\n                        if (~waitrequest) begin\n                           write <= 1'b0;\n                           state <= GET_WRITE_DATA;\n                           in_ready_0 <= 1;\n                           byteenable <= 'b0;\n                           if (command[2] == 1'b1) begin\n                              \n                              address[31:2] <= (address[31:2] + 1'b1);\n                           end\n                           if (last_trans) begin\n                              state <= RETURN_PACKET;\n                              out_startofpacket <= 1'b1;\n                              out_data <= (8'h80 | command);\n                              out_valid <= 1'b1;\n                              current_byte <= 'h0;\n                              in_ready_0 <= 1'b0;\n                           end\n                        end\n              end\n              \n              RETURN_PACKET : begin\n                        out_valid <= 1'b1;\n                        if (out_ready) begin\n                           case (current_byte)\n                          \n                          \n                          \n                          \n                             0: begin\n                               out_data <= 8'b0;\n                             end\n                             1: begin\n                               out_data <= counter[15:8];\n                             end\n                             2: begin\n                               out_endofpacket <= 1'b1;\n                               out_data <= counter[7:0];\n                             end\n                             default: begin\n                          \n                          \n                          \n                             end\n                           endcase\n                           current_byte <= current_byte + 1'b1;\n                           if (current_byte == 3) begin\n                              state     <= READY;\n                              out_valid <= 1'b0;\n                           end\n                           else                   state     <= RETURN_PACKET;\n                        end\n              end\n              READ_ASSERT : begin\n                        if (current_byte == 3) byteenable <= unshifted_byteenable << 3;\n                        if (current_byte == 2) byteenable <= unshifted_byteenable << 2;\n                        if (current_byte == 1) byteenable <= unshifted_byteenable << 1;\n                        if (current_byte == 0) byteenable <= unshifted_byteenable;\n\n                        read             <= 1;\n                        state            <= READ_CMD_WAIT;\n              end\n              READ_CMD_WAIT : begin\n                        read_data_buffer <= readdata[31:8];\n                        out_data         <= readdata[7:0];\n                        read             <= 1; \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        if (readdatavalid) begin\n                           state <= READ_SEND_ISSUE;\n                           read <= 0;\n                        end else begin\n                           if (~waitrequest) begin\n                               state <= READ_DATA_WAIT;\n                               read <= 0;\n                           end\n                        end\n              end\n              READ_DATA_WAIT : begin\n                        read_data_buffer <= readdata[31:8];\n                        out_data         <= readdata[7:0];\n                        if (readdatavalid) begin\n                            state <= READ_SEND_ISSUE;\n                        end\n              end\n              READ_SEND_ISSUE : begin\n                        out_valid <= 1'b1;\n                        out_startofpacket <= 'h0;\n                        out_endofpacket   <= 'h0;\n                        if (counter == 1) begin\n                           out_endofpacket <= 1'b1;\n                        end \n                        if (first_trans) begin\n                           first_trans <= 1'b0;\n                           out_startofpacket <= 1'b1;\n                        end\n                        case (current_byte)\n                          3: begin\n                             out_data        <= read_data_buffer[23:16];\n                          end\n                          2: begin\n                             out_data        <= read_data_buffer[15:8];\n                          end\n                          1: begin\n                             out_data        <= read_data_buffer[7:0];\n                          end\n                          default: begin\n                             out_data        <= out_data; \n                          end\n                        endcase\n                        state <= READ_SEND_WAIT;\n              end\n              READ_SEND_WAIT : begin\n                        out_valid <= 1'b1;\n                        if (out_ready) begin\n                           counter <= counter - 1'b1;\n                           current_byte <= current_byte + 1'b1;\n                           out_valid <= 1'b0;\n                           \n                           \n                           \n                           \n                           \n                           \n                           if (counter == 1) begin\n                              state <= READY;\n                           \n                           \n                           end else if (current_byte == 3) begin\n                              if (command[2] == 1'b1) begin\n                                 \n                                 address[31:2] <= (address[31:2] + 1'b1);\n                              end\n                              state <= READ_ASSERT;\n                           \n                           end else begin\n                              state <= READ_SEND_ISSUE;\n                           end\n                           \n                           \n                        end \n              end\n           endcase\n           if (enable & in_startofpacket) begin\n              state <= GET_EXTRA;\n              command           <= in_data;\n              in_ready_0 <= 1'b1;\n           end\n      end  \n   end  \nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_avalon_packets_to_master. Module specification: This module is a packet-to-master converter for Altera Avalon interfaces, designed to receive packet data through an input interface, process it, and convert it into Avalon master read/write transactions. It supports two operational modes: a fast version using separate submodules (packets_to_fifo, fifo_to_packet, and fifo_buffer) for packet conversion and buffering, and a standard version using a single packets_to_master module for direct conversion. The module handles various command types for read and write operations, supporting both incrementing and non-incrementing address modes. Input ports include clk, reset_n, in_valid, in_data, in_startofpacket, in_endofpacket, out_ready, readdata, waitrequest, and readdatavalid, while output ports include"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_avalon_packets_to_master\n\nExplanation: This module appears to be a packet-to-master converter for Altera Avalon interfaces. It receives packet data through an input interface, processes it, and converts it into Avalon master read/write transactions. The module can operate in two modes:\n\n1. Fast version: Uses separate submodules (packets_to_fifo, fifo_to_packet, and fifo_buffer) to handle packet conversion and buffering.\n2. Standard version: Uses a single packets_to_master module for direct packet-to-master conversion.\n\nThe module supports various command types for read and write operations, with both incrementing and non-incrementing address modes. It handles packet framing, address decoding, and data buffering to facilitate the conversion between packet-based communication and Avalon master transactions."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, reset_n, in_valid, in_data, in_startofpacket, in_endofpacket, out_ready, readdata, waitrequest, readdatavalid\n\nExplanation:\n- clk: System clock input\n- reset_n: Active-low reset input\n- in_valid: Input data valid signal\n- in_data: 8-bit input data\n- in_startofpacket: Start of packet indicator for input\n- in_endofpacket: End of packet indicator for input\n- out_ready: Downstream module ready to accept output\n- readdata: 32-bit data input for read operations\n- waitrequest: Wait request signal from Avalon slave\n- readdatavalid: Read data valid signal from Avalon slave\n\nOutput ports:\nin_ready, out_valid, out_data, out_startofpacket, out_endofpacket, address, read, write, byteenable, writedata\n\nExplanation:\n- in_ready: Module ready to accept input data\n- out_valid: Output data valid signal\n- out_data: 8-bit output data\n- out_startofpacket: Start of packet indicator for output\n- out_endofpacket: End of packet indicator for output\n- address: 32-bit address for Avalon master transactions\n- read: Read request signal for Avalon master\n- write: Write request signal for Avalon master\n- byteenable: 4-bit byte enable signal for Avalon master\n- writedata: 32-bit data output for write operations"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nBased on the provided Verilog code for the altera_avalon_packets_to_master module, here are the internal signals and their explanations:\n\nInternal signals: fifo_readdata, fifo_read, fifo_empty, fifo_writedata, fifo_write, fifo_write_waitrequest.\n\nExplanation:\n1. fifo_readdata [35:0]: Data output from the FIFO buffer, containing packet information and payload.\n2. fifo_read: Control signal to read data from the FIFO buffer.\n3. fifo_empty: Status signal indicating whether the FIFO buffer is empty.\n4. fifo_writedata [35:0]: Data input to the FIFO buffer, containing packet information and payload.\n5. fifo_write: Control signal to write data to the FIFO buffer.\n6. fifo_write_waitrequest: Status signal indicating whether the FIFO buffer is ready to accept new data.\n\nThese internal signals are used to interface between the packets_to_fifo, fifo_to_packet, and fifo_buffer submodules when the fast version of the converter is used. They facilitate the buffering and transfer of packet data between the input interface and the Avalon master interface."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n`timescale 1ns / 100ps\n\n\n\nmodule altera_avalon_packets_to_master (\n    \n      input wire             clk,\n      input wire             reset_n,\n      \n      output wire         in_ready,\n      input  wire         in_valid,\n      input  wire [ 7: 0] in_data,\n      input  wire         in_startofpacket,\n      input  wire         in_endofpacket,\n\n      \n      input  wire         out_ready,\n      output wire         out_valid,\n      output wire [ 7: 0] out_data,\n      output wire         out_startofpacket,\n      output wire         out_endofpacket,\n\n      \n      output wire [31: 0] address,\n      input  wire [31: 0] readdata,\n      output wire         read,\n      output wire         write,\n      output wire [ 3: 0] byteenable,\n      output wire [31: 0] writedata,\n      input  wire         waitrequest,\n      input  wire         readdatavalid\n);\n\n    wire [ 35: 0] fifo_readdata;\n    wire          fifo_read;\n    wire          fifo_empty;\n    wire [ 35: 0] fifo_writedata;\n    wire          fifo_write;\n    wire          fifo_write_waitrequest;\n    \n   \n   \n   \n   parameter EXPORT_MASTER_SIGNALS = 0;\n   parameter FIFO_DEPTHS           = 2;\n   parameter FIFO_WIDTHU           = 1;\n   parameter FAST_VER              = 0;\n   \n   generate\n       if (FAST_VER) begin\n            packets_to_fifo p2f (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .in_ready            (in_ready),\n                .in_valid            (in_valid),\n                .in_data             (in_data),\n                .in_startofpacket    (in_startofpacket),\n                .in_endofpacket      (in_endofpacket),\n                .address             (address),\n                .readdata            (readdata),\n                .read                (read),\n                .write               (write),\n                .byteenable          (byteenable),\n                .writedata           (writedata),\n                .waitrequest         (waitrequest),\n                .readdatavalid       (readdatavalid),\n                .fifo_writedata      (fifo_writedata),\n                .fifo_write          (fifo_write),\n                .fifo_write_waitrequest (fifo_write_waitrequest)\n            );\n            \n            fifo_to_packet f2p (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .out_ready           (out_ready),\n                .out_valid           (out_valid),\n                .out_data            (out_data),\n                .out_startofpacket   (out_startofpacket),\n                .out_endofpacket     (out_endofpacket),\n                .fifo_readdata       (fifo_readdata),\n                .fifo_read           (fifo_read),\n                .fifo_empty          (fifo_empty)\n            );\n            \n            fifo_buffer #(\n                .FIFO_DEPTHS(FIFO_DEPTHS),\n                .FIFO_WIDTHU(FIFO_WIDTHU)\n            ) fb (\n                .wrclock                          (clk),\n                .reset_n                          (reset_n),\n                .avalonmm_write_slave_writedata   (fifo_writedata),  \n                .avalonmm_write_slave_write       (fifo_write),      \n                .avalonmm_write_slave_waitrequest (fifo_write_waitrequest),\n                .avalonmm_read_slave_readdata     (fifo_readdata),  \n                .avalonmm_read_slave_read         (fifo_read),      \n                .avalonmm_read_slave_waitrequest  (fifo_empty)\n            );\n       end else begin\n           packets_to_master p2m (\n                .clk                 (clk),\n                .reset_n             (reset_n),\n                .in_ready            (in_ready),\n                .in_valid            (in_valid),\n                .in_data             (in_data),\n                .in_startofpacket    (in_startofpacket),\n                .in_endofpacket      (in_endofpacket),\n                .address             (address),\n                .readdata            (readdata),\n                .read                (read),\n                .write               (write),\n                .byteenable          (byteenable),\n                .writedata           (writedata),\n                .waitrequest         (waitrequest),\n                .readdatavalid       (readdatavalid),\n                .out_ready           (out_ready),\n                .out_valid           (out_valid),\n                .out_data            (out_data),\n                .out_startofpacket   (out_startofpacket),\n                .out_endofpacket     (out_endofpacket)\n            );\n       end\n   endgenerate\nendmodule\n\nmodule packets_to_fifo (\n\n      \n      input              clk,\n      input              reset_n,\n      \n      output reg         in_ready,\n      input              in_valid,\n      input      [ 7: 0] in_data,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      \n      output reg [31: 0] address,\n      input      [31: 0] readdata,\n      output reg         read,\n      output reg         write,\n      output reg [ 3: 0] byteenable,\n      output reg [31: 0] writedata,\n      input              waitrequest,\n      input              readdatavalid,\n      \n      \n      \n      \n      output reg [ 35: 0] fifo_writedata,\n      output reg        fifo_write,\n      input wire        fifo_write_waitrequest\n);\n\n   \n   \n   \n   localparam CMD_WRITE_NON_INCR = 8'h00;\n   localparam CMD_WRITE_INCR     = 8'h04;\n   localparam CMD_READ_NON_INCR  = 8'h10;\n   localparam CMD_READ_INCR      = 8'h14;\n   \n   \n   \n   \n\n   reg  [ 3: 0]  state;\n   reg  [ 7: 0]  command;\n   reg  [ 1: 0]  current_byte, byte_avail;\n   reg  [ 15: 0] counter;\n   reg  [ 31: 0] read_data_buffer;\n   reg  [ 31: 0] fifo_data_buffer;\n   reg           in_ready_0;\n   reg           first_trans, last_trans, fifo_sop;\n   reg  [ 3: 0]  unshifted_byteenable;\n   wire enable;\n\n   localparam READY           = 4'b0000,\n              GET_EXTRA       = 4'b0001,\n              GET_SIZE1       = 4'b0010,\n              GET_SIZE2       = 4'b0011,\n              GET_ADDR1       = 4'b0100,\n              GET_ADDR2       = 4'b0101,\n              GET_ADDR3       = 4'b0110,\n              GET_ADDR4       = 4'b0111,\n              GET_WRITE_DATA  = 4'b1000,\n              WRITE_WAIT      = 4'b1001,\n              READ_ASSERT     = 4'b1010,\n              READ_CMD_WAIT   = 4'b1011,\n              READ_DATA_WAIT  = 4'b1100,\n              PUSH_FIFO       = 4'b1101,\n              PUSH_FIFO_WAIT  = 4'b1110,\n              FIFO_CMD_WAIT   = 4'b1111;\n   \n   \n   \n\n   assign enable = (in_ready & in_valid);\n\n   always @* begin\n      in_ready = in_ready_0;      \n   end\n   \n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n            in_ready_0          <= 1'b0;\n            fifo_writedata      <=  'b0;\n            fifo_write          <= 1'b0;\n            fifo_sop            <= 1'b0;\n            read                <= 1'b0;\n            write               <= 1'b0;\n            byteenable          <=  'b0;\n            writedata           <=  'b0;\n            address             <=  'b0;\n            counter             <=  'b0;\n            command             <=  'b0;\n            first_trans         <= 1'b0;\n            last_trans          <= 1'b0;\n            state               <=  'b0;\n            current_byte        <=  'b0;\n            read_data_buffer    <=  'b0;\n            unshifted_byteenable <= 'b0;\n            byte_avail          <=  'b0;\n            fifo_data_buffer    <=  'b0;\n      end else begin\n            address[1:0]      <= 'b0;\n            in_ready_0 <= 1'b0;\n            \n            if (counter > 3)       unshifted_byteenable <= 4'b1111;\n            else if (counter == 3) unshifted_byteenable <= 4'b0111;\n            else if (counter == 2) unshifted_byteenable <= 4'b0011;\n            else if (counter == 1) unshifted_byteenable <= 4'b0001;\n\n            case (state)\n              READY : begin\n                   in_ready_0        <= !fifo_write_waitrequest;\n                   fifo_write        <= 1'b0;\n              end\n              GET_EXTRA : begin\n                   in_ready_0        <= 1'b1;\n                   byteenable        <=  'b0;\n                   if (enable) state <= GET_SIZE1;\n              end\n\n              GET_SIZE1 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[15:8]     <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_SIZE2;\n              end\n\n              GET_SIZE2 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[7:0]      <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_ADDR1;\n              end\n              \n              GET_ADDR1 : begin\n                in_ready_0        <= 1'b1;\n                first_trans       <= 1'b1;\n                last_trans        <= 1'b0;\n                address[31:24]    <= in_data;\n                if (enable) state <= GET_ADDR2;\n              end\n\n              GET_ADDR2 : begin\n                in_ready_0        <= 1'b1;\n                address[23:16]    <= in_data;\n                if (enable) state <= GET_ADDR3;\n              end\n\n              GET_ADDR3 : begin\n                in_ready_0        <= 1'b1;\n                address[15:8]     <= in_data;\n                if (enable) state <= GET_ADDR4;\n              end\n\n              GET_ADDR4 : begin\n                in_ready_0        <= 1'b1;\n                address[7:2]      <= in_data[7:2];\n                current_byte      <= in_data[1:0];\n                if (enable) begin\n                      if (command == CMD_WRITE_NON_INCR | command == CMD_WRITE_INCR) begin\n                        state <= GET_WRITE_DATA; \n                        in_ready_0 <= 1'b1;\n                      end\n                      else if (command == CMD_READ_NON_INCR | command == CMD_READ_INCR) begin\n                        state   <= READ_ASSERT; \n                        in_ready_0 <= 1'b0;\n                      end\n                      else begin\n                        \n                        \n                        in_ready_0          <= 1'b0;\n                        state <= FIFO_CMD_WAIT; \n                        \n                        \n                        fifo_writedata[7:0] <= (8'h80 | command);\n                        fifo_writedata[35:8]<= {4'b1111,counter[7:0],counter[15:8],8'b0};\n                        fifo_write          <= 1'b1;    \n                        counter             <= 0;\n                      end\n                end\n              end\n\n              GET_WRITE_DATA : begin\n                        in_ready_0 <= 1'b1; \n                        if (enable) begin\n                          counter <= counter + 1'b1;\n                          \n                          current_byte <= current_byte + 1'b1;\n                          if (in_endofpacket || current_byte == 3) \n                          begin\n                             in_ready_0 <= 1'b0;\n                             write      <= 1'b1;\n                             state      <= WRITE_WAIT;\n                          end\n                        end\n                        if (in_endofpacket) begin\n                          last_trans <= 1'b1;\n                        end\n                        \n                        \n                        case (current_byte)\n                          0: begin\n                            writedata[7:0]   <= in_data;\n                            byteenable[0]    <= 1'b1;\n                          end\n                          1: begin\n                            writedata[15:8]  <= in_data;\n                            byteenable[1]    <= 1'b1;\n                          end\n                          2: begin\n                            writedata[23:16] <= in_data;\n                            byteenable[2]    <= 1'b1;\n                          end\n                          3: begin\n                            writedata[31:24] <= in_data;\n                            byteenable[3]    <= 1'b1;\n                          end\n                        endcase\n              end\n              WRITE_WAIT : begin\n                        in_ready_0 <= 1'b0;\n                        write      <= 1'b1;\n                        if (~waitrequest) begin\n                           write <= 1'b0;\n                           state <= GET_WRITE_DATA;\n                           in_ready_0 <= 1'b1;\n                           byteenable <= 'b0;\n                           if (command[2] == 1'b1) begin\n                              \n                              address[31:2] <= (address[31:2] + 1'b1);\n                           end\n                           if (last_trans) begin\n                               in_ready_0         <= 1'b0;\n                               state <= FIFO_CMD_WAIT;\n                               \n                               \n                               fifo_writedata[7:0] <= (8'h80 | command);\n                               fifo_writedata[35:8]<= {4'b1111,counter[7:0],counter[15:8],8'b0};\n                               fifo_write          <= 1'b1;\n                               counter             <= 0;\n                           end\n                        end\n              end\n              READ_ASSERT : begin\n                            if (current_byte == 3) byteenable <= unshifted_byteenable << 3;\n                            if (current_byte == 2) byteenable <= unshifted_byteenable << 2;\n                            if (current_byte == 1) byteenable <= unshifted_byteenable << 1;\n                            if (current_byte == 0) byteenable <= unshifted_byteenable;\n                            read             <= 1'b1;\n                            fifo_write       <= 1'b0;\n                            state            <= READ_CMD_WAIT;\n              end\n              READ_CMD_WAIT : begin\n                        \n                        case (byteenable)\n                            4'b0000 : byte_avail <= 1'b0;\n                            4'b0001 : byte_avail <= 1'b0;\n                            4'b0010 : byte_avail <= 1'b0;\n                            4'b0100 : byte_avail <= 1'b0;\n                            4'b1000 : byte_avail <= 1'b0;\n                            4'b0011 : byte_avail <= 1'b1;\n                            4'b0110 : byte_avail <= 1'b1;\n                            4'b1100 : byte_avail <= 1'b1;\n                            4'b0111 : byte_avail <= 2'h2;\n                            4'b1110 : byte_avail <= 2'h2;\n                            default : byte_avail <= 2'h3;\n                        endcase\n                        read_data_buffer <= readdata;\n                        read             <= 1; \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        if (readdatavalid) begin\n                           state <= PUSH_FIFO;\n                           read <= 0;\n                        end else begin\n                           if (~waitrequest) begin\n                               state <= READ_DATA_WAIT;\n                               read <= 0;\n                           end\n                        end\n              end\n              READ_DATA_WAIT : begin\n                        read_data_buffer <= readdata;\n                        if (readdatavalid) begin\n                            state <= PUSH_FIFO;\n                        end\n              end              \n              PUSH_FIFO : begin\n                        fifo_write <= 1'b0;\n                        fifo_sop   <= 1'b0;\n                        if (first_trans) begin\n                            first_trans <= 1'b0;\n                            fifo_sop    <= 1'b1;\n                        end\n                        case (current_byte)\n                            3 : begin\n                                fifo_data_buffer <= read_data_buffer >> 24;\n                                counter <= counter - 1'b1;\n                            end\n                            2 : begin\n                                fifo_data_buffer <= read_data_buffer >> 16;\n                                if (counter == 1) counter <= 0;\n                                else counter <= counter - 2'h2;\n                            end\n                            1 : begin\n                                fifo_data_buffer <= read_data_buffer >> 8;\n                                if (counter < 3) counter <= 0;\n                                else counter <= counter - 2'h3;\n                            end\n                            default : begin\n                                fifo_data_buffer <= read_data_buffer;\n                                if (counter < 4) counter <= 0;\n                                else counter <= counter - 3'h4;\n                            end\n                        endcase\n                        current_byte <= 0;\n                        state <= PUSH_FIFO_WAIT;\n              end\n              PUSH_FIFO_WAIT : begin\n                            \n                            fifo_write     <= 1'b1;\n                            fifo_writedata <= {fifo_sop,(counter == 0)?1'b1:1'b0,byte_avail,fifo_data_buffer};\n                            \n                            \n                            \n                            \n                            \n                            \n                            if (counter == 0) begin\n                                state <= FIFO_CMD_WAIT;\n                            end else if (command[2]== 1'b1) begin\n                                    \n                                    state <= FIFO_CMD_WAIT;\n                                    address[31:2] <= (address[31:2] + 1'b1);\n                            end\n              end\n              FIFO_CMD_WAIT : begin\n                        \n                        if (!fifo_write_waitrequest) begin\n                            if (counter == 0) begin\n                                state       <= READY;\n                            end else begin\n                                state <= READ_ASSERT;\n                            end\n                            fifo_write  <= 1'b0;\n                        end\n              end\n           endcase\n           if (enable & in_startofpacket) begin\n              state      <= GET_EXTRA;\n              command    <= in_data;\n              in_ready_0 <= !fifo_write_waitrequest;\n           end\n      end  \n   end  \nendmodule\n\n\n\n\n\n\n\n\nmodule fifo_buffer_single_clock_fifo (\n                                                   \n                                                    aclr,\n                                                    clock,\n                                                    data,\n                                                    rdreq,\n                                                    wrreq,\n\n                                                   \n                                                    empty,\n                                                    full,\n                                                    q\n                                                 )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n\n  output           empty;\n  output           full;\n  output  [ 35: 0] q;\n  input            aclr;\n  input            clock;\n  input   [ 35: 0] data;\n  input            rdreq;\n  input            wrreq;\n\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  scfifo single_clock_fifo\n    (\n      .aclr (aclr),\n      .clock (clock),\n      .data (data),\n      .empty (empty),\n      .full (full),\n      .q (q),\n      .rdreq (rdreq),\n      .wrreq (wrreq)\n    );\n\n  defparam single_clock_fifo.add_ram_output_register = \"OFF\",\n           single_clock_fifo.lpm_numwords = FIFO_DEPTHS,\n           single_clock_fifo.lpm_showahead = \"OFF\",\n           single_clock_fifo.lpm_type = \"scfifo\",\n           single_clock_fifo.lpm_width = 36,\n           single_clock_fifo.lpm_widthu = FIFO_WIDTHU,\n           single_clock_fifo.overflow_checking = \"ON\",\n           single_clock_fifo.underflow_checking = \"ON\",\n           single_clock_fifo.use_eab = \"OFF\";\n\n\nendmodule\n\n\n\n\n\n\n\nmodule fifo_buffer_scfifo_with_controls (\n                                                      \n                                                       clock,\n                                                       data,\n                                                       rdreq,\n                                                       reset_n,\n                                                       wrreq,\n\n                                                      \n                                                       empty,\n                                                       full,\n                                                       q\n                                                    )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n  \n  output           empty;\n  output           full;\n  output  [ 35: 0] q;\n  input            clock;\n  input   [ 35: 0] data;\n  input            rdreq;\n  input            reset_n;\n  input            wrreq;\n\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  wire             wrreq_valid;\n  \n  fifo_buffer_single_clock_fifo #(\n            .FIFO_DEPTHS(FIFO_DEPTHS),\n            .FIFO_WIDTHU(FIFO_WIDTHU)\n  ) the_scfifo (\n      .aclr  (~reset_n),\n      .clock (clock),\n      .data  (data),\n      .empty (empty),\n      .full  (full),\n      .q     (q),\n      .rdreq (rdreq),\n      .wrreq (wrreq_valid)\n    );\n\n  assign wrreq_valid = wrreq & ~full;\n\nendmodule\n\n\n\n\n\nmodule fifo_buffer (\n                                 \n                                  avalonmm_read_slave_read,\n                                  avalonmm_write_slave_write,\n                                  avalonmm_write_slave_writedata,\n                                  reset_n,\n                                  wrclock,\n\n                                 \n                                  avalonmm_read_slave_readdata,\n                                  avalonmm_read_slave_waitrequest,\n                                  avalonmm_write_slave_waitrequest\n                               )\n;\n\n  parameter FIFO_DEPTHS = 2;\n  parameter FIFO_WIDTHU = 1;\n\n\n  output  [ 35: 0] avalonmm_read_slave_readdata;\n  output           avalonmm_read_slave_waitrequest;\n  output           avalonmm_write_slave_waitrequest;\n  input            avalonmm_read_slave_read;\n  input            avalonmm_write_slave_write;\n  input   [ 35: 0] avalonmm_write_slave_writedata;\n  input            reset_n;\n  input            wrclock;\n\n  wire    [ 35: 0] avalonmm_read_slave_readdata;\n  wire             avalonmm_read_slave_waitrequest;\n  wire             avalonmm_write_slave_waitrequest;\n  wire             clock;\n  wire    [ 35: 0] data;\n  wire             empty;\n  wire             full;\n  wire    [ 35: 0] q;\n  wire             rdreq;\n  wire             wrreq;\n  \n  fifo_buffer_scfifo_with_controls #(\n      .FIFO_DEPTHS(FIFO_DEPTHS),\n      .FIFO_WIDTHU(FIFO_WIDTHU)\n  ) the_scfifo_with_controls\n    (\n      .clock   (clock),\n      .data    (data),\n      .empty   (empty),\n      .full    (full),\n      .q       (q),\n      .rdreq   (rdreq),\n      .reset_n (reset_n),\n      .wrreq   (wrreq)\n    );\n\n  \n  \n  assign data = avalonmm_write_slave_writedata;\n  assign wrreq = avalonmm_write_slave_write;\n  assign avalonmm_read_slave_readdata = q;\n  assign rdreq = avalonmm_read_slave_read;\n  assign clock = wrclock;\n  assign avalonmm_write_slave_waitrequest = full;\n  assign avalonmm_read_slave_waitrequest = empty;\n\nendmodule\n\n\n\n\n\nmodule fifo_to_packet (\n\n      \n      input              clk,\n      input              reset_n,\n\n      \n      input              out_ready,\n      output reg         out_valid,\n      output reg [ 7: 0] out_data,\n      output reg         out_startofpacket,\n      output reg         out_endofpacket,\n\n      \n      input  [ 35: 0]    fifo_readdata,\n      output reg         fifo_read,\n      input              fifo_empty \n);\n\nreg [ 1: 0]     state;\nreg             enable, sent_all;\nreg [ 1: 0]     current_byte, byte_end;\nreg             first_trans, last_trans;\nreg [ 23:0]     fifo_data_buffer;\n\nlocalparam    POP_FIFO        = 2'b00,\n              POP_FIFO_WAIT   = 2'b01,\n              FIFO_DATA_WAIT  = 2'b10,\n              READ_SEND_ISSUE = 2'b11;\n\nalways @* begin\n      enable = (!fifo_empty & sent_all);\nend\n          \nalways @(posedge clk or negedge reset_n) begin\n          if (!reset_n) begin\n                fifo_data_buffer  <=  'b0;\n                out_startofpacket <= 1'b0;\n                out_endofpacket   <= 1'b0;\n                out_valid         <= 1'b0;\n                out_data          <=  'b0;\n                state             <=  'b0;\n                fifo_read         <= 1'b0;\n                current_byte      <=  'b0;\n                byte_end          <=  'b0;\n                first_trans       <= 1'b0;\n                last_trans        <= 1'b0;\n                sent_all          <= 1'b1;\n          end else begin\n                if (out_ready) begin\n                  out_startofpacket <= 1'b0;\n                  out_endofpacket   <= 1'b0;\n                end\n                \n                case (state)\n                  POP_FIFO : begin\n                            if (out_ready) begin\n                                out_startofpacket   <= 1'b0;\n                                out_endofpacket     <= 1'b0;\n                                out_valid           <= 1'b0;\n                                first_trans         <= 1'b0;\n                                last_trans          <= 1'b0;\n                                byte_end            <=  'b0;\n                                fifo_read           <= 1'b0;\n                                sent_all            <= 1'b1;\n                            end\n                            \n                            if (enable) begin   \n                                fifo_read       <= 1'b1;\n                                out_valid       <= 1'b0;\n                                state           <= POP_FIFO_WAIT;\n                            end\n                  end\n                  POP_FIFO_WAIT : begin\n                  \n                                fifo_read               <= 1'b0;\n                                state                   <= FIFO_DATA_WAIT;\n                  end\n                  FIFO_DATA_WAIT : begin\n                                sent_all                <= 1'b0;\n                                first_trans             <= fifo_readdata[35];\n                                last_trans              <= fifo_readdata[34];\n                                out_data                <= fifo_readdata[7:0];\n                                fifo_data_buffer        <= fifo_readdata[31:8];\n                                byte_end                <= fifo_readdata[33:32];\n                                current_byte            <= 1'b1;\n                                out_valid               <= 1'b1;\n                                \n                                \n                                if (fifo_readdata[35] & fifo_readdata[34] & (fifo_readdata[33:32] == 0)) begin\n                                    first_trans         <= 1'b0;\n                                    last_trans          <= 1'b0;\n                                    out_startofpacket   <= 1'b1;\n                                    out_endofpacket     <= 1'b1;\n                                    state <= POP_FIFO;\n                                end else if (fifo_readdata[35] & (fifo_readdata[33:32] == 0)) begin\n                                    first_trans         <= 1'b0;\n                                    out_startofpacket   <= 1'b1;\n                                    state               <= POP_FIFO;\n                                end else if (fifo_readdata[35]) begin\n                                   first_trans          <= 1'b0;\n                                   out_startofpacket    <= 1'b1;\n                                   state <= READ_SEND_ISSUE;\n                                end else if (fifo_readdata[34] & (fifo_readdata[33:32] == 0)) begin\n                                    last_trans          <= 1'b0;\n                                    out_endofpacket     <= 1'b1;\n                                    state               <= POP_FIFO;\n                                end else begin\n                                    state               <= READ_SEND_ISSUE;\n                                end\n                                \n                  end\n                  READ_SEND_ISSUE : begin\n                            out_valid         <= 1'b1;\n                            sent_all          <= 1'b0;\n                            \n                            if (out_ready) begin\n                                out_startofpacket <= 1'b0;\n                                \n                                if (last_trans & (current_byte == byte_end)) begin\n                                        last_trans      <= 1'b0;\n                                        out_endofpacket <= 1'b1;\n                                        state           <= POP_FIFO;\n                                end\n                                case (current_byte)\n                                       3: begin\n                                          out_data <= fifo_data_buffer[23:16];\n                                       end\n                                       2: begin\n                                          out_data <= fifo_data_buffer[15:8];\n                                       end\n                                       1: begin\n                                          out_data <= fifo_data_buffer[7:0];\n                                       end\n                                       default: begin\n                                          \n                                       end\n                                endcase\n                                current_byte <= current_byte + 1'b1;\n                                if (current_byte == byte_end) begin\n                                    state <= POP_FIFO;\n                                end else begin\n                                    state <= READ_SEND_ISSUE;\n                                end\n                            end\n                  end\n                endcase\n          end\n    end\nendmodule\n\n\n\n\nmodule packets_to_master (\n\n      \n      input              clk,\n      input              reset_n,\n      \n      output reg         in_ready,\n      input              in_valid,\n      input      [ 7: 0] in_data,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      \n      input              out_ready,\n      output reg         out_valid,\n      output reg [ 7: 0] out_data,\n      output reg         out_startofpacket,\n      output reg         out_endofpacket,\n\n      \n      output reg [31: 0] address,\n      input      [31: 0] readdata,\n      output reg         read,\n      output reg         write,\n      output reg [ 3: 0] byteenable,\n      output reg [31: 0] writedata,\n      input              waitrequest,\n      input              readdatavalid\n      \n);\n\n   \n   \n   \n   parameter EXPORT_MASTER_SIGNALS = 0;\n\n   \n   \n   \n   localparam CMD_WRITE_NON_INCR = 8'h00;\n   localparam CMD_WRITE_INCR     = 8'h04;\n   localparam CMD_READ_NON_INCR  = 8'h10;\n   localparam CMD_READ_INCR      = 8'h14;\n   \n   \n   \n   \n\n   reg  [ 3: 0]  state;\n   reg  [ 7: 0]  command;\n   reg  [ 1: 0]  current_byte; \n   reg  [ 15: 0] counter;\n   reg  [ 23: 0] read_data_buffer;\n   reg           in_ready_0;\n   reg           first_trans, last_trans;\n   reg  [ 3: 0]  unshifted_byteenable;\n   wire enable;\n\n   localparam READY          = 4'b0000, \n              GET_EXTRA      = 4'b0001,\n              GET_SIZE1      = 4'b0010,\n              GET_SIZE2      = 4'b0011,\n              GET_ADDR1      = 4'b0100,\n              GET_ADDR2      = 4'b0101,\n              GET_ADDR3      = 4'b0110,\n              GET_ADDR4      = 4'b0111,\n              GET_WRITE_DATA = 4'b1000,      \n              WRITE_WAIT     = 4'b1001,\n              RETURN_PACKET  = 4'b1010,\n              READ_ASSERT    = 4'b1011,\n              READ_CMD_WAIT  = 4'b1100,\n              READ_DATA_WAIT = 4'b1101,\n              READ_SEND_ISSUE= 4'b1110,\n              READ_SEND_WAIT = 4'b1111;\n   \n   \n   \n   \n   \n\n   assign enable = (in_ready & in_valid);\n\n   always @*\n\n      in_ready = in_ready_0;\n   \n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n            in_ready_0        <= 1'b0;\n            out_startofpacket <= 1'b0;\n            out_endofpacket   <= 1'b0;\n            out_valid         <= 1'b0;\n            out_data          <=  'b0;\n            read              <= 1'b0;\n            write             <= 1'b0;\n            byteenable        <=  'b0;\n            writedata         <=  'b0;\n            address           <=  'b0;\n            counter           <=  'b0;\n            command           <=  'b0;\n            first_trans       <= 1'b0;\n            last_trans        <= 1'b0;\n            state             <= 'b0;\n            current_byte      <= 'b0;\n          \n            read_data_buffer  <= 'b0;\n            unshifted_byteenable <= 'b0;\n      end else begin\n            address[1:0]      <= 'b0;\n \n            if (out_ready) begin\n              out_startofpacket <= 1'b0;\n              out_endofpacket   <= 1'b0;\n              out_valid         <= 1'b0;\n            end\n            in_ready_0 <= 1'b0;\n            \n            if (counter >= 3)      unshifted_byteenable <= 4'b1111;\n            else if (counter == 3) unshifted_byteenable <= 4'b0111;\n            else if (counter == 2) unshifted_byteenable <= 4'b0011;\n            else if (counter == 1) unshifted_byteenable <= 4'b0001;\n\n            case (state)\n              READY : begin\n                   out_valid         <= 1'b0;\n                   in_ready_0        <= 1'b1;\n              end\n              GET_EXTRA : begin\n                   in_ready_0        <= 1'b1;\n                   byteenable        <=  'b0;\n                   if (enable) state <= GET_SIZE1;\n              end\n\n              GET_SIZE1 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[15:8]     <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_SIZE2;\n              end\n\n              GET_SIZE2 : begin\n                   in_ready_0        <= 1'b1;\n                   \n                   counter[7:0]      <= command[4]?in_data:8'b0;\n                   if (enable) state <= GET_ADDR1;\n              end\n              \n              GET_ADDR1 : begin\n                in_ready_0        <= 1'b1;\n                first_trans       <= 1'b1;\n                last_trans        <= 1'b0;\n                address[31:24]    <= in_data;\n                if (enable) state <= GET_ADDR2;\n              end\n\n              GET_ADDR2 : begin\n                in_ready_0        <= 1'b1;\n                address[23:16]    <= in_data;\n                if (enable) state <= GET_ADDR3;\n              end\n\n              GET_ADDR3 : begin\n                in_ready_0        <= 1'b1;\n                address[15:8]     <= in_data;\n                if (enable) state <= GET_ADDR4;\n              end\n\n              GET_ADDR4 : begin\n                in_ready_0        <= 1'b1;\n                address[7:2]      <= in_data[7:2];\n                current_byte      <= in_data[1:0];\n                if (enable) begin\n                      if (command == CMD_WRITE_NON_INCR | command == CMD_WRITE_INCR) begin\n                        state <= GET_WRITE_DATA; \n                        in_ready_0 <= 1'b1;\n                      end\n                      else if (command == CMD_READ_NON_INCR | command == CMD_READ_INCR) begin\n                        state   <= READ_ASSERT; \n                        in_ready_0 <= 1'b0;\n                      end\n                      else begin\n                        \n                        \n                        state <= RETURN_PACKET; \n                        out_startofpacket <= 1'b1;\n                        out_data <= (8'h80 | command);\n                        out_valid <= 1'b1;\n                        current_byte <= 'h0;\n                        in_ready_0 <= 1'b0;\n                      end\n                end\n              end\n\n              GET_WRITE_DATA : begin\n                        in_ready_0 <= 1; \n                        if (enable) begin\n                          counter <= counter + 1'b1;\n                          \n                          current_byte <= current_byte + 1'b1;\n                          if (in_endofpacket || current_byte == 3) \n                          begin\n                             in_ready_0 <= 0;\n                             write      <= 1'b1;\n                             state      <= WRITE_WAIT;\n                          end\n                        end\n                        if (in_endofpacket) begin\n                          last_trans <= 1'b1;\n                        end\n                        \n                        \n                        case (current_byte)\n                          0: begin\n                            writedata[7:0]   <= in_data;\n                            byteenable[0]    <= 1;\n                          end\n                          1: begin\n                            writedata[15:8]  <= in_data;\n                            byteenable[1]    <= 1;\n                          end\n                          2: begin\n                            writedata[23:16] <= in_data;\n                            byteenable[2]    <= 1;\n                          end\n                          3: begin\n                            writedata[31:24] <= in_data;\n                            byteenable[3]    <= 1;\n                          end\n                        endcase\n              end\n\n              WRITE_WAIT : begin\n                        in_ready_0 <= 0;\n                        write      <= 1'b1;\n                        if (~waitrequest) begin\n                           write <= 1'b0;\n                           state <= GET_WRITE_DATA;\n                           in_ready_0 <= 1;\n                           byteenable <= 'b0;\n                           if (command[2] == 1'b1) begin\n                              \n                              address[31:2] <= (address[31:2] + 1'b1);\n                           end\n                           if (last_trans) begin\n                              state <= RETURN_PACKET;\n                              out_startofpacket <= 1'b1;\n                              out_data <= (8'h80 | command);\n                              out_valid <= 1'b1;\n                              current_byte <= 'h0;\n                              in_ready_0 <= 1'b0;\n                           end\n                        end\n              end\n              \n              RETURN_PACKET : begin\n                        out_valid <= 1'b1;\n                        if (out_ready) begin\n                           case (current_byte)\n                          \n                          \n                          \n                          \n                             0: begin\n                               out_data <= 8'b0;\n                             end\n                             1: begin\n                               out_data <= counter[15:8];\n                             end\n                             2: begin\n                               out_endofpacket <= 1'b1;\n                               out_data <= counter[7:0];\n                             end\n                             default: begin\n                          \n                          \n                          \n                             end\n                           endcase\n                           current_byte <= current_byte + 1'b1;\n                           if (current_byte == 3) begin\n                              state     <= READY;\n                              out_valid <= 1'b0;\n                           end\n                           else                   state     <= RETURN_PACKET;\n                        end\n              end\n              READ_ASSERT : begin\n                        if (current_byte == 3) byteenable <= unshifted_byteenable << 3;\n                        if (current_byte == 2) byteenable <= unshifted_byteenable << 2;\n                        if (current_byte == 1) byteenable <= unshifted_byteenable << 1;\n                        if (current_byte == 0) byteenable <= unshifted_byteenable;\n\n                        read             <= 1;\n                        state            <= READ_CMD_WAIT;\n              end\n              READ_CMD_WAIT : begin\n                        read_data_buffer <= readdata[31:8];\n                        out_data         <= readdata[7:0];\n                        read             <= 1; \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        if (readdatavalid) begin\n                           state <= READ_SEND_ISSUE;\n                           read <= 0;\n                        end else begin\n                           if (~waitrequest) begin\n                               state <= READ_DATA_WAIT;\n                               read <= 0;\n                           end\n                        end\n              end\n              READ_DATA_WAIT : begin\n                        read_data_buffer <= readdata[31:8];\n                        out_data         <= readdata[7:0];\n                        if (readdatavalid) begin\n                            state <= READ_SEND_ISSUE;\n                        end\n              end\n              READ_SEND_ISSUE : begin\n                        out_valid <= 1'b1;\n                        out_startofpacket <= 'h0;\n                        out_endofpacket   <= 'h0;\n                        if (counter == 1) begin\n                           out_endofpacket <= 1'b1;\n                        end \n                        if (first_trans) begin\n                           first_trans <= 1'b0;\n                           out_startofpacket <= 1'b1;\n                        end\n                        case (current_byte)\n                          3: begin\n                             out_data        <= read_data_buffer[23:16];\n                          end\n                          2: begin\n                             out_data        <= read_data_buffer[15:8];\n                          end\n                          1: begin\n                             out_data        <= read_data_buffer[7:0];\n                          end\n                          default: begin\n                             out_data        <= out_data; \n                          end\n                        endcase\n                        state <= READ_SEND_WAIT;\n              end\n              READ_SEND_WAIT : begin\n                        out_valid <= 1'b1;\n                        if (out_ready) begin\n                           counter <= counter - 1'b1;\n                           current_byte <= current_byte + 1'b1;\n                           out_valid <= 1'b0;\n                           \n                           \n                           \n                           \n                           \n                           \n                           if (counter == 1) begin\n                              state <= READY;\n                           \n                           \n                           end else if (current_byte == 3) begin\n                              if (command[2] == 1'b1) begin\n                                 \n                                 address[31:2] <= (address[31:2] + 1'b1);\n                              end\n                              state <= READ_ASSERT;\n                           \n                           end else begin\n                              state <= READ_SEND_ISSUE;\n                           end\n                           \n                           \n                        end \n              end\n           endcase\n           if (enable & in_startofpacket) begin\n              state <= GET_EXTRA;\n              command           <= in_data;\n              in_ready_0 <= 1'b1;\n           end\n      end  \n   end  \nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_avalon_packets_to_master. Module specification: This module is a packet-to-master converter for Altera Avalon interfaces, designed to receive packet data through an input interface, process it, and convert it into Avalon master read/write transactions. It supports two operational modes: a fast version using separate submodules (packets_to_fifo, fifo_to_packet, and fifo_buffer) for packet conversion and buffering, and a standard version using a single packets_to_master module for direct conversion. The module handles various command types for read and write operations, supporting both incrementing and non-incrementing address modes. Input ports include clk, reset_n, in_valid, in_data, in_startofpacket, in_endofpacket, out_ready, readdata, waitrequest, and readdatavalid, while output ports include"
                }
            ]
        }
    ]
}