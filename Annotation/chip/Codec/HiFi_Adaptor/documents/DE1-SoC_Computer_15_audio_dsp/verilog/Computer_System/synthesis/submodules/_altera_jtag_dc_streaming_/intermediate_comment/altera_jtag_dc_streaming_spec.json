{
    "spec": "Module name: altera_jtag_dc_streaming.\n\nModule specification: The altera_jtag_dc_streaming module is specifically designed for controlling JTAG data streaming and synchronization between multiple clock domains, particularly between JTAG and system clock domains in testing and debugging scenarios. The input ports include `tck`, `tdi`, `ir_in` for JTAG operations, `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr` for state machine synchronization, `clk` for system operations, `reset_n` for resetting the module, `sink_data`, and `sink_valid` for data input management. The output ports comprise `tdo` for the output data from JTAG, `source_data`, `source_valid` for sending data to system domain, `sink_ready` to accept more data, `resetrequest`, `debug_reset` for various reset functions, and `mgmt_valid`, `mgmt_channel`, `mgmt_data` for management operations. Internal signals such as `jtag_clock_reset_n` ensure reset operations are synced with the JTAG clock domain, while `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` manage data integrity and flow control across domains. Key blocks in the code include `altera_std_synchronizer` for synchronization, `altera_jtag_streaming` for JTAG operations, and `altera_avalon_st_clock_crosser` and `altera_jtag_src_crosser` for clock domain data transfer. Each of these components is integral to maintaining data accuracy and timing across complex clock domain interactions.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_dc_streaming.\nExplanation: The module is designed for JTAG data streaming and synchronization across different clock domains. It uses specialized submodules (`altera_std_synchronizer`, `altera_jtag_streaming`, and `altera_avalon_st_clock_crosser`) to ensure data integrity and timing correctness when transferring signals between the JTAG domain (related to tck - test clock) and a system clock domain, as well as managing various signals like reset, management commands, and data flow control. The module synchronizes input and output data streams and handles crossing clock domains, making it suitable for applications involving complex interactions between system and test clocks, particularly in testing and debugging scenarios involving hardware."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\n- `tck`, `tdi`, `ir_in`, `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`, `clk`, `reset_n`, `sink_data`, `sink_valid`\n  \nExplanation:\n- `tck`: Test Clock for JTAG operations. It is the main clock signal used for JTAG data and synchronization purposes.\n- `tdi`: Test Data Input for JTAG. This is a serial data line used for sending data into the device under test.\n- `ir_in`: Instruction Register Input for JTAG, controlling the operation type being executed on the Test Access Port (TAP).\n- `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`: Indicate whether different JTAG state machine states (Capture-DR, Shift-DR, Update-DR) are active, providing synchronization points within JTAG operations.\n- `clk`: System Clock signal used for system-level operations outside of the JTAG domain.\n- `reset_n`: Active low reset signal, used to initialize the module and synchronizer components at startup or during certain fault conditions.\n- `sink_data`: Data coming from the system domain into the JTAG domain.\n- `sink_valid`: Indicates if the `sink_data` is valid and should be processed or transferred.\n\nOutput ports:\n- `tdo`, `source_data`, `source_valid`, `sink_ready`, `resetrequest`, `debug_reset`, `mgmt_valid`, `mgmt_channel`, `mgmt_data`\n\nExplanation:\n- `tdo`: Test Data Output for JTAG. This is the serial data output line on which results or data are sent out from the device under test.\n- `source_data`: Data that has been synchronized from the JTAG domain to the system clock domain for further use in system-side applications.\n- `source_valid`: Indicates that the `source_data` is valid and can be used by downstream components in the system domain.\n- `sink_ready`: Indicates readiness to accept more `sink_data`, ensuring that data is not lost due to overruns.\n- `resetrequest`: Typically used for requesting a system reset based on JTAG operations or detected conditions that require a system-level reset.\n- `debug_reset`: Used specifically for resetting debug logic or components related to debugging that might be operating in system space.\n- `mgmt_valid`, `mgmt_channel`, `mgmt_data`: These ports are typically used for management operations, possibly related to configuration, status reporting, or other administrative tasks that need communication between system and JTAG domains.\n\nThese explanations provide a clear overview of each port's role within the altera_jtag_dc_streaming module, highlighting their importance in JTAG operations and system synchronization."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n- `jtag_clock_reset_n`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_data`\n- `jtag_sink_valid`\n- `jtag_sink_ready`\n\nExplanation:\n- `jtag_clock_reset_n`: This is an internally synchronized reset signal derived from the system reset `reset_n` using a synchronizer (`altera_std_synchronizer`). Its purpose is to ensure that the JTAG-related operations are consistently reset with the JTAG clock domain's edge, thereby preventing issues such as metastability that might arise from direct usage of system domain resets.\n- `jtag_source_data`: Holds the data that is synchronized from the JTAG domain and is ready to be passed to the system clock domain. This signal is driven by internal JTAG streaming (`altera_jtag_streaming`) mechanisms which handle the actual data interactions with the JTAG operations.\n- `jtag_source_valid`: Indicates that the data held in `jtag_source_data` is valid and is a result of JTAG data streaming operations. It ensures that only valid data crosses from the JTAG domain to the system domain.\n- `jtag_sink_data`: Serves as the internal buffer holding data intended for the JTAG domain, received from the system domain. This data is used within JTAG operations and is managed to ensure proper synchronization and timing across clock domains.\n- `jtag_sink_valid`: A validation signal for `jtag_sink_data`, signaling that the data is valid and ready for processing within the JTAG domain.\n- `jtag_sink_ready`: Indicates whether the JTAG domain is ready to receive more data. This back-pressure mechanism ensures that the system domain does not overrun the JTAG domain with data, preventing potential data loss or processing errors.\n\nThese internal signals play crucial roles in managing the data and control flow between system and JTAG clock domains, ensuring that data integrity and correct operation sequencing are maintained across the different functional blocks of the `altera_jtag_dc_streaming` module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_jtag_control_signal_crosser (\n   clk,\n   reset_n,\n   async_control_signal,\n   sense_pos_edge,\n   sync_control_signal\n);\n   input  clk;\n   input  reset_n;\n   input  async_control_signal;\n   input  sense_pos_edge;\n   output sync_control_signal;\n\n   parameter SYNC_DEPTH = 3; \n\n   reg sync_control_signal;\n\n   wire synchronized_raw_signal;\n   reg  edge_detector_register;\n\n   altera_std_synchronizer #(.depth(SYNC_DEPTH)) synchronizer (\n       .clk(clk),\n       .reset_n(reset_n),\n       .din(async_control_signal),\n       .dout(synchronized_raw_signal)\n   );\n\n  always @ (posedge clk or negedge reset_n)\n    if (~reset_n)\n      edge_detector_register <= 1'b0;\n    else\n      edge_detector_register <= synchronized_raw_signal;\n\n  always @* begin\n    if (sense_pos_edge)\n      sync_control_signal <= ~edge_detector_register & synchronized_raw_signal;\n    else\n      sync_control_signal <= edge_detector_register & ~synchronized_raw_signal;\n  end\nendmodule\n\n\nmodule altera_jtag_src_crosser (\n   sink_clk,\n   sink_reset_n,\n   sink_valid,\n   sink_data,\n   src_clk,\n   src_reset_n,\n   src_valid,\n   src_data\n);\n   parameter WIDTH = 8;\n   parameter SYNC_DEPTH = 3; \n\n   input              sink_clk;\n   input              sink_reset_n;\n   input              sink_valid;\n   input [WIDTH-1:0]  sink_data;\n   input              src_clk;\n   input              src_reset_n;\n   output             src_valid;\n   output [WIDTH-1:0] src_data;\n\n   reg              sink_valid_buffer;\n   reg [WIDTH-1:0]  sink_data_buffer;\n\n   reg              src_valid;\n   reg [WIDTH-1:0]  src_data ;\n\n   wire synchronized_valid;\n\n   altera_jtag_control_signal_crosser #(\n     .SYNC_DEPTH(SYNC_DEPTH)\n   ) crosser (\n       .clk(src_clk),\n       .reset_n(src_reset_n),\n       .async_control_signal(sink_valid_buffer),\n       .sense_pos_edge(1'b1),\n       .sync_control_signal(synchronized_valid)\n   );\n   always @ (posedge sink_clk or negedge sink_reset_n) begin\n      if (~sink_reset_n) begin\n         sink_valid_buffer <= 1'b0;\n         sink_data_buffer <= 'b0;\n      end else begin\n         sink_valid_buffer <= sink_valid;\n         if (sink_valid) begin\n           sink_data_buffer <= sink_data;\n         end\n      end \n   end \n\n   always @ (posedge src_clk or negedge src_reset_n) begin\n      if (~src_reset_n) begin\n     src_valid <= 1'b0;\n     src_data <= {WIDTH{1'b0}};\n      end else begin\n     src_valid <= synchronized_valid;\n     src_data <= synchronized_valid ? sink_data_buffer : src_data;\n      end\n   end\n\nendmodule\n\nmodule altera_jtag_dc_streaming  #(\n    parameter PURPOSE = 0, \n                           \n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1\n) (\n    \n    input  wire       tck,\n    input  wire       tdi,\n    output wire       tdo,\n    input  wire [2:0] ir_in,\n    input  wire       virtual_state_cdr,\n    input  wire       virtual_state_sdr,\n    input  wire       virtual_state_udr,\n\n    input  wire       clk,\n    input  wire       reset_n,\n    output wire [7:0] source_data,\n    output wire       source_valid,\n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    output wire       resetrequest,\n    output wire       debug_reset,\n    output wire       mgmt_valid,\n    output wire [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output wire       mgmt_data\n);\n\n   \n   \n   \n   localparam TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   \n   \n   localparam SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n   wire       jtag_clock_reset_n; \n   wire [7:0] jtag_source_data;\n   wire       jtag_source_valid;\n   wire [7:0] jtag_sink_data;\n   wire       jtag_sink_valid;\n   wire       jtag_sink_ready;\n\n   \n\n\n\n\n\n\n\n\n\n   altera_std_synchronizer #(\n       .depth(SYSCLK_TO_TCK_SYNC_DEPTH)\n   ) synchronizer (\n       .clk(tck),\n       .reset_n(reset_n),\n       .din(1'b1),\n       .dout(jtag_clock_reset_n)\n   );\n\n   altera_jtag_streaming #(\n       .PURPOSE(PURPOSE),\n       .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n       .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n       .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n   ) jtag_streaming (\n       .tck              (tck),\n       .tdi              (tdi),\n       .tdo              (tdo),\n       .ir_in            (ir_in),\n       .virtual_state_cdr(virtual_state_cdr),\n       .virtual_state_sdr(virtual_state_sdr),\n       .virtual_state_udr(virtual_state_udr),\n\n       .reset_n(jtag_clock_reset_n),\n       .source_data(jtag_source_data),\n       .source_valid(jtag_source_valid),\n       .sink_data(jtag_sink_data),\n       .sink_valid(jtag_sink_valid),\n       .sink_ready(jtag_sink_ready),\n       .clock_to_sample(clk),\n       .reset_to_sample(reset_n),\n       .resetrequest(resetrequest),\n       .debug_reset(debug_reset),\n       .mgmt_valid(mgmt_valid),\n       .mgmt_channel(mgmt_channel),\n       .mgmt_data(mgmt_data)\n    );\n\n   \n\n   altera_avalon_st_clock_crosser #(\n       .SYMBOLS_PER_BEAT(1),\n       .BITS_PER_SYMBOL(8),\n       .FORWARD_SYNC_DEPTH(SYSCLK_TO_TCK_SYNC_DEPTH),\n       .BACKWARD_SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) sink_crosser (\n       .in_clk(clk),\n       .in_reset(~reset_n),\n       .in_data(sink_data),\n       .in_ready(sink_ready),\n       .in_valid(sink_valid),\n       .out_clk(tck),\n       .out_reset(~jtag_clock_reset_n),\n       .out_data(jtag_sink_data),\n       .out_ready(jtag_sink_ready),\n       .out_valid(jtag_sink_valid)\n   );\n\n   altera_jtag_src_crosser #(\n       .SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) source_crosser (\n       .sink_clk(tck),\n       .sink_reset_n(jtag_clock_reset_n),\n       .sink_valid(jtag_source_valid),\n       .sink_data(jtag_source_data),\n       .src_clk(clk),\n       .src_reset_n(reset_n),\n       .src_valid(source_valid),\n       .src_data(source_data)\n   );\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_jtag_dc_streaming.\n\nModule specification: The altera_jtag_dc_streaming module is specifically designed for controlling JTAG data streaming and synchronization between multiple clock domains, particularly between JTAG and system clock domains in testing and debugging scenarios. The input ports include `tck`, `tdi`, `ir_in` for JTAG operations, `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr` for state machine synchronization, `clk` for system operations, `reset_n` for resetting the module, `sink_data`, and `sink_valid` for data input management. The output ports comprise `tdo` for the output data from JTAG, `source_data`, `source_valid` for sending data to system domain, `sink_ready` to accept more data, `resetrequest`, `debug_reset` for various reset functions, and `mgmt_valid`, `mgmt_channel`, `mgmt_data` for management operations. Internal signals such as `jtag_clock_reset_n` ensure reset operations are synced with the JTAG clock domain, while `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` manage data integrity and flow control across domains. Key blocks in the code include `altera_std_synchronizer` for synchronization, `altera_jtag_streaming` for JTAG operations, and `altera_avalon_st_clock_crosser` and `altera_jtag_src_crosser` for clock domain data transfer. Each of these components is integral to maintaining data accuracy and timing across complex clock domain interactions."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_dc_streaming.\nExplanation: The module is designed for JTAG data streaming and synchronization across different clock domains. It uses specialized submodules (`altera_std_synchronizer`, `altera_jtag_streaming`, and `altera_avalon_st_clock_crosser`) to ensure data integrity and timing correctness when transferring signals between the JTAG domain (related to tck - test clock) and a system clock domain, as well as managing various signals like reset, management commands, and data flow control. The module synchronizes input and output data streams and handles crossing clock domains, making it suitable for applications involving complex interactions between system and test clocks, particularly in testing and debugging scenarios involving hardware."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\n- `tck`, `tdi`, `ir_in`, `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`, `clk`, `reset_n`, `sink_data`, `sink_valid`\n  \nExplanation:\n- `tck`: Test Clock for JTAG operations. It is the main clock signal used for JTAG data and synchronization purposes.\n- `tdi`: Test Data Input for JTAG. This is a serial data line used for sending data into the device under test.\n- `ir_in`: Instruction Register Input for JTAG, controlling the operation type being executed on the Test Access Port (TAP).\n- `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`: Indicate whether different JTAG state machine states (Capture-DR, Shift-DR, Update-DR) are active, providing synchronization points within JTAG operations.\n- `clk`: System Clock signal used for system-level operations outside of the JTAG domain.\n- `reset_n`: Active low reset signal, used to initialize the module and synchronizer components at startup or during certain fault conditions.\n- `sink_data`: Data coming from the system domain into the JTAG domain.\n- `sink_valid`: Indicates if the `sink_data` is valid and should be processed or transferred.\n\nOutput ports:\n- `tdo`, `source_data`, `source_valid`, `sink_ready`, `resetrequest`, `debug_reset`, `mgmt_valid`, `mgmt_channel`, `mgmt_data`\n\nExplanation:\n- `tdo`: Test Data Output for JTAG. This is the serial data output line on which results or data are sent out from the device under test.\n- `source_data`: Data that has been synchronized from the JTAG domain to the system clock domain for further use in system-side applications.\n- `source_valid`: Indicates that the `source_data` is valid and can be used by downstream components in the system domain.\n- `sink_ready`: Indicates readiness to accept more `sink_data`, ensuring that data is not lost due to overruns.\n- `resetrequest`: Typically used for requesting a system reset based on JTAG operations or detected conditions that require a system-level reset.\n- `debug_reset`: Used specifically for resetting debug logic or components related to debugging that might be operating in system space.\n- `mgmt_valid`, `mgmt_channel`, `mgmt_data`: These ports are typically used for management operations, possibly related to configuration, status reporting, or other administrative tasks that need communication between system and JTAG domains.\n\nThese explanations provide a clear overview of each port's role within the altera_jtag_dc_streaming module, highlighting their importance in JTAG operations and system synchronization."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n- `jtag_clock_reset_n`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_data`\n- `jtag_sink_valid`\n- `jtag_sink_ready`\n\nExplanation:\n- `jtag_clock_reset_n`: This is an internally synchronized reset signal derived from the system reset `reset_n` using a synchronizer (`altera_std_synchronizer`). Its purpose is to ensure that the JTAG-related operations are consistently reset with the JTAG clock domain's edge, thereby preventing issues such as metastability that might arise from direct usage of system domain resets.\n- `jtag_source_data`: Holds the data that is synchronized from the JTAG domain and is ready to be passed to the system clock domain. This signal is driven by internal JTAG streaming (`altera_jtag_streaming`) mechanisms which handle the actual data interactions with the JTAG operations.\n- `jtag_source_valid`: Indicates that the data held in `jtag_source_data` is valid and is a result of JTAG data streaming operations. It ensures that only valid data crosses from the JTAG domain to the system domain.\n- `jtag_sink_data`: Serves as the internal buffer holding data intended for the JTAG domain, received from the system domain. This data is used within JTAG operations and is managed to ensure proper synchronization and timing across clock domains.\n- `jtag_sink_valid`: A validation signal for `jtag_sink_data`, signaling that the data is valid and ready for processing within the JTAG domain.\n- `jtag_sink_ready`: Indicates whether the JTAG domain is ready to receive more data. This back-pressure mechanism ensures that the system domain does not overrun the JTAG domain with data, preventing potential data loss or processing errors.\n\nThese internal signals play crucial roles in managing the data and control flow between system and JTAG clock domains, ensuring that data integrity and correct operation sequencing are maintained across the different functional blocks of the `altera_jtag_dc_streaming` module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_jtag_control_signal_crosser (\n   clk,\n   reset_n,\n   async_control_signal,\n   sense_pos_edge,\n   sync_control_signal\n);\n   input  clk;\n   input  reset_n;\n   input  async_control_signal;\n   input  sense_pos_edge;\n   output sync_control_signal;\n\n   parameter SYNC_DEPTH = 3; \n\n   reg sync_control_signal;\n\n   wire synchronized_raw_signal;\n   reg  edge_detector_register;\n\n   altera_std_synchronizer #(.depth(SYNC_DEPTH)) synchronizer (\n       .clk(clk),\n       .reset_n(reset_n),\n       .din(async_control_signal),\n       .dout(synchronized_raw_signal)\n   );\n\n  always @ (posedge clk or negedge reset_n)\n    if (~reset_n)\n      edge_detector_register <= 1'b0;\n    else\n      edge_detector_register <= synchronized_raw_signal;\n\n  always @* begin\n    if (sense_pos_edge)\n      sync_control_signal <= ~edge_detector_register & synchronized_raw_signal;\n    else\n      sync_control_signal <= edge_detector_register & ~synchronized_raw_signal;\n  end\nendmodule\n\n\nmodule altera_jtag_src_crosser (\n   sink_clk,\n   sink_reset_n,\n   sink_valid,\n   sink_data,\n   src_clk,\n   src_reset_n,\n   src_valid,\n   src_data\n);\n   parameter WIDTH = 8;\n   parameter SYNC_DEPTH = 3; \n\n   input              sink_clk;\n   input              sink_reset_n;\n   input              sink_valid;\n   input [WIDTH-1:0]  sink_data;\n   input              src_clk;\n   input              src_reset_n;\n   output             src_valid;\n   output [WIDTH-1:0] src_data;\n\n   reg              sink_valid_buffer;\n   reg [WIDTH-1:0]  sink_data_buffer;\n\n   reg              src_valid;\n   reg [WIDTH-1:0]  src_data ;\n\n   wire synchronized_valid;\n\n   altera_jtag_control_signal_crosser #(\n     .SYNC_DEPTH(SYNC_DEPTH)\n   ) crosser (\n       .clk(src_clk),\n       .reset_n(src_reset_n),\n       .async_control_signal(sink_valid_buffer),\n       .sense_pos_edge(1'b1),\n       .sync_control_signal(synchronized_valid)\n   );\n   always @ (posedge sink_clk or negedge sink_reset_n) begin\n      if (~sink_reset_n) begin\n         sink_valid_buffer <= 1'b0;\n         sink_data_buffer <= 'b0;\n      end else begin\n         sink_valid_buffer <= sink_valid;\n         if (sink_valid) begin\n           sink_data_buffer <= sink_data;\n         end\n      end \n   end \n\n   always @ (posedge src_clk or negedge src_reset_n) begin\n      if (~src_reset_n) begin\n     src_valid <= 1'b0;\n     src_data <= {WIDTH{1'b0}};\n      end else begin\n     src_valid <= synchronized_valid;\n     src_data <= synchronized_valid ? sink_data_buffer : src_data;\n      end\n   end\n\nendmodule\n\nmodule altera_jtag_dc_streaming  #(\n    parameter PURPOSE = 0, \n                           \n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1\n) (\n    \n    input  wire       tck,\n    input  wire       tdi,\n    output wire       tdo,\n    input  wire [2:0] ir_in,\n    input  wire       virtual_state_cdr,\n    input  wire       virtual_state_sdr,\n    input  wire       virtual_state_udr,\n\n    input  wire       clk,\n    input  wire       reset_n,\n    output wire [7:0] source_data,\n    output wire       source_valid,\n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    output wire       resetrequest,\n    output wire       debug_reset,\n    output wire       mgmt_valid,\n    output wire [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output wire       mgmt_data\n);\n\n   \n   \n   \n   localparam TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n   \n   \n   localparam SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n   wire       jtag_clock_reset_n; \n   wire [7:0] jtag_source_data;\n   wire       jtag_source_valid;\n   wire [7:0] jtag_sink_data;\n   wire       jtag_sink_valid;\n   wire       jtag_sink_ready;\n\n   \n\n\n\n\n\n\n\n\n\n   altera_std_synchronizer #(\n       .depth(SYSCLK_TO_TCK_SYNC_DEPTH)\n   ) synchronizer (\n       .clk(tck),\n       .reset_n(reset_n),\n       .din(1'b1),\n       .dout(jtag_clock_reset_n)\n   );\n\n   altera_jtag_streaming #(\n       .PURPOSE(PURPOSE),\n       .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n       .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n       .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n   ) jtag_streaming (\n       .tck              (tck),\n       .tdi              (tdi),\n       .tdo              (tdo),\n       .ir_in            (ir_in),\n       .virtual_state_cdr(virtual_state_cdr),\n       .virtual_state_sdr(virtual_state_sdr),\n       .virtual_state_udr(virtual_state_udr),\n\n       .reset_n(jtag_clock_reset_n),\n       .source_data(jtag_source_data),\n       .source_valid(jtag_source_valid),\n       .sink_data(jtag_sink_data),\n       .sink_valid(jtag_sink_valid),\n       .sink_ready(jtag_sink_ready),\n       .clock_to_sample(clk),\n       .reset_to_sample(reset_n),\n       .resetrequest(resetrequest),\n       .debug_reset(debug_reset),\n       .mgmt_valid(mgmt_valid),\n       .mgmt_channel(mgmt_channel),\n       .mgmt_data(mgmt_data)\n    );\n\n   \n\n   altera_avalon_st_clock_crosser #(\n       .SYMBOLS_PER_BEAT(1),\n       .BITS_PER_SYMBOL(8),\n       .FORWARD_SYNC_DEPTH(SYSCLK_TO_TCK_SYNC_DEPTH),\n       .BACKWARD_SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) sink_crosser (\n       .in_clk(clk),\n       .in_reset(~reset_n),\n       .in_data(sink_data),\n       .in_ready(sink_ready),\n       .in_valid(sink_valid),\n       .out_clk(tck),\n       .out_reset(~jtag_clock_reset_n),\n       .out_data(jtag_sink_data),\n       .out_ready(jtag_sink_ready),\n       .out_valid(jtag_sink_valid)\n   );\n\n   altera_jtag_src_crosser #(\n       .SYNC_DEPTH(TCK_TO_SYSCLK_SYNC_DEPTH)\n   ) source_crosser (\n       .sink_clk(tck),\n       .sink_reset_n(jtag_clock_reset_n),\n       .sink_valid(jtag_source_valid),\n       .sink_data(jtag_source_data),\n       .src_clk(clk),\n       .src_reset_n(reset_n),\n       .src_valid(source_valid),\n       .src_data(source_data)\n   );\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_jtag_dc_streaming.\n\nModule specification: The altera_jtag_dc_streaming module is specifically designed for controlling JTAG data streaming and synchronization between multiple clock domains, particularly between JTAG and system clock domains in testing and debugging scenarios. The input ports include `tck`, `tdi`, `ir_in` for JTAG operations, `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr` for state machine synchronization, `clk` for system operations, `reset_n` for resetting the module, `sink_data`, and `sink_valid` for data input management. The output ports comprise `tdo` for the output data from JTAG, `source_data`, `source_valid` for sending data to system domain, `sink_ready` to accept more data, `resetrequest`, `debug_reset` for various reset functions, and `mgmt_valid`, `mgmt_channel`, `mgmt_data` for management operations. Internal signals such as `jtag_clock_reset_n` ensure reset operations are synced with the JTAG clock domain, while `jtag_source_data`, `jtag_source_valid`, `jtag_sink_data`, `jtag_sink_valid`, and `jtag_sink_ready` manage data integrity and flow control across domains. Key blocks in the code include `altera_std_synchronizer` for synchronization, `altera_jtag_streaming` for JTAG operations, and `altera_avalon_st_clock_crosser` and `altera_jtag_src_crosser` for clock domain data transfer. Each of these components is integral to maintaining data accuracy and timing across complex clock domain interactions."
                }
            ]
        }
    ]
}