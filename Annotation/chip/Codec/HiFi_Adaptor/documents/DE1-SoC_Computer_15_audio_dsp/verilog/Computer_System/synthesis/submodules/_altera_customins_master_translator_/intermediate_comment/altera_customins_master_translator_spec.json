{
    "spec": "Module name: altera_customins_master_translator.\nModule specification: The \"altera_customins_master_translator\" is a Verilog module designed for interfacing and translating signals between custom instruction master and slave interfaces in Altera FPGA architectures. It selectively routes input signals from the slave interface across either combinatorial or multi-cycle master outputs depending on the configuration specified by the module parameter `SHARED_COMB_AND_MULTI`. Input ports include various data, control, and clock signals such as `ci_slave_dataa`, `ci_slave_datab` (32-bit data operands), control signals (`ci_slave_readra`, `ci_slave_readrb`, `ci_slave_writerc` for read/write operations), and clock and control signals for multi-cycle operations (`ci_slave_multi_clk`, `ci_slave_multi_clken`, etc.). Output ports include the results back to slave interfaces (`ci_slave_result`, `ci_slave_multi_result`) and transferred signals to the master interfaces like `comb_ci_master_dataa`, `comb_ci_master_datab` for combinatorial operations, and `multi_ci_master_dataa`, `multi_ci_master_datab` for multi-cycle operations. An internal signal, `SHARED_COMB_AND_MULTI`, dictates operational mode, determining whether combinatorial and multi-cycle interfaces share signals or operate independently. The code features two main conditional blocks managed by a `generate if` statement, which adaptively reroutes the handling of input/output signal assignment based on the active mode indicated by `SHARED_COMB_AND_MULTI`. This organization facilitates flexible, accurate signal translation essential for custom instruction operations in diverse FPGA configurations.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_customins_master_translator.\nExplanation: This module serves as a translator between custom instruction master and slave interfaces. It transfers signals from ci_slave interfaces to comb_ci_master and multi_ci_master outputs based on the parameter `SHARED_COMB_AND_MULTI`. When `SHARED_COMB_AND_MULTI` is 0, the module operates in a mode where the combinatorial and multi-cycle custom instruction interfaces are handled separately, directly mapping each set of signals to their respective outputs. Otherwise, the module handles the interfaces in a shared mode, using the same signals for combinatorial and multi-cycle operations except for the result selection, which depends on the completion status of the multi-cycle operation. This facilitates the integration of both types of custom instructions (combinatorial and multi-cycle) in systems using Altera's FPGA architecture."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- ci_slave_dataa, ci_slave_datab: 32-bit input data operands for custom instructions.\n- ci_slave_n: 8-bit input specifying some parameter or mode for the custom instruction operation.\n- ci_slave_readra, ci_slave_readrb: Control signals to indicate if registers addressed by ci_slave_a and ci_slave_b should be read.\n- ci_slave_writerc: Control signal to indicate if the result should be written to the register addressed by ci_slave_c.\n- ci_slave_a, ci_slave_b, ci_slave_c: 5-bit register addresses used for read or write operations depending on control signals.\n- ci_slave_ipending, ci_slave_estatus: Input status signals possibly representing interrupt pending and status of execution respectively.\n- ci_slave_multi_clk, ci_slave_multi_reset, ci_slave_multi_reset_req, ci_slave_multi_clken, ci_slave_multi_start: Control and clock signals specifically for multi-cycle custom instruction operations.\n- ci_slave_multi_dataa, ci_slave_multi_datab: 32-bit input operands for multi-cycle operations.\n- ci_slave_multi_n: 8-bit input for multi-cycle operations specifying mode or parameter.\n- ci_slave_multi_readra, ci_slave_multi_readrb: Control signals for reading registers in multi-cycle operations.\n- ci_slave_multi_writerc: Control signal for writing result to a register in multi-cycle operations.\n- ci_slave_multi_a, ci_slave_multi_b, ci_slave_multi_c: Register addresses for multi-cycle operations.\n- multi_ci_master_done, multi_ci_master_result: Feedback from the master indicating the completion status of a multi-cycle operation and its result.\n\n**Explanation of Input Ports:**\nThese inputs either provide data, control, or clock signals essential for translating and forwarding custom instruction operations from the slave interface to the master interface. They are differentiated mainly between regular (combinatorial) and multi-cycle operations.\n\n**Output ports:**\n- ci_slave_result, ci_slave_multi_result: 32-bit outputs where results from the master interfaces are written back to the slave.\n- ci_slave_multi_done: Indicates the completion of multi-cycle operation.\n- comb_ci_master_dataa, comb_ci_master_datab: Forwarded data operands for the master in combinatorial operations.\n- comb_ci_master_n, comb_ci_master_readra, comb_ci_master_readrb, comb_ci_master_writerc, comb_ci_master_a, comb_ci_master_b, comb_ci_master_c, comb_ci_master_ipending, comb_ci_master_estatus: Various control and configuration signals for combinatorial operations mapped from slave inputs.\n- multi_ci_master_clk, multi_ci_master_reset, multi_ci_master_reset_req, multi_ci_master_clken, multi_ci_master_start: Clock and control signals for multi-cycle operations mapped from slave inputs.\n- multi_ci_master_dataa, multi_ci_master_datab, multi_ci_master_n, multi_ci_master_readra, multi_ci_master_readrb, multi_ci_master_writerc, multi_ci_master_a, multi_ci_master_b, multi_ci_master_c: Data and control outputs for multi-cycle operations mapped from either plain slave inputs or shared between combinatorial and multi-cycle operations depending on `SHARED_COMB_AND_MULTI`.\n\n**Explanation of Output Ports:**\nOutputs facilitate the completion of the operations started by the inputs. They return results and statuses to the slave interfaces or propagate necessary control and data signals to the master interfaces, ensuring smooth custom instruction operations across different cycles and modes conditioned by the module's internal logic and parameterizations."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n- SHARED_COMB_AND_MULTI\n\nExplanation:\n- SHARED_COMB_AND_MULTI: This is a parameter that is used to control the operational mode of the module. It determines how the signals are mapped between the slave interfaces and the master interfaces; either as separate mappings for combinatorial and multi-cycle custom instructions or shared mappings with conditional result selection based on the completion status from the multi-cycle operations.\n\nThis parameter effectively switches the wiring and logic behaviors internal to the module, impacting how data and control signals are transferred, thus allowing customization of the module's functionality based on the system\u2019s specifications or requirements."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_customins_master_translator \n#(\n    parameter SHARED_COMB_AND_MULTI = 0\n)\n(\n    \n    \n    \n    input  wire [31:0] ci_slave_dataa,          \n    input  wire [31:0] ci_slave_datab,          \n    output wire [31:0] ci_slave_result,         \n    input  wire [7:0]  ci_slave_n,              \n    input  wire        ci_slave_readra,         \n    input  wire        ci_slave_readrb,         \n    input  wire        ci_slave_writerc,        \n    input  wire [4:0]  ci_slave_a,              \n    input  wire [4:0]  ci_slave_b,              \n    input  wire [4:0]  ci_slave_c,              \n    input  wire [31:0] ci_slave_ipending,       \n    input  wire        ci_slave_estatus,        \n    input  wire        ci_slave_multi_clk,      \n    input  wire        ci_slave_multi_reset,    \n    input  wire        ci_slave_multi_reset_req,\n    input  wire        ci_slave_multi_clken,    \n    input  wire        ci_slave_multi_start,    \n    output wire        ci_slave_multi_done,     \n    input  wire [31:0] ci_slave_multi_dataa,    \n    input  wire [31:0] ci_slave_multi_datab,    \n    output wire [31:0] ci_slave_multi_result,   \n    input  wire [7:0]  ci_slave_multi_n,        \n    input  wire        ci_slave_multi_readra,   \n    input  wire        ci_slave_multi_readrb,   \n    input  wire        ci_slave_multi_writerc,  \n    input  wire [4:0]  ci_slave_multi_a,        \n    input  wire [4:0]  ci_slave_multi_b,        \n    input  wire [4:0]  ci_slave_multi_c,        \n    \n    \n    \n    output wire [31:0] comb_ci_master_dataa,    \n    output wire [31:0] comb_ci_master_datab,    \n    input  wire [31:0] comb_ci_master_result,   \n    output wire [7:0]  comb_ci_master_n,        \n    output wire        comb_ci_master_readra,   \n    output wire        comb_ci_master_readrb,   \n    output wire        comb_ci_master_writerc,  \n    output wire [4:0]  comb_ci_master_a,        \n    output wire [4:0]  comb_ci_master_b,        \n    output wire [4:0]  comb_ci_master_c,        \n    output wire [31:0] comb_ci_master_ipending, \n    output wire        comb_ci_master_estatus,  \n    \n    \n    \n    output wire        multi_ci_master_clk,     \n    output wire        multi_ci_master_reset,   \n    output wire        multi_ci_master_reset_req, \n    output wire        multi_ci_master_clken,   \n    output wire        multi_ci_master_start,   \n    input  wire        multi_ci_master_done,    \n    output wire [31:0] multi_ci_master_dataa,   \n    output wire [31:0] multi_ci_master_datab,   \n    input  wire [31:0] multi_ci_master_result,  \n    output wire [7:0]  multi_ci_master_n,       \n    output wire        multi_ci_master_readra,  \n    output wire        multi_ci_master_readrb,  \n    output wire        multi_ci_master_writerc, \n    output wire [4:0]  multi_ci_master_a,       \n    output wire [4:0]  multi_ci_master_b,       \n    output wire [4:0]  multi_ci_master_c        \n\t);\n\n    assign comb_ci_master_dataa   = ci_slave_dataa;\n    assign comb_ci_master_datab   = ci_slave_datab;\n    assign comb_ci_master_n       = ci_slave_n;\n    assign comb_ci_master_a       = ci_slave_a;\n    assign comb_ci_master_b       = ci_slave_b;\n    assign comb_ci_master_c       = ci_slave_c;\n    assign comb_ci_master_readra  = ci_slave_readra;\n    assign comb_ci_master_readrb  = ci_slave_readrb;\n    assign comb_ci_master_writerc = ci_slave_writerc;\n    assign comb_ci_master_ipending = ci_slave_ipending;\n    assign comb_ci_master_estatus  = ci_slave_estatus;\n\n    assign multi_ci_master_clk   = ci_slave_multi_clk;\n    assign multi_ci_master_reset = ci_slave_multi_reset;\n    assign multi_ci_master_reset_req = ci_slave_multi_reset_req;\n    assign multi_ci_master_clken = ci_slave_multi_clken;\n    assign multi_ci_master_start = ci_slave_multi_start;\n    assign ci_slave_multi_done   = multi_ci_master_done;\n\n    generate if (SHARED_COMB_AND_MULTI == 0) begin\n\n        assign multi_ci_master_dataa   = ci_slave_multi_dataa;\n        assign multi_ci_master_datab   = ci_slave_multi_datab;\n        assign multi_ci_master_n       = ci_slave_multi_n;\n        assign multi_ci_master_a       = ci_slave_multi_a;\n        assign multi_ci_master_b       = ci_slave_multi_b;\n        assign multi_ci_master_c       = ci_slave_multi_c;\n        assign multi_ci_master_readra  = ci_slave_multi_readra;\n        assign multi_ci_master_readrb  = ci_slave_multi_readrb;\n        assign multi_ci_master_writerc = ci_slave_multi_writerc;\n        \n        assign ci_slave_result         = comb_ci_master_result;\n        assign ci_slave_multi_result   = multi_ci_master_result;\n\n    end else begin\n\n\t    assign multi_ci_master_dataa   = ci_slave_dataa;\n\t    assign multi_ci_master_datab   = ci_slave_datab;\n        assign multi_ci_master_n       = ci_slave_n;\n        assign multi_ci_master_a       = ci_slave_a;\n        assign multi_ci_master_b       = ci_slave_b;\n        assign multi_ci_master_c       = ci_slave_c;\n        assign multi_ci_master_readra  = ci_slave_readra;\n        assign multi_ci_master_readrb  = ci_slave_readrb;\n        assign multi_ci_master_writerc = ci_slave_writerc;\n\n        assign ci_slave_result = ci_slave_multi_done ? multi_ci_master_result :\n                                    comb_ci_master_result;\n\n    end\n\n    endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_customins_master_translator.\nModule specification: The \"altera_customins_master_translator\" is a Verilog module designed for interfacing and translating signals between custom instruction master and slave interfaces in Altera FPGA architectures. It selectively routes input signals from the slave interface across either combinatorial or multi-cycle master outputs depending on the configuration specified by the module parameter `SHARED_COMB_AND_MULTI`. Input ports include various data, control, and clock signals such as `ci_slave_dataa`, `ci_slave_datab` (32-bit data operands), control signals (`ci_slave_readra`, `ci_slave_readrb`, `ci_slave_writerc` for read/write operations), and clock and control signals for multi-cycle operations (`ci_slave_multi_clk`, `ci_slave_multi_clken`, etc.). Output ports include the results back to slave interfaces (`ci_slave_result`, `ci_slave_multi_result`) and transferred signals to the master interfaces like `comb_ci_master_dataa`, `comb_ci_master_datab` for combinatorial operations, and `multi_ci_master_dataa`, `multi_ci_master_datab` for multi-cycle operations. An internal signal, `SHARED_COMB_AND_MULTI`, dictates operational mode, determining whether combinatorial and multi-cycle interfaces share signals or operate independently. The code features two main conditional blocks managed by a `generate if` statement, which adaptively reroutes the handling of input/output signal assignment based on the active mode indicated by `SHARED_COMB_AND_MULTI`. This organization facilitates flexible, accurate signal translation essential for custom instruction operations in diverse FPGA configurations."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_customins_master_translator.\nExplanation: This module serves as a translator between custom instruction master and slave interfaces. It transfers signals from ci_slave interfaces to comb_ci_master and multi_ci_master outputs based on the parameter `SHARED_COMB_AND_MULTI`. When `SHARED_COMB_AND_MULTI` is 0, the module operates in a mode where the combinatorial and multi-cycle custom instruction interfaces are handled separately, directly mapping each set of signals to their respective outputs. Otherwise, the module handles the interfaces in a shared mode, using the same signals for combinatorial and multi-cycle operations except for the result selection, which depends on the completion status of the multi-cycle operation. This facilitates the integration of both types of custom instructions (combinatorial and multi-cycle) in systems using Altera's FPGA architecture."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- ci_slave_dataa, ci_slave_datab: 32-bit input data operands for custom instructions.\n- ci_slave_n: 8-bit input specifying some parameter or mode for the custom instruction operation.\n- ci_slave_readra, ci_slave_readrb: Control signals to indicate if registers addressed by ci_slave_a and ci_slave_b should be read.\n- ci_slave_writerc: Control signal to indicate if the result should be written to the register addressed by ci_slave_c.\n- ci_slave_a, ci_slave_b, ci_slave_c: 5-bit register addresses used for read or write operations depending on control signals.\n- ci_slave_ipending, ci_slave_estatus: Input status signals possibly representing interrupt pending and status of execution respectively.\n- ci_slave_multi_clk, ci_slave_multi_reset, ci_slave_multi_reset_req, ci_slave_multi_clken, ci_slave_multi_start: Control and clock signals specifically for multi-cycle custom instruction operations.\n- ci_slave_multi_dataa, ci_slave_multi_datab: 32-bit input operands for multi-cycle operations.\n- ci_slave_multi_n: 8-bit input for multi-cycle operations specifying mode or parameter.\n- ci_slave_multi_readra, ci_slave_multi_readrb: Control signals for reading registers in multi-cycle operations.\n- ci_slave_multi_writerc: Control signal for writing result to a register in multi-cycle operations.\n- ci_slave_multi_a, ci_slave_multi_b, ci_slave_multi_c: Register addresses for multi-cycle operations.\n- multi_ci_master_done, multi_ci_master_result: Feedback from the master indicating the completion status of a multi-cycle operation and its result.\n\n**Explanation of Input Ports:**\nThese inputs either provide data, control, or clock signals essential for translating and forwarding custom instruction operations from the slave interface to the master interface. They are differentiated mainly between regular (combinatorial) and multi-cycle operations.\n\n**Output ports:**\n- ci_slave_result, ci_slave_multi_result: 32-bit outputs where results from the master interfaces are written back to the slave.\n- ci_slave_multi_done: Indicates the completion of multi-cycle operation.\n- comb_ci_master_dataa, comb_ci_master_datab: Forwarded data operands for the master in combinatorial operations.\n- comb_ci_master_n, comb_ci_master_readra, comb_ci_master_readrb, comb_ci_master_writerc, comb_ci_master_a, comb_ci_master_b, comb_ci_master_c, comb_ci_master_ipending, comb_ci_master_estatus: Various control and configuration signals for combinatorial operations mapped from slave inputs.\n- multi_ci_master_clk, multi_ci_master_reset, multi_ci_master_reset_req, multi_ci_master_clken, multi_ci_master_start: Clock and control signals for multi-cycle operations mapped from slave inputs.\n- multi_ci_master_dataa, multi_ci_master_datab, multi_ci_master_n, multi_ci_master_readra, multi_ci_master_readrb, multi_ci_master_writerc, multi_ci_master_a, multi_ci_master_b, multi_ci_master_c: Data and control outputs for multi-cycle operations mapped from either plain slave inputs or shared between combinatorial and multi-cycle operations depending on `SHARED_COMB_AND_MULTI`.\n\n**Explanation of Output Ports:**\nOutputs facilitate the completion of the operations started by the inputs. They return results and statuses to the slave interfaces or propagate necessary control and data signals to the master interfaces, ensuring smooth custom instruction operations across different cycles and modes conditioned by the module's internal logic and parameterizations."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n- SHARED_COMB_AND_MULTI\n\nExplanation:\n- SHARED_COMB_AND_MULTI: This is a parameter that is used to control the operational mode of the module. It determines how the signals are mapped between the slave interfaces and the master interfaces; either as separate mappings for combinatorial and multi-cycle custom instructions or shared mappings with conditional result selection based on the completion status from the multi-cycle operations.\n\nThis parameter effectively switches the wiring and logic behaviors internal to the module, impacting how data and control signals are transferred, thus allowing customization of the module's functionality based on the system\u2019s specifications or requirements."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_customins_master_translator \n#(\n    parameter SHARED_COMB_AND_MULTI = 0\n)\n(\n    \n    \n    \n    input  wire [31:0] ci_slave_dataa,          \n    input  wire [31:0] ci_slave_datab,          \n    output wire [31:0] ci_slave_result,         \n    input  wire [7:0]  ci_slave_n,              \n    input  wire        ci_slave_readra,         \n    input  wire        ci_slave_readrb,         \n    input  wire        ci_slave_writerc,        \n    input  wire [4:0]  ci_slave_a,              \n    input  wire [4:0]  ci_slave_b,              \n    input  wire [4:0]  ci_slave_c,              \n    input  wire [31:0] ci_slave_ipending,       \n    input  wire        ci_slave_estatus,        \n    input  wire        ci_slave_multi_clk,      \n    input  wire        ci_slave_multi_reset,    \n    input  wire        ci_slave_multi_reset_req,\n    input  wire        ci_slave_multi_clken,    \n    input  wire        ci_slave_multi_start,    \n    output wire        ci_slave_multi_done,     \n    input  wire [31:0] ci_slave_multi_dataa,    \n    input  wire [31:0] ci_slave_multi_datab,    \n    output wire [31:0] ci_slave_multi_result,   \n    input  wire [7:0]  ci_slave_multi_n,        \n    input  wire        ci_slave_multi_readra,   \n    input  wire        ci_slave_multi_readrb,   \n    input  wire        ci_slave_multi_writerc,  \n    input  wire [4:0]  ci_slave_multi_a,        \n    input  wire [4:0]  ci_slave_multi_b,        \n    input  wire [4:0]  ci_slave_multi_c,        \n    \n    \n    \n    output wire [31:0] comb_ci_master_dataa,    \n    output wire [31:0] comb_ci_master_datab,    \n    input  wire [31:0] comb_ci_master_result,   \n    output wire [7:0]  comb_ci_master_n,        \n    output wire        comb_ci_master_readra,   \n    output wire        comb_ci_master_readrb,   \n    output wire        comb_ci_master_writerc,  \n    output wire [4:0]  comb_ci_master_a,        \n    output wire [4:0]  comb_ci_master_b,        \n    output wire [4:0]  comb_ci_master_c,        \n    output wire [31:0] comb_ci_master_ipending, \n    output wire        comb_ci_master_estatus,  \n    \n    \n    \n    output wire        multi_ci_master_clk,     \n    output wire        multi_ci_master_reset,   \n    output wire        multi_ci_master_reset_req, \n    output wire        multi_ci_master_clken,   \n    output wire        multi_ci_master_start,   \n    input  wire        multi_ci_master_done,    \n    output wire [31:0] multi_ci_master_dataa,   \n    output wire [31:0] multi_ci_master_datab,   \n    input  wire [31:0] multi_ci_master_result,  \n    output wire [7:0]  multi_ci_master_n,       \n    output wire        multi_ci_master_readra,  \n    output wire        multi_ci_master_readrb,  \n    output wire        multi_ci_master_writerc, \n    output wire [4:0]  multi_ci_master_a,       \n    output wire [4:0]  multi_ci_master_b,       \n    output wire [4:0]  multi_ci_master_c        \n\t);\n\n    assign comb_ci_master_dataa   = ci_slave_dataa;\n    assign comb_ci_master_datab   = ci_slave_datab;\n    assign comb_ci_master_n       = ci_slave_n;\n    assign comb_ci_master_a       = ci_slave_a;\n    assign comb_ci_master_b       = ci_slave_b;\n    assign comb_ci_master_c       = ci_slave_c;\n    assign comb_ci_master_readra  = ci_slave_readra;\n    assign comb_ci_master_readrb  = ci_slave_readrb;\n    assign comb_ci_master_writerc = ci_slave_writerc;\n    assign comb_ci_master_ipending = ci_slave_ipending;\n    assign comb_ci_master_estatus  = ci_slave_estatus;\n\n    assign multi_ci_master_clk   = ci_slave_multi_clk;\n    assign multi_ci_master_reset = ci_slave_multi_reset;\n    assign multi_ci_master_reset_req = ci_slave_multi_reset_req;\n    assign multi_ci_master_clken = ci_slave_multi_clken;\n    assign multi_ci_master_start = ci_slave_multi_start;\n    assign ci_slave_multi_done   = multi_ci_master_done;\n\n    generate if (SHARED_COMB_AND_MULTI == 0) begin\n\n        assign multi_ci_master_dataa   = ci_slave_multi_dataa;\n        assign multi_ci_master_datab   = ci_slave_multi_datab;\n        assign multi_ci_master_n       = ci_slave_multi_n;\n        assign multi_ci_master_a       = ci_slave_multi_a;\n        assign multi_ci_master_b       = ci_slave_multi_b;\n        assign multi_ci_master_c       = ci_slave_multi_c;\n        assign multi_ci_master_readra  = ci_slave_multi_readra;\n        assign multi_ci_master_readrb  = ci_slave_multi_readrb;\n        assign multi_ci_master_writerc = ci_slave_multi_writerc;\n        \n        assign ci_slave_result         = comb_ci_master_result;\n        assign ci_slave_multi_result   = multi_ci_master_result;\n\n    end else begin\n\n\t    assign multi_ci_master_dataa   = ci_slave_dataa;\n\t    assign multi_ci_master_datab   = ci_slave_datab;\n        assign multi_ci_master_n       = ci_slave_n;\n        assign multi_ci_master_a       = ci_slave_a;\n        assign multi_ci_master_b       = ci_slave_b;\n        assign multi_ci_master_c       = ci_slave_c;\n        assign multi_ci_master_readra  = ci_slave_readra;\n        assign multi_ci_master_readrb  = ci_slave_readrb;\n        assign multi_ci_master_writerc = ci_slave_writerc;\n\n        assign ci_slave_result = ci_slave_multi_done ? multi_ci_master_result :\n                                    comb_ci_master_result;\n\n    end\n\n    endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_customins_master_translator.\nModule specification: The \"altera_customins_master_translator\" is a Verilog module designed for interfacing and translating signals between custom instruction master and slave interfaces in Altera FPGA architectures. It selectively routes input signals from the slave interface across either combinatorial or multi-cycle master outputs depending on the configuration specified by the module parameter `SHARED_COMB_AND_MULTI`. Input ports include various data, control, and clock signals such as `ci_slave_dataa`, `ci_slave_datab` (32-bit data operands), control signals (`ci_slave_readra`, `ci_slave_readrb`, `ci_slave_writerc` for read/write operations), and clock and control signals for multi-cycle operations (`ci_slave_multi_clk`, `ci_slave_multi_clken`, etc.). Output ports include the results back to slave interfaces (`ci_slave_result`, `ci_slave_multi_result`) and transferred signals to the master interfaces like `comb_ci_master_dataa`, `comb_ci_master_datab` for combinatorial operations, and `multi_ci_master_dataa`, `multi_ci_master_datab` for multi-cycle operations. An internal signal, `SHARED_COMB_AND_MULTI`, dictates operational mode, determining whether combinatorial and multi-cycle interfaces share signals or operate independently. The code features two main conditional blocks managed by a `generate if` statement, which adaptively reroutes the handling of input/output signal assignment based on the active mode indicated by `SHARED_COMB_AND_MULTI`. This organization facilitates flexible, accurate signal translation essential for custom instruction operations in diverse FPGA configurations."
                }
            ]
        }
    ]
}