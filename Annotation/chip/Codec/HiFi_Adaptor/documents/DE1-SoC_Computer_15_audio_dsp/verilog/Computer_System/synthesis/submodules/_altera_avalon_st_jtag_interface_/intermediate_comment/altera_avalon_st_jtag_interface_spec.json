{
    "spec": "Module name: altera_avalon_st_jtag_interface.\nModule specification: The altera_avalon_st_jtag_interface module is designed to integrate JTAG communication capabilities with Altera's Avalon streaming architecture, providing key functionalities and debugging features for embedded systems. Among its input ports, this module includes JTAG signals like `jtag_tck`, `jtag_tms`, `jtag_tdi`, and the enable signal `jtag_ena`, among others specifying various JTAG states (`jtag_state_tlr`, `jtag_state_rti`, etc.) and control signals (`reset_n`, `clk` for synchronization, `source_ready`, and data flow control ports `sink_data`, `sink_valid`). Output ports include `jtag_tdo`, handling JTAG Test Data Output, `source_data`, `source_valid`, and `sink_ready` which manage data streams, and signals like `resetrequest`, `debug_reset`, and management signals (`mgmt_valid`, `mgmt_channel`, `mgmt_data`). Internal signals such as `tck`, `tdi`, `tdo`, and virtual state indicators (`virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`) manage the internal state and data processing based on JTAG operations. The code includes conditional generation blocks. If EXPORT_JTAG is enabled, JTAG-related signals are directly assigned. On the other hand, a PLI-based simulation unit, controlled by USE_PLI, is used for more sophisticated simulation interfacing operations, dictating how data is transmitted or received during simulations. This dual operation mode (normal and PLI simulation) allows flexibility in testing and debugging across different system configurations.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_avalon_st_jtag_interface.\n\nExplanation: This Verilog module defines an interface that integrates JTAG communication capabilities with Altera's Avalon streaming architecture. The parameters allow customization of FIFO sizes, management data channel widths, and the ability to integrate with software simulations through a PLI (Programming Language Interface). It supports handling JTAG operations in two parts: normal operation and PLI-based simulation. In normal operation, it uses \"altera_jtag_dc_streaming\" to handle data streaming across JTAG. In PLI mode, it employs simulation-specific tasks using `$do_transaction`.\n\nIn the control path, it checks for different states of JTAG transitions (like Capture-DR, Shift-DR, etc.) and reacts accordingly based on whether JTAG is exported directly or the system is under simulation. The module provides output signals like JTAG IRQ and data flow controls which are essential for integrated systems testing and debugging."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n- `jtag_tck`\n- `jtag_tms`\n- `jtag_tdi`\n- `jtag_ena`\n- `jtag_usr1`\n- `jtag_clr`\n- `jtag_clrn`\n- `jtag_state_tlr`\n- `jtag_state_rti`\n- `jtag_state_sdrs`\n- `jtag_state_cdr`\n- `jtag_state_sdr`\n- `jtag_state_e1dr`\n- `jtag_state_pdr`\n- `jtag_state_e2dr`\n- `jtag_state_udr`\n- `jtag_state_sirs`\n- `jtag_state_cir`\n- `jtag_state_sir`\n- `jtag_state_e1ir`\n- `jtag_state_pir`\n- `jtag_state_e2ir`\n- `jtag_state_uir`\n- `jtag_ir_in`\n- `clk`\n- `reset_n`\n- `source_ready`\n- `sink_data`\n- `sink_valid`\n\nExplanation: \n- `jtag_tck`: JTAG Test Clock input used for synchronizing JTAG operations.\n- `jtag_tms`: JTAG Mode Select, used for navigating through the JTAG state machine.\n- `jtag_tdi`: JTAG Test Data In, receives serial data input targeted for the device\u2019s test logic.\n- `jtag_ena`: Enable signal, used to activate JTAG operations.\n- `jtag_usr1`: A user-defined signal, typically used to control specific JTAG operations.\n- `jtag_clr`, `jtag_clrn`: Clear signals (active high and active low) for JTAG state resets.\n- State detection signals (`jtag_state_xxx`): For detecting various states in the JTAG state machine such as Test Logic Reset (`tlr`), Run Test/Idle (`rti`), Capture-IR/DR (`cir`/`cdr`), Shift-IR/DR (`sir`/`sdr`), Exit1-IR/DR (`e1ir`/`e1dr`), Pause-IR/DR (`pir`/`pdr`), Exit2-IR/DR (`e2ir`/`e2dr`), and Update-IR/DR (`uir`/`udr`).\n- `jtag_ir_in`: Input to set the Instruction Register for JTAG operations.\n- `clk`: Clock input for synchronizing internal operations.\n- `reset_n`: Active low reset signal to initialize the internal state of the module.\n- `source_ready`: A signal indicating that the upstream component is ready to accept data.\n- `sink_data`: Data input from the downstream component.\n- `sink_valid`: Indicates valid data available at `sink_data`.\n\nOutput ports:\n- `jtag_tdo`\n- `jtag_irq`\n- `jtag_ir_out`\n- `source_data`\n- `source_valid`\n- `sink_ready`\n- `resetrequest`\n- `debug_reset`\n- `mgmt_valid`\n- `mgmt_channel`\n- `mgmt_data`\n\nExplanation:\n- `jtag_tdo`: JTAG Test Data Out, sends serial data out from the device\u2019s test logic.\n- `jtag_irq`: JTAG interrupt request, signaling an interrupt request to the host.\n- `jtag_ir_out`: Outputs the Instruction Register settings for linked JTAG device configurations.\n- `source_data`: Output data stream sent to the upstream component.\n- `source_valid`: Indicates the `source_data` is valid and ready for consumption.\n- `sink_ready`: Signals the readiness to accept more data into the sink component.\n- `resetrequest`: Requests a system reset, typically used in system testing scenarios.\n- `debug_reset`: A reset signal specifically for debugging purposes.\n- `mgmt_valid`: Indicates the validity of management data available on `mgmt_channel`.\n- `mgmt_channel`: Management channel for auxiliary data (width may vary).\n- `mgmt_data`: Output for management data used in control operations."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n- `tck`\n- `tdi`\n- `tdo`\n- `ir_in`\n- `virtual_state_cdr`\n- `virtual_state_sdr`\n- `virtual_state_udr`\n- `pli_out_valid`\n- `pli_in_ready`\n- `pli_out_data`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_ready`\n- `jtag_resetrequest`\n\nExplanation:\n- `tck`: Mirrors the `jtag_tck` input or is driven by an internal module, used as the clock for JTAG operations in the given instance.\n- `tdi`: Mirrors the `jtag_tdi` input or is controlled by the internal module, used as the input data line for JTAG data transfer.\n- `tdo`: Used to drive the `jtag_tdo` output after internal data processing or simulation results.\n- `ir_in`: Internal representation of the JTAG instruction register input, controls JTAG operations based on instruction set.\n- `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`: These signals represent internal virtual states corresponding to the Capture-DR, Shift-DR, and Update-DR states in JTAG operations. They help in managing the data flow and state machine transitions during JTAG operations.\n- `pli_out_valid`, `pli_in_ready`: Used in PLI mode to manage and coordinate the status of data streams interacting with simulation environments.\n- `pli_out_data`: Represents the data to be sent out during PLI simulation operations.\n- `jtag_source_data`, `jtag_source_valid`, `jtag_sink_ready`, `jtag_resetrequest`: These are replica or corresponding signals used specifically in the context of the PLI mode to handle data streams and reset requests effectively, bridging the simulation with real operations."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_avalon_st_jtag_interface #(\n    parameter PURPOSE = 0, \n                           \n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1,\n    parameter EXPORT_JTAG = 0,\n    parameter USE_PLI = 0,      \n    parameter PLI_PORT = 50000  \n) (\n    input  wire       jtag_tck,\n    input  wire       jtag_tms,\n    input  wire       jtag_tdi,\n    output wire       jtag_tdo,\n    input  wire       jtag_ena,\n    input  wire       jtag_usr1,\n    input  wire       jtag_clr,\n    input  wire       jtag_clrn,\n    input  wire       jtag_state_tlr,\n    input  wire       jtag_state_rti,\n    input  wire       jtag_state_sdrs,\n    input  wire       jtag_state_cdr,\n    input  wire       jtag_state_sdr,\n    input  wire       jtag_state_e1dr,\n    input  wire       jtag_state_pdr,\n    input  wire       jtag_state_e2dr,\n    input  wire       jtag_state_udr,\n    input  wire       jtag_state_sirs,\n    input  wire       jtag_state_cir,\n    input  wire       jtag_state_sir,\n    input  wire       jtag_state_e1ir,\n    input  wire       jtag_state_pir,\n    input  wire       jtag_state_e2ir,\n    input  wire       jtag_state_uir,\n    input  wire [2:0] jtag_ir_in,\n    output wire       jtag_irq,\n    output wire [2:0] jtag_ir_out,\n    input  wire       clk,\n    input  wire       reset_n,\n    input  wire       source_ready,\n    output wire [7:0] source_data,\n    output wire       source_valid,\n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    output wire       resetrequest,\n    output wire       debug_reset,\n    output wire       mgmt_valid,\n    output wire [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output wire       mgmt_data\n);\n\n  \n  wire       tck;\n  wire       tdi;\n  wire       tdo;\n  wire [2:0] ir_in;\n  wire       virtual_state_cdr;\n  wire       virtual_state_sdr;\n  wire       virtual_state_udr;\n\n  assign jtag_irq = 1'b0;\n  assign jtag_ir_out = 3'b000;\n\n  generate\n    if (EXPORT_JTAG == 0) begin\n      \n      altera_jtag_sld_node node (\n        .tck                (tck),\n        .tdi                (tdi),\n        .tdo                (tdo),\n        .ir_out             (1'b0),\n        .ir_in              (ir_in),\n        .virtual_state_cdr  (virtual_state_cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (virtual_state_sdr),\n        .virtual_state_udr  (virtual_state_udr),\n        .virtual_state_uir  ()\n      );\n\n      assign jtag_tdo = 1'b0;\n    end else begin\n      assign tck = jtag_tck;\n      assign tdi = jtag_tdi;\n      assign jtag_tdo = tdo;\n      assign ir_in = jtag_ir_in;\n      assign virtual_state_cdr = jtag_ena && !jtag_usr1 && jtag_state_cdr;\n      assign virtual_state_sdr = jtag_ena && !jtag_usr1 && jtag_state_sdr;\n      assign virtual_state_udr = jtag_ena && !jtag_usr1 && jtag_state_udr;\n    end\n  endgenerate\n\n  generate \n    if (USE_PLI == 0)\n      begin : normal\n        altera_jtag_dc_streaming #(\n          .PURPOSE(PURPOSE),\n          .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n          .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n          .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n        ) jtag_dc_streaming (\n          .tck              (tck),\n          .tdi              (tdi),\n          .tdo              (tdo),\n          .ir_in            (ir_in),\n          .virtual_state_cdr(virtual_state_cdr),\n          .virtual_state_sdr(virtual_state_sdr),\n          .virtual_state_udr(virtual_state_udr),\n          .clk(clk),\n          .reset_n(reset_n),\n          .source_data(source_data),\n          .source_valid(source_valid),\n          .sink_data(sink_data),\n          .sink_valid(sink_valid),\n          .sink_ready(sink_ready),\n          .resetrequest(resetrequest),\n          .debug_reset(debug_reset),\n          .mgmt_valid(mgmt_valid),\n          .mgmt_channel(mgmt_channel),\n          .mgmt_data(mgmt_data)\n        );\n   \n      end\n    else\n      begin : pli_mode\n\t  \n        \n        reg pli_out_valid;\n        reg pli_in_ready;\n        reg [7 : 0] pli_out_data;\n        \n        always @(posedge clk or negedge reset_n) begin\n          if (!reset_n) begin\n            pli_out_valid <= 0;\n            pli_out_data <= 'b0;\n            pli_in_ready <= 0;\n          end\n          else begin\n            `ifdef MODEL_TECH\n              $do_transaction(\n                PLI_PORT, \n                pli_out_valid, \n                source_ready, \n                pli_out_data,\n                sink_valid,\n                pli_in_ready,\n                sink_data\n              );\n            `endif\n          end\n        end\n\t\t\n\t\t\n        wire [7:0] jtag_source_data;\n        wire jtag_source_valid;\n        wire jtag_sink_ready;\n        wire jtag_resetrequest;\n\t\t\n        altera_jtag_dc_streaming #(\n          .PURPOSE(PURPOSE),\n          .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n          .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n          .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n        ) jtag_dc_streaming (\n          .tck              (tck),\n          .tdi              (tdi),\n          .tdo              (tdo),\n          .ir_in            (ir_in),\n          .virtual_state_cdr(virtual_state_cdr),\n          .virtual_state_sdr(virtual_state_sdr),\n          .virtual_state_udr(virtual_state_udr),\n          .clk(clk),\n          .reset_n(reset_n),\n          .source_data(jtag_source_data),\n          .source_valid(jtag_source_valid),\n          .sink_data(sink_data),\n          .sink_valid(sink_valid),\n          .sink_ready(jtag_sink_ready),\n          .resetrequest(jtag_resetrequest)\n          \n          \n          \n          \n        );\n       \n          \n          \n          \n          \n          \n          \n\n          \n\t  assign source_valid = pli_out_valid;\n          assign source_data = pli_out_data;\n          assign sink_ready = pli_in_ready;\n          assign resetrequest = 1'b0;\n          \n          assign jtag_tdo = 1'b0;\n      end\n  endgenerate\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_avalon_st_jtag_interface.\nModule specification: The altera_avalon_st_jtag_interface module is designed to integrate JTAG communication capabilities with Altera's Avalon streaming architecture, providing key functionalities and debugging features for embedded systems. Among its input ports, this module includes JTAG signals like `jtag_tck`, `jtag_tms`, `jtag_tdi`, and the enable signal `jtag_ena`, among others specifying various JTAG states (`jtag_state_tlr`, `jtag_state_rti`, etc.) and control signals (`reset_n`, `clk` for synchronization, `source_ready`, and data flow control ports `sink_data`, `sink_valid`). Output ports include `jtag_tdo`, handling JTAG Test Data Output, `source_data`, `source_valid`, and `sink_ready` which manage data streams, and signals like `resetrequest`, `debug_reset`, and management signals (`mgmt_valid`, `mgmt_channel`, `mgmt_data`). Internal signals such as `tck`, `tdi`, `tdo`, and virtual state indicators (`virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`) manage the internal state and data processing based on JTAG operations. The code includes conditional generation blocks. If EXPORT_JTAG is enabled, JTAG-related signals are directly assigned. On the other hand, a PLI-based simulation unit, controlled by USE_PLI, is used for more sophisticated simulation interfacing operations, dictating how data is transmitted or received during simulations. This dual operation mode (normal and PLI simulation) allows flexibility in testing and debugging across different system configurations."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_avalon_st_jtag_interface.\n\nExplanation: This Verilog module defines an interface that integrates JTAG communication capabilities with Altera's Avalon streaming architecture. The parameters allow customization of FIFO sizes, management data channel widths, and the ability to integrate with software simulations through a PLI (Programming Language Interface). It supports handling JTAG operations in two parts: normal operation and PLI-based simulation. In normal operation, it uses \"altera_jtag_dc_streaming\" to handle data streaming across JTAG. In PLI mode, it employs simulation-specific tasks using `$do_transaction`.\n\nIn the control path, it checks for different states of JTAG transitions (like Capture-DR, Shift-DR, etc.) and reacts accordingly based on whether JTAG is exported directly or the system is under simulation. The module provides output signals like JTAG IRQ and data flow controls which are essential for integrated systems testing and debugging."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n- `jtag_tck`\n- `jtag_tms`\n- `jtag_tdi`\n- `jtag_ena`\n- `jtag_usr1`\n- `jtag_clr`\n- `jtag_clrn`\n- `jtag_state_tlr`\n- `jtag_state_rti`\n- `jtag_state_sdrs`\n- `jtag_state_cdr`\n- `jtag_state_sdr`\n- `jtag_state_e1dr`\n- `jtag_state_pdr`\n- `jtag_state_e2dr`\n- `jtag_state_udr`\n- `jtag_state_sirs`\n- `jtag_state_cir`\n- `jtag_state_sir`\n- `jtag_state_e1ir`\n- `jtag_state_pir`\n- `jtag_state_e2ir`\n- `jtag_state_uir`\n- `jtag_ir_in`\n- `clk`\n- `reset_n`\n- `source_ready`\n- `sink_data`\n- `sink_valid`\n\nExplanation: \n- `jtag_tck`: JTAG Test Clock input used for synchronizing JTAG operations.\n- `jtag_tms`: JTAG Mode Select, used for navigating through the JTAG state machine.\n- `jtag_tdi`: JTAG Test Data In, receives serial data input targeted for the device\u2019s test logic.\n- `jtag_ena`: Enable signal, used to activate JTAG operations.\n- `jtag_usr1`: A user-defined signal, typically used to control specific JTAG operations.\n- `jtag_clr`, `jtag_clrn`: Clear signals (active high and active low) for JTAG state resets.\n- State detection signals (`jtag_state_xxx`): For detecting various states in the JTAG state machine such as Test Logic Reset (`tlr`), Run Test/Idle (`rti`), Capture-IR/DR (`cir`/`cdr`), Shift-IR/DR (`sir`/`sdr`), Exit1-IR/DR (`e1ir`/`e1dr`), Pause-IR/DR (`pir`/`pdr`), Exit2-IR/DR (`e2ir`/`e2dr`), and Update-IR/DR (`uir`/`udr`).\n- `jtag_ir_in`: Input to set the Instruction Register for JTAG operations.\n- `clk`: Clock input for synchronizing internal operations.\n- `reset_n`: Active low reset signal to initialize the internal state of the module.\n- `source_ready`: A signal indicating that the upstream component is ready to accept data.\n- `sink_data`: Data input from the downstream component.\n- `sink_valid`: Indicates valid data available at `sink_data`.\n\nOutput ports:\n- `jtag_tdo`\n- `jtag_irq`\n- `jtag_ir_out`\n- `source_data`\n- `source_valid`\n- `sink_ready`\n- `resetrequest`\n- `debug_reset`\n- `mgmt_valid`\n- `mgmt_channel`\n- `mgmt_data`\n\nExplanation:\n- `jtag_tdo`: JTAG Test Data Out, sends serial data out from the device\u2019s test logic.\n- `jtag_irq`: JTAG interrupt request, signaling an interrupt request to the host.\n- `jtag_ir_out`: Outputs the Instruction Register settings for linked JTAG device configurations.\n- `source_data`: Output data stream sent to the upstream component.\n- `source_valid`: Indicates the `source_data` is valid and ready for consumption.\n- `sink_ready`: Signals the readiness to accept more data into the sink component.\n- `resetrequest`: Requests a system reset, typically used in system testing scenarios.\n- `debug_reset`: A reset signal specifically for debugging purposes.\n- `mgmt_valid`: Indicates the validity of management data available on `mgmt_channel`.\n- `mgmt_channel`: Management channel for auxiliary data (width may vary).\n- `mgmt_data`: Output for management data used in control operations."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n- `tck`\n- `tdi`\n- `tdo`\n- `ir_in`\n- `virtual_state_cdr`\n- `virtual_state_sdr`\n- `virtual_state_udr`\n- `pli_out_valid`\n- `pli_in_ready`\n- `pli_out_data`\n- `jtag_source_data`\n- `jtag_source_valid`\n- `jtag_sink_ready`\n- `jtag_resetrequest`\n\nExplanation:\n- `tck`: Mirrors the `jtag_tck` input or is driven by an internal module, used as the clock for JTAG operations in the given instance.\n- `tdi`: Mirrors the `jtag_tdi` input or is controlled by the internal module, used as the input data line for JTAG data transfer.\n- `tdo`: Used to drive the `jtag_tdo` output after internal data processing or simulation results.\n- `ir_in`: Internal representation of the JTAG instruction register input, controls JTAG operations based on instruction set.\n- `virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`: These signals represent internal virtual states corresponding to the Capture-DR, Shift-DR, and Update-DR states in JTAG operations. They help in managing the data flow and state machine transitions during JTAG operations.\n- `pli_out_valid`, `pli_in_ready`: Used in PLI mode to manage and coordinate the status of data streams interacting with simulation environments.\n- `pli_out_data`: Represents the data to be sent out during PLI simulation operations.\n- `jtag_source_data`, `jtag_source_valid`, `jtag_sink_ready`, `jtag_resetrequest`: These are replica or corresponding signals used specifically in the context of the PLI mode to handle data streams and reset requests effectively, bridging the simulation with real operations."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_avalon_st_jtag_interface #(\n    parameter PURPOSE = 0, \n                           \n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1,\n    parameter EXPORT_JTAG = 0,\n    parameter USE_PLI = 0,      \n    parameter PLI_PORT = 50000  \n) (\n    input  wire       jtag_tck,\n    input  wire       jtag_tms,\n    input  wire       jtag_tdi,\n    output wire       jtag_tdo,\n    input  wire       jtag_ena,\n    input  wire       jtag_usr1,\n    input  wire       jtag_clr,\n    input  wire       jtag_clrn,\n    input  wire       jtag_state_tlr,\n    input  wire       jtag_state_rti,\n    input  wire       jtag_state_sdrs,\n    input  wire       jtag_state_cdr,\n    input  wire       jtag_state_sdr,\n    input  wire       jtag_state_e1dr,\n    input  wire       jtag_state_pdr,\n    input  wire       jtag_state_e2dr,\n    input  wire       jtag_state_udr,\n    input  wire       jtag_state_sirs,\n    input  wire       jtag_state_cir,\n    input  wire       jtag_state_sir,\n    input  wire       jtag_state_e1ir,\n    input  wire       jtag_state_pir,\n    input  wire       jtag_state_e2ir,\n    input  wire       jtag_state_uir,\n    input  wire [2:0] jtag_ir_in,\n    output wire       jtag_irq,\n    output wire [2:0] jtag_ir_out,\n    input  wire       clk,\n    input  wire       reset_n,\n    input  wire       source_ready,\n    output wire [7:0] source_data,\n    output wire       source_valid,\n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    output wire       resetrequest,\n    output wire       debug_reset,\n    output wire       mgmt_valid,\n    output wire [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output wire       mgmt_data\n);\n\n  \n  wire       tck;\n  wire       tdi;\n  wire       tdo;\n  wire [2:0] ir_in;\n  wire       virtual_state_cdr;\n  wire       virtual_state_sdr;\n  wire       virtual_state_udr;\n\n  assign jtag_irq = 1'b0;\n  assign jtag_ir_out = 3'b000;\n\n  generate\n    if (EXPORT_JTAG == 0) begin\n      \n      altera_jtag_sld_node node (\n        .tck                (tck),\n        .tdi                (tdi),\n        .tdo                (tdo),\n        .ir_out             (1'b0),\n        .ir_in              (ir_in),\n        .virtual_state_cdr  (virtual_state_cdr),\n        .virtual_state_cir  (),\n        .virtual_state_e1dr (),\n        .virtual_state_e2dr (),\n        .virtual_state_pdr  (),\n        .virtual_state_sdr  (virtual_state_sdr),\n        .virtual_state_udr  (virtual_state_udr),\n        .virtual_state_uir  ()\n      );\n\n      assign jtag_tdo = 1'b0;\n    end else begin\n      assign tck = jtag_tck;\n      assign tdi = jtag_tdi;\n      assign jtag_tdo = tdo;\n      assign ir_in = jtag_ir_in;\n      assign virtual_state_cdr = jtag_ena && !jtag_usr1 && jtag_state_cdr;\n      assign virtual_state_sdr = jtag_ena && !jtag_usr1 && jtag_state_sdr;\n      assign virtual_state_udr = jtag_ena && !jtag_usr1 && jtag_state_udr;\n    end\n  endgenerate\n\n  generate \n    if (USE_PLI == 0)\n      begin : normal\n        altera_jtag_dc_streaming #(\n          .PURPOSE(PURPOSE),\n          .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n          .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n          .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n        ) jtag_dc_streaming (\n          .tck              (tck),\n          .tdi              (tdi),\n          .tdo              (tdo),\n          .ir_in            (ir_in),\n          .virtual_state_cdr(virtual_state_cdr),\n          .virtual_state_sdr(virtual_state_sdr),\n          .virtual_state_udr(virtual_state_udr),\n          .clk(clk),\n          .reset_n(reset_n),\n          .source_data(source_data),\n          .source_valid(source_valid),\n          .sink_data(sink_data),\n          .sink_valid(sink_valid),\n          .sink_ready(sink_ready),\n          .resetrequest(resetrequest),\n          .debug_reset(debug_reset),\n          .mgmt_valid(mgmt_valid),\n          .mgmt_channel(mgmt_channel),\n          .mgmt_data(mgmt_data)\n        );\n   \n      end\n    else\n      begin : pli_mode\n\t  \n        \n        reg pli_out_valid;\n        reg pli_in_ready;\n        reg [7 : 0] pli_out_data;\n        \n        always @(posedge clk or negedge reset_n) begin\n          if (!reset_n) begin\n            pli_out_valid <= 0;\n            pli_out_data <= 'b0;\n            pli_in_ready <= 0;\n          end\n          else begin\n            `ifdef MODEL_TECH\n              $do_transaction(\n                PLI_PORT, \n                pli_out_valid, \n                source_ready, \n                pli_out_data,\n                sink_valid,\n                pli_in_ready,\n                sink_data\n              );\n            `endif\n          end\n        end\n\t\t\n\t\t\n        wire [7:0] jtag_source_data;\n        wire jtag_source_valid;\n        wire jtag_sink_ready;\n        wire jtag_resetrequest;\n\t\t\n        altera_jtag_dc_streaming #(\n          .PURPOSE(PURPOSE),\n          .UPSTREAM_FIFO_SIZE(UPSTREAM_FIFO_SIZE),\n          .DOWNSTREAM_FIFO_SIZE(DOWNSTREAM_FIFO_SIZE),\n          .MGMT_CHANNEL_WIDTH(MGMT_CHANNEL_WIDTH)\n        ) jtag_dc_streaming (\n          .tck              (tck),\n          .tdi              (tdi),\n          .tdo              (tdo),\n          .ir_in            (ir_in),\n          .virtual_state_cdr(virtual_state_cdr),\n          .virtual_state_sdr(virtual_state_sdr),\n          .virtual_state_udr(virtual_state_udr),\n          .clk(clk),\n          .reset_n(reset_n),\n          .source_data(jtag_source_data),\n          .source_valid(jtag_source_valid),\n          .sink_data(sink_data),\n          .sink_valid(sink_valid),\n          .sink_ready(jtag_sink_ready),\n          .resetrequest(jtag_resetrequest)\n          \n          \n          \n          \n        );\n       \n          \n          \n          \n          \n          \n          \n\n          \n\t  assign source_valid = pli_out_valid;\n          assign source_data = pli_out_data;\n          assign sink_ready = pli_in_ready;\n          assign resetrequest = 1'b0;\n          \n          assign jtag_tdo = 1'b0;\n      end\n  endgenerate\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_avalon_st_jtag_interface.\nModule specification: The altera_avalon_st_jtag_interface module is designed to integrate JTAG communication capabilities with Altera's Avalon streaming architecture, providing key functionalities and debugging features for embedded systems. Among its input ports, this module includes JTAG signals like `jtag_tck`, `jtag_tms`, `jtag_tdi`, and the enable signal `jtag_ena`, among others specifying various JTAG states (`jtag_state_tlr`, `jtag_state_rti`, etc.) and control signals (`reset_n`, `clk` for synchronization, `source_ready`, and data flow control ports `sink_data`, `sink_valid`). Output ports include `jtag_tdo`, handling JTAG Test Data Output, `source_data`, `source_valid`, and `sink_ready` which manage data streams, and signals like `resetrequest`, `debug_reset`, and management signals (`mgmt_valid`, `mgmt_channel`, `mgmt_data`). Internal signals such as `tck`, `tdi`, `tdo`, and virtual state indicators (`virtual_state_cdr`, `virtual_state_sdr`, `virtual_state_udr`) manage the internal state and data processing based on JTAG operations. The code includes conditional generation blocks. If EXPORT_JTAG is enabled, JTAG-related signals are directly assigned. On the other hand, a PLI-based simulation unit, controlled by USE_PLI, is used for more sophisticated simulation interfacing operations, dictating how data is transmitted or received during simulations. This dual operation mode (normal and PLI simulation) allows flexibility in testing and debugging across different system configurations."
                }
            ]
        }
    ]
}