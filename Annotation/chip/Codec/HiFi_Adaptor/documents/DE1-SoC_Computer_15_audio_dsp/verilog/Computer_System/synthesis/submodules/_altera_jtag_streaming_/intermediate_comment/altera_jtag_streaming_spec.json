{
    "spec": "Module name: altera_jtag_streaming.\nModule specification: The \"altera_jtag_streaming\" module is specifically engineered for handling JTAG data streaming operations within FPGA systems, focusing on data, loopback, debug, management, and control functionalities. It leverages input ports such as `tck` (Test Clock), `tdi` (Test Data In), and `ir_in` (Instruction Register input) for operation specification, along with various status signals like `virtual_state_cdr`, `virtual_state_sdr`, and `virtual_state_udr` to manage states in the JTAG state machine. The module outputs data through ports including `tdo` (Test Data Out) and `source_data` which indicate the processed data stream and its validity. Internally, the module utilizes a range of signals such as `dr_data_in`, `dr_data_out`, and state management flags (`write_state`, `read_state`) to control the data reading and writing processes. Various counters like `bypass_bit_counter` and `write_data_bit_counter` are used to manage data alignment and transitions. Blocks within the code handle synchronization (e.g., `altera_std_synchronizer`), data stream manipulation (e.g., `altera_avalon_st_idle_remover` and `altera_avalon_st_idle_inserter`), and conditional operations based on the JTAG instruction type (`DATA`, `LOOPBACK`, `DEBUG`, `INFO`, `CONTROL`, `MGMT`) to configure or respond to different operational needs. This architecture provides robust control and diagnostics for embedded system debugging and data management in a JTAG environment.\n",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\n\nExplanation: The module \"altera_jtag_streaming\" is designed to handle JTAG data streaming for various operations including data, loopback, debug, info, control, and management (MGMT) contexts within FPGA-based systems. It manages data transactions between upstream and downstream FIFOs (First In First Out memory buffers), transforms and regulates data flows during different JTAG states (like Capture-DR, Shift-DR, Update-DR), and provides debugging interface functionalities. Additionally, it includes processing states via a state machine to read, write, and bypass data based on the IR (Instruction Register) input and the current JTAG state. The module also integrates synchronization of signals between different clock domains and manipulates management channel data when applicable, enabling enhanced control and diagnostics capabilities in embedded system debugging and testing."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n**Input ports:** \n- tck\n- tdi\n- ir_in\n- virtual_state_cdr\n- virtual_state_sdr\n- virtual_state_udr\n- reset_n\n- sink_data\n- sink_valid\n- clock_to_sample\n- reset_to_sample\n\n**Explanation:**\n- **tck:** Test Clock input used for timing the serial data transmission.\n- **tdi:** Test Data In, the serial input stream into the module, forming the primary data input for JTAG operations.\n- **ir_in:** Instruction Register input which specifies the type of operation to perform, such as data streaming, debugging, loopback, etc.\n- **virtual_state_cdr (Capture-DR), virtual_state_sdr (Shift-DR), virtual_state_udr (Update-DR):** These inputs indicate the current state in the JTAG state machine. They help in controlling the flow of data as per the state machine logic.\n- **reset_n:** Active-low reset signal which initializes the state and output registers when asserted.\n- **sink_data:** Incoming data from a downstream source that needs to be processed or transmitted.\n- **sink_valid:** Flag to indicate that the sink_data is valid and ready to be processed.\n- **clock_to_sample:** Clock signal used for sampling and processing the incoming data.\n- **reset_to_sample:** Reset signal for resetting the sample handling logic.\n\n**Output ports:**\n- tdo\n- source_data\n- source_valid\n- sink_ready\n- resetrequest\n- debug_reset\n- mgmt_valid\n- mgmt_channel\n- mgmt_data\n\n**Explanation:**\n- **tdo:** Test Data Out, the serial data output stream of the module, conveying the results of the performed JTAG operations.\n- **source_data:** The processed data intended to be sent upstream.\n- **source_valid:** A flag indicating that source_data is valid and ready to be sent out.\n- **sink_ready:** A signal indicating that the module is ready to receive new sink_data.\n- **resetrequest:** Flag to request a system reset based on control operations or error conditions detected during data processing.\n- **debug_reset:** Signal used to reset debugging state machines or debugging sessions.\n- **mgmt_valid:** Asserted when management data is valid and should be considered by external systems.\n- **mgmt_channel:** Denotes which management channel is active or being referenced in the current context.\n- **mgmt_data:** Management specific data, used for configuration or control purposes in the management context."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n**Internal signals:**\n- write_state, read_state\n- dr_data_in, dr_data_out, dr_loopback, dr_debug, dr_info, dr_control, dr_mgmt\n- padded_bit_counter, bypass_bit_counter, write_data_bit_counter, read_data_bit_counter, header_in_bit_counter, header_out_bit_counter, scan_length_byte_counter, valid_write_data_length_byte_counter\n- write_data_valid, read_data_valid, read_data_all_valid\n- decode_header_1, decode_header_2\n- write_data_byte_aligned, read_data_byte_aligned, padded_bit_byte_aligned, bytestream_end\n- offset, header_in\n- scan_length, read_data_length, write_data_length\n- idle_inserter_sink_data, idle_inserter_sink_valid, idle_inserter_sink_ready, idle_inserter_source_data\n- idle_remover_sink_data, idle_remover_sink_valid, idle_remover_source_data, idle_remover_source_valid\n- clock_sensor, clock_to_sample_div2, clock_sense_reset_n\n- data_available\n- decoded_scan_length, decoded_write_data_length, decoded_read_data_length\n- clock_sensor_sync, reset_to_sample_sync, clock_to_sample_div2_sync, clock_sense_reset_n_sync\n- mgmt_out, mgmt_toggle, mgmt_toggle_sync, mgmt_toggle_prev\n\n**Explanation:**\n- **write_state, read_state:** Finite state machine registers for managing write and read operations respectively.\n- **dr_data_in, dr_data_out:** Registers to temporarily store data being shifted in and out during JTAG operations.\n- **dr_loopback:** Used to mirror data inputs directly to outputs in loopback test mode.\n- **dr_debug, dr_info, dr_control, dr_mgmt:** Registers to hold and manipulate data specific to debugging, informational, control, and management operations.\n- **padded_bit_counter, bypass_bit_counter, ... , valid_write_data_length_byte_counter:** Counters for maintaining and managing lengths and amounts of bits processed in various modes and states.\n- **write_data_valid, read_data_valid, read_data_all_valid:** Flags indicating the validity of data being written and read.\n- **decode_header_1, decode_header_2:** Flags used for controlling the flow of header decoding.\n- **write_data_byte_aligned, ... , bytestream_end:** These signals aid in proper data alignment and detection of data stream boundaries.\n- **offset, header_in:** Used for storing data offsets and part of the incoming data header being processed.\n- **scan_length, read_data_length, write_data_length:** Registers holding length values for scanning, reading, and writing data operations.\n- **idle_inserter_sink_data, ... , idle_inserter_source_data:** Data and control signals associated with managing idle data insertion.\n- **idle_remover_sink_data, ... , idle_remover_source_valid:** Data and control signals associated with removing idle data from the stream.\n- **clock_sensor, clock_to_sample_div2, clock_sense_reset_n:** Clock-related signals used for timing and reset purposes.\n- **data_available:** A signal indicating the availability of data in the sink.\n- **decoded_scan_length, ... , decoded_read_data_length:** Derived length values used in various operations within the module.\n- **clock_sensor_sync, ... , clock_sense_reset_n_sync:** Synchronized versions of clock and reset signals for stable operation across different clock domains.\n- **mgmt_out, mgmt_toggle, mgmt_toggle_sync, mgmt_toggle_prev:** Management specific toggling and data output signals used for managing and synchronizing outputs related to the management channels."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming #(\n    parameter PURPOSE = 0,\n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1\n) (\n    \n    input  wire       tck,\n    input  wire       tdi,\n    output reg        tdo,\n    input  wire [2:0] ir_in,\n    input  wire       virtual_state_cdr,\n    input  wire       virtual_state_sdr,\n    input  wire       virtual_state_udr,\n    \n    input  wire       reset_n,\n    \n    output wire [7:0] source_data,\n    output wire       source_valid,\n    \n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    \n    input  wire       clock_to_sample,\n    input  wire       reset_to_sample,\n    \n    output reg        resetrequest,\n    \n    output wire       debug_reset,\n    output reg        mgmt_valid,\n    output reg  [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output reg        mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n    localparam TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n    localparam SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (virtual_state_cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (virtual_state_sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (virtual_state_cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (virtual_state_sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (virtual_state_cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (virtual_state_sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (virtual_state_cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (virtual_state_sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (virtual_state_udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (virtual_state_cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (virtual_state_sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (virtual_state_cdr) begin\n                dr_control <= 'b0; \n            end\n            if (virtual_state_sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (virtual_state_udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (virtual_state_sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (virtual_state_cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (virtual_state_sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (virtual_state_udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_jtag_streaming.\nModule specification: The \"altera_jtag_streaming\" module is specifically engineered for handling JTAG data streaming operations within FPGA systems, focusing on data, loopback, debug, management, and control functionalities. It leverages input ports such as `tck` (Test Clock), `tdi` (Test Data In), and `ir_in` (Instruction Register input) for operation specification, along with various status signals like `virtual_state_cdr`, `virtual_state_sdr`, and `virtual_state_udr` to manage states in the JTAG state machine. The module outputs data through ports including `tdo` (Test Data Out) and `source_data` which indicate the processed data stream and its validity. Internally, the module utilizes a range of signals such as `dr_data_in`, `dr_data_out`, and state management flags (`write_state`, `read_state`) to control the data reading and writing processes. Various counters like `bypass_bit_counter` and `write_data_bit_counter` are used to manage data alignment and transitions. Blocks within the code handle synchronization (e.g., `altera_std_synchronizer`), data stream manipulation (e.g., `altera_avalon_st_idle_remover` and `altera_avalon_st_idle_inserter`), and conditional operations based on the JTAG instruction type (`DATA`, `LOOPBACK`, `DEBUG`, `INFO`, `CONTROL`, `MGMT`) to configure or respond to different operational needs. This architecture provides robust control and diagnostics for embedded system debugging and data management in a JTAG environment.\n"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_jtag_streaming.\n\nExplanation: The module \"altera_jtag_streaming\" is designed to handle JTAG data streaming for various operations including data, loopback, debug, info, control, and management (MGMT) contexts within FPGA-based systems. It manages data transactions between upstream and downstream FIFOs (First In First Out memory buffers), transforms and regulates data flows during different JTAG states (like Capture-DR, Shift-DR, Update-DR), and provides debugging interface functionalities. Additionally, it includes processing states via a state machine to read, write, and bypass data based on the IR (Instruction Register) input and the current JTAG state. The module also integrates synchronization of signals between different clock domains and manipulates management channel data when applicable, enabling enhanced control and diagnostics capabilities in embedded system debugging and testing."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n**Input ports:** \n- tck\n- tdi\n- ir_in\n- virtual_state_cdr\n- virtual_state_sdr\n- virtual_state_udr\n- reset_n\n- sink_data\n- sink_valid\n- clock_to_sample\n- reset_to_sample\n\n**Explanation:**\n- **tck:** Test Clock input used for timing the serial data transmission.\n- **tdi:** Test Data In, the serial input stream into the module, forming the primary data input for JTAG operations.\n- **ir_in:** Instruction Register input which specifies the type of operation to perform, such as data streaming, debugging, loopback, etc.\n- **virtual_state_cdr (Capture-DR), virtual_state_sdr (Shift-DR), virtual_state_udr (Update-DR):** These inputs indicate the current state in the JTAG state machine. They help in controlling the flow of data as per the state machine logic.\n- **reset_n:** Active-low reset signal which initializes the state and output registers when asserted.\n- **sink_data:** Incoming data from a downstream source that needs to be processed or transmitted.\n- **sink_valid:** Flag to indicate that the sink_data is valid and ready to be processed.\n- **clock_to_sample:** Clock signal used for sampling and processing the incoming data.\n- **reset_to_sample:** Reset signal for resetting the sample handling logic.\n\n**Output ports:**\n- tdo\n- source_data\n- source_valid\n- sink_ready\n- resetrequest\n- debug_reset\n- mgmt_valid\n- mgmt_channel\n- mgmt_data\n\n**Explanation:**\n- **tdo:** Test Data Out, the serial data output stream of the module, conveying the results of the performed JTAG operations.\n- **source_data:** The processed data intended to be sent upstream.\n- **source_valid:** A flag indicating that source_data is valid and ready to be sent out.\n- **sink_ready:** A signal indicating that the module is ready to receive new sink_data.\n- **resetrequest:** Flag to request a system reset based on control operations or error conditions detected during data processing.\n- **debug_reset:** Signal used to reset debugging state machines or debugging sessions.\n- **mgmt_valid:** Asserted when management data is valid and should be considered by external systems.\n- **mgmt_channel:** Denotes which management channel is active or being referenced in the current context.\n- **mgmt_data:** Management specific data, used for configuration or control purposes in the management context."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n**Internal signals:**\n- write_state, read_state\n- dr_data_in, dr_data_out, dr_loopback, dr_debug, dr_info, dr_control, dr_mgmt\n- padded_bit_counter, bypass_bit_counter, write_data_bit_counter, read_data_bit_counter, header_in_bit_counter, header_out_bit_counter, scan_length_byte_counter, valid_write_data_length_byte_counter\n- write_data_valid, read_data_valid, read_data_all_valid\n- decode_header_1, decode_header_2\n- write_data_byte_aligned, read_data_byte_aligned, padded_bit_byte_aligned, bytestream_end\n- offset, header_in\n- scan_length, read_data_length, write_data_length\n- idle_inserter_sink_data, idle_inserter_sink_valid, idle_inserter_sink_ready, idle_inserter_source_data\n- idle_remover_sink_data, idle_remover_sink_valid, idle_remover_source_data, idle_remover_source_valid\n- clock_sensor, clock_to_sample_div2, clock_sense_reset_n\n- data_available\n- decoded_scan_length, decoded_write_data_length, decoded_read_data_length\n- clock_sensor_sync, reset_to_sample_sync, clock_to_sample_div2_sync, clock_sense_reset_n_sync\n- mgmt_out, mgmt_toggle, mgmt_toggle_sync, mgmt_toggle_prev\n\n**Explanation:**\n- **write_state, read_state:** Finite state machine registers for managing write and read operations respectively.\n- **dr_data_in, dr_data_out:** Registers to temporarily store data being shifted in and out during JTAG operations.\n- **dr_loopback:** Used to mirror data inputs directly to outputs in loopback test mode.\n- **dr_debug, dr_info, dr_control, dr_mgmt:** Registers to hold and manipulate data specific to debugging, informational, control, and management operations.\n- **padded_bit_counter, bypass_bit_counter, ... , valid_write_data_length_byte_counter:** Counters for maintaining and managing lengths and amounts of bits processed in various modes and states.\n- **write_data_valid, read_data_valid, read_data_all_valid:** Flags indicating the validity of data being written and read.\n- **decode_header_1, decode_header_2:** Flags used for controlling the flow of header decoding.\n- **write_data_byte_aligned, ... , bytestream_end:** These signals aid in proper data alignment and detection of data stream boundaries.\n- **offset, header_in:** Used for storing data offsets and part of the incoming data header being processed.\n- **scan_length, read_data_length, write_data_length:** Registers holding length values for scanning, reading, and writing data operations.\n- **idle_inserter_sink_data, ... , idle_inserter_source_data:** Data and control signals associated with managing idle data insertion.\n- **idle_remover_sink_data, ... , idle_remover_source_valid:** Data and control signals associated with removing idle data from the stream.\n- **clock_sensor, clock_to_sample_div2, clock_sense_reset_n:** Clock-related signals used for timing and reset purposes.\n- **data_available:** A signal indicating the availability of data in the sink.\n- **decoded_scan_length, ... , decoded_read_data_length:** Derived length values used in various operations within the module.\n- **clock_sensor_sync, ... , clock_sense_reset_n_sync:** Synchronized versions of clock and reset signals for stable operation across different clock domains.\n- **mgmt_out, mgmt_toggle, mgmt_toggle_sync, mgmt_toggle_prev:** Management specific toggling and data output signals used for managing and synchronizing outputs related to the management channels."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\n\nmodule altera_jtag_streaming #(\n    parameter PURPOSE = 0,\n    parameter UPSTREAM_FIFO_SIZE = 0,\n    parameter DOWNSTREAM_FIFO_SIZE = 0,\n    parameter MGMT_CHANNEL_WIDTH = -1\n) (\n    \n    input  wire       tck,\n    input  wire       tdi,\n    output reg        tdo,\n    input  wire [2:0] ir_in,\n    input  wire       virtual_state_cdr,\n    input  wire       virtual_state_sdr,\n    input  wire       virtual_state_udr,\n    \n    input  wire       reset_n,\n    \n    output wire [7:0] source_data,\n    output wire       source_valid,\n    \n    input  wire [7:0] sink_data,\n    input  wire       sink_valid,\n    output wire       sink_ready,\n    \n    input  wire       clock_to_sample,\n    input  wire       reset_to_sample,\n    \n    output reg        resetrequest,\n    \n    output wire       debug_reset,\n    output reg        mgmt_valid,\n    output reg  [(MGMT_CHANNEL_WIDTH>0?MGMT_CHANNEL_WIDTH:1)-1:0] mgmt_channel,\n    output reg        mgmt_data\n);\n\n    \n    function integer flog2;\n      input [31:0] Depth;\n      integer i;\n      begin\n        i = Depth;\n        if ( i <= 0 ) flog2 = 0;\n        else begin\n          for(flog2 = -1; i > 0; flog2 = flog2 + 1)\n          i = i >> 1;\n        end\n      end    \n    endfunction \n\n    localparam UPSTREAM_ENCODED_SIZE = flog2(UPSTREAM_FIFO_SIZE);\n    localparam DOWNSTREAM_ENCODED_SIZE = flog2(DOWNSTREAM_FIFO_SIZE);\n\n    localparam TCK_TO_SYSCLK_SYNC_DEPTH = 8;\n    localparam SYSCLK_TO_TCK_SYNC_DEPTH = 3;\n\n    \n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    \n    \n    \n    \n    \n    \n    \n\n    localparam IRWIDTH = 3;\n\t\n    \n    localparam ST_BYPASS     = 'h0;\n    localparam ST_HEADER_1   = 'h1;\n    localparam ST_HEADER_2   = 'h2;\n    localparam ST_WRITE_DATA = 'h3;\n\n    \n    localparam ST_HEADER    = 'h0;\n    localparam ST_PADDED    = 'h1;\n    localparam ST_READ_DATA = 'h2;\n\n    reg [1:0] write_state = ST_BYPASS;\n    reg [1:0] read_state  = ST_HEADER;\n\n    reg [ 7:0] dr_data_in  = 'b0;\n    reg [ 7:0] dr_data_out = 'b0;\n    reg        dr_loopback = 'b0;\n    reg [ 2:0] dr_debug    = 'b0;\n    reg [10:0] dr_info     = 'b0;\n    reg [ 8:0] dr_control  = 'b0;\n    reg [MGMT_CHANNEL_WIDTH+2:0] dr_mgmt = 'b0;\n\n    reg [ 8:0] padded_bit_counter             = 'b0;\n    reg [ 7:0] bypass_bit_counter             = 'b0;\n    reg [ 2:0] write_data_bit_counter         = 'b0;\n    reg [ 2:0] read_data_bit_counter          = 'b0;\n    reg [ 3:0] header_in_bit_counter          = 'b0;\n    reg [ 3:0] header_out_bit_counter         = 'b0;\n    reg [18:0] scan_length_byte_counter       = 'b0;\n    reg [18:0] valid_write_data_length_byte_counter  = 'b0;\n\n    reg write_data_valid     = 'b0;\n    reg read_data_valid      = 'b0;\n    reg read_data_all_valid  = 'b0;\n\n    reg decode_header_1 = 'b0;\n    reg decode_header_2 = 'b0;\n\n    wire write_data_byte_aligned;\n    wire read_data_byte_aligned;\n    wire padded_bit_byte_aligned;\n    wire bytestream_end;\n\n    assign write_data_byte_aligned = (write_data_bit_counter == 1);\n    assign read_data_byte_aligned  = (read_data_bit_counter == 1);\n    assign padded_bit_byte_aligned = (padded_bit_counter[2:0] == 'b0);\n    assign bytestream_end          = (scan_length_byte_counter == 'b0);\n\n    reg [ 7:0] offset     = 'b0;\n    reg [15:0] header_in  = 'b0;\n\n    reg [9:0] scan_length       = 'b0;\n    reg [2:0] read_data_length  = 'b0;\n    reg [2:0] write_data_length = 'b0;\n\n    wire [7:0] idle_inserter_sink_data;\n    wire       idle_inserter_sink_valid;\n    wire       idle_inserter_sink_ready;\n    wire [7:0] idle_inserter_source_data;\n    reg        idle_inserter_source_ready = 'b0;\n    reg  [7:0] idle_remover_sink_data     = 'b0;\n    reg        idle_remover_sink_valid    = 'b0;\n    wire [7:0] idle_remover_source_data;\n    wire       idle_remover_source_valid;\n\n    assign source_data  = idle_remover_source_data;\n    assign source_valid = idle_remover_source_valid;\n    assign sink_ready   = idle_inserter_sink_ready;\n    assign idle_inserter_sink_data  = sink_data;\n    assign idle_inserter_sink_valid = sink_valid;\n\n    reg clock_sensor         = 'b0;\n    reg clock_to_sample_div2 = 'b0;\n    (* altera_attribute = {\"-name GLOBAL_SIGNAL OFF\"}*) reg clock_sense_reset_n  = 'b1;\n\n    wire data_available;\n\n    assign data_available = sink_valid;\n\n    wire [18:0] decoded_scan_length;\n    wire [18:0] decoded_write_data_length;\n    wire [18:0] decoded_read_data_length;\n\n    assign decoded_scan_length =  { scan_length, {8{1'b1}} };\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    assign decoded_write_data_length = (write_data_length == 0) ? 19'h0 : (19'h00080 << write_data_length);\n    assign decoded_read_data_length  = (read_data_length == 0)  ? 19'h0 : (19'h00080 << read_data_length);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    wire clock_sensor_sync;\n    wire reset_to_sample_sync;\n    wire clock_to_sample_div2_sync;\n    wire clock_sense_reset_n_sync;\n\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_sensor_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_sensor),\n        .dout(clock_sensor_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) reset_to_sample_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(reset_to_sample),\n        .dout(reset_to_sample_sync));\n\n    altera_std_synchronizer #(.depth(SYSCLK_TO_TCK_SYNC_DEPTH)) clock_to_sample_div2_synchronizer (\n        .clk(tck),\n        .reset_n(1'b1),\n        .din(clock_to_sample_div2),\n        .dout(clock_to_sample_div2_sync));\n\n    altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) clock_sense_reset_n_synchronizer (\n        .clk(clock_to_sample),\n        .reset_n(clock_sense_reset_n),\n        .din(1'b1),\n        .dout(clock_sense_reset_n_sync));\n\n    always @ (posedge clock_to_sample or negedge clock_sense_reset_n_sync) begin\n        if (~clock_sense_reset_n_sync) begin\n            clock_sensor <= 1'b0;\n        end else begin\n            clock_sensor <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock_to_sample) begin\n        clock_to_sample_div2 <= ~clock_to_sample_div2;\n    end\n\n    always @ (posedge tck) begin\n\n        idle_remover_sink_valid <= 1'b0;\n        idle_inserter_source_ready <= 1'b0;\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n\n            if (virtual_state_cdr) begin\n                if (offset == 'b0) begin\n                    write_state <= ST_HEADER_1;\n                end else begin\n                    write_state <= ST_BYPASS;\n                end\n                \n                bypass_bit_counter <= offset;\n                \n                header_in_bit_counter <= 15;\n                \n                write_data_bit_counter <= 0;\n                \n                \n                decode_header_1 <= 1'b0;\n                decode_header_2 <= 1'b0;\n                read_data_all_valid  <= 1'b0;\n                valid_write_data_length_byte_counter  <= 0;\n            end\n\n            if (virtual_state_sdr) begin\n                \n                \n                \n                \n                \n                \n\n                case (write_state)\n                    ST_BYPASS: begin\n                        \n                        bypass_bit_counter <= bypass_bit_counter - 1'b1;\n                        if (bypass_bit_counter == 1) begin\n                            write_state <= ST_HEADER_1;\n                        end\n                    end\n                    \n                    ST_HEADER_1: begin\n                        \n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        if (header_in_bit_counter == 3) begin\n                            read_data_length  <= {tdi, header_in[15:14]};\n                            scan_length       <= header_in[13:4];\n                            write_state <= ST_HEADER_2;\n                            decode_header_1 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_HEADER_2: begin\n                        \n                        header_in <= {tdi, header_in[15:1]};\n                        header_in_bit_counter <= header_in_bit_counter - 1'b1;\n                        \n                        if (decode_header_1) begin\n                            decode_header_1 <= 1'b0;\n                            \n                            if (read_data_length == 3'b111) begin\n                                read_data_all_valid <= 1'b1;\n                            end\n                            \n                            scan_length_byte_counter <= decoded_scan_length;\n                        end\n                        if (header_in_bit_counter == 0) begin\n                            write_data_length <= {tdi, header_in[15:14]};\n                            write_state <= ST_WRITE_DATA;\n                            decode_header_2 <= 1'b1;\n                        end\n                    end\n                    \n                    ST_WRITE_DATA: begin\n                        \n                        dr_data_in <= {tdi, dr_data_in[7:1]};\n                        \n                        if (decode_header_2) begin\n                            decode_header_2 <= 1'b0;\n                            \n                            case (write_data_length)\n                                3'b111:  valid_write_data_length_byte_counter <= decoded_scan_length + 1'b1;\n                                3'b000:  valid_write_data_length_byte_counter <= 'b0;\n                                default: valid_write_data_length_byte_counter <= decoded_write_data_length;\n                            endcase\n                        end\n                        write_data_bit_counter <= write_data_bit_counter - 1'b1;\n                        write_data_valid <= (valid_write_data_length_byte_counter != 0);\n                        \n                        if (write_data_byte_aligned && write_data_valid) begin\n                            valid_write_data_length_byte_counter <= valid_write_data_length_byte_counter - 1'b1;\n                            idle_remover_sink_valid <= 1'b1;\n                            idle_remover_sink_data <= {tdi, dr_data_in[7:1]};\n                        end\n                    end\n                endcase\n            end\n\n        end\n\n        \n\n        \n        \n        \n        \n        \n        \n        if (ir_in == DATA) begin\n\n            if (virtual_state_cdr) begin\n\n                read_state <= ST_HEADER;\n                \n                \n                if (|offset[2:0]) begin\n                    padded_bit_counter[8:3] <= offset[7:3] + 1'b1;\n                    padded_bit_counter[2:0] <= 3'b0;\n                end else begin\n                    padded_bit_counter <= {1'b0, offset};\n                end\n                \n                header_out_bit_counter <= 0;\n                \n                read_data_bit_counter <= 0;\n                \n                dr_data_out <= {{7{1'b0}}, data_available};\n                read_data_valid <= 0;\n\n            end\n\n            if (virtual_state_sdr) begin\n                \n                \n                \n                \n                \n\n                dr_data_out <= {1'b0, dr_data_out[7:1]};\n                case (read_state)\n                    \n                    ST_HEADER: begin\n                        header_out_bit_counter <= header_out_bit_counter - 1'b1;\n                        \n                        if (header_out_bit_counter == 2) begin\n                            if (padded_bit_counter == 0) begin\n                                idle_inserter_source_ready <= read_data_all_valid;\n                            end\n                        end\n                        if (header_out_bit_counter == 1) begin\n                            if (padded_bit_counter == 0) begin\n                                read_state <= ST_READ_DATA;\n                                read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                                dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                            end else begin\n                                read_state <= ST_PADDED;\n                                padded_bit_counter <= padded_bit_counter - 1'b1;\n                                idle_inserter_source_ready <= 1'b0;\n                                dr_data_out <= 8'h4a;\n                            end\n                        end\n                    end\n                    ST_PADDED: begin\n                        padded_bit_counter <= padded_bit_counter - 1'b1;\n                        if (padded_bit_byte_aligned) begin\n                            \n                            dr_data_out <= 8'h4a;\n                        end\n                        \n                        if (padded_bit_counter == 1) begin\n                            idle_inserter_source_ready <= read_data_all_valid;\n                        end\n                        if (padded_bit_counter == 0) begin \n                            read_state <= ST_READ_DATA;\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            dr_data_out <= read_data_all_valid ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                    ST_READ_DATA: begin\n                        read_data_bit_counter <= read_data_bit_counter - 1'b1;\n                        \n                        if (read_data_bit_counter == 2) begin\n                            \n                            \n                            idle_inserter_source_ready <= bytestream_end ? 1'b0 : read_data_valid;\n                        end\n                        if (read_data_byte_aligned) begin\n                            \n                            if (~bytestream_end) begin\n                                scan_length_byte_counter <= scan_length_byte_counter - 1'b1;\n                            end\n                            read_data_valid <= read_data_all_valid || (scan_length_byte_counter<=decoded_read_data_length+1);\n                            \n                            dr_data_out <= (read_data_valid & ~bytestream_end) ? idle_inserter_source_data : 8'h4a;\n                        end\n                    end\n                endcase\n\n            end\n\n        end\n\n        \n        if (ir_in == LOOPBACK) begin\n            if (virtual_state_cdr) begin\n                dr_loopback <= 1'b0; \n            end\n            if (virtual_state_sdr) begin\n                \n                dr_loopback <= tdi;\n            end\n        end\n\n        \n        if (ir_in == DEBUG) begin\n            if (virtual_state_cdr) begin\n                dr_debug <= {clock_sensor_sync, clock_to_sample_div2_sync, reset_to_sample_sync};\n            end\n            if (virtual_state_sdr) begin\n                \n                dr_debug <= {1'b0, dr_debug[2:1]}; \n            end\n            if (virtual_state_udr) begin\n                clock_sense_reset_n <= 1'b0;\n            end else begin\n                clock_sense_reset_n <= 1'b1;\n            end\n        end\n\n        \n        if (ir_in == INFO) begin\n            if (virtual_state_cdr) begin\n                dr_info <= {PURPOSE[2:0], UPSTREAM_ENCODED_SIZE[3:0], DOWNSTREAM_ENCODED_SIZE[3:0]};\n            end\n            if (virtual_state_sdr) begin\n                \n                dr_info <= {1'b0, dr_info[10:1]}; \n            end\n        end\n\n        \n        if (ir_in == CONTROL) begin\n            if (virtual_state_cdr) begin\n                dr_control <= 'b0; \n            end\n            if (virtual_state_sdr) begin\n                \n                dr_control <= {tdi, dr_control[8:1]};\n            end\n            if (virtual_state_udr) begin\n                \n                {resetrequest, offset} <= dr_control;\n            end\n        end\n\n    end\n\n    always @ * begin\n        if (virtual_state_sdr) begin\n            case (ir_in)\n                DATA:     tdo <= dr_data_out[0];\n                LOOPBACK: tdo <= dr_loopback;\n                DEBUG:    tdo <= dr_debug[0];\n                INFO:     tdo <= dr_info[0];\n                CONTROL:  tdo <= dr_control[0];\n                MGMT:     tdo <= dr_mgmt[0];\n                default:  tdo <= 1'b0;\n            endcase\n        end else begin\n            tdo <= 1'b0;\n        end\n    end\n\n    \n    altera_avalon_st_idle_remover idle_remover (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (), \n        .in_valid (idle_remover_sink_valid),\n        .in_data  (idle_remover_sink_data),\n\n        \n        .out_ready (1'b1), \n        .out_valid (idle_remover_source_valid),\n        .out_data  (idle_remover_source_data)\n    );\n\n    \n    altera_avalon_st_idle_inserter idle_inserter (\n        \n        .clk     (tck),\n        .reset_n (reset_n),\n\n        \n        .in_ready (idle_inserter_sink_ready),\n        .in_valid (idle_inserter_sink_valid),\n        .in_data  (idle_inserter_sink_data),\n\n        \n        .out_ready (idle_inserter_source_ready),\n        .out_valid (),\n        .out_data  (idle_inserter_source_data)\n    );\n\n   generate \n    if (MGMT_CHANNEL_WIDTH > 0)\n      begin : has_mgmt\n        reg [MGMT_CHANNEL_WIDTH+2:0] mgmt_out = 'b0;\n        reg mgmt_toggle = 1'b0;\n        wire mgmt_toggle_sync;\n        reg mgmt_toggle_prev;\n        always @ (posedge tck) begin\n            \n            if (ir_in == MGMT) begin\n                if (virtual_state_cdr) begin\n                    dr_mgmt <= 'b0;\n                    dr_mgmt[MGMT_CHANNEL_WIDTH+2] <= 1'b1;\n                end\n                if (virtual_state_sdr) begin\n                    \n                    dr_mgmt <= {tdi, dr_mgmt[MGMT_CHANNEL_WIDTH+2:1]};\n                end\n                if (virtual_state_udr) begin\n                    mgmt_out <= dr_mgmt;\n                    mgmt_toggle <= mgmt_out[MGMT_CHANNEL_WIDTH+2] ? 1'b0 : ~mgmt_toggle;\n                end\n            end\n        end\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) debug_reset_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_out[MGMT_CHANNEL_WIDTH+2]),\n            .dout(debug_reset));\n\n        altera_std_synchronizer #(.depth(TCK_TO_SYSCLK_SYNC_DEPTH)) mgmt_toggle_synchronizer (\n            .clk(clock_to_sample),\n            .reset_n(1'b1),\n            .din(mgmt_toggle),\n            .dout(mgmt_toggle_sync));\n\n        always @ (posedge clock_to_sample or posedge debug_reset) begin\n            if (debug_reset) begin\n                mgmt_valid <= 1'b0;\n                mgmt_toggle_prev <= 1'b0;\n            end else begin\n                if ((mgmt_toggle_sync ^ mgmt_toggle_prev) && mgmt_out[MGMT_CHANNEL_WIDTH+1]) begin\n                    mgmt_valid <= 1'b1;\n                    mgmt_channel <= mgmt_out[MGMT_CHANNEL_WIDTH:1];\n                    mgmt_data <= mgmt_out[0];\n                end else begin\n                    mgmt_valid <= 1'b0;\n                end\n                mgmt_toggle_prev <= mgmt_toggle_sync;\n            end\n        end\n        \n      end\n    else\n      begin : no_mgmt\n          always @ (posedge tck) begin\n              dr_mgmt[0] <= 1'b0;\n          end\n          assign debug_reset = 1'b0;\n          always @ (posedge clock_to_sample) begin\n              mgmt_valid <= 1'b0;\n              mgmt_data <= 'b0;\n              mgmt_channel <= 'b0;\n          end\n      end\n   endgenerate \n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_jtag_streaming.\nModule specification: The \"altera_jtag_streaming\" module is specifically engineered for handling JTAG data streaming operations within FPGA systems, focusing on data, loopback, debug, management, and control functionalities. It leverages input ports such as `tck` (Test Clock), `tdi` (Test Data In), and `ir_in` (Instruction Register input) for operation specification, along with various status signals like `virtual_state_cdr`, `virtual_state_sdr`, and `virtual_state_udr` to manage states in the JTAG state machine. The module outputs data through ports including `tdo` (Test Data Out) and `source_data` which indicate the processed data stream and its validity. Internally, the module utilizes a range of signals such as `dr_data_in`, `dr_data_out`, and state management flags (`write_state`, `read_state`) to control the data reading and writing processes. Various counters like `bypass_bit_counter` and `write_data_bit_counter` are used to manage data alignment and transitions. Blocks within the code handle synchronization (e.g., `altera_std_synchronizer`), data stream manipulation (e.g., `altera_avalon_st_idle_remover` and `altera_avalon_st_idle_inserter`), and conditional operations based on the JTAG instruction type (`DATA`, `LOOPBACK`, `DEBUG`, `INFO`, `CONTROL`, `MGMT`) to configure or respond to different operational needs. This architecture provides robust control and diagnostics for embedded system debugging and data management in a JTAG environment.\n"
                }
            ]
        }
    ]
}