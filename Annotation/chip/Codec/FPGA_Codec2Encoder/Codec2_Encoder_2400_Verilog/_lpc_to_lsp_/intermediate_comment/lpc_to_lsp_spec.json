{
    "spec": "Module name: lpc_to_lsp. Module specification: This module implements a Linear Predictive Coding (LPC) to Line Spectral Pairs (LSP) conversion algorithm. It takes LPC coefficients as input and converts them to LSP frequencies. The module has input ports for start signal (startltl), clock (clk), reset (rst), LPC coefficients (ak_out, ak_0 to ak_10), and output ports for LSP frequencies (freq0 to freq9), done signal (doneltl), address for accessing LPC coefficients (ak_addr), and intermediate calculation results (c_psum, c_sig). Internally, it uses various signals for state management, counters, polynomial coefficients, and intermediate calculations. The module is structured with a finite state machine controlling the conversion process, which includes initializing variables, calculating polynomial coefficients, finding roots of polynomials,",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: lpc_to_lsp\n\nExplanation: This module appears to implement a Linear Predictive Coding (LPC) to Line Spectral Pairs (LSP) conversion algorithm. It takes LPC coefficients as input and converts them to LSP frequencies. The module uses a state machine to control the conversion process, which includes initializing variables, calculating polynomial coefficients, finding roots of polynomials, and converting the roots to frequencies using an arccosine function. The module also includes various arithmetic operations and uses sub-modules for specific calculations like Chebyshev polynomial evaluation and arccosine computation. The final output consists of 10 LSP frequencies."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nstartltl, clk, rst, ak_out, ak_0, ak_1, ak_2, ak_3, ak_4, ak_5, ak_6, ak_7, ak_8, ak_9, ak_10\n\nExplanation:\n- startltl: Start signal for the LPC to LSP conversion process\n- clk: Clock input for synchronous operations\n- rst: Reset signal for initializing the module\n- ak_out: LPC coefficient input from RAM\n- ak_0 to ak_10: Individual LPC coefficient inputs\n\nOutput ports:\nfreq0, freq1, freq2, freq3, freq4, freq5, freq6, freq7, freq8, freq9, doneltl, ak_addr, c_psum, c_sig\n\nExplanation:\n- freq0 to freq9: Output LSP frequencies\n- doneltl: Signal indicating completion of the conversion process\n- ak_addr: Address for accessing LPC coefficients from RAM\n- c_psum, c_sig: Intermediate calculation results (likely for debugging or monitoring)"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nSTATE, NEXT_STATE, j, k, i, roots, ak0-ak10, psumr, psum1, psumm, xr, x1, p0-p5, q0-q5, coeff0-coeff5, flag, check_roots, count, xm, ac, startcp1, startcp2, startcp3, startacosf, a1_in1, a1_in2, a2_in1, a2_in2, a3_in1, a3_in2, a4_in1, a4_in2, x_1, x_2, x_3, value, gt1_in1, gt1_in2, temp_psumr, temp_xr.\n\nExplanation:\n- STATE, NEXT_STATE: Current and next state of the FSM controlling the module's operation\n- j, k, i, roots: Counters and indexes for various loops and operations\n- ak0-ak10: Internal storage for LPC coefficients\n- psumr, psum1, psumm: Intermediate sum values used in root-finding process\n- xr, x1: Variables used in the root-finding algorithm\n- p0-p5, q0-q5: Coefficients of polynomials used in the LSP conversion\n- coeff0-coeff5: Coefficients used in Chebyshev polynomial evaluation\n- flag: Control flag for the while loop in root-finding\n- check_roots, count: Variables for tracking the root-finding process\n- xm: Intermediate value in root bisection method\n- ac: Counter for arccosine calculation loop\n- startcp1, startcp2, startcp3, startacosf: Start signals for sub-modules\n- a1_in1, a1_in2, a2_in1, a2_in2, a3_in1, a3_in2, a4_in1, a4_in2: Inputs for arithmetic operations\n- x_1, x_2, x_3: Inputs for Chebyshev polynomial evaluation\n- value: Input value for arccosine calculation\n- gt1_in1, gt1_in2: Inputs for comparison operations\n- temp_psumr, temp_xr: Temporary storage for intermediate values"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule lpc_to_lsp (startltl,clk,rst,ak_out,\n\t\t\t\tak_0,ak_1,ak_2,ak_3,ak_4,ak_5,ak_6,ak_7,ak_8,ak_9,ak_10,\n\t\t\t\tfreq0,freq1,freq2,freq3,freq4,freq5,freq6,freq7,freq8,freq9,\n\t\t\t\t\t\t ak_addr,\n\t\t\t\t\t\n\t\t\t\t\t\t doneltl,\n\t\t\t\t\t\t c_psum,c_sig\n\t\t\t\t\t\t \n\t\t\t\t\t\t );\n\n\n\n\n\n\n\n\tparameter N = 32;\n\tparameter Q = 16;\n\t\n\tparameter Q1 = 24;\n\t\n\tinput startltl,clk,rst;\n\tinput [N-1:0] ak_out;\n\t\n\toutput reg [N-1:0] freq0,freq1,freq2,freq3,freq4,freq5,freq6,freq7,freq8,freq9;\n\treg [N-1:0] ak0,ak1,ak2,ak3,ak4,ak5,ak6,ak7,ak8,ak9,ak10;\n\tinput [N-1:0] ak_0,ak_1,ak_2,ak_3,ak_4,ak_5,ak_6,ak_7,ak_8,ak_9,ak_10;\n\t\n\treg [N-1:0]\t psumr,psum1;\n\t\t\t\t\t\t \n\toutput reg doneltl;\n\twire donecp2c;\n\toutput reg [3:0] ak_addr;\n\t\n\treg [3:0] check_roots,i;\n\treg [9:0] count;\n\t\n\toutput reg [N-1:0] c_psum,c_sig;\n\t\n\t\n\n\tRAM_ak         module_RAM_ak\t\t\t   (ak_addr,clk,,1,0,ak_out); */  //frame 0\n\t\n\n\n\n\n\nparameter START = 5'd0,\n          INIT = 6'd1,\n\t\t\t SET_AK_ADDR = 6'd2,\n\t\t\t GET_AK = 6'd3,\n\t\t\t INCR_J = 6'd4,\n\t\t\t CHECK_J = 6'd5,\n\t\t\t PRE_CALC_PQ = 6'd6 ,\n\t\t\t CALC_PQ1 = 6'd7,\n\t\t\t CALC_PQ2 = 6'd8,\n\t\t\t CALC_PQ3 = 6'd9,\n\t\t\t CALC_PQ4 = 6'd10,\n\t\t\t CALC_PQ5 = 6'd11,\n\t\t\t CALC_PQ = 6'd12,\n\t\t\t PRE_GET_AK = 6'd13,\n\t\t\t SET_COEFF = 6'd14,\n\t\t\t CALC_PSUM1 = 6'd15,\n\t\t\t SET_WHILE = 6'd16,\n\t\t\t CHECK_WHILE = 6'd17,\n\t\t\t CALC_XR = 6'd18,\n\t\t\t OUT_XR = 6'd19,\n\t\t\t SET_PSUMR = 6'd20,\n\t\t\t SET_TEMPS = 6'd21,\n\t\t\t DOUBLE_PQ = 6'd22,\n\t\t\t CHECK_IF = 6'd23,\n\t\t\t INIT_IF = 6'd24,\n\t\t\t CHECK_K = 6'd25,\n\t\t\t ADD_XM = 6'd26,\n\t\t\t OUT_XM = 6'd27,\n\t\t\t INIT_PSUMM = 6'd28,\n\t\t\t OUT_PSUMM = 6'd29,\n\t\t\t CHECK_IF_2 = 6'd30,\n\t\t\t IF2_TRUE = 6'd31,\n\t\t\t IF2_FALSE = 6'd32,\n\t\t\t INCR_K = 6'd33,\n\t\t\t SET_FREQ = 6'd34,\n\t\t\t IF_FALSE = 6'd35,\n\t\t\t INCR_I = 6'd36,\n\t\t\t CHECK_I = 6'd37,\n\t\t\t CALC_FREQ_ACOSF = 6'd38,\n\t\t\t SET_FREQ_ACOSF = 6'd39,\t\n\t\t\tINCR_ACOSF = 6'd40,\n\t\t\tCHECK_ACOSF = 6'd41,\n\t\t\tINIT_ACOSF = 6'd42,\n\t\t\tDONE = 6'd43,\n\t\t\tSTART_ACOSF = 6'd44,\n\t\t\tSTART_PSUMM = 6'd45,\n\t\t\tRUN_OUT_XR = 6'd46;\n\nreg [5:0] STATE, NEXT_STATE;\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t  \nparameter [N-1:0] NUMBER_TWO = {8'h02,24'b0},\n\t\t\t\t  NUMBER_ONE = {8'h01,24'b0},\n\t\t\t\t  NUMBER_POINT_FIVE = {8'h00,1'b1,23'b0},\n\t\t\t\t  NUMBER_NEG_ONE = {8'h81,24'b0},\n\t\t\t\t  DELTA = {8'h00,24'h028F5C};\n\nparameter [3:0] NB = 4'd5, ORDER = 4'd10; \t\t\t\t  \n\t\t\t\t  \nreg \t[N-1:0] xr,x1,p0,p1,p2,p3,p4,p5,q0,q1,q2,q3,q4,q5;\n\n\nreg \t[3:0]   j,k,roots;\n\nreg \t[N-1:0] a1_in1,a1_in2,a2_in1,a2_in2,a3_in1,a3_in2,a4_in1,a4_in2,x_1,x_2,x_3,\n\t\t\t\t  value;\nwire \t[N-1:0] a1_out,a2_out,a3_out,a4_out,sum1,sum2,sum3,\n\t\t\t\t  theta;\nwire \tdonecp1,donecp2,donecp3,gt1,doneacosf;\nreg \tstartcp1,startcp2,startcp3,flag,startacosf;\nreg \t[N-1:0] coeff0,coeff1,coeff2,coeff3,coeff4,coeff5,temp_psumr,temp_xr,x,gt1_in1,gt1_in2;\n\nreg [N-1:0] psumm,xm;\nreg [3:0] ac;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\ncheb_poly_eva  module_cheb_poly_eva1  \t(clk,rst,startcp1,x_1,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t donecp1);\t\t\t\t\t\t\t\t\t\t\t\t\t \ncheb_poly_eva  module_cheb_poly_eva2  \t(clk,rst,startcp2,x_2,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum2,donecp2);\ncheb_poly_eva  module_cheb_poly_eva3  \t(clk,rst,startcp3,x_3,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum3,donecp3);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\nqadd #(Q1,N) add1(a1_in1, a1_in2, a1_out);\nqadd #(Q1,N) add2(a2_in1, a2_in2, a2_out);\nqadd #(Q1,N) add3(a3_in1, a3_in2, a3_out);\nqadd #(Q1,N) add4(a4_in1, a4_in2, a4_out);\nfpgreaterthan #(Q1,N) fpgt1(gt1_in1,gt1_in2,gt1);\n\n\n\nacosf acosf0(startacosf,clk,rst,value,theta,doneacosf);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalways@(posedge clk or negedge rst)     \nbegin\n\n\tif (rst == 1'b0)\n\t\tSTATE <= START;\n\telse\n\t\tSTATE <= NEXT_STATE;\n\nend\n\n\nalways@(*)                              \nbegin\n\tcase(STATE)\n\n\tSTART:\n\tbegin\n\t\tif(startltl)\n\t\tbegin\n\t\t\tNEXT_STATE = INIT;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START;\n\t\tend\n\tend\n\n\tINIT:\n\tbegin\n\t\tNEXT_STATE = PRE_CALC_PQ;\n\tend\n\t\n\tSET_AK_ADDR:\n\tbegin\n\t\tNEXT_STATE = PRE_GET_AK;\n\tend\n\t\n\t\t\t\n\tPRE_GET_AK:\n\tbegin\n\t\tNEXT_STATE = GET_AK;\t\n\tend\n\n\tGET_AK:\n\tbegin\n\t\tNEXT_STATE = INCR_J;\n\tend\n\t\n\tINCR_J:\n\tbegin\n\t\tNEXT_STATE = CHECK_J;\n\tend\n\t\n\tCHECK_J:\n\tbegin\n\t\tif(j <= 4'd11)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_AK_ADDR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = PRE_CALC_PQ;\n\t\tend\n\tend\n\t\n\tPRE_CALC_PQ:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ1;\n\tend\n\t\n\tCALC_PQ1:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ2;\n\tend\n\t\n\tCALC_PQ2:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ3;\n\tend\n\t\n\tCALC_PQ3:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ4;\n\tend\n\t\n\tCALC_PQ4:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ5;\n\tend\n\t\n\tCALC_PQ5:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ;\n\tend\n\t\n\tCALC_PQ:\n\tbegin\n\t\tNEXT_STATE = DOUBLE_PQ;\n\tend\n\t\n\tDOUBLE_PQ:\n\tbegin\n\t\tNEXT_STATE = SET_COEFF;\n\tend\n\t\n\tSET_COEFF:\n\tbegin\n\t\tif(donecp1)\n\t\tbegin\n\t\t\tNEXT_STATE = CALC_PSUM1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = SET_COEFF;\n\t\tend\n\tend\n\t\n\tCALC_PSUM1:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\n\tSET_WHILE:\n\tbegin\n\t\tNEXT_STATE = CHECK_WHILE;\n\tend\t\n\n\tCHECK_WHILE:\n\tbegin\n\t\tif(flag && (gt1 || (xr == NUMBER_NEG_ONE)))\n\t\tbegin\n\t\t\tNEXT_STATE = CALC_XR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = INCR_I;\n\t\tend\n\tend\t\n\t\n\tINCR_I:\n\tbegin\n\t\tNEXT_STATE = CHECK_I;\n\tend\n\t\n\tCHECK_I:\n\tbegin\n\t\tif(i < ORDER)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_COEFF;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = INIT_ACOSF;\n\t\tend\n\t\n\tend\n\n\tCALC_XR:\n\tbegin\n\t\tNEXT_STATE = OUT_XR;\n\tend\n\t\n\tOUT_XR:\n\tbegin\n\t\tNEXT_STATE = RUN_OUT_XR;\n\tend\n\t\n\tRUN_OUT_XR:\n\tbegin\n\t\tif(donecp2)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_PSUMR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = RUN_OUT_XR;\n\t\tend\n\tend\n\t\n\tSET_PSUMR:\n\tbegin\n\t\tNEXT_STATE = SET_TEMPS;\n\tend\n\t\n\tSET_TEMPS:\n\tbegin\n\t\tNEXT_STATE = CHECK_IF;\n\tend\n\t\n\tCHECK_IF:\n\tbegin\n\t\tif((psumr[N-1] ==  1 && psum1[N-1] == 0) || \n\t\t\t(psumr[N-1] ==  0 && psum1[N-1] == 1) ||\n\t\t\t(psumr == 32'b0))\n\t\tbegin\n\t\t\tNEXT_STATE = INIT_IF;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t   NEXT_STATE = IF_FALSE;\n\t\tend\n\tend\n\t\n\tINIT_IF:\n\tbegin\n\t\tNEXT_STATE = CHECK_K;\n\tend\n\n\tCHECK_K:\n\tbegin\n\t\tif(k <= NB)\n\t\tbegin\n\t\t\tNEXT_STATE = ADD_XM;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = SET_FREQ;\n\t\tend\n\tend\n\t\n\tADD_XM:\n\tbegin\n\t\tNEXT_STATE = OUT_XM;\n\tend\n\n\tOUT_XM:\n\tbegin\n\t\tNEXT_STATE = INIT_PSUMM;\n\tend\n \n\t INIT_PSUMM:\n\tbegin\n\t\tNEXT_STATE = START_PSUMM;\n\tend \n\t\n\tSTART_PSUMM:\n\tbegin\n\t\tif(donecp3)\n\t\tbegin\n\t\t\tNEXT_STATE = OUT_PSUMM;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START_PSUMM;\n\t\tend\n\tend\n\n\tOUT_PSUMM:\n\tbegin\n\t\tNEXT_STATE = CHECK_IF_2;\n\tend\n\t\n\tCHECK_IF_2:\n\tbegin\n\t\tif((psumm[N-1] == 1 && psum1[N-1] == 1) || (psumm[N-1] == 0 && psum1[N-1] == 0))\n\t\tbegin\n\t\t\tNEXT_STATE = IF2_TRUE;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = IF2_FALSE;\n\t\tend\n\tend\n\t\n\tIF2_TRUE:\n\tbegin\n\t\tNEXT_STATE = INCR_K;\n\tend\n\t\n\tIF2_FALSE:\n\tbegin\n\t\tNEXT_STATE = INCR_K;\n\tend\n\t\n\tINCR_K:\n\tbegin\n\t\tNEXT_STATE = CHECK_K;\n\tend\n\t\n\tSET_FREQ:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\t\n\tIF_FALSE:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\t\n\tINIT_ACOSF:\n\tbegin\n\t\tNEXT_STATE = START_ACOSF;\n\tend\n\t\n\tSTART_ACOSF:\n\tbegin\n\t\tNEXT_STATE = CALC_FREQ_ACOSF;\n\tend\n\t\n\tCALC_FREQ_ACOSF:\n\tbegin\n\t\tif(doneacosf)\n\t\t\tbegin\n\t\t\t\tNEXT_STATE = SET_FREQ_ACOSF;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tNEXT_STATE = CALC_FREQ_ACOSF;\n\t\t\tend\n\tend\n\t\n\tSET_FREQ_ACOSF:\n\tbegin\n\t\tNEXT_STATE = INCR_ACOSF;\n\tend\n\t\n\tINCR_ACOSF:\n\tbegin\n\t\tNEXT_STATE = CHECK_ACOSF;\n\tend\n\t\n\tCHECK_ACOSF:\n\tbegin\n\t\tif(ac >= 4'd10)\n\t\tbegin\n\t\t\tNEXT_STATE = DONE;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START_ACOSF;\n\t\tend\n\t\t\n\tend\n\t\n\tDONE:\n\tbegin\n\t\tNEXT_STATE = START;\n\tend\n\n\tdefault:\n\tbegin\n\t\tNEXT_STATE = DONE;\n\tend\n\n\tendcase\nend\n\n\nalways@(posedge clk or negedge rst)     \nbegin\n\n\tif (rst == 1'b0)\n\tbegin\n\n\t\tdoneltl <= 1'b0;\n\n\tend\n\n\telse\n\tbegin\n\t\tcase(STATE)\n\n\t\tSTART:\n\t\tbegin\n\t\t\tstartcp1 <= 1'b0;\n\t\t\tstartcp2 <= 1'b0;\n\t\t\tstartcp3 <= 1'b0;\n\t\t\tstartacosf <= 1'b0;\n\t\t\tcount <= 6'd0;\n\t\t\txm <= 32'b0;\n\t\t\tdoneltl <= 1'd0;\n\t\t\t\n\t\t   \n\n\n\n\n\n\n\n\n\n\t\t\tak10 <= {8'h00,24'h159E3E};     // 0.08444589   */         // Actual from c code base; \n\t\t\t\n\t\t\t\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\n\t\t\t\n\t\t\tak0 <= {ak_0[N-1],ak_0[22:16],ak_0[15:0],8'b0};\n\t\t\tak1 <= {ak_1[N-1],ak_1[22:16],ak_1[15:0],8'b0};\n\t\t\tak2 <= {ak_2[N-1],ak_2[22:16],ak_2[15:0],8'b0};\n\t\t\tak3 <= {ak_3[N-1],ak_3[22:16],ak_3[15:0],8'b0};\n\t\t\tak4 <= {ak_4[N-1],ak_4[22:16],ak_4[15:0],8'b0};\n\t\t\tak5 <= {ak_5[N-1],ak_5[22:16],ak_5[15:0],8'b0};\n\t\t\tak6 <= {ak_6[N-1],ak_6[22:16],ak_6[15:0],8'b0};\n\t\t\tak7 <= {ak_7[N-1],ak_7[22:16],ak_7[15:0],8'b0};\n\t\t\tak8 <= {ak_8[N-1],ak_8[22:16],ak_8[15:0],8'b0};\n\t\t\tak9 <= {ak_9[N-1],ak_9[22:16],ak_9[15:0],8'b0};\n\t\t\tak10 <= {ak_10[N-1],ak_10[22:16],ak_10[15:0],8'b0};  \n\t\t\t\n\t\t\t\n\t\tend\n\n\t\tINIT:\n\t\tbegin\n\t\t\tdoneltl <= 1'b0;\n\t\t\txr <= 32'b0;\n\t\t\tx1 <= NUMBER_ONE;\n\t\t\tj <= 4'd0;\n\t\t\troots <= 4'd0;\n\t\tend\n\t\t\n\t\tSET_AK_ADDR:\n\t\tbegin\n\t\t\tak_addr <= j;\n\t\tend\n\t\t\n\t\tPRE_GET_AK:\n\t\tbegin\n\t\t\t\n\t\tend\n\n\t\tGET_AK:\n\t\tbegin\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tend\n\t\t\n\t\tINCR_J:\n\t\tbegin\n\t\t\tj <= j + 4'd1;\n\n\t\tend\n\t\t\n\t\tCHECK_J:\n\t\tbegin\n\t\t\n\t\tend\n\t\t\n\t\tPRE_CALC_PQ:\n\t\tbegin\n\t\t\tp0 <= NUMBER_ONE;\t\t\t\n\t\t\tq0 <= NUMBER_ONE;\n\t\t\t\n\t\t\ta1_in1 <= ak1;\n\t\t\ta1_in2 <= ak10;\n\t\t\t\n\t\t\ta2_in1 <= ak1;\n\t\t\ta2_in2 <= {(ak10[N-1] == 0)?1'b1:1'b0,ak10[N-2:0]};\n\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ1:\n\t\tbegin\n\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= NUMBER_NEG_ONE;\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= NUMBER_ONE;\n\t\t\t\t \n\t\t\ta1_in1 <= ak2;\n\t\t\ta1_in2 <= ak9;\n\t\t\t\t\n\t\t\ta2_in1 <= ak2;\n\t\t\ta2_in2 <= {(ak9[N-1] == 0)?1'b1:1'b0,ak9[N-2:0]};\n\t\t\t \n\t\t\t \n\t\tend\n\t\t\n\t\tCALC_PQ2:\n\t\tbegin\n\t\t\n\t\t\tp1 <= a3_out;\n\t\t\tq1 <= a4_out;\n\t\t\t\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak3;\n\t\t\ta1_in2 <= ak8;\n\t\t\t\t\n\t\t\ta2_in1 <= ak3;\n\t\t\ta2_in2 <= {(ak8[N-1] == 0)?1'b1:1'b0,ak8[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ3:\n\t\tbegin\n\t\t\n\t\t\tp2 <= a3_out;\n\t\t\tq2 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak4;\n\t\t\ta1_in2 <= ak7;\n\t\t\t\t\n\t\t\ta2_in1 <= ak4;\n\t\t\ta2_in2 <= {(ak7[N-1] == 0)?1'b1:1'b0,ak7[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ4:\n\t\tbegin\n\t\t\n\t\t\tp3 <= a3_out;\n\t\t\tq3 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak5;\n\t\t\ta1_in2 <= ak6;\n\t\t\t\t\n\t\t\ta2_in1 <= ak5;\n\t\t\ta2_in2 <= {(ak6[N-1] == 0)?1'b1:1'b0,ak6[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ5:\n\t\tbegin\n\t\t\n\t\t\tp4 <= a3_out;\n\t\t\tq4 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ:\n\t\tbegin\n\t\t\n\t\t\tp5 <= a3_out;\n\t\t\tq5 <= a4_out;\n\t\t\t\n\t\t\ti <= 4'd0;\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tDOUBLE_PQ:\n\t\tbegin\n\t\t\tp0 <= {p0[N-1], p0[N-2 : 0] << 1};\n\t\t\tp1 <= {p1[N-1], p1[N-2 : 0] << 1};\n\t\t\tp2 <= {p2[N-1], p2[N-2 : 0] << 1};\n\t\t\tp3 <= {p3[N-1], p3[N-2 : 0] << 1};\n\t\t\tp4 <= {p4[N-1], p4[N-2 : 0] << 1};\n\t\t\t\n\t\t\tq0 <= {q0[N-1], q0[N-2 : 0] << 1};\n\t\t\tq1 <= {q1[N-1], q1[N-2 : 0] << 1};\n\t\t\tq2 <= {q2[N-1], q2[N-2 : 0] << 1};\n\t\t\tq3 <= {q3[N-1], q3[N-2 : 0] << 1};\n\t\t\tq4 <= {q4[N-1], q4[N-2 : 0] << 1};\n\t\tend\n\t\t\n\t\tINCR_I:\n\t\tbegin\n\t\t\ti <= i + 4'd1;\n\t\tend\n\t\t\n\t\tCHECK_I:\n\t\tbegin\n\t\t\t\n\t\tend\n\n\t\tSET_COEFF:\n\t\tbegin\n\t\t\n\t\t\n\t\t\tstartcp1 <= 1'b1;\n\t\t\t\n\t\t\tx_1 <= x1;\n\t\t\tif(!(i % 4'd2))\n\t\t\tbegin\n\t\t\t\tcoeff0 <= p0;\n\t\t\t\tcoeff1 <= p1;\n\t\t\t\tcoeff2 <= p2;\n\t\t\t\tcoeff3 <= p3;\n\t\t\t\tcoeff4 <= p4;\n\t\t\t\tcoeff5 <= p5;\n\t\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tcoeff0 <= q0;\n\t\t\t\tcoeff1 <= q1;\n\t\t\t\tcoeff2 <= q2;\n\t\t\t\tcoeff3 <= q3;\n\t\t\t\tcoeff4 <= q4;\n\t\t\t\tcoeff5 <= q5;\n\t\t\t\n\t\t\tend\n\t\tend\n\t\t\n\t\t\n\t\t\n\t\tCALC_PSUM1:\n\t\tbegin\n\t\t\t\n\t\t\tpsum1 <= sum1;\t\t\n\t\t\tflag <= 1'b1;\n\t\t\tstartcp1 <= 1'b0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\tend\n\n\t\tSET_WHILE:\n\t\tbegin\n\t\t\tgt1_in1 <= xr;\n\t\t\tgt1_in2 <= NUMBER_NEG_ONE;\n\t\tend\t\n\n\t\tCHECK_WHILE:\n\t\tbegin\n\t\t\t\n\t\tend\t\n\n\t\tCALC_XR:\n\t\tbegin\n\t\t\ta1_in1 <= x1;\n\t\t\ta1_in2 <= {(DELTA[N-1] == 0)?1'b1:1'b0,DELTA[N-2:0]};\n\t\t\t\n\t\t\tcount <= count + 6'd1;\n\t\t\t\n\t\tend\n\t\t\n\t\tOUT_XR:\n\t\tbegin\n\t\t\txr <= a1_out;\n\t\t\tx_2 <= a1_out;\n\t\t\tstartcp2 <= 1'b1;\n\t\t\t\n\t\tend\n\t\t\n\t\tRUN_OUT_XR:\n\t\tbegin\n\t\t\tstartcp2 <= 1'b0;\n\t\tend\n\t\t\n\n\t\tSET_PSUMR:\n\t\tbegin\n\t\t\tpsumr <= sum2;\n\t\n\t\tend\n\t\t\n\t\tSET_TEMPS:\n\t\tbegin\n\t\t\ttemp_psumr <= psumr;\n\t\t\ttemp_xr <= xr;\t\t\n\t\tend\n\t\t\n\t\tCHECK_IF:\n\t\tbegin\n\n\t\tend\n\t\t\n\t\tINIT_IF:\n\t\tbegin\n\t\t\troots <= roots + 4'd1;\n\t\t\tpsumm <= psum1;\n\t\t\tk <= 4'd0;\n\t\tend\n\n\t\tCHECK_K:\n\t\tbegin\n\t\t\t\n\t\tend\n\t\t\n\t\tADD_XM:\n\t\tbegin\n\t\t\ta1_in1 <= x1;\n\t\t\ta1_in2 <= xr;\n\t\tend\n\n\t\tOUT_XM:\n\t\tbegin\n\n\t\t\txm <= {a1_out[N-1],a1_out[N-2:0] >> 1};\n\t\t\t\n\t\tend\n\t \n\t\tINIT_PSUMM:\n\t\tbegin\n\n\t\t\tx_3 <= xm;\n\t\t\tstartcp3 <= 1'b1;\n\t\n\t\tend\n\t\t\n\t\tSTART_PSUMM:\n\t\tbegin\n\t\t\tstartcp3 <= 1'b0;\n\t\tend \n\n\t\tOUT_PSUMM:\n\t\tbegin\n\t\t\tpsumm <= sum3;\n\n\t\tend\n\t\t\n\t\tCHECK_IF_2:\n\t\tbegin\n\t\t\tif(i == 4'd0 && k == 4'd1)\n\t\t\tbegin\n\t\t\t\tc_psum <= psumm;\n\t\t\t\tc_sig <= xm ;\n\t\t\tend\n\t\tend\n\t\t\n\t\tIF2_TRUE:\n\t\tbegin\n\t\t\tpsum1 <= psumm;\n\t\t\tx1 \t<= xm;\n\t\tend\n\t\t\n\t\tIF2_FALSE:\n\t\tbegin\n\t\t\tpsumr <= psumm;\n\t\t\txr    <= xm;\n\t\t\t\n\t\t\t\n\t\tend\n\t\t\n\t\tINCR_K:\n\t\tbegin\n\t\t\tk <= k + 4'd1;\n\t\tend\n\t\t\n\t\tSET_FREQ:\n\t\tbegin\n\t\t\tcase(i)\n\t\t\t4'd0: freq0 <= xm;\n\t\t\t4'd1: freq1 <= xm;\n\t\t\t4'd2: freq2 <= xm;\n\t\t\t4'd3: freq3 <= xm;\n\t\t\t4'd4: freq4 <= xm;\n\t\t\t4'd5: freq5 <= xm;\n\t\t\t4'd6: freq6 <= xm;\n\t\t\t4'd7: freq7 <= xm;\n\t\t\t4'd8: freq8 <= xm;\n\t\t\t4'd9: freq9 <= xm;\n\t\t\tendcase\n\t\t\t\n\t\t\tx1 <= xm;\n\t\t\tflag = 1'b0;\n\t\t\t\n\t\tend\n\t\t\n\t\tIF_FALSE:\n\t\tbegin\n\t\t\tpsum1 <= temp_psumr;\n\t\t\tx1 \t<= temp_xr;\n\t\tend\n\t\t\n\t\tINIT_ACOSF:\n\t\tbegin\n\t\t\tac <= 4'd0;\n\t\t\t\n\t\tend\n\t\t\n\t\tSTART_ACOSF:\n\t\tbegin\n\t\t\tstartacosf <= 1'b1;\n\t\t\t\n\t\t\tcase(ac)\n\t\t\t4'd0: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq0[N-1],8'b0,freq0[30:24],freq0[23:8]};\n\t\t\tend\n\t\t\t4'd1: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq1[N-1],8'b0,freq1[30:24],freq1[23:8]};\n\t\t\tend\n\t\t\t4'd2: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq2[N-1],8'b0,freq2[30:24],freq2[23:8]};\n\t\t\tend\n\t\t\t4'd3: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq3[N-1],8'b0,freq3[30:24],freq3[23:8]};\n\t\t\tend\n\t\t\t4'd4: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq4[N-1],8'b0,freq4[30:24],freq4[23:8]};\n\t\t\tend\n\t\t\t4'd5: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq5[N-1],8'b0,freq5[30:24],freq5[23:8]};\n\t\t\tend\n\t\t\t4'd6: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq6[N-1],8'b0,freq6[30:24],freq6[23:8]};\n\t\t\tend\n\t\t\t4'd7: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq7[N-1],8'b0,freq7[30:24],freq7[23:8]};\n\t\t\tend\n\t\t\t4'd8: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq8[N-1],8'b0,freq8[30:24],freq8[23:8]};\n\t\t\tend\n\t\t\t4'd9: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq9[N-1],8'b0,freq9[30:24],freq9[23:8]};\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\t\n\t\tCALC_FREQ_ACOSF:\n\t\tbegin\n\t\t\tstartacosf <= 1'b0;\n\t\t\t\n\t\t\t\n\t\tend\n\t\t\n\t\tSET_FREQ_ACOSF:\n\t\tbegin\n\t\t\n\t\t\tcase(ac)\n\t\t\t4'd0: \n\t\t\tbegin\n\t\t\t\tfreq0  <=  theta;\n\t\t\tend\n\t\t\t4'd1: \n\t\t\tbegin\n\t\t\t\tfreq1  <=  theta;\n\t\t\tend\n\t\t\t4'd2: \n\t\t\tbegin\n\t\t\t\tfreq2  <=  theta;\n\t\t\tend\n\t\t\t4'd3: \n\t\t\tbegin\n\t\t\t\tfreq3  <=  theta;\n\t\t\tend\n\t\t\t4'd4: \n\t\t\tbegin\n\t\t\t\tfreq4  <=  theta;\n\t\t\tend\n\t\t\t4'd5: \n\t\t\tbegin\n\t\t\t\tfreq5  <=  theta;\n\t\t\tend\n\t\t\t4'd6: \n\t\t\tbegin\n\t\t\t\tfreq6  <=  theta;\n\t\t\tend\n\t\t\t4'd7: \n\t\t\tbegin\n\t\t\t\tfreq7  <=  theta;\n\t\t\tend\n\t\t\t4'd8: \n\t\t\tbegin\n\t\t\t\tfreq8  <=  theta;\n\t\t\tend\n\t\t\t4'd9: \n\t\t\tbegin\n\t\t\t\tfreq9  <=  theta;\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\t\n\t\tINCR_ACOSF:\n\t\tbegin\n\t\t\tac <= ac + 4'd1;\n\t\tend\n\t\t\n\t\tCHECK_ACOSF:\n\t\tbegin\n\t\t\t\n\t\tend\n\t\n\n\t\tDONE:\n\t\tbegin\n\t\t\tdoneltl <= 1'b1;\n\t\tend\n\n\t\tendcase\n\tend\n\nend\n\n\nendmodule```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: lpc_to_lsp. Module specification: This module implements a Linear Predictive Coding (LPC) to Line Spectral Pairs (LSP) conversion algorithm. It takes LPC coefficients as input and converts them to LSP frequencies. The module has input ports for start signal (startltl), clock (clk), reset (rst), LPC coefficients (ak_out, ak_0 to ak_10), and output ports for LSP frequencies (freq0 to freq9), done signal (doneltl), address for accessing LPC coefficients (ak_addr), and intermediate calculation results (c_psum, c_sig). Internally, it uses various signals for state management, counters, polynomial coefficients, and intermediate calculations. The module is structured with a finite state machine controlling the conversion process, which includes initializing variables, calculating polynomial coefficients, finding roots of polynomials,"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: lpc_to_lsp\n\nExplanation: This module appears to implement a Linear Predictive Coding (LPC) to Line Spectral Pairs (LSP) conversion algorithm. It takes LPC coefficients as input and converts them to LSP frequencies. The module uses a state machine to control the conversion process, which includes initializing variables, calculating polynomial coefficients, finding roots of polynomials, and converting the roots to frequencies using an arccosine function. The module also includes various arithmetic operations and uses sub-modules for specific calculations like Chebyshev polynomial evaluation and arccosine computation. The final output consists of 10 LSP frequencies."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nstartltl, clk, rst, ak_out, ak_0, ak_1, ak_2, ak_3, ak_4, ak_5, ak_6, ak_7, ak_8, ak_9, ak_10\n\nExplanation:\n- startltl: Start signal for the LPC to LSP conversion process\n- clk: Clock input for synchronous operations\n- rst: Reset signal for initializing the module\n- ak_out: LPC coefficient input from RAM\n- ak_0 to ak_10: Individual LPC coefficient inputs\n\nOutput ports:\nfreq0, freq1, freq2, freq3, freq4, freq5, freq6, freq7, freq8, freq9, doneltl, ak_addr, c_psum, c_sig\n\nExplanation:\n- freq0 to freq9: Output LSP frequencies\n- doneltl: Signal indicating completion of the conversion process\n- ak_addr: Address for accessing LPC coefficients from RAM\n- c_psum, c_sig: Intermediate calculation results (likely for debugging or monitoring)"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nSTATE, NEXT_STATE, j, k, i, roots, ak0-ak10, psumr, psum1, psumm, xr, x1, p0-p5, q0-q5, coeff0-coeff5, flag, check_roots, count, xm, ac, startcp1, startcp2, startcp3, startacosf, a1_in1, a1_in2, a2_in1, a2_in2, a3_in1, a3_in2, a4_in1, a4_in2, x_1, x_2, x_3, value, gt1_in1, gt1_in2, temp_psumr, temp_xr.\n\nExplanation:\n- STATE, NEXT_STATE: Current and next state of the FSM controlling the module's operation\n- j, k, i, roots: Counters and indexes for various loops and operations\n- ak0-ak10: Internal storage for LPC coefficients\n- psumr, psum1, psumm: Intermediate sum values used in root-finding process\n- xr, x1: Variables used in the root-finding algorithm\n- p0-p5, q0-q5: Coefficients of polynomials used in the LSP conversion\n- coeff0-coeff5: Coefficients used in Chebyshev polynomial evaluation\n- flag: Control flag for the while loop in root-finding\n- check_roots, count: Variables for tracking the root-finding process\n- xm: Intermediate value in root bisection method\n- ac: Counter for arccosine calculation loop\n- startcp1, startcp2, startcp3, startacosf: Start signals for sub-modules\n- a1_in1, a1_in2, a2_in1, a2_in2, a3_in1, a3_in2, a4_in1, a4_in2: Inputs for arithmetic operations\n- x_1, x_2, x_3: Inputs for Chebyshev polynomial evaluation\n- value: Input value for arccosine calculation\n- gt1_in1, gt1_in2: Inputs for comparison operations\n- temp_psumr, temp_xr: Temporary storage for intermediate values"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule lpc_to_lsp (startltl,clk,rst,ak_out,\n\t\t\t\tak_0,ak_1,ak_2,ak_3,ak_4,ak_5,ak_6,ak_7,ak_8,ak_9,ak_10,\n\t\t\t\tfreq0,freq1,freq2,freq3,freq4,freq5,freq6,freq7,freq8,freq9,\n\t\t\t\t\t\t ak_addr,\n\t\t\t\t\t\n\t\t\t\t\t\t doneltl,\n\t\t\t\t\t\t c_psum,c_sig\n\t\t\t\t\t\t \n\t\t\t\t\t\t );\n\n\n\n\n\n\n\n\tparameter N = 32;\n\tparameter Q = 16;\n\t\n\tparameter Q1 = 24;\n\t\n\tinput startltl,clk,rst;\n\tinput [N-1:0] ak_out;\n\t\n\toutput reg [N-1:0] freq0,freq1,freq2,freq3,freq4,freq5,freq6,freq7,freq8,freq9;\n\treg [N-1:0] ak0,ak1,ak2,ak3,ak4,ak5,ak6,ak7,ak8,ak9,ak10;\n\tinput [N-1:0] ak_0,ak_1,ak_2,ak_3,ak_4,ak_5,ak_6,ak_7,ak_8,ak_9,ak_10;\n\t\n\treg [N-1:0]\t psumr,psum1;\n\t\t\t\t\t\t \n\toutput reg doneltl;\n\twire donecp2c;\n\toutput reg [3:0] ak_addr;\n\t\n\treg [3:0] check_roots,i;\n\treg [9:0] count;\n\t\n\toutput reg [N-1:0] c_psum,c_sig;\n\t\n\t\n\n\tRAM_ak         module_RAM_ak\t\t\t   (ak_addr,clk,,1,0,ak_out); */  //frame 0\n\t\n\n\n\n\n\nparameter START = 5'd0,\n          INIT = 6'd1,\n\t\t\t SET_AK_ADDR = 6'd2,\n\t\t\t GET_AK = 6'd3,\n\t\t\t INCR_J = 6'd4,\n\t\t\t CHECK_J = 6'd5,\n\t\t\t PRE_CALC_PQ = 6'd6 ,\n\t\t\t CALC_PQ1 = 6'd7,\n\t\t\t CALC_PQ2 = 6'd8,\n\t\t\t CALC_PQ3 = 6'd9,\n\t\t\t CALC_PQ4 = 6'd10,\n\t\t\t CALC_PQ5 = 6'd11,\n\t\t\t CALC_PQ = 6'd12,\n\t\t\t PRE_GET_AK = 6'd13,\n\t\t\t SET_COEFF = 6'd14,\n\t\t\t CALC_PSUM1 = 6'd15,\n\t\t\t SET_WHILE = 6'd16,\n\t\t\t CHECK_WHILE = 6'd17,\n\t\t\t CALC_XR = 6'd18,\n\t\t\t OUT_XR = 6'd19,\n\t\t\t SET_PSUMR = 6'd20,\n\t\t\t SET_TEMPS = 6'd21,\n\t\t\t DOUBLE_PQ = 6'd22,\n\t\t\t CHECK_IF = 6'd23,\n\t\t\t INIT_IF = 6'd24,\n\t\t\t CHECK_K = 6'd25,\n\t\t\t ADD_XM = 6'd26,\n\t\t\t OUT_XM = 6'd27,\n\t\t\t INIT_PSUMM = 6'd28,\n\t\t\t OUT_PSUMM = 6'd29,\n\t\t\t CHECK_IF_2 = 6'd30,\n\t\t\t IF2_TRUE = 6'd31,\n\t\t\t IF2_FALSE = 6'd32,\n\t\t\t INCR_K = 6'd33,\n\t\t\t SET_FREQ = 6'd34,\n\t\t\t IF_FALSE = 6'd35,\n\t\t\t INCR_I = 6'd36,\n\t\t\t CHECK_I = 6'd37,\n\t\t\t CALC_FREQ_ACOSF = 6'd38,\n\t\t\t SET_FREQ_ACOSF = 6'd39,\t\n\t\t\tINCR_ACOSF = 6'd40,\n\t\t\tCHECK_ACOSF = 6'd41,\n\t\t\tINIT_ACOSF = 6'd42,\n\t\t\tDONE = 6'd43,\n\t\t\tSTART_ACOSF = 6'd44,\n\t\t\tSTART_PSUMM = 6'd45,\n\t\t\tRUN_OUT_XR = 6'd46;\n\nreg [5:0] STATE, NEXT_STATE;\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t  \nparameter [N-1:0] NUMBER_TWO = {8'h02,24'b0},\n\t\t\t\t  NUMBER_ONE = {8'h01,24'b0},\n\t\t\t\t  NUMBER_POINT_FIVE = {8'h00,1'b1,23'b0},\n\t\t\t\t  NUMBER_NEG_ONE = {8'h81,24'b0},\n\t\t\t\t  DELTA = {8'h00,24'h028F5C};\n\nparameter [3:0] NB = 4'd5, ORDER = 4'd10; \t\t\t\t  \n\t\t\t\t  \nreg \t[N-1:0] xr,x1,p0,p1,p2,p3,p4,p5,q0,q1,q2,q3,q4,q5;\n\n\nreg \t[3:0]   j,k,roots;\n\nreg \t[N-1:0] a1_in1,a1_in2,a2_in1,a2_in2,a3_in1,a3_in2,a4_in1,a4_in2,x_1,x_2,x_3,\n\t\t\t\t  value;\nwire \t[N-1:0] a1_out,a2_out,a3_out,a4_out,sum1,sum2,sum3,\n\t\t\t\t  theta;\nwire \tdonecp1,donecp2,donecp3,gt1,doneacosf;\nreg \tstartcp1,startcp2,startcp3,flag,startacosf;\nreg \t[N-1:0] coeff0,coeff1,coeff2,coeff3,coeff4,coeff5,temp_psumr,temp_xr,x,gt1_in1,gt1_in2;\n\nreg [N-1:0] psumm,xm;\nreg [3:0] ac;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\ncheb_poly_eva  module_cheb_poly_eva1  \t(clk,rst,startcp1,x_1,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t donecp1);\t\t\t\t\t\t\t\t\t\t\t\t\t \ncheb_poly_eva  module_cheb_poly_eva2  \t(clk,rst,startcp2,x_2,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum2,donecp2);\ncheb_poly_eva  module_cheb_poly_eva3  \t(clk,rst,startcp3,x_3,coeff0,coeff1,coeff2,coeff3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t coeff4,coeff5,sum3,donecp3);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\nqadd #(Q1,N) add1(a1_in1, a1_in2, a1_out);\nqadd #(Q1,N) add2(a2_in1, a2_in2, a2_out);\nqadd #(Q1,N) add3(a3_in1, a3_in2, a3_out);\nqadd #(Q1,N) add4(a4_in1, a4_in2, a4_out);\nfpgreaterthan #(Q1,N) fpgt1(gt1_in1,gt1_in2,gt1);\n\n\n\nacosf acosf0(startacosf,clk,rst,value,theta,doneacosf);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalways@(posedge clk or negedge rst)     \nbegin\n\n\tif (rst == 1'b0)\n\t\tSTATE <= START;\n\telse\n\t\tSTATE <= NEXT_STATE;\n\nend\n\n\nalways@(*)                              \nbegin\n\tcase(STATE)\n\n\tSTART:\n\tbegin\n\t\tif(startltl)\n\t\tbegin\n\t\t\tNEXT_STATE = INIT;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START;\n\t\tend\n\tend\n\n\tINIT:\n\tbegin\n\t\tNEXT_STATE = PRE_CALC_PQ;\n\tend\n\t\n\tSET_AK_ADDR:\n\tbegin\n\t\tNEXT_STATE = PRE_GET_AK;\n\tend\n\t\n\t\t\t\n\tPRE_GET_AK:\n\tbegin\n\t\tNEXT_STATE = GET_AK;\t\n\tend\n\n\tGET_AK:\n\tbegin\n\t\tNEXT_STATE = INCR_J;\n\tend\n\t\n\tINCR_J:\n\tbegin\n\t\tNEXT_STATE = CHECK_J;\n\tend\n\t\n\tCHECK_J:\n\tbegin\n\t\tif(j <= 4'd11)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_AK_ADDR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = PRE_CALC_PQ;\n\t\tend\n\tend\n\t\n\tPRE_CALC_PQ:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ1;\n\tend\n\t\n\tCALC_PQ1:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ2;\n\tend\n\t\n\tCALC_PQ2:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ3;\n\tend\n\t\n\tCALC_PQ3:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ4;\n\tend\n\t\n\tCALC_PQ4:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ5;\n\tend\n\t\n\tCALC_PQ5:\n\tbegin\n\t\tNEXT_STATE = CALC_PQ;\n\tend\n\t\n\tCALC_PQ:\n\tbegin\n\t\tNEXT_STATE = DOUBLE_PQ;\n\tend\n\t\n\tDOUBLE_PQ:\n\tbegin\n\t\tNEXT_STATE = SET_COEFF;\n\tend\n\t\n\tSET_COEFF:\n\tbegin\n\t\tif(donecp1)\n\t\tbegin\n\t\t\tNEXT_STATE = CALC_PSUM1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = SET_COEFF;\n\t\tend\n\tend\n\t\n\tCALC_PSUM1:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\n\tSET_WHILE:\n\tbegin\n\t\tNEXT_STATE = CHECK_WHILE;\n\tend\t\n\n\tCHECK_WHILE:\n\tbegin\n\t\tif(flag && (gt1 || (xr == NUMBER_NEG_ONE)))\n\t\tbegin\n\t\t\tNEXT_STATE = CALC_XR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = INCR_I;\n\t\tend\n\tend\t\n\t\n\tINCR_I:\n\tbegin\n\t\tNEXT_STATE = CHECK_I;\n\tend\n\t\n\tCHECK_I:\n\tbegin\n\t\tif(i < ORDER)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_COEFF;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = INIT_ACOSF;\n\t\tend\n\t\n\tend\n\n\tCALC_XR:\n\tbegin\n\t\tNEXT_STATE = OUT_XR;\n\tend\n\t\n\tOUT_XR:\n\tbegin\n\t\tNEXT_STATE = RUN_OUT_XR;\n\tend\n\t\n\tRUN_OUT_XR:\n\tbegin\n\t\tif(donecp2)\n\t\tbegin\n\t\t\tNEXT_STATE = SET_PSUMR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = RUN_OUT_XR;\n\t\tend\n\tend\n\t\n\tSET_PSUMR:\n\tbegin\n\t\tNEXT_STATE = SET_TEMPS;\n\tend\n\t\n\tSET_TEMPS:\n\tbegin\n\t\tNEXT_STATE = CHECK_IF;\n\tend\n\t\n\tCHECK_IF:\n\tbegin\n\t\tif((psumr[N-1] ==  1 && psum1[N-1] == 0) || \n\t\t\t(psumr[N-1] ==  0 && psum1[N-1] == 1) ||\n\t\t\t(psumr == 32'b0))\n\t\tbegin\n\t\t\tNEXT_STATE = INIT_IF;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t   NEXT_STATE = IF_FALSE;\n\t\tend\n\tend\n\t\n\tINIT_IF:\n\tbegin\n\t\tNEXT_STATE = CHECK_K;\n\tend\n\n\tCHECK_K:\n\tbegin\n\t\tif(k <= NB)\n\t\tbegin\n\t\t\tNEXT_STATE = ADD_XM;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = SET_FREQ;\n\t\tend\n\tend\n\t\n\tADD_XM:\n\tbegin\n\t\tNEXT_STATE = OUT_XM;\n\tend\n\n\tOUT_XM:\n\tbegin\n\t\tNEXT_STATE = INIT_PSUMM;\n\tend\n \n\t INIT_PSUMM:\n\tbegin\n\t\tNEXT_STATE = START_PSUMM;\n\tend \n\t\n\tSTART_PSUMM:\n\tbegin\n\t\tif(donecp3)\n\t\tbegin\n\t\t\tNEXT_STATE = OUT_PSUMM;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START_PSUMM;\n\t\tend\n\tend\n\n\tOUT_PSUMM:\n\tbegin\n\t\tNEXT_STATE = CHECK_IF_2;\n\tend\n\t\n\tCHECK_IF_2:\n\tbegin\n\t\tif((psumm[N-1] == 1 && psum1[N-1] == 1) || (psumm[N-1] == 0 && psum1[N-1] == 0))\n\t\tbegin\n\t\t\tNEXT_STATE = IF2_TRUE;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = IF2_FALSE;\n\t\tend\n\tend\n\t\n\tIF2_TRUE:\n\tbegin\n\t\tNEXT_STATE = INCR_K;\n\tend\n\t\n\tIF2_FALSE:\n\tbegin\n\t\tNEXT_STATE = INCR_K;\n\tend\n\t\n\tINCR_K:\n\tbegin\n\t\tNEXT_STATE = CHECK_K;\n\tend\n\t\n\tSET_FREQ:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\t\n\tIF_FALSE:\n\tbegin\n\t\tNEXT_STATE = SET_WHILE;\n\tend\n\t\n\tINIT_ACOSF:\n\tbegin\n\t\tNEXT_STATE = START_ACOSF;\n\tend\n\t\n\tSTART_ACOSF:\n\tbegin\n\t\tNEXT_STATE = CALC_FREQ_ACOSF;\n\tend\n\t\n\tCALC_FREQ_ACOSF:\n\tbegin\n\t\tif(doneacosf)\n\t\t\tbegin\n\t\t\t\tNEXT_STATE = SET_FREQ_ACOSF;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tNEXT_STATE = CALC_FREQ_ACOSF;\n\t\t\tend\n\tend\n\t\n\tSET_FREQ_ACOSF:\n\tbegin\n\t\tNEXT_STATE = INCR_ACOSF;\n\tend\n\t\n\tINCR_ACOSF:\n\tbegin\n\t\tNEXT_STATE = CHECK_ACOSF;\n\tend\n\t\n\tCHECK_ACOSF:\n\tbegin\n\t\tif(ac >= 4'd10)\n\t\tbegin\n\t\t\tNEXT_STATE = DONE;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tNEXT_STATE = START_ACOSF;\n\t\tend\n\t\t\n\tend\n\t\n\tDONE:\n\tbegin\n\t\tNEXT_STATE = START;\n\tend\n\n\tdefault:\n\tbegin\n\t\tNEXT_STATE = DONE;\n\tend\n\n\tendcase\nend\n\n\nalways@(posedge clk or negedge rst)     \nbegin\n\n\tif (rst == 1'b0)\n\tbegin\n\n\t\tdoneltl <= 1'b0;\n\n\tend\n\n\telse\n\tbegin\n\t\tcase(STATE)\n\n\t\tSTART:\n\t\tbegin\n\t\t\tstartcp1 <= 1'b0;\n\t\t\tstartcp2 <= 1'b0;\n\t\t\tstartcp3 <= 1'b0;\n\t\t\tstartacosf <= 1'b0;\n\t\t\tcount <= 6'd0;\n\t\t\txm <= 32'b0;\n\t\t\tdoneltl <= 1'd0;\n\t\t\t\n\t\t   \n\n\n\n\n\n\n\n\n\n\t\t\tak10 <= {8'h00,24'h159E3E};     // 0.08444589   */         // Actual from c code base; \n\t\t\t\n\t\t\t\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\n\t\t\t\n\t\t\tak0 <= {ak_0[N-1],ak_0[22:16],ak_0[15:0],8'b0};\n\t\t\tak1 <= {ak_1[N-1],ak_1[22:16],ak_1[15:0],8'b0};\n\t\t\tak2 <= {ak_2[N-1],ak_2[22:16],ak_2[15:0],8'b0};\n\t\t\tak3 <= {ak_3[N-1],ak_3[22:16],ak_3[15:0],8'b0};\n\t\t\tak4 <= {ak_4[N-1],ak_4[22:16],ak_4[15:0],8'b0};\n\t\t\tak5 <= {ak_5[N-1],ak_5[22:16],ak_5[15:0],8'b0};\n\t\t\tak6 <= {ak_6[N-1],ak_6[22:16],ak_6[15:0],8'b0};\n\t\t\tak7 <= {ak_7[N-1],ak_7[22:16],ak_7[15:0],8'b0};\n\t\t\tak8 <= {ak_8[N-1],ak_8[22:16],ak_8[15:0],8'b0};\n\t\t\tak9 <= {ak_9[N-1],ak_9[22:16],ak_9[15:0],8'b0};\n\t\t\tak10 <= {ak_10[N-1],ak_10[22:16],ak_10[15:0],8'b0};  \n\t\t\t\n\t\t\t\n\t\tend\n\n\t\tINIT:\n\t\tbegin\n\t\t\tdoneltl <= 1'b0;\n\t\t\txr <= 32'b0;\n\t\t\tx1 <= NUMBER_ONE;\n\t\t\tj <= 4'd0;\n\t\t\troots <= 4'd0;\n\t\tend\n\t\t\n\t\tSET_AK_ADDR:\n\t\tbegin\n\t\t\tak_addr <= j;\n\t\tend\n\t\t\n\t\tPRE_GET_AK:\n\t\tbegin\n\t\t\t\n\t\tend\n\n\t\tGET_AK:\n\t\tbegin\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tend\n\t\t\n\t\tINCR_J:\n\t\tbegin\n\t\t\tj <= j + 4'd1;\n\n\t\tend\n\t\t\n\t\tCHECK_J:\n\t\tbegin\n\t\t\n\t\tend\n\t\t\n\t\tPRE_CALC_PQ:\n\t\tbegin\n\t\t\tp0 <= NUMBER_ONE;\t\t\t\n\t\t\tq0 <= NUMBER_ONE;\n\t\t\t\n\t\t\ta1_in1 <= ak1;\n\t\t\ta1_in2 <= ak10;\n\t\t\t\n\t\t\ta2_in1 <= ak1;\n\t\t\ta2_in2 <= {(ak10[N-1] == 0)?1'b1:1'b0,ak10[N-2:0]};\n\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ1:\n\t\tbegin\n\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= NUMBER_NEG_ONE;\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= NUMBER_ONE;\n\t\t\t\t \n\t\t\ta1_in1 <= ak2;\n\t\t\ta1_in2 <= ak9;\n\t\t\t\t\n\t\t\ta2_in1 <= ak2;\n\t\t\ta2_in2 <= {(ak9[N-1] == 0)?1'b1:1'b0,ak9[N-2:0]};\n\t\t\t \n\t\t\t \n\t\tend\n\t\t\n\t\tCALC_PQ2:\n\t\tbegin\n\t\t\n\t\t\tp1 <= a3_out;\n\t\t\tq1 <= a4_out;\n\t\t\t\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak3;\n\t\t\ta1_in2 <= ak8;\n\t\t\t\t\n\t\t\ta2_in1 <= ak3;\n\t\t\ta2_in2 <= {(ak8[N-1] == 0)?1'b1:1'b0,ak8[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ3:\n\t\tbegin\n\t\t\n\t\t\tp2 <= a3_out;\n\t\t\tq2 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak4;\n\t\t\ta1_in2 <= ak7;\n\t\t\t\t\n\t\t\ta2_in1 <= ak4;\n\t\t\ta2_in2 <= {(ak7[N-1] == 0)?1'b1:1'b0,ak7[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ4:\n\t\tbegin\n\t\t\n\t\t\tp3 <= a3_out;\n\t\t\tq3 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\n\t\t\ta1_in1 <= ak5;\n\t\t\ta1_in2 <= ak6;\n\t\t\t\t\n\t\t\ta2_in1 <= ak5;\n\t\t\ta2_in2 <= {(ak6[N-1] == 0)?1'b1:1'b0,ak6[N-2:0]};\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ5:\n\t\tbegin\n\t\t\n\t\t\tp4 <= a3_out;\n\t\t\tq4 <= a4_out;\n\t\t\t\n\t\t\ta3_in1 <= a1_out;\n\t\t\ta3_in2 <= {(a3_out[N-1] == 0)?1'b1:1'b0,a3_out[N-2:0]};\n\t\t\t \n\t\t\ta4_in1 <= a2_out;\n\t\t\ta4_in2 <= a4_out;\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tCALC_PQ:\n\t\tbegin\n\t\t\n\t\t\tp5 <= a3_out;\n\t\t\tq5 <= a4_out;\n\t\t\t\n\t\t\ti <= 4'd0;\n\t\t\t\t\t\t\n\t\tend\n\t\t\n\t\tDOUBLE_PQ:\n\t\tbegin\n\t\t\tp0 <= {p0[N-1], p0[N-2 : 0] << 1};\n\t\t\tp1 <= {p1[N-1], p1[N-2 : 0] << 1};\n\t\t\tp2 <= {p2[N-1], p2[N-2 : 0] << 1};\n\t\t\tp3 <= {p3[N-1], p3[N-2 : 0] << 1};\n\t\t\tp4 <= {p4[N-1], p4[N-2 : 0] << 1};\n\t\t\t\n\t\t\tq0 <= {q0[N-1], q0[N-2 : 0] << 1};\n\t\t\tq1 <= {q1[N-1], q1[N-2 : 0] << 1};\n\t\t\tq2 <= {q2[N-1], q2[N-2 : 0] << 1};\n\t\t\tq3 <= {q3[N-1], q3[N-2 : 0] << 1};\n\t\t\tq4 <= {q4[N-1], q4[N-2 : 0] << 1};\n\t\tend\n\t\t\n\t\tINCR_I:\n\t\tbegin\n\t\t\ti <= i + 4'd1;\n\t\tend\n\t\t\n\t\tCHECK_I:\n\t\tbegin\n\t\t\t\n\t\tend\n\n\t\tSET_COEFF:\n\t\tbegin\n\t\t\n\t\t\n\t\t\tstartcp1 <= 1'b1;\n\t\t\t\n\t\t\tx_1 <= x1;\n\t\t\tif(!(i % 4'd2))\n\t\t\tbegin\n\t\t\t\tcoeff0 <= p0;\n\t\t\t\tcoeff1 <= p1;\n\t\t\t\tcoeff2 <= p2;\n\t\t\t\tcoeff3 <= p3;\n\t\t\t\tcoeff4 <= p4;\n\t\t\t\tcoeff5 <= p5;\n\t\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tcoeff0 <= q0;\n\t\t\t\tcoeff1 <= q1;\n\t\t\t\tcoeff2 <= q2;\n\t\t\t\tcoeff3 <= q3;\n\t\t\t\tcoeff4 <= q4;\n\t\t\t\tcoeff5 <= q5;\n\t\t\t\n\t\t\tend\n\t\tend\n\t\t\n\t\t\n\t\t\n\t\tCALC_PSUM1:\n\t\tbegin\n\t\t\t\n\t\t\tpsum1 <= sum1;\t\t\n\t\t\tflag <= 1'b1;\n\t\t\tstartcp1 <= 1'b0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\tend\n\n\t\tSET_WHILE:\n\t\tbegin\n\t\t\tgt1_in1 <= xr;\n\t\t\tgt1_in2 <= NUMBER_NEG_ONE;\n\t\tend\t\n\n\t\tCHECK_WHILE:\n\t\tbegin\n\t\t\t\n\t\tend\t\n\n\t\tCALC_XR:\n\t\tbegin\n\t\t\ta1_in1 <= x1;\n\t\t\ta1_in2 <= {(DELTA[N-1] == 0)?1'b1:1'b0,DELTA[N-2:0]};\n\t\t\t\n\t\t\tcount <= count + 6'd1;\n\t\t\t\n\t\tend\n\t\t\n\t\tOUT_XR:\n\t\tbegin\n\t\t\txr <= a1_out;\n\t\t\tx_2 <= a1_out;\n\t\t\tstartcp2 <= 1'b1;\n\t\t\t\n\t\tend\n\t\t\n\t\tRUN_OUT_XR:\n\t\tbegin\n\t\t\tstartcp2 <= 1'b0;\n\t\tend\n\t\t\n\n\t\tSET_PSUMR:\n\t\tbegin\n\t\t\tpsumr <= sum2;\n\t\n\t\tend\n\t\t\n\t\tSET_TEMPS:\n\t\tbegin\n\t\t\ttemp_psumr <= psumr;\n\t\t\ttemp_xr <= xr;\t\t\n\t\tend\n\t\t\n\t\tCHECK_IF:\n\t\tbegin\n\n\t\tend\n\t\t\n\t\tINIT_IF:\n\t\tbegin\n\t\t\troots <= roots + 4'd1;\n\t\t\tpsumm <= psum1;\n\t\t\tk <= 4'd0;\n\t\tend\n\n\t\tCHECK_K:\n\t\tbegin\n\t\t\t\n\t\tend\n\t\t\n\t\tADD_XM:\n\t\tbegin\n\t\t\ta1_in1 <= x1;\n\t\t\ta1_in2 <= xr;\n\t\tend\n\n\t\tOUT_XM:\n\t\tbegin\n\n\t\t\txm <= {a1_out[N-1],a1_out[N-2:0] >> 1};\n\t\t\t\n\t\tend\n\t \n\t\tINIT_PSUMM:\n\t\tbegin\n\n\t\t\tx_3 <= xm;\n\t\t\tstartcp3 <= 1'b1;\n\t\n\t\tend\n\t\t\n\t\tSTART_PSUMM:\n\t\tbegin\n\t\t\tstartcp3 <= 1'b0;\n\t\tend \n\n\t\tOUT_PSUMM:\n\t\tbegin\n\t\t\tpsumm <= sum3;\n\n\t\tend\n\t\t\n\t\tCHECK_IF_2:\n\t\tbegin\n\t\t\tif(i == 4'd0 && k == 4'd1)\n\t\t\tbegin\n\t\t\t\tc_psum <= psumm;\n\t\t\t\tc_sig <= xm ;\n\t\t\tend\n\t\tend\n\t\t\n\t\tIF2_TRUE:\n\t\tbegin\n\t\t\tpsum1 <= psumm;\n\t\t\tx1 \t<= xm;\n\t\tend\n\t\t\n\t\tIF2_FALSE:\n\t\tbegin\n\t\t\tpsumr <= psumm;\n\t\t\txr    <= xm;\n\t\t\t\n\t\t\t\n\t\tend\n\t\t\n\t\tINCR_K:\n\t\tbegin\n\t\t\tk <= k + 4'd1;\n\t\tend\n\t\t\n\t\tSET_FREQ:\n\t\tbegin\n\t\t\tcase(i)\n\t\t\t4'd0: freq0 <= xm;\n\t\t\t4'd1: freq1 <= xm;\n\t\t\t4'd2: freq2 <= xm;\n\t\t\t4'd3: freq3 <= xm;\n\t\t\t4'd4: freq4 <= xm;\n\t\t\t4'd5: freq5 <= xm;\n\t\t\t4'd6: freq6 <= xm;\n\t\t\t4'd7: freq7 <= xm;\n\t\t\t4'd8: freq8 <= xm;\n\t\t\t4'd9: freq9 <= xm;\n\t\t\tendcase\n\t\t\t\n\t\t\tx1 <= xm;\n\t\t\tflag = 1'b0;\n\t\t\t\n\t\tend\n\t\t\n\t\tIF_FALSE:\n\t\tbegin\n\t\t\tpsum1 <= temp_psumr;\n\t\t\tx1 \t<= temp_xr;\n\t\tend\n\t\t\n\t\tINIT_ACOSF:\n\t\tbegin\n\t\t\tac <= 4'd0;\n\t\t\t\n\t\tend\n\t\t\n\t\tSTART_ACOSF:\n\t\tbegin\n\t\t\tstartacosf <= 1'b1;\n\t\t\t\n\t\t\tcase(ac)\n\t\t\t4'd0: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq0[N-1],8'b0,freq0[30:24],freq0[23:8]};\n\t\t\tend\n\t\t\t4'd1: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq1[N-1],8'b0,freq1[30:24],freq1[23:8]};\n\t\t\tend\n\t\t\t4'd2: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq2[N-1],8'b0,freq2[30:24],freq2[23:8]};\n\t\t\tend\n\t\t\t4'd3: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq3[N-1],8'b0,freq3[30:24],freq3[23:8]};\n\t\t\tend\n\t\t\t4'd4: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq4[N-1],8'b0,freq4[30:24],freq4[23:8]};\n\t\t\tend\n\t\t\t4'd5: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq5[N-1],8'b0,freq5[30:24],freq5[23:8]};\n\t\t\tend\n\t\t\t4'd6: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq6[N-1],8'b0,freq6[30:24],freq6[23:8]};\n\t\t\tend\n\t\t\t4'd7: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq7[N-1],8'b0,freq7[30:24],freq7[23:8]};\n\t\t\tend\n\t\t\t4'd8: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq8[N-1],8'b0,freq8[30:24],freq8[23:8]};\n\t\t\tend\n\t\t\t4'd9: \n\t\t\tbegin\n\t\t\t\tvalue <= {freq9[N-1],8'b0,freq9[30:24],freq9[23:8]};\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\t\n\t\tCALC_FREQ_ACOSF:\n\t\tbegin\n\t\t\tstartacosf <= 1'b0;\n\t\t\t\n\t\t\t\n\t\tend\n\t\t\n\t\tSET_FREQ_ACOSF:\n\t\tbegin\n\t\t\n\t\t\tcase(ac)\n\t\t\t4'd0: \n\t\t\tbegin\n\t\t\t\tfreq0  <=  theta;\n\t\t\tend\n\t\t\t4'd1: \n\t\t\tbegin\n\t\t\t\tfreq1  <=  theta;\n\t\t\tend\n\t\t\t4'd2: \n\t\t\tbegin\n\t\t\t\tfreq2  <=  theta;\n\t\t\tend\n\t\t\t4'd3: \n\t\t\tbegin\n\t\t\t\tfreq3  <=  theta;\n\t\t\tend\n\t\t\t4'd4: \n\t\t\tbegin\n\t\t\t\tfreq4  <=  theta;\n\t\t\tend\n\t\t\t4'd5: \n\t\t\tbegin\n\t\t\t\tfreq5  <=  theta;\n\t\t\tend\n\t\t\t4'd6: \n\t\t\tbegin\n\t\t\t\tfreq6  <=  theta;\n\t\t\tend\n\t\t\t4'd7: \n\t\t\tbegin\n\t\t\t\tfreq7  <=  theta;\n\t\t\tend\n\t\t\t4'd8: \n\t\t\tbegin\n\t\t\t\tfreq8  <=  theta;\n\t\t\tend\n\t\t\t4'd9: \n\t\t\tbegin\n\t\t\t\tfreq9  <=  theta;\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\t\n\t\tINCR_ACOSF:\n\t\tbegin\n\t\t\tac <= ac + 4'd1;\n\t\tend\n\t\t\n\t\tCHECK_ACOSF:\n\t\tbegin\n\t\t\t\n\t\tend\n\t\n\n\t\tDONE:\n\t\tbegin\n\t\t\tdoneltl <= 1'b1;\n\t\tend\n\n\t\tendcase\n\tend\n\nend\n\n\nendmodule</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: lpc_to_lsp. Module specification: This module implements a Linear Predictive Coding (LPC) to Line Spectral Pairs (LSP) conversion algorithm. It takes LPC coefficients as input and converts them to LSP frequencies. The module has input ports for start signal (startltl), clock (clk), reset (rst), LPC coefficients (ak_out, ak_0 to ak_10), and output ports for LSP frequencies (freq0 to freq9), done signal (doneltl), address for accessing LPC coefficients (ak_addr), and intermediate calculation results (c_psum, c_sig). Internally, it uses various signals for state management, counters, polynomial coefficients, and intermediate calculations. The module is structured with a finite state machine controlling the conversion process, which includes initializing variables, calculating polynomial coefficients, finding roots of polynomials,"
                }
            ]
        }
    ]
}