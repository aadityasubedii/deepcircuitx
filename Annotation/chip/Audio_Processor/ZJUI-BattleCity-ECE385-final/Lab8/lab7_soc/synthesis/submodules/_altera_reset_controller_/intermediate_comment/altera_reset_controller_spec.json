{
    "spec": "Module name: altera_reset_controller. \n\nModule specification:\n\nThe altera_reset_controller is a FPGA-based module primarily designed to process multiple reset and reset request signals, synchronize them and then generate a solitary, de-bounced and edge-detectable reset signal. It uses 16 reset inputs named 'reset_in[0-15]' and similarly 16 'reset_req_in[0-15]', and a clock signal 'clk'. The output from this module includes 'reset_out', providing the final, processed reset signal, and 'reset_req', indicating whether a reset is requested or not.\n\nThe internal signals such as 'merged_reset', 'merged_reset_req_in', 'reset_out_pre', 'reset_req_pre', 'altera_reset_synchronizer_int_chain', 'r_sync_rst_chain', 'r_sync_rst', 'r_early_rst', 'reset_out_pre2' play key roles in merging, synchronizing and buffering the reset and reset request signals.\n\nThe code is divided into different blocks or sections to handle different functionalities. The initialization parameters at the beginning of the module allow customization of reset requirements including synchronization depth, wait time, the requirement of reset request signals etc. The block after input, output declarations set the parameters which will be used later in signal processing. Following blocks work on merging all the inputs into single, pre-processing the merged inputs, and then creating the final, post-processed 'reset_out' and 'reset_req'. The final always block contains the logic to form synchronized 'reset_out' and 'reset_req'.\n\nThe module ensures proper synchronization and debouncing, and it assists in avoiding system metastability, thus enhancing the reliability and robustness of the rest of the FPGA design.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller.\nExplanation: This module is a reset controller function in Altera FPGA design. It takes multiple reset signals and reset requests, synchronizes them, and combines them into a single, de-bounced, and edge-detectable reset signal, which is then output to the rest of the FPGA design. The behavior of the reset signal depends on the parameters given to the module. These parameters include the number of reset inputs, use of reset requests, sync depth, reset request wait time, minimum reset assertion time, etc. The generated reset signal is safer to use than the raw input reset signals because it has been synchronized and de-bounced to avoid instability caused by signal metastability in digital circuits. This module also supports additional functions such as early deassertion and reset requests."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset_in[0-15] - These ports accept reset signals. The module combines these reset signals into a single, de-bounced, and edge-detectable output reset signal.\n2. reset_req_in[0-15] - These ports accept reset request signals. If the parameter values indicate to use these reset request signals, then the reset request signals are factored in during output reset signal generation.\n3. clk - This is the clock signal input. The synchronization of the reset signals is done based on this clock signal.\n\nOutput ports: \n1. reset_out - This port outputs the processed reset signal that is synchronized, de-bounced and edge-detectable. It can be directly used by other parts of the FPGA design.\n2. reset_req - This port outputs a combined and synchronized reset request signal. This signal indicates whether a reset is requested or not.\n\nExplanation:\nThe input ports accept multiple reset and reset request signals along with the clock. The module processes these signals, synchronizes them according to the clock signal, de-bounces them, and combines them into a single reset signal. This processed signal is then outputted via the 'reset_out' output port. Simultaneously, a reset request signal indicating whether or not a reset is requested is outputted via the 'reset_req' output port. The output signals ensure safer use in rest of the design due to their synchronized and de-bounced characteristics."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: \n\n1. merged_reset\n2. merged_reset_req_in\n3. reset_out_pre\n4. reset_req_pre\n5. altera_reset_synchronizer_int_chain\n6. r_sync_rst_chain\n7. r_sync_rst\n8. r_early_rst\n9. reset_out_pre2\n\nExplanation: \n\n1. merged_reset: It is a combined or merged form of all the input reset signals 'reset_in[0-15]'. This internal signal is used as an intermediate synchronized reset signal for computations in some conditional logic.\n\n2. merged_reset_req_in: Similar to 'merged_reset', it is a combined form of all the reset request signals 'reset_req_in[0-15]' based on the parameter 'USE_RESET_REQUEST_IN[0-15]'. This plays a role in the generation of the synchronized reset request signal and is also used in some conditional logic.\n\n3. reset_out_pre: This is an internal signal which works as an intermediate stage for the output reset signal. After the merged_reset signal is processed, the result is loaded onto 'reset_out_pre'.\n\n4. reset_req_pre: Similar to 'reset_out_pre', this signal acts as an intermediate stage for the output reset request signal.\n\n5. altera_reset_synchronizer_int_chain: This is an internal shift register chain used to delay the reset signal and help in synchronizing the reset signal. This helps prevent issues caused by signal metastability.\n\n6. r_sync_rst_chain: This chain is used to handle the reset assertion time and helps in syncing the reset signal.\n\n7. r_sync_rst: This signal is derived from the 'r_sync_rst_chain' and 'altera_reset_synchronizer_int_chain'. It represents the final synchronized reset signal before being assigned to the output 'reset_out'. \n\n8. r_early_rst: It represents an early, synchronized reset request signal before being assigned to the output 'reset_req'. It is derived from the 'r_sync_rst_chain' and 'reset_req_pre'.\n\n9. reset_out_pre2: An intermediate signal produced during the processing of 'reset_out_pre' when 'ADAPT_RESET_REQUEST' parameter is set to 1. It serves as an additional level of syncing before assigning to 'reset_out'."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_reset_controller. \n\nModule specification:\n\nThe altera_reset_controller is a FPGA-based module primarily designed to process multiple reset and reset request signals, synchronize them and then generate a solitary, de-bounced and edge-detectable reset signal. It uses 16 reset inputs named 'reset_in[0-15]' and similarly 16 'reset_req_in[0-15]', and a clock signal 'clk'. The output from this module includes 'reset_out', providing the final, processed reset signal, and 'reset_req', indicating whether a reset is requested or not.\n\nThe internal signals such as 'merged_reset', 'merged_reset_req_in', 'reset_out_pre', 'reset_req_pre', 'altera_reset_synchronizer_int_chain', 'r_sync_rst_chain', 'r_sync_rst', 'r_early_rst', 'reset_out_pre2' play key roles in merging, synchronizing and buffering the reset and reset request signals.\n\nThe code is divided into different blocks or sections to handle different functionalities. The initialization parameters at the beginning of the module allow customization of reset requirements including synchronization depth, wait time, the requirement of reset request signals etc. The block after input, output declarations set the parameters which will be used later in signal processing. Following blocks work on merging all the inputs into single, pre-processing the merged inputs, and then creating the final, post-processed 'reset_out' and 'reset_req'. The final always block contains the logic to form synchronized 'reset_out' and 'reset_req'.\n\nThe module ensures proper synchronization and debouncing, and it assists in avoiding system metastability, thus enhancing the reliability and robustness of the rest of the FPGA design."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller.\nExplanation: This module is a reset controller function in Altera FPGA design. It takes multiple reset signals and reset requests, synchronizes them, and combines them into a single, de-bounced, and edge-detectable reset signal, which is then output to the rest of the FPGA design. The behavior of the reset signal depends on the parameters given to the module. These parameters include the number of reset inputs, use of reset requests, sync depth, reset request wait time, minimum reset assertion time, etc. The generated reset signal is safer to use than the raw input reset signals because it has been synchronized and de-bounced to avoid instability caused by signal metastability in digital circuits. This module also supports additional functions such as early deassertion and reset requests."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset_in[0-15] - These ports accept reset signals. The module combines these reset signals into a single, de-bounced, and edge-detectable output reset signal.\n2. reset_req_in[0-15] - These ports accept reset request signals. If the parameter values indicate to use these reset request signals, then the reset request signals are factored in during output reset signal generation.\n3. clk - This is the clock signal input. The synchronization of the reset signals is done based on this clock signal.\n\nOutput ports: \n1. reset_out - This port outputs the processed reset signal that is synchronized, de-bounced and edge-detectable. It can be directly used by other parts of the FPGA design.\n2. reset_req - This port outputs a combined and synchronized reset request signal. This signal indicates whether a reset is requested or not.\n\nExplanation:\nThe input ports accept multiple reset and reset request signals along with the clock. The module processes these signals, synchronizes them according to the clock signal, de-bounces them, and combines them into a single reset signal. This processed signal is then outputted via the 'reset_out' output port. Simultaneously, a reset request signal indicating whether or not a reset is requested is outputted via the 'reset_req' output port. The output signals ensure safer use in rest of the design due to their synchronized and de-bounced characteristics."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: \n\n1. merged_reset\n2. merged_reset_req_in\n3. reset_out_pre\n4. reset_req_pre\n5. altera_reset_synchronizer_int_chain\n6. r_sync_rst_chain\n7. r_sync_rst\n8. r_early_rst\n9. reset_out_pre2\n\nExplanation: \n\n1. merged_reset: It is a combined or merged form of all the input reset signals 'reset_in[0-15]'. This internal signal is used as an intermediate synchronized reset signal for computations in some conditional logic.\n\n2. merged_reset_req_in: Similar to 'merged_reset', it is a combined form of all the reset request signals 'reset_req_in[0-15]' based on the parameter 'USE_RESET_REQUEST_IN[0-15]'. This plays a role in the generation of the synchronized reset request signal and is also used in some conditional logic.\n\n3. reset_out_pre: This is an internal signal which works as an intermediate stage for the output reset signal. After the merged_reset signal is processed, the result is loaded onto 'reset_out_pre'.\n\n4. reset_req_pre: Similar to 'reset_out_pre', this signal acts as an intermediate stage for the output reset request signal.\n\n5. altera_reset_synchronizer_int_chain: This is an internal shift register chain used to delay the reset signal and help in synchronizing the reset signal. This helps prevent issues caused by signal metastability.\n\n6. r_sync_rst_chain: This chain is used to handle the reset assertion time and helps in syncing the reset signal.\n\n7. r_sync_rst: This signal is derived from the 'r_sync_rst_chain' and 'altera_reset_synchronizer_int_chain'. It represents the final synchronized reset signal before being assigned to the output 'reset_out'. \n\n8. r_early_rst: It represents an early, synchronized reset request signal before being assigned to the output 'reset_req'. It is derived from the 'r_sync_rst_chain' and 'reset_req_pre'.\n\n9. reset_out_pre2: An intermediate signal produced during the processing of 'reset_out_pre' when 'ADAPT_RESET_REQUEST' parameter is set to 1. It serves as an additional level of syncing before assigning to 'reset_out'."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_reset_controller. \n\nModule specification:\n\nThe altera_reset_controller is a FPGA-based module primarily designed to process multiple reset and reset request signals, synchronize them and then generate a solitary, de-bounced and edge-detectable reset signal. It uses 16 reset inputs named 'reset_in[0-15]' and similarly 16 'reset_req_in[0-15]', and a clock signal 'clk'. The output from this module includes 'reset_out', providing the final, processed reset signal, and 'reset_req', indicating whether a reset is requested or not.\n\nThe internal signals such as 'merged_reset', 'merged_reset_req_in', 'reset_out_pre', 'reset_req_pre', 'altera_reset_synchronizer_int_chain', 'r_sync_rst_chain', 'r_sync_rst', 'r_early_rst', 'reset_out_pre2' play key roles in merging, synchronizing and buffering the reset and reset request signals.\n\nThe code is divided into different blocks or sections to handle different functionalities. The initialization parameters at the beginning of the module allow customization of reset requirements including synchronization depth, wait time, the requirement of reset request signals etc. The block after input, output declarations set the parameters which will be used later in signal processing. Following blocks work on merging all the inputs into single, pre-processing the merged inputs, and then creating the final, post-processed 'reset_out' and 'reset_req'. The final always block contains the logic to form synchronized 'reset_out' and 'reset_req'.\n\nThe module ensures proper synchronization and debouncing, and it assists in avoiding system metastability, thus enhancing the reliability and robustness of the rest of the FPGA design."
                }
            ]
        }
    ]
}