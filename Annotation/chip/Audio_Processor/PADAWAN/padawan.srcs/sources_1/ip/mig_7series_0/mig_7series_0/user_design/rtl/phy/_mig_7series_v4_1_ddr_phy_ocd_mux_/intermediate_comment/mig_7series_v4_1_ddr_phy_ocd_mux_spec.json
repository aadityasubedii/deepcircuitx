{
    "spec": "Module name: mig_7series_v4_1_ddr_phy_ocd_mux. \n\nModule specification: This module is a part of a DDR memory interface which mainly provides control over the output clock delay (OCD). It differentiates the control signals into appropriate behavior for stage2 and stage3. It also handles the left and right KTAP signals and edge detection through controlling signals. Important code sections are designed around reset and control operations, with edge detection contributing to the functionality. The module requires a clock and reset inputs, as well as multiple control signals to steer the action of the KTAP and edge detection as well as increment or decrement operations. Outputs from the module control the KTAP, edge detection readiness, and several stages of operation including setting count for the PLL. \n\nInternally used signals cater to different parts of the system, including set up, changes, incremental processes and ready states. For instance, 'clogb2' calculates the base 2 logarithm, 'PO_WAIT' provides the wait state prior to setup and changes, 'setup_po' signal detects necessary setup changes, 'po_en_stg23_ns' along with 'po_en_stg23_r' determines the current and future states of stage 2 and stage 3 enablement, and 'wl_po_fine_shifted' is a count selector for the phase-locked loop post shifting based on the calibration count etc.\n\nThe module's Verilog code is clearly divided into different sections: parameter declarations, input and output declarations, internal signal definitions, logic implementation, and functional routines. This ensures a clean, efficient structure with minimal redundancy and an emphasis on reusability and modularity. Procedures for the next-stage setup, increment or decrement operations, and the readiness of the system are to be found in the 'always' blocks of the codes. Also, a pre-defined function 'clogb2()' is used for calculating the base 2 logarithm.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_ocd_mux.\nExplanation: This module forms a part of a DDR interface; specifically, it controls the output clock delay through different controlling signals. It differentiates the control signals into suitable behavior for stage3 or stage2 and stage3. It evaluates the edge detection and handles left and right KTAP signals. The required condition is known using the reset signal, setup signals, input signals. The module is designed based on the reset signal and clock inputs to function properly. It uses several internal variables to keep track of the state of the inputs. Furthermore, it manipulates the input signals to create output signals that are appropriate for the countdown, setup, and output requests."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. clk: This is the clock signal for the module.\n\n2. rst: This is the reset signal for the module.\n\n3. ocd_ktap_right, ocd_ktap_left: These are input signals that help the module decide if the ktap is at the right or left edge.\n\n4. lim2poc_ktap_right: This signal is used to help decide if the ktap is at the right edge.\n\n5. lim2poc_rdy, ocd_edge_detect_rdy: These signals are used to indicate if the edge has been detected.\n\n6. lim2stg2_inc, lim2stg2_dec, lim2stg3_inc, lim2stg3_dec: Signals used for controlling the increment or decrement of Stage 2 or Stage 3.\n\n7. ocd2stg2_inc, ocd_cntlr2stg2_dec, ocd2stg2_dec, ocd2stg3_inc, ocd2stg3_dec: Signals from the OCD module for controlling Stage 2 or Stage 3.\n\n8. wl_po_fine_cnt, oclkdelay_calib_cnt: These signals are used to select a count for the phase-locked loop (PLL).\n\n9. lim2init_prech_req, ocd_prech_req: These signals are used to signal if a precharge is required.\n\nOutput Ports:\n\n1. ktap_at_left_edge, ktap_at_right_edge: These signals indicate if ktap is at the left or right edge.\n\n2. mmcm_edge_detect_rdy: This signal indicates if the edge detection is ready.\n\n3. po_stg3_incdec, po_en_stg3, po_en_stg23, po_stg23_sel, po_stg23_incdec, po_rdy: These signals are used for controlling Stage 3 or Stage 2 and 3.\n\n4. wl_po_fine_cnt_sel: This signal is used to select a count output based. \n\n5. oclk_prech_req: This signals request the precharge of clock."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n1. Internal signals:\n\n  - clogb2\n  - PO_WAIT\n  - POW_WIDTH\n  - ONE\n  - TWO\n  - setup_po\n  - po_setup_ns\n  - po_setup_r\n  - po_en_stg23_ns\n  - po_en_stg23_r\n  - sel_stg3\n  - po_wait_r\n  - po_wait_ns\n  - po_stg23_sel_ns\n  - po_stg23_sel_r\n  - po_inc\n  - po_stg23_incdec_r\n  - po_stg23_incdec_ns\n  - po_rdy_ns\n  - po_rdy_r\n  - wl_po_fine_shifted  \n\n2. Explanation:\n\n  - clogb2: A function used to compute the ceiling of the base 2 logarithm of an integer.\n  \n  - PO_WAIT: A local parameter used as the value for the wait state before setup and controls change.\n\n  - POW_WIDTH: Holds the value of the base 2 logarithm of PO_WAIT, essentially represents the number of bits required to express PO_WAIT.\n  \n  - ONE, TWO: These are just constants with the value of one and two respectively.\n  \n  - setup_po: This internal signal is used to detect whether any setup changes are required.\n  \n  - po_setup_ns, po_setup_r: These signals keep track of the current and next states of the setup of the phase-locked loop (PLL).\n  \n  - po_en_stg23_ns, po_en_stg23_r: These signals determine the current and future states of stage 2 and stage 3 enablement.\n  \n  - sel_stg3: This signal determines if stage 3 is selected for modification.\n  \n  - po_wait_r, po_wait_ns: These signals keep track of the current and next states of the PO_WAIT.\n  \n  - po_stg23_sel_ns, po_stg23_sel_r: These signals determine the current and future states of the selection between stage 2 and stage 3.\n  \n  - po_inc: The signal represents a request to increment a count.\n  \n  - po_stg23_incdec_r, po_stg23_incdec_ns: These signals control the increment or decrement of Stage 2 and Stage 3 based on the input requests.\n  \n  - po_rdy_ns, po_rdy_r: These signals show the current and next states of readiness for the PLL.\n  \n  - wl_po_fine_shifted: The signal is used to select a count in the phase-locked loop after shifting based on the calibration count."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule mig_7series_v4_1_ddr_phy_ocd_mux #\n  (parameter DQS_CNT_WIDTH   = 3,\n   parameter DQS_WIDTH       = 8,\n   parameter TCQ             = 100)\n  (\n  \n  ktap_at_left_edge, ktap_at_right_edge, mmcm_edge_detect_rdy,\n  po_stg3_incdec, po_en_stg3, po_en_stg23, po_stg23_sel,\n  po_stg23_incdec, po_rdy, wl_po_fine_cnt_sel, oclk_prech_req,\n  \n  clk, rst, ocd_ktap_right, ocd_ktap_left, lim2poc_ktap_right,\n  lim2poc_rdy, ocd_edge_detect_rdy, lim2stg2_inc, lim2stg2_dec,\n  lim2stg3_inc, lim2stg3_dec, ocd2stg2_inc, ocd2stg2_dec,\n  ocd_cntlr2stg2_dec, ocd2stg3_inc, ocd2stg3_dec, wl_po_fine_cnt,\n  oclkdelay_calib_cnt, lim2init_prech_req, ocd_prech_req\n  );\n\n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  localparam PO_WAIT = 15;\n  localparam POW_WIDTH = clogb2(PO_WAIT);\n  localparam ONE = 1;\n  localparam TWO = 2;\n\n  input clk;\n  input rst;\n\n  input ocd_ktap_right, ocd_ktap_left;\n  input lim2poc_ktap_right;\n  output ktap_at_left_edge, ktap_at_right_edge;\n  assign ktap_at_left_edge = ocd_ktap_left;\n  assign ktap_at_right_edge = lim2poc_ktap_right || ocd_ktap_right;\n  \n  input lim2poc_rdy;\n  input ocd_edge_detect_rdy;\n  output mmcm_edge_detect_rdy;\n  assign mmcm_edge_detect_rdy = lim2poc_rdy || ocd_edge_detect_rdy;\n  \n  \n  output po_stg3_incdec;\n  output po_en_stg3;\n  assign po_stg3_incdec = 1'b0;\n  assign po_en_stg3 = 1'b0;\n\n\n  reg [1:0] po_setup_ns, po_setup_r;\n  always @(posedge clk) po_setup_r <= #TCQ po_setup_ns;\n\n  input lim2stg2_inc;\n  input lim2stg2_dec;\n\n  input lim2stg3_inc;\n  input lim2stg3_dec;\n\n  input ocd2stg2_inc;\n  input ocd2stg2_dec;\n  input ocd_cntlr2stg2_dec;\n  \n  input ocd2stg3_inc;\n  input ocd2stg3_dec;\n\n  wire setup_po = \n       lim2stg2_inc || lim2stg2_dec || lim2stg3_inc || lim2stg3_dec ||\n       ocd2stg2_inc || ocd2stg2_dec || ocd2stg3_inc || ocd2stg3_dec || ocd_cntlr2stg2_dec;\n\n  always @(*) begin\n    po_setup_ns = po_setup_r;\n    if (rst) po_setup_ns = 2'b00;\n    else if (setup_po) po_setup_ns = 2'b11;\n    else if (|po_setup_r) po_setup_ns = po_setup_r - 2'b01;\n  end\n\n  reg po_en_stg23_r;\n  wire po_en_stg23_ns = ~rst && po_setup_r == 2'b01;\n  always @(posedge clk) po_en_stg23_r <= #TCQ po_en_stg23_ns;\n  output po_en_stg23;\n  assign po_en_stg23 = po_en_stg23_r; \n\n  wire sel_stg3 = lim2stg3_inc || lim2stg3_dec || ocd2stg3_inc || ocd2stg3_dec;\n\n  reg [POW_WIDTH-1:0] po_wait_r, po_wait_ns;\n  reg po_stg23_sel_r;\n  \n  \n  wire po_stg23_sel_ns = ~rst && (setup_po \n                                    ? sel_stg3\n                                       ? 1'b1 \n                                       : 1'b0 \n                                    : po_stg23_sel_r && !(po_wait_r == ONE[POW_WIDTH-1:0]));\n  always @(posedge clk) po_stg23_sel_r <= #TCQ po_stg23_sel_ns;\n  output po_stg23_sel;\n  assign po_stg23_sel = po_stg23_sel_r;\n\n  wire po_inc = lim2stg2_inc || lim2stg3_inc || ocd2stg2_inc || ocd2stg3_inc;\n\n  reg po_stg23_incdec_r;\n  wire po_stg23_incdec_ns = ~rst && (setup_po ? po_inc ? 1'b1 : 1'b0 : po_stg23_incdec_r);\n  always @(posedge clk) po_stg23_incdec_r <= #TCQ po_stg23_incdec_ns;\n  output po_stg23_incdec;\n  assign po_stg23_incdec = po_stg23_incdec_r;\n\n\n  always @(posedge clk) po_wait_r <= #TCQ po_wait_ns;\n  always @(*) begin\n    po_wait_ns = po_wait_r;\n    if (rst) po_wait_ns = {POW_WIDTH{1'b0}};\n    else if (po_en_stg23_r) po_wait_ns = PO_WAIT[POW_WIDTH-1:0] - ONE[POW_WIDTH-1:0];\n    else if (po_wait_r != {POW_WIDTH{1'b0}}) po_wait_ns = po_wait_r - ONE[POW_WIDTH-1:0];\t   \n  end\n  \n  wire po_rdy_ns = ~(setup_po || |po_setup_r || |po_wait_ns);\n  reg po_rdy_r;\n  always @(posedge clk) po_rdy_r <= #TCQ po_rdy_ns;\n  \n  output po_rdy;\n  assign po_rdy = po_rdy_r;\n\n  input [6*DQS_WIDTH-1:0] wl_po_fine_cnt;\n  input [DQS_CNT_WIDTH:0] oclkdelay_calib_cnt;\n  wire [6*DQS_WIDTH-1:0] wl_po_fine_shifted = wl_po_fine_cnt >> oclkdelay_calib_cnt*6;\n  output [5:0] wl_po_fine_cnt_sel;\n  assign wl_po_fine_cnt_sel = wl_po_fine_shifted[5:0];\n\n  input lim2init_prech_req;\n  input ocd_prech_req;\n  output oclk_prech_req;\n  assign oclk_prech_req = ocd_prech_req || lim2init_prech_req;\n\t\nendmodule \n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_ddr_phy_ocd_mux. \n\nModule specification: This module is a part of a DDR memory interface which mainly provides control over the output clock delay (OCD). It differentiates the control signals into appropriate behavior for stage2 and stage3. It also handles the left and right KTAP signals and edge detection through controlling signals. Important code sections are designed around reset and control operations, with edge detection contributing to the functionality. The module requires a clock and reset inputs, as well as multiple control signals to steer the action of the KTAP and edge detection as well as increment or decrement operations. Outputs from the module control the KTAP, edge detection readiness, and several stages of operation including setting count for the PLL. \n\nInternally used signals cater to different parts of the system, including set up, changes, incremental processes and ready states. For instance, 'clogb2' calculates the base 2 logarithm, 'PO_WAIT' provides the wait state prior to setup and changes, 'setup_po' signal detects necessary setup changes, 'po_en_stg23_ns' along with 'po_en_stg23_r' determines the current and future states of stage 2 and stage 3 enablement, and 'wl_po_fine_shifted' is a count selector for the phase-locked loop post shifting based on the calibration count etc.\n\nThe module's Verilog code is clearly divided into different sections: parameter declarations, input and output declarations, internal signal definitions, logic implementation, and functional routines. This ensures a clean, efficient structure with minimal redundancy and an emphasis on reusability and modularity. Procedures for the next-stage setup, increment or decrement operations, and the readiness of the system are to be found in the 'always' blocks of the codes. Also, a pre-defined function 'clogb2()' is used for calculating the base 2 logarithm."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_ocd_mux.\nExplanation: This module forms a part of a DDR interface; specifically, it controls the output clock delay through different controlling signals. It differentiates the control signals into suitable behavior for stage3 or stage2 and stage3. It evaluates the edge detection and handles left and right KTAP signals. The required condition is known using the reset signal, setup signals, input signals. The module is designed based on the reset signal and clock inputs to function properly. It uses several internal variables to keep track of the state of the inputs. Furthermore, it manipulates the input signals to create output signals that are appropriate for the countdown, setup, and output requests."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. clk: This is the clock signal for the module.\n\n2. rst: This is the reset signal for the module.\n\n3. ocd_ktap_right, ocd_ktap_left: These are input signals that help the module decide if the ktap is at the right or left edge.\n\n4. lim2poc_ktap_right: This signal is used to help decide if the ktap is at the right edge.\n\n5. lim2poc_rdy, ocd_edge_detect_rdy: These signals are used to indicate if the edge has been detected.\n\n6. lim2stg2_inc, lim2stg2_dec, lim2stg3_inc, lim2stg3_dec: Signals used for controlling the increment or decrement of Stage 2 or Stage 3.\n\n7. ocd2stg2_inc, ocd_cntlr2stg2_dec, ocd2stg2_dec, ocd2stg3_inc, ocd2stg3_dec: Signals from the OCD module for controlling Stage 2 or Stage 3.\n\n8. wl_po_fine_cnt, oclkdelay_calib_cnt: These signals are used to select a count for the phase-locked loop (PLL).\n\n9. lim2init_prech_req, ocd_prech_req: These signals are used to signal if a precharge is required.\n\nOutput Ports:\n\n1. ktap_at_left_edge, ktap_at_right_edge: These signals indicate if ktap is at the left or right edge.\n\n2. mmcm_edge_detect_rdy: This signal indicates if the edge detection is ready.\n\n3. po_stg3_incdec, po_en_stg3, po_en_stg23, po_stg23_sel, po_stg23_incdec, po_rdy: These signals are used for controlling Stage 3 or Stage 2 and 3.\n\n4. wl_po_fine_cnt_sel: This signal is used to select a count output based. \n\n5. oclk_prech_req: This signals request the precharge of clock."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n1. Internal signals:\n\n  - clogb2\n  - PO_WAIT\n  - POW_WIDTH\n  - ONE\n  - TWO\n  - setup_po\n  - po_setup_ns\n  - po_setup_r\n  - po_en_stg23_ns\n  - po_en_stg23_r\n  - sel_stg3\n  - po_wait_r\n  - po_wait_ns\n  - po_stg23_sel_ns\n  - po_stg23_sel_r\n  - po_inc\n  - po_stg23_incdec_r\n  - po_stg23_incdec_ns\n  - po_rdy_ns\n  - po_rdy_r\n  - wl_po_fine_shifted  \n\n2. Explanation:\n\n  - clogb2: A function used to compute the ceiling of the base 2 logarithm of an integer.\n  \n  - PO_WAIT: A local parameter used as the value for the wait state before setup and controls change.\n\n  - POW_WIDTH: Holds the value of the base 2 logarithm of PO_WAIT, essentially represents the number of bits required to express PO_WAIT.\n  \n  - ONE, TWO: These are just constants with the value of one and two respectively.\n  \n  - setup_po: This internal signal is used to detect whether any setup changes are required.\n  \n  - po_setup_ns, po_setup_r: These signals keep track of the current and next states of the setup of the phase-locked loop (PLL).\n  \n  - po_en_stg23_ns, po_en_stg23_r: These signals determine the current and future states of stage 2 and stage 3 enablement.\n  \n  - sel_stg3: This signal determines if stage 3 is selected for modification.\n  \n  - po_wait_r, po_wait_ns: These signals keep track of the current and next states of the PO_WAIT.\n  \n  - po_stg23_sel_ns, po_stg23_sel_r: These signals determine the current and future states of the selection between stage 2 and stage 3.\n  \n  - po_inc: The signal represents a request to increment a count.\n  \n  - po_stg23_incdec_r, po_stg23_incdec_ns: These signals control the increment or decrement of Stage 2 and Stage 3 based on the input requests.\n  \n  - po_rdy_ns, po_rdy_r: These signals show the current and next states of readiness for the PLL.\n  \n  - wl_po_fine_shifted: The signal is used to select a count in the phase-locked loop after shifting based on the calibration count."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule mig_7series_v4_1_ddr_phy_ocd_mux #\n  (parameter DQS_CNT_WIDTH   = 3,\n   parameter DQS_WIDTH       = 8,\n   parameter TCQ             = 100)\n  (\n  \n  ktap_at_left_edge, ktap_at_right_edge, mmcm_edge_detect_rdy,\n  po_stg3_incdec, po_en_stg3, po_en_stg23, po_stg23_sel,\n  po_stg23_incdec, po_rdy, wl_po_fine_cnt_sel, oclk_prech_req,\n  \n  clk, rst, ocd_ktap_right, ocd_ktap_left, lim2poc_ktap_right,\n  lim2poc_rdy, ocd_edge_detect_rdy, lim2stg2_inc, lim2stg2_dec,\n  lim2stg3_inc, lim2stg3_dec, ocd2stg2_inc, ocd2stg2_dec,\n  ocd_cntlr2stg2_dec, ocd2stg3_inc, ocd2stg3_dec, wl_po_fine_cnt,\n  oclkdelay_calib_cnt, lim2init_prech_req, ocd_prech_req\n  );\n\n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  localparam PO_WAIT = 15;\n  localparam POW_WIDTH = clogb2(PO_WAIT);\n  localparam ONE = 1;\n  localparam TWO = 2;\n\n  input clk;\n  input rst;\n\n  input ocd_ktap_right, ocd_ktap_left;\n  input lim2poc_ktap_right;\n  output ktap_at_left_edge, ktap_at_right_edge;\n  assign ktap_at_left_edge = ocd_ktap_left;\n  assign ktap_at_right_edge = lim2poc_ktap_right || ocd_ktap_right;\n  \n  input lim2poc_rdy;\n  input ocd_edge_detect_rdy;\n  output mmcm_edge_detect_rdy;\n  assign mmcm_edge_detect_rdy = lim2poc_rdy || ocd_edge_detect_rdy;\n  \n  \n  output po_stg3_incdec;\n  output po_en_stg3;\n  assign po_stg3_incdec = 1'b0;\n  assign po_en_stg3 = 1'b0;\n\n\n  reg [1:0] po_setup_ns, po_setup_r;\n  always @(posedge clk) po_setup_r <= #TCQ po_setup_ns;\n\n  input lim2stg2_inc;\n  input lim2stg2_dec;\n\n  input lim2stg3_inc;\n  input lim2stg3_dec;\n\n  input ocd2stg2_inc;\n  input ocd2stg2_dec;\n  input ocd_cntlr2stg2_dec;\n  \n  input ocd2stg3_inc;\n  input ocd2stg3_dec;\n\n  wire setup_po = \n       lim2stg2_inc || lim2stg2_dec || lim2stg3_inc || lim2stg3_dec ||\n       ocd2stg2_inc || ocd2stg2_dec || ocd2stg3_inc || ocd2stg3_dec || ocd_cntlr2stg2_dec;\n\n  always @(*) begin\n    po_setup_ns = po_setup_r;\n    if (rst) po_setup_ns = 2'b00;\n    else if (setup_po) po_setup_ns = 2'b11;\n    else if (|po_setup_r) po_setup_ns = po_setup_r - 2'b01;\n  end\n\n  reg po_en_stg23_r;\n  wire po_en_stg23_ns = ~rst && po_setup_r == 2'b01;\n  always @(posedge clk) po_en_stg23_r <= #TCQ po_en_stg23_ns;\n  output po_en_stg23;\n  assign po_en_stg23 = po_en_stg23_r; \n\n  wire sel_stg3 = lim2stg3_inc || lim2stg3_dec || ocd2stg3_inc || ocd2stg3_dec;\n\n  reg [POW_WIDTH-1:0] po_wait_r, po_wait_ns;\n  reg po_stg23_sel_r;\n  \n  \n  wire po_stg23_sel_ns = ~rst && (setup_po \n                                    ? sel_stg3\n                                       ? 1'b1 \n                                       : 1'b0 \n                                    : po_stg23_sel_r && !(po_wait_r == ONE[POW_WIDTH-1:0]));\n  always @(posedge clk) po_stg23_sel_r <= #TCQ po_stg23_sel_ns;\n  output po_stg23_sel;\n  assign po_stg23_sel = po_stg23_sel_r;\n\n  wire po_inc = lim2stg2_inc || lim2stg3_inc || ocd2stg2_inc || ocd2stg3_inc;\n\n  reg po_stg23_incdec_r;\n  wire po_stg23_incdec_ns = ~rst && (setup_po ? po_inc ? 1'b1 : 1'b0 : po_stg23_incdec_r);\n  always @(posedge clk) po_stg23_incdec_r <= #TCQ po_stg23_incdec_ns;\n  output po_stg23_incdec;\n  assign po_stg23_incdec = po_stg23_incdec_r;\n\n\n  always @(posedge clk) po_wait_r <= #TCQ po_wait_ns;\n  always @(*) begin\n    po_wait_ns = po_wait_r;\n    if (rst) po_wait_ns = {POW_WIDTH{1'b0}};\n    else if (po_en_stg23_r) po_wait_ns = PO_WAIT[POW_WIDTH-1:0] - ONE[POW_WIDTH-1:0];\n    else if (po_wait_r != {POW_WIDTH{1'b0}}) po_wait_ns = po_wait_r - ONE[POW_WIDTH-1:0];\t   \n  end\n  \n  wire po_rdy_ns = ~(setup_po || |po_setup_r || |po_wait_ns);\n  reg po_rdy_r;\n  always @(posedge clk) po_rdy_r <= #TCQ po_rdy_ns;\n  \n  output po_rdy;\n  assign po_rdy = po_rdy_r;\n\n  input [6*DQS_WIDTH-1:0] wl_po_fine_cnt;\n  input [DQS_CNT_WIDTH:0] oclkdelay_calib_cnt;\n  wire [6*DQS_WIDTH-1:0] wl_po_fine_shifted = wl_po_fine_cnt >> oclkdelay_calib_cnt*6;\n  output [5:0] wl_po_fine_cnt_sel;\n  assign wl_po_fine_cnt_sel = wl_po_fine_shifted[5:0];\n\n  input lim2init_prech_req;\n  input ocd_prech_req;\n  output oclk_prech_req;\n  assign oclk_prech_req = ocd_prech_req || lim2init_prech_req;\n\t\nendmodule \n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_ddr_phy_ocd_mux. \n\nModule specification: This module is a part of a DDR memory interface which mainly provides control over the output clock delay (OCD). It differentiates the control signals into appropriate behavior for stage2 and stage3. It also handles the left and right KTAP signals and edge detection through controlling signals. Important code sections are designed around reset and control operations, with edge detection contributing to the functionality. The module requires a clock and reset inputs, as well as multiple control signals to steer the action of the KTAP and edge detection as well as increment or decrement operations. Outputs from the module control the KTAP, edge detection readiness, and several stages of operation including setting count for the PLL. \n\nInternally used signals cater to different parts of the system, including set up, changes, incremental processes and ready states. For instance, 'clogb2' calculates the base 2 logarithm, 'PO_WAIT' provides the wait state prior to setup and changes, 'setup_po' signal detects necessary setup changes, 'po_en_stg23_ns' along with 'po_en_stg23_r' determines the current and future states of stage 2 and stage 3 enablement, and 'wl_po_fine_shifted' is a count selector for the phase-locked loop post shifting based on the calibration count etc.\n\nThe module's Verilog code is clearly divided into different sections: parameter declarations, input and output declarations, internal signal definitions, logic implementation, and functional routines. This ensures a clean, efficient structure with minimal redundancy and an emphasis on reusability and modularity. Procedures for the next-stage setup, increment or decrement operations, and the readiness of the system are to be found in the 'always' blocks of the codes. Also, a pre-defined function 'clogb2()' is used for calculating the base 2 logarithm."
                }
            ]
        }
    ]
}