{
    "spec": "Module name: mig_7series_v4_1_ddr_mc_phy_wrapper. Module specification: This module serves as a wrapper for the DDR memory controller PHY (Physical Layer) interface in a 7 Series FPGA design. It handles the physical interface between the memory controller and DDR memory devices, managing various signals such as data, address, command, and control lines. The module takes inputs like clocks, resets, control signals, and data, and outputs memory interface signals. Key inputs include rst, clk, phy_cmd_wr_en, phy_data_wr_en, phy_ctl_wd, mux_address, mux_bank, and mux_wrdata. Outputs include ddr_clk, ddr_addr, ddr_ba, ddr_cas_n, ddr_ras_n, ddr",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_mc_phy_wrapper\n\nExplanation: This module serves as a wrapper for the DDR memory controller PHY (Physical Layer) interface in a 7 Series FPGA design. It handles the physical interface between the memory controller and DDR memory devices, managing various signals such as data, address, command, and control lines. The module includes functionality for input/output buffering, data alignment, timing adjustments, and calibration. It supports different DDR memory types and configurations, and incorporates features like per-bit deskew, write leveling, and read calibration to ensure proper signal integrity and timing across the memory interface."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nHere's a concise overview of the input and output ports for the mig_7series_v4_1_ddr_mc_phy_wrapper module:\n\nInput ports:\n- rst, iddr_rst, clk, clk_div2, freq_refclk, mem_refclk, pll_lock, sync_pulse, mmcm_ps_clk, idelayctrl_refclk\n- phy_cmd_wr_en, phy_data_wr_en, phy_ctl_wd, phy_ctl_wr, phy_if_empty_def, phy_if_reset\n- data_offset_1, data_offset_2, aux_in_1, aux_in_2\n- phy_write_calib, phy_read_calib, calib_in_common, calib_sel, byte_sel_cnt\n- fine_delay_incdec_pb, fine_delay_sel, calib_zero_inputs, calib_zero_ctrl\n- po_fine_enable, po_coarse_enable, po_fine_inc, po_coarse_inc, po_counter_load_en, po_counter_read_en, po_sel_fine_oclk_delay, po_counter_load_val\n- pi_rst_dqs_find, pi_fine_enable, pi_fine_inc, pi_counter_load_en, pi_counter_load_val\n- idelay_ce, idelay_inc, idelay_ld, idle\n- phy_init_data_sel, mux_address, mux_bank, mux_cas_n, mux_cs_n, mux_ras_n, mux_odt, mux_cke, mux_we_n, parity_in, mux_wrdata, mux_wrdata_mask, mux_reset_n\n- dbg_pi_counter_read_en, rst_phaser_ref\n\nExplanation: These inputs control various aspects of the PHY wrapper, including clock and reset signals, calibration controls, delay adjustments, and memory interface signals.\n\nOutput ports:\n- idelaye2_init_val, oclkdelay_init_val, if_empty, phy_ctl_full, phy_cmd_full, phy_data_full, phy_pre_data_a_full\n- ddr_clk, phy_mc_go, pi_phase_locked, pi_phase_locked_all, pi_dqs_found, pi_dqs_found_all, pi_dqs_out_of_range\n- rd_data, ddr_addr, ddr_ba, ddr_cas_n, ddr_cke, ddr_cs_n, ddr_dm, ddr_odt, ddr_parity, ddr_ras_n, ddr_we_n, ddr_reset_n\n- pd_out, ref_dll_lock, dbg_pi_phase_locked_phy4lanes, dbg_pi_dqs_found_lanes_phy4lanes\n- po_counter_read_val, pi_counter_read_val\n\nExplanation: These outputs provide status information, calibration results, and interface signals for the DDR memory. They include initialization values, flags for various states, and actual DDR interface signals.\n\nInout ports:\n- ddr_dq, ddr_dqs, ddr_dqs_n\n\nExplanation: These are bidirectional data and data strobe signals for the DDR memory interface."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n1. aux_out\n2. mem_dqs_in, mem_dqs_out, mem_dqs_ts\n3. mem_dq_in, mem_dq_out, mem_dq_ts\n4. in_dq, in_dqs\n5. out_addr, out_ba, out_cas_n, out_cs_n, out_dm, out_odt, out_cke, out_dq, out_dqs, out_parity, out_ras_n, out_we_n\n6. phy_din, phy_dout\n7. phy_rd_en\n8. ts_dm, ts_dq, ts_dqs\n9. in_dqs_lpbk_to_iddr\n10. pd_out_pre\n11. phy_ctl_wd_i1, phy_ctl_wd_i2, phy_ctl_wr_i1, phy_ctl_wr_i2\n12. data_offset_1_i1, data_offset_1_i2, data_offset_2_i1, data_offset_2_i2\n13. phy_ctl_wd_temp, phy_ctl_wr_temp, data_offset_1_temp, data_offset_2_temp\n14. data_offset_1_of, data_offset_2_of, phy_ctl_wd_of, phy_ctl_wr_of\n15. phy_ctl_full_temp\n16. data_io_idle_pwrdwn\n17. fine_delay_mod, fine_delay_sel_r\n18. iddr_rst_i\n19. byte_sel_cnt_w1\n\nExplanation:\n1. aux_out: Auxiliary output signals for CKE and ODT control.\n2. mem_dqs_in/out/ts: DQS signals for memory interface (input, output, and tri-state).\n3. mem_dq_in/out/ts: DQ signals for memory interface (input, output, and tri-state).\n4. in_dq, in_dqs: Input signals for DQ and DQS lines.\n5. out_* signals: Output signals for various memory interface lines (address, bank, commands, etc.).\n6. phy_din, phy_dout: Data input and output for the PHY interface.\n7. phy_rd_en: Read enable signal for the PHY.\n8. ts_dm, ts_dq, ts_dqs: Tri-state control signals for DM, DQ, and DQS lines.\n9. in_dqs_lpbk_to_iddr: DQS loopback signal to IDDR.\n10. pd_out_pre: Pre-processed phase detector output.\n11-14. phy_ctl_* and data_offset_* signals: Pipelined and temporary signals for PHY control and data offset.\n15. phy_ctl_full_temp: Temporary signal for PHY control full status.\n16. data_io_idle_pwrdwn: Control signal for data I/O idle power down.\n17. fine_delay_mod, fine_delay_sel_r: Signals for fine delay adjustment.\n18. iddr_rst_i: IDDR reset signal.\n19. byte_sel_cnt_w1: Byte select count signal."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ps / 1 ps\n\nmodule mig_7series_v4_1_ddr_mc_phy_wrapper #\n  (\n   parameter TCQ              = 100,    \n   parameter tCK              = 2500,   \n   parameter BANK_TYPE        = \"HP_IO\", \n   parameter DATA_IO_PRIM_TYPE = \"DEFAULT\", \n   parameter DATA_IO_IDLE_PWRDWN = \"ON\",  \n   parameter IODELAY_GRP      = \"IODELAY_MIG\",\n   parameter FPGA_SPEED_GRADE = 1,\n   parameter nCK_PER_CLK      = 4,      \n   parameter nCS_PER_RANK     = 1,      \n   parameter BANK_WIDTH       = 3,      \n   parameter CKE_WIDTH        = 1,      \n   parameter CS_WIDTH         = 1,      \n   parameter CK_WIDTH         = 1,      \n   parameter CWL              = 5,      \n   parameter DDR2_DQSN_ENABLE = \"YES\",  \n   parameter DM_WIDTH         = 8,      \n   parameter DQ_WIDTH         = 16,     \n   parameter DQS_CNT_WIDTH    = 3,      \n   parameter DQS_WIDTH        = 8,      \n   parameter DRAM_TYPE        = \"DDR3\", \n   parameter RANKS            = 4,      \n   parameter ODT_WIDTH        = 1,      \n   parameter POC_USE_METASTABLE_SAMP = \"FALSE\",\n   parameter REG_CTRL         = \"OFF\",  \n   parameter ROW_WIDTH        = 16,     \n   parameter USE_CS_PORT      = 1,      \n   parameter USE_DM_PORT      = 1,      \n   parameter USE_ODT_PORT     = 1,      \n   parameter IBUF_LPWR_MODE   = \"OFF\",  \n   parameter LP_DDR_CK_WIDTH  = 2,\n\n   \n   parameter PHYCTL_CMD_FIFO = \"FALSE\",\n   parameter DATA_CTL_B0     = 4'hc,\n   parameter DATA_CTL_B1     = 4'hf,\n   parameter DATA_CTL_B2     = 4'hf,\n   parameter DATA_CTL_B3     = 4'hf,\n   parameter DATA_CTL_B4     = 4'hf,\n   parameter BYTE_LANES_B0   = 4'b1111,\n   parameter BYTE_LANES_B1   = 4'b0000,\n   parameter BYTE_LANES_B2   = 4'b0000,\n   parameter BYTE_LANES_B3   = 4'b0000,\n   parameter BYTE_LANES_B4   = 4'b0000,\n   parameter PHY_0_BITLANES  = 48'h0000_0000_0000,\n   parameter PHY_1_BITLANES  = 48'h0000_0000_0000,\n   parameter PHY_2_BITLANES  = 48'h0000_0000_0000,\n   \n   parameter HIGHEST_BANK    = 3,        \n   parameter HIGHEST_LANE    = 12,       \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   parameter CK_BYTE_MAP\n     = 144'h00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00,\n   parameter ADDR_MAP\n     = 192'h000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000,\n   parameter BANK_MAP   = 36'h000_000_000,\n   parameter CAS_MAP    = 12'h000,\n   parameter CKE_ODT_BYTE_MAP = 8'h00,\n   parameter CKE_MAP    = 96'h000_000_000_000_000_000_000_000,\n   parameter ODT_MAP    = 96'h000_000_000_000_000_000_000_000,\n   parameter CKE_ODT_AUX = \"FALSE\",\n   parameter CS_MAP     = 120'h000_000_000_000_000_000_000_000_000_000,\n   parameter PARITY_MAP = 12'h000,\n   parameter RAS_MAP    = 12'h000,\n   parameter WE_MAP     = 12'h000,\n   parameter DQS_BYTE_MAP\n     = 144'h00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00,\n   \n   parameter DATA0_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA1_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA2_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA3_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA4_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA5_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA6_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA7_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA8_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA9_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA10_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA11_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA12_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA13_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA14_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA15_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA16_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA17_MAP = 96'h000_000_000_000_000_000_000_000,\n   \n   parameter MASK0_MAP  = 108'h000_000_000_000_000_000_000_000_000,\n   parameter MASK1_MAP  = 108'h000_000_000_000_000_000_000_000_000,\n   \n   parameter SIM_CAL_OPTION  = \"NONE\",\n\n   \n   \n   parameter MASTER_PHY_CTL  = 1,\n   parameter DRAM_WIDTH = 8,\n   parameter PI_DIV2_INCDEC = \"FALSE\"\n  )\n  (\n   input                               rst,\n   input                               iddr_rst,\n   input                               clk,\n   input                               clk_div2,\n   input                               freq_refclk,\n   input                               mem_refclk,\n   input                               pll_lock,\n   input                               sync_pulse,\n   input                               mmcm_ps_clk,\n   input                               idelayctrl_refclk,\n   input                               phy_cmd_wr_en,\n   input                               phy_data_wr_en,\n   input [31:0]                        phy_ctl_wd,\n   input                               phy_ctl_wr,\n   input                               phy_if_empty_def,\n   input                               phy_if_reset,\n   input [5:0]                         data_offset_1,\n   input [5:0]                         data_offset_2,\n   input [3:0]                         aux_in_1,\n   input [3:0]                         aux_in_2,\n   output [4:0]                        idelaye2_init_val,\n   output [5:0]                        oclkdelay_init_val,\n   output                              if_empty,\n   output                              phy_ctl_full,\n   output                              phy_cmd_full,\n   output                              phy_data_full,\n   output                              phy_pre_data_a_full,\n   output [(CK_WIDTH * LP_DDR_CK_WIDTH)-1:0] ddr_clk,\n   output                              phy_mc_go,\n   input                               phy_write_calib,\n   input                               phy_read_calib,\n   input                               calib_in_common,\n   input [5:0]                         calib_sel,\n   input [DQS_CNT_WIDTH:0]             byte_sel_cnt,\n   input [DRAM_WIDTH-1:0]              fine_delay_incdec_pb,\n   input                               fine_delay_sel,\n   input [HIGHEST_BANK-1:0]            calib_zero_inputs,\n   input [HIGHEST_BANK-1:0]            calib_zero_ctrl,\n   input [2:0]                         po_fine_enable,\n   input [2:0]                         po_coarse_enable,\n   input [2:0]                         po_fine_inc,\n   input [2:0]                         po_coarse_inc,\n   input                               po_counter_load_en,\n   input                               po_counter_read_en,\n   input [2:0]                         po_sel_fine_oclk_delay,\n   input [8:0]                         po_counter_load_val,\n   output [8:0]                        po_counter_read_val,\n   output [5:0]                        pi_counter_read_val,\n   input [HIGHEST_BANK-1:0]            pi_rst_dqs_find,\n   input                               pi_fine_enable,\n   input                               pi_fine_inc,\n   input                               pi_counter_load_en,\n   input [5:0]                         pi_counter_load_val,\n   input                               idelay_ce,\n   input                               idelay_inc,\n   input                               idelay_ld,\n   input                               idle,\n   output                              pi_phase_locked,\n   output                              pi_phase_locked_all,\n   output                              pi_dqs_found,\n   output                              pi_dqs_found_all,\n   output                              pi_dqs_out_of_range,\n   \n   input                                         phy_init_data_sel,\n   input [nCK_PER_CLK*ROW_WIDTH-1:0]             mux_address,\n   input [nCK_PER_CLK*BANK_WIDTH-1:0]            mux_bank,\n   input [nCK_PER_CLK-1:0]                       mux_cas_n,\n   input [CS_WIDTH*nCS_PER_RANK*nCK_PER_CLK-1:0] mux_cs_n,\n   input [nCK_PER_CLK-1:0]                       mux_ras_n,\n   input [1:0]                                   mux_odt,\n   input [nCK_PER_CLK-1:0]                       mux_cke,\n   input [nCK_PER_CLK-1:0]                       mux_we_n,\n   input [nCK_PER_CLK-1:0]                       parity_in,\n   input [2*nCK_PER_CLK*DQ_WIDTH-1:0]            mux_wrdata,\n   input [2*nCK_PER_CLK*(DQ_WIDTH/8)-1:0]        mux_wrdata_mask,\n   input                                         mux_reset_n,\n   output [2*nCK_PER_CLK*DQ_WIDTH-1:0]           rd_data,\n   \n   output [ROW_WIDTH-1:0]                        ddr_addr,\n   output [BANK_WIDTH-1:0]                       ddr_ba,\n   output                                        ddr_cas_n,\n   output [CKE_WIDTH-1:0]                        ddr_cke,\n   output [CS_WIDTH*nCS_PER_RANK-1:0]            ddr_cs_n,\n   output [DM_WIDTH-1:0]                         ddr_dm,\n   output [ODT_WIDTH-1:0]                        ddr_odt,\n   output                                        ddr_parity,\n   output                                        ddr_ras_n,\n   output                                        ddr_we_n,\n   output                                        ddr_reset_n,\n   inout [DQ_WIDTH-1:0]                          ddr_dq,\n   inout [DQS_WIDTH-1:0]                         ddr_dqs,\n   inout [DQS_WIDTH-1:0]                         ddr_dqs_n,\n   \n   output                                        pd_out\n\n   ,input                                        dbg_pi_counter_read_en\n   ,output                                       ref_dll_lock\n   ,input                                        rst_phaser_ref\n   ,output [11:0]                                dbg_pi_phase_locked_phy4lanes\n   ,output [11:0]                                dbg_pi_dqs_found_lanes_phy4lanes\n   );\n\n  function [71:0] generate_bytelanes_ddr_ck;\n    input [143:0] ck_byte_map;\n    integer v ;\n    begin\n      generate_bytelanes_ddr_ck = 'b0 ;\n      for (v = 0; v < CK_WIDTH; v = v + 1) begin\n        if ((CK_BYTE_MAP[((v*8)+4)+:4]) == 2)\n          generate_bytelanes_ddr_ck[48+(4*v)+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n        else if ((CK_BYTE_MAP[((v*8)+4)+:4]) == 1)\n          generate_bytelanes_ddr_ck[24+(4*v)+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n        else\n          generate_bytelanes_ddr_ck[4*v+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n      end\n    end\n  endfunction\n\n  function [(2*CK_WIDTH*8)-1:0] generate_ddr_ck_map;\n    input [143:0] ck_byte_map;\n    integer g;\n    begin\n      generate_ddr_ck_map = 'b0 ;\n      for(g = 0 ; g < CK_WIDTH ; g= g + 1) begin\n        generate_ddr_ck_map[(g*2*8)+:8]  = (ck_byte_map[(g*8)+:4] == 4'd0) ? \"A\" :\n                                           (ck_byte_map[(g*8)+:4] == 4'd1) ? \"B\" :\n                                           (ck_byte_map[(g*8)+:4] == 4'd2) ? \"C\" : \"D\" ;\n        generate_ddr_ck_map[(((g*2)+1)*8)+:8] = (ck_byte_map[((g*8)+4)+:4] == 4'd0) ? \"0\" :\n                                                (ck_byte_map[((g*8)+4)+:4] == 4'd1) ? \"1\" :  \"2\" ; \n      end\n    end\n  endfunction\n\n\n\n  \n  localparam IBUF_LOW_PWR\n             = (IBUF_LPWR_MODE == \"OFF\") ? \"FALSE\" :\n             ((IBUF_LPWR_MODE == \"ON\")  ? \"TRUE\" : \"ILLEGAL\");\n\n  \n  localparam DQ_PER_DQS = DQ_WIDTH / DQS_WIDTH;\n  \n  localparam PHASE_PER_CLK = 2*nCK_PER_CLK;\n  \n  \n  localparam PHASE_DIV = 4 / nCK_PER_CLK;\n\n  localparam CLK_PERIOD = tCK * nCK_PER_CLK;\n\n  \n  \n  \n  \n  localparam FULL_DATA_MAP = {DATA17_MAP[12*DQ_PER_DQS-1:0],\n                              DATA16_MAP[12*DQ_PER_DQS-1:0],\n                              DATA15_MAP[12*DQ_PER_DQS-1:0],\n                              DATA14_MAP[12*DQ_PER_DQS-1:0],\n                              DATA13_MAP[12*DQ_PER_DQS-1:0],\n                              DATA12_MAP[12*DQ_PER_DQS-1:0],\n                              DATA11_MAP[12*DQ_PER_DQS-1:0],\n                              DATA10_MAP[12*DQ_PER_DQS-1:0],\n                              DATA9_MAP[12*DQ_PER_DQS-1:0],\n                              DATA8_MAP[12*DQ_PER_DQS-1:0],\n                              DATA7_MAP[12*DQ_PER_DQS-1:0],\n                              DATA6_MAP[12*DQ_PER_DQS-1:0],\n                              DATA5_MAP[12*DQ_PER_DQS-1:0],\n                              DATA4_MAP[12*DQ_PER_DQS-1:0],\n                              DATA3_MAP[12*DQ_PER_DQS-1:0],\n                              DATA2_MAP[12*DQ_PER_DQS-1:0],\n                              DATA1_MAP[12*DQ_PER_DQS-1:0],\n                              DATA0_MAP[12*DQ_PER_DQS-1:0]};\n  \n  localparam FULL_MASK_MAP = {MASK1_MAP, MASK0_MAP};\n  localparam TMP_BYTELANES_DDR_CK  = generate_bytelanes_ddr_ck(CK_BYTE_MAP) ;\n  localparam TMP_GENERATE_DDR_CK_MAP = generate_ddr_ck_map(CK_BYTE_MAP) ;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  function [143:0] calc_phy_bitlanes_outonly;\n    input [215:0] data_mask_in;\n    integer       z;\n    begin\n      calc_phy_bitlanes_outonly = 'b0;\n      \n      \n      if (USE_DM_PORT == 1)\n        for (z = 0; z < DM_WIDTH; z = z + 1)\n          calc_phy_bitlanes_outonly[48*data_mask_in[(12*z+8)+:3] +\n                                    12*data_mask_in[(12*z+4)+:2] +\n                                    data_mask_in[12*z+:4]] = 1'b1;\n    end\n  endfunction\n\n  localparam PHY_BITLANES_OUTONLY   = calc_phy_bitlanes_outonly(FULL_MASK_MAP);\n  localparam PHY_0_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[47:0];\n  localparam PHY_1_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[95:48];\n  localparam PHY_2_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[143:96];\n\n  \n  \n  localparam CKE_ODT_RCLK_SELECT_BANK_AUX_ON\n             = (CKE_ODT_BYTE_MAP[7:4] == 4'h0) ? 0 :\n                 ((CKE_ODT_BYTE_MAP[7:4] == 4'h1) ? 1 :\n                  ((CKE_ODT_BYTE_MAP[7:4] == 4'h2) ? 2 :\n                   ((CKE_ODT_BYTE_MAP[7:4] == 4'h3) ? 3 :\n                    ((CKE_ODT_BYTE_MAP[7:4] == 4'h4) ? 4 : -1))));\n  localparam CKE_ODT_RCLK_SELECT_LANE_AUX_ON\n             = (CKE_ODT_BYTE_MAP[3:0] == 4'h0) ? \"A\" :\n                 ((CKE_ODT_BYTE_MAP[3:0] == 4'h1) ? \"B\" :\n                  ((CKE_ODT_BYTE_MAP[3:0] == 4'h2) ? \"C\" :\n                   ((CKE_ODT_BYTE_MAP[3:0] == 4'h3) ? \"D\" : \"ILLEGAL\")));\n\n  localparam CKE_ODT_RCLK_SELECT_BANK_AUX_OFF\n             = (CKE_MAP[11:8] == 4'h0) ? 0 :\n                 ((CKE_MAP[11:8] == 4'h1) ? 1 :\n                  ((CKE_MAP[11:8] == 4'h2) ? 2 :\n                   ((CKE_MAP[11:8] == 4'h3) ? 3 :\n                    ((CKE_MAP[11:8] == 4'h4) ? 4 : -1))));\n  localparam CKE_ODT_RCLK_SELECT_LANE_AUX_OFF\n             = (CKE_MAP[7:4] == 4'h0) ? \"A\" :\n                 ((CKE_MAP[7:4] == 4'h1) ? \"B\" :\n                  ((CKE_MAP[7:4] == 4'h2) ? \"C\" :\n                   ((CKE_MAP[7:4] == 4'h3) ? \"D\" : \"ILLEGAL\")));\n\n\n  localparam CKE_ODT_RCLK_SELECT_BANK = (CKE_ODT_AUX == \"TRUE\") ? CKE_ODT_RCLK_SELECT_BANK_AUX_ON : CKE_ODT_RCLK_SELECT_BANK_AUX_OFF ;\n  localparam CKE_ODT_RCLK_SELECT_LANE = (CKE_ODT_AUX == \"TRUE\") ? CKE_ODT_RCLK_SELECT_LANE_AUX_ON : CKE_ODT_RCLK_SELECT_LANE_AUX_OFF ;\n\n\n  \n  \n  \n  \n  \n\n  \n  \n  \n  localparam PO_OCLKDELAY_INV = (tCK >= 2500) ?  \"FALSE\" : \"TRUE\";\n\n  \n  \n  localparam PHY_0_A_PI_FREQ_REF_DIV = tCK > 5000 ?  \"DIV4\" :\n                                       tCK >= 2500 ? \"DIV2\": \"NONE\";\n\n  localparam FREQ_REF_DIV = (PHY_0_A_PI_FREQ_REF_DIV == \"DIV4\" ? 4 :\n                             PHY_0_A_PI_FREQ_REF_DIV == \"DIV2\" ? 2 : 1);\n\n  \n  localparam real INT_DELAY = 0.4392/FREQ_REF_DIV + 100.0/tCK;\n\n  \n  localparam real HALF_CYCLE_DELAY = 0.5*(PO_OCLKDELAY_INV == \"TRUE\" ? 1 : 0);\n\n  \n  \n  \n  localparam real MC_OCLK_DELAY = ((PO_OCLKDELAY_INV == \"TRUE\" ? 1.25 : 0.25) -\n                                   (INT_DELAY + HALF_CYCLE_DELAY))\n                                   * 63 * FREQ_REF_DIV;\n  \n\n  localparam integer PHY_0_A_PO_OCLK_DELAY_HW\n                     = (tCK > 2273)  ? 34 :\n                       (tCK > 2000)  ? 33 :\n                       (tCK > 1724)  ? 32 :\n                       (tCK > 1515)  ? 31 :\n                       (tCK > 1315)  ? 30 :\n                       (tCK > 1136)  ? 29 :\n                       (tCK > 1021)  ? 28 : 27;\n\n  \n  \n  localparam integer PHY_0_A_PO_OCLK_DELAY = (SIM_CAL_OPTION == \"NONE\") ?   \n                                               ((tCK >= 2500) ? 0 :\n                                                (DRAM_TYPE == \"DDR3\") ? PHY_0_A_PO_OCLK_DELAY_HW : 30) :\n                                               (tCK >= 2500) ? 0 : MC_OCLK_DELAY;\n\n  \n  localparam PHY_0_A_IDELAYE2_IDELAY_VALUE = (SIM_CAL_OPTION != \"FAST_CAL\") ? 0 :\n                  (tCK < 1000) ? 0 :\n                  (tCK < 1330) ? 0 :\n                  (tCK < 2300) ? 0 :\n                  (tCK < 2500) ? 2 : 0;\n  \n\n  \n  localparam PHY_0_RD_CMD_OFFSET_0 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_1 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_2 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_3 = 10;\n  \n  localparam PHY_0_WR_CMD_OFFSET_0 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_1 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_2 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_3 = (nCK_PER_CLK == 4) ? 8 : 4;\n  \n  localparam PHY_0_WR_DURATION_0 = 7;\n  localparam PHY_0_WR_DURATION_1 = 7;\n  localparam PHY_0_WR_DURATION_2 = 7;\n  localparam PHY_0_WR_DURATION_3 = 7;\n  \n  localparam CWL_M = (REG_CTRL == \"ON\") ? CWL + 1 : CWL;\n  localparam PHY_0_CMD_OFFSET = (nCK_PER_CLK == 4) ?  (CWL_M % 2) ? 8 : 9 :\n                                  (CWL < 7) ?\n                                    4 + ((CWL_M % 2) ? 0 : 1) :\n                                    5 + ((CWL_M % 2) ? 0 : 1);\n\n  \n  \n  \n  localparam PHY_COUNT_EN = (nCK_PER_CLK == 4) ? \"TRUE\" : \"FALSE\";\n\n\n  wire [((HIGHEST_LANE+3)/4)*4-1:0] aux_out;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_in;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_out;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_ts;\n  wire [HIGHEST_LANE*10-1:0]        mem_dq_in;\n  wire [HIGHEST_LANE*12-1:0]        mem_dq_out;\n  wire [HIGHEST_LANE*12-1:0]        mem_dq_ts;\n  wire [DQ_WIDTH-1:0]               in_dq;\n  wire [DQS_WIDTH-1:0]              in_dqs;\n  wire [ROW_WIDTH-1:0]              out_addr;\n  wire [BANK_WIDTH-1:0]             out_ba;\n  wire                              out_cas_n;\n  wire [CS_WIDTH*nCS_PER_RANK-1:0]  out_cs_n;\n  wire [DM_WIDTH-1:0]               out_dm;\n  wire [ODT_WIDTH -1:0]             out_odt;\n  wire [CKE_WIDTH -1 :0]            out_cke ;\n  wire [DQ_WIDTH-1:0]               out_dq;\n  wire [DQS_WIDTH-1:0]              out_dqs;\n  wire                              out_parity;\n  wire                              out_ras_n;\n  wire                              out_we_n;\n  wire [HIGHEST_LANE*80-1:0]        phy_din;\n  wire [HIGHEST_LANE*80-1:0]        phy_dout;\n  wire                              phy_rd_en;\n  wire [DM_WIDTH-1:0]               ts_dm;\n  wire [DQ_WIDTH-1:0]               ts_dq;\n  wire [DQS_WIDTH-1:0]              ts_dqs;\n  wire [DQS_WIDTH-1:0]              in_dqs_lpbk_to_iddr;\n  wire [DQS_WIDTH-1:0]              pd_out_pre;\n  \n\n  reg [31:0]                        phy_ctl_wd_i1;\n  reg [31:0]                        phy_ctl_wd_i2;\n  reg                               phy_ctl_wr_i1;\n  reg                               phy_ctl_wr_i2;\n  reg [5:0]                         data_offset_1_i1;\n  reg [5:0]                         data_offset_1_i2;\n  reg [5:0]                         data_offset_2_i1;\n  reg [5:0]                         data_offset_2_i2;\n  wire [31:0]                       phy_ctl_wd_temp;\n  wire                              phy_ctl_wr_temp;\n  wire [5:0]                        data_offset_1_temp;\n  wire [5:0]                        data_offset_2_temp;\n  wire [5:0]                        data_offset_1_of;\n  wire [5:0]                        data_offset_2_of;\n  wire [31:0]                       phy_ctl_wd_of;\n  wire          phy_ctl_wr_of ;\n  wire [3:0]                        phy_ctl_full_temp;\n\n  wire                              data_io_idle_pwrdwn;\n  reg  [29:0]                       fine_delay_mod;    \n  reg                               fine_delay_sel_r;  \n\n  wire iddr_rst_i;\n\n  (* use_dsp48 = \"no\" *) wire [DQS_CNT_WIDTH:0]             byte_sel_cnt_w1;\n\n  \n  assign phy_rd_en = !if_empty;\n\n  \n  assign idelaye2_init_val = PHY_0_A_IDELAYE2_IDELAY_VALUE;\n  assign oclkdelay_init_val = PHY_0_A_PO_OCLK_DELAY;\n\n  \n  assign data_io_idle_pwrdwn = DATA_IO_IDLE_PWRDWN == \"ON\" ? idle : 1'b0;\n  assign iddr_rst_i = iddr_rst;\n  \n  \n  \n\n  \n  \n  \n  \n  generate\n  if(CKE_ODT_AUX == \"TRUE\")begin:cke_thru_auxpins\n    if (CKE_WIDTH == 1) begin : gen_cke\n      \n      \n      \n      \n      \n      \n      OBUF u_cke_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK]),\n         .O (ddr_cke)\n         );\n    end else begin: gen_2rank_cke\n      OBUF u_cke0_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK]),\n         .O (ddr_cke[0])\n         );\n      OBUF u_cke1_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n         .O (ddr_cke[1])\n         );\n    end\n  end\n  endgenerate\n\n  generate\n  if(CKE_ODT_AUX == \"TRUE\")begin:odt_thru_auxpins\n    if (USE_ODT_PORT == 1) begin : gen_use_odt\n      \n      \n      \n      \n      \n      \n        OBUF u_odt_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+1]),\n           .O (ddr_odt[0])\n           );\n      if (ODT_WIDTH == 2 && RANKS == 1) begin: gen_2port_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n           .O (ddr_odt[1])\n           );\n      end else if (ODT_WIDTH == 2 && RANKS == 2) begin: gen_2rank_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+3]),\n           .O (ddr_odt[1])\n           );\n      end else if (ODT_WIDTH == 3 && RANKS == 1) begin: gen_3port_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n           .O (ddr_odt[1])\n           );\n        OBUF u_odt2_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+3]),\n           .O (ddr_odt[2])\n           );\n      end\n    end else begin\n        assign ddr_odt = 'b0;\n    end\n  end\n  endgenerate\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  generate\n    genvar i, j;\n    for (i = 0; i < DQ_WIDTH; i = i + 1) begin: gen_loop_rd_data_1\n      for (j = 0; j < PHASE_PER_CLK; j = j + 1) begin: gen_loop_rd_data_2\n        assign rd_data[DQ_WIDTH*j + i]\n                 = phy_din[(320*FULL_DATA_MAP[(12*i+8)+:3]+\n                            80*FULL_DATA_MAP[(12*i+4)+:2] +\n                            8*FULL_DATA_MAP[12*i+:4]) + j];\n      end\n    end\n  endgenerate\n\n  \n\n  reg [11:0] cal_tmp;\n  reg [95:0] byte_sel_data_map;\n\n  assign byte_sel_cnt_w1 = byte_sel_cnt;\n\n  always @ (posedge clk) begin\n     byte_sel_data_map <= #TCQ FULL_DATA_MAP[12*DQ_PER_DQS*byte_sel_cnt_w1+:96];\n  end\n\n  always @ (posedge clk) begin\n     fine_delay_mod[((byte_sel_data_map[3:0])*3)+:3] <= #TCQ {fine_delay_incdec_pb[0],2'b00};\n     fine_delay_mod[((byte_sel_data_map[12+3:12])*3)+:3] <= #TCQ {fine_delay_incdec_pb[1],2'b00};\n     fine_delay_mod[((byte_sel_data_map[24+3:24])*3)+:3] <= #TCQ {fine_delay_incdec_pb[2],2'b00};\n     fine_delay_mod[((byte_sel_data_map[36+3:36])*3)+:3] <= #TCQ {fine_delay_incdec_pb[3],2'b00};\n     fine_delay_mod[((byte_sel_data_map[48+3:48])*3)+:3] <= #TCQ {fine_delay_incdec_pb[4],2'b00};\n     fine_delay_mod[((byte_sel_data_map[60+3:60])*3)+:3] <= #TCQ {fine_delay_incdec_pb[5],2'b00};\n     fine_delay_mod[((byte_sel_data_map[72+3:72])*3)+:3] <= #TCQ {fine_delay_incdec_pb[6],2'b00};\n     fine_delay_mod[((byte_sel_data_map[84+3:84])*3)+:3] <= #TCQ {fine_delay_incdec_pb[7],2'b00};\n     fine_delay_sel_r <= #TCQ fine_delay_sel;\n  end\n\n  \n  \n  \n\n  assign out_cas_n\n    = mem_dq_out[48*CAS_MAP[10:8] + 12*CAS_MAP[5:4] + CAS_MAP[3:0]];\n\n  generate\n    \n    if (CAS_MAP[3:0] < 4'hA) begin: gen_cas_lt10\n      \n      \n      \n      \n      \n      \n      assign phy_dout[(320*CAS_MAP[10:8] + 80*CAS_MAP[5:4] +\n                       8*CAS_MAP[3:0])+:4]\n               = {mux_cas_n[3/PHASE_DIV], mux_cas_n[2/PHASE_DIV],\n                  mux_cas_n[1/PHASE_DIV], mux_cas_n[0]};\n    end else begin: gen_cas_ge10\n      \n      \n      \n      \n      \n      assign phy_dout[(320*CAS_MAP[10:8] + 80*CAS_MAP[5:4] +\n                       8*(CAS_MAP[3:0]-5) + 4)+:4]\n               = {mux_cas_n[3/PHASE_DIV], mux_cas_n[2/PHASE_DIV],\n                  mux_cas_n[1/PHASE_DIV], mux_cas_n[0]};\n    end\n  endgenerate\n\n  assign out_ras_n\n    = mem_dq_out[48*RAS_MAP[10:8] + 12*RAS_MAP[5:4] + RAS_MAP[3:0]];\n\n  generate\n    if (RAS_MAP[3:0] < 4'hA) begin: gen_ras_lt10\n      assign phy_dout[(320*RAS_MAP[10:8] + 80*RAS_MAP[5:4] +\n                       8*RAS_MAP[3:0])+:4]\n               = {mux_ras_n[3/PHASE_DIV], mux_ras_n[2/PHASE_DIV],\n                  mux_ras_n[1/PHASE_DIV], mux_ras_n[0]};\n    end else begin: gen_ras_ge10\n      assign phy_dout[(320*RAS_MAP[10:8] + 80*RAS_MAP[5:4] +\n                       8*(RAS_MAP[3:0]-5) + 4)+:4]\n               = {mux_ras_n[3/PHASE_DIV], mux_ras_n[2/PHASE_DIV],\n                  mux_ras_n[1/PHASE_DIV], mux_ras_n[0]};\n    end\n  endgenerate\n\n  assign out_we_n\n    = mem_dq_out[48*WE_MAP[10:8] + 12*WE_MAP[5:4] + WE_MAP[3:0]];\n\n  generate\n    if (WE_MAP[3:0] < 4'hA) begin: gen_we_lt10\n      assign phy_dout[(320*WE_MAP[10:8] + 80*WE_MAP[5:4] +\n                       8*WE_MAP[3:0])+:4]\n               = {mux_we_n[3/PHASE_DIV], mux_we_n[2/PHASE_DIV],\n                  mux_we_n[1/PHASE_DIV], mux_we_n[0]};\n    end else begin: gen_we_ge10\n      assign phy_dout[(320*WE_MAP[10:8] + 80*WE_MAP[5:4] +\n                       8*(WE_MAP[3:0]-5) + 4)+:4]\n               = {mux_we_n[3/PHASE_DIV], mux_we_n[2/PHASE_DIV],\n                  mux_we_n[1/PHASE_DIV], mux_we_n[0]};\n    end\n  endgenerate\n\n  generate\n    if (REG_CTRL == \"ON\") begin: gen_parity_out\n      \n      assign out_parity\n        = mem_dq_out[48*PARITY_MAP[10:8] + 12*PARITY_MAP[5:4] +\n                     PARITY_MAP[3:0]];\n      if (PARITY_MAP[3:0] < 4'hA) begin: gen_lt10\n        assign phy_dout[(320*PARITY_MAP[10:8] + 80*PARITY_MAP[5:4] +\n                         8*PARITY_MAP[3:0])+:4]\n                 = {parity_in[3/PHASE_DIV], parity_in[2/PHASE_DIV],\n                    parity_in[1/PHASE_DIV], parity_in[0]};\n      end else begin: gen_ge10\n        assign phy_dout[(320*PARITY_MAP[10:8] + 80*PARITY_MAP[5:4] +\n                         8*(PARITY_MAP[3:0]-5) + 4)+:4]\n               = {parity_in[3/PHASE_DIV], parity_in[2/PHASE_DIV],\n                  parity_in[1/PHASE_DIV], parity_in[0]};\n      end\n    end\n  endgenerate\n\n  \n\n  generate\n    genvar m, n,x;\n\n    \n    \n    \n\n    \n    for (m = 0; m < ROW_WIDTH; m = m + 1) begin: gen_addr_out\n      assign out_addr[m]\n               = mem_dq_out[48*ADDR_MAP[(12*m+8)+:3] +\n                            12*ADDR_MAP[(12*m+4)+:2] +\n                            ADDR_MAP[12*m+:4]];\n\n      if (ADDR_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n        \n        \n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*ADDR_MAP[(12*m+8)+:3] +\n                          80*ADDR_MAP[(12*m+4)+:2] +\n                          8*ADDR_MAP[12*m+:4] + n]\n                   = mux_address[ROW_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end else begin: gen_ge10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*ADDR_MAP[(12*m+8)+:3] +\n                          80*ADDR_MAP[(12*m+4)+:2] +\n                          8*(ADDR_MAP[12*m+:4]-5) + 4 + n]\n                   = mux_address[ROW_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end\n    end\n\n    \n    for (m = 0; m < BANK_WIDTH; m = m + 1) begin: gen_ba_out\n        assign out_ba[m]\n                 = mem_dq_out[48*BANK_MAP[(12*m+8)+:3] +\n                              12*BANK_MAP[(12*m+4)+:2] +\n                              BANK_MAP[12*m+:4]];\n\n      if (BANK_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*BANK_MAP[(12*m+8)+:3] +\n                          80*BANK_MAP[(12*m+4)+:2] +\n                          8*BANK_MAP[12*m+:4] + n]\n                   = mux_bank[BANK_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end else begin: gen_ge10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*BANK_MAP[(12*m+8)+:3] +\n                          80*BANK_MAP[(12*m+4)+:2] +\n                          8*(BANK_MAP[12*m+:4]-5) + 4 + n]\n                   = mux_bank[BANK_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end\n    end\n\n    \n    if (USE_CS_PORT == 1) begin: gen_cs_n_out\n      for (m = 0; m < CS_WIDTH*nCS_PER_RANK; m = m + 1) begin: gen_cs_out\n        assign out_cs_n[m]\n                 = mem_dq_out[48*CS_MAP[(12*m+8)+:3] +\n                              12*CS_MAP[(12*m+4)+:2] +\n                              CS_MAP[12*m+:4]];\n        if (CS_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n          for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n            assign phy_dout[320*CS_MAP[(12*m+8)+:3] +\n                            80*CS_MAP[(12*m+4)+:2] +\n                            8*CS_MAP[12*m+:4] + n]\n                     = mux_cs_n[CS_WIDTH*nCS_PER_RANK*(n/PHASE_DIV) + m];\n          end\n        end else begin: gen_ge10\n          for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n            assign phy_dout[320*CS_MAP[(12*m+8)+:3] +\n                            80*CS_MAP[(12*m+4)+:2] +\n                            8*(CS_MAP[12*m+:4]-5) + 4 + n]\n                     = mux_cs_n[CS_WIDTH*nCS_PER_RANK*(n/PHASE_DIV) + m];\n          end\n        end\n      end\n    end\n\n\n   if(CKE_ODT_AUX == \"FALSE\") begin\n     \n     wire [ODT_WIDTH*nCK_PER_CLK -1 :0] mux_odt_remap  ;\n\n     if(RANKS == 1) begin\n        for(x =0 ; x < nCK_PER_CLK ; x = x+1) begin\n          assign mux_odt_remap[(x*ODT_WIDTH)+:ODT_WIDTH] = {ODT_WIDTH{mux_odt[0]}} ;\n        end\n     end else begin\n        for(x =0 ; x < 2*nCK_PER_CLK ; x = x+2) begin\n          assign mux_odt_remap[(x*ODT_WIDTH/RANKS)+:ODT_WIDTH/RANKS] = {ODT_WIDTH/RANKS{mux_odt[0]}} ;\n          assign mux_odt_remap[((x*ODT_WIDTH/RANKS)+(ODT_WIDTH/RANKS))+:ODT_WIDTH/RANKS] = {ODT_WIDTH/RANKS{mux_odt[1]}} ;\n        end\n     end\n\n     if (USE_ODT_PORT == 1) begin: gen_odt_out\n       for (m = 0; m < ODT_WIDTH; m = m + 1) begin: gen_odt_out_1\n         assign out_odt[m]\n                  = mem_dq_out[48*ODT_MAP[(12*m+8)+:3] +\n                               12*ODT_MAP[(12*m+4)+:2] +\n                               ODT_MAP[12*m+:4]];\n         if (ODT_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n           for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n             assign phy_dout[320*ODT_MAP[(12*m+8)+:3] +\n                             80*ODT_MAP[(12*m+4)+:2] +\n                             8*ODT_MAP[12*m+:4] + n]\n                      = mux_odt_remap[ODT_WIDTH*(n/PHASE_DIV) + m];\n           end\n         end else begin: gen_ge10\n           for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n             assign phy_dout[320*ODT_MAP[(12*m+8)+:3] +\n                             80*ODT_MAP[(12*m+4)+:2] +\n                             8*(ODT_MAP[12*m+:4]-5) + 4 + n]\n                      = mux_odt_remap[ODT_WIDTH*(n/PHASE_DIV) + m];\n           end\n         end\n       end\n     end\n\n\n     wire [CKE_WIDTH*nCK_PER_CLK -1:0] mux_cke_remap ;\n\n     for(x = 0 ; x < nCK_PER_CLK ; x = x +1) begin\n      assign  mux_cke_remap[(x*CKE_WIDTH)+:CKE_WIDTH] = {CKE_WIDTH{mux_cke[x]}} ;\n     end\n\n\n\n     for (m = 0; m < CKE_WIDTH; m = m + 1) begin: gen_cke_out\n       assign out_cke[m]\n                = mem_dq_out[48*CKE_MAP[(12*m+8)+:3] +\n                             12*CKE_MAP[(12*m+4)+:2] +\n                             CKE_MAP[12*m+:4]];\n       if (CKE_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n         for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n           assign phy_dout[320*CKE_MAP[(12*m+8)+:3] +\n                           80*CKE_MAP[(12*m+4)+:2] +\n                           8*CKE_MAP[12*m+:4] + n]\n                    = mux_cke_remap[CKE_WIDTH*(n/PHASE_DIV) + m];\n         end\n       end else begin: gen_ge10\n         for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n           assign phy_dout[320*CKE_MAP[(12*m+8)+:3] +\n                           80*CKE_MAP[(12*m+4)+:2] +\n                           8*(CKE_MAP[12*m+:4]-5) + 4 + n]\n                    = mux_cke_remap[CKE_WIDTH*(n/PHASE_DIV) + m];\n         end\n       end\n     end\n   end\n\n    \n    \n    \n\n    if (USE_DM_PORT == 1) begin: gen_dm_out\n      for (m = 0; m < DM_WIDTH; m = m + 1) begin: gen_dm_out\n        assign out_dm[m]\n                 = mem_dq_out[48*FULL_MASK_MAP[(12*m+8)+:3] +\n                              12*FULL_MASK_MAP[(12*m+4)+:2] +\n                              FULL_MASK_MAP[12*m+:4]];\n        assign ts_dm[m]\n                 = mem_dq_ts[48*FULL_MASK_MAP[(12*m+8)+:3] +\n                             12*FULL_MASK_MAP[(12*m+4)+:2] +\n                             FULL_MASK_MAP[12*m+:4]];\n        for (n = 0; n < PHASE_PER_CLK; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*FULL_MASK_MAP[(12*m+8)+:3] +\n                          80*FULL_MASK_MAP[(12*m+4)+:2] +\n                          8*FULL_MASK_MAP[12*m+:4] + n]\n                   = mux_wrdata_mask[DM_WIDTH*n + m];\n        end\n      end\n    end\n\n    \n    \n    \n\n    for (m = 0; m < DQ_WIDTH; m = m + 1) begin: gen_dq_inout\n      \n      assign mem_dq_in[40*FULL_DATA_MAP[(12*m+8)+:3] +\n                       10*FULL_DATA_MAP[(12*m+4)+:2] +\n                       FULL_DATA_MAP[12*m+:4]]\n               = in_dq[m];\n      \n      assign out_dq[m]\n               = mem_dq_out[48*FULL_DATA_MAP[(12*m+8)+:3] +\n                            12*FULL_DATA_MAP[(12*m+4)+:2] +\n                            FULL_DATA_MAP[12*m+:4]];\n      assign ts_dq[m]\n               = mem_dq_ts[48*FULL_DATA_MAP[(12*m+8)+:3] +\n                           12*FULL_DATA_MAP[(12*m+4)+:2] +\n                           FULL_DATA_MAP[12*m+:4]];\n      for (n = 0; n < PHASE_PER_CLK; n = n + 1) begin: loop_xpose\n        assign phy_dout[320*FULL_DATA_MAP[(12*m+8)+:3] +\n                        80*FULL_DATA_MAP[(12*m+4)+:2] +\n                        8*FULL_DATA_MAP[12*m+:4] + n]\n                 = mux_wrdata[DQ_WIDTH*n + m];\n      end\n    end\n\n    \n    \n    \n\n    for (m = 0; m < DQS_WIDTH; m = m + 1) begin: gen_dqs_inout\n      \n      assign mem_dqs_in[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]]\n        = in_dqs[m];\n      \n      assign out_dqs[m]\n        = mem_dqs_out[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]];\n      assign ts_dqs[m]\n        = mem_dqs_ts[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]];\n    end\n  endgenerate\n\n  assign pd_out = pd_out_pre[byte_sel_cnt_w1];\n\n\n  \n  \n  \n\n  \n  \n  \n  \n\n  OBUF u_cas_n_obuf\n    (\n     .I (out_cas_n),\n     .O (ddr_cas_n)\n     );\n\n  OBUF u_ras_n_obuf\n    (\n     .I (out_ras_n),\n     .O (ddr_ras_n)\n     );\n\n  OBUF u_we_n_obuf\n    (\n     .I (out_we_n),\n     .O (ddr_we_n)\n     );\n\n  generate\n    genvar p;\n\n    for (p = 0; p < ROW_WIDTH; p = p + 1) begin: gen_addr_obuf\n      OBUF u_addr_obuf\n        (\n         .I (out_addr[p]),\n         .O (ddr_addr[p])\n         );\n    end\n\n    for (p = 0; p < BANK_WIDTH; p = p + 1) begin: gen_bank_obuf\n      OBUF u_bank_obuf\n        (\n         .I (out_ba[p]),\n         .O (ddr_ba[p])\n         );\n    end\n\n    if (USE_CS_PORT == 1) begin: gen_cs_n_obuf\n      for (p = 0; p < CS_WIDTH*nCS_PER_RANK; p = p + 1) begin: gen_cs_obuf\n        OBUF u_cs_n_obuf\n          (\n           .I (out_cs_n[p]),\n           .O (ddr_cs_n[p])\n           );\n      end\n    end\n    if(CKE_ODT_AUX == \"FALSE\")begin:cke_odt_thru_outfifo\n      if (USE_ODT_PORT== 1) begin: gen_odt_obuf\n        for (p = 0; p < ODT_WIDTH; p = p + 1) begin: gen_odt_obuf\n          OBUF u_cs_n_obuf\n            (\n             .I (out_odt[p]),\n             .O (ddr_odt[p])\n             );\n        end\n      end\n        for (p = 0; p < CKE_WIDTH; p = p + 1) begin: gen_cke_obuf\n          OBUF u_cs_n_obuf\n            (\n             .I (out_cke[p]),\n             .O (ddr_cke[p])\n             );\n        end\n    end\n\n    if (REG_CTRL == \"ON\") begin: gen_parity_obuf\n      \n      OBUF u_parity_obuf\n        (\n         .I (out_parity),\n         .O (ddr_parity)\n         );\n    end else begin: gen_parity_tieoff\n      assign ddr_parity = 1'b0;\n    end\n\n    if ((DRAM_TYPE == \"DDR3\") || (REG_CTRL == \"ON\")) begin: gen_reset_obuf\n      \n      OBUF u_reset_obuf\n        (\n         .I (mux_reset_n),\n         .O (ddr_reset_n)\n         );\n    end else begin: gen_reset_tieoff\n      assign ddr_reset_n = 1'b1;\n    end\n\n    if (USE_DM_PORT == 1) begin: gen_dm_obuf\n      for (p = 0; p < DM_WIDTH; p = p + 1) begin: loop_dm\n        OBUFT u_dm_obuf\n          (\n           .I (out_dm[p]),\n           .T (ts_dm[p]),\n           .O (ddr_dm[p])\n           );\n      end\n    end else begin: gen_dm_tieoff\n      assign ddr_dm = 'b0;\n    end\n\n    if (DATA_IO_PRIM_TYPE == \"HP_LP\") begin: gen_dq_iobuf_HP\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF_DCIEN #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .DCITERMDISABLE (data_io_idle_pwrdwn),\n             .IBUFDISABLE    (data_io_idle_pwrdwn),\n             .I              (out_dq[p]),\n             .T              (ts_dq[p]),\n             .O              (in_dq[p]),\n             .IO             (ddr_dq[p])\n             );\n      end\n    end else if (DATA_IO_PRIM_TYPE == \"HR_LP\") begin: gen_dq_iobuf_HR\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF_INTERMDISABLE #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .INTERMDISABLE  (data_io_idle_pwrdwn),\n             .IBUFDISABLE    (data_io_idle_pwrdwn),\n             .I              (out_dq[p]),\n             .T              (ts_dq[p]),\n             .O              (in_dq[p]),\n             .IO             (ddr_dq[p])\n             );\n      end\n    end else begin: gen_dq_iobuf_default\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .I  (out_dq[p]),\n             .T  (ts_dq[p]),\n             .O  (in_dq[p]),\n             .IO (ddr_dq[p])\n             );\n      end\n    end\n\n    \n    if ((BANK_TYPE == \"HP_IO\") || (BANK_TYPE == \"HPL_IO\")) begin: gen_dqs_iobuf_HP\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else if ((DRAM_TYPE == \"DDR2\") ||\n                     (tCK > 2500)) begin : gen_ddr2_or_low_dqs_diff\n          IOBUFDS_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS_DIFF_OUT_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n         .DQS_BIAS     (\"TRUE\"),\n         .SIM_DEVICE   (\"7SERIES\"),\n             .USE_IBUFDISABLE (\"FALSE\")\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .TM             (ts_dqs[p]),\n               .TS             (ts_dqs[p]),\n               .OB             (in_dqs_lpbk_to_iddr[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n\n          mig_7series_v4_1_poc_pd #\n          (\n           .TCQ        (TCQ),\n           .POC_USE_METASTABLE_SAMP (POC_USE_METASTABLE_SAMP)\n          )\n          u_iddr_edge_det\n          (\n            .clk         (clk),\n            .iddr_rst         (iddr_rst_i),\n            .kclk        (in_dqs_lpbk_to_iddr[p]),\n            .mmcm_ps_clk (mmcm_ps_clk),\n            .pd_out      (pd_out_pre[p])\n          );\n        end\n      end\n    \n    end else if ((BANK_TYPE == \"HR_IO\") || (BANK_TYPE == \"HRL_IO\")) begin: gen_dqs_iobuf_HR\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else if ((DRAM_TYPE == \"DDR2\") ||\n                     (tCK > 2500)) begin: gen_ddr2_or_low_dqs_diff\n          IOBUFDS_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS_DIFF_OUT_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\"),\n         .SIM_DEVICE   (\"7SERIES\"),\n             .USE_IBUFDISABLE (\"FALSE\")\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               \n               .I              (out_dqs[p]),\n               .TM             (ts_dqs[p]),\n               .TS             (ts_dqs[p]),\n               .OB             (in_dqs_lpbk_to_iddr[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n\n        mig_7series_v4_1_poc_pd #\n        (\n         .TCQ        (TCQ),\n         .POC_USE_METASTABLE_SAMP (POC_USE_METASTABLE_SAMP)\n        )\n        u_iddr_edge_det\n          (\n           .clk         (clk),\n               .iddr_rst    (iddr_rst_i),\n           .kclk        (in_dqs_lpbk_to_iddr[p]),\n               .mmcm_ps_clk (mmcm_ps_clk),\n               .pd_out      (pd_out_pre[p])\n          );\n        end\n      end\n    end else begin: gen_dqs_iobuf_default\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .I   (out_dqs[p]),\n               .T   (ts_dqs[p]),\n               .O   (in_dqs[p]),\n               .IO  (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .I   (out_dqs[p]),\n               .T   (ts_dqs[p]),\n               .O   (in_dqs[p]),\n               .IO  (ddr_dqs[p]),\n               .IOB (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end\n      end\n    end\n\n  endgenerate\n\n  always @(posedge clk) begin\n    phy_ctl_wd_i1 <= #TCQ phy_ctl_wd;\n    phy_ctl_wr_i1 <= #TCQ phy_ctl_wr;\n    phy_ctl_wd_i2 <= #TCQ phy_ctl_wd_i1;\n    phy_ctl_wr_i2 <= #TCQ phy_ctl_wr_i1;\n    data_offset_1_i1 <= #TCQ data_offset_1;\n    data_offset_1_i2 <= #TCQ data_offset_1_i1;\n    data_offset_2_i1 <= #TCQ data_offset_2;\n    data_offset_2_i2 <= #TCQ data_offset_2_i1;\n  end\n\n\n  \n  \n  assign phy_ctl_wd_temp = (nCK_PER_CLK == 4) ? phy_ctl_wd_i2 : phy_ctl_wd_of;\n  assign phy_ctl_wr_temp = (nCK_PER_CLK == 4) ? phy_ctl_wr_i2 : phy_ctl_wr_of;\n  assign data_offset_1_temp = (nCK_PER_CLK == 4) ? data_offset_1_i2 : data_offset_1_of;\n  assign data_offset_2_temp = (nCK_PER_CLK == 4) ? data_offset_2_i2 : data_offset_2_of;\n\n  generate\n    begin\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (32)\n        )\n        phy_ctl_pre_fifo_0\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[1]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (phy_ctl_wd),\n         .wr_en_out (phy_ctl_wr_of),\n         .d_out     (phy_ctl_wd_of)\n        );\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (6)\n        )\n        phy_ctl_pre_fifo_1\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[2]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (data_offset_1),\n         .wr_en_out (),\n         .d_out     (data_offset_1_of)\n        );\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (6)\n        )\n        phy_ctl_pre_fifo_2\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[3]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (data_offset_2),\n         .wr_en_out (),\n         .d_out     (data_offset_2_of)\n        );\n\n    end\n  endgenerate\n\n\n\n  \n  \n  \n\n   assign phy_ctl_full = phy_ctl_full_temp[0];\n\n  mig_7series_v4_1_ddr_mc_phy #\n    (\n     .BYTE_LANES_B0                 (BYTE_LANES_B0),\n     .BYTE_LANES_B1                 (BYTE_LANES_B1),\n     .BYTE_LANES_B2                 (BYTE_LANES_B2),\n     .BYTE_LANES_B3                 (BYTE_LANES_B3),\n     .BYTE_LANES_B4                 (BYTE_LANES_B4),\n     .DATA_CTL_B0                   (DATA_CTL_B0),\n     .DATA_CTL_B1                   (DATA_CTL_B1),\n     .DATA_CTL_B2                   (DATA_CTL_B2),\n     .DATA_CTL_B3                   (DATA_CTL_B3),\n     .DATA_CTL_B4                   (DATA_CTL_B4),\n     .PHY_0_BITLANES                (PHY_0_BITLANES),\n     .PHY_1_BITLANES                (PHY_1_BITLANES),\n     .PHY_2_BITLANES                (PHY_2_BITLANES),\n     .PHY_0_BITLANES_OUTONLY        (PHY_0_BITLANES_OUTONLY),\n     .PHY_1_BITLANES_OUTONLY        (PHY_1_BITLANES_OUTONLY),\n     .PHY_2_BITLANES_OUTONLY        (PHY_2_BITLANES_OUTONLY),\n     .RCLK_SELECT_BANK              (CKE_ODT_RCLK_SELECT_BANK),\n     .RCLK_SELECT_LANE              (CKE_ODT_RCLK_SELECT_LANE),\n     \n     .GENERATE_DDR_CK_MAP           (TMP_GENERATE_DDR_CK_MAP),\n     .BYTELANES_DDR_CK              (TMP_BYTELANES_DDR_CK),\n     .NUM_DDR_CK                    (CK_WIDTH),\n     .LP_DDR_CK_WIDTH               (LP_DDR_CK_WIDTH),\n     .PO_CTL_COARSE_BYPASS          (\"FALSE\"),\n     .PHYCTL_CMD_FIFO               (\"FALSE\"),\n     .PHY_CLK_RATIO                 (nCK_PER_CLK),\n     .MASTER_PHY_CTL                (MASTER_PHY_CTL),\n     .PHY_FOUR_WINDOW_CLOCKS        (63),\n     .PHY_EVENTS_DELAY              (18),\n     .PHY_COUNT_EN                  (\"FALSE\"), \n     .PHY_SYNC_MODE                 (\"FALSE\"),\n     .SYNTHESIS                     ((SIM_CAL_OPTION == \"NONE\") ? \"TRUE\" : \"FALSE\"),\n     .PHY_DISABLE_SEQ_MATCH         (\"TRUE\"), \n     .PHY_0_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     .PHY_0_A_PI_FREQ_REF_DIV       (PHY_0_A_PI_FREQ_REF_DIV),\n     .PHY_0_CMD_OFFSET              (PHY_0_CMD_OFFSET),   \n     .PHY_0_RD_CMD_OFFSET_0         (PHY_0_RD_CMD_OFFSET_0),\n     .PHY_0_RD_CMD_OFFSET_1         (PHY_0_RD_CMD_OFFSET_1),\n     .PHY_0_RD_CMD_OFFSET_2         (PHY_0_RD_CMD_OFFSET_2),\n     .PHY_0_RD_CMD_OFFSET_3         (PHY_0_RD_CMD_OFFSET_3),\n     .PHY_0_RD_DURATION_0           (6),\n     .PHY_0_RD_DURATION_1           (6),\n     .PHY_0_RD_DURATION_2           (6),\n     .PHY_0_RD_DURATION_3           (6),\n     .PHY_0_WR_CMD_OFFSET_0         (PHY_0_WR_CMD_OFFSET_0),\n     .PHY_0_WR_CMD_OFFSET_1         (PHY_0_WR_CMD_OFFSET_1),\n     .PHY_0_WR_CMD_OFFSET_2         (PHY_0_WR_CMD_OFFSET_2),\n     .PHY_0_WR_CMD_OFFSET_3         (PHY_0_WR_CMD_OFFSET_3),\n     .PHY_0_WR_DURATION_0           (PHY_0_WR_DURATION_0),\n     .PHY_0_WR_DURATION_1           (PHY_0_WR_DURATION_1),\n     .PHY_0_WR_DURATION_2           (PHY_0_WR_DURATION_2),\n     .PHY_0_WR_DURATION_3           (PHY_0_WR_DURATION_3),\n     .PHY_0_AO_TOGGLE               ((RANKS == 1) ? 1 : 5),\n     .PHY_0_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_A_PO_OCLKDELAY_INV      (PO_OCLKDELAY_INV),\n     .PHY_0_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     \n     \n     .PHY_1_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     \n     \n     .PHY_2_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .TCK                           (tCK),\n     .PHY_0_IODELAY_GRP             (IODELAY_GRP),\n     .PHY_1_IODELAY_GRP             (IODELAY_GRP),\n     .PHY_2_IODELAY_GRP             (IODELAY_GRP),\n     .FPGA_SPEED_GRADE              (FPGA_SPEED_GRADE),\n     .BANK_TYPE                     (BANK_TYPE),\n     .CKE_ODT_AUX                   (CKE_ODT_AUX),\n     .PI_DIV2_INCDEC                (PI_DIV2_INCDEC)\n     )\n    u_ddr_mc_phy\n      (\n       .rst                    (rst),\n       \n       \n       .ddr_rst_in_n           (1'b1),\n       .phy_clk                (clk),\n       .clk_div2               (clk_div2),\n       .freq_refclk            (freq_refclk),\n       .mem_refclk             (mem_refclk),\n       \n       .mem_refclk_div4        (clk),\n       .pll_lock               (pll_lock),\n       .auxout_clk             (),\n       .sync_pulse             (sync_pulse),\n       \n       .idelayctrl_refclk      (),\n       .phy_dout               (phy_dout),\n       .phy_cmd_wr_en          (phy_cmd_wr_en),\n       .phy_data_wr_en         (phy_data_wr_en),\n       .phy_rd_en              (phy_rd_en),\n       .phy_ctl_wd             (phy_ctl_wd_temp),\n       .phy_ctl_wr             (phy_ctl_wr_temp),\n       .if_empty_def           (phy_if_empty_def),\n       .if_rst                 (phy_if_reset),\n       .phyGo                  ('b1),\n       .aux_in_1               (aux_in_1),\n       .aux_in_2               (aux_in_2),\n       \n       \n       .data_offset_1          (data_offset_1_temp),\n       .data_offset_2          (data_offset_2_temp),\n       .cke_in                 (),\n       .if_a_empty             (),\n       .if_empty               (if_empty),\n       .if_empty_or            (),\n       .if_empty_and           (),\n       .of_ctl_a_full          (),\n      \n       .of_ctl_full            (phy_cmd_full),\n       .of_data_full           (),\n       .pre_data_a_full        (phy_pre_data_a_full),\n       .idelay_ld              (idelay_ld),\n       .idelay_ce              (idelay_ce),\n       .idelay_inc             (idelay_inc),\n       .input_sink             (),\n       .phy_din                (phy_din),\n       .phy_ctl_a_full         (),\n       .phy_ctl_full           (phy_ctl_full_temp),\n       .mem_dq_out             (mem_dq_out),\n       .mem_dq_ts              (mem_dq_ts),\n       .mem_dq_in              (mem_dq_in),\n       .mem_dqs_out            (mem_dqs_out),\n       .mem_dqs_ts             (mem_dqs_ts),\n       .mem_dqs_in             (mem_dqs_in),\n       .aux_out                (aux_out),\n       .phy_ctl_ready          (),\n       .rst_out                (),\n       .ddr_clk                (ddr_clk),\n       \n       .mcGo                   (phy_mc_go),\n       .phy_write_calib        (phy_write_calib),\n       .phy_read_calib         (phy_read_calib),\n       .calib_sel              (calib_sel),\n       .calib_in_common        (calib_in_common),\n       .calib_zero_inputs      (calib_zero_inputs),\n       .calib_zero_ctrl        (calib_zero_ctrl),\n       .calib_zero_lanes       ('b0),\n       .po_fine_enable         (po_fine_enable),\n       .po_coarse_enable       (po_coarse_enable),\n       .po_fine_inc            (po_fine_inc),\n       .po_coarse_inc          (po_coarse_inc),\n       .po_counter_load_en     (po_counter_load_en),\n       .po_sel_fine_oclk_delay (po_sel_fine_oclk_delay),\n       .po_counter_load_val    (po_counter_load_val),\n       .po_counter_read_en     (po_counter_read_en),\n       .po_coarse_overflow     (),\n       .po_fine_overflow       (),\n       .po_counter_read_val    (po_counter_read_val),\n       .pi_rst_dqs_find        (pi_rst_dqs_find),\n       .pi_fine_enable         (pi_fine_enable),\n       .pi_fine_inc            (pi_fine_inc),\n       .pi_counter_load_en     (pi_counter_load_en),\n       .pi_counter_read_en     (dbg_pi_counter_read_en),\n       .pi_counter_load_val    (pi_counter_load_val),\n       .pi_fine_overflow       (),\n       .pi_counter_read_val    (pi_counter_read_val),\n       .pi_phase_locked        (pi_phase_locked),\n       .pi_phase_locked_all    (pi_phase_locked_all),\n       .pi_dqs_found           (),\n       .pi_dqs_found_any       (pi_dqs_found),\n       .pi_dqs_found_all       (pi_dqs_found_all),\n       .pi_dqs_found_lanes     (dbg_pi_dqs_found_lanes_phy4lanes),\n       \n       \n       \n       \n       .pi_dqs_out_of_range    (pi_dqs_out_of_range)\n\n       ,.ref_dll_lock          (ref_dll_lock)\n       ,.pi_phase_locked_lanes (dbg_pi_phase_locked_phy4lanes)\n       ,.fine_delay            (fine_delay_mod)\n       ,.fine_delay_sel        (fine_delay_sel_r)\n\n       );\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_ddr_mc_phy_wrapper. Module specification: This module serves as a wrapper for the DDR memory controller PHY (Physical Layer) interface in a 7 Series FPGA design. It handles the physical interface between the memory controller and DDR memory devices, managing various signals such as data, address, command, and control lines. The module takes inputs like clocks, resets, control signals, and data, and outputs memory interface signals. Key inputs include rst, clk, phy_cmd_wr_en, phy_data_wr_en, phy_ctl_wd, mux_address, mux_bank, and mux_wrdata. Outputs include ddr_clk, ddr_addr, ddr_ba, ddr_cas_n, ddr_ras_n, ddr"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_mc_phy_wrapper\n\nExplanation: This module serves as a wrapper for the DDR memory controller PHY (Physical Layer) interface in a 7 Series FPGA design. It handles the physical interface between the memory controller and DDR memory devices, managing various signals such as data, address, command, and control lines. The module includes functionality for input/output buffering, data alignment, timing adjustments, and calibration. It supports different DDR memory types and configurations, and incorporates features like per-bit deskew, write leveling, and read calibration to ensure proper signal integrity and timing across the memory interface."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nHere's a concise overview of the input and output ports for the mig_7series_v4_1_ddr_mc_phy_wrapper module:\n\nInput ports:\n- rst, iddr_rst, clk, clk_div2, freq_refclk, mem_refclk, pll_lock, sync_pulse, mmcm_ps_clk, idelayctrl_refclk\n- phy_cmd_wr_en, phy_data_wr_en, phy_ctl_wd, phy_ctl_wr, phy_if_empty_def, phy_if_reset\n- data_offset_1, data_offset_2, aux_in_1, aux_in_2\n- phy_write_calib, phy_read_calib, calib_in_common, calib_sel, byte_sel_cnt\n- fine_delay_incdec_pb, fine_delay_sel, calib_zero_inputs, calib_zero_ctrl\n- po_fine_enable, po_coarse_enable, po_fine_inc, po_coarse_inc, po_counter_load_en, po_counter_read_en, po_sel_fine_oclk_delay, po_counter_load_val\n- pi_rst_dqs_find, pi_fine_enable, pi_fine_inc, pi_counter_load_en, pi_counter_load_val\n- idelay_ce, idelay_inc, idelay_ld, idle\n- phy_init_data_sel, mux_address, mux_bank, mux_cas_n, mux_cs_n, mux_ras_n, mux_odt, mux_cke, mux_we_n, parity_in, mux_wrdata, mux_wrdata_mask, mux_reset_n\n- dbg_pi_counter_read_en, rst_phaser_ref\n\nExplanation: These inputs control various aspects of the PHY wrapper, including clock and reset signals, calibration controls, delay adjustments, and memory interface signals.\n\nOutput ports:\n- idelaye2_init_val, oclkdelay_init_val, if_empty, phy_ctl_full, phy_cmd_full, phy_data_full, phy_pre_data_a_full\n- ddr_clk, phy_mc_go, pi_phase_locked, pi_phase_locked_all, pi_dqs_found, pi_dqs_found_all, pi_dqs_out_of_range\n- rd_data, ddr_addr, ddr_ba, ddr_cas_n, ddr_cke, ddr_cs_n, ddr_dm, ddr_odt, ddr_parity, ddr_ras_n, ddr_we_n, ddr_reset_n\n- pd_out, ref_dll_lock, dbg_pi_phase_locked_phy4lanes, dbg_pi_dqs_found_lanes_phy4lanes\n- po_counter_read_val, pi_counter_read_val\n\nExplanation: These outputs provide status information, calibration results, and interface signals for the DDR memory. They include initialization values, flags for various states, and actual DDR interface signals.\n\nInout ports:\n- ddr_dq, ddr_dqs, ddr_dqs_n\n\nExplanation: These are bidirectional data and data strobe signals for the DDR memory interface."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n1. aux_out\n2. mem_dqs_in, mem_dqs_out, mem_dqs_ts\n3. mem_dq_in, mem_dq_out, mem_dq_ts\n4. in_dq, in_dqs\n5. out_addr, out_ba, out_cas_n, out_cs_n, out_dm, out_odt, out_cke, out_dq, out_dqs, out_parity, out_ras_n, out_we_n\n6. phy_din, phy_dout\n7. phy_rd_en\n8. ts_dm, ts_dq, ts_dqs\n9. in_dqs_lpbk_to_iddr\n10. pd_out_pre\n11. phy_ctl_wd_i1, phy_ctl_wd_i2, phy_ctl_wr_i1, phy_ctl_wr_i2\n12. data_offset_1_i1, data_offset_1_i2, data_offset_2_i1, data_offset_2_i2\n13. phy_ctl_wd_temp, phy_ctl_wr_temp, data_offset_1_temp, data_offset_2_temp\n14. data_offset_1_of, data_offset_2_of, phy_ctl_wd_of, phy_ctl_wr_of\n15. phy_ctl_full_temp\n16. data_io_idle_pwrdwn\n17. fine_delay_mod, fine_delay_sel_r\n18. iddr_rst_i\n19. byte_sel_cnt_w1\n\nExplanation:\n1. aux_out: Auxiliary output signals for CKE and ODT control.\n2. mem_dqs_in/out/ts: DQS signals for memory interface (input, output, and tri-state).\n3. mem_dq_in/out/ts: DQ signals for memory interface (input, output, and tri-state).\n4. in_dq, in_dqs: Input signals for DQ and DQS lines.\n5. out_* signals: Output signals for various memory interface lines (address, bank, commands, etc.).\n6. phy_din, phy_dout: Data input and output for the PHY interface.\n7. phy_rd_en: Read enable signal for the PHY.\n8. ts_dm, ts_dq, ts_dqs: Tri-state control signals for DM, DQ, and DQS lines.\n9. in_dqs_lpbk_to_iddr: DQS loopback signal to IDDR.\n10. pd_out_pre: Pre-processed phase detector output.\n11-14. phy_ctl_* and data_offset_* signals: Pipelined and temporary signals for PHY control and data offset.\n15. phy_ctl_full_temp: Temporary signal for PHY control full status.\n16. data_io_idle_pwrdwn: Control signal for data I/O idle power down.\n17. fine_delay_mod, fine_delay_sel_r: Signals for fine delay adjustment.\n18. iddr_rst_i: IDDR reset signal.\n19. byte_sel_cnt_w1: Byte select count signal."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ps / 1 ps\n\nmodule mig_7series_v4_1_ddr_mc_phy_wrapper #\n  (\n   parameter TCQ              = 100,    \n   parameter tCK              = 2500,   \n   parameter BANK_TYPE        = \"HP_IO\", \n   parameter DATA_IO_PRIM_TYPE = \"DEFAULT\", \n   parameter DATA_IO_IDLE_PWRDWN = \"ON\",  \n   parameter IODELAY_GRP      = \"IODELAY_MIG\",\n   parameter FPGA_SPEED_GRADE = 1,\n   parameter nCK_PER_CLK      = 4,      \n   parameter nCS_PER_RANK     = 1,      \n   parameter BANK_WIDTH       = 3,      \n   parameter CKE_WIDTH        = 1,      \n   parameter CS_WIDTH         = 1,      \n   parameter CK_WIDTH         = 1,      \n   parameter CWL              = 5,      \n   parameter DDR2_DQSN_ENABLE = \"YES\",  \n   parameter DM_WIDTH         = 8,      \n   parameter DQ_WIDTH         = 16,     \n   parameter DQS_CNT_WIDTH    = 3,      \n   parameter DQS_WIDTH        = 8,      \n   parameter DRAM_TYPE        = \"DDR3\", \n   parameter RANKS            = 4,      \n   parameter ODT_WIDTH        = 1,      \n   parameter POC_USE_METASTABLE_SAMP = \"FALSE\",\n   parameter REG_CTRL         = \"OFF\",  \n   parameter ROW_WIDTH        = 16,     \n   parameter USE_CS_PORT      = 1,      \n   parameter USE_DM_PORT      = 1,      \n   parameter USE_ODT_PORT     = 1,      \n   parameter IBUF_LPWR_MODE   = \"OFF\",  \n   parameter LP_DDR_CK_WIDTH  = 2,\n\n   \n   parameter PHYCTL_CMD_FIFO = \"FALSE\",\n   parameter DATA_CTL_B0     = 4'hc,\n   parameter DATA_CTL_B1     = 4'hf,\n   parameter DATA_CTL_B2     = 4'hf,\n   parameter DATA_CTL_B3     = 4'hf,\n   parameter DATA_CTL_B4     = 4'hf,\n   parameter BYTE_LANES_B0   = 4'b1111,\n   parameter BYTE_LANES_B1   = 4'b0000,\n   parameter BYTE_LANES_B2   = 4'b0000,\n   parameter BYTE_LANES_B3   = 4'b0000,\n   parameter BYTE_LANES_B4   = 4'b0000,\n   parameter PHY_0_BITLANES  = 48'h0000_0000_0000,\n   parameter PHY_1_BITLANES  = 48'h0000_0000_0000,\n   parameter PHY_2_BITLANES  = 48'h0000_0000_0000,\n   \n   parameter HIGHEST_BANK    = 3,        \n   parameter HIGHEST_LANE    = 12,       \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   parameter CK_BYTE_MAP\n     = 144'h00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00,\n   parameter ADDR_MAP\n     = 192'h000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000,\n   parameter BANK_MAP   = 36'h000_000_000,\n   parameter CAS_MAP    = 12'h000,\n   parameter CKE_ODT_BYTE_MAP = 8'h00,\n   parameter CKE_MAP    = 96'h000_000_000_000_000_000_000_000,\n   parameter ODT_MAP    = 96'h000_000_000_000_000_000_000_000,\n   parameter CKE_ODT_AUX = \"FALSE\",\n   parameter CS_MAP     = 120'h000_000_000_000_000_000_000_000_000_000,\n   parameter PARITY_MAP = 12'h000,\n   parameter RAS_MAP    = 12'h000,\n   parameter WE_MAP     = 12'h000,\n   parameter DQS_BYTE_MAP\n     = 144'h00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00,\n   \n   parameter DATA0_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA1_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA2_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA3_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA4_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA5_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA6_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA7_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA8_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA9_MAP  = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA10_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA11_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA12_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA13_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA14_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA15_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA16_MAP = 96'h000_000_000_000_000_000_000_000,\n   parameter DATA17_MAP = 96'h000_000_000_000_000_000_000_000,\n   \n   parameter MASK0_MAP  = 108'h000_000_000_000_000_000_000_000_000,\n   parameter MASK1_MAP  = 108'h000_000_000_000_000_000_000_000_000,\n   \n   parameter SIM_CAL_OPTION  = \"NONE\",\n\n   \n   \n   parameter MASTER_PHY_CTL  = 1,\n   parameter DRAM_WIDTH = 8,\n   parameter PI_DIV2_INCDEC = \"FALSE\"\n  )\n  (\n   input                               rst,\n   input                               iddr_rst,\n   input                               clk,\n   input                               clk_div2,\n   input                               freq_refclk,\n   input                               mem_refclk,\n   input                               pll_lock,\n   input                               sync_pulse,\n   input                               mmcm_ps_clk,\n   input                               idelayctrl_refclk,\n   input                               phy_cmd_wr_en,\n   input                               phy_data_wr_en,\n   input [31:0]                        phy_ctl_wd,\n   input                               phy_ctl_wr,\n   input                               phy_if_empty_def,\n   input                               phy_if_reset,\n   input [5:0]                         data_offset_1,\n   input [5:0]                         data_offset_2,\n   input [3:0]                         aux_in_1,\n   input [3:0]                         aux_in_2,\n   output [4:0]                        idelaye2_init_val,\n   output [5:0]                        oclkdelay_init_val,\n   output                              if_empty,\n   output                              phy_ctl_full,\n   output                              phy_cmd_full,\n   output                              phy_data_full,\n   output                              phy_pre_data_a_full,\n   output [(CK_WIDTH * LP_DDR_CK_WIDTH)-1:0] ddr_clk,\n   output                              phy_mc_go,\n   input                               phy_write_calib,\n   input                               phy_read_calib,\n   input                               calib_in_common,\n   input [5:0]                         calib_sel,\n   input [DQS_CNT_WIDTH:0]             byte_sel_cnt,\n   input [DRAM_WIDTH-1:0]              fine_delay_incdec_pb,\n   input                               fine_delay_sel,\n   input [HIGHEST_BANK-1:0]            calib_zero_inputs,\n   input [HIGHEST_BANK-1:0]            calib_zero_ctrl,\n   input [2:0]                         po_fine_enable,\n   input [2:0]                         po_coarse_enable,\n   input [2:0]                         po_fine_inc,\n   input [2:0]                         po_coarse_inc,\n   input                               po_counter_load_en,\n   input                               po_counter_read_en,\n   input [2:0]                         po_sel_fine_oclk_delay,\n   input [8:0]                         po_counter_load_val,\n   output [8:0]                        po_counter_read_val,\n   output [5:0]                        pi_counter_read_val,\n   input [HIGHEST_BANK-1:0]            pi_rst_dqs_find,\n   input                               pi_fine_enable,\n   input                               pi_fine_inc,\n   input                               pi_counter_load_en,\n   input [5:0]                         pi_counter_load_val,\n   input                               idelay_ce,\n   input                               idelay_inc,\n   input                               idelay_ld,\n   input                               idle,\n   output                              pi_phase_locked,\n   output                              pi_phase_locked_all,\n   output                              pi_dqs_found,\n   output                              pi_dqs_found_all,\n   output                              pi_dqs_out_of_range,\n   \n   input                                         phy_init_data_sel,\n   input [nCK_PER_CLK*ROW_WIDTH-1:0]             mux_address,\n   input [nCK_PER_CLK*BANK_WIDTH-1:0]            mux_bank,\n   input [nCK_PER_CLK-1:0]                       mux_cas_n,\n   input [CS_WIDTH*nCS_PER_RANK*nCK_PER_CLK-1:0] mux_cs_n,\n   input [nCK_PER_CLK-1:0]                       mux_ras_n,\n   input [1:0]                                   mux_odt,\n   input [nCK_PER_CLK-1:0]                       mux_cke,\n   input [nCK_PER_CLK-1:0]                       mux_we_n,\n   input [nCK_PER_CLK-1:0]                       parity_in,\n   input [2*nCK_PER_CLK*DQ_WIDTH-1:0]            mux_wrdata,\n   input [2*nCK_PER_CLK*(DQ_WIDTH/8)-1:0]        mux_wrdata_mask,\n   input                                         mux_reset_n,\n   output [2*nCK_PER_CLK*DQ_WIDTH-1:0]           rd_data,\n   \n   output [ROW_WIDTH-1:0]                        ddr_addr,\n   output [BANK_WIDTH-1:0]                       ddr_ba,\n   output                                        ddr_cas_n,\n   output [CKE_WIDTH-1:0]                        ddr_cke,\n   output [CS_WIDTH*nCS_PER_RANK-1:0]            ddr_cs_n,\n   output [DM_WIDTH-1:0]                         ddr_dm,\n   output [ODT_WIDTH-1:0]                        ddr_odt,\n   output                                        ddr_parity,\n   output                                        ddr_ras_n,\n   output                                        ddr_we_n,\n   output                                        ddr_reset_n,\n   inout [DQ_WIDTH-1:0]                          ddr_dq,\n   inout [DQS_WIDTH-1:0]                         ddr_dqs,\n   inout [DQS_WIDTH-1:0]                         ddr_dqs_n,\n   \n   output                                        pd_out\n\n   ,input                                        dbg_pi_counter_read_en\n   ,output                                       ref_dll_lock\n   ,input                                        rst_phaser_ref\n   ,output [11:0]                                dbg_pi_phase_locked_phy4lanes\n   ,output [11:0]                                dbg_pi_dqs_found_lanes_phy4lanes\n   );\n\n  function [71:0] generate_bytelanes_ddr_ck;\n    input [143:0] ck_byte_map;\n    integer v ;\n    begin\n      generate_bytelanes_ddr_ck = 'b0 ;\n      for (v = 0; v < CK_WIDTH; v = v + 1) begin\n        if ((CK_BYTE_MAP[((v*8)+4)+:4]) == 2)\n          generate_bytelanes_ddr_ck[48+(4*v)+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n        else if ((CK_BYTE_MAP[((v*8)+4)+:4]) == 1)\n          generate_bytelanes_ddr_ck[24+(4*v)+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n        else\n          generate_bytelanes_ddr_ck[4*v+1*(CK_BYTE_MAP[(v*8)+:4])] = 1'b1;\n      end\n    end\n  endfunction\n\n  function [(2*CK_WIDTH*8)-1:0] generate_ddr_ck_map;\n    input [143:0] ck_byte_map;\n    integer g;\n    begin\n      generate_ddr_ck_map = 'b0 ;\n      for(g = 0 ; g < CK_WIDTH ; g= g + 1) begin\n        generate_ddr_ck_map[(g*2*8)+:8]  = (ck_byte_map[(g*8)+:4] == 4'd0) ? \"A\" :\n                                           (ck_byte_map[(g*8)+:4] == 4'd1) ? \"B\" :\n                                           (ck_byte_map[(g*8)+:4] == 4'd2) ? \"C\" : \"D\" ;\n        generate_ddr_ck_map[(((g*2)+1)*8)+:8] = (ck_byte_map[((g*8)+4)+:4] == 4'd0) ? \"0\" :\n                                                (ck_byte_map[((g*8)+4)+:4] == 4'd1) ? \"1\" :  \"2\" ; \n      end\n    end\n  endfunction\n\n\n\n  \n  localparam IBUF_LOW_PWR\n             = (IBUF_LPWR_MODE == \"OFF\") ? \"FALSE\" :\n             ((IBUF_LPWR_MODE == \"ON\")  ? \"TRUE\" : \"ILLEGAL\");\n\n  \n  localparam DQ_PER_DQS = DQ_WIDTH / DQS_WIDTH;\n  \n  localparam PHASE_PER_CLK = 2*nCK_PER_CLK;\n  \n  \n  localparam PHASE_DIV = 4 / nCK_PER_CLK;\n\n  localparam CLK_PERIOD = tCK * nCK_PER_CLK;\n\n  \n  \n  \n  \n  localparam FULL_DATA_MAP = {DATA17_MAP[12*DQ_PER_DQS-1:0],\n                              DATA16_MAP[12*DQ_PER_DQS-1:0],\n                              DATA15_MAP[12*DQ_PER_DQS-1:0],\n                              DATA14_MAP[12*DQ_PER_DQS-1:0],\n                              DATA13_MAP[12*DQ_PER_DQS-1:0],\n                              DATA12_MAP[12*DQ_PER_DQS-1:0],\n                              DATA11_MAP[12*DQ_PER_DQS-1:0],\n                              DATA10_MAP[12*DQ_PER_DQS-1:0],\n                              DATA9_MAP[12*DQ_PER_DQS-1:0],\n                              DATA8_MAP[12*DQ_PER_DQS-1:0],\n                              DATA7_MAP[12*DQ_PER_DQS-1:0],\n                              DATA6_MAP[12*DQ_PER_DQS-1:0],\n                              DATA5_MAP[12*DQ_PER_DQS-1:0],\n                              DATA4_MAP[12*DQ_PER_DQS-1:0],\n                              DATA3_MAP[12*DQ_PER_DQS-1:0],\n                              DATA2_MAP[12*DQ_PER_DQS-1:0],\n                              DATA1_MAP[12*DQ_PER_DQS-1:0],\n                              DATA0_MAP[12*DQ_PER_DQS-1:0]};\n  \n  localparam FULL_MASK_MAP = {MASK1_MAP, MASK0_MAP};\n  localparam TMP_BYTELANES_DDR_CK  = generate_bytelanes_ddr_ck(CK_BYTE_MAP) ;\n  localparam TMP_GENERATE_DDR_CK_MAP = generate_ddr_ck_map(CK_BYTE_MAP) ;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  function [143:0] calc_phy_bitlanes_outonly;\n    input [215:0] data_mask_in;\n    integer       z;\n    begin\n      calc_phy_bitlanes_outonly = 'b0;\n      \n      \n      if (USE_DM_PORT == 1)\n        for (z = 0; z < DM_WIDTH; z = z + 1)\n          calc_phy_bitlanes_outonly[48*data_mask_in[(12*z+8)+:3] +\n                                    12*data_mask_in[(12*z+4)+:2] +\n                                    data_mask_in[12*z+:4]] = 1'b1;\n    end\n  endfunction\n\n  localparam PHY_BITLANES_OUTONLY   = calc_phy_bitlanes_outonly(FULL_MASK_MAP);\n  localparam PHY_0_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[47:0];\n  localparam PHY_1_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[95:48];\n  localparam PHY_2_BITLANES_OUTONLY = PHY_BITLANES_OUTONLY[143:96];\n\n  \n  \n  localparam CKE_ODT_RCLK_SELECT_BANK_AUX_ON\n             = (CKE_ODT_BYTE_MAP[7:4] == 4'h0) ? 0 :\n                 ((CKE_ODT_BYTE_MAP[7:4] == 4'h1) ? 1 :\n                  ((CKE_ODT_BYTE_MAP[7:4] == 4'h2) ? 2 :\n                   ((CKE_ODT_BYTE_MAP[7:4] == 4'h3) ? 3 :\n                    ((CKE_ODT_BYTE_MAP[7:4] == 4'h4) ? 4 : -1))));\n  localparam CKE_ODT_RCLK_SELECT_LANE_AUX_ON\n             = (CKE_ODT_BYTE_MAP[3:0] == 4'h0) ? \"A\" :\n                 ((CKE_ODT_BYTE_MAP[3:0] == 4'h1) ? \"B\" :\n                  ((CKE_ODT_BYTE_MAP[3:0] == 4'h2) ? \"C\" :\n                   ((CKE_ODT_BYTE_MAP[3:0] == 4'h3) ? \"D\" : \"ILLEGAL\")));\n\n  localparam CKE_ODT_RCLK_SELECT_BANK_AUX_OFF\n             = (CKE_MAP[11:8] == 4'h0) ? 0 :\n                 ((CKE_MAP[11:8] == 4'h1) ? 1 :\n                  ((CKE_MAP[11:8] == 4'h2) ? 2 :\n                   ((CKE_MAP[11:8] == 4'h3) ? 3 :\n                    ((CKE_MAP[11:8] == 4'h4) ? 4 : -1))));\n  localparam CKE_ODT_RCLK_SELECT_LANE_AUX_OFF\n             = (CKE_MAP[7:4] == 4'h0) ? \"A\" :\n                 ((CKE_MAP[7:4] == 4'h1) ? \"B\" :\n                  ((CKE_MAP[7:4] == 4'h2) ? \"C\" :\n                   ((CKE_MAP[7:4] == 4'h3) ? \"D\" : \"ILLEGAL\")));\n\n\n  localparam CKE_ODT_RCLK_SELECT_BANK = (CKE_ODT_AUX == \"TRUE\") ? CKE_ODT_RCLK_SELECT_BANK_AUX_ON : CKE_ODT_RCLK_SELECT_BANK_AUX_OFF ;\n  localparam CKE_ODT_RCLK_SELECT_LANE = (CKE_ODT_AUX == \"TRUE\") ? CKE_ODT_RCLK_SELECT_LANE_AUX_ON : CKE_ODT_RCLK_SELECT_LANE_AUX_OFF ;\n\n\n  \n  \n  \n  \n  \n\n  \n  \n  \n  localparam PO_OCLKDELAY_INV = (tCK >= 2500) ?  \"FALSE\" : \"TRUE\";\n\n  \n  \n  localparam PHY_0_A_PI_FREQ_REF_DIV = tCK > 5000 ?  \"DIV4\" :\n                                       tCK >= 2500 ? \"DIV2\": \"NONE\";\n\n  localparam FREQ_REF_DIV = (PHY_0_A_PI_FREQ_REF_DIV == \"DIV4\" ? 4 :\n                             PHY_0_A_PI_FREQ_REF_DIV == \"DIV2\" ? 2 : 1);\n\n  \n  localparam real INT_DELAY = 0.4392/FREQ_REF_DIV + 100.0/tCK;\n\n  \n  localparam real HALF_CYCLE_DELAY = 0.5*(PO_OCLKDELAY_INV == \"TRUE\" ? 1 : 0);\n\n  \n  \n  \n  localparam real MC_OCLK_DELAY = ((PO_OCLKDELAY_INV == \"TRUE\" ? 1.25 : 0.25) -\n                                   (INT_DELAY + HALF_CYCLE_DELAY))\n                                   * 63 * FREQ_REF_DIV;\n  \n\n  localparam integer PHY_0_A_PO_OCLK_DELAY_HW\n                     = (tCK > 2273)  ? 34 :\n                       (tCK > 2000)  ? 33 :\n                       (tCK > 1724)  ? 32 :\n                       (tCK > 1515)  ? 31 :\n                       (tCK > 1315)  ? 30 :\n                       (tCK > 1136)  ? 29 :\n                       (tCK > 1021)  ? 28 : 27;\n\n  \n  \n  localparam integer PHY_0_A_PO_OCLK_DELAY = (SIM_CAL_OPTION == \"NONE\") ?   \n                                               ((tCK >= 2500) ? 0 :\n                                                (DRAM_TYPE == \"DDR3\") ? PHY_0_A_PO_OCLK_DELAY_HW : 30) :\n                                               (tCK >= 2500) ? 0 : MC_OCLK_DELAY;\n\n  \n  localparam PHY_0_A_IDELAYE2_IDELAY_VALUE = (SIM_CAL_OPTION != \"FAST_CAL\") ? 0 :\n                  (tCK < 1000) ? 0 :\n                  (tCK < 1330) ? 0 :\n                  (tCK < 2300) ? 0 :\n                  (tCK < 2500) ? 2 : 0;\n  \n\n  \n  localparam PHY_0_RD_CMD_OFFSET_0 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_1 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_2 = 10;\n  localparam PHY_0_RD_CMD_OFFSET_3 = 10;\n  \n  localparam PHY_0_WR_CMD_OFFSET_0 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_1 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_2 = (nCK_PER_CLK == 4) ? 8 : 4;\n  localparam PHY_0_WR_CMD_OFFSET_3 = (nCK_PER_CLK == 4) ? 8 : 4;\n  \n  localparam PHY_0_WR_DURATION_0 = 7;\n  localparam PHY_0_WR_DURATION_1 = 7;\n  localparam PHY_0_WR_DURATION_2 = 7;\n  localparam PHY_0_WR_DURATION_3 = 7;\n  \n  localparam CWL_M = (REG_CTRL == \"ON\") ? CWL + 1 : CWL;\n  localparam PHY_0_CMD_OFFSET = (nCK_PER_CLK == 4) ?  (CWL_M % 2) ? 8 : 9 :\n                                  (CWL < 7) ?\n                                    4 + ((CWL_M % 2) ? 0 : 1) :\n                                    5 + ((CWL_M % 2) ? 0 : 1);\n\n  \n  \n  \n  localparam PHY_COUNT_EN = (nCK_PER_CLK == 4) ? \"TRUE\" : \"FALSE\";\n\n\n  wire [((HIGHEST_LANE+3)/4)*4-1:0] aux_out;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_in;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_out;\n  wire [HIGHEST_LANE-1:0]           mem_dqs_ts;\n  wire [HIGHEST_LANE*10-1:0]        mem_dq_in;\n  wire [HIGHEST_LANE*12-1:0]        mem_dq_out;\n  wire [HIGHEST_LANE*12-1:0]        mem_dq_ts;\n  wire [DQ_WIDTH-1:0]               in_dq;\n  wire [DQS_WIDTH-1:0]              in_dqs;\n  wire [ROW_WIDTH-1:0]              out_addr;\n  wire [BANK_WIDTH-1:0]             out_ba;\n  wire                              out_cas_n;\n  wire [CS_WIDTH*nCS_PER_RANK-1:0]  out_cs_n;\n  wire [DM_WIDTH-1:0]               out_dm;\n  wire [ODT_WIDTH -1:0]             out_odt;\n  wire [CKE_WIDTH -1 :0]            out_cke ;\n  wire [DQ_WIDTH-1:0]               out_dq;\n  wire [DQS_WIDTH-1:0]              out_dqs;\n  wire                              out_parity;\n  wire                              out_ras_n;\n  wire                              out_we_n;\n  wire [HIGHEST_LANE*80-1:0]        phy_din;\n  wire [HIGHEST_LANE*80-1:0]        phy_dout;\n  wire                              phy_rd_en;\n  wire [DM_WIDTH-1:0]               ts_dm;\n  wire [DQ_WIDTH-1:0]               ts_dq;\n  wire [DQS_WIDTH-1:0]              ts_dqs;\n  wire [DQS_WIDTH-1:0]              in_dqs_lpbk_to_iddr;\n  wire [DQS_WIDTH-1:0]              pd_out_pre;\n  \n\n  reg [31:0]                        phy_ctl_wd_i1;\n  reg [31:0]                        phy_ctl_wd_i2;\n  reg                               phy_ctl_wr_i1;\n  reg                               phy_ctl_wr_i2;\n  reg [5:0]                         data_offset_1_i1;\n  reg [5:0]                         data_offset_1_i2;\n  reg [5:0]                         data_offset_2_i1;\n  reg [5:0]                         data_offset_2_i2;\n  wire [31:0]                       phy_ctl_wd_temp;\n  wire                              phy_ctl_wr_temp;\n  wire [5:0]                        data_offset_1_temp;\n  wire [5:0]                        data_offset_2_temp;\n  wire [5:0]                        data_offset_1_of;\n  wire [5:0]                        data_offset_2_of;\n  wire [31:0]                       phy_ctl_wd_of;\n  wire          phy_ctl_wr_of ;\n  wire [3:0]                        phy_ctl_full_temp;\n\n  wire                              data_io_idle_pwrdwn;\n  reg  [29:0]                       fine_delay_mod;    \n  reg                               fine_delay_sel_r;  \n\n  wire iddr_rst_i;\n\n  (* use_dsp48 = \"no\" *) wire [DQS_CNT_WIDTH:0]             byte_sel_cnt_w1;\n\n  \n  assign phy_rd_en = !if_empty;\n\n  \n  assign idelaye2_init_val = PHY_0_A_IDELAYE2_IDELAY_VALUE;\n  assign oclkdelay_init_val = PHY_0_A_PO_OCLK_DELAY;\n\n  \n  assign data_io_idle_pwrdwn = DATA_IO_IDLE_PWRDWN == \"ON\" ? idle : 1'b0;\n  assign iddr_rst_i = iddr_rst;\n  \n  \n  \n\n  \n  \n  \n  \n  generate\n  if(CKE_ODT_AUX == \"TRUE\")begin:cke_thru_auxpins\n    if (CKE_WIDTH == 1) begin : gen_cke\n      \n      \n      \n      \n      \n      \n      OBUF u_cke_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK]),\n         .O (ddr_cke)\n         );\n    end else begin: gen_2rank_cke\n      OBUF u_cke0_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK]),\n         .O (ddr_cke[0])\n         );\n      OBUF u_cke1_obuf\n        (\n         .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n         .O (ddr_cke[1])\n         );\n    end\n  end\n  endgenerate\n\n  generate\n  if(CKE_ODT_AUX == \"TRUE\")begin:odt_thru_auxpins\n    if (USE_ODT_PORT == 1) begin : gen_use_odt\n      \n      \n      \n      \n      \n      \n        OBUF u_odt_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+1]),\n           .O (ddr_odt[0])\n           );\n      if (ODT_WIDTH == 2 && RANKS == 1) begin: gen_2port_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n           .O (ddr_odt[1])\n           );\n      end else if (ODT_WIDTH == 2 && RANKS == 2) begin: gen_2rank_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+3]),\n           .O (ddr_odt[1])\n           );\n      end else if (ODT_WIDTH == 3 && RANKS == 1) begin: gen_3port_odt\n        OBUF u_odt1_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+2]),\n           .O (ddr_odt[1])\n           );\n        OBUF u_odt2_obuf\n          (\n           .I (aux_out[4*CKE_ODT_RCLK_SELECT_BANK+3]),\n           .O (ddr_odt[2])\n           );\n      end\n    end else begin\n        assign ddr_odt = 'b0;\n    end\n  end\n  endgenerate\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  generate\n    genvar i, j;\n    for (i = 0; i < DQ_WIDTH; i = i + 1) begin: gen_loop_rd_data_1\n      for (j = 0; j < PHASE_PER_CLK; j = j + 1) begin: gen_loop_rd_data_2\n        assign rd_data[DQ_WIDTH*j + i]\n                 = phy_din[(320*FULL_DATA_MAP[(12*i+8)+:3]+\n                            80*FULL_DATA_MAP[(12*i+4)+:2] +\n                            8*FULL_DATA_MAP[12*i+:4]) + j];\n      end\n    end\n  endgenerate\n\n  \n\n  reg [11:0] cal_tmp;\n  reg [95:0] byte_sel_data_map;\n\n  assign byte_sel_cnt_w1 = byte_sel_cnt;\n\n  always @ (posedge clk) begin\n     byte_sel_data_map <= #TCQ FULL_DATA_MAP[12*DQ_PER_DQS*byte_sel_cnt_w1+:96];\n  end\n\n  always @ (posedge clk) begin\n     fine_delay_mod[((byte_sel_data_map[3:0])*3)+:3] <= #TCQ {fine_delay_incdec_pb[0],2'b00};\n     fine_delay_mod[((byte_sel_data_map[12+3:12])*3)+:3] <= #TCQ {fine_delay_incdec_pb[1],2'b00};\n     fine_delay_mod[((byte_sel_data_map[24+3:24])*3)+:3] <= #TCQ {fine_delay_incdec_pb[2],2'b00};\n     fine_delay_mod[((byte_sel_data_map[36+3:36])*3)+:3] <= #TCQ {fine_delay_incdec_pb[3],2'b00};\n     fine_delay_mod[((byte_sel_data_map[48+3:48])*3)+:3] <= #TCQ {fine_delay_incdec_pb[4],2'b00};\n     fine_delay_mod[((byte_sel_data_map[60+3:60])*3)+:3] <= #TCQ {fine_delay_incdec_pb[5],2'b00};\n     fine_delay_mod[((byte_sel_data_map[72+3:72])*3)+:3] <= #TCQ {fine_delay_incdec_pb[6],2'b00};\n     fine_delay_mod[((byte_sel_data_map[84+3:84])*3)+:3] <= #TCQ {fine_delay_incdec_pb[7],2'b00};\n     fine_delay_sel_r <= #TCQ fine_delay_sel;\n  end\n\n  \n  \n  \n\n  assign out_cas_n\n    = mem_dq_out[48*CAS_MAP[10:8] + 12*CAS_MAP[5:4] + CAS_MAP[3:0]];\n\n  generate\n    \n    if (CAS_MAP[3:0] < 4'hA) begin: gen_cas_lt10\n      \n      \n      \n      \n      \n      \n      assign phy_dout[(320*CAS_MAP[10:8] + 80*CAS_MAP[5:4] +\n                       8*CAS_MAP[3:0])+:4]\n               = {mux_cas_n[3/PHASE_DIV], mux_cas_n[2/PHASE_DIV],\n                  mux_cas_n[1/PHASE_DIV], mux_cas_n[0]};\n    end else begin: gen_cas_ge10\n      \n      \n      \n      \n      \n      assign phy_dout[(320*CAS_MAP[10:8] + 80*CAS_MAP[5:4] +\n                       8*(CAS_MAP[3:0]-5) + 4)+:4]\n               = {mux_cas_n[3/PHASE_DIV], mux_cas_n[2/PHASE_DIV],\n                  mux_cas_n[1/PHASE_DIV], mux_cas_n[0]};\n    end\n  endgenerate\n\n  assign out_ras_n\n    = mem_dq_out[48*RAS_MAP[10:8] + 12*RAS_MAP[5:4] + RAS_MAP[3:0]];\n\n  generate\n    if (RAS_MAP[3:0] < 4'hA) begin: gen_ras_lt10\n      assign phy_dout[(320*RAS_MAP[10:8] + 80*RAS_MAP[5:4] +\n                       8*RAS_MAP[3:0])+:4]\n               = {mux_ras_n[3/PHASE_DIV], mux_ras_n[2/PHASE_DIV],\n                  mux_ras_n[1/PHASE_DIV], mux_ras_n[0]};\n    end else begin: gen_ras_ge10\n      assign phy_dout[(320*RAS_MAP[10:8] + 80*RAS_MAP[5:4] +\n                       8*(RAS_MAP[3:0]-5) + 4)+:4]\n               = {mux_ras_n[3/PHASE_DIV], mux_ras_n[2/PHASE_DIV],\n                  mux_ras_n[1/PHASE_DIV], mux_ras_n[0]};\n    end\n  endgenerate\n\n  assign out_we_n\n    = mem_dq_out[48*WE_MAP[10:8] + 12*WE_MAP[5:4] + WE_MAP[3:0]];\n\n  generate\n    if (WE_MAP[3:0] < 4'hA) begin: gen_we_lt10\n      assign phy_dout[(320*WE_MAP[10:8] + 80*WE_MAP[5:4] +\n                       8*WE_MAP[3:0])+:4]\n               = {mux_we_n[3/PHASE_DIV], mux_we_n[2/PHASE_DIV],\n                  mux_we_n[1/PHASE_DIV], mux_we_n[0]};\n    end else begin: gen_we_ge10\n      assign phy_dout[(320*WE_MAP[10:8] + 80*WE_MAP[5:4] +\n                       8*(WE_MAP[3:0]-5) + 4)+:4]\n               = {mux_we_n[3/PHASE_DIV], mux_we_n[2/PHASE_DIV],\n                  mux_we_n[1/PHASE_DIV], mux_we_n[0]};\n    end\n  endgenerate\n\n  generate\n    if (REG_CTRL == \"ON\") begin: gen_parity_out\n      \n      assign out_parity\n        = mem_dq_out[48*PARITY_MAP[10:8] + 12*PARITY_MAP[5:4] +\n                     PARITY_MAP[3:0]];\n      if (PARITY_MAP[3:0] < 4'hA) begin: gen_lt10\n        assign phy_dout[(320*PARITY_MAP[10:8] + 80*PARITY_MAP[5:4] +\n                         8*PARITY_MAP[3:0])+:4]\n                 = {parity_in[3/PHASE_DIV], parity_in[2/PHASE_DIV],\n                    parity_in[1/PHASE_DIV], parity_in[0]};\n      end else begin: gen_ge10\n        assign phy_dout[(320*PARITY_MAP[10:8] + 80*PARITY_MAP[5:4] +\n                         8*(PARITY_MAP[3:0]-5) + 4)+:4]\n               = {parity_in[3/PHASE_DIV], parity_in[2/PHASE_DIV],\n                  parity_in[1/PHASE_DIV], parity_in[0]};\n      end\n    end\n  endgenerate\n\n  \n\n  generate\n    genvar m, n,x;\n\n    \n    \n    \n\n    \n    for (m = 0; m < ROW_WIDTH; m = m + 1) begin: gen_addr_out\n      assign out_addr[m]\n               = mem_dq_out[48*ADDR_MAP[(12*m+8)+:3] +\n                            12*ADDR_MAP[(12*m+4)+:2] +\n                            ADDR_MAP[12*m+:4]];\n\n      if (ADDR_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n        \n        \n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*ADDR_MAP[(12*m+8)+:3] +\n                          80*ADDR_MAP[(12*m+4)+:2] +\n                          8*ADDR_MAP[12*m+:4] + n]\n                   = mux_address[ROW_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end else begin: gen_ge10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*ADDR_MAP[(12*m+8)+:3] +\n                          80*ADDR_MAP[(12*m+4)+:2] +\n                          8*(ADDR_MAP[12*m+:4]-5) + 4 + n]\n                   = mux_address[ROW_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end\n    end\n\n    \n    for (m = 0; m < BANK_WIDTH; m = m + 1) begin: gen_ba_out\n        assign out_ba[m]\n                 = mem_dq_out[48*BANK_MAP[(12*m+8)+:3] +\n                              12*BANK_MAP[(12*m+4)+:2] +\n                              BANK_MAP[12*m+:4]];\n\n      if (BANK_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*BANK_MAP[(12*m+8)+:3] +\n                          80*BANK_MAP[(12*m+4)+:2] +\n                          8*BANK_MAP[12*m+:4] + n]\n                   = mux_bank[BANK_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end else begin: gen_ge10\n        for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*BANK_MAP[(12*m+8)+:3] +\n                          80*BANK_MAP[(12*m+4)+:2] +\n                          8*(BANK_MAP[12*m+:4]-5) + 4 + n]\n                   = mux_bank[BANK_WIDTH*(n/PHASE_DIV) + m];\n        end\n      end\n    end\n\n    \n    if (USE_CS_PORT == 1) begin: gen_cs_n_out\n      for (m = 0; m < CS_WIDTH*nCS_PER_RANK; m = m + 1) begin: gen_cs_out\n        assign out_cs_n[m]\n                 = mem_dq_out[48*CS_MAP[(12*m+8)+:3] +\n                              12*CS_MAP[(12*m+4)+:2] +\n                              CS_MAP[12*m+:4]];\n        if (CS_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n          for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n            assign phy_dout[320*CS_MAP[(12*m+8)+:3] +\n                            80*CS_MAP[(12*m+4)+:2] +\n                            8*CS_MAP[12*m+:4] + n]\n                     = mux_cs_n[CS_WIDTH*nCS_PER_RANK*(n/PHASE_DIV) + m];\n          end\n        end else begin: gen_ge10\n          for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n            assign phy_dout[320*CS_MAP[(12*m+8)+:3] +\n                            80*CS_MAP[(12*m+4)+:2] +\n                            8*(CS_MAP[12*m+:4]-5) + 4 + n]\n                     = mux_cs_n[CS_WIDTH*nCS_PER_RANK*(n/PHASE_DIV) + m];\n          end\n        end\n      end\n    end\n\n\n   if(CKE_ODT_AUX == \"FALSE\") begin\n     \n     wire [ODT_WIDTH*nCK_PER_CLK -1 :0] mux_odt_remap  ;\n\n     if(RANKS == 1) begin\n        for(x =0 ; x < nCK_PER_CLK ; x = x+1) begin\n          assign mux_odt_remap[(x*ODT_WIDTH)+:ODT_WIDTH] = {ODT_WIDTH{mux_odt[0]}} ;\n        end\n     end else begin\n        for(x =0 ; x < 2*nCK_PER_CLK ; x = x+2) begin\n          assign mux_odt_remap[(x*ODT_WIDTH/RANKS)+:ODT_WIDTH/RANKS] = {ODT_WIDTH/RANKS{mux_odt[0]}} ;\n          assign mux_odt_remap[((x*ODT_WIDTH/RANKS)+(ODT_WIDTH/RANKS))+:ODT_WIDTH/RANKS] = {ODT_WIDTH/RANKS{mux_odt[1]}} ;\n        end\n     end\n\n     if (USE_ODT_PORT == 1) begin: gen_odt_out\n       for (m = 0; m < ODT_WIDTH; m = m + 1) begin: gen_odt_out_1\n         assign out_odt[m]\n                  = mem_dq_out[48*ODT_MAP[(12*m+8)+:3] +\n                               12*ODT_MAP[(12*m+4)+:2] +\n                               ODT_MAP[12*m+:4]];\n         if (ODT_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n           for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n             assign phy_dout[320*ODT_MAP[(12*m+8)+:3] +\n                             80*ODT_MAP[(12*m+4)+:2] +\n                             8*ODT_MAP[12*m+:4] + n]\n                      = mux_odt_remap[ODT_WIDTH*(n/PHASE_DIV) + m];\n           end\n         end else begin: gen_ge10\n           for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n             assign phy_dout[320*ODT_MAP[(12*m+8)+:3] +\n                             80*ODT_MAP[(12*m+4)+:2] +\n                             8*(ODT_MAP[12*m+:4]-5) + 4 + n]\n                      = mux_odt_remap[ODT_WIDTH*(n/PHASE_DIV) + m];\n           end\n         end\n       end\n     end\n\n\n     wire [CKE_WIDTH*nCK_PER_CLK -1:0] mux_cke_remap ;\n\n     for(x = 0 ; x < nCK_PER_CLK ; x = x +1) begin\n      assign  mux_cke_remap[(x*CKE_WIDTH)+:CKE_WIDTH] = {CKE_WIDTH{mux_cke[x]}} ;\n     end\n\n\n\n     for (m = 0; m < CKE_WIDTH; m = m + 1) begin: gen_cke_out\n       assign out_cke[m]\n                = mem_dq_out[48*CKE_MAP[(12*m+8)+:3] +\n                             12*CKE_MAP[(12*m+4)+:2] +\n                             CKE_MAP[12*m+:4]];\n       if (CKE_MAP[12*m+:4] < 4'hA) begin: gen_lt10\n         for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n           assign phy_dout[320*CKE_MAP[(12*m+8)+:3] +\n                           80*CKE_MAP[(12*m+4)+:2] +\n                           8*CKE_MAP[12*m+:4] + n]\n                    = mux_cke_remap[CKE_WIDTH*(n/PHASE_DIV) + m];\n         end\n       end else begin: gen_ge10\n         for (n = 0; n < 4; n = n + 1) begin: loop_xpose\n           assign phy_dout[320*CKE_MAP[(12*m+8)+:3] +\n                           80*CKE_MAP[(12*m+4)+:2] +\n                           8*(CKE_MAP[12*m+:4]-5) + 4 + n]\n                    = mux_cke_remap[CKE_WIDTH*(n/PHASE_DIV) + m];\n         end\n       end\n     end\n   end\n\n    \n    \n    \n\n    if (USE_DM_PORT == 1) begin: gen_dm_out\n      for (m = 0; m < DM_WIDTH; m = m + 1) begin: gen_dm_out\n        assign out_dm[m]\n                 = mem_dq_out[48*FULL_MASK_MAP[(12*m+8)+:3] +\n                              12*FULL_MASK_MAP[(12*m+4)+:2] +\n                              FULL_MASK_MAP[12*m+:4]];\n        assign ts_dm[m]\n                 = mem_dq_ts[48*FULL_MASK_MAP[(12*m+8)+:3] +\n                             12*FULL_MASK_MAP[(12*m+4)+:2] +\n                             FULL_MASK_MAP[12*m+:4]];\n        for (n = 0; n < PHASE_PER_CLK; n = n + 1) begin: loop_xpose\n          assign phy_dout[320*FULL_MASK_MAP[(12*m+8)+:3] +\n                          80*FULL_MASK_MAP[(12*m+4)+:2] +\n                          8*FULL_MASK_MAP[12*m+:4] + n]\n                   = mux_wrdata_mask[DM_WIDTH*n + m];\n        end\n      end\n    end\n\n    \n    \n    \n\n    for (m = 0; m < DQ_WIDTH; m = m + 1) begin: gen_dq_inout\n      \n      assign mem_dq_in[40*FULL_DATA_MAP[(12*m+8)+:3] +\n                       10*FULL_DATA_MAP[(12*m+4)+:2] +\n                       FULL_DATA_MAP[12*m+:4]]\n               = in_dq[m];\n      \n      assign out_dq[m]\n               = mem_dq_out[48*FULL_DATA_MAP[(12*m+8)+:3] +\n                            12*FULL_DATA_MAP[(12*m+4)+:2] +\n                            FULL_DATA_MAP[12*m+:4]];\n      assign ts_dq[m]\n               = mem_dq_ts[48*FULL_DATA_MAP[(12*m+8)+:3] +\n                           12*FULL_DATA_MAP[(12*m+4)+:2] +\n                           FULL_DATA_MAP[12*m+:4]];\n      for (n = 0; n < PHASE_PER_CLK; n = n + 1) begin: loop_xpose\n        assign phy_dout[320*FULL_DATA_MAP[(12*m+8)+:3] +\n                        80*FULL_DATA_MAP[(12*m+4)+:2] +\n                        8*FULL_DATA_MAP[12*m+:4] + n]\n                 = mux_wrdata[DQ_WIDTH*n + m];\n      end\n    end\n\n    \n    \n    \n\n    for (m = 0; m < DQS_WIDTH; m = m + 1) begin: gen_dqs_inout\n      \n      assign mem_dqs_in[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]]\n        = in_dqs[m];\n      \n      assign out_dqs[m]\n        = mem_dqs_out[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]];\n      assign ts_dqs[m]\n        = mem_dqs_ts[4*DQS_BYTE_MAP[(8*m+4)+:3] + DQS_BYTE_MAP[(8*m)+:2]];\n    end\n  endgenerate\n\n  assign pd_out = pd_out_pre[byte_sel_cnt_w1];\n\n\n  \n  \n  \n\n  \n  \n  \n  \n\n  OBUF u_cas_n_obuf\n    (\n     .I (out_cas_n),\n     .O (ddr_cas_n)\n     );\n\n  OBUF u_ras_n_obuf\n    (\n     .I (out_ras_n),\n     .O (ddr_ras_n)\n     );\n\n  OBUF u_we_n_obuf\n    (\n     .I (out_we_n),\n     .O (ddr_we_n)\n     );\n\n  generate\n    genvar p;\n\n    for (p = 0; p < ROW_WIDTH; p = p + 1) begin: gen_addr_obuf\n      OBUF u_addr_obuf\n        (\n         .I (out_addr[p]),\n         .O (ddr_addr[p])\n         );\n    end\n\n    for (p = 0; p < BANK_WIDTH; p = p + 1) begin: gen_bank_obuf\n      OBUF u_bank_obuf\n        (\n         .I (out_ba[p]),\n         .O (ddr_ba[p])\n         );\n    end\n\n    if (USE_CS_PORT == 1) begin: gen_cs_n_obuf\n      for (p = 0; p < CS_WIDTH*nCS_PER_RANK; p = p + 1) begin: gen_cs_obuf\n        OBUF u_cs_n_obuf\n          (\n           .I (out_cs_n[p]),\n           .O (ddr_cs_n[p])\n           );\n      end\n    end\n    if(CKE_ODT_AUX == \"FALSE\")begin:cke_odt_thru_outfifo\n      if (USE_ODT_PORT== 1) begin: gen_odt_obuf\n        for (p = 0; p < ODT_WIDTH; p = p + 1) begin: gen_odt_obuf\n          OBUF u_cs_n_obuf\n            (\n             .I (out_odt[p]),\n             .O (ddr_odt[p])\n             );\n        end\n      end\n        for (p = 0; p < CKE_WIDTH; p = p + 1) begin: gen_cke_obuf\n          OBUF u_cs_n_obuf\n            (\n             .I (out_cke[p]),\n             .O (ddr_cke[p])\n             );\n        end\n    end\n\n    if (REG_CTRL == \"ON\") begin: gen_parity_obuf\n      \n      OBUF u_parity_obuf\n        (\n         .I (out_parity),\n         .O (ddr_parity)\n         );\n    end else begin: gen_parity_tieoff\n      assign ddr_parity = 1'b0;\n    end\n\n    if ((DRAM_TYPE == \"DDR3\") || (REG_CTRL == \"ON\")) begin: gen_reset_obuf\n      \n      OBUF u_reset_obuf\n        (\n         .I (mux_reset_n),\n         .O (ddr_reset_n)\n         );\n    end else begin: gen_reset_tieoff\n      assign ddr_reset_n = 1'b1;\n    end\n\n    if (USE_DM_PORT == 1) begin: gen_dm_obuf\n      for (p = 0; p < DM_WIDTH; p = p + 1) begin: loop_dm\n        OBUFT u_dm_obuf\n          (\n           .I (out_dm[p]),\n           .T (ts_dm[p]),\n           .O (ddr_dm[p])\n           );\n      end\n    end else begin: gen_dm_tieoff\n      assign ddr_dm = 'b0;\n    end\n\n    if (DATA_IO_PRIM_TYPE == \"HP_LP\") begin: gen_dq_iobuf_HP\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF_DCIEN #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .DCITERMDISABLE (data_io_idle_pwrdwn),\n             .IBUFDISABLE    (data_io_idle_pwrdwn),\n             .I              (out_dq[p]),\n             .T              (ts_dq[p]),\n             .O              (in_dq[p]),\n             .IO             (ddr_dq[p])\n             );\n      end\n    end else if (DATA_IO_PRIM_TYPE == \"HR_LP\") begin: gen_dq_iobuf_HR\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF_INTERMDISABLE #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .INTERMDISABLE  (data_io_idle_pwrdwn),\n             .IBUFDISABLE    (data_io_idle_pwrdwn),\n             .I              (out_dq[p]),\n             .T              (ts_dq[p]),\n             .O              (in_dq[p]),\n             .IO             (ddr_dq[p])\n             );\n      end\n    end else begin: gen_dq_iobuf_default\n      for (p = 0; p < DQ_WIDTH; p = p + 1) begin: gen_dq_iobuf\n        IOBUF #\n          (\n           .IBUF_LOW_PWR (IBUF_LOW_PWR)\n           )\n          u_iobuf_dq\n            (\n             .I  (out_dq[p]),\n             .T  (ts_dq[p]),\n             .O  (in_dq[p]),\n             .IO (ddr_dq[p])\n             );\n      end\n    end\n\n    \n    if ((BANK_TYPE == \"HP_IO\") || (BANK_TYPE == \"HPL_IO\")) begin: gen_dqs_iobuf_HP\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else if ((DRAM_TYPE == \"DDR2\") ||\n                     (tCK > 2500)) begin : gen_ddr2_or_low_dqs_diff\n          IOBUFDS_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS_DIFF_OUT_DCIEN #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n         .DQS_BIAS     (\"TRUE\"),\n         .SIM_DEVICE   (\"7SERIES\"),\n             .USE_IBUFDISABLE (\"FALSE\")\n             )\n            u_iobuf_dqs\n              (\n               .DCITERMDISABLE (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .TM             (ts_dqs[p]),\n               .TS             (ts_dqs[p]),\n               .OB             (in_dqs_lpbk_to_iddr[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n\n          mig_7series_v4_1_poc_pd #\n          (\n           .TCQ        (TCQ),\n           .POC_USE_METASTABLE_SAMP (POC_USE_METASTABLE_SAMP)\n          )\n          u_iddr_edge_det\n          (\n            .clk         (clk),\n            .iddr_rst         (iddr_rst_i),\n            .kclk        (in_dqs_lpbk_to_iddr[p]),\n            .mmcm_ps_clk (mmcm_ps_clk),\n            .pd_out      (pd_out_pre[p])\n          );\n        end\n      end\n    \n    end else if ((BANK_TYPE == \"HR_IO\") || (BANK_TYPE == \"HRL_IO\")) begin: gen_dqs_iobuf_HR\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else if ((DRAM_TYPE == \"DDR2\") ||\n                     (tCK > 2500)) begin: gen_ddr2_or_low_dqs_diff\n          IOBUFDS_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               .IBUFDISABLE    (data_io_idle_pwrdwn),\n               .I              (out_dqs[p]),\n               .T              (ts_dqs[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS_DIFF_OUT_INTERMDISABLE #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\"),\n         .SIM_DEVICE   (\"7SERIES\"),\n             .USE_IBUFDISABLE (\"FALSE\")\n             )\n            u_iobuf_dqs\n              (\n               .INTERMDISABLE  (data_io_idle_pwrdwn),\n               \n               .I              (out_dqs[p]),\n               .TM             (ts_dqs[p]),\n               .TS             (ts_dqs[p]),\n               .OB             (in_dqs_lpbk_to_iddr[p]),\n               .O              (in_dqs[p]),\n               .IO             (ddr_dqs[p]),\n               .IOB            (ddr_dqs_n[p])\n               );\n\n        mig_7series_v4_1_poc_pd #\n        (\n         .TCQ        (TCQ),\n         .POC_USE_METASTABLE_SAMP (POC_USE_METASTABLE_SAMP)\n        )\n        u_iddr_edge_det\n          (\n           .clk         (clk),\n               .iddr_rst    (iddr_rst_i),\n           .kclk        (in_dqs_lpbk_to_iddr[p]),\n               .mmcm_ps_clk (mmcm_ps_clk),\n               .pd_out      (pd_out_pre[p])\n          );\n        end\n      end\n    end else begin: gen_dqs_iobuf_default\n      for (p = 0; p < DQS_WIDTH; p = p + 1) begin: gen_dqs_iobuf\n        if ((DRAM_TYPE == \"DDR2\") &&\n            (DDR2_DQSN_ENABLE != \"YES\")) begin: gen_ddr2_dqs_se\n          IOBUF #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR)\n             )\n            u_iobuf_dqs\n              (\n               .I   (out_dqs[p]),\n               .T   (ts_dqs[p]),\n               .O   (in_dqs[p]),\n               .IO  (ddr_dqs[p])\n               );\n          assign ddr_dqs_n[p] = 1'b0;\n          assign pd_out_pre[p] = 1'b0;\n        end else begin: gen_dqs_diff\n          IOBUFDS #\n            (\n             .IBUF_LOW_PWR (IBUF_LOW_PWR),\n             .DQS_BIAS     (\"TRUE\")\n             )\n            u_iobuf_dqs\n              (\n               .I   (out_dqs[p]),\n               .T   (ts_dqs[p]),\n               .O   (in_dqs[p]),\n               .IO  (ddr_dqs[p]),\n               .IOB (ddr_dqs_n[p])\n               );\n          assign pd_out_pre[p] = 1'b0;\n        end\n      end\n    end\n\n  endgenerate\n\n  always @(posedge clk) begin\n    phy_ctl_wd_i1 <= #TCQ phy_ctl_wd;\n    phy_ctl_wr_i1 <= #TCQ phy_ctl_wr;\n    phy_ctl_wd_i2 <= #TCQ phy_ctl_wd_i1;\n    phy_ctl_wr_i2 <= #TCQ phy_ctl_wr_i1;\n    data_offset_1_i1 <= #TCQ data_offset_1;\n    data_offset_1_i2 <= #TCQ data_offset_1_i1;\n    data_offset_2_i1 <= #TCQ data_offset_2;\n    data_offset_2_i2 <= #TCQ data_offset_2_i1;\n  end\n\n\n  \n  \n  assign phy_ctl_wd_temp = (nCK_PER_CLK == 4) ? phy_ctl_wd_i2 : phy_ctl_wd_of;\n  assign phy_ctl_wr_temp = (nCK_PER_CLK == 4) ? phy_ctl_wr_i2 : phy_ctl_wr_of;\n  assign data_offset_1_temp = (nCK_PER_CLK == 4) ? data_offset_1_i2 : data_offset_1_of;\n  assign data_offset_2_temp = (nCK_PER_CLK == 4) ? data_offset_2_i2 : data_offset_2_of;\n\n  generate\n    begin\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (32)\n        )\n        phy_ctl_pre_fifo_0\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[1]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (phy_ctl_wd),\n         .wr_en_out (phy_ctl_wr_of),\n         .d_out     (phy_ctl_wd_of)\n        );\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (6)\n        )\n        phy_ctl_pre_fifo_1\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[2]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (data_offset_1),\n         .wr_en_out (),\n         .d_out     (data_offset_1_of)\n        );\n\n      mig_7series_v4_1_ddr_of_pre_fifo #\n        (\n         .TCQ   (25),\n         .DEPTH (8),\n         .WIDTH (6)\n        )\n        phy_ctl_pre_fifo_2\n        (\n         .clk       (clk),\n         .rst       (rst),\n         .full_in   (phy_ctl_full_temp[3]),\n         .wr_en_in  (phy_ctl_wr),\n         .d_in      (data_offset_2),\n         .wr_en_out (),\n         .d_out     (data_offset_2_of)\n        );\n\n    end\n  endgenerate\n\n\n\n  \n  \n  \n\n   assign phy_ctl_full = phy_ctl_full_temp[0];\n\n  mig_7series_v4_1_ddr_mc_phy #\n    (\n     .BYTE_LANES_B0                 (BYTE_LANES_B0),\n     .BYTE_LANES_B1                 (BYTE_LANES_B1),\n     .BYTE_LANES_B2                 (BYTE_LANES_B2),\n     .BYTE_LANES_B3                 (BYTE_LANES_B3),\n     .BYTE_LANES_B4                 (BYTE_LANES_B4),\n     .DATA_CTL_B0                   (DATA_CTL_B0),\n     .DATA_CTL_B1                   (DATA_CTL_B1),\n     .DATA_CTL_B2                   (DATA_CTL_B2),\n     .DATA_CTL_B3                   (DATA_CTL_B3),\n     .DATA_CTL_B4                   (DATA_CTL_B4),\n     .PHY_0_BITLANES                (PHY_0_BITLANES),\n     .PHY_1_BITLANES                (PHY_1_BITLANES),\n     .PHY_2_BITLANES                (PHY_2_BITLANES),\n     .PHY_0_BITLANES_OUTONLY        (PHY_0_BITLANES_OUTONLY),\n     .PHY_1_BITLANES_OUTONLY        (PHY_1_BITLANES_OUTONLY),\n     .PHY_2_BITLANES_OUTONLY        (PHY_2_BITLANES_OUTONLY),\n     .RCLK_SELECT_BANK              (CKE_ODT_RCLK_SELECT_BANK),\n     .RCLK_SELECT_LANE              (CKE_ODT_RCLK_SELECT_LANE),\n     \n     .GENERATE_DDR_CK_MAP           (TMP_GENERATE_DDR_CK_MAP),\n     .BYTELANES_DDR_CK              (TMP_BYTELANES_DDR_CK),\n     .NUM_DDR_CK                    (CK_WIDTH),\n     .LP_DDR_CK_WIDTH               (LP_DDR_CK_WIDTH),\n     .PO_CTL_COARSE_BYPASS          (\"FALSE\"),\n     .PHYCTL_CMD_FIFO               (\"FALSE\"),\n     .PHY_CLK_RATIO                 (nCK_PER_CLK),\n     .MASTER_PHY_CTL                (MASTER_PHY_CTL),\n     .PHY_FOUR_WINDOW_CLOCKS        (63),\n     .PHY_EVENTS_DELAY              (18),\n     .PHY_COUNT_EN                  (\"FALSE\"), \n     .PHY_SYNC_MODE                 (\"FALSE\"),\n     .SYNTHESIS                     ((SIM_CAL_OPTION == \"NONE\") ? \"TRUE\" : \"FALSE\"),\n     .PHY_DISABLE_SEQ_MATCH         (\"TRUE\"), \n     .PHY_0_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     .PHY_0_A_PI_FREQ_REF_DIV       (PHY_0_A_PI_FREQ_REF_DIV),\n     .PHY_0_CMD_OFFSET              (PHY_0_CMD_OFFSET),   \n     .PHY_0_RD_CMD_OFFSET_0         (PHY_0_RD_CMD_OFFSET_0),\n     .PHY_0_RD_CMD_OFFSET_1         (PHY_0_RD_CMD_OFFSET_1),\n     .PHY_0_RD_CMD_OFFSET_2         (PHY_0_RD_CMD_OFFSET_2),\n     .PHY_0_RD_CMD_OFFSET_3         (PHY_0_RD_CMD_OFFSET_3),\n     .PHY_0_RD_DURATION_0           (6),\n     .PHY_0_RD_DURATION_1           (6),\n     .PHY_0_RD_DURATION_2           (6),\n     .PHY_0_RD_DURATION_3           (6),\n     .PHY_0_WR_CMD_OFFSET_0         (PHY_0_WR_CMD_OFFSET_0),\n     .PHY_0_WR_CMD_OFFSET_1         (PHY_0_WR_CMD_OFFSET_1),\n     .PHY_0_WR_CMD_OFFSET_2         (PHY_0_WR_CMD_OFFSET_2),\n     .PHY_0_WR_CMD_OFFSET_3         (PHY_0_WR_CMD_OFFSET_3),\n     .PHY_0_WR_DURATION_0           (PHY_0_WR_DURATION_0),\n     .PHY_0_WR_DURATION_1           (PHY_0_WR_DURATION_1),\n     .PHY_0_WR_DURATION_2           (PHY_0_WR_DURATION_2),\n     .PHY_0_WR_DURATION_3           (PHY_0_WR_DURATION_3),\n     .PHY_0_AO_TOGGLE               ((RANKS == 1) ? 1 : 5),\n     .PHY_0_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_0_A_PO_OCLKDELAY_INV      (PO_OCLKDELAY_INV),\n     .PHY_0_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_0_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     \n     \n     .PHY_1_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_1_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_1_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_GENERATE_IDELAYCTRL     (\"FALSE\"),\n     \n     \n     .PHY_2_A_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_B_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_C_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_D_PO_OCLK_DELAY         (PHY_0_A_PO_OCLK_DELAY),\n     .PHY_2_A_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_B_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_C_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .PHY_2_D_IDELAYE2_IDELAY_VALUE (PHY_0_A_IDELAYE2_IDELAY_VALUE),\n     .TCK                           (tCK),\n     .PHY_0_IODELAY_GRP             (IODELAY_GRP),\n     .PHY_1_IODELAY_GRP             (IODELAY_GRP),\n     .PHY_2_IODELAY_GRP             (IODELAY_GRP),\n     .FPGA_SPEED_GRADE              (FPGA_SPEED_GRADE),\n     .BANK_TYPE                     (BANK_TYPE),\n     .CKE_ODT_AUX                   (CKE_ODT_AUX),\n     .PI_DIV2_INCDEC                (PI_DIV2_INCDEC)\n     )\n    u_ddr_mc_phy\n      (\n       .rst                    (rst),\n       \n       \n       .ddr_rst_in_n           (1'b1),\n       .phy_clk                (clk),\n       .clk_div2               (clk_div2),\n       .freq_refclk            (freq_refclk),\n       .mem_refclk             (mem_refclk),\n       \n       .mem_refclk_div4        (clk),\n       .pll_lock               (pll_lock),\n       .auxout_clk             (),\n       .sync_pulse             (sync_pulse),\n       \n       .idelayctrl_refclk      (),\n       .phy_dout               (phy_dout),\n       .phy_cmd_wr_en          (phy_cmd_wr_en),\n       .phy_data_wr_en         (phy_data_wr_en),\n       .phy_rd_en              (phy_rd_en),\n       .phy_ctl_wd             (phy_ctl_wd_temp),\n       .phy_ctl_wr             (phy_ctl_wr_temp),\n       .if_empty_def           (phy_if_empty_def),\n       .if_rst                 (phy_if_reset),\n       .phyGo                  ('b1),\n       .aux_in_1               (aux_in_1),\n       .aux_in_2               (aux_in_2),\n       \n       \n       .data_offset_1          (data_offset_1_temp),\n       .data_offset_2          (data_offset_2_temp),\n       .cke_in                 (),\n       .if_a_empty             (),\n       .if_empty               (if_empty),\n       .if_empty_or            (),\n       .if_empty_and           (),\n       .of_ctl_a_full          (),\n      \n       .of_ctl_full            (phy_cmd_full),\n       .of_data_full           (),\n       .pre_data_a_full        (phy_pre_data_a_full),\n       .idelay_ld              (idelay_ld),\n       .idelay_ce              (idelay_ce),\n       .idelay_inc             (idelay_inc),\n       .input_sink             (),\n       .phy_din                (phy_din),\n       .phy_ctl_a_full         (),\n       .phy_ctl_full           (phy_ctl_full_temp),\n       .mem_dq_out             (mem_dq_out),\n       .mem_dq_ts              (mem_dq_ts),\n       .mem_dq_in              (mem_dq_in),\n       .mem_dqs_out            (mem_dqs_out),\n       .mem_dqs_ts             (mem_dqs_ts),\n       .mem_dqs_in             (mem_dqs_in),\n       .aux_out                (aux_out),\n       .phy_ctl_ready          (),\n       .rst_out                (),\n       .ddr_clk                (ddr_clk),\n       \n       .mcGo                   (phy_mc_go),\n       .phy_write_calib        (phy_write_calib),\n       .phy_read_calib         (phy_read_calib),\n       .calib_sel              (calib_sel),\n       .calib_in_common        (calib_in_common),\n       .calib_zero_inputs      (calib_zero_inputs),\n       .calib_zero_ctrl        (calib_zero_ctrl),\n       .calib_zero_lanes       ('b0),\n       .po_fine_enable         (po_fine_enable),\n       .po_coarse_enable       (po_coarse_enable),\n       .po_fine_inc            (po_fine_inc),\n       .po_coarse_inc          (po_coarse_inc),\n       .po_counter_load_en     (po_counter_load_en),\n       .po_sel_fine_oclk_delay (po_sel_fine_oclk_delay),\n       .po_counter_load_val    (po_counter_load_val),\n       .po_counter_read_en     (po_counter_read_en),\n       .po_coarse_overflow     (),\n       .po_fine_overflow       (),\n       .po_counter_read_val    (po_counter_read_val),\n       .pi_rst_dqs_find        (pi_rst_dqs_find),\n       .pi_fine_enable         (pi_fine_enable),\n       .pi_fine_inc            (pi_fine_inc),\n       .pi_counter_load_en     (pi_counter_load_en),\n       .pi_counter_read_en     (dbg_pi_counter_read_en),\n       .pi_counter_load_val    (pi_counter_load_val),\n       .pi_fine_overflow       (),\n       .pi_counter_read_val    (pi_counter_read_val),\n       .pi_phase_locked        (pi_phase_locked),\n       .pi_phase_locked_all    (pi_phase_locked_all),\n       .pi_dqs_found           (),\n       .pi_dqs_found_any       (pi_dqs_found),\n       .pi_dqs_found_all       (pi_dqs_found_all),\n       .pi_dqs_found_lanes     (dbg_pi_dqs_found_lanes_phy4lanes),\n       \n       \n       \n       \n       .pi_dqs_out_of_range    (pi_dqs_out_of_range)\n\n       ,.ref_dll_lock          (ref_dll_lock)\n       ,.pi_phase_locked_lanes (dbg_pi_phase_locked_phy4lanes)\n       ,.fine_delay            (fine_delay_mod)\n       ,.fine_delay_sel        (fine_delay_sel_r)\n\n       );\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_ddr_mc_phy_wrapper. Module specification: This module serves as a wrapper for the DDR memory controller PHY (Physical Layer) interface in a 7 Series FPGA design. It handles the physical interface between the memory controller and DDR memory devices, managing various signals such as data, address, command, and control lines. The module takes inputs like clocks, resets, control signals, and data, and outputs memory interface signals. Key inputs include rst, clk, phy_cmd_wr_en, phy_data_wr_en, phy_ctl_wd, mux_address, mux_bank, and mux_wrdata. Outputs include ddr_clk, ddr_addr, ddr_ba, ddr_cas_n, ddr_ras_n, ddr"
                }
            ]
        }
    ]
}