{
    "spec": "Module name: mig_7series_v4_1_bank_state. Module specification: This module implements a bank state controller for a memory interface generator (MIG) in 7 series FPGAs. It manages the timing and control of memory operations such as activation, read, write, and precharge for a single bank in a multi-bank memory system. The module has numerous input ports including clk, rst, bm_end, sending_row, rcv_open_bank, sending_col, rd_wr_r, req_wr_r, phy_rddata_valid, and various timing and configuration signals. Output ports include start_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp, bank_wait_in_progress, start_pre_wait, rts_row, rts_col, and several control",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_bank_state\n\nExplanation: This module appears to be a bank state controller for a memory interface generator (MIG) in a 7 series FPGA. It manages the timing and control of various memory operations such as activation, read, write, and precharge for a single bank in a multi-bank memory system. The module handles complex timing requirements, manages priorities for different operations, and coordinates with other bank machines to ensure proper memory access. It includes features like row activation, column access control, refresh management, and interfaces with the physical layer (PHY) for command and data transfer. The module also implements mechanisms to prevent starvation and handle different DRAM types and configurations."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, rst, bm_end, pass_open_bank_r, sending_row, rcv_open_bank, sending_col, rd_wr_r, req_wr_r, rd_data_addr, req_data_buf_addr_r, phy_rddata_valid, rd_rmw, ras_timer_ns_in, rb_hit_busies_r, idle_r, passing_open_bank, low_idle_cnt_r, op_exit_grant, tail_r, auto_pre_r, pass_open_bank_ns, req_rank_r, req_rank_r_in, inhbt_act_faw_r, wait_for_maint_r, head_r, sent_row, start_rcd_in, sent_col, q_has_rd, q_has_priority, req_priority_r, idle_ns, demand_priority_in, inhbt_rd, inhbt_wr, dq_busy_data, rnk_config_strobe, rnk_config_valid_r, rnk_config, phy_mc_cmd_full, phy_mc_ctl_full, phy_mc_data_full, rnk_config_kill_rts_col.\n\nExplanation: These inputs provide various control signals, timing information, bank status, and configuration data necessary for managing the bank state and operations.\n\nOutput ports:\nstart_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp, bank_wait_in_progress, start_pre_wait, op_exit_req, pre_wait_r, allow_auto_pre, precharge_bm_end, demand_act_priority, rts_row, act_this_rank_r, demand_priority, col_rdy_wr, rtc, rts_col, wr_this_rank_r, rd_this_rank_r, rts_pre.\n\nExplanation: These outputs provide control signals for various memory operations, timing information, bank status flags, and signals to coordinate with other bank machines and the memory controller."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nact_wait_r_lcl, start_rcd_lcl, act_wait_ns, end_rcd, rcd_active_r, rmw_rd_done, rmw_wait_r, col_wait_ns, col_wait_r, passed_ras_timer, start_wtp_timer, ras_timer_zero_ns, ras_timer_zero_r, rtp_timer_ns, rtp_timer_r, end_rtp_lcl, op_wait_r, pre_wait_ns, pre_request, start_pre, rp_timer_r, inhbt_act_rrd, act_req, rts_act_denied, act_starve_limit_cntr_ns, act_starve_limit_cntr_r, demand_act_priority_r, demand_act_priority_ns, act_demanded, row_demand_ok, req_bank_rdy_ns, req_bank_rdy_r, rts_col_denied, starve_limit_cntr_r, starve_limit_cntr_ns, starved, demand_priority_r, demand_priority_ns, demanded, demanded_prior_r, demanded_prior_ns, demand_ok, rnk_config_match, my_inhbt_rd, my_inhbt_wr, allow_rw, col_rdy, col_cmd_rts, phy_mc_ctl_full_r, phy_mc_cmd_full_r, ofs_rdy_r, override_demand_r, override_demand_ns.\n\nExplanation:\n- act_wait_r_lcl, start_rcd_lcl, act_wait_ns: Control signals for activation wait state\n- end_rcd, rcd_active_r: Signals for row-to-column delay timing\n- rmw_rd_done, rmw_wait_r: Read-modify-write operation control signals\n- col_wait_ns, col_wait_r: Column access wait state signals\n- passed_ras_timer: RAS timer value passed from other bank machines\n- start_wtp_timer: Write-to-precharge timer start signal\n- ras_timer_zero_ns, ras_timer_zero_r: RAS timer zero detection signals\n- rtp_timer_ns, rtp_timer_r: Read-to-precharge timer signals\n- end_rtp_lcl: Local end of read-to-precharge timing signal\n- op_wait_r: Operation wait state signal\n- pre_wait_ns, pre_request: Precharge wait and request signals\n- start_pre: Start precharge operation signal\n- rp_timer_r: Row precharge timer signal\n- inhbt_act_rrd: Inhibit activation due to RAS-to-RAS delay\n- act_req, rts_act_denied: Activation request and denial signals\n- act_starve_limit_cntr_ns, act_starve_limit_cntr_r: Activation starvation limit counter\n- demand_act_priority_r, demand_act_priority_ns: Demand activation priority signals\n- act_demanded: Activation demand signal from other bank machines\n- row_demand_ok: Row demand priority check signal\n- req_bank_rdy_ns, req_bank_rdy_r: Bank ready for request signals\n- rts_col_denied: Column access denial signal\n- starve_limit_cntr_r, starve_limit_cntr_ns: Starvation limit counter signals\n- starved: Starvation detection signal\n- demand_priority_r, demand_priority_ns: Demand priority signals\n- demanded: Demand signal from other bank machines\n- demanded_prior_r, demanded_prior_ns: Prior demand tracking signals\n- demand_ok: Demand priority check signal\n- rnk_config_match: Rank configuration match signal\n- my_inhbt_rd, my_inhbt_wr: Read and write inhibit signals for current rank\n- allow_rw: Allow read/write operation signal\n- col_rdy: Column ready signal\n- col_cmd_rts: Column command ready-to-send signal\n- phy_mc_ctl_full_r, phy_mc_cmd_full_r: PHY control and command full signals\n- ofs_rdy_r: Output FIFO stage ready signal\n- override_demand_r, override_demand_ns: Demand override signals for rank configuration\n\nThese internal signals manage various aspects of the bank state, including timing, priorities, and operation control within the memory controller."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n`define BM_SHARED_BV (ID+nBANK_MACHS-1):(ID+1)\n\nmodule mig_7series_v4_1_bank_state #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_CMD_MODE            = \"1T\",\n   parameter BM_CNT_WIDTH             = 2,\n   parameter BURST_MODE               = \"8\",\n   parameter CWL                      = 5,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter DRAM_TYPE                = \"DDR3\",\n   parameter ECC                      = \"OFF\",\n   parameter ID                       = 0,\n   parameter nBANK_MACHS              = 4,\n   parameter nCK_PER_CLK              = 2,\n   parameter nOP_WAIT                 = 0,\n   parameter nRAS_CLKS                = 10,\n   parameter nRP                      = 10,\n   parameter nRTP                     = 4,\n   parameter nRCD                     = 5,\n   parameter nWTP_CLKS                = 5,\n   parameter ORDERING                 = \"NORM\",\n   parameter RANKS                    = 4,\n   parameter RANK_WIDTH               = 4,\n   parameter RAS_TIMER_WIDTH          = 5,\n   parameter STARVE_LIMIT             = 2\n  )\n  (\n  \n  start_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp,\n  bank_wait_in_progress, start_pre_wait, op_exit_req, pre_wait_r,\n  allow_auto_pre, precharge_bm_end, demand_act_priority, rts_row,\n  act_this_rank_r, demand_priority, col_rdy_wr, rts_col, wr_this_rank_r,\n  rd_this_rank_r, rts_pre, rtc,\n  \n  clk, rst, bm_end, pass_open_bank_r, sending_row, sending_pre, rcv_open_bank,\n  sending_col, rd_wr_r, req_wr_r, rd_data_addr, req_data_buf_addr_r,\n  phy_rddata_valid, rd_rmw, ras_timer_ns_in, rb_hit_busies_r, idle_r,\n  passing_open_bank, low_idle_cnt_r, op_exit_grant, tail_r,\n  auto_pre_r, pass_open_bank_ns, req_rank_r, req_rank_r_in,\n  start_rcd_in, inhbt_act_faw_r, wait_for_maint_r, head_r, sent_row,\n  demand_act_priority_in, order_q_zero, sent_col, q_has_rd,\n  q_has_priority, req_priority_r, idle_ns, demand_priority_in, inhbt_rd,\n  inhbt_wr, dq_busy_data, rnk_config_strobe, rnk_config_valid_r, rnk_config,\n  rnk_config_kill_rts_col, phy_mc_cmd_full, phy_mc_ctl_full, phy_mc_data_full\n  );\n\n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  input clk;\n  input rst;\n\n\n  input bm_end;\n  reg bm_end_r1;\n  always @(posedge clk) bm_end_r1 <= #TCQ bm_end;\n\n  reg col_wait_r;\n\n  input pass_open_bank_r;\n  input sending_row;\n  reg act_wait_r_lcl;\n  input rcv_open_bank;\n  wire start_rcd_lcl = act_wait_r_lcl && sending_row;\n  output wire start_rcd;\n  assign start_rcd = start_rcd_lcl;\n  wire act_wait_ns = rst ||\n                     ((act_wait_r_lcl && ~start_rcd_lcl && ~rcv_open_bank) ||\n                      bm_end_r1 || (pass_open_bank_r && bm_end));\n  always @(posedge clk) act_wait_r_lcl <= #TCQ act_wait_ns;\n  output wire act_wait_r;\n  assign act_wait_r = act_wait_r_lcl;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  localparam nRCD_CLKS =\n    nCK_PER_CLK == 1 ?\n      nRCD :\n    nCK_PER_CLK == 2 ?\n      ADDR_CMD_MODE == \"2T\" ?\n        (nRCD/2) + (nRCD%2) :\n          CWL % 2 ?\n            (nRCD/2) :\n            (nRCD+2) / 2 :\n\n      ADDR_CMD_MODE == \"2T\" ? \n        (nRCD/4) + (nRCD%4 > 2 ? 1 : 0) :\n        CWL % 2 ?\n          (nRCD-2 ? (nRCD-2) / 4 + 1 : 1) :\n          nRCD/4 + 1;\n\n  localparam nRCD_CLKS_M2 = (nRCD_CLKS-2 <0) ? 0 : nRCD_CLKS-2;\n  localparam RCD_TIMER_WIDTH = clogb2(nRCD_CLKS_M2+1);\n  localparam ZERO = 0;\n  localparam ONE = 1;\n  reg [RCD_TIMER_WIDTH-1:0] rcd_timer_r = {RCD_TIMER_WIDTH{1'b0}};\n  reg end_rcd;\n  reg rcd_active_r = 1'b0;\n\n  generate\n    if (nRCD_CLKS <= 2) begin : rcd_timer_leq_2\n      always @(start_rcd_lcl) end_rcd = start_rcd_lcl;\n    end\n    else if (nRCD_CLKS > 2) begin : rcd_timer_gt_2\n      reg [RCD_TIMER_WIDTH-1:0] rcd_timer_ns;\n      always @(rcd_timer_r or rst or start_rcd_lcl) begin\n        if (rst) rcd_timer_ns = ZERO[RCD_TIMER_WIDTH-1:0];\n        else begin\n          rcd_timer_ns = rcd_timer_r;\n          if (start_rcd_lcl) rcd_timer_ns = nRCD_CLKS_M2[RCD_TIMER_WIDTH-1:0];\n          else if (|rcd_timer_r) rcd_timer_ns =\n                                   rcd_timer_r - ONE[RCD_TIMER_WIDTH-1:0];\n        end\n      end\n      always @(posedge clk) rcd_timer_r <= #TCQ rcd_timer_ns;\n      wire end_rcd_ns = (rcd_timer_ns == ONE[RCD_TIMER_WIDTH-1:0]);\n      always @(posedge clk) end_rcd = end_rcd_ns;\n      wire rcd_active_ns = |rcd_timer_ns;\n      always @(posedge clk) rcd_active_r <= #TCQ rcd_active_ns;\n    end\n  endgenerate\n\n\n\n\n\n\n\n  input sending_col;\n  input rd_wr_r;\n  input req_wr_r;\n  input [DATA_BUF_ADDR_WIDTH-1:0] rd_data_addr;\n  input [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  input phy_rddata_valid;\n  input rd_rmw;\n  reg rmw_rd_done = 1'b0;\n  reg rd_half_rmw_lcl = 1'b0;\n  output wire rd_half_rmw;\n  assign rd_half_rmw = rd_half_rmw_lcl;\n  reg rmw_wait_r = 1'b0;\n  generate\n    if (ECC != \"OFF\") begin : rmw_on\n\n\n      reg phy_rddata_valid_r;\n      reg rd_rmw_r;\n      always @(posedge clk) begin\n        phy_rddata_valid_r <= #TCQ phy_rddata_valid;\n        rd_rmw_r <= #TCQ rd_rmw;\n      end   \n      wire my_rmw_rd_ns = phy_rddata_valid_r && rd_rmw_r && \n                            (rd_data_addr == req_data_buf_addr_r); \n      if (CWL == 8) always @(my_rmw_rd_ns) rmw_rd_done = my_rmw_rd_ns;\n      else always @(posedge clk) rmw_rd_done = #TCQ my_rmw_rd_ns;\n      always @(rd_wr_r or req_wr_r) rd_half_rmw_lcl = req_wr_r && rd_wr_r;\n      wire rmw_wait_ns = ~rst && \n             ((rmw_wait_r && ~rmw_rd_done) || (rd_half_rmw_lcl && sending_col));\n      always @(posedge clk) rmw_wait_r <= #TCQ rmw_wait_ns;\n    end\n  endgenerate\n\n\n  wire col_wait_ns = ~rst && ((col_wait_r && ~sending_col) || end_rcd\n                            || rcv_open_bank || (rmw_rd_done && rmw_wait_r));\n  always @(posedge clk) col_wait_r <= #TCQ col_wait_ns;\n\n\n\n  localparam TWO = 2;\n  output reg [RAS_TIMER_WIDTH-1:0] ras_timer_ns;\n  reg [RAS_TIMER_WIDTH-1:0] ras_timer_r;\n  input [(2*(RAS_TIMER_WIDTH*nBANK_MACHS))-1:0] ras_timer_ns_in;\n  input [(nBANK_MACHS*2)-1:0] rb_hit_busies_r;\n\n\n  reg [RAS_TIMER_WIDTH-1:0] passed_ras_timer;\n  integer i;\n  always @(ras_timer_ns_in or rb_hit_busies_r) begin\n    passed_ras_timer = {RAS_TIMER_WIDTH{1'b0}};\n    for (i=ID+1; i<(ID+nBANK_MACHS); i=i+1)\n      if (rb_hit_busies_r[i])\n        passed_ras_timer = ras_timer_ns_in[i*RAS_TIMER_WIDTH+:RAS_TIMER_WIDTH];\n  end\n\n\n\n\n\n\n  wire start_wtp_timer = sending_col && ~rd_wr_r;\n  input idle_r;\n\n  always @(bm_end_r1 or ras_timer_r or rst or start_rcd_lcl\n           or start_wtp_timer) begin\n    if (bm_end_r1 || rst) ras_timer_ns = ZERO[RAS_TIMER_WIDTH-1:0];\n    else begin\n      ras_timer_ns = ras_timer_r;\n      if (start_rcd_lcl) ras_timer_ns =\n           nRAS_CLKS[RAS_TIMER_WIDTH-1:0] - TWO[RAS_TIMER_WIDTH-1:0];\n      if (start_wtp_timer) ras_timer_ns =\n            \n            \n           (ras_timer_r <= (nWTP_CLKS-2)) ? nWTP_CLKS[RAS_TIMER_WIDTH-1:0] - TWO[RAS_TIMER_WIDTH-1:0]\n                                          : ras_timer_r - ONE[RAS_TIMER_WIDTH-1:0];\n      if (|ras_timer_r && ~start_wtp_timer) ras_timer_ns =\n           ras_timer_r - ONE[RAS_TIMER_WIDTH-1:0];\n    end\n  end \n\n  wire [RAS_TIMER_WIDTH-1:0] ras_timer_passed_ns = rcv_open_bank\n                                                     ? passed_ras_timer\n                                                     : ras_timer_ns;\n  always @(posedge clk) ras_timer_r <= #TCQ ras_timer_passed_ns;\n\n  wire ras_timer_zero_ns = (ras_timer_ns == ZERO[RAS_TIMER_WIDTH-1:0]);\n  reg ras_timer_zero_r;\n  always @(posedge clk) ras_timer_zero_r <= #TCQ ras_timer_zero_ns;\n\n\n\n\n\n  localparam nRTP_CLKS = (nCK_PER_CLK == 1)\n                            ? nRTP :\n                         (nCK_PER_CLK == 2)\n                            ? (nRTP/2) + ((ADDR_CMD_MODE == \"2T\") ? nRTP%2 : 1) :\n                              (nRTP/4) + ((ADDR_CMD_MODE == \"2T\") ? (nRTP%4 > 2 ? 2 : 1) : 2);\n  localparam nRTP_CLKS_M1 = ((nRTP_CLKS-1) <= 0) ? 0 : nRTP_CLKS-1;\n  localparam RTP_TIMER_WIDTH = clogb2(nRTP_CLKS_M1 + 1);\n  reg [RTP_TIMER_WIDTH-1:0] rtp_timer_ns;\n  reg [RTP_TIMER_WIDTH-1:0] rtp_timer_r;\n  wire sending_col_not_rmw_rd = sending_col && ~rd_half_rmw_lcl;\n  always @(pass_open_bank_r or rst or rtp_timer_r\n           or sending_col_not_rmw_rd) begin\n    rtp_timer_ns = rtp_timer_r;\n    if (rst || pass_open_bank_r)\n      rtp_timer_ns = ZERO[RTP_TIMER_WIDTH-1:0];\n    else begin\n      if (sending_col_not_rmw_rd) \n         rtp_timer_ns = nRTP_CLKS_M1[RTP_TIMER_WIDTH-1:0];\n      if (|rtp_timer_r) rtp_timer_ns = rtp_timer_r - ONE[RTP_TIMER_WIDTH-1:0];\n    end\n  end\n  always @(posedge clk) rtp_timer_r <= #TCQ rtp_timer_ns;\n\n  wire end_rtp_lcl =   ~pass_open_bank_r &&\n                       ((rtp_timer_r == ONE[RTP_TIMER_WIDTH-1:0]) ||\n                       ((nRTP_CLKS_M1 == 0) && sending_col_not_rmw_rd));\n  output wire end_rtp;\n  assign end_rtp = end_rtp_lcl;\n\n\n  localparam OP_WIDTH = clogb2(nOP_WAIT + 1);\n  output wire bank_wait_in_progress;\n  output wire start_pre_wait;\n  input passing_open_bank;\n  input low_idle_cnt_r;\n  output wire op_exit_req;\n  input op_exit_grant;\n  input tail_r;\n  output reg pre_wait_r;\n\n  generate\n    if (nOP_WAIT == 0) begin : op_mode_disabled\n      assign bank_wait_in_progress = sending_col_not_rmw_rd || |rtp_timer_r ||\n                                     (pre_wait_r && ~ras_timer_zero_r);\n      assign start_pre_wait = end_rtp_lcl;\n      assign op_exit_req = 1'b0;\n    end\n    else begin : op_mode_enabled\n      reg op_wait_r;\n      assign bank_wait_in_progress = sending_col || |rtp_timer_r ||\n                                     (pre_wait_r && ~ras_timer_zero_r) ||\n                                     op_wait_r;\n      wire op_active = ~rst && ~passing_open_bank && ((end_rtp_lcl && tail_r)\n                                || op_wait_r);\n      wire op_wait_ns = ~op_exit_grant && op_active;\n      always @(posedge clk) op_wait_r <= #TCQ op_wait_ns;\n      assign start_pre_wait = op_exit_grant ||\n                              (end_rtp_lcl && ~tail_r && ~passing_open_bank);\n      if (nOP_WAIT == -1)\n        assign op_exit_req = (low_idle_cnt_r && op_active);\n      else begin : op_cnt\n        reg [OP_WIDTH-1:0] op_cnt_r;\n        wire [OP_WIDTH-1:0] op_cnt_ns =\n                                   (passing_open_bank || op_exit_grant || rst)\n                                       ? ZERO[OP_WIDTH-1:0]\n                                       : end_rtp_lcl\n                                         ? nOP_WAIT[OP_WIDTH-1:0]\n                                         : |op_cnt_r\n                                            ? op_cnt_r - ONE[OP_WIDTH-1:0]\n                                            : op_cnt_r;\n        always @(posedge clk) op_cnt_r <= #TCQ op_cnt_ns;\n        assign op_exit_req = (low_idle_cnt_r && op_active) ||\n                             (op_wait_r && ~|op_cnt_r);\n      end\n    end\n  endgenerate\n\n  output allow_auto_pre;\n  wire allow_auto_pre = act_wait_r_lcl || rcd_active_r ||\n                        (col_wait_r && ~sending_col);\n\n\n  input auto_pre_r;\n  wire start_pre;\n  input pass_open_bank_ns;\n  wire pre_wait_ns = ~rst && (~pass_open_bank_ns &&\n                     (start_pre_wait || (pre_wait_r && ~start_pre)));\n  always @(posedge clk) pre_wait_r <= #TCQ pre_wait_ns;\n  wire pre_request = pre_wait_r && ras_timer_zero_r && ~auto_pre_r;\n\n\n  localparam nRP_CLKS = (nCK_PER_CLK == 1) ? nRP : \n                        (nCK_PER_CLK == 2) ? ((nRP/2) + (nRP%2)) : \n                       ((nRP/4) + ((nRP%4) ? 1 : 0));\n\n\n\n  localparam nRP_CLKS_M2 = (nRP_CLKS-2 < 0) ? 0 : nRP_CLKS-2;\n  localparam RP_TIMER_WIDTH = clogb2(nRP_CLKS_M2 + 1);\n  \n  input sending_pre;\n  output rts_pre;\n  \n  generate\n  \n    if((nCK_PER_CLK == 4) && (ADDR_CMD_MODE != \"2T\")) begin\n    \n      assign start_pre =  pre_wait_r && ras_timer_zero_r &&\n                          (sending_pre || auto_pre_r);\n      \n      assign rts_pre = ~sending_pre && pre_request;\n    \n    end\n    \n    else begin\n    \n      assign start_pre =  pre_wait_r && ras_timer_zero_r &&\n                          (sending_row || auto_pre_r);\n                          \n      assign rts_pre = 1'b0;\n      \n    end\n\n  endgenerate\n\n  reg [RP_TIMER_WIDTH-1:0] rp_timer_r = ZERO[RP_TIMER_WIDTH-1:0];\n\n  generate\n    if (nRP_CLKS_M2 > ZERO) begin : rp_timer\n      reg [RP_TIMER_WIDTH-1:0] rp_timer_ns;\n      always @(rp_timer_r or rst or start_pre)\n        if (rst) rp_timer_ns = ZERO[RP_TIMER_WIDTH-1:0];\n        else begin\n          rp_timer_ns = rp_timer_r;\n          if (start_pre) rp_timer_ns = nRP_CLKS_M2[RP_TIMER_WIDTH-1:0];\n          else if (|rp_timer_r) rp_timer_ns =\n                                  rp_timer_r - ONE[RP_TIMER_WIDTH-1:0];\n        end\n      always @(posedge clk) rp_timer_r <= #TCQ rp_timer_ns;\n    end \n  endgenerate\n\n  output wire precharge_bm_end;\n  assign precharge_bm_end = (rp_timer_r == ONE[RP_TIMER_WIDTH-1:0]) ||\n                            (start_pre && (nRP_CLKS_M2 == ZERO));\n\n\n\n\n\n\n\n\n\n\n  input [RANK_WIDTH-1:0] req_rank_r;\n  input [(RANK_WIDTH*nBANK_MACHS*2)-1:0] req_rank_r_in;\n\n  reg inhbt_act_rrd;\n  input [(nBANK_MACHS*2)-1:0] start_rcd_in;\n\n  generate\n    integer j;\n    if (RANKS == 1)\n      always @(req_rank_r or req_rank_r_in or start_rcd_in) begin\n        inhbt_act_rrd = 1'b0;\n        for (j=(ID+1); j<(ID+nBANK_MACHS); j=j+1)\n          inhbt_act_rrd = inhbt_act_rrd || start_rcd_in[j];\n      end\n    else begin\n      always @(req_rank_r or req_rank_r_in or start_rcd_in) begin\n        inhbt_act_rrd = 1'b0;\n        for (j=(ID+1); j<(ID+nBANK_MACHS); j=j+1)\n          inhbt_act_rrd = inhbt_act_rrd ||\n             (start_rcd_in[j] &&\n              (req_rank_r_in[(j*RANK_WIDTH)+:RANK_WIDTH] == req_rank_r));\n      end\n    end\n\n  endgenerate\n\n\n\n\n  input [RANKS-1:0] inhbt_act_faw_r;\n  wire my_inhbt_act_faw = inhbt_act_faw_r[req_rank_r];\n\n  input wait_for_maint_r;\n  input head_r;\n  wire act_req = ~idle_r && head_r && act_wait_r && ras_timer_zero_r &&\n                 ~wait_for_maint_r;\n\n\n\n\n\n\n  input sent_row;\n  wire rts_act_denied = act_req && sent_row && ~sending_row;\n\n  reg [BM_CNT_WIDTH-1:0] act_starve_limit_cntr_ns;\n  reg [BM_CNT_WIDTH-1:0] act_starve_limit_cntr_r;\n\n  generate\n    if (BM_CNT_WIDTH > 1) \n    begin :BM_MORE_THAN_2 \n       always @(act_req or act_starve_limit_cntr_r or rts_act_denied)\n         begin\n           act_starve_limit_cntr_ns = act_starve_limit_cntr_r;\n           if (~act_req)\n             act_starve_limit_cntr_ns = {BM_CNT_WIDTH{1'b0}};\n           else\n             if (rts_act_denied && &act_starve_limit_cntr_r)\n               act_starve_limit_cntr_ns = act_starve_limit_cntr_r +\n                                          {{BM_CNT_WIDTH-1{1'b0}}, 1'b1};\n         end\n    end \n    else \n    begin :BM_EQUAL_2 \n       always @(act_req or act_starve_limit_cntr_r or rts_act_denied)\n         begin\n           act_starve_limit_cntr_ns = act_starve_limit_cntr_r;\n           if (~act_req)\n             act_starve_limit_cntr_ns = {BM_CNT_WIDTH{1'b0}};\n           else\n             if (rts_act_denied && &act_starve_limit_cntr_r)\n               act_starve_limit_cntr_ns = act_starve_limit_cntr_r +\n                                          {1'b1};\n         end\n    end \n  endgenerate\n\n  always @(posedge clk) act_starve_limit_cntr_r <=\n                        #TCQ act_starve_limit_cntr_ns;\n\n  reg demand_act_priority_r;\n  wire demand_act_priority_ns = act_req &&\n      (demand_act_priority_r || (rts_act_denied && &act_starve_limit_cntr_r));\n  always @(posedge clk) demand_act_priority_r <= #TCQ demand_act_priority_ns;\n\n`ifdef MC_SVA\n  cover_demand_act_priority:\n    cover property (@(posedge clk) (~rst && demand_act_priority_r));\n`endif\n\n  output wire demand_act_priority;\n  assign demand_act_priority = demand_act_priority_r && ~sending_row;\n\n\n  input [(nBANK_MACHS*2)-1:0] demand_act_priority_in;\n  reg act_demanded = 1'b0;\n  generate\n    if (nBANK_MACHS > 1) begin : compute_act_demanded\n      always @(demand_act_priority_in[`BM_SHARED_BV])\n           act_demanded = |demand_act_priority_in[`BM_SHARED_BV];\n    end\n  endgenerate\n\n  wire row_demand_ok = demand_act_priority_r || ~act_demanded;\n\n\n  output wire rts_row;\n\n  generate\n\n    if((nCK_PER_CLK == 4) && (ADDR_CMD_MODE != \"2T\"))\n      assign rts_row = ~sending_row && row_demand_ok &&\n                      (act_req && ~my_inhbt_act_faw && ~inhbt_act_rrd);\n    else\n      assign rts_row = ~sending_row && row_demand_ok &&\n                      ((act_req && ~my_inhbt_act_faw && ~inhbt_act_rrd) ||\n                        pre_request);\n  endgenerate\n  \n`ifdef MC_SVA\n  four_activate_window_wait:\n    cover property (@(posedge clk)\n      (~rst && ~sending_row && act_req &&  my_inhbt_act_faw));\n  ras_ras_delay_wait:\n    cover property (@(posedge clk)\n      (~rst && ~sending_row && act_req && inhbt_act_rrd));\n`endif\n\n\n\n\n\n  output reg [RANKS-1:0] act_this_rank_r;\n  reg [RANKS-1:0] act_this_rank_ns;\n  always @(act_wait_r or req_rank_r) begin\n    act_this_rank_ns = {RANKS{1'b0}};\n    for (i = 0; i < RANKS; i = i + 1)\n      act_this_rank_ns[i] = act_wait_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n  end\n  always @(posedge clk) act_this_rank_r <= #TCQ act_this_rank_ns;\n\n\n\n\n  input order_q_zero;\n  wire req_bank_rdy_ns = order_q_zero && col_wait_r;\n  reg req_bank_rdy_r;\n  always @(posedge clk) req_bank_rdy_r <= #TCQ req_bank_rdy_ns;\n\n\n  input sent_col;\n  wire rts_col_denied = req_bank_rdy_r && sent_col && ~sending_col;\n\n\n\n  localparam STARVE_LIMIT_CNT      = STARVE_LIMIT * nBANK_MACHS;\n  localparam STARVE_LIMIT_WIDTH    = clogb2(STARVE_LIMIT_CNT);\n  reg [STARVE_LIMIT_WIDTH-1:0] starve_limit_cntr_r;\n  reg [STARVE_LIMIT_WIDTH-1:0] starve_limit_cntr_ns;\n  always @(col_wait_r or rts_col_denied or starve_limit_cntr_r)\n   if (~col_wait_r)\n     starve_limit_cntr_ns = {STARVE_LIMIT_WIDTH{1'b0}};\n   else\n     if (rts_col_denied && (starve_limit_cntr_r != STARVE_LIMIT_CNT-1))\n       starve_limit_cntr_ns = starve_limit_cntr_r +\n                              {{STARVE_LIMIT_WIDTH-1{1'b0}}, 1'b1};\n     else starve_limit_cntr_ns = starve_limit_cntr_r;\n  always @(posedge clk) starve_limit_cntr_r <= #TCQ starve_limit_cntr_ns;\n\n  input q_has_rd;\n  input q_has_priority;\n\n\n\n  wire starved = ((starve_limit_cntr_r == (STARVE_LIMIT_CNT-1)) &&\n                 rts_col_denied);\n  input req_priority_r;\n  input idle_ns;\n  reg demand_priority_r;\n  wire demand_priority_ns = ~idle_ns && col_wait_ns &&\n                              (demand_priority_r ||\n                              (order_q_zero &&\n                               (req_priority_r || q_has_priority)) ||\n                               (starved && (q_has_rd || ~req_wr_r)));\n\n  always @(posedge clk) demand_priority_r <= #TCQ demand_priority_ns;\n\n`ifdef MC_SVA\n  wire rdy_for_priority = ~rst && ~demand_priority_r && ~idle_ns &&\n                          col_wait_ns;\n  req_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (rdy_for_priority && req_priority_r && ~q_has_priority && ~starved));\n  q_priority_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (rdy_for_priority && ~req_priority_r && q_has_priority && ~starved));\n  wire not_req_or_q_rdy_for_priority =\n        rdy_for_priority && ~req_priority_r && ~q_has_priority;\n  starved_req_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (not_req_or_q_rdy_for_priority && starved && ~q_has_rd && ~req_wr_r));\n  starved_q_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (not_req_or_q_rdy_for_priority && starved && q_has_rd && req_wr_r));\n`endif\n\n\n  input [(nBANK_MACHS*2)-1:0] demand_priority_in;\n  reg demanded = 1'b0;\n  generate\n    if (nBANK_MACHS > 1) begin : compute_demanded\n      always @(demand_priority_in[`BM_SHARED_BV]) demanded =\n                                    |demand_priority_in[`BM_SHARED_BV];\n    end\n  endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n  reg demanded_prior_r;\n  wire demanded_prior_ns = demanded &&\n                          (demanded_prior_r || ~demand_priority_r);\n  always @(posedge clk) demanded_prior_r <= #TCQ demanded_prior_ns;\n\n  output wire demand_priority;\n  assign demand_priority = demand_priority_r && ~demanded_prior_r &&\n                           ~sending_col;\n\n`ifdef MC_SVA\n  demand_priority_gated:\n    cover property (@(posedge clk) (demand_priority_r && ~demand_priority));\n  generate\n    if (nBANK_MACHS >1) multiple_demand_priority:\n         cover property (@(posedge clk)\n           ($countones(demand_priority_in[`BM_SHARED_BV]) > 1));\n  endgenerate\n`endif\n\n  wire demand_ok = demand_priority_r || ~demanded;\n  \n  \n  \n  input rnk_config_strobe;\n  input rnk_config_kill_rts_col;\n  input rnk_config_valid_r;\n  input [RANK_WIDTH-1:0] rnk_config;\n  output wire rtc;\n\n  wire rnk_config_match = rnk_config_valid_r && (rnk_config == req_rank_r);\n  assign rtc = ~rnk_config_match && ~rnk_config_kill_rts_col && order_q_zero && col_wait_r && demand_ok;\n\n\n\n  input [RANKS-1:0] inhbt_rd;\n  wire my_inhbt_rd = inhbt_rd[req_rank_r];\n  input [RANKS-1:0] inhbt_wr;\n  wire my_inhbt_wr = inhbt_wr[req_rank_r];\n  wire allow_rw = ~rd_wr_r ? ~my_inhbt_wr : ~my_inhbt_rd;\n\n\n  input dq_busy_data;\n\n\n  wire col_rdy = (col_wait_r || ((nRCD_CLKS <= 1) && end_rcd) ||\n               (rcv_open_bank && nCK_PER_CLK == 2 && DRAM_TYPE==\"DDR2\" && BURST_MODE == \"4\") || \n               (rcv_open_bank && nCK_PER_CLK == 4 && BURST_MODE == \"8\")) &&\n                order_q_zero;\n\n\n\n  output wire col_rdy_wr;\n  assign col_rdy_wr = col_rdy && ~rd_wr_r;\n  \n\n\n\n  wire col_cmd_rts = col_rdy && ~dq_busy_data && allow_rw && rnk_config_match;\n\n`ifdef MC_SVA\n  col_wait_for_order_q: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && ~order_q_zero && ~dq_busy_data &&\n         allow_rw));\n  col_wait_for_dq_busy: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && order_q_zero && dq_busy_data &&\n         allow_rw));\n  col_wait_for_allow_rw: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && order_q_zero && ~dq_busy_data &&\n         ~allow_rw));\n`endif\n\n\n\n  input phy_mc_ctl_full;\n  input phy_mc_cmd_full;\n  input phy_mc_data_full;\n\n  \n  reg phy_mc_ctl_full_r = 1'b0;\n  reg phy_mc_cmd_full_r = 1'b0;\n  always @(posedge clk)\n    if(rst) begin\n      phy_mc_ctl_full_r <= #TCQ 1'b0;\n      phy_mc_cmd_full_r <= #TCQ 1'b0;\n    end else begin\n      phy_mc_ctl_full_r <= #TCQ phy_mc_ctl_full;\n      phy_mc_cmd_full_r <= #TCQ phy_mc_cmd_full;\n    end\n  \n  \n  reg ofs_rdy_r = 1'b0;\n  always @(posedge clk)\n    if(rst)\n      ofs_rdy_r <= #TCQ 1'b0;\n    else\n      ofs_rdy_r <= #TCQ ~phy_mc_cmd_full_r && ~phy_mc_ctl_full_r && ~(phy_mc_data_full && ~rd_wr_r);\n\n\n\n  reg override_demand_r;\n  wire override_demand_ns = rnk_config_strobe || rnk_config_kill_rts_col;\n  always @(posedge clk) override_demand_r <= override_demand_ns;\n  output wire rts_col;\n  assign rts_col = ~sending_col && (demand_ok || override_demand_r) &&\n                   col_cmd_rts && ofs_rdy_r;\n\n\n\n\n  reg [RANKS-1:0] wr_this_rank_ns;\n  reg [RANKS-1:0] rd_this_rank_ns;\n  always @(rd_wr_r or req_rank_r) begin\n    wr_this_rank_ns = {RANKS{1'b0}};\n    rd_this_rank_ns = {RANKS{1'b0}};\n    for (i=0; i<RANKS; i=i+1) begin\n      wr_this_rank_ns[i] = ~rd_wr_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n      rd_this_rank_ns[i] = rd_wr_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n    end\n  end\n  output reg [RANKS-1:0] wr_this_rank_r;\n  always @(posedge clk) wr_this_rank_r <= #TCQ wr_this_rank_ns;\n  output reg [RANKS-1:0] rd_this_rank_r;\n  always @(posedge clk) rd_this_rank_r <= #TCQ rd_this_rank_ns;\n                                   \nendmodule \n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_bank_state. Module specification: This module implements a bank state controller for a memory interface generator (MIG) in 7 series FPGAs. It manages the timing and control of memory operations such as activation, read, write, and precharge for a single bank in a multi-bank memory system. The module has numerous input ports including clk, rst, bm_end, sending_row, rcv_open_bank, sending_col, rd_wr_r, req_wr_r, phy_rddata_valid, and various timing and configuration signals. Output ports include start_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp, bank_wait_in_progress, start_pre_wait, rts_row, rts_col, and several control"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_bank_state\n\nExplanation: This module appears to be a bank state controller for a memory interface generator (MIG) in a 7 series FPGA. It manages the timing and control of various memory operations such as activation, read, write, and precharge for a single bank in a multi-bank memory system. The module handles complex timing requirements, manages priorities for different operations, and coordinates with other bank machines to ensure proper memory access. It includes features like row activation, column access control, refresh management, and interfaces with the physical layer (PHY) for command and data transfer. The module also implements mechanisms to prevent starvation and handle different DRAM types and configurations."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, rst, bm_end, pass_open_bank_r, sending_row, rcv_open_bank, sending_col, rd_wr_r, req_wr_r, rd_data_addr, req_data_buf_addr_r, phy_rddata_valid, rd_rmw, ras_timer_ns_in, rb_hit_busies_r, idle_r, passing_open_bank, low_idle_cnt_r, op_exit_grant, tail_r, auto_pre_r, pass_open_bank_ns, req_rank_r, req_rank_r_in, inhbt_act_faw_r, wait_for_maint_r, head_r, sent_row, start_rcd_in, sent_col, q_has_rd, q_has_priority, req_priority_r, idle_ns, demand_priority_in, inhbt_rd, inhbt_wr, dq_busy_data, rnk_config_strobe, rnk_config_valid_r, rnk_config, phy_mc_cmd_full, phy_mc_ctl_full, phy_mc_data_full, rnk_config_kill_rts_col.\n\nExplanation: These inputs provide various control signals, timing information, bank status, and configuration data necessary for managing the bank state and operations.\n\nOutput ports:\nstart_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp, bank_wait_in_progress, start_pre_wait, op_exit_req, pre_wait_r, allow_auto_pre, precharge_bm_end, demand_act_priority, rts_row, act_this_rank_r, demand_priority, col_rdy_wr, rtc, rts_col, wr_this_rank_r, rd_this_rank_r, rts_pre.\n\nExplanation: These outputs provide control signals for various memory operations, timing information, bank status flags, and signals to coordinate with other bank machines and the memory controller."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nact_wait_r_lcl, start_rcd_lcl, act_wait_ns, end_rcd, rcd_active_r, rmw_rd_done, rmw_wait_r, col_wait_ns, col_wait_r, passed_ras_timer, start_wtp_timer, ras_timer_zero_ns, ras_timer_zero_r, rtp_timer_ns, rtp_timer_r, end_rtp_lcl, op_wait_r, pre_wait_ns, pre_request, start_pre, rp_timer_r, inhbt_act_rrd, act_req, rts_act_denied, act_starve_limit_cntr_ns, act_starve_limit_cntr_r, demand_act_priority_r, demand_act_priority_ns, act_demanded, row_demand_ok, req_bank_rdy_ns, req_bank_rdy_r, rts_col_denied, starve_limit_cntr_r, starve_limit_cntr_ns, starved, demand_priority_r, demand_priority_ns, demanded, demanded_prior_r, demanded_prior_ns, demand_ok, rnk_config_match, my_inhbt_rd, my_inhbt_wr, allow_rw, col_rdy, col_cmd_rts, phy_mc_ctl_full_r, phy_mc_cmd_full_r, ofs_rdy_r, override_demand_r, override_demand_ns.\n\nExplanation:\n- act_wait_r_lcl, start_rcd_lcl, act_wait_ns: Control signals for activation wait state\n- end_rcd, rcd_active_r: Signals for row-to-column delay timing\n- rmw_rd_done, rmw_wait_r: Read-modify-write operation control signals\n- col_wait_ns, col_wait_r: Column access wait state signals\n- passed_ras_timer: RAS timer value passed from other bank machines\n- start_wtp_timer: Write-to-precharge timer start signal\n- ras_timer_zero_ns, ras_timer_zero_r: RAS timer zero detection signals\n- rtp_timer_ns, rtp_timer_r: Read-to-precharge timer signals\n- end_rtp_lcl: Local end of read-to-precharge timing signal\n- op_wait_r: Operation wait state signal\n- pre_wait_ns, pre_request: Precharge wait and request signals\n- start_pre: Start precharge operation signal\n- rp_timer_r: Row precharge timer signal\n- inhbt_act_rrd: Inhibit activation due to RAS-to-RAS delay\n- act_req, rts_act_denied: Activation request and denial signals\n- act_starve_limit_cntr_ns, act_starve_limit_cntr_r: Activation starvation limit counter\n- demand_act_priority_r, demand_act_priority_ns: Demand activation priority signals\n- act_demanded: Activation demand signal from other bank machines\n- row_demand_ok: Row demand priority check signal\n- req_bank_rdy_ns, req_bank_rdy_r: Bank ready for request signals\n- rts_col_denied: Column access denial signal\n- starve_limit_cntr_r, starve_limit_cntr_ns: Starvation limit counter signals\n- starved: Starvation detection signal\n- demand_priority_r, demand_priority_ns: Demand priority signals\n- demanded: Demand signal from other bank machines\n- demanded_prior_r, demanded_prior_ns: Prior demand tracking signals\n- demand_ok: Demand priority check signal\n- rnk_config_match: Rank configuration match signal\n- my_inhbt_rd, my_inhbt_wr: Read and write inhibit signals for current rank\n- allow_rw: Allow read/write operation signal\n- col_rdy: Column ready signal\n- col_cmd_rts: Column command ready-to-send signal\n- phy_mc_ctl_full_r, phy_mc_cmd_full_r: PHY control and command full signals\n- ofs_rdy_r: Output FIFO stage ready signal\n- override_demand_r, override_demand_ns: Demand override signals for rank configuration\n\nThese internal signals manage various aspects of the bank state, including timing, priorities, and operation control within the memory controller."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n`define BM_SHARED_BV (ID+nBANK_MACHS-1):(ID+1)\n\nmodule mig_7series_v4_1_bank_state #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_CMD_MODE            = \"1T\",\n   parameter BM_CNT_WIDTH             = 2,\n   parameter BURST_MODE               = \"8\",\n   parameter CWL                      = 5,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter DRAM_TYPE                = \"DDR3\",\n   parameter ECC                      = \"OFF\",\n   parameter ID                       = 0,\n   parameter nBANK_MACHS              = 4,\n   parameter nCK_PER_CLK              = 2,\n   parameter nOP_WAIT                 = 0,\n   parameter nRAS_CLKS                = 10,\n   parameter nRP                      = 10,\n   parameter nRTP                     = 4,\n   parameter nRCD                     = 5,\n   parameter nWTP_CLKS                = 5,\n   parameter ORDERING                 = \"NORM\",\n   parameter RANKS                    = 4,\n   parameter RANK_WIDTH               = 4,\n   parameter RAS_TIMER_WIDTH          = 5,\n   parameter STARVE_LIMIT             = 2\n  )\n  (\n  \n  start_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp,\n  bank_wait_in_progress, start_pre_wait, op_exit_req, pre_wait_r,\n  allow_auto_pre, precharge_bm_end, demand_act_priority, rts_row,\n  act_this_rank_r, demand_priority, col_rdy_wr, rts_col, wr_this_rank_r,\n  rd_this_rank_r, rts_pre, rtc,\n  \n  clk, rst, bm_end, pass_open_bank_r, sending_row, sending_pre, rcv_open_bank,\n  sending_col, rd_wr_r, req_wr_r, rd_data_addr, req_data_buf_addr_r,\n  phy_rddata_valid, rd_rmw, ras_timer_ns_in, rb_hit_busies_r, idle_r,\n  passing_open_bank, low_idle_cnt_r, op_exit_grant, tail_r,\n  auto_pre_r, pass_open_bank_ns, req_rank_r, req_rank_r_in,\n  start_rcd_in, inhbt_act_faw_r, wait_for_maint_r, head_r, sent_row,\n  demand_act_priority_in, order_q_zero, sent_col, q_has_rd,\n  q_has_priority, req_priority_r, idle_ns, demand_priority_in, inhbt_rd,\n  inhbt_wr, dq_busy_data, rnk_config_strobe, rnk_config_valid_r, rnk_config,\n  rnk_config_kill_rts_col, phy_mc_cmd_full, phy_mc_ctl_full, phy_mc_data_full\n  );\n\n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  input clk;\n  input rst;\n\n\n  input bm_end;\n  reg bm_end_r1;\n  always @(posedge clk) bm_end_r1 <= #TCQ bm_end;\n\n  reg col_wait_r;\n\n  input pass_open_bank_r;\n  input sending_row;\n  reg act_wait_r_lcl;\n  input rcv_open_bank;\n  wire start_rcd_lcl = act_wait_r_lcl && sending_row;\n  output wire start_rcd;\n  assign start_rcd = start_rcd_lcl;\n  wire act_wait_ns = rst ||\n                     ((act_wait_r_lcl && ~start_rcd_lcl && ~rcv_open_bank) ||\n                      bm_end_r1 || (pass_open_bank_r && bm_end));\n  always @(posedge clk) act_wait_r_lcl <= #TCQ act_wait_ns;\n  output wire act_wait_r;\n  assign act_wait_r = act_wait_r_lcl;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  localparam nRCD_CLKS =\n    nCK_PER_CLK == 1 ?\n      nRCD :\n    nCK_PER_CLK == 2 ?\n      ADDR_CMD_MODE == \"2T\" ?\n        (nRCD/2) + (nRCD%2) :\n          CWL % 2 ?\n            (nRCD/2) :\n            (nRCD+2) / 2 :\n\n      ADDR_CMD_MODE == \"2T\" ? \n        (nRCD/4) + (nRCD%4 > 2 ? 1 : 0) :\n        CWL % 2 ?\n          (nRCD-2 ? (nRCD-2) / 4 + 1 : 1) :\n          nRCD/4 + 1;\n\n  localparam nRCD_CLKS_M2 = (nRCD_CLKS-2 <0) ? 0 : nRCD_CLKS-2;\n  localparam RCD_TIMER_WIDTH = clogb2(nRCD_CLKS_M2+1);\n  localparam ZERO = 0;\n  localparam ONE = 1;\n  reg [RCD_TIMER_WIDTH-1:0] rcd_timer_r = {RCD_TIMER_WIDTH{1'b0}};\n  reg end_rcd;\n  reg rcd_active_r = 1'b0;\n\n  generate\n    if (nRCD_CLKS <= 2) begin : rcd_timer_leq_2\n      always @(start_rcd_lcl) end_rcd = start_rcd_lcl;\n    end\n    else if (nRCD_CLKS > 2) begin : rcd_timer_gt_2\n      reg [RCD_TIMER_WIDTH-1:0] rcd_timer_ns;\n      always @(rcd_timer_r or rst or start_rcd_lcl) begin\n        if (rst) rcd_timer_ns = ZERO[RCD_TIMER_WIDTH-1:0];\n        else begin\n          rcd_timer_ns = rcd_timer_r;\n          if (start_rcd_lcl) rcd_timer_ns = nRCD_CLKS_M2[RCD_TIMER_WIDTH-1:0];\n          else if (|rcd_timer_r) rcd_timer_ns =\n                                   rcd_timer_r - ONE[RCD_TIMER_WIDTH-1:0];\n        end\n      end\n      always @(posedge clk) rcd_timer_r <= #TCQ rcd_timer_ns;\n      wire end_rcd_ns = (rcd_timer_ns == ONE[RCD_TIMER_WIDTH-1:0]);\n      always @(posedge clk) end_rcd = end_rcd_ns;\n      wire rcd_active_ns = |rcd_timer_ns;\n      always @(posedge clk) rcd_active_r <= #TCQ rcd_active_ns;\n    end\n  endgenerate\n\n\n\n\n\n\n\n  input sending_col;\n  input rd_wr_r;\n  input req_wr_r;\n  input [DATA_BUF_ADDR_WIDTH-1:0] rd_data_addr;\n  input [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  input phy_rddata_valid;\n  input rd_rmw;\n  reg rmw_rd_done = 1'b0;\n  reg rd_half_rmw_lcl = 1'b0;\n  output wire rd_half_rmw;\n  assign rd_half_rmw = rd_half_rmw_lcl;\n  reg rmw_wait_r = 1'b0;\n  generate\n    if (ECC != \"OFF\") begin : rmw_on\n\n\n      reg phy_rddata_valid_r;\n      reg rd_rmw_r;\n      always @(posedge clk) begin\n        phy_rddata_valid_r <= #TCQ phy_rddata_valid;\n        rd_rmw_r <= #TCQ rd_rmw;\n      end   \n      wire my_rmw_rd_ns = phy_rddata_valid_r && rd_rmw_r && \n                            (rd_data_addr == req_data_buf_addr_r); \n      if (CWL == 8) always @(my_rmw_rd_ns) rmw_rd_done = my_rmw_rd_ns;\n      else always @(posedge clk) rmw_rd_done = #TCQ my_rmw_rd_ns;\n      always @(rd_wr_r or req_wr_r) rd_half_rmw_lcl = req_wr_r && rd_wr_r;\n      wire rmw_wait_ns = ~rst && \n             ((rmw_wait_r && ~rmw_rd_done) || (rd_half_rmw_lcl && sending_col));\n      always @(posedge clk) rmw_wait_r <= #TCQ rmw_wait_ns;\n    end\n  endgenerate\n\n\n  wire col_wait_ns = ~rst && ((col_wait_r && ~sending_col) || end_rcd\n                            || rcv_open_bank || (rmw_rd_done && rmw_wait_r));\n  always @(posedge clk) col_wait_r <= #TCQ col_wait_ns;\n\n\n\n  localparam TWO = 2;\n  output reg [RAS_TIMER_WIDTH-1:0] ras_timer_ns;\n  reg [RAS_TIMER_WIDTH-1:0] ras_timer_r;\n  input [(2*(RAS_TIMER_WIDTH*nBANK_MACHS))-1:0] ras_timer_ns_in;\n  input [(nBANK_MACHS*2)-1:0] rb_hit_busies_r;\n\n\n  reg [RAS_TIMER_WIDTH-1:0] passed_ras_timer;\n  integer i;\n  always @(ras_timer_ns_in or rb_hit_busies_r) begin\n    passed_ras_timer = {RAS_TIMER_WIDTH{1'b0}};\n    for (i=ID+1; i<(ID+nBANK_MACHS); i=i+1)\n      if (rb_hit_busies_r[i])\n        passed_ras_timer = ras_timer_ns_in[i*RAS_TIMER_WIDTH+:RAS_TIMER_WIDTH];\n  end\n\n\n\n\n\n\n  wire start_wtp_timer = sending_col && ~rd_wr_r;\n  input idle_r;\n\n  always @(bm_end_r1 or ras_timer_r or rst or start_rcd_lcl\n           or start_wtp_timer) begin\n    if (bm_end_r1 || rst) ras_timer_ns = ZERO[RAS_TIMER_WIDTH-1:0];\n    else begin\n      ras_timer_ns = ras_timer_r;\n      if (start_rcd_lcl) ras_timer_ns =\n           nRAS_CLKS[RAS_TIMER_WIDTH-1:0] - TWO[RAS_TIMER_WIDTH-1:0];\n      if (start_wtp_timer) ras_timer_ns =\n            \n            \n           (ras_timer_r <= (nWTP_CLKS-2)) ? nWTP_CLKS[RAS_TIMER_WIDTH-1:0] - TWO[RAS_TIMER_WIDTH-1:0]\n                                          : ras_timer_r - ONE[RAS_TIMER_WIDTH-1:0];\n      if (|ras_timer_r && ~start_wtp_timer) ras_timer_ns =\n           ras_timer_r - ONE[RAS_TIMER_WIDTH-1:0];\n    end\n  end \n\n  wire [RAS_TIMER_WIDTH-1:0] ras_timer_passed_ns = rcv_open_bank\n                                                     ? passed_ras_timer\n                                                     : ras_timer_ns;\n  always @(posedge clk) ras_timer_r <= #TCQ ras_timer_passed_ns;\n\n  wire ras_timer_zero_ns = (ras_timer_ns == ZERO[RAS_TIMER_WIDTH-1:0]);\n  reg ras_timer_zero_r;\n  always @(posedge clk) ras_timer_zero_r <= #TCQ ras_timer_zero_ns;\n\n\n\n\n\n  localparam nRTP_CLKS = (nCK_PER_CLK == 1)\n                            ? nRTP :\n                         (nCK_PER_CLK == 2)\n                            ? (nRTP/2) + ((ADDR_CMD_MODE == \"2T\") ? nRTP%2 : 1) :\n                              (nRTP/4) + ((ADDR_CMD_MODE == \"2T\") ? (nRTP%4 > 2 ? 2 : 1) : 2);\n  localparam nRTP_CLKS_M1 = ((nRTP_CLKS-1) <= 0) ? 0 : nRTP_CLKS-1;\n  localparam RTP_TIMER_WIDTH = clogb2(nRTP_CLKS_M1 + 1);\n  reg [RTP_TIMER_WIDTH-1:0] rtp_timer_ns;\n  reg [RTP_TIMER_WIDTH-1:0] rtp_timer_r;\n  wire sending_col_not_rmw_rd = sending_col && ~rd_half_rmw_lcl;\n  always @(pass_open_bank_r or rst or rtp_timer_r\n           or sending_col_not_rmw_rd) begin\n    rtp_timer_ns = rtp_timer_r;\n    if (rst || pass_open_bank_r)\n      rtp_timer_ns = ZERO[RTP_TIMER_WIDTH-1:0];\n    else begin\n      if (sending_col_not_rmw_rd) \n         rtp_timer_ns = nRTP_CLKS_M1[RTP_TIMER_WIDTH-1:0];\n      if (|rtp_timer_r) rtp_timer_ns = rtp_timer_r - ONE[RTP_TIMER_WIDTH-1:0];\n    end\n  end\n  always @(posedge clk) rtp_timer_r <= #TCQ rtp_timer_ns;\n\n  wire end_rtp_lcl =   ~pass_open_bank_r &&\n                       ((rtp_timer_r == ONE[RTP_TIMER_WIDTH-1:0]) ||\n                       ((nRTP_CLKS_M1 == 0) && sending_col_not_rmw_rd));\n  output wire end_rtp;\n  assign end_rtp = end_rtp_lcl;\n\n\n  localparam OP_WIDTH = clogb2(nOP_WAIT + 1);\n  output wire bank_wait_in_progress;\n  output wire start_pre_wait;\n  input passing_open_bank;\n  input low_idle_cnt_r;\n  output wire op_exit_req;\n  input op_exit_grant;\n  input tail_r;\n  output reg pre_wait_r;\n\n  generate\n    if (nOP_WAIT == 0) begin : op_mode_disabled\n      assign bank_wait_in_progress = sending_col_not_rmw_rd || |rtp_timer_r ||\n                                     (pre_wait_r && ~ras_timer_zero_r);\n      assign start_pre_wait = end_rtp_lcl;\n      assign op_exit_req = 1'b0;\n    end\n    else begin : op_mode_enabled\n      reg op_wait_r;\n      assign bank_wait_in_progress = sending_col || |rtp_timer_r ||\n                                     (pre_wait_r && ~ras_timer_zero_r) ||\n                                     op_wait_r;\n      wire op_active = ~rst && ~passing_open_bank && ((end_rtp_lcl && tail_r)\n                                || op_wait_r);\n      wire op_wait_ns = ~op_exit_grant && op_active;\n      always @(posedge clk) op_wait_r <= #TCQ op_wait_ns;\n      assign start_pre_wait = op_exit_grant ||\n                              (end_rtp_lcl && ~tail_r && ~passing_open_bank);\n      if (nOP_WAIT == -1)\n        assign op_exit_req = (low_idle_cnt_r && op_active);\n      else begin : op_cnt\n        reg [OP_WIDTH-1:0] op_cnt_r;\n        wire [OP_WIDTH-1:0] op_cnt_ns =\n                                   (passing_open_bank || op_exit_grant || rst)\n                                       ? ZERO[OP_WIDTH-1:0]\n                                       : end_rtp_lcl\n                                         ? nOP_WAIT[OP_WIDTH-1:0]\n                                         : |op_cnt_r\n                                            ? op_cnt_r - ONE[OP_WIDTH-1:0]\n                                            : op_cnt_r;\n        always @(posedge clk) op_cnt_r <= #TCQ op_cnt_ns;\n        assign op_exit_req = (low_idle_cnt_r && op_active) ||\n                             (op_wait_r && ~|op_cnt_r);\n      end\n    end\n  endgenerate\n\n  output allow_auto_pre;\n  wire allow_auto_pre = act_wait_r_lcl || rcd_active_r ||\n                        (col_wait_r && ~sending_col);\n\n\n  input auto_pre_r;\n  wire start_pre;\n  input pass_open_bank_ns;\n  wire pre_wait_ns = ~rst && (~pass_open_bank_ns &&\n                     (start_pre_wait || (pre_wait_r && ~start_pre)));\n  always @(posedge clk) pre_wait_r <= #TCQ pre_wait_ns;\n  wire pre_request = pre_wait_r && ras_timer_zero_r && ~auto_pre_r;\n\n\n  localparam nRP_CLKS = (nCK_PER_CLK == 1) ? nRP : \n                        (nCK_PER_CLK == 2) ? ((nRP/2) + (nRP%2)) : \n                       ((nRP/4) + ((nRP%4) ? 1 : 0));\n\n\n\n  localparam nRP_CLKS_M2 = (nRP_CLKS-2 < 0) ? 0 : nRP_CLKS-2;\n  localparam RP_TIMER_WIDTH = clogb2(nRP_CLKS_M2 + 1);\n  \n  input sending_pre;\n  output rts_pre;\n  \n  generate\n  \n    if((nCK_PER_CLK == 4) && (ADDR_CMD_MODE != \"2T\")) begin\n    \n      assign start_pre =  pre_wait_r && ras_timer_zero_r &&\n                          (sending_pre || auto_pre_r);\n      \n      assign rts_pre = ~sending_pre && pre_request;\n    \n    end\n    \n    else begin\n    \n      assign start_pre =  pre_wait_r && ras_timer_zero_r &&\n                          (sending_row || auto_pre_r);\n                          \n      assign rts_pre = 1'b0;\n      \n    end\n\n  endgenerate\n\n  reg [RP_TIMER_WIDTH-1:0] rp_timer_r = ZERO[RP_TIMER_WIDTH-1:0];\n\n  generate\n    if (nRP_CLKS_M2 > ZERO) begin : rp_timer\n      reg [RP_TIMER_WIDTH-1:0] rp_timer_ns;\n      always @(rp_timer_r or rst or start_pre)\n        if (rst) rp_timer_ns = ZERO[RP_TIMER_WIDTH-1:0];\n        else begin\n          rp_timer_ns = rp_timer_r;\n          if (start_pre) rp_timer_ns = nRP_CLKS_M2[RP_TIMER_WIDTH-1:0];\n          else if (|rp_timer_r) rp_timer_ns =\n                                  rp_timer_r - ONE[RP_TIMER_WIDTH-1:0];\n        end\n      always @(posedge clk) rp_timer_r <= #TCQ rp_timer_ns;\n    end \n  endgenerate\n\n  output wire precharge_bm_end;\n  assign precharge_bm_end = (rp_timer_r == ONE[RP_TIMER_WIDTH-1:0]) ||\n                            (start_pre && (nRP_CLKS_M2 == ZERO));\n\n\n\n\n\n\n\n\n\n\n  input [RANK_WIDTH-1:0] req_rank_r;\n  input [(RANK_WIDTH*nBANK_MACHS*2)-1:0] req_rank_r_in;\n\n  reg inhbt_act_rrd;\n  input [(nBANK_MACHS*2)-1:0] start_rcd_in;\n\n  generate\n    integer j;\n    if (RANKS == 1)\n      always @(req_rank_r or req_rank_r_in or start_rcd_in) begin\n        inhbt_act_rrd = 1'b0;\n        for (j=(ID+1); j<(ID+nBANK_MACHS); j=j+1)\n          inhbt_act_rrd = inhbt_act_rrd || start_rcd_in[j];\n      end\n    else begin\n      always @(req_rank_r or req_rank_r_in or start_rcd_in) begin\n        inhbt_act_rrd = 1'b0;\n        for (j=(ID+1); j<(ID+nBANK_MACHS); j=j+1)\n          inhbt_act_rrd = inhbt_act_rrd ||\n             (start_rcd_in[j] &&\n              (req_rank_r_in[(j*RANK_WIDTH)+:RANK_WIDTH] == req_rank_r));\n      end\n    end\n\n  endgenerate\n\n\n\n\n  input [RANKS-1:0] inhbt_act_faw_r;\n  wire my_inhbt_act_faw = inhbt_act_faw_r[req_rank_r];\n\n  input wait_for_maint_r;\n  input head_r;\n  wire act_req = ~idle_r && head_r && act_wait_r && ras_timer_zero_r &&\n                 ~wait_for_maint_r;\n\n\n\n\n\n\n  input sent_row;\n  wire rts_act_denied = act_req && sent_row && ~sending_row;\n\n  reg [BM_CNT_WIDTH-1:0] act_starve_limit_cntr_ns;\n  reg [BM_CNT_WIDTH-1:0] act_starve_limit_cntr_r;\n\n  generate\n    if (BM_CNT_WIDTH > 1) \n    begin :BM_MORE_THAN_2 \n       always @(act_req or act_starve_limit_cntr_r or rts_act_denied)\n         begin\n           act_starve_limit_cntr_ns = act_starve_limit_cntr_r;\n           if (~act_req)\n             act_starve_limit_cntr_ns = {BM_CNT_WIDTH{1'b0}};\n           else\n             if (rts_act_denied && &act_starve_limit_cntr_r)\n               act_starve_limit_cntr_ns = act_starve_limit_cntr_r +\n                                          {{BM_CNT_WIDTH-1{1'b0}}, 1'b1};\n         end\n    end \n    else \n    begin :BM_EQUAL_2 \n       always @(act_req or act_starve_limit_cntr_r or rts_act_denied)\n         begin\n           act_starve_limit_cntr_ns = act_starve_limit_cntr_r;\n           if (~act_req)\n             act_starve_limit_cntr_ns = {BM_CNT_WIDTH{1'b0}};\n           else\n             if (rts_act_denied && &act_starve_limit_cntr_r)\n               act_starve_limit_cntr_ns = act_starve_limit_cntr_r +\n                                          {1'b1};\n         end\n    end \n  endgenerate\n\n  always @(posedge clk) act_starve_limit_cntr_r <=\n                        #TCQ act_starve_limit_cntr_ns;\n\n  reg demand_act_priority_r;\n  wire demand_act_priority_ns = act_req &&\n      (demand_act_priority_r || (rts_act_denied && &act_starve_limit_cntr_r));\n  always @(posedge clk) demand_act_priority_r <= #TCQ demand_act_priority_ns;\n\n`ifdef MC_SVA\n  cover_demand_act_priority:\n    cover property (@(posedge clk) (~rst && demand_act_priority_r));\n`endif\n\n  output wire demand_act_priority;\n  assign demand_act_priority = demand_act_priority_r && ~sending_row;\n\n\n  input [(nBANK_MACHS*2)-1:0] demand_act_priority_in;\n  reg act_demanded = 1'b0;\n  generate\n    if (nBANK_MACHS > 1) begin : compute_act_demanded\n      always @(demand_act_priority_in[`BM_SHARED_BV])\n           act_demanded = |demand_act_priority_in[`BM_SHARED_BV];\n    end\n  endgenerate\n\n  wire row_demand_ok = demand_act_priority_r || ~act_demanded;\n\n\n  output wire rts_row;\n\n  generate\n\n    if((nCK_PER_CLK == 4) && (ADDR_CMD_MODE != \"2T\"))\n      assign rts_row = ~sending_row && row_demand_ok &&\n                      (act_req && ~my_inhbt_act_faw && ~inhbt_act_rrd);\n    else\n      assign rts_row = ~sending_row && row_demand_ok &&\n                      ((act_req && ~my_inhbt_act_faw && ~inhbt_act_rrd) ||\n                        pre_request);\n  endgenerate\n  \n`ifdef MC_SVA\n  four_activate_window_wait:\n    cover property (@(posedge clk)\n      (~rst && ~sending_row && act_req &&  my_inhbt_act_faw));\n  ras_ras_delay_wait:\n    cover property (@(posedge clk)\n      (~rst && ~sending_row && act_req && inhbt_act_rrd));\n`endif\n\n\n\n\n\n  output reg [RANKS-1:0] act_this_rank_r;\n  reg [RANKS-1:0] act_this_rank_ns;\n  always @(act_wait_r or req_rank_r) begin\n    act_this_rank_ns = {RANKS{1'b0}};\n    for (i = 0; i < RANKS; i = i + 1)\n      act_this_rank_ns[i] = act_wait_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n  end\n  always @(posedge clk) act_this_rank_r <= #TCQ act_this_rank_ns;\n\n\n\n\n  input order_q_zero;\n  wire req_bank_rdy_ns = order_q_zero && col_wait_r;\n  reg req_bank_rdy_r;\n  always @(posedge clk) req_bank_rdy_r <= #TCQ req_bank_rdy_ns;\n\n\n  input sent_col;\n  wire rts_col_denied = req_bank_rdy_r && sent_col && ~sending_col;\n\n\n\n  localparam STARVE_LIMIT_CNT      = STARVE_LIMIT * nBANK_MACHS;\n  localparam STARVE_LIMIT_WIDTH    = clogb2(STARVE_LIMIT_CNT);\n  reg [STARVE_LIMIT_WIDTH-1:0] starve_limit_cntr_r;\n  reg [STARVE_LIMIT_WIDTH-1:0] starve_limit_cntr_ns;\n  always @(col_wait_r or rts_col_denied or starve_limit_cntr_r)\n   if (~col_wait_r)\n     starve_limit_cntr_ns = {STARVE_LIMIT_WIDTH{1'b0}};\n   else\n     if (rts_col_denied && (starve_limit_cntr_r != STARVE_LIMIT_CNT-1))\n       starve_limit_cntr_ns = starve_limit_cntr_r +\n                              {{STARVE_LIMIT_WIDTH-1{1'b0}}, 1'b1};\n     else starve_limit_cntr_ns = starve_limit_cntr_r;\n  always @(posedge clk) starve_limit_cntr_r <= #TCQ starve_limit_cntr_ns;\n\n  input q_has_rd;\n  input q_has_priority;\n\n\n\n  wire starved = ((starve_limit_cntr_r == (STARVE_LIMIT_CNT-1)) &&\n                 rts_col_denied);\n  input req_priority_r;\n  input idle_ns;\n  reg demand_priority_r;\n  wire demand_priority_ns = ~idle_ns && col_wait_ns &&\n                              (demand_priority_r ||\n                              (order_q_zero &&\n                               (req_priority_r || q_has_priority)) ||\n                               (starved && (q_has_rd || ~req_wr_r)));\n\n  always @(posedge clk) demand_priority_r <= #TCQ demand_priority_ns;\n\n`ifdef MC_SVA\n  wire rdy_for_priority = ~rst && ~demand_priority_r && ~idle_ns &&\n                          col_wait_ns;\n  req_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (rdy_for_priority && req_priority_r && ~q_has_priority && ~starved));\n  q_priority_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (rdy_for_priority && ~req_priority_r && q_has_priority && ~starved));\n  wire not_req_or_q_rdy_for_priority =\n        rdy_for_priority && ~req_priority_r && ~q_has_priority;\n  starved_req_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (not_req_or_q_rdy_for_priority && starved && ~q_has_rd && ~req_wr_r));\n  starved_q_triggers_demand_priority:\n    cover property (@(posedge clk)\n       (not_req_or_q_rdy_for_priority && starved && q_has_rd && req_wr_r));\n`endif\n\n\n  input [(nBANK_MACHS*2)-1:0] demand_priority_in;\n  reg demanded = 1'b0;\n  generate\n    if (nBANK_MACHS > 1) begin : compute_demanded\n      always @(demand_priority_in[`BM_SHARED_BV]) demanded =\n                                    |demand_priority_in[`BM_SHARED_BV];\n    end\n  endgenerate\n\n\n\n\n\n\n\n\n\n\n\n\n  reg demanded_prior_r;\n  wire demanded_prior_ns = demanded &&\n                          (demanded_prior_r || ~demand_priority_r);\n  always @(posedge clk) demanded_prior_r <= #TCQ demanded_prior_ns;\n\n  output wire demand_priority;\n  assign demand_priority = demand_priority_r && ~demanded_prior_r &&\n                           ~sending_col;\n\n`ifdef MC_SVA\n  demand_priority_gated:\n    cover property (@(posedge clk) (demand_priority_r && ~demand_priority));\n  generate\n    if (nBANK_MACHS >1) multiple_demand_priority:\n         cover property (@(posedge clk)\n           ($countones(demand_priority_in[`BM_SHARED_BV]) > 1));\n  endgenerate\n`endif\n\n  wire demand_ok = demand_priority_r || ~demanded;\n  \n  \n  \n  input rnk_config_strobe;\n  input rnk_config_kill_rts_col;\n  input rnk_config_valid_r;\n  input [RANK_WIDTH-1:0] rnk_config;\n  output wire rtc;\n\n  wire rnk_config_match = rnk_config_valid_r && (rnk_config == req_rank_r);\n  assign rtc = ~rnk_config_match && ~rnk_config_kill_rts_col && order_q_zero && col_wait_r && demand_ok;\n\n\n\n  input [RANKS-1:0] inhbt_rd;\n  wire my_inhbt_rd = inhbt_rd[req_rank_r];\n  input [RANKS-1:0] inhbt_wr;\n  wire my_inhbt_wr = inhbt_wr[req_rank_r];\n  wire allow_rw = ~rd_wr_r ? ~my_inhbt_wr : ~my_inhbt_rd;\n\n\n  input dq_busy_data;\n\n\n  wire col_rdy = (col_wait_r || ((nRCD_CLKS <= 1) && end_rcd) ||\n               (rcv_open_bank && nCK_PER_CLK == 2 && DRAM_TYPE==\"DDR2\" && BURST_MODE == \"4\") || \n               (rcv_open_bank && nCK_PER_CLK == 4 && BURST_MODE == \"8\")) &&\n                order_q_zero;\n\n\n\n  output wire col_rdy_wr;\n  assign col_rdy_wr = col_rdy && ~rd_wr_r;\n  \n\n\n\n  wire col_cmd_rts = col_rdy && ~dq_busy_data && allow_rw && rnk_config_match;\n\n`ifdef MC_SVA\n  col_wait_for_order_q: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && ~order_q_zero && ~dq_busy_data &&\n         allow_rw));\n  col_wait_for_dq_busy: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && order_q_zero && dq_busy_data &&\n         allow_rw));\n  col_wait_for_allow_rw: cover property\n    (@(posedge clk)\n        (~rst && col_wait_r && order_q_zero && ~dq_busy_data &&\n         ~allow_rw));\n`endif\n\n\n\n  input phy_mc_ctl_full;\n  input phy_mc_cmd_full;\n  input phy_mc_data_full;\n\n  \n  reg phy_mc_ctl_full_r = 1'b0;\n  reg phy_mc_cmd_full_r = 1'b0;\n  always @(posedge clk)\n    if(rst) begin\n      phy_mc_ctl_full_r <= #TCQ 1'b0;\n      phy_mc_cmd_full_r <= #TCQ 1'b0;\n    end else begin\n      phy_mc_ctl_full_r <= #TCQ phy_mc_ctl_full;\n      phy_mc_cmd_full_r <= #TCQ phy_mc_cmd_full;\n    end\n  \n  \n  reg ofs_rdy_r = 1'b0;\n  always @(posedge clk)\n    if(rst)\n      ofs_rdy_r <= #TCQ 1'b0;\n    else\n      ofs_rdy_r <= #TCQ ~phy_mc_cmd_full_r && ~phy_mc_ctl_full_r && ~(phy_mc_data_full && ~rd_wr_r);\n\n\n\n  reg override_demand_r;\n  wire override_demand_ns = rnk_config_strobe || rnk_config_kill_rts_col;\n  always @(posedge clk) override_demand_r <= override_demand_ns;\n  output wire rts_col;\n  assign rts_col = ~sending_col && (demand_ok || override_demand_r) &&\n                   col_cmd_rts && ofs_rdy_r;\n\n\n\n\n  reg [RANKS-1:0] wr_this_rank_ns;\n  reg [RANKS-1:0] rd_this_rank_ns;\n  always @(rd_wr_r or req_rank_r) begin\n    wr_this_rank_ns = {RANKS{1'b0}};\n    rd_this_rank_ns = {RANKS{1'b0}};\n    for (i=0; i<RANKS; i=i+1) begin\n      wr_this_rank_ns[i] = ~rd_wr_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n      rd_this_rank_ns[i] = rd_wr_r && (i[RANK_WIDTH-1:0] == req_rank_r);\n    end\n  end\n  output reg [RANKS-1:0] wr_this_rank_r;\n  always @(posedge clk) wr_this_rank_r <= #TCQ wr_this_rank_ns;\n  output reg [RANKS-1:0] rd_this_rank_r;\n  always @(posedge clk) rd_this_rank_r <= #TCQ rd_this_rank_ns;\n                                   \nendmodule \n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_bank_state. Module specification: This module implements a bank state controller for a memory interface generator (MIG) in 7 series FPGAs. It manages the timing and control of memory operations such as activation, read, write, and precharge for a single bank in a multi-bank memory system. The module has numerous input ports including clk, rst, bm_end, sending_row, rcv_open_bank, sending_col, rd_wr_r, req_wr_r, phy_rddata_valid, and various timing and configuration signals. Output ports include start_rcd, act_wait_r, rd_half_rmw, ras_timer_ns, end_rtp, bank_wait_in_progress, start_pre_wait, rts_row, rts_col, and several control"
                }
            ]
        }
    ]
}