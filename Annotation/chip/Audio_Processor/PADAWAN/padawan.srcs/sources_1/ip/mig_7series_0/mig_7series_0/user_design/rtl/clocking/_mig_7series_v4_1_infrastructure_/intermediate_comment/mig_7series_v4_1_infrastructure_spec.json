{
    "spec": "Module name: mig_7series_v4_1_infrastructure. Module specification: This module is designed to generate and control various clocks and reset signals for a memory interface in Xilinx 7 series devices. It utilizes a Phase-Locked Loop (PLL) and Mixed-Mode Clock Manager (MMCM) to generate multiple clock outputs with configurable frequencies and phases. The module takes inputs such as mmcm_clk (primary clock input), sys_rst (system reset), iodelay_ctrl_rdy (delay control ready signal), ref_dll_lock (DLL lock signal), psen (phase shift enable), and psincdec (phase shift increment/decrement). It produces outputs including clk (main clock), clk_div2 (half-frequency clock), various reset signals (rstdiv0, rst_div2, iddr_rst, rst_phaser",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_infrastructure\nExplanation: This module is designed to generate and control various clocks and reset signals used in a memory interface for Xilinx 7 series devices. It utilizes Xilinx's primitive components like the phase-locked loop (PLL) and Mixed-Mode Clock Manager (MMCM) to generate the clocks. The parameters of the module can be set accordingly to handle different configuration and operational requirements. It also has a significant condition checking and reset mechanism to ensure the stability and correctness of the generated clocks."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. mmcm_clk: This is the primary clock input for the MMCM (Mixed-Mode Clock Manager) to generate various clock output frequencies.\n\n2. sys_rst: This is the system reset input and its active level is controlled by the parameter RST_ACT_LOW. \n\n3. iodelay_ctrl_rdy: This input comes from the delay controls and can be used to indicate when the delay controls are ready.\n\n4. ref_dll_lock: This input signal indicates that the Delay Locked Loop (DLL) has locked on the reference clock.\n\n5. psen: This input signal enables phase shifting in the MMCM.\n\n6. psincdec: This input signal determines whether the phase shift in the MMCM is to increment or decrement.\n\nOutput Ports:\n\n1. clk: This is the main output clock generated by the module.\n\n2. clk_div2: This is another output clock generated by the module having half frequency of the main clock. \n\n3. rst_div2: This is the reset signal correspondingly synchronized with the clk_div2.\n\n4. mem_refclk: This is the clock reference for the memory system.\n\n5. freq_refclk: This is the frequency reference clock output.\n\n6. sync_pulse: This is the clock used for synchronization purposes.\n\n7. mmcm_ps_clk: This clock is a programmable clock from the MMCM used for processes needing specific frequency rates.\n\n8. poc_sample_pd: This is the power-on control sample power down signal.\n\n9. ui_addn_clk_0, ui_addn_clk_1, ui_addn_clk_2, ui_addn_clk_3, ui_addn_clk_4: These are additional user interface clocks. Their functionalities can be set accordingly based on user requirement.\n\n10. pll_locked: This output signal indicates whether the PLL has locked onto the input clock.\n\n11. mmcm_locked: This output signal indicates whether the MMCM has locked onto the input clock.\n\n12. rstdiv0: This is the reset signal synchronized with the main clock.\n\n13. iddr_rst: This is the reset signal that is synchronized with the MMCM clock.\n\n14. rst_phaser_ref: This is the reset signal for the Phaser Reference.\n\n15. psdone: This output signal indicates whether the phase shift operation of the MMCM has been completed."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \n1. Internal signals: RST_SYNC_NUM, RST_DIV_SYNC_NUM, CLKIN1_PERIOD_NS, CLKOUT4_DIVIDE, VCO_PERIOD, CLKOUT0_PERIOD, CLKOUT1_PERIOD, CLKOUT2_PERIOD, CLKOUT3_PERIOD, CLKOUT4_PERIOD, CLKOUT4_PHASE, CLKOUT3_PERIOD_NS, CLKOUT4_PERIOD_NS, clk_bufg, clk_pll_i, clkfbout_pll, pll_clkfbout, pll_locked_i, rstdiv0_sync_r, rst_tmp, rstdiv0_sync_r1, rst_sync_r, rst_sync_r1, rstdiv2_sync_r, rstdiv2_sync_r1, sys_rst_act_hi, rst_tmp_phaser_ref, rst_phaser_ref_sync_r, clkfbout, MMCM_Locked_i, mmcm_clkout0, mmcm_clkout1, mmcm_clkout2, mmcm_clkout3, mmcm_clkout4, mmcm_ps_clk_bufg_in, clk_div2_bufg_in, pll_clk3_out, pll_clk3, ONE, TAPSPERFCLK, TAPSPERFCLK_MINUS_ONE, QCNTR_WIDTH, qcntr_ns, qcntr_r, inv_poc_sample_ns, inv_poc_sample_r, first_rising_ps_clk, first_rising_ps_clk_ns, first_rising_ps_clk_r, mmcm_hi0_ns, mmcm_hi0_r, pdiff, poc_sample_pd_ns, poc_sample_pd_r \n\n2. Explanation:\n- RST_SYNC_NUM, RST_DIV_SYNC_NUM: Local parameters for synchronization.\n- CLKIN1_PERIOD_NS, CLKOUT4_DIVIDE, VCO_PERIOD, CLKOUT0_PERIOD, CLKOUT1_PERIOD, CLKOUT2_PERIOD, CLKOUT3_PERIOD, CLKOUT4_PERIOD, CLKOUT4_PHASE, CLKOUT3_PERIOD_NS, CLKOUT4_PERIOD_NS: Local parameters used in the design to define the clocking parameters and phases of the PLL and MMCME2_ADV.\n- clk_bufg, clk_pll_i, clkfbout_pll, pll_clkfbout, pll_locked_i: Internal wired connections used for interconnecting different components like buffers and the PLL.\n- rstdiv0_sync_r, rst_tmp, rstdiv0_sync_r1, rst_sync_r, rst_sync_r1, rstdiv2_sync_r, rstdiv2_sync_r1: Internal reg type signals used in the generation of the synchronized reset signals.\n- sys_rst_act_hi: Wired connection used for controlling the effective level of the system reset signal.\n- rst_tmp_phaser_ref, rst_phaser_ref_sync_r: Internal signal generated to reset the Phaser Reference.\n- clkfbout, MMCM_Locked_i, mmcm_clkout0, mmcm_clkout1, mmcm_clkout2, mmcm_clkout3, mmcm_clkout4, mmcm_ps_clk_bufg_in, clk_div2_bufg_in: Wired connections to the MMCME2_ADV component to control different clocks and monitor the lock condition.\n- pll_clk3_out, pll_clk3: Internal signals in control of the third output clock of PLL.\n- ONE, TAPSPERFCLK, TAPSPERFCLK_MINUS_ONE, QCNTR_WIDTH: Local parameters regarding the phase shifting operation of the MMCM.\n- qcntr_ns, qcntr_r, inv_poc_sample_ns, inv_poc_sample_r, first_rising_ps_clk, first_rising_ps_clk_ns, first_rising_ps_clk_r, mmcm_hi0_ns, mmcm_hi0_r, pdiff: Internal register type signals for handling the phase shifting operation and synchronization mechanism of the MMCM.\n- poc_sample_pd_ns, poc_sample_pd_r: Internal signals to control the power-on control sample power down signal.\n"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n\nmodule mig_7series_v4_1_infrastructure #\n  (\n   parameter SIMULATION      = \"FALSE\",  \n                                         \n   parameter TCQ             = 100,      \n   parameter CLKIN_PERIOD    = 3000,     \n   parameter nCK_PER_CLK     = 2,        \n   parameter SYSCLK_TYPE     = \"DIFFERENTIAL\",\n                                         \n                                         \n   parameter UI_EXTRA_CLOCKS = \"FALSE\",\n                                         \n                                         \n                                         \n                                         \n   parameter CLKFBOUT_MULT   = 4,        \n   parameter DIVCLK_DIVIDE   = 1,        \n   parameter CLKOUT0_PHASE   = 45.0,     \n   parameter CLKOUT0_DIVIDE   = 16,      \n   parameter CLKOUT1_DIVIDE   = 4,       \n   parameter CLKOUT2_DIVIDE   = 64,      \n   parameter CLKOUT3_DIVIDE   = 16,      \n   parameter MMCM_VCO             = 1200,     \n   parameter MMCM_MULT_F          = 4,        \n   parameter MMCM_DIVCLK_DIVIDE   = 1,        \n   parameter MMCM_CLKOUT0_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT1_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT2_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT3_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT4_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT0_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT1_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT2_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT3_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT4_DIVIDE   = 1,  \n   parameter RST_ACT_LOW           = 1,\n   parameter tCK                   = 1250,\n                                     \n                                     \n   parameter MEM_TYPE              = \"DDR3\"\n   )\n  (\n   \n   input  mmcm_clk,           \n   \n   input  sys_rst,            \n   \n   input  [1:0] iodelay_ctrl_rdy,   \n   \n\n   output clk,                \n                              \n   output clk_div2,           \n   output rst_div2,           \n   output mem_refclk,         \n   output freq_refclk,        \n                              \n                              \n   output sync_pulse,         \n\n   output mmcm_ps_clk,        \n   output poc_sample_pd,      \n   output ui_addn_clk_0,      \n   output ui_addn_clk_1,      \n   output ui_addn_clk_2,      \n   output ui_addn_clk_3,      \n   output ui_addn_clk_4,      \n   output pll_locked,         \n   output mmcm_locked,        \n   \n   output rstdiv0,             \n   output iddr_rst\n\n   ,output rst_phaser_ref\n   ,input  ref_dll_lock\n   ,input  psen\n   ,input  psincdec\n   ,output psdone\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n  localparam RST_SYNC_NUM = 25;\n\n  \n  \n  \n  localparam RST_DIV_SYNC_NUM = (RST_SYNC_NUM+1)/2;\n\n  \n  \n  \n  localparam real CLKIN1_PERIOD_NS = CLKIN_PERIOD / 1000.0;\n  localparam CLKOUT4_DIVIDE = 2 * CLKOUT1_DIVIDE;\n\n  localparam integer VCO_PERIOD\n             = (CLKIN1_PERIOD_NS * DIVCLK_DIVIDE * 1000) / CLKFBOUT_MULT;\n\n  localparam CLKOUT0_PERIOD = VCO_PERIOD * CLKOUT0_DIVIDE;\n  localparam CLKOUT1_PERIOD = VCO_PERIOD * CLKOUT1_DIVIDE;\n  localparam CLKOUT2_PERIOD = VCO_PERIOD * CLKOUT2_DIVIDE;\n  localparam CLKOUT3_PERIOD = VCO_PERIOD * CLKOUT3_DIVIDE;\n  localparam CLKOUT4_PERIOD = VCO_PERIOD * CLKOUT4_DIVIDE;\n\n  localparam CLKOUT4_PHASE  = (SIMULATION == \"TRUE\") ? 22.5 : 168.75;\n\n  localparam real CLKOUT3_PERIOD_NS = CLKOUT3_PERIOD / 1000.0;\n  localparam real CLKOUT4_PERIOD_NS = CLKOUT4_PERIOD / 1000.0;\n\n  \n  initial begin\n    $display(\"############# Write Clocks PLLE2_ADV Parameters #############\\n\");\n    $display(\"nCK_PER_CLK      = %7d\",   nCK_PER_CLK     );\n    $display(\"CLK_PERIOD       = %7d\",   CLKIN_PERIOD    );\n    $display(\"CLKIN1_PERIOD    = %7.3f\", CLKIN1_PERIOD_NS);\n    $display(\"DIVCLK_DIVIDE    = %7d\",   DIVCLK_DIVIDE   );\n    $display(\"CLKFBOUT_MULT    = %7d\",   CLKFBOUT_MULT );\n    $display(\"VCO_PERIOD       = %7.1f\", VCO_PERIOD      );\n    $display(\"CLKOUT0_DIVIDE_F = %7d\",   CLKOUT0_DIVIDE  );\n    $display(\"CLKOUT1_DIVIDE   = %7d\",   CLKOUT1_DIVIDE  );\n    $display(\"CLKOUT2_DIVIDE   = %7d\",   CLKOUT2_DIVIDE  );\n    $display(\"CLKOUT3_DIVIDE   = %7d\",   CLKOUT3_DIVIDE  );\n    $display(\"CLKOUT0_PERIOD   = %7d\",   CLKOUT0_PERIOD  );\n    $display(\"CLKOUT1_PERIOD   = %7d\",   CLKOUT1_PERIOD  );\n    $display(\"CLKOUT2_PERIOD   = %7d\",   CLKOUT2_PERIOD  );\n    $display(\"CLKOUT3_PERIOD   = %7d\",   CLKOUT3_PERIOD  );\n    $display(\"CLKOUT4_PERIOD   = %7d\",   CLKOUT4_PERIOD  );\n    $display(\"############################################################\\n\");\n  end\n  \n\n  wire                       clk_bufg;\n  wire                       clk_pll_i;\n  wire                       clkfbout_pll;\n  wire                       pll_clkfbout;\n  wire                       pll_locked_i\n                             ;\n  (* max_fanout = 50 *) reg [RST_DIV_SYNC_NUM-2:0] rstdiv0_sync_r;\n  wire                       rst_tmp;\n  (* max_fanout = 50 *) reg rstdiv0_sync_r1\n                            ;\n  reg [RST_DIV_SYNC_NUM-2:0] rst_sync_r;\n (* max_fanout = 10  *) reg rst_sync_r1\n                             ;\n  reg [RST_DIV_SYNC_NUM-2:0] rstdiv2_sync_r;\n  (* max_fanout = 10  *) reg rstdiv2_sync_r1\n                             ;\n  wire                       sys_rst_act_hi;\n\n  wire                       rst_tmp_phaser_ref;\n  (* max_fanout = 50 *) reg [RST_DIV_SYNC_NUM-1:0] rst_phaser_ref_sync_r\n                             ;\n\n  \n  wire        clkfbout;\n  wire        MMCM_Locked_i;\n\n  wire        mmcm_clkout0;\n  wire        mmcm_clkout1;\n  wire        mmcm_clkout2;\n  wire        mmcm_clkout3;\n  wire        mmcm_clkout4;\n  wire        mmcm_ps_clk_bufg_in;\n  wire        clk_div2_bufg_in;\n\n  wire        pll_clk3_out;\n  wire        pll_clk3;\n\n  assign sys_rst_act_hi = RST_ACT_LOW ? ~sys_rst: sys_rst;\n\n  \n  \n  \n  \n\n  assign clk        = clk_bufg;\n  assign pll_locked = pll_locked_i & MMCM_Locked_i;\n  assign mmcm_locked = MMCM_Locked_i;\n\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  PLLE2_ADV #\n    (\n     .BANDWIDTH          (\"OPTIMIZED\"),\n     .COMPENSATION       (\"INTERNAL\"),\n     .STARTUP_WAIT       (\"FALSE\"),\n     .CLKOUT0_DIVIDE     (CLKOUT0_DIVIDE),  \n     .CLKOUT1_DIVIDE     (CLKOUT1_DIVIDE),  \n     .CLKOUT2_DIVIDE     (CLKOUT2_DIVIDE),  \n     .CLKOUT3_DIVIDE     (CLKOUT3_DIVIDE),  \n     .CLKOUT4_DIVIDE     (CLKOUT4_DIVIDE),\n     .CLKOUT5_DIVIDE     (),\n     .DIVCLK_DIVIDE      (DIVCLK_DIVIDE),\n     .CLKFBOUT_MULT      (CLKFBOUT_MULT),\n     .CLKFBOUT_PHASE     (0.000),\n     .CLKIN1_PERIOD      (CLKIN1_PERIOD_NS),\n     .CLKIN2_PERIOD      (),\n     .CLKOUT0_DUTY_CYCLE (0.500),\n     .CLKOUT0_PHASE      (CLKOUT0_PHASE),\n     .CLKOUT1_DUTY_CYCLE (0.500),\n     .CLKOUT1_PHASE      (0.000),\n     .CLKOUT2_DUTY_CYCLE (1.0/16.0),\n     .CLKOUT2_PHASE      (9.84375),     \n     .CLKOUT3_DUTY_CYCLE (0.500),\n     .CLKOUT3_PHASE      (0.000),\n     .CLKOUT4_DUTY_CYCLE (0.500),\n     .CLKOUT4_PHASE      (CLKOUT4_PHASE),\n     .CLKOUT5_DUTY_CYCLE (0.500),\n     .CLKOUT5_PHASE      (0.000),\n     .REF_JITTER1        (0.010),\n     .REF_JITTER2        (0.010)\n     )\n    plle2_i\n      (\n       .CLKFBOUT (pll_clkfbout),\n       .CLKOUT0  (freq_refclk),\n       .CLKOUT1  (mem_refclk),\n       .CLKOUT2  (sync_pulse),  \n       .CLKOUT3  (pll_clk3_out),\n\n       .CLKOUT4  (),\n       .CLKOUT5  (),\n       .DO       (),\n       .DRDY     (),\n       .LOCKED   (pll_locked_i),\n       .CLKFBIN  (pll_clkfbout),\n       .CLKIN1   (mmcm_clk),\n       .CLKIN2   (),\n       .CLKINSEL (1'b1),\n       .DADDR    (7'b0),\n       .DCLK     (1'b0),\n       .DEN      (1'b0),\n       .DI       (16'b0),\n       .DWE      (1'b0),\n       .PWRDWN   (1'b0),\n       .RST      ( sys_rst_act_hi)\n       );\n\n\n\n\n\n\n\n\n  BUFG u_bufg_clkdiv0\n    (\n     .O (clk_bufg),\n     .I (clk_pll_i)\n     );\n\n  BUFH u_bufh_pll_clk3\n    (\n     .O (pll_clk3),\n     .I (pll_clk3_out)\n     );\n\n  localparam  real    MMCM_VCO_PERIOD       = 1000000.0/MMCM_VCO;\n\n  \n  initial begin\n    $display(\"############# MMCME2_ADV Parameters #############\\n\");\n    $display(\"MMCM_MULT_F           = %d\", MMCM_MULT_F);\n\n    $display(\"MMCM_VCO_FREQ (MHz)   = %7.3f\", MMCM_VCO*1.000);\n    $display(\"MMCM_VCO_PERIOD       = %7.3f\", MMCM_VCO_PERIOD);\n    $display(\"#################################################\\n\");\n  end\n  \n\n  generate\n    if (UI_EXTRA_CLOCKS == \"TRUE\") begin: gen_ui_extra_clocks\n\n      localparam MMCM_CLKOUT0_DIVIDE_CAL = (MMCM_CLKOUT0_EN == \"TRUE\") ? MMCM_CLKOUT0_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT1_DIVIDE_CAL = (MMCM_CLKOUT1_EN == \"TRUE\") ? MMCM_CLKOUT1_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT2_DIVIDE_CAL = (MMCM_CLKOUT2_EN == \"TRUE\") ? MMCM_CLKOUT2_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT3_DIVIDE_CAL = (MMCM_CLKOUT3_EN == \"TRUE\") ? MMCM_CLKOUT3_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT4_DIVIDE_CAL = (MMCM_CLKOUT4_EN == \"TRUE\") ? MMCM_CLKOUT4_DIVIDE : MMCM_MULT_F;\n\n      MMCME2_ADV\n      #(.BANDWIDTH            (\"HIGH\"),\n        .CLKOUT4_CASCADE      (\"FALSE\"),\n        .COMPENSATION         (\"BUF_IN\"),\n        .STARTUP_WAIT         (\"FALSE\"),\n\n        .DIVCLK_DIVIDE        (MMCM_DIVCLK_DIVIDE),\n        .CLKFBOUT_MULT_F      (MMCM_MULT_F),\n        .CLKFBOUT_PHASE       (0.000),\n        .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n        .CLKOUT0_DIVIDE_F     (MMCM_CLKOUT0_DIVIDE_CAL),\n        .CLKOUT0_PHASE        (0.000),\n        .CLKOUT0_DUTY_CYCLE   (0.500),\n        .CLKOUT0_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT1_DIVIDE       (MMCM_CLKOUT1_DIVIDE_CAL),\n        .CLKOUT1_PHASE        (0.000),\n        .CLKOUT1_DUTY_CYCLE   (0.500),\n        .CLKOUT1_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT2_DIVIDE       (MMCM_CLKOUT2_DIVIDE_CAL),\n        .CLKOUT2_PHASE        (0.000),\n        .CLKOUT2_DUTY_CYCLE   (0.500),\n        .CLKOUT2_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT3_DIVIDE       (MMCM_CLKOUT3_DIVIDE_CAL),\n        .CLKOUT3_PHASE        (0.000),\n        .CLKOUT3_DUTY_CYCLE   (0.500),\n        .CLKOUT3_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT4_DIVIDE       (MMCM_CLKOUT4_DIVIDE_CAL),\n        .CLKOUT4_PHASE        (0.000),\n        .CLKOUT4_DUTY_CYCLE   (0.500),\n        .CLKOUT4_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT5_DIVIDE       (((MMCM_MULT_F*2)/MMCM_DIVCLK_DIVIDE)),\n        .CLKOUT5_PHASE        (0.000),\n        .CLKOUT5_DUTY_CYCLE   (0.500),\n        .CLKOUT5_USE_FINE_PS  (\"TRUE\"),\n        .CLKOUT6_DIVIDE       (MMCM_MULT_F/2),\n        .CLKOUT6_PHASE        (0.000),\n        .CLKOUT6_DUTY_CYCLE   (0.500),\n        .CLKOUT6_USE_FINE_PS  (\"FALSE\"),\n        .CLKIN1_PERIOD        (CLKOUT3_PERIOD_NS),\n        .REF_JITTER1          (0.000))\n      mmcm_i\n        \n       (.CLKFBOUT            (clk_pll_i),\n        .CLKFBOUTB           (),\n        .CLKOUT0             (mmcm_clkout0),\n        .CLKOUT0B            (),\n        .CLKOUT1             (mmcm_clkout1),\n        .CLKOUT1B            (),\n        .CLKOUT2             (mmcm_clkout2),\n        .CLKOUT2B            (),\n        .CLKOUT3             (mmcm_clkout3),\n        .CLKOUT3B            (),\n        .CLKOUT4             (mmcm_clkout4),\n        .CLKOUT5             (mmcm_ps_clk_bufg_in),\n        .CLKOUT6             (clk_div2_bufg_in),\n         \n        .CLKFBIN             (clk_bufg),      \n        .CLKIN1              (pll_clk3),      \n        .CLKIN2              (1'b0),\n         \n        .CLKINSEL            (1'b1),\n        \n        .DADDR               (7'h0),\n        .DCLK                (1'b0),\n        .DEN                 (1'b0),\n        .DI                  (16'h0),\n        .DO                  (),\n        .DRDY                (),\n        .DWE                 (1'b0),\n        \n        .PSCLK               (clk),\n        .PSEN                (psen),\n        .PSINCDEC            (psincdec),\n        .PSDONE              (psdone),\n        \n        .LOCKED              (MMCM_Locked_i),\n        .CLKINSTOPPED        (),\n        .CLKFBSTOPPED        (),\n        .PWRDWN              (1'b0),\n        .RST                 (~pll_locked_i));\n\n      BUFG u_bufg_ui_addn_clk_0\n        (\n         .O (ui_addn_clk_0),\n         .I (mmcm_clkout0)\n         );\n\n      BUFG u_bufg_ui_addn_clk_1\n        (\n         .O (ui_addn_clk_1),\n         .I (mmcm_clkout1)\n         );\n\n      BUFG u_bufg_ui_addn_clk_2\n        (\n         .O (ui_addn_clk_2),\n         .I (mmcm_clkout2)\n         );\n\n      BUFG u_bufg_ui_addn_clk_3\n        (\n         .O (ui_addn_clk_3),\n         .I (mmcm_clkout3)\n         );\n\n      BUFG u_bufg_ui_addn_clk_4\n        (\n         .O (ui_addn_clk_4),\n         .I (mmcm_clkout4)\n         );\n\n      BUFG u_bufg_mmcm_ps_clk\n        (\n         .O (mmcm_ps_clk),\n         .I (mmcm_ps_clk_bufg_in)\n         );\n       \n      BUFG u_bufg_clk_div2\n        (\n         .O (clk_div2),\n         .I (clk_div2_bufg_in)\n         );\n    end else begin: gen_mmcm\n\n      MMCME2_ADV\n      #(.BANDWIDTH            (\"HIGH\"),\n        .CLKOUT4_CASCADE      (\"FALSE\"),\n        .COMPENSATION         (\"BUF_IN\"),\n        .STARTUP_WAIT         (\"FALSE\"),\n\n        .DIVCLK_DIVIDE        (MMCM_DIVCLK_DIVIDE),\n        .CLKFBOUT_MULT_F      (MMCM_MULT_F),\n        .CLKFBOUT_PHASE       (0.000),\n        .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n        .CLKOUT0_DIVIDE_F     (((MMCM_MULT_F*2)/MMCM_DIVCLK_DIVIDE)),\n        .CLKOUT0_PHASE        (0.000),\n        .CLKOUT0_DUTY_CYCLE   (0.500),\n        .CLKOUT0_USE_FINE_PS  (\"TRUE\"),\n        .CLKOUT1_DIVIDE       (MMCM_MULT_F/2),\n        .CLKOUT1_PHASE        (0.000),\n        .CLKOUT1_DUTY_CYCLE   (0.500),\n        .CLKOUT1_USE_FINE_PS  (\"FALSE\"),\n        .CLKIN1_PERIOD        (CLKOUT3_PERIOD_NS),\n        .REF_JITTER1          (0.000))\n      mmcm_i\n        \n       (.CLKFBOUT            (clk_pll_i),\n        .CLKFBOUTB           (),\n        .CLKOUT0             (mmcm_ps_clk_bufg_in),\n        .CLKOUT0B            (),\n        .CLKOUT1             (clk_div2_bufg_in),\n        .CLKOUT1B            (),\n        .CLKOUT2             (),\n        .CLKOUT2B            (),\n        .CLKOUT3             (),\n        .CLKOUT3B            (),\n        .CLKOUT4             (),\n        .CLKOUT5             (),\n        .CLKOUT6             (),\n         \n        .CLKFBIN             (clk_bufg),      \n        .CLKIN1              (pll_clk3),      \n        .CLKIN2              (1'b0),\n         \n        .CLKINSEL            (1'b1),\n        \n        .DADDR               (7'h0),\n        .DCLK                (1'b0),\n        .DEN                 (1'b0),\n        .DI                  (16'h0),\n        .DO                  (),\n        .DRDY                (),\n        .DWE                 (1'b0),\n        \n        .PSCLK               (clk),\n        .PSEN                (psen),\n        .PSINCDEC            (psincdec),\n        .PSDONE              (psdone),\n        \n        .LOCKED              (MMCM_Locked_i),\n        .CLKINSTOPPED        (),\n        .CLKFBSTOPPED        (),\n        .PWRDWN              (1'b0),\n        .RST                 (~pll_locked_i));\n\n    BUFG u_bufg_mmcm_ps_clk\n    (\n     .O (mmcm_ps_clk),\n     .I (mmcm_ps_clk_bufg_in)\n     );\n\t \n    BUFG u_bufg_clk_div2\n    (\n     .O (clk_div2),\n     .I (clk_div2_bufg_in)\n     );\n\t \n    end \n  endgenerate\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam ONE = 1;\n  localparam integer TAPSPERFCLK = 56 * MMCM_MULT_F;\n  localparam TAPSPERFCLK_MINUS_ONE = TAPSPERFCLK - 1;\n  localparam QCNTR_WIDTH = clogb2(TAPSPERFCLK);\n  \n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  reg [QCNTR_WIDTH-1:0] qcntr_ns, qcntr_r;\n  always @(posedge clk) qcntr_r <= #TCQ qcntr_ns;\n\n  reg inv_poc_sample_ns, inv_poc_sample_r;\n  always @(posedge clk) inv_poc_sample_r <= #TCQ inv_poc_sample_ns;\n  \n  always @(*) begin\n    qcntr_ns = qcntr_r;\n    inv_poc_sample_ns = inv_poc_sample_r;\n    if (rstdiv0) begin\n      qcntr_ns = 'b0;\n      inv_poc_sample_ns = 'b0;\n    end else if (psen) begin\n      if (qcntr_r < TAPSPERFCLK_MINUS_ONE[QCNTR_WIDTH-1:0])\n        qcntr_ns = (qcntr_r + ONE[QCNTR_WIDTH-1:0]);\n      else begin\n        qcntr_ns = {QCNTR_WIDTH{1'b0}};\n\tinv_poc_sample_ns = ~inv_poc_sample_r;\n      end\n    end\n  end \n\n  \n  \n  reg first_rising_ps_clk_ns, first_rising_ps_clk_r;\n  always @(posedge mmcm_ps_clk) first_rising_ps_clk_r <= #TCQ first_rising_ps_clk_ns;\n  always @(*) first_rising_ps_clk_ns = ~rstdiv0;\n\n  reg mmcm_hi0_ns, mmcm_hi0_r;\n  always @(posedge clk) mmcm_hi0_r <= #TCQ mmcm_hi0_ns;\n  always @(*) mmcm_hi0_ns = ~first_rising_ps_clk_r || ~mmcm_hi0_r;\n\n  reg poc_sample_pd_ns, poc_sample_pd_r;\n  always @(*) poc_sample_pd_ns = inv_poc_sample_ns ^ mmcm_hi0_r;\n  always @(posedge clk) poc_sample_pd_r <= #TCQ poc_sample_pd_ns;\n  assign poc_sample_pd = poc_sample_pd_r;\n\n  \n  \n  \n  \n\n  \n  generate \n    if ( tCK <= 2500 ) begin : check_ocal_timing\n      localparam CLK_PERIOD_PS = MMCM_VCO_PERIOD * MMCM_MULT_F;\n      localparam integer CLK_PERIOD_PS_DIV4 = CLK_PERIOD_PS/4;\n\n      time rising_mmcm_ps_clk;\n      always @(posedge mmcm_ps_clk) rising_mmcm_ps_clk = $time();\n\n      time pdiff;  \n      always @(posedge clk) pdiff = $time() - rising_mmcm_ps_clk;\n    end\n  endgenerate\n\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n\n  \n  generate\n    if (MEM_TYPE == \"DDR3\" && tCK <= 1500) begin: rst_tmp_300_400\n      assign rst_tmp = sys_rst_act_hi | ~iodelay_ctrl_rdy[1] |\n                       ~ref_dll_lock | ~MMCM_Locked_i;\n    end else begin: rst_tmp_200\n      assign rst_tmp = sys_rst_act_hi | ~iodelay_ctrl_rdy[0] |\n                       ~ref_dll_lock | ~MMCM_Locked_i;\n    end\n  endgenerate\n\n  always @(posedge clk_bufg or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rstdiv0_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rstdiv0_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rstdiv0_sync_r  <= #TCQ rstdiv0_sync_r << 1;\n      rstdiv0_sync_r1 <= #TCQ rstdiv0_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign rstdiv0 = rstdiv0_sync_r1 ;\n\n\n  always @(posedge mmcm_ps_clk  or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rst_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rst_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rst_sync_r  <= #TCQ rst_sync_r << 1;\n      rst_sync_r1 <= #TCQ rst_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign iddr_rst = rst_sync_r1 ;\n  \n\n  always @(posedge clk_div2  or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rstdiv2_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rstdiv2_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rstdiv2_sync_r  <= #TCQ rstdiv2_sync_r << 1;\n      rstdiv2_sync_r1 <= #TCQ rstdiv2_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign rst_div2 = rstdiv2_sync_r1 ;\n\n  generate\n    if (MEM_TYPE == \"DDR3\" && tCK <= 1500) begin: rst_tmp_phaser_ref_300_400\n      assign rst_tmp_phaser_ref = sys_rst_act_hi | ~MMCM_Locked_i | ~iodelay_ctrl_rdy[1];\n    end else begin: rst_tmp_phaser_ref_200\n      assign rst_tmp_phaser_ref = sys_rst_act_hi | ~MMCM_Locked_i | ~iodelay_ctrl_rdy[0];\n    end\n  endgenerate\n\n  always @(posedge clk_bufg or posedge rst_tmp_phaser_ref)\n    if (rst_tmp_phaser_ref)\n      rst_phaser_ref_sync_r <= #TCQ {RST_DIV_SYNC_NUM{1'b1}};\n    else\n      rst_phaser_ref_sync_r <= #TCQ rst_phaser_ref_sync_r << 1;\n\n  assign rst_phaser_ref = rst_phaser_ref_sync_r[RST_DIV_SYNC_NUM-1];\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_infrastructure. Module specification: This module is designed to generate and control various clocks and reset signals for a memory interface in Xilinx 7 series devices. It utilizes a Phase-Locked Loop (PLL) and Mixed-Mode Clock Manager (MMCM) to generate multiple clock outputs with configurable frequencies and phases. The module takes inputs such as mmcm_clk (primary clock input), sys_rst (system reset), iodelay_ctrl_rdy (delay control ready signal), ref_dll_lock (DLL lock signal), psen (phase shift enable), and psincdec (phase shift increment/decrement). It produces outputs including clk (main clock), clk_div2 (half-frequency clock), various reset signals (rstdiv0, rst_div2, iddr_rst, rst_phaser"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_infrastructure\nExplanation: This module is designed to generate and control various clocks and reset signals used in a memory interface for Xilinx 7 series devices. It utilizes Xilinx's primitive components like the phase-locked loop (PLL) and Mixed-Mode Clock Manager (MMCM) to generate the clocks. The parameters of the module can be set accordingly to handle different configuration and operational requirements. It also has a significant condition checking and reset mechanism to ensure the stability and correctness of the generated clocks."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. mmcm_clk: This is the primary clock input for the MMCM (Mixed-Mode Clock Manager) to generate various clock output frequencies.\n\n2. sys_rst: This is the system reset input and its active level is controlled by the parameter RST_ACT_LOW. \n\n3. iodelay_ctrl_rdy: This input comes from the delay controls and can be used to indicate when the delay controls are ready.\n\n4. ref_dll_lock: This input signal indicates that the Delay Locked Loop (DLL) has locked on the reference clock.\n\n5. psen: This input signal enables phase shifting in the MMCM.\n\n6. psincdec: This input signal determines whether the phase shift in the MMCM is to increment or decrement.\n\nOutput Ports:\n\n1. clk: This is the main output clock generated by the module.\n\n2. clk_div2: This is another output clock generated by the module having half frequency of the main clock. \n\n3. rst_div2: This is the reset signal correspondingly synchronized with the clk_div2.\n\n4. mem_refclk: This is the clock reference for the memory system.\n\n5. freq_refclk: This is the frequency reference clock output.\n\n6. sync_pulse: This is the clock used for synchronization purposes.\n\n7. mmcm_ps_clk: This clock is a programmable clock from the MMCM used for processes needing specific frequency rates.\n\n8. poc_sample_pd: This is the power-on control sample power down signal.\n\n9. ui_addn_clk_0, ui_addn_clk_1, ui_addn_clk_2, ui_addn_clk_3, ui_addn_clk_4: These are additional user interface clocks. Their functionalities can be set accordingly based on user requirement.\n\n10. pll_locked: This output signal indicates whether the PLL has locked onto the input clock.\n\n11. mmcm_locked: This output signal indicates whether the MMCM has locked onto the input clock.\n\n12. rstdiv0: This is the reset signal synchronized with the main clock.\n\n13. iddr_rst: This is the reset signal that is synchronized with the MMCM clock.\n\n14. rst_phaser_ref: This is the reset signal for the Phaser Reference.\n\n15. psdone: This output signal indicates whether the phase shift operation of the MMCM has been completed."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \n1. Internal signals: RST_SYNC_NUM, RST_DIV_SYNC_NUM, CLKIN1_PERIOD_NS, CLKOUT4_DIVIDE, VCO_PERIOD, CLKOUT0_PERIOD, CLKOUT1_PERIOD, CLKOUT2_PERIOD, CLKOUT3_PERIOD, CLKOUT4_PERIOD, CLKOUT4_PHASE, CLKOUT3_PERIOD_NS, CLKOUT4_PERIOD_NS, clk_bufg, clk_pll_i, clkfbout_pll, pll_clkfbout, pll_locked_i, rstdiv0_sync_r, rst_tmp, rstdiv0_sync_r1, rst_sync_r, rst_sync_r1, rstdiv2_sync_r, rstdiv2_sync_r1, sys_rst_act_hi, rst_tmp_phaser_ref, rst_phaser_ref_sync_r, clkfbout, MMCM_Locked_i, mmcm_clkout0, mmcm_clkout1, mmcm_clkout2, mmcm_clkout3, mmcm_clkout4, mmcm_ps_clk_bufg_in, clk_div2_bufg_in, pll_clk3_out, pll_clk3, ONE, TAPSPERFCLK, TAPSPERFCLK_MINUS_ONE, QCNTR_WIDTH, qcntr_ns, qcntr_r, inv_poc_sample_ns, inv_poc_sample_r, first_rising_ps_clk, first_rising_ps_clk_ns, first_rising_ps_clk_r, mmcm_hi0_ns, mmcm_hi0_r, pdiff, poc_sample_pd_ns, poc_sample_pd_r \n\n2. Explanation:\n- RST_SYNC_NUM, RST_DIV_SYNC_NUM: Local parameters for synchronization.\n- CLKIN1_PERIOD_NS, CLKOUT4_DIVIDE, VCO_PERIOD, CLKOUT0_PERIOD, CLKOUT1_PERIOD, CLKOUT2_PERIOD, CLKOUT3_PERIOD, CLKOUT4_PERIOD, CLKOUT4_PHASE, CLKOUT3_PERIOD_NS, CLKOUT4_PERIOD_NS: Local parameters used in the design to define the clocking parameters and phases of the PLL and MMCME2_ADV.\n- clk_bufg, clk_pll_i, clkfbout_pll, pll_clkfbout, pll_locked_i: Internal wired connections used for interconnecting different components like buffers and the PLL.\n- rstdiv0_sync_r, rst_tmp, rstdiv0_sync_r1, rst_sync_r, rst_sync_r1, rstdiv2_sync_r, rstdiv2_sync_r1: Internal reg type signals used in the generation of the synchronized reset signals.\n- sys_rst_act_hi: Wired connection used for controlling the effective level of the system reset signal.\n- rst_tmp_phaser_ref, rst_phaser_ref_sync_r: Internal signal generated to reset the Phaser Reference.\n- clkfbout, MMCM_Locked_i, mmcm_clkout0, mmcm_clkout1, mmcm_clkout2, mmcm_clkout3, mmcm_clkout4, mmcm_ps_clk_bufg_in, clk_div2_bufg_in: Wired connections to the MMCME2_ADV component to control different clocks and monitor the lock condition.\n- pll_clk3_out, pll_clk3: Internal signals in control of the third output clock of PLL.\n- ONE, TAPSPERFCLK, TAPSPERFCLK_MINUS_ONE, QCNTR_WIDTH: Local parameters regarding the phase shifting operation of the MMCM.\n- qcntr_ns, qcntr_r, inv_poc_sample_ns, inv_poc_sample_r, first_rising_ps_clk, first_rising_ps_clk_ns, first_rising_ps_clk_r, mmcm_hi0_ns, mmcm_hi0_r, pdiff: Internal register type signals for handling the phase shifting operation and synchronization mechanism of the MMCM.\n- poc_sample_pd_ns, poc_sample_pd_r: Internal signals to control the power-on control sample power down signal.\n"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n\nmodule mig_7series_v4_1_infrastructure #\n  (\n   parameter SIMULATION      = \"FALSE\",  \n                                         \n   parameter TCQ             = 100,      \n   parameter CLKIN_PERIOD    = 3000,     \n   parameter nCK_PER_CLK     = 2,        \n   parameter SYSCLK_TYPE     = \"DIFFERENTIAL\",\n                                         \n                                         \n   parameter UI_EXTRA_CLOCKS = \"FALSE\",\n                                         \n                                         \n                                         \n                                         \n   parameter CLKFBOUT_MULT   = 4,        \n   parameter DIVCLK_DIVIDE   = 1,        \n   parameter CLKOUT0_PHASE   = 45.0,     \n   parameter CLKOUT0_DIVIDE   = 16,      \n   parameter CLKOUT1_DIVIDE   = 4,       \n   parameter CLKOUT2_DIVIDE   = 64,      \n   parameter CLKOUT3_DIVIDE   = 16,      \n   parameter MMCM_VCO             = 1200,     \n   parameter MMCM_MULT_F          = 4,        \n   parameter MMCM_DIVCLK_DIVIDE   = 1,        \n   parameter MMCM_CLKOUT0_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT1_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT2_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT3_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT4_EN       = \"FALSE\",  \n   parameter MMCM_CLKOUT0_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT1_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT2_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT3_DIVIDE   = 1,  \n   parameter MMCM_CLKOUT4_DIVIDE   = 1,  \n   parameter RST_ACT_LOW           = 1,\n   parameter tCK                   = 1250,\n                                     \n                                     \n   parameter MEM_TYPE              = \"DDR3\"\n   )\n  (\n   \n   input  mmcm_clk,           \n   \n   input  sys_rst,            \n   \n   input  [1:0] iodelay_ctrl_rdy,   \n   \n\n   output clk,                \n                              \n   output clk_div2,           \n   output rst_div2,           \n   output mem_refclk,         \n   output freq_refclk,        \n                              \n                              \n   output sync_pulse,         \n\n   output mmcm_ps_clk,        \n   output poc_sample_pd,      \n   output ui_addn_clk_0,      \n   output ui_addn_clk_1,      \n   output ui_addn_clk_2,      \n   output ui_addn_clk_3,      \n   output ui_addn_clk_4,      \n   output pll_locked,         \n   output mmcm_locked,        \n   \n   output rstdiv0,             \n   output iddr_rst\n\n   ,output rst_phaser_ref\n   ,input  ref_dll_lock\n   ,input  psen\n   ,input  psincdec\n   ,output psdone\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n  localparam RST_SYNC_NUM = 25;\n\n  \n  \n  \n  localparam RST_DIV_SYNC_NUM = (RST_SYNC_NUM+1)/2;\n\n  \n  \n  \n  localparam real CLKIN1_PERIOD_NS = CLKIN_PERIOD / 1000.0;\n  localparam CLKOUT4_DIVIDE = 2 * CLKOUT1_DIVIDE;\n\n  localparam integer VCO_PERIOD\n             = (CLKIN1_PERIOD_NS * DIVCLK_DIVIDE * 1000) / CLKFBOUT_MULT;\n\n  localparam CLKOUT0_PERIOD = VCO_PERIOD * CLKOUT0_DIVIDE;\n  localparam CLKOUT1_PERIOD = VCO_PERIOD * CLKOUT1_DIVIDE;\n  localparam CLKOUT2_PERIOD = VCO_PERIOD * CLKOUT2_DIVIDE;\n  localparam CLKOUT3_PERIOD = VCO_PERIOD * CLKOUT3_DIVIDE;\n  localparam CLKOUT4_PERIOD = VCO_PERIOD * CLKOUT4_DIVIDE;\n\n  localparam CLKOUT4_PHASE  = (SIMULATION == \"TRUE\") ? 22.5 : 168.75;\n\n  localparam real CLKOUT3_PERIOD_NS = CLKOUT3_PERIOD / 1000.0;\n  localparam real CLKOUT4_PERIOD_NS = CLKOUT4_PERIOD / 1000.0;\n\n  \n  initial begin\n    $display(\"############# Write Clocks PLLE2_ADV Parameters #############\\n\");\n    $display(\"nCK_PER_CLK      = %7d\",   nCK_PER_CLK     );\n    $display(\"CLK_PERIOD       = %7d\",   CLKIN_PERIOD    );\n    $display(\"CLKIN1_PERIOD    = %7.3f\", CLKIN1_PERIOD_NS);\n    $display(\"DIVCLK_DIVIDE    = %7d\",   DIVCLK_DIVIDE   );\n    $display(\"CLKFBOUT_MULT    = %7d\",   CLKFBOUT_MULT );\n    $display(\"VCO_PERIOD       = %7.1f\", VCO_PERIOD      );\n    $display(\"CLKOUT0_DIVIDE_F = %7d\",   CLKOUT0_DIVIDE  );\n    $display(\"CLKOUT1_DIVIDE   = %7d\",   CLKOUT1_DIVIDE  );\n    $display(\"CLKOUT2_DIVIDE   = %7d\",   CLKOUT2_DIVIDE  );\n    $display(\"CLKOUT3_DIVIDE   = %7d\",   CLKOUT3_DIVIDE  );\n    $display(\"CLKOUT0_PERIOD   = %7d\",   CLKOUT0_PERIOD  );\n    $display(\"CLKOUT1_PERIOD   = %7d\",   CLKOUT1_PERIOD  );\n    $display(\"CLKOUT2_PERIOD   = %7d\",   CLKOUT2_PERIOD  );\n    $display(\"CLKOUT3_PERIOD   = %7d\",   CLKOUT3_PERIOD  );\n    $display(\"CLKOUT4_PERIOD   = %7d\",   CLKOUT4_PERIOD  );\n    $display(\"############################################################\\n\");\n  end\n  \n\n  wire                       clk_bufg;\n  wire                       clk_pll_i;\n  wire                       clkfbout_pll;\n  wire                       pll_clkfbout;\n  wire                       pll_locked_i\n                             ;\n  (* max_fanout = 50 *) reg [RST_DIV_SYNC_NUM-2:0] rstdiv0_sync_r;\n  wire                       rst_tmp;\n  (* max_fanout = 50 *) reg rstdiv0_sync_r1\n                            ;\n  reg [RST_DIV_SYNC_NUM-2:0] rst_sync_r;\n (* max_fanout = 10  *) reg rst_sync_r1\n                             ;\n  reg [RST_DIV_SYNC_NUM-2:0] rstdiv2_sync_r;\n  (* max_fanout = 10  *) reg rstdiv2_sync_r1\n                             ;\n  wire                       sys_rst_act_hi;\n\n  wire                       rst_tmp_phaser_ref;\n  (* max_fanout = 50 *) reg [RST_DIV_SYNC_NUM-1:0] rst_phaser_ref_sync_r\n                             ;\n\n  \n  wire        clkfbout;\n  wire        MMCM_Locked_i;\n\n  wire        mmcm_clkout0;\n  wire        mmcm_clkout1;\n  wire        mmcm_clkout2;\n  wire        mmcm_clkout3;\n  wire        mmcm_clkout4;\n  wire        mmcm_ps_clk_bufg_in;\n  wire        clk_div2_bufg_in;\n\n  wire        pll_clk3_out;\n  wire        pll_clk3;\n\n  assign sys_rst_act_hi = RST_ACT_LOW ? ~sys_rst: sys_rst;\n\n  \n  \n  \n  \n\n  assign clk        = clk_bufg;\n  assign pll_locked = pll_locked_i & MMCM_Locked_i;\n  assign mmcm_locked = MMCM_Locked_i;\n\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  PLLE2_ADV #\n    (\n     .BANDWIDTH          (\"OPTIMIZED\"),\n     .COMPENSATION       (\"INTERNAL\"),\n     .STARTUP_WAIT       (\"FALSE\"),\n     .CLKOUT0_DIVIDE     (CLKOUT0_DIVIDE),  \n     .CLKOUT1_DIVIDE     (CLKOUT1_DIVIDE),  \n     .CLKOUT2_DIVIDE     (CLKOUT2_DIVIDE),  \n     .CLKOUT3_DIVIDE     (CLKOUT3_DIVIDE),  \n     .CLKOUT4_DIVIDE     (CLKOUT4_DIVIDE),\n     .CLKOUT5_DIVIDE     (),\n     .DIVCLK_DIVIDE      (DIVCLK_DIVIDE),\n     .CLKFBOUT_MULT      (CLKFBOUT_MULT),\n     .CLKFBOUT_PHASE     (0.000),\n     .CLKIN1_PERIOD      (CLKIN1_PERIOD_NS),\n     .CLKIN2_PERIOD      (),\n     .CLKOUT0_DUTY_CYCLE (0.500),\n     .CLKOUT0_PHASE      (CLKOUT0_PHASE),\n     .CLKOUT1_DUTY_CYCLE (0.500),\n     .CLKOUT1_PHASE      (0.000),\n     .CLKOUT2_DUTY_CYCLE (1.0/16.0),\n     .CLKOUT2_PHASE      (9.84375),     \n     .CLKOUT3_DUTY_CYCLE (0.500),\n     .CLKOUT3_PHASE      (0.000),\n     .CLKOUT4_DUTY_CYCLE (0.500),\n     .CLKOUT4_PHASE      (CLKOUT4_PHASE),\n     .CLKOUT5_DUTY_CYCLE (0.500),\n     .CLKOUT5_PHASE      (0.000),\n     .REF_JITTER1        (0.010),\n     .REF_JITTER2        (0.010)\n     )\n    plle2_i\n      (\n       .CLKFBOUT (pll_clkfbout),\n       .CLKOUT0  (freq_refclk),\n       .CLKOUT1  (mem_refclk),\n       .CLKOUT2  (sync_pulse),  \n       .CLKOUT3  (pll_clk3_out),\n\n       .CLKOUT4  (),\n       .CLKOUT5  (),\n       .DO       (),\n       .DRDY     (),\n       .LOCKED   (pll_locked_i),\n       .CLKFBIN  (pll_clkfbout),\n       .CLKIN1   (mmcm_clk),\n       .CLKIN2   (),\n       .CLKINSEL (1'b1),\n       .DADDR    (7'b0),\n       .DCLK     (1'b0),\n       .DEN      (1'b0),\n       .DI       (16'b0),\n       .DWE      (1'b0),\n       .PWRDWN   (1'b0),\n       .RST      ( sys_rst_act_hi)\n       );\n\n\n\n\n\n\n\n\n  BUFG u_bufg_clkdiv0\n    (\n     .O (clk_bufg),\n     .I (clk_pll_i)\n     );\n\n  BUFH u_bufh_pll_clk3\n    (\n     .O (pll_clk3),\n     .I (pll_clk3_out)\n     );\n\n  localparam  real    MMCM_VCO_PERIOD       = 1000000.0/MMCM_VCO;\n\n  \n  initial begin\n    $display(\"############# MMCME2_ADV Parameters #############\\n\");\n    $display(\"MMCM_MULT_F           = %d\", MMCM_MULT_F);\n\n    $display(\"MMCM_VCO_FREQ (MHz)   = %7.3f\", MMCM_VCO*1.000);\n    $display(\"MMCM_VCO_PERIOD       = %7.3f\", MMCM_VCO_PERIOD);\n    $display(\"#################################################\\n\");\n  end\n  \n\n  generate\n    if (UI_EXTRA_CLOCKS == \"TRUE\") begin: gen_ui_extra_clocks\n\n      localparam MMCM_CLKOUT0_DIVIDE_CAL = (MMCM_CLKOUT0_EN == \"TRUE\") ? MMCM_CLKOUT0_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT1_DIVIDE_CAL = (MMCM_CLKOUT1_EN == \"TRUE\") ? MMCM_CLKOUT1_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT2_DIVIDE_CAL = (MMCM_CLKOUT2_EN == \"TRUE\") ? MMCM_CLKOUT2_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT3_DIVIDE_CAL = (MMCM_CLKOUT3_EN == \"TRUE\") ? MMCM_CLKOUT3_DIVIDE : MMCM_MULT_F;\n      localparam MMCM_CLKOUT4_DIVIDE_CAL = (MMCM_CLKOUT4_EN == \"TRUE\") ? MMCM_CLKOUT4_DIVIDE : MMCM_MULT_F;\n\n      MMCME2_ADV\n      #(.BANDWIDTH            (\"HIGH\"),\n        .CLKOUT4_CASCADE      (\"FALSE\"),\n        .COMPENSATION         (\"BUF_IN\"),\n        .STARTUP_WAIT         (\"FALSE\"),\n\n        .DIVCLK_DIVIDE        (MMCM_DIVCLK_DIVIDE),\n        .CLKFBOUT_MULT_F      (MMCM_MULT_F),\n        .CLKFBOUT_PHASE       (0.000),\n        .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n        .CLKOUT0_DIVIDE_F     (MMCM_CLKOUT0_DIVIDE_CAL),\n        .CLKOUT0_PHASE        (0.000),\n        .CLKOUT0_DUTY_CYCLE   (0.500),\n        .CLKOUT0_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT1_DIVIDE       (MMCM_CLKOUT1_DIVIDE_CAL),\n        .CLKOUT1_PHASE        (0.000),\n        .CLKOUT1_DUTY_CYCLE   (0.500),\n        .CLKOUT1_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT2_DIVIDE       (MMCM_CLKOUT2_DIVIDE_CAL),\n        .CLKOUT2_PHASE        (0.000),\n        .CLKOUT2_DUTY_CYCLE   (0.500),\n        .CLKOUT2_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT3_DIVIDE       (MMCM_CLKOUT3_DIVIDE_CAL),\n        .CLKOUT3_PHASE        (0.000),\n        .CLKOUT3_DUTY_CYCLE   (0.500),\n        .CLKOUT3_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT4_DIVIDE       (MMCM_CLKOUT4_DIVIDE_CAL),\n        .CLKOUT4_PHASE        (0.000),\n        .CLKOUT4_DUTY_CYCLE   (0.500),\n        .CLKOUT4_USE_FINE_PS  (\"FALSE\"),\n        .CLKOUT5_DIVIDE       (((MMCM_MULT_F*2)/MMCM_DIVCLK_DIVIDE)),\n        .CLKOUT5_PHASE        (0.000),\n        .CLKOUT5_DUTY_CYCLE   (0.500),\n        .CLKOUT5_USE_FINE_PS  (\"TRUE\"),\n        .CLKOUT6_DIVIDE       (MMCM_MULT_F/2),\n        .CLKOUT6_PHASE        (0.000),\n        .CLKOUT6_DUTY_CYCLE   (0.500),\n        .CLKOUT6_USE_FINE_PS  (\"FALSE\"),\n        .CLKIN1_PERIOD        (CLKOUT3_PERIOD_NS),\n        .REF_JITTER1          (0.000))\n      mmcm_i\n        \n       (.CLKFBOUT            (clk_pll_i),\n        .CLKFBOUTB           (),\n        .CLKOUT0             (mmcm_clkout0),\n        .CLKOUT0B            (),\n        .CLKOUT1             (mmcm_clkout1),\n        .CLKOUT1B            (),\n        .CLKOUT2             (mmcm_clkout2),\n        .CLKOUT2B            (),\n        .CLKOUT3             (mmcm_clkout3),\n        .CLKOUT3B            (),\n        .CLKOUT4             (mmcm_clkout4),\n        .CLKOUT5             (mmcm_ps_clk_bufg_in),\n        .CLKOUT6             (clk_div2_bufg_in),\n         \n        .CLKFBIN             (clk_bufg),      \n        .CLKIN1              (pll_clk3),      \n        .CLKIN2              (1'b0),\n         \n        .CLKINSEL            (1'b1),\n        \n        .DADDR               (7'h0),\n        .DCLK                (1'b0),\n        .DEN                 (1'b0),\n        .DI                  (16'h0),\n        .DO                  (),\n        .DRDY                (),\n        .DWE                 (1'b0),\n        \n        .PSCLK               (clk),\n        .PSEN                (psen),\n        .PSINCDEC            (psincdec),\n        .PSDONE              (psdone),\n        \n        .LOCKED              (MMCM_Locked_i),\n        .CLKINSTOPPED        (),\n        .CLKFBSTOPPED        (),\n        .PWRDWN              (1'b0),\n        .RST                 (~pll_locked_i));\n\n      BUFG u_bufg_ui_addn_clk_0\n        (\n         .O (ui_addn_clk_0),\n         .I (mmcm_clkout0)\n         );\n\n      BUFG u_bufg_ui_addn_clk_1\n        (\n         .O (ui_addn_clk_1),\n         .I (mmcm_clkout1)\n         );\n\n      BUFG u_bufg_ui_addn_clk_2\n        (\n         .O (ui_addn_clk_2),\n         .I (mmcm_clkout2)\n         );\n\n      BUFG u_bufg_ui_addn_clk_3\n        (\n         .O (ui_addn_clk_3),\n         .I (mmcm_clkout3)\n         );\n\n      BUFG u_bufg_ui_addn_clk_4\n        (\n         .O (ui_addn_clk_4),\n         .I (mmcm_clkout4)\n         );\n\n      BUFG u_bufg_mmcm_ps_clk\n        (\n         .O (mmcm_ps_clk),\n         .I (mmcm_ps_clk_bufg_in)\n         );\n       \n      BUFG u_bufg_clk_div2\n        (\n         .O (clk_div2),\n         .I (clk_div2_bufg_in)\n         );\n    end else begin: gen_mmcm\n\n      MMCME2_ADV\n      #(.BANDWIDTH            (\"HIGH\"),\n        .CLKOUT4_CASCADE      (\"FALSE\"),\n        .COMPENSATION         (\"BUF_IN\"),\n        .STARTUP_WAIT         (\"FALSE\"),\n\n        .DIVCLK_DIVIDE        (MMCM_DIVCLK_DIVIDE),\n        .CLKFBOUT_MULT_F      (MMCM_MULT_F),\n        .CLKFBOUT_PHASE       (0.000),\n        .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n        .CLKOUT0_DIVIDE_F     (((MMCM_MULT_F*2)/MMCM_DIVCLK_DIVIDE)),\n        .CLKOUT0_PHASE        (0.000),\n        .CLKOUT0_DUTY_CYCLE   (0.500),\n        .CLKOUT0_USE_FINE_PS  (\"TRUE\"),\n        .CLKOUT1_DIVIDE       (MMCM_MULT_F/2),\n        .CLKOUT1_PHASE        (0.000),\n        .CLKOUT1_DUTY_CYCLE   (0.500),\n        .CLKOUT1_USE_FINE_PS  (\"FALSE\"),\n        .CLKIN1_PERIOD        (CLKOUT3_PERIOD_NS),\n        .REF_JITTER1          (0.000))\n      mmcm_i\n        \n       (.CLKFBOUT            (clk_pll_i),\n        .CLKFBOUTB           (),\n        .CLKOUT0             (mmcm_ps_clk_bufg_in),\n        .CLKOUT0B            (),\n        .CLKOUT1             (clk_div2_bufg_in),\n        .CLKOUT1B            (),\n        .CLKOUT2             (),\n        .CLKOUT2B            (),\n        .CLKOUT3             (),\n        .CLKOUT3B            (),\n        .CLKOUT4             (),\n        .CLKOUT5             (),\n        .CLKOUT6             (),\n         \n        .CLKFBIN             (clk_bufg),      \n        .CLKIN1              (pll_clk3),      \n        .CLKIN2              (1'b0),\n         \n        .CLKINSEL            (1'b1),\n        \n        .DADDR               (7'h0),\n        .DCLK                (1'b0),\n        .DEN                 (1'b0),\n        .DI                  (16'h0),\n        .DO                  (),\n        .DRDY                (),\n        .DWE                 (1'b0),\n        \n        .PSCLK               (clk),\n        .PSEN                (psen),\n        .PSINCDEC            (psincdec),\n        .PSDONE              (psdone),\n        \n        .LOCKED              (MMCM_Locked_i),\n        .CLKINSTOPPED        (),\n        .CLKFBSTOPPED        (),\n        .PWRDWN              (1'b0),\n        .RST                 (~pll_locked_i));\n\n    BUFG u_bufg_mmcm_ps_clk\n    (\n     .O (mmcm_ps_clk),\n     .I (mmcm_ps_clk_bufg_in)\n     );\n\t \n    BUFG u_bufg_clk_div2\n    (\n     .O (clk_div2),\n     .I (clk_div2_bufg_in)\n     );\n\t \n    end \n  endgenerate\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam ONE = 1;\n  localparam integer TAPSPERFCLK = 56 * MMCM_MULT_F;\n  localparam TAPSPERFCLK_MINUS_ONE = TAPSPERFCLK - 1;\n  localparam QCNTR_WIDTH = clogb2(TAPSPERFCLK);\n  \n  function integer clogb2 (input integer size); \n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction \n\n  reg [QCNTR_WIDTH-1:0] qcntr_ns, qcntr_r;\n  always @(posedge clk) qcntr_r <= #TCQ qcntr_ns;\n\n  reg inv_poc_sample_ns, inv_poc_sample_r;\n  always @(posedge clk) inv_poc_sample_r <= #TCQ inv_poc_sample_ns;\n  \n  always @(*) begin\n    qcntr_ns = qcntr_r;\n    inv_poc_sample_ns = inv_poc_sample_r;\n    if (rstdiv0) begin\n      qcntr_ns = 'b0;\n      inv_poc_sample_ns = 'b0;\n    end else if (psen) begin\n      if (qcntr_r < TAPSPERFCLK_MINUS_ONE[QCNTR_WIDTH-1:0])\n        qcntr_ns = (qcntr_r + ONE[QCNTR_WIDTH-1:0]);\n      else begin\n        qcntr_ns = {QCNTR_WIDTH{1'b0}};\n\tinv_poc_sample_ns = ~inv_poc_sample_r;\n      end\n    end\n  end \n\n  \n  \n  reg first_rising_ps_clk_ns, first_rising_ps_clk_r;\n  always @(posedge mmcm_ps_clk) first_rising_ps_clk_r <= #TCQ first_rising_ps_clk_ns;\n  always @(*) first_rising_ps_clk_ns = ~rstdiv0;\n\n  reg mmcm_hi0_ns, mmcm_hi0_r;\n  always @(posedge clk) mmcm_hi0_r <= #TCQ mmcm_hi0_ns;\n  always @(*) mmcm_hi0_ns = ~first_rising_ps_clk_r || ~mmcm_hi0_r;\n\n  reg poc_sample_pd_ns, poc_sample_pd_r;\n  always @(*) poc_sample_pd_ns = inv_poc_sample_ns ^ mmcm_hi0_r;\n  always @(posedge clk) poc_sample_pd_r <= #TCQ poc_sample_pd_ns;\n  assign poc_sample_pd = poc_sample_pd_r;\n\n  \n  \n  \n  \n\n  \n  generate \n    if ( tCK <= 2500 ) begin : check_ocal_timing\n      localparam CLK_PERIOD_PS = MMCM_VCO_PERIOD * MMCM_MULT_F;\n      localparam integer CLK_PERIOD_PS_DIV4 = CLK_PERIOD_PS/4;\n\n      time rising_mmcm_ps_clk;\n      always @(posedge mmcm_ps_clk) rising_mmcm_ps_clk = $time();\n\n      time pdiff;  \n      always @(posedge clk) pdiff = $time() - rising_mmcm_ps_clk;\n    end\n  endgenerate\n\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n\n  \n  generate\n    if (MEM_TYPE == \"DDR3\" && tCK <= 1500) begin: rst_tmp_300_400\n      assign rst_tmp = sys_rst_act_hi | ~iodelay_ctrl_rdy[1] |\n                       ~ref_dll_lock | ~MMCM_Locked_i;\n    end else begin: rst_tmp_200\n      assign rst_tmp = sys_rst_act_hi | ~iodelay_ctrl_rdy[0] |\n                       ~ref_dll_lock | ~MMCM_Locked_i;\n    end\n  endgenerate\n\n  always @(posedge clk_bufg or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rstdiv0_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rstdiv0_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rstdiv0_sync_r  <= #TCQ rstdiv0_sync_r << 1;\n      rstdiv0_sync_r1 <= #TCQ rstdiv0_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign rstdiv0 = rstdiv0_sync_r1 ;\n\n\n  always @(posedge mmcm_ps_clk  or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rst_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rst_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rst_sync_r  <= #TCQ rst_sync_r << 1;\n      rst_sync_r1 <= #TCQ rst_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign iddr_rst = rst_sync_r1 ;\n  \n\n  always @(posedge clk_div2  or posedge rst_tmp) begin\n    if (rst_tmp) begin\n      rstdiv2_sync_r  <= #TCQ {RST_DIV_SYNC_NUM-1{1'b1}};\n      rstdiv2_sync_r1 <= #TCQ 1'b1 ;\n    end else begin\n      rstdiv2_sync_r  <= #TCQ rstdiv2_sync_r << 1;\n      rstdiv2_sync_r1 <= #TCQ rstdiv2_sync_r[RST_DIV_SYNC_NUM-2];\n    end\n  end\n\n  assign rst_div2 = rstdiv2_sync_r1 ;\n\n  generate\n    if (MEM_TYPE == \"DDR3\" && tCK <= 1500) begin: rst_tmp_phaser_ref_300_400\n      assign rst_tmp_phaser_ref = sys_rst_act_hi | ~MMCM_Locked_i | ~iodelay_ctrl_rdy[1];\n    end else begin: rst_tmp_phaser_ref_200\n      assign rst_tmp_phaser_ref = sys_rst_act_hi | ~MMCM_Locked_i | ~iodelay_ctrl_rdy[0];\n    end\n  endgenerate\n\n  always @(posedge clk_bufg or posedge rst_tmp_phaser_ref)\n    if (rst_tmp_phaser_ref)\n      rst_phaser_ref_sync_r <= #TCQ {RST_DIV_SYNC_NUM{1'b1}};\n    else\n      rst_phaser_ref_sync_r <= #TCQ rst_phaser_ref_sync_r << 1;\n\n  assign rst_phaser_ref = rst_phaser_ref_sync_r[RST_DIV_SYNC_NUM-1];\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_infrastructure. Module specification: This module is designed to generate and control various clocks and reset signals for a memory interface in Xilinx 7 series devices. It utilizes a Phase-Locked Loop (PLL) and Mixed-Mode Clock Manager (MMCM) to generate multiple clock outputs with configurable frequencies and phases. The module takes inputs such as mmcm_clk (primary clock input), sys_rst (system reset), iodelay_ctrl_rdy (delay control ready signal), ref_dll_lock (DLL lock signal), psen (phase shift enable), and psincdec (phase shift increment/decrement). It produces outputs including clk (main clock), clk_div2 (half-frequency clock), various reset signals (rstdiv0, rst_div2, iddr_rst, rst_phaser"
                }
            ]
        }
    ]
}