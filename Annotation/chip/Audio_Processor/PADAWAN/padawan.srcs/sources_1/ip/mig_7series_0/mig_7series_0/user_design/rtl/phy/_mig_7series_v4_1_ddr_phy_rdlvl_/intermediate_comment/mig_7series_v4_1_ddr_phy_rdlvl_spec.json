{
    "spec": "Module name: mig_7series_v4_1_ddr_phy_rdlvl. Module specification: This module implements a read leveling calibration algorithm for DDR memory interfaces. It adjusts the timing of read data capture to ensure proper alignment with the memory clock. The module takes inputs such as clock, reset, calibration start triggers, and read data, and outputs status signals, delay control signals, and calibration results. Key internal signals include counters for tracking calibration progress, flags for edge detection and pattern matching, and shift registers for storing read data. The module operates through several states, including initializing delays, detecting data patterns, finding valid edges of the data eye, and centering the read capture point. It supports multiple ranks and handles both DDR3 and DDR4 memory types. The calibration process involves incrementing delays, detecting data patterns, finding valid eye regions, and centering the read capture point within",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_rdlvl\n\nExplanation: This module implements a read leveling calibration algorithm for DDR memory interfaces. It adjusts the timing of read data capture to ensure proper alignment with the memory clock. The module performs edge detection, pattern matching, and delay adjustments on a per-byte and per-bit basis. It supports multiple ranks and handles both DDR3 and DDR4 memory types. The calibration process involves incrementing delays, detecting data patterns, finding valid eye regions, and centering the read capture point within the eye. The module uses both IDELAY and PHASER_IN delays to achieve fine-grained timing adjustments."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nBased on the provided Verilog code, here are the input and output ports of the mig_7series_v4_1_ddr_phy_rdlvl module:\n\nInput ports: clk, rst, mpr_rdlvl_start, rdlvl_stg1_start, prech_done, phy_if_empty, idelaye2_init_val, rd_data, dqs_po_dec_done, pi_counter_read_val, idelay_ld, wrcal_cnt, dbg_idel_up_all, dbg_idel_down_all, dbg_idel_up_cpt, dbg_idel_down_cpt, dbg_sel_idel_cpt, dbg_sel_all_idel_cpt.\n\nExplanation: These inputs include clock and reset signals, calibration start triggers, status signals from other memory controller components, read data, delay values, and debug control signals.\n\nOutput ports: mpr_rdlvl_done, mpr_last_byte_done, mpr_rnk_done, rdlvl_stg1_done, rdlvl_stg1_rnk_done, rdlvl_stg1_err, mpr_rdlvl_err, rdlvl_err, rdlvl_prech_req, rdlvl_last_byte_done, rdlvl_assrt_common, pi_fine_dly_dec_done, pi_en_stg2_f, pi_stg2_f_incdec, pi_stg2_load, pi_stg2_reg_l, pi_stg2_rdlvl_cnt, idelay_ce, idelay_inc, dlyval_dq, rdlvl_pi_incdec, dbg_cpt_first_edge_cnt, dbg_cpt_second_edge_cnt, dbg_cpt_tap_cnt, dbg_dq_idelay_tap_cnt, dbg_phy_rdlvl.\n\nExplanation: These outputs provide status signals for the read leveling process, error flags, delay control signals for fine-tuning, calibration results, and debug information for monitoring the calibration process."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: cal1_cnt_cpt_r, cal1_dlyce_cpt_r, cal1_dlyinc_cpt_r, cal1_prech_req_r, cal1_state_r, cnt_idel_dec_cpt_r, found_first_edge_r, found_second_edge_r, tap_cnt_cpt_r, tap_limit_cpt_r, sr_rise0_r, sr_fall0_r, sr_rise1_r, sr_fall1_r, sr_valid_r, store_sr_r, pat_data_match_r, detect_edge_done_r, found_edge_r, found_stable_eye_r, rdlvl_dqs_tap_cnt_r, rnk_cnt_r, rdlvl_rank_done_r.\n\nExplanation:\n- cal1_cnt_cpt_r: Counter for tracking the current DQS byte being calibrated\n- cal1_dlyce_cpt_r, cal1_dlyinc_cpt_r: Control signals for IDELAY adjustment\n- cal1_prech_req_r: Request signal for precharge operation\n- cal1_state_r: Current state of the calibration state machine\n- cnt_idel_dec_cpt_r: Counter for IDELAY decrements during centering\n- found_first_edge_r, found_second_edge_r: Flags indicating edge detection status\n- tap_cnt_cpt_r: Current tap count for IDELAY\n- tap_limit_cpt_r: Flag indicating if maximum tap count is reached\n- sr_rise0_r, sr_fall0_r, sr_rise1_r, sr_fall1_r: Shift registers for storing read data\n- sr_valid_r: Flag indicating valid data in shift registers\n- store_sr_r: Control signal to store shift register data\n- pat_data_match_r: Flag indicating a match with expected data pattern\n- detect_edge_done_r: Flag indicating completion of edge detection\n- found_edge_r: Flag indicating an edge has been found\n- found_stable_eye_r: Flag indicating a stable data eye has been found\n- rdlvl_dqs_tap_cnt_r: Array storing final tap counts for each DQS\n- rnk_cnt_r: Counter for tracking the current rank being calibrated\n- rdlvl_rank_done_r: Flag indicating completion of calibration for a rank"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n(* use_dsp48 = \"no\" *)\n\nmodule mig_7series_v4_1_ddr_phy_rdlvl #\n  (\n   parameter TCQ             = 100,    \n   parameter nCK_PER_CLK     = 2,      \n   parameter CLK_PERIOD      = 3333,   \n   parameter DQ_WIDTH        = 64,     \n   parameter DQS_CNT_WIDTH   = 3,      \n   parameter DQS_WIDTH       = 8,      \n   parameter DRAM_WIDTH      = 8,      \n   parameter RANKS           = 1,      \n   parameter PER_BIT_DESKEW  = \"ON\",   \n   parameter SIM_CAL_OPTION  = \"NONE\", \n   parameter DEBUG_PORT      = \"OFF\",  \n   parameter DRAM_TYPE       = \"DDR3\",  \n   parameter OCAL_EN         = \"ON\",\n   parameter IDELAY_ADJ      = \"ON\",\n   parameter PI_DIV2_INCDEC  = \"TRUE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   \n   input                        mpr_rdlvl_start,\n   output                       mpr_rdlvl_done,\n   output reg                   mpr_last_byte_done,\n   output                       mpr_rnk_done,\n   input                        rdlvl_stg1_start,\n   output                       rdlvl_stg1_done ,\n   output                       rdlvl_stg1_rnk_done,\n   output reg                   rdlvl_stg1_err,\n   output                       mpr_rdlvl_err,\n   output                       rdlvl_err,\n   output reg                   rdlvl_prech_req,\n   output                       rdlvl_last_byte_done,\n   output reg                   rdlvl_assrt_common,\n   input                        prech_done,\n   input                        phy_if_empty,\n   input [4:0]                  idelaye2_init_val,\n   \n   input [2*nCK_PER_CLK*DQ_WIDTH-1:0] rd_data,\n   \n   input                        dqs_po_dec_done,\n   input [5:0]                  pi_counter_read_val,\n   \n   output reg                   pi_fine_dly_dec_done,\n   output reg                   pi_en_stg2_f,\n   output reg                   pi_stg2_f_incdec,\n   output reg                   pi_stg2_load,\n   output reg [5:0]             pi_stg2_reg_l,\n   output [DQS_CNT_WIDTH:0]     pi_stg2_rdlvl_cnt,\n   \n   \n   output                       idelay_ce,\n   output                       idelay_inc,\n   input                        idelay_ld,\n   input [DQS_CNT_WIDTH:0]      wrcal_cnt,\n   \n   output reg [5*RANKS*DQ_WIDTH-1:0] dlyval_dq,\n   \n   output reg                     rdlvl_pi_incdec,\n   \n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_first_edge_cnt,\n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_second_edge_cnt,\n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_tap_cnt,\n   output [5*DQS_WIDTH*RANKS-1:0] dbg_dq_idelay_tap_cnt,\n\n   input                        dbg_idel_up_all,\n   input                        dbg_idel_down_all,\n   input                        dbg_idel_up_cpt,\n   input                        dbg_idel_down_cpt,\n   input [DQS_CNT_WIDTH-1:0]    dbg_sel_idel_cpt,\n   input                        dbg_sel_all_idel_cpt,\n   output [255:0]               dbg_phy_rdlvl\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  localparam MIN_EYE_SIZE = 16;\n\n  \n  localparam CAL_PAT_LEN = 8;\n  \n  localparam RD_SHIFT_LEN = CAL_PAT_LEN / (2*nCK_PER_CLK);\n\n  \n  \n  \n  localparam RD_SHIFT_COMP_DELAY = 5;\n\n  \n  \n  \n  \n  localparam SR_VALID_DELAY = (2 * RD_SHIFT_LEN) + RD_SHIFT_COMP_DELAY + 1;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  localparam PIPE_WAIT_CNT = (nCK_PER_CLK == 2) ? 31 : (SR_VALID_DELAY < 8) ? 16\n                                                     : (SR_VALID_DELAY + 8);\n\n  \n  \n  \n  \n  \n  localparam [11:0] DETECT_EDGE_SAMPLE_CNT0 = 12'h001; \n  localparam [11:0] DETECT_EDGE_SAMPLE_CNT1 = 12'h001;   \n\n  localparam [5:0] CAL1_IDLE                 = 6'h00;\n  localparam [5:0] CAL1_NEW_DQS_WAIT         = 6'h01;\n  localparam [5:0] CAL1_STORE_FIRST_WAIT     = 6'h02;\n  localparam [5:0] CAL1_PAT_DETECT           = 6'h03;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_INC      = 6'h04;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_INC_WAIT = 6'h05;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_DEC      = 6'h06;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_DEC_WAIT = 6'h07;\n  localparam [5:0] CAL1_DETECT_EDGE          = 6'h08;\n  localparam [5:0] CAL1_IDEL_INC_CPT         = 6'h09;\n  localparam [5:0] CAL1_IDEL_INC_CPT_WAIT    = 6'h0A;\n  localparam [5:0] CAL1_CALC_IDEL            = 6'h0B;\n  localparam [5:0] CAL1_IDEL_DEC_CPT         = 6'h0C;\n  localparam [5:0] CAL1_IDEL_DEC_CPT_WAIT    = 6'h0D;\n  localparam [5:0] CAL1_NEXT_DQS             = 6'h0E;\n  localparam [5:0] CAL1_DONE                 = 6'h0F;\n  localparam [5:0] CAL1_PB_STORE_FIRST_WAIT  = 6'h10;\n  localparam [5:0] CAL1_PB_DETECT_EDGE       = 6'h11;\n  localparam [5:0] CAL1_PB_INC_CPT           = 6'h12;\n  localparam [5:0] CAL1_PB_INC_CPT_WAIT      = 6'h13;\n  localparam [5:0] CAL1_PB_DEC_CPT_LEFT      = 6'h14;\n  localparam [5:0] CAL1_PB_DEC_CPT_LEFT_WAIT = 6'h15;\n  localparam [5:0] CAL1_PB_DETECT_EDGE_DQ    = 6'h16;\n  localparam [5:0] CAL1_PB_INC_DQ            = 6'h17;\n  localparam [5:0] CAL1_PB_INC_DQ_WAIT       = 6'h18;\n  localparam [5:0] CAL1_PB_DEC_CPT           = 6'h19;\n  localparam [5:0] CAL1_PB_DEC_CPT_WAIT      = 6'h1A;\n  localparam [5:0] CAL1_REGL_LOAD            = 6'h1B;\n  localparam [5:0] CAL1_RDLVL_ERR            = 6'h1C;\n  localparam [5:0] CAL1_MPR_NEW_DQS_WAIT     = 6'h1D;\n  localparam [5:0] CAL1_VALID_WAIT           = 6'h1E;\n  localparam [5:0] CAL1_MPR_PAT_DETECT       = 6'h1F;\n  localparam [5:0] CAL1_NEW_DQS_PREWAIT      = 6'h20;\n  localparam [5:0] CAL1_RD_STOP_FOR_PI_INC   = 6'h21;\n  localparam [5:0] CAL1_CENTER_WAIT          = 6'h22;\n\n  integer    a;\n  integer    b;\n  integer    d;\n  integer    e;\n  integer    f;\n  integer    h;\n  integer    g;\n  integer    i;\n  integer    j;\n  integer    k;\n  integer    l;\n  integer    m;\n  integer    n;\n  integer    r;\n  integer    p;\n  integer    q;\n  integer    s;\n  integer    t;\n  integer    u;\n  integer    w;\n  integer    ce_i;\n  integer    ce_rnk_i;\n  integer    aa;\n  integer    bb;\n  integer    cc;\n  integer    dd;\n  genvar     x;\n  genvar     z;\n\n  reg [DQS_CNT_WIDTH:0]   cal1_cnt_cpt_r;\n  wire [DQS_CNT_WIDTH+2:0]cal1_cnt_cpt_timing;\n  reg [DQS_CNT_WIDTH:0]   cal1_cnt_cpt_timing_r;\n  reg                     cal1_dq_idel_ce;\n  reg                     cal1_dq_idel_inc;\n  reg                     cal1_dlyce_cpt_r;\n  reg                     cal1_dlyinc_cpt_r;\n  reg                     cal1_dlyce_dq_r;\n  reg                     cal1_dlyinc_dq_r;\n  reg                     cal1_wait_cnt_en_r;\n  reg [4:0]               cal1_wait_cnt_r;\n  reg                     cal1_wait_r;\n  reg [DQ_WIDTH-1:0]      dlyce_dq_r;\n  reg                     dlyinc_dq_r;\n  reg [4:0]               dlyval_dq_reg_r [0:RANKS-1][0:DQ_WIDTH-1];\n  reg                     cal1_prech_req_r;\n  reg [5:0]               cal1_state_r;\n  reg [5:0]               cal1_state_r1;\n  reg [5:0]               cal1_state_r2;\n  reg [5:0]               cal1_state_r3;\n  reg [5:0]               cnt_idel_dec_cpt_r;\n  reg [3:0]               cnt_shift_r;\n  reg                     detect_edge_done_r;\n  reg [5:0]               right_edge_taps_r;\n  reg [5:0]               first_edge_taps_r;\n  reg                     found_edge_r;\n  reg                     found_first_edge_r;\n  reg                     found_second_edge_r;\n  reg                     found_stable_eye_r;\n  reg                     found_stable_eye_last_r;\n  reg                     found_edge_all_r;\n  reg [5:0]               tap_cnt_cpt_r;\n  reg                     tap_limit_cpt_r;\n  reg [4:0]               idel_tap_cnt_dq_pb_r;\n  reg                     idel_tap_limit_dq_pb_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall0_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall1_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise0_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise1_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall2_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall3_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise2_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise3_r;\n  reg                     mux_rd_valid_r;\n  reg                     new_cnt_cpt_r;\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise3_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall3_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise3_r;\n  reg [4:0]               pb_cnt_eye_size_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    pb_detect_edge_done_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_edge_last_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_edge_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_first_edge_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_stable_eye_r;\n  reg [DRAM_WIDTH-1:0]    pb_last_tap_jitter_r;\n  reg             pi_en_stg2_f_timing;\n  reg             pi_stg2_f_incdec_timing;\n  reg             pi_stg2_load_timing;\n  reg [5:0]           pi_stg2_reg_l_timing;\n  reg [DRAM_WIDTH-1:0]    prev_sr_diff_r;\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise3_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_cyc2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall3_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise3_r;\n  wire [DQ_WIDTH-1:0]     rd_data_rise0;\n  wire [DQ_WIDTH-1:0]     rd_data_fall0;\n  wire [DQ_WIDTH-1:0]     rd_data_rise1;\n  wire [DQ_WIDTH-1:0]     rd_data_fall1;\n  wire [DQ_WIDTH-1:0]     rd_data_rise2;\n  wire [DQ_WIDTH-1:0]     rd_data_fall2;\n  wire [DQ_WIDTH-1:0]     rd_data_rise3;\n  wire [DQ_WIDTH-1:0]     rd_data_fall3;\n  reg                     samp_cnt_done_r;\n  reg                     samp_edge_cnt0_en_r;\n  reg [11:0]              samp_edge_cnt0_r;\n  reg                     samp_edge_cnt1_en_r;\n  reg [11:0]              samp_edge_cnt1_r;\n  reg [DQS_CNT_WIDTH:0]   rd_mux_sel_r;\n  reg [5:0]               second_edge_taps_r;\n  reg [RD_SHIFT_LEN-1:0]  sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise3_r [DRAM_WIDTH-1:0];\n  reg                     store_sr_r;\n  reg                     store_sr_req_pulsed_r;\n  reg                     store_sr_req_r;\n  reg                     sr_valid_r;\n  reg                     sr_valid_r1;\n  reg                     sr_valid_r2;\n  reg [DRAM_WIDTH-1:0]    old_sr_diff_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_cyc2_r;\n  reg                     pat0_data_match_r;\n  reg                     pat1_data_match_r;\n  wire                    pat_data_match_r;\n  wire [RD_SHIFT_LEN-1:0] pat0_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall3 [3:0];\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall0_r;\n  reg                     pat0_match_fall0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall1_r;\n  reg                     pat0_match_fall1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall2_r;\n  reg                     pat0_match_fall2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall3_r;\n  reg                     pat0_match_fall3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise0_r;\n  reg                     pat0_match_rise0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise1_r;\n  reg                     pat0_match_rise1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise2_r;\n  reg                     pat0_match_rise2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise3_r;\n  reg                     pat0_match_rise3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall0_r;\n  reg                     pat1_match_fall0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall1_r;\n  reg                     pat1_match_fall1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall2_r;\n  reg                     pat1_match_fall2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall3_r;\n  reg                     pat1_match_fall3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise0_r;\n  reg                     pat1_match_rise0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise1_r;\n  reg                     pat1_match_rise1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise2_r;\n  reg                     pat1_match_rise2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise3_r;\n  reg                     pat1_match_rise3_and_r;\n  reg [4:0]               idelay_tap_cnt_r [0:RANKS-1][0:DQS_WIDTH-1];\n  reg [5*DQS_WIDTH*RANKS-1:0] idelay_tap_cnt_w;\n  reg [4:0]               idelay_tap_cnt_slice_r;\n  reg                     idelay_tap_limit_r;\n\n  wire [RD_SHIFT_LEN-1:0] pat0_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise3 [3:0];\n\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall3 [3:0];\n\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise3_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall3_r;\n\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise3_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall3_r;\n\n  reg                     idel_pat0_match_rise0_and_r;\n  reg                     idel_pat0_match_fall0_and_r;\n  reg                     idel_pat0_match_rise1_and_r;\n  reg                     idel_pat0_match_fall1_and_r;\n  reg                     idel_pat0_match_rise2_and_r;\n  reg                     idel_pat0_match_fall2_and_r;\n  reg                     idel_pat0_match_rise3_and_r;\n  reg                     idel_pat0_match_fall3_and_r;\n\n  reg                     idel_pat1_match_rise0_and_r;\n  reg                     idel_pat1_match_fall0_and_r;\n  reg                     idel_pat1_match_rise1_and_r;\n  reg                     idel_pat1_match_fall1_and_r;\n  reg                     idel_pat1_match_rise2_and_r;\n  reg                     idel_pat1_match_fall2_and_r;\n  reg                     idel_pat1_match_rise3_and_r;\n  reg                     idel_pat1_match_fall3_and_r;\n\n  reg                     idel_pat0_data_match_r;\n  reg                     idel_pat1_data_match_r;\n\n  reg                     idel_pat_data_match;\n  reg                     idel_pat_data_match_r;\n\n  reg [4:0]               idel_dec_cnt;\n\n  reg [5:0]               rdlvl_dqs_tap_cnt_r [0:RANKS-1][0:DQS_WIDTH-1];\n  reg [1:0]               rnk_cnt_r;\n  reg                     rdlvl_rank_done_r;\n\n  reg [3:0]               done_cnt;\n  reg [1:0]               regl_rank_cnt;\n  reg [DQS_CNT_WIDTH:0]   regl_dqs_cnt;\n  reg [DQS_CNT_WIDTH:0]   regl_dqs_cnt_r;\n  wire [DQS_CNT_WIDTH+2:0]regl_dqs_cnt_timing;\n  reg                     regl_rank_done_r;\n  reg                     rdlvl_stg1_start_r;\n\n  reg                     dqs_po_dec_done_r1;\n  reg                     dqs_po_dec_done_r2;\n  reg                     fine_dly_dec_done_r1;\n  reg                     fine_dly_dec_done_r2;\n  reg                     fine_dly_dec_done_r3;\n  reg                     fine_dly_dec_done_r4;\n  reg [3:0]               wait_cnt_r;\n  reg [5:0]               pi_rdval_cnt;\n  reg                     pi_cnt_dec;\n\n  reg                     mpr_valid_r;\n  reg                     mpr_valid_r1;\n  reg                     mpr_valid_r2;\n  reg                     mpr_rd_rise0_prev_r;\n  reg                     mpr_rd_fall0_prev_r;\n  reg                     mpr_rd_rise1_prev_r;\n  reg                     mpr_rd_fall1_prev_r;\n  reg                     mpr_rd_rise2_prev_r;\n  reg                     mpr_rd_fall2_prev_r;\n  reg                     mpr_rd_rise3_prev_r;\n  reg                     mpr_rd_fall3_prev_r;\n  reg                     mpr_rdlvl_done_r;\n  reg                     mpr_rdlvl_done_r1;\n  reg                     mpr_rdlvl_done_r2;\n  reg                     mpr_rdlvl_start_r;\n  reg                     mpr_rank_done_r;\n  reg [2:0]               stable_idel_cnt;\n  reg                     inhibit_edge_detect_r;\n  reg                     idel_pat_detect_valid_r;\n  reg                     idel_mpr_pat_detect_r;\n  reg                     mpr_pat_detect_r;\n  reg                     mpr_dec_cpt_r;\n  reg                     idel_adj_inc;   \n  wire [1:0]              idelay_adj;\n  wire                    pb_detect_edge_setup;\n  wire                    pb_detect_edge;\n  \n  reg [6*DQS_WIDTH-1:0] dbg_cpt_first_edge_taps;\n  reg [6*DQS_WIDTH-1:0] dbg_cpt_second_edge_taps;\n  reg [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_tap_cnt_w;\n  reg rdlvl_stg1_done_int;\n  reg rdlvl_stg1_done_int_r1, rdlvl_stg1_done_int_r2, rdlvl_stg1_done_int_r3;\n  reg rdlvl_last_byte_done_int;\n  reg rdlvl_last_byte_done_int_r1, rdlvl_last_byte_done_int_r2, rdlvl_last_byte_done_int_r3;\n\n\n  \n  \n  \n  \n  assign idelay_adj = (IDELAY_ADJ == \"ON\") ? 2'b10: 2'b00;\n\n  \n  \n  \n\n  always @(*) begin\n    for (d = 0; d < RANKS; d = d + 1) begin\n      for (e = 0; e < DQS_WIDTH; e = e + 1) begin\n        idelay_tap_cnt_w[(5*e+5*DQS_WIDTH*d)+:5] = idelay_tap_cnt_r[d][e];\n        dbg_cpt_tap_cnt_w[(6*e+6*DQS_WIDTH*d)+:6] = rdlvl_dqs_tap_cnt_r[d][e];\n      end\n    end\n  end\n\n  assign mpr_rdlvl_err         = rdlvl_stg1_err & (!mpr_rdlvl_done);\n  assign rdlvl_err              = rdlvl_stg1_err & (mpr_rdlvl_done);\n\n\n  assign dbg_phy_rdlvl[0]      = rdlvl_stg1_start;\n  assign dbg_phy_rdlvl[1]      = pat_data_match_r;\n  assign dbg_phy_rdlvl[2]      = mux_rd_valid_r;\n  assign dbg_phy_rdlvl[3]      = idelay_tap_limit_r;\n  assign dbg_phy_rdlvl[8:4]    = 'b0;\n  assign dbg_phy_rdlvl[14:9]   = cal1_state_r[5:0];\n  assign dbg_phy_rdlvl[20:15]  = cnt_idel_dec_cpt_r;\n  assign dbg_phy_rdlvl[21]     = found_first_edge_r;\n  assign dbg_phy_rdlvl[22]     = found_second_edge_r;\n  assign dbg_phy_rdlvl[23]     = found_edge_r;\n  assign dbg_phy_rdlvl[24]     = store_sr_r;\n  \n  \n  assign dbg_phy_rdlvl[40:25]  = 'b0;\n  assign dbg_phy_rdlvl[41]     = sr_valid_r;\n  assign dbg_phy_rdlvl[42]     = found_stable_eye_r;\n  assign dbg_phy_rdlvl[48:43]  = tap_cnt_cpt_r;\n  assign dbg_phy_rdlvl[54:49]  = first_edge_taps_r;\n  assign dbg_phy_rdlvl[60:55]  = second_edge_taps_r;\n  assign dbg_phy_rdlvl[64:61]  = cal1_cnt_cpt_timing_r;\n  assign dbg_phy_rdlvl[65]     = cal1_dlyce_cpt_r;\n  assign dbg_phy_rdlvl[66]     = cal1_dlyinc_cpt_r;\n  assign dbg_phy_rdlvl[67]     = found_edge_r;\n  assign dbg_phy_rdlvl[68]     = found_first_edge_r;\n  assign dbg_phy_rdlvl[73:69]  = 'b0;\n  assign dbg_phy_rdlvl[74]     = idel_pat_data_match;\n  assign dbg_phy_rdlvl[75]     = idel_pat0_data_match_r;\n  assign dbg_phy_rdlvl[76]     = idel_pat1_data_match_r;\n  assign dbg_phy_rdlvl[77]     = pat0_data_match_r;\n  assign dbg_phy_rdlvl[78]     = pat1_data_match_r;\n  assign dbg_phy_rdlvl[79+:5*DQS_WIDTH*RANKS] = idelay_tap_cnt_w;\n  assign dbg_phy_rdlvl[170+:8] = mux_rd_rise0_r;\n  assign dbg_phy_rdlvl[178+:8] = mux_rd_fall0_r;\n  assign dbg_phy_rdlvl[186+:8] = mux_rd_rise1_r;\n  assign dbg_phy_rdlvl[194+:8] = mux_rd_fall1_r;\n  assign dbg_phy_rdlvl[202+:8] = mux_rd_rise2_r;\n  assign dbg_phy_rdlvl[210+:8] = mux_rd_fall2_r;\n  assign dbg_phy_rdlvl[218+:8] = mux_rd_rise3_r;\n  assign dbg_phy_rdlvl[226+:8] = mux_rd_fall3_r;\n\n  \n  \n  \n\n  \n  assign dbg_cpt_first_edge_cnt  = dbg_cpt_first_edge_taps;\n  assign dbg_cpt_second_edge_cnt = dbg_cpt_second_edge_taps;\n  assign dbg_cpt_tap_cnt         = dbg_cpt_tap_cnt_w;\n  assign dbg_dq_idelay_tap_cnt   = idelay_tap_cnt_w;\n\n  \n\n  generate\n    always @(posedge clk)\n      if (rst || (rdlvl_stg1_start && ~rdlvl_stg1_start_r)) begin\n        dbg_cpt_first_edge_taps  <= #TCQ 'b0;\n        dbg_cpt_second_edge_taps <= #TCQ 'b0;\n      end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (cal1_state_r1 == CAL1_CALC_IDEL)) begin\n        \n          for (ce_i = 0; ce_i < DQS_WIDTH; ce_i = ce_i + 1) begin: gen_dbg_cpt_edge\n            if (found_first_edge_r)\n              dbg_cpt_first_edge_taps[(6*ce_i)+:6]\n                  <= #TCQ first_edge_taps_r;\n            if (found_second_edge_r)\n              dbg_cpt_second_edge_taps[(6*ce_i)+:6]\n                  <= #TCQ second_edge_taps_r;\n          end\n        \n      end else if (cal1_state_r == CAL1_CALC_IDEL) begin\n        \n        \n        \n          if (found_first_edge_r)\n            dbg_cpt_first_edge_taps[((cal1_cnt_cpt_timing <<2) + (cal1_cnt_cpt_timing <<1))+:6]\n              <= #TCQ first_edge_taps_r;\n          if (found_second_edge_r)\n            dbg_cpt_second_edge_taps[((cal1_cnt_cpt_timing <<2) + (cal1_cnt_cpt_timing <<1))+:6]\n              <= #TCQ second_edge_taps_r;\n      end\n  endgenerate\n\n  assign rdlvl_stg1_rnk_done = rdlvl_rank_done_r;\n  assign mpr_rnk_done        = mpr_rank_done_r;\n  assign mpr_rdlvl_done      = ((DRAM_TYPE == \"DDR3\") && (OCAL_EN == \"ON\")) ? \n                                mpr_rdlvl_done_r : 1'b1;\n\n   \n   \n   \n   \n   assign pi_stg2_rdlvl_cnt = (((PI_DIV2_INCDEC == \"TRUE\") && (cal1_state_r3 == CAL1_REGL_LOAD)) || ((PI_DIV2_INCDEC == \"FALSE\") && (cal1_state_r == CAL1_REGL_LOAD))) ? regl_dqs_cnt_r : cal1_cnt_cpt_r;\n   assign rdlvl_stg1_done   = (PI_DIV2_INCDEC == \"TRUE\") ? rdlvl_stg1_done_int_r3 : rdlvl_stg1_done_int;\n   assign rdlvl_last_byte_done = (PI_DIV2_INCDEC == \"TRUE\") ? rdlvl_last_byte_done_int_r3 : rdlvl_last_byte_done_int;\n\n   always @ (posedge clk) begin\n     rdlvl_stg1_done_int_r1 <= #TCQ rdlvl_stg1_done_int;\n     rdlvl_stg1_done_int_r2 <= #TCQ rdlvl_stg1_done_int_r1;\n     rdlvl_stg1_done_int_r3 <= #TCQ rdlvl_stg1_done_int_r2;\n     rdlvl_last_byte_done_int_r1 <= #TCQ rdlvl_last_byte_done_int;\n     rdlvl_last_byte_done_int_r2 <= #TCQ rdlvl_last_byte_done_int_r1;\n     rdlvl_last_byte_done_int_r3 <= #TCQ rdlvl_last_byte_done_int_r2;\n   end\n\n   assign idelay_ce  = cal1_dq_idel_ce;\n   assign idelay_inc = cal1_dq_idel_inc;\n\n  \n  \n  \n  \n\n  always @(posedge clk) begin\n    if (rst)\n      rdlvl_assrt_common <= #TCQ 1'b0;\n    else if ((SIM_CAL_OPTION == \"FAST_CAL\") & rdlvl_stg1_start &\n            !rdlvl_stg1_start_r)\n      rdlvl_assrt_common <= #TCQ 1'b1;\n    else if (!idel_pat_data_match_r & idel_pat_data_match)\n      rdlvl_assrt_common <= #TCQ 1'b0;\n  end\n\n  \n  \n  \n  \n\n  generate\n    if (nCK_PER_CLK == 4) begin: rd_data_div4_logic_clk\n      assign rd_data_rise0 = rd_data[DQ_WIDTH-1:0];\n      assign rd_data_fall0 = rd_data[2*DQ_WIDTH-1:DQ_WIDTH];\n      assign rd_data_rise1 = rd_data[3*DQ_WIDTH-1:2*DQ_WIDTH];\n      assign rd_data_fall1 = rd_data[4*DQ_WIDTH-1:3*DQ_WIDTH];\n      assign rd_data_rise2 = rd_data[5*DQ_WIDTH-1:4*DQ_WIDTH];\n      assign rd_data_fall2 = rd_data[6*DQ_WIDTH-1:5*DQ_WIDTH];\n      assign rd_data_rise3 = rd_data[7*DQ_WIDTH-1:6*DQ_WIDTH];\n      assign rd_data_fall3 = rd_data[8*DQ_WIDTH-1:7*DQ_WIDTH];\n    end else begin: rd_data_div2_logic_clk\n      assign rd_data_rise0 = rd_data[DQ_WIDTH-1:0];\n      assign rd_data_fall0 = rd_data[2*DQ_WIDTH-1:DQ_WIDTH];\n      assign rd_data_rise1 = rd_data[3*DQ_WIDTH-1:2*DQ_WIDTH];\n      assign rd_data_fall1 = rd_data[4*DQ_WIDTH-1:3*DQ_WIDTH];\n    end\n  endgenerate\n\n  always @(posedge clk) begin\n    rd_mux_sel_r <= #TCQ cal1_cnt_cpt_r;\n  end\n\n  \n  \n  \n  generate\n    genvar mux_i;\n    for (mux_i = 0; mux_i < DRAM_WIDTH; mux_i = mux_i + 1) begin: gen_mux_rd\n      always @(posedge clk) begin\n        mux_rd_rise0_r[mux_i] <= #TCQ rd_data_rise0[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall0_r[mux_i] <= #TCQ rd_data_fall0[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise1_r[mux_i] <= #TCQ rd_data_rise1[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall1_r[mux_i] <= #TCQ rd_data_fall1[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise2_r[mux_i] <= #TCQ rd_data_rise2[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall2_r[mux_i] <= #TCQ rd_data_fall2[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise3_r[mux_i] <= #TCQ rd_data_rise3[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall3_r[mux_i] <= #TCQ rd_data_fall3[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n  \n  \n   always @(posedge clk)begin\n     if ((cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) ||\n        ((cal1_state_r == CAL1_MPR_PAT_DETECT) && (idel_pat_detect_valid_r)))begin\n       mpr_rd_rise0_prev_r <= #TCQ mux_rd_rise0_r[0];\n       mpr_rd_fall0_prev_r <= #TCQ mux_rd_fall0_r[0];\n       mpr_rd_rise1_prev_r <= #TCQ mux_rd_rise1_r[0];\n       mpr_rd_fall1_prev_r <= #TCQ mux_rd_fall1_r[0];\n       mpr_rd_rise2_prev_r <= #TCQ mux_rd_rise2_r[0];\n       mpr_rd_fall2_prev_r <= #TCQ mux_rd_fall2_r[0];\n       mpr_rd_rise3_prev_r <= #TCQ mux_rd_rise3_r[0];\n       mpr_rd_fall3_prev_r <= #TCQ mux_rd_fall3_r[0];\n     end\n   end\n\n   generate\n    if (nCK_PER_CLK == 4) begin: mpr_4to1\n   \n   always @(posedge clk) begin\n      if (rst | (cal1_state_r == CAL1_NEW_DQS_PREWAIT) |\n         \n         (mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) |\n         (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) |\n         (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) |\n         (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]) |\n         (mpr_rd_rise2_prev_r != mux_rd_rise2_r[0]) |\n         (mpr_rd_fall2_prev_r != mux_rd_fall2_r[0]) |\n         (mpr_rd_rise3_prev_r != mux_rd_rise3_r[0]) |\n         (mpr_rd_fall3_prev_r != mux_rd_fall3_r[0]))\n        stable_idel_cnt <= #TCQ 3'd0;\n      else if ((|idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing]) &\n               ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n               (idel_pat_detect_valid_r))) begin\n        if ((mpr_rd_rise0_prev_r == mux_rd_rise0_r[0]) &\n            (mpr_rd_fall0_prev_r == mux_rd_fall0_r[0]) &\n            (mpr_rd_rise1_prev_r == mux_rd_rise1_r[0]) &\n            (mpr_rd_fall1_prev_r == mux_rd_fall1_r[0]) &\n            (mpr_rd_rise2_prev_r == mux_rd_rise2_r[0]) &\n            (mpr_rd_fall2_prev_r == mux_rd_fall2_r[0]) &\n            (mpr_rd_rise3_prev_r == mux_rd_rise3_r[0]) &\n            (mpr_rd_fall3_prev_r == mux_rd_fall3_r[0]) &\n            (stable_idel_cnt < 3'd2))\n          stable_idel_cnt <= #TCQ stable_idel_cnt + 1;\n      end\n   end\n\n   always @(posedge clk) begin\n     if (rst |\n         (mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n          mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r &\n          mpr_rd_rise2_prev_r & ~mpr_rd_fall2_prev_r &\n          mpr_rd_rise3_prev_r & ~mpr_rd_fall3_prev_r))\n       inhibit_edge_detect_r <= 1'b1;\n     \n     \n     else if ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n              (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd1) &\n              (~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n               ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r &\n               ~mpr_rd_rise2_prev_r & mpr_rd_fall2_prev_r &\n               ~mpr_rd_rise3_prev_r & mpr_rd_fall3_prev_r))\n       inhibit_edge_detect_r <= 1'b0;\n   end\n\n   \n   always @(posedge clk)begin\n     if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n         inhibit_edge_detect_r)\n       idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n     \n     else if ((mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n               mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r &\n               mpr_rd_rise2_prev_r & ~mpr_rd_fall2_prev_r &\n               mpr_rd_rise3_prev_r & ~mpr_rd_fall3_prev_r) ||\n              ((stable_idel_cnt < 3'd2) & (cal1_state_r == CAL1_MPR_PAT_DETECT)\n               && (idel_pat_detect_valid_r)))\n              \n       idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n     \n     else if ((~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n               ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r &\n               ~mpr_rd_rise2_prev_r & mpr_rd_fall2_prev_r &\n               ~mpr_rd_rise3_prev_r & mpr_rd_fall3_prev_r) &\n               (stable_idel_cnt == 3'd2) &\n               ((mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) ||\n                (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) ||\n                (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) ||\n                (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]) ||\n                (mpr_rd_rise2_prev_r != mux_rd_rise2_r[0]) ||\n                (mpr_rd_fall2_prev_r != mux_rd_fall2_r[0]) ||\n                (mpr_rd_rise3_prev_r != mux_rd_rise3_r[0]) ||\n                (mpr_rd_fall3_prev_r != mux_rd_fall3_r[0])))\n       idel_mpr_pat_detect_r     <= #TCQ 1'b1;\n   end\n    end else if (nCK_PER_CLK == 2) begin: mpr_2to1\n      \n      always @(posedge clk) begin\n         if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n            (mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) |\n            (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) |\n            (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) |\n            (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]))\n           stable_idel_cnt <= #TCQ 3'd0;\n         else if ((idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd0) &\n                  ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n                  (idel_pat_detect_valid_r))) begin\n           if ((mpr_rd_rise0_prev_r == mux_rd_rise0_r[0]) &\n               (mpr_rd_fall0_prev_r == mux_rd_fall0_r[0]) &\n               (mpr_rd_rise1_prev_r == mux_rd_rise1_r[0]) &\n               (mpr_rd_fall1_prev_r == mux_rd_fall1_r[0]) &\n               (stable_idel_cnt < 3'd2))\n             stable_idel_cnt <= #TCQ stable_idel_cnt + 1;\n         end\n      end\n\n      always @(posedge clk) begin\n        if (rst |\n            (mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n             mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r))\n          inhibit_edge_detect_r <= 1'b1;\n        else if ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n                 (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd1) &\n                 (~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n                  ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r))\n          inhibit_edge_detect_r <= 1'b0;\n      end\n\n      \n      always @(posedge clk)begin\n        if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n            inhibit_edge_detect_r)\n          idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n        \n        else if ((mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n                  mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r) ||\n                 ((stable_idel_cnt < 3'd2) & (cal1_state_r == CAL1_MPR_PAT_DETECT)\n                 & (idel_pat_detect_valid_r)))\n                 \n          idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n        \n        else if ((~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n                  ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r) &\n                  (stable_idel_cnt == 3'd2) &\n                  ((mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) ||\n                   (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) ||\n                   (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) ||\n                   (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0])))\n          idel_mpr_pat_detect_r     <= #TCQ 1'b1;\n      end\n    end\n  endgenerate\n\n\n\n  \n  always @(posedge clk)\n    mux_rd_valid_r <= #TCQ ~phy_if_empty;\n\n\n  \n  \n  \n  \n\n     always @(posedge clk) begin\n       dqs_po_dec_done_r1 <= #TCQ dqs_po_dec_done;\n       dqs_po_dec_done_r2 <= #TCQ dqs_po_dec_done_r1;\n       fine_dly_dec_done_r2 <= #TCQ fine_dly_dec_done_r1;\n       fine_dly_dec_done_r3 <= #TCQ fine_dly_dec_done_r2;\n       fine_dly_dec_done_r4 <= #TCQ fine_dly_dec_done_r3;\n       if (PI_DIV2_INCDEC == \"TRUE\")\n         pi_fine_dly_dec_done <= #TCQ fine_dly_dec_done_r4;\n       else\n       pi_fine_dly_dec_done <= #TCQ fine_dly_dec_done_r2;\n     end\n\n     always @(posedge clk) begin\n       if (rst || pi_cnt_dec)\n         wait_cnt_r <= #TCQ 'd8;\n       else if (dqs_po_dec_done_r2 && (wait_cnt_r > 'd0))\n         wait_cnt_r <= #TCQ wait_cnt_r - 1;\n     end\n\n     always @(posedge clk) begin\n     if (rst) begin\n       pi_rdval_cnt    <= #TCQ 'd0;\n     end else if (dqs_po_dec_done_r1 && ~dqs_po_dec_done_r2) begin\n       pi_rdval_cnt    <= #TCQ pi_counter_read_val;\n     end else if (pi_rdval_cnt > 'd0) begin\n       if (pi_cnt_dec)\n         pi_rdval_cnt  <= #TCQ pi_rdval_cnt - 1;\n       else\n         pi_rdval_cnt  <= #TCQ pi_rdval_cnt;\n     end else if (pi_rdval_cnt == 'd0) begin\n       pi_rdval_cnt    <= #TCQ pi_rdval_cnt;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (pi_rdval_cnt == 'd0))\n       pi_cnt_dec      <= #TCQ 1'b0;\n     else if (dqs_po_dec_done_r2 && (pi_rdval_cnt > 'd0)\n                  && (wait_cnt_r == 'd1))\n       pi_cnt_dec      <= #TCQ 1'b1;\n     else\n       pi_cnt_dec      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst) begin\n       fine_dly_dec_done_r1 <= #TCQ 1'b0;\n     end else if (((pi_cnt_dec == 'd1) && (pi_rdval_cnt == 'd1)) ||\n                  (dqs_po_dec_done_r2 && (pi_rdval_cnt == 'd0))) begin\n       fine_dly_dec_done_r1 <= #TCQ 1'b1;\n     end\n   end\n\n  \n  \n  \n\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      pi_en_stg2_f_timing     <= #TCQ 'b0;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end else if (pi_cnt_dec) begin\n      pi_en_stg2_f_timing     <= #TCQ 'b1;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end else if (cal1_dlyce_cpt_r) begin\n      if ((SIM_CAL_OPTION == \"NONE\") ||\n          (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n        \n        pi_en_stg2_f_timing     <= #TCQ 1'b1;\n        pi_stg2_f_incdec_timing <= #TCQ cal1_dlyinc_cpt_r;\n      end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n        \n        \n        \n        pi_en_stg2_f_timing     <= #TCQ 1'b1;\n        pi_stg2_f_incdec_timing <= #TCQ cal1_dlyinc_cpt_r;\n      end\n    end else begin\n      pi_en_stg2_f_timing     <= #TCQ 'b0;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end\n  end\n\n  \n  always @(posedge clk) begin\n    pi_en_stg2_f     <= #TCQ pi_en_stg2_f_timing;\n    pi_stg2_f_incdec <= #TCQ pi_stg2_f_incdec_timing;\n  end\n\n   \n   \n   always @(posedge clk) begin\n     if (rst)\n       done_cnt <= #TCQ 'b0;\n     else if (((cal1_state_r == CAL1_REGL_LOAD) &&\n               (cal1_state_r1 == CAL1_NEXT_DQS)) ||\n              ((done_cnt == 4'd1) && (cal1_state_r != CAL1_DONE)))\n       done_cnt <= #TCQ 4'b1010;\n     else if (done_cnt > 'b0)\n       done_cnt <= #TCQ done_cnt - 1;\n   end\n\n   \n   \n   \n   \n   always @(posedge clk) begin\n     if (rst || (regl_rank_done_r == 1'b1))\n       regl_rank_done_r <= #TCQ 1'b0;\n     else if ((regl_dqs_cnt == DQS_WIDTH-1) &&\n              (regl_rank_cnt != RANKS-1) &&\n              (done_cnt == 4'd1))\n       regl_rank_done_r <= #TCQ 1'b1;\n   end\n\n   \n   \n   \n   \n   \n   \n   assign regl_dqs_cnt_timing = {2'd0, regl_dqs_cnt};\n\n   \n   \n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0)) begin\n       pi_stg2_load_timing    <= #TCQ 'b0;\n       pi_stg2_reg_l_timing   <= #TCQ 'b0;\n     end else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n                  (regl_dqs_cnt <= DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       pi_stg2_load_timing  <= #TCQ 'b1;\n       pi_stg2_reg_l_timing <= #TCQ\n         rdlvl_dqs_tap_cnt_r[rnk_cnt_r][regl_dqs_cnt];\n     end else begin\n       pi_stg2_load_timing  <= #TCQ 'b0;\n       pi_stg2_reg_l_timing <= #TCQ 'b0;\n     end\n   end\n\n   \n   always @(posedge clk) begin\n     pi_stg2_load  <= #TCQ pi_stg2_load_timing;\n     pi_stg2_reg_l <= #TCQ pi_stg2_reg_l_timing;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0) ||\n         (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n       regl_rank_cnt   <= #TCQ 2'b00;\n     else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n              (regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       if (regl_rank_cnt == RANKS-1)\n         regl_rank_cnt  <= #TCQ regl_rank_cnt;\n       else\n         regl_rank_cnt <= #TCQ regl_rank_cnt + 1;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0) ||\n         (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n       regl_dqs_cnt    <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n     else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n              (regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       if (regl_rank_cnt == RANKS-1)\n         regl_dqs_cnt  <= #TCQ regl_dqs_cnt;\n       else\n         regl_dqs_cnt  <= #TCQ 'b0;\n     end else if ((cal1_state_r == CAL1_REGL_LOAD) && (regl_dqs_cnt != DQS_WIDTH-1)\n                  && (done_cnt == 4'd1))\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt + 1;\n     else\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt;\n   end\n\n\n   always @(posedge clk)\n     regl_dqs_cnt_r <= #TCQ regl_dqs_cnt;\n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  generate\n    for (z = 0; z < DQS_WIDTH; z = z + 1) begin: gen_dlyce_dq\n      always @(posedge clk)\n        if (rst)\n          dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n        else\n          if (SIM_CAL_OPTION == \"SKIP_CAL\")\n            \n            \n            dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n          else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n            \n            \n            \n            for (h = 0; h < DRAM_WIDTH; h = h + 1) begin\n              dlyce_dq_r[DRAM_WIDTH*z + h] <= #TCQ cal1_dlyce_dq_r;\n            end\n          end else if ((SIM_CAL_OPTION == \"NONE\") ||\n                   (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n            if (cal1_cnt_cpt_r == z) begin\n              for (g = 0; g < DRAM_WIDTH; g = g + 1) begin\n                dlyce_dq_r[DRAM_WIDTH*z + g]\n                <= #TCQ cal1_dlyce_dq_r;\n              end\n            end else\n              dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n          end\n    end\n  endgenerate\n\n  \n  always @(posedge clk)\n    if (rst)\n      dlyinc_dq_r <= #TCQ 1'b0;\n    else\n      dlyinc_dq_r <= #TCQ cal1_dlyinc_dq_r;\n\n\n  \n  \n  always @(posedge clk)\n    \n    if (rst | (SIM_CAL_OPTION == \"SKIP_CAL\")) begin\n      for (aa = 0; aa < RANKS; aa = aa + 1) begin: rst_dlyval_dq_reg_r\n        for (bb = 0; bb < DQ_WIDTH; bb = bb + 1)\n          dlyval_dq_reg_r[aa][bb] <= #TCQ 'b0;\n      end\n    end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n      for (n = 0; n < RANKS; n = n + 1) begin: gen_dlyval_dq_reg_rnk\n        for (r = 0; r < DQ_WIDTH; r = r + 1) begin: gen_dlyval_dq_reg\n          if (dlyce_dq_r[r]) begin\n            if (dlyinc_dq_r)\n              dlyval_dq_reg_r[n][r] <= #TCQ dlyval_dq_reg_r[n][r] + 5'h01;\n            else\n              dlyval_dq_reg_r[n][r] <= #TCQ dlyval_dq_reg_r[n][r] - 5'h01;\n          end\n        end\n      end\n    end else begin\n      if (dlyce_dq_r[cal1_cnt_cpt_r]) begin\n        if (dlyinc_dq_r)\n          dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] <= #TCQ\n            dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] + 5'h01;\n        else\n          dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] <= #TCQ\n            dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] - 5'h01;\n      end\n    end\n\n  \n  always @(posedge clk) begin\n    for (cc = 0; cc < RANKS; cc = cc + 1) begin: dlyval_dq_assgn\n      for (dd = 0; dd < DQ_WIDTH; dd = dd + 1)\n        dlyval_dq[((5*dd)+(cc*DQ_WIDTH*5))+:5] <= #TCQ dlyval_dq_reg_r[cc][dd];\n      end\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  \n    \n  always @(posedge clk)\n    if ((cal1_state_r == CAL1_NEW_DQS_WAIT) ||\n        (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) ||\n        (cal1_state_r == CAL1_NEW_DQS_PREWAIT) ||\n        (cal1_state_r == CAL1_VALID_WAIT) ||\n        (cal1_state_r == CAL1_PB_STORE_FIRST_WAIT) ||\n        (cal1_state_r == CAL1_PB_INC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_PB_DEC_CPT_LEFT_WAIT) ||\n        (cal1_state_r == CAL1_PB_INC_DQ_WAIT) ||\n        (cal1_state_r == CAL1_PB_DEC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_IDEL_INC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_IDEL_DEC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_STORE_FIRST_WAIT) ||\n        (cal1_state_r == CAL1_DQ_IDEL_TAP_INC_WAIT) ||\n        (cal1_state_r == CAL1_DQ_IDEL_TAP_DEC_WAIT) ||\n        (cal1_state_r == CAL1_CENTER_WAIT) ||\n        (cal1_state_r == CAL1_RD_STOP_FOR_PI_INC))\n      cal1_wait_cnt_en_r <= #TCQ 1'b1;\n    else\n      cal1_wait_cnt_en_r <= #TCQ 1'b0;\n\n  always @(posedge clk)\n    if (!cal1_wait_cnt_en_r) begin\n      cal1_wait_cnt_r <= #TCQ 5'b00000;\n      cal1_wait_r     <= #TCQ 1'b1;\n    end else begin\n      if (cal1_wait_cnt_r != PIPE_WAIT_CNT - 1) begin\n        cal1_wait_cnt_r <= #TCQ cal1_wait_cnt_r + 1;\n        cal1_wait_r     <= #TCQ 1'b1;\n      end else begin\n        \n        \n        cal1_wait_cnt_r <= #TCQ 5'b00000;\n        cal1_wait_r     <= #TCQ 1'b0;\n      end\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst)\n      rdlvl_prech_req <= #TCQ 1'b0;\n    else\n      rdlvl_prech_req <= #TCQ cal1_prech_req_r;\n\n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n\n  generate\n    genvar rd_i;\n    if (nCK_PER_CLK == 4) begin: gen_sr_div4\n      if (RD_SHIFT_LEN == 1) begin: gen_sr_len_eq1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ mux_rd_rise0_r[rd_i];\n              sr_fall0_r[rd_i] <= #TCQ mux_rd_fall0_r[rd_i];\n              sr_rise1_r[rd_i] <= #TCQ mux_rd_rise1_r[rd_i];\n              sr_fall1_r[rd_i] <= #TCQ mux_rd_fall1_r[rd_i];\n              sr_rise2_r[rd_i] <= #TCQ mux_rd_rise2_r[rd_i];\n              sr_fall2_r[rd_i] <= #TCQ mux_rd_fall2_r[rd_i];\n              sr_rise3_r[rd_i] <= #TCQ mux_rd_rise3_r[rd_i];\n              sr_fall3_r[rd_i] <= #TCQ mux_rd_fall3_r[rd_i];\n            end\n          end\n        end\n      end else if (RD_SHIFT_LEN > 1) begin: gen_sr_len_gt1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {sr_rise0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {sr_fall0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {sr_rise1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {sr_fall1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall1_r[rd_i]};\n              sr_rise2_r[rd_i] <= #TCQ {sr_rise2_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise2_r[rd_i]};\n              sr_fall2_r[rd_i] <= #TCQ {sr_fall2_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall2_r[rd_i]};\n              sr_rise3_r[rd_i] <= #TCQ {sr_rise3_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise3_r[rd_i]};\n              sr_fall3_r[rd_i] <= #TCQ {sr_fall3_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall3_r[rd_i]};\n            end\n          end\n        end\n      end\n    end else if (nCK_PER_CLK == 2) begin: gen_sr_div2\n      if (RD_SHIFT_LEN == 1) begin: gen_sr_len_eq1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {mux_rd_fall1_r[rd_i]};\n            end\n          end\n        end\n      end else if (RD_SHIFT_LEN > 1) begin: gen_sr_len_gt1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {sr_rise0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {sr_fall0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {sr_rise1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {sr_fall1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall1_r[rd_i]};\n            end\n          end\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  generate\n    if (nCK_PER_CLK == 4) begin: gen_pat_div4\n      \n\n      \n      assign {idel_pat0_rise0[3], idel_pat0_rise0[2],\n              idel_pat0_rise0[1], idel_pat0_rise0[0]} = 4'h1;\n      assign {idel_pat0_fall0[3], idel_pat0_fall0[2],\n              idel_pat0_fall0[1], idel_pat0_fall0[0]} = 4'h7;\n      assign {idel_pat0_rise1[3], idel_pat0_rise1[2],\n              idel_pat0_rise1[1], idel_pat0_rise1[0]} = 4'hE;\n      assign {idel_pat0_fall1[3], idel_pat0_fall1[2],\n              idel_pat0_fall1[1], idel_pat0_fall1[0]} = 4'hC;\n      assign {idel_pat0_rise2[3], idel_pat0_rise2[2],\n              idel_pat0_rise2[1], idel_pat0_rise2[0]} = 4'h9;\n      assign {idel_pat0_fall2[3], idel_pat0_fall2[2],\n              idel_pat0_fall2[1], idel_pat0_fall2[0]} = 4'h2;\n      assign {idel_pat0_rise3[3], idel_pat0_rise3[2],\n              idel_pat0_rise3[1], idel_pat0_rise3[0]} = 4'h4;\n      assign {idel_pat0_fall3[3], idel_pat0_fall3[2],\n              idel_pat0_fall3[1], idel_pat0_fall3[0]} = 4'hB;\n\n      \n      assign {idel_pat1_rise0[3], idel_pat1_rise0[2],\n              idel_pat1_rise0[1], idel_pat1_rise0[0]} = 4'h4;\n      assign {idel_pat1_fall0[3], idel_pat1_fall0[2],\n              idel_pat1_fall0[1], idel_pat1_fall0[0]} = 4'h9;\n      assign {idel_pat1_rise1[3], idel_pat1_rise1[2],\n              idel_pat1_rise1[1], idel_pat1_rise1[0]} = 4'h3;\n      assign {idel_pat1_fall1[3], idel_pat1_fall1[2],\n              idel_pat1_fall1[1], idel_pat1_fall1[0]} = 4'h7;\n      assign {idel_pat1_rise2[3], idel_pat1_rise2[2],\n              idel_pat1_rise2[1], idel_pat1_rise2[0]} = 4'hE;\n      assign {idel_pat1_fall2[3], idel_pat1_fall2[2],\n              idel_pat1_fall2[1], idel_pat1_fall2[0]} = 4'hC;\n      assign {idel_pat1_rise3[3], idel_pat1_rise3[2],\n              idel_pat1_rise3[1], idel_pat1_rise3[0]} = 4'h9;\n      assign {idel_pat1_fall3[3], idel_pat1_fall3[2],\n              idel_pat1_fall3[1], idel_pat1_fall3[0]} = 4'h2;\n\n\n      \n      assign {pat0_rise0[3], pat0_rise0[2],\n              pat0_rise0[1], pat0_rise0[0]} = 4'h7;\n      assign {pat0_fall0[3], pat0_fall0[2],\n              pat0_fall0[1], pat0_fall0[0]} = 4'hE;\n      assign {pat0_rise1[3], pat0_rise1[2],\n              pat0_rise1[1], pat0_rise1[0]} = 4'hC;\n      assign {pat0_fall1[3], pat0_fall1[2],\n              pat0_fall1[1], pat0_fall1[0]} = 4'h9;\n      assign {pat0_rise2[3], pat0_rise2[2],\n              pat0_rise2[1], pat0_rise2[0]} = 4'h2;\n      assign {pat0_fall2[3], pat0_fall2[2],\n              pat0_fall2[1], pat0_fall2[0]} = 4'h4;\n      assign {pat0_rise3[3], pat0_rise3[2],\n              pat0_rise3[1], pat0_rise3[0]} = 4'hB;\n      assign {pat0_fall3[3], pat0_fall3[2],\n              pat0_fall3[1], pat0_fall3[0]} = 4'h1;\n\n      \n      assign {pat1_rise0[3], pat1_rise0[2],\n              pat1_rise0[1], pat1_rise0[0]} = 4'h9;\n      assign {pat1_fall0[3], pat1_fall0[2],\n              pat1_fall0[1], pat1_fall0[0]} = 4'h3;\n      assign {pat1_rise1[3], pat1_rise1[2],\n              pat1_rise1[1], pat1_rise1[0]} = 4'h7;\n      assign {pat1_fall1[3], pat1_fall1[2],\n              pat1_fall1[1], pat1_fall1[0]} = 4'hE;\n      assign {pat1_rise2[3], pat1_rise2[2],\n              pat1_rise2[1], pat1_rise2[0]} = 4'hC;\n      assign {pat1_fall2[3], pat1_fall2[2],\n              pat1_fall2[1], pat1_fall2[0]} = 4'h9;\n      assign {pat1_rise3[3], pat1_rise3[2],\n              pat1_rise3[1], pat1_rise3[0]} = 4'h2;\n      assign {pat1_fall3[3], pat1_fall3[2],\n              pat1_fall3[1], pat1_fall3[0]} = 4'h4;\n\n    end else if (nCK_PER_CLK == 2) begin: gen_pat_div2\n\n            \n\n      \n      assign idel_pat0_rise0[3] = 2'b01;\n      assign idel_pat0_fall0[3] = 2'b00;\n      assign idel_pat0_rise1[3] = 2'b10;\n      assign idel_pat0_fall1[3] = 2'b11;\n\n      assign idel_pat0_rise0[2] = 2'b00;\n      assign idel_pat0_fall0[2] = 2'b10;\n      assign idel_pat0_rise1[2] = 2'b11;\n      assign idel_pat0_fall1[2] = 2'b10;\n\n      assign idel_pat0_rise0[1] = 2'b00;\n      assign idel_pat0_fall0[1] = 2'b11;\n      assign idel_pat0_rise1[1] = 2'b10;\n      assign idel_pat0_fall1[1] = 2'b01;\n\n      assign idel_pat0_rise0[0] = 2'b11;\n      assign idel_pat0_fall0[0] = 2'b10;\n      assign idel_pat0_rise1[0] = 2'b00;\n      assign idel_pat0_fall1[0] = 2'b01;\n\n\n      \n      assign idel_pat1_rise0[3] = 2'b01;\n      assign idel_pat1_fall0[3] = 2'b11;\n      assign idel_pat1_rise1[3] = 2'b01;\n      assign idel_pat1_fall1[3] = 2'b00;\n\n      assign idel_pat1_rise0[2] = 2'b11;\n      assign idel_pat1_fall0[2] = 2'b01;\n      assign idel_pat1_rise1[2] = 2'b00;\n      assign idel_pat1_fall1[2] = 2'b10;\n\n      assign idel_pat1_rise0[1] = 2'b01;\n      assign idel_pat1_fall0[1] = 2'b00;\n      assign idel_pat1_rise1[1] = 2'b10;\n      assign idel_pat1_fall1[1] = 2'b11;\n\n      assign idel_pat1_rise0[0] = 2'b00;\n      assign idel_pat1_fall0[0] = 2'b10;\n      assign idel_pat1_rise1[0] = 2'b11;\n      assign idel_pat1_fall1[0] = 2'b10;\n\n\n      \n      assign pat0_rise0[3] = 2'b00;\n      assign pat0_fall0[3] = 2'b10;\n      assign pat0_rise1[3] = 2'b11;\n      assign pat0_fall1[3] = 2'b10;\n\n      assign pat0_rise0[2] = 2'b10;\n      assign pat0_fall0[2] = 2'b11;\n      assign pat0_rise1[2] = 2'b10;\n      assign pat0_fall1[2] = 2'b00;\n\n      assign pat0_rise0[1] = 2'b11;\n      assign pat0_fall0[1] = 2'b10;\n      assign pat0_rise1[1] = 2'b01;\n      assign pat0_fall1[1] = 2'b00;\n\n      assign pat0_rise0[0] = 2'b10;\n      assign pat0_fall0[0] = 2'b00;\n      assign pat0_rise1[0] = 2'b01;\n      assign pat0_fall1[0] = 2'b11;\n\n      \n      assign pat1_rise0[3] = 2'b11;\n      assign pat1_fall0[3] = 2'b01;\n      assign pat1_rise1[3] = 2'b00;\n      assign pat1_fall1[3] = 2'b10;\n\n      assign pat1_rise0[2] = 2'b01;\n      assign pat1_fall0[2] = 2'b00;\n      assign pat1_rise1[2] = 2'b10;\n      assign pat1_fall1[2] = 2'b11;\n\n      assign pat1_rise0[1] = 2'b00;\n      assign pat1_fall0[1] = 2'b10;\n      assign pat1_rise1[1] = 2'b11;\n      assign pat1_fall1[1] = 2'b10;\n\n      assign pat1_rise0[0] = 2'b10;\n      assign pat1_fall0[0] = 2'b11;\n      assign pat1_rise1[0] = 2'b10;\n      assign pat1_fall1[0] = 2'b00;\n    end\n  endgenerate\n\n  \n  \n  \n  \n  \n  \n  generate\n    genvar pt_i;\n    if (nCK_PER_CLK == 4) begin: gen_pat_match_div4\n      for (pt_i = 0; pt_i < DRAM_WIDTH; pt_i = pt_i + 1) begin: gen_pat_match\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat0_rise0[pt_i%4])\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat0_fall0[pt_i%4])\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat0_rise1[pt_i%4])\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat0_fall1[pt_i%4])\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == idel_pat0_rise2[pt_i%4])\n            idel_pat0_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == idel_pat0_fall2[pt_i%4])\n            idel_pat0_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == idel_pat0_rise3[pt_i%4])\n            idel_pat0_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == idel_pat0_fall3[pt_i%4])\n            idel_pat0_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat1_rise0[pt_i%4])\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat1_fall0[pt_i%4])\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat1_rise1[pt_i%4])\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat1_fall1[pt_i%4])\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == idel_pat1_rise2[pt_i%4])\n            idel_pat1_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == idel_pat1_fall2[pt_i%4])\n            idel_pat1_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == idel_pat1_rise3[pt_i%4])\n            idel_pat1_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == idel_pat1_fall3[pt_i%4])\n            idel_pat1_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat0_rise0[pt_i%4])\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat0_fall0[pt_i%4])\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat0_rise1[pt_i%4])\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat0_fall1[pt_i%4])\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == pat0_rise2[pt_i%4])\n            pat0_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == pat0_fall2[pt_i%4])\n            pat0_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == pat0_rise3[pt_i%4])\n            pat0_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == pat0_fall3[pt_i%4])\n            pat0_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat1_rise0[pt_i%4])\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat1_fall0[pt_i%4])\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat1_rise1[pt_i%4])\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat1_fall1[pt_i%4])\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == pat1_rise2[pt_i%4])\n            pat1_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == pat1_fall2[pt_i%4])\n            pat1_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == pat1_rise3[pt_i%4])\n            pat1_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == pat1_fall3[pt_i%4])\n            pat1_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n      end\n\n      \n      always @(posedge clk) begin\n        idel_pat0_match_rise0_and_r <= #TCQ &idel_pat0_match_rise0_r;\n        idel_pat0_match_fall0_and_r <= #TCQ &idel_pat0_match_fall0_r;\n        idel_pat0_match_rise1_and_r <= #TCQ &idel_pat0_match_rise1_r;\n        idel_pat0_match_fall1_and_r <= #TCQ &idel_pat0_match_fall1_r;\n        idel_pat0_match_rise2_and_r <= #TCQ &idel_pat0_match_rise2_r;\n        idel_pat0_match_fall2_and_r <= #TCQ &idel_pat0_match_fall2_r;\n        idel_pat0_match_rise3_and_r <= #TCQ &idel_pat0_match_rise3_r;\n        idel_pat0_match_fall3_and_r <= #TCQ &idel_pat0_match_fall3_r;\n        idel_pat0_data_match_r <= #TCQ (idel_pat0_match_rise0_and_r &&\n                                        idel_pat0_match_fall0_and_r &&\n                                        idel_pat0_match_rise1_and_r &&\n                                        idel_pat0_match_fall1_and_r &&\n                                        idel_pat0_match_rise2_and_r &&\n                                        idel_pat0_match_fall2_and_r &&\n                                        idel_pat0_match_rise3_and_r &&\n                                        idel_pat0_match_fall3_and_r);\n      end\n\n      always @(posedge clk) begin\n        idel_pat1_match_rise0_and_r <= #TCQ &idel_pat1_match_rise0_r;\n        idel_pat1_match_fall0_and_r <= #TCQ &idel_pat1_match_fall0_r;\n        idel_pat1_match_rise1_and_r <= #TCQ &idel_pat1_match_rise1_r;\n        idel_pat1_match_fall1_and_r <= #TCQ &idel_pat1_match_fall1_r;\n        idel_pat1_match_rise2_and_r <= #TCQ &idel_pat1_match_rise2_r;\n        idel_pat1_match_fall2_and_r <= #TCQ &idel_pat1_match_fall2_r;\n        idel_pat1_match_rise3_and_r <= #TCQ &idel_pat1_match_rise3_r;\n        idel_pat1_match_fall3_and_r <= #TCQ &idel_pat1_match_fall3_r;\n        idel_pat1_data_match_r <= #TCQ (idel_pat1_match_rise0_and_r &&\n                                        idel_pat1_match_fall0_and_r &&\n                                        idel_pat1_match_rise1_and_r &&\n                                        idel_pat1_match_fall1_and_r &&\n                                        idel_pat1_match_rise2_and_r &&\n                                        idel_pat1_match_fall2_and_r &&\n                                        idel_pat1_match_rise3_and_r &&\n                                        idel_pat1_match_fall3_and_r);\n      end\n\n      always @(*)\n        idel_pat_data_match <= #TCQ idel_pat0_data_match_r |\n                                    idel_pat1_data_match_r;\n\n      always @(posedge clk)\n        idel_pat_data_match_r <= #TCQ idel_pat_data_match;\n\n      \n      always @(posedge clk) begin\n        pat0_match_rise0_and_r <= #TCQ &pat0_match_rise0_r;\n        pat0_match_fall0_and_r <= #TCQ &pat0_match_fall0_r;\n        pat0_match_rise1_and_r <= #TCQ &pat0_match_rise1_r;\n        pat0_match_fall1_and_r <= #TCQ &pat0_match_fall1_r;\n        pat0_match_rise2_and_r <= #TCQ &pat0_match_rise2_r;\n        pat0_match_fall2_and_r <= #TCQ &pat0_match_fall2_r;\n        pat0_match_rise3_and_r <= #TCQ &pat0_match_rise3_r;\n        pat0_match_fall3_and_r <= #TCQ &pat0_match_fall3_r;\n        pat0_data_match_r <= #TCQ (pat0_match_rise0_and_r &&\n                                   pat0_match_fall0_and_r &&\n                                   pat0_match_rise1_and_r &&\n                                   pat0_match_fall1_and_r &&\n                                   pat0_match_rise2_and_r &&\n                                   pat0_match_fall2_and_r &&\n                                   pat0_match_rise3_and_r &&\n                                   pat0_match_fall3_and_r);\n      end\n\n      always @(posedge clk) begin\n        pat1_match_rise0_and_r <= #TCQ &pat1_match_rise0_r;\n        pat1_match_fall0_and_r <= #TCQ &pat1_match_fall0_r;\n        pat1_match_rise1_and_r <= #TCQ &pat1_match_rise1_r;\n        pat1_match_fall1_and_r <= #TCQ &pat1_match_fall1_r;\n        pat1_match_rise2_and_r <= #TCQ &pat1_match_rise2_r;\n        pat1_match_fall2_and_r <= #TCQ &pat1_match_fall2_r;\n        pat1_match_rise3_and_r <= #TCQ &pat1_match_rise3_r;\n        pat1_match_fall3_and_r <= #TCQ &pat1_match_fall3_r;\n        pat1_data_match_r <= #TCQ (pat1_match_rise0_and_r &&\n                                   pat1_match_fall0_and_r &&\n                                   pat1_match_rise1_and_r &&\n                                   pat1_match_fall1_and_r &&\n                                   pat1_match_rise2_and_r &&\n                                   pat1_match_fall2_and_r &&\n                                   pat1_match_rise3_and_r &&\n                                   pat1_match_fall3_and_r);\n      end\n\n      assign pat_data_match_r = pat0_data_match_r | pat1_data_match_r;\n\n    end else if (nCK_PER_CLK == 2) begin: gen_pat_match_div2\n      for (pt_i = 0; pt_i < DRAM_WIDTH; pt_i = pt_i + 1) begin: gen_pat_match\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat0_rise0[pt_i%4])\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat0_fall0[pt_i%4])\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat0_rise1[pt_i%4])\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat0_fall1[pt_i%4])\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat1_rise0[pt_i%4])\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat1_fall0[pt_i%4])\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat1_rise1[pt_i%4])\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat1_fall1[pt_i%4])\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat0_rise0[pt_i%4])\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat0_fall0[pt_i%4])\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat0_rise1[pt_i%4])\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat0_fall1[pt_i%4])\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat1_rise0[pt_i%4])\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat1_fall0[pt_i%4])\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat1_rise1[pt_i%4])\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat1_fall1[pt_i%4])\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n      end\n\n        \n      always @(posedge clk) begin\n        idel_pat0_match_rise0_and_r <= #TCQ &idel_pat0_match_rise0_r;\n        idel_pat0_match_fall0_and_r <= #TCQ &idel_pat0_match_fall0_r;\n        idel_pat0_match_rise1_and_r <= #TCQ &idel_pat0_match_rise1_r;\n        idel_pat0_match_fall1_and_r <= #TCQ &idel_pat0_match_fall1_r;\n        idel_pat0_data_match_r <= #TCQ (idel_pat0_match_rise0_and_r &&\n                                        idel_pat0_match_fall0_and_r &&\n                                        idel_pat0_match_rise1_and_r &&\n                                        idel_pat0_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        idel_pat1_match_rise0_and_r <= #TCQ &idel_pat1_match_rise0_r;\n        idel_pat1_match_fall0_and_r <= #TCQ &idel_pat1_match_fall0_r;\n        idel_pat1_match_rise1_and_r <= #TCQ &idel_pat1_match_rise1_r;\n        idel_pat1_match_fall1_and_r <= #TCQ &idel_pat1_match_fall1_r;\n        idel_pat1_data_match_r <= #TCQ (idel_pat1_match_rise0_and_r &&\n                                        idel_pat1_match_fall0_and_r &&\n                                        idel_pat1_match_rise1_and_r &&\n                                        idel_pat1_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        if (sr_valid_r2)\n          idel_pat_data_match <= #TCQ idel_pat0_data_match_r |\n                                      idel_pat1_data_match_r;\n      end\n\n      \n      \n\n      always @(posedge clk)\n        idel_pat_data_match_r <= #TCQ idel_pat_data_match;\n\n      \n      always @(posedge clk) begin\n        pat0_match_rise0_and_r <= #TCQ &pat0_match_rise0_r;\n        pat0_match_fall0_and_r <= #TCQ &pat0_match_fall0_r;\n        pat0_match_rise1_and_r <= #TCQ &pat0_match_rise1_r;\n        pat0_match_fall1_and_r <= #TCQ &pat0_match_fall1_r;\n        pat0_data_match_r <= #TCQ (pat0_match_rise0_and_r &&\n                                   pat0_match_fall0_and_r &&\n                                   pat0_match_rise1_and_r &&\n                                   pat0_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        pat1_match_rise0_and_r <= #TCQ &pat1_match_rise0_r;\n        pat1_match_fall0_and_r <= #TCQ &pat1_match_fall0_r;\n        pat1_match_rise1_and_r <= #TCQ &pat1_match_rise1_r;\n        pat1_match_fall1_and_r <= #TCQ &pat1_match_fall1_r;\n        pat1_data_match_r <= #TCQ (pat1_match_rise0_and_r &&\n                                   pat1_match_fall0_and_r &&\n                                   pat1_match_rise1_and_r &&\n                                   pat1_match_fall1_and_r);\n      end\n\n      assign pat_data_match_r = pat0_data_match_r | pat1_data_match_r;\n\n    end\n\n  endgenerate\n\n\n  always @(posedge clk) begin\n    rdlvl_stg1_start_r <= #TCQ rdlvl_stg1_start;\n    mpr_rdlvl_done_r1  <= #TCQ mpr_rdlvl_done_r;\n    mpr_rdlvl_done_r2  <= #TCQ mpr_rdlvl_done_r1;\n    mpr_rdlvl_start_r  <= #TCQ mpr_rdlvl_start;\n  end\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst || (mpr_rdlvl_done_r && ~rdlvl_stg1_start)) begin\n      cnt_shift_r <= #TCQ 'b1;\n      sr_valid_r  <= #TCQ 1'b0;\n      mpr_valid_r <= #TCQ 1'b0;\n    end else begin\n      if (mux_rd_valid_r && mpr_rdlvl_start && ~mpr_rdlvl_done_r) begin\n        if (cnt_shift_r == 'b0)\n          mpr_valid_r <= #TCQ 1'b1;\n        else begin\n          mpr_valid_r <= #TCQ 1'b0;\n          cnt_shift_r <= #TCQ cnt_shift_r + 1;\n        end\n      end else\n        mpr_valid_r <= #TCQ 1'b0;\n\n      if (mux_rd_valid_r && rdlvl_stg1_start) begin\n        if (cnt_shift_r == RD_SHIFT_LEN-1) begin\n          sr_valid_r <= #TCQ 1'b1;\n          cnt_shift_r <= #TCQ 'b0;\n        end else begin\n          sr_valid_r <= #TCQ 1'b0;\n          cnt_shift_r <= #TCQ cnt_shift_r + 1;\n        end\n      end else\n        \n        \n        \n        \n        sr_valid_r <= #TCQ 1'b0;\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  always @(posedge clk)\n    if (rst)\n      store_sr_r      <= #TCQ 1'b0;\n    else begin\n      if (store_sr_req_r)\n        store_sr_r <= #TCQ 1'b1;\n      else if ((sr_valid_r || mpr_valid_r) && store_sr_r)\n        store_sr_r <= #TCQ 1'b0;\n    end\n\n  \n  \n  \n  generate\n    if (nCK_PER_CLK == 4) begin: gen_old_sr_div4\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_old_sr\n      always @(posedge clk) begin\n        if (sr_valid_r || mpr_valid_r) begin\n          \n          prev_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n          prev_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n          prev_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n          prev_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          prev_sr_rise2_r[z] <= #TCQ sr_rise2_r[z];\n          prev_sr_fall2_r[z] <= #TCQ sr_fall2_r[z];\n          prev_sr_rise3_r[z] <= #TCQ sr_rise3_r[z];\n          prev_sr_fall3_r[z] <= #TCQ sr_fall3_r[z];\n        end\n        if ((sr_valid_r || mpr_valid_r) && store_sr_r) begin\n          old_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n          old_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n          old_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n          old_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          old_sr_rise2_r[z] <= #TCQ sr_rise2_r[z];\n          old_sr_fall2_r[z] <= #TCQ sr_fall2_r[z];\n          old_sr_rise3_r[z] <= #TCQ sr_rise3_r[z];\n          old_sr_fall3_r[z] <= #TCQ sr_fall3_r[z];\n        end\n      end\n    end\n    end else if (nCK_PER_CLK == 2) begin: gen_old_sr_div2\n      for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_old_sr\n        always @(posedge clk) begin\n          if (sr_valid_r || mpr_valid_r) begin\n            prev_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n            prev_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n            prev_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n            prev_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          end\n          if ((sr_valid_r || mpr_valid_r) && store_sr_r) begin\n            old_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n            old_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n            old_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n            old_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n  always @(posedge clk) begin\n    sr_valid_r1  <= #TCQ sr_valid_r;\n    sr_valid_r2  <= #TCQ sr_valid_r1;\n    mpr_valid_r1 <= #TCQ mpr_valid_r;\n    mpr_valid_r2 <= #TCQ mpr_valid_r1;\n  end\n\n  generate\n    if (nCK_PER_CLK == 4) begin: gen_sr_match_div4\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_sr_match\n      always @(posedge clk) begin\n        \n        \n        \n        \n        \n        \n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise0_r[z] == old_sr_rise0_r[z]))\n          old_sr_match_rise0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise0_r[z] <= #TCQ old_sr_match_rise0_r[z];\n        else\n          old_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall0_r[z] == old_sr_fall0_r[z]))\n          old_sr_match_fall0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall0_r[z] <= #TCQ old_sr_match_fall0_r[z];\n        else\n          old_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise1_r[z] == old_sr_rise1_r[z]))\n          old_sr_match_rise1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise1_r[z] <= #TCQ old_sr_match_rise1_r[z];\n        else\n          old_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall1_r[z] == old_sr_fall1_r[z]))\n          old_sr_match_fall1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall1_r[z] <= #TCQ old_sr_match_fall1_r[z];\n        else\n          old_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise2_r[z] == old_sr_rise2_r[z]))\n          old_sr_match_rise2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise2_r[z] <= #TCQ old_sr_match_rise2_r[z];\n        else\n          old_sr_match_rise2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall2_r[z] == old_sr_fall2_r[z]))\n          old_sr_match_fall2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall2_r[z] <= #TCQ old_sr_match_fall2_r[z];\n        else\n          old_sr_match_fall2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise3_r[z] == old_sr_rise3_r[z]))\n          old_sr_match_rise3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise3_r[z] <= #TCQ old_sr_match_rise3_r[z];\n        else\n          old_sr_match_rise3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall3_r[z] == old_sr_fall3_r[z]))\n          old_sr_match_fall3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall3_r[z] <= #TCQ old_sr_match_fall3_r[z];\n        else\n          old_sr_match_fall3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise0_r[z] == prev_sr_rise0_r[z]))\n          prev_sr_match_rise0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise0_r[z] <= #TCQ prev_sr_match_rise0_r[z];\n        else\n          prev_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall0_r[z] == prev_sr_fall0_r[z]))\n          prev_sr_match_fall0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall0_r[z] <= #TCQ prev_sr_match_fall0_r[z];\n        else\n          prev_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise1_r[z] == prev_sr_rise1_r[z]))\n          prev_sr_match_rise1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise1_r[z] <= #TCQ prev_sr_match_rise1_r[z];\n        else\n          prev_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall1_r[z] == prev_sr_fall1_r[z]))\n          prev_sr_match_fall1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall1_r[z] <= #TCQ prev_sr_match_fall1_r[z];\n        else\n          prev_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise2_r[z] == prev_sr_rise2_r[z]))\n          prev_sr_match_rise2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise2_r[z] <= #TCQ prev_sr_match_rise2_r[z];\n        else\n          prev_sr_match_rise2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall2_r[z] == prev_sr_fall2_r[z]))\n          prev_sr_match_fall2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall2_r[z] <= #TCQ prev_sr_match_fall2_r[z];\n        else\n          prev_sr_match_fall2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise3_r[z] == prev_sr_rise3_r[z]))\n          prev_sr_match_rise3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise3_r[z] <= #TCQ prev_sr_match_rise3_r[z];\n        else\n          prev_sr_match_rise3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall3_r[z] == prev_sr_fall3_r[z]))\n          prev_sr_match_fall3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall3_r[z] <= #TCQ prev_sr_match_fall3_r[z];\n        else\n          prev_sr_match_fall3_r[z] <= #TCQ 1'b0;\n\n        \n        \n        \n          old_sr_match_cyc2_r[z] <= #TCQ\n                                    old_sr_match_rise0_r[z] &\n                                  old_sr_match_fall0_r[z] &\n                                  old_sr_match_rise1_r[z] &\n                                  old_sr_match_fall1_r[z] &\n                                  old_sr_match_rise2_r[z] &\n                                  old_sr_match_fall2_r[z] &\n                                  old_sr_match_rise3_r[z] &\n                                  old_sr_match_fall3_r[z];\n          prev_sr_match_cyc2_r[z] <= #TCQ\n                                     prev_sr_match_rise0_r[z] &\n                                   prev_sr_match_fall0_r[z] &\n                                   prev_sr_match_rise1_r[z] &\n                                   prev_sr_match_fall1_r[z] &\n                                   prev_sr_match_rise2_r[z] &\n                                   prev_sr_match_fall2_r[z] &\n                                   prev_sr_match_rise3_r[z] &\n                                   prev_sr_match_fall3_r[z];\n\n        \n        \n        \n        if (sr_valid_r2 || mpr_valid_r2) begin\n          old_sr_diff_r[z]  <= #TCQ ~old_sr_match_cyc2_r[z];\n          prev_sr_diff_r[z] <= #TCQ ~prev_sr_match_cyc2_r[z];\n        end else begin\n          old_sr_diff_r[z]  <= #TCQ 'b0;\n          prev_sr_diff_r[z] <= #TCQ 'b0;\n        end\n        end\n      end\n    end if (nCK_PER_CLK == 2) begin: gen_sr_match_div2\n      for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_sr_match\n        always @(posedge clk) begin\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise0_r[z] == old_sr_rise0_r[z]))\n            old_sr_match_rise0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_rise0_r[z] <= #TCQ old_sr_match_rise0_r[z];\n          else\n            old_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall0_r[z] == old_sr_fall0_r[z]))\n            old_sr_match_fall0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_fall0_r[z] <= #TCQ old_sr_match_fall0_r[z];\n          else\n            old_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise1_r[z] == old_sr_rise1_r[z]))\n            old_sr_match_rise1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_rise1_r[z] <= #TCQ old_sr_match_rise1_r[z];\n          else\n            old_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall1_r[z] == old_sr_fall1_r[z]))\n            old_sr_match_fall1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_fall1_r[z] <= #TCQ old_sr_match_fall1_r[z];\n          else\n            old_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise0_r[z] == prev_sr_rise0_r[z]))\n            prev_sr_match_rise0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_rise0_r[z] <= #TCQ prev_sr_match_rise0_r[z];\n          else\n            prev_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall0_r[z] == prev_sr_fall0_r[z]))\n            prev_sr_match_fall0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_fall0_r[z] <= #TCQ prev_sr_match_fall0_r[z];\n          else\n            prev_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise1_r[z] == prev_sr_rise1_r[z]))\n            prev_sr_match_rise1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_rise1_r[z] <= #TCQ prev_sr_match_rise1_r[z];\n          else\n            prev_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall1_r[z] == prev_sr_fall1_r[z]))\n            prev_sr_match_fall1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_fall1_r[z] <= #TCQ prev_sr_match_fall1_r[z];\n          else\n            prev_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n          old_sr_match_cyc2_r[z] <= #TCQ\n                                    old_sr_match_rise0_r[z] &\n                                    old_sr_match_fall0_r[z] &\n                                    old_sr_match_rise1_r[z] &\n                                    old_sr_match_fall1_r[z];\n          prev_sr_match_cyc2_r[z] <= #TCQ\n                                     prev_sr_match_rise0_r[z] &\n                                     prev_sr_match_fall0_r[z] &\n                                     prev_sr_match_rise1_r[z] &\n                                     prev_sr_match_fall1_r[z];\n\n          \n          \n          \n          if (sr_valid_r2 || mpr_valid_r2) begin\n            old_sr_diff_r[z]  <= #TCQ ~old_sr_match_cyc2_r[z];\n            prev_sr_diff_r[z] <= #TCQ ~prev_sr_match_cyc2_r[z];\n          end else begin\n            old_sr_diff_r[z]  <= #TCQ 'b0;\n            prev_sr_diff_r[z] <= #TCQ 'b0;\n          end\n        end\n     end\n    end\n  endgenerate\n\n  \n  \n  \n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  always @(posedge clk)\n    samp_edge_cnt0_en_r <= #TCQ\n                          (cal1_state_r == CAL1_PAT_DETECT) ||\n                          (cal1_state_r == CAL1_DETECT_EDGE) ||\n                          (cal1_state_r == CAL1_PB_DETECT_EDGE) ||\n                          (cal1_state_r == CAL1_PB_DETECT_EDGE_DQ);\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt0_r <= #TCQ 'b0;\n    else begin\n      if (!samp_edge_cnt0_en_r)\n        \n        samp_edge_cnt0_r <= #TCQ 'b0;\n      else if (sr_valid_r2 || mpr_valid_r2)\n        \n        samp_edge_cnt0_r <= #TCQ samp_edge_cnt0_r + 1;\n    end\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt1_en_r <= #TCQ 1'b0;\n    else begin\n      \n      if ((samp_edge_cnt0_r == DETECT_EDGE_SAMPLE_CNT0) &&\n          (sr_valid_r2 || mpr_valid_r2))\n        samp_edge_cnt1_en_r <= #TCQ 1'b1;\n      else\n        samp_edge_cnt1_en_r <= #TCQ 1'b0;\n    end\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt1_r <= #TCQ 'b0;\n    else\n      if (!samp_edge_cnt0_en_r)\n        samp_edge_cnt1_r <= #TCQ 'b0;\n      else if (samp_edge_cnt1_en_r)\n        samp_edge_cnt1_r <= #TCQ samp_edge_cnt1_r + 1;\n\n  always @(posedge clk)\n    if (rst)\n      samp_cnt_done_r <= #TCQ 1'b0;\n    else begin\n      if (!samp_edge_cnt0_en_r)\n        samp_cnt_done_r <= #TCQ 'b0;\n      else if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n               (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n        if (samp_edge_cnt0_r == SR_VALID_DELAY-1)\n          \n          \n          samp_cnt_done_r <= #TCQ 1'b1;\n      end else begin\n        if (samp_edge_cnt1_r == DETECT_EDGE_SAMPLE_CNT1)\n          samp_cnt_done_r <= #TCQ 1'b1;\n      end\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  assign pb_detect_edge_setup\n    = (cal1_state_r == CAL1_STORE_FIRST_WAIT) ||\n      (cal1_state_r == CAL1_PB_STORE_FIRST_WAIT) ||\n      (cal1_state_r == CAL1_PB_DEC_CPT_LEFT_WAIT);\n\n  assign pb_detect_edge\n    = (cal1_state_r == CAL1_PAT_DETECT) ||\n      (cal1_state_r == CAL1_DETECT_EDGE) ||\n      (cal1_state_r == CAL1_PB_DETECT_EDGE) ||\n      (cal1_state_r == CAL1_PB_DETECT_EDGE_DQ);\n\n  generate\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_track_left_edge\n      always @(posedge clk) begin\n        if (pb_detect_edge_setup) begin\n          \n          \n          pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n          pb_detect_edge_done_r[z] <= #TCQ 1'b0;\n          pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n          pb_last_tap_jitter_r[z]  <= #TCQ 1'b0;\n          pb_found_edge_last_r[z]  <= #TCQ 1'b0;\n          pb_found_edge_r[z]       <= #TCQ 1'b0;\n          pb_found_first_edge_r[z] <= #TCQ 1'b0;\n        end else if (pb_detect_edge) begin\n          \n          \n          \n          pb_found_edge_last_r[z] <= #TCQ pb_found_edge_r[z];\n\n          if (!pb_detect_edge_done_r[z]) begin\n            if (samp_cnt_done_r) begin\n              \n              \n              \n              \n              \n              \n              pb_last_tap_jitter_r[z]  <= #TCQ 1'b0;\n              pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n              if (!pb_found_edge_r[z] && !pb_last_tap_jitter_r[z]) begin\n                \n                \n                \n                if (pb_cnt_eye_size_r[z] != MIN_EYE_SIZE-1)\n                  pb_cnt_eye_size_r[z] <= #TCQ pb_cnt_eye_size_r[z] + 1;\n                else \n                  \n                  pb_found_stable_eye_r[z] <= #TCQ 1'b1;\n              end else begin\n                \n                \n                \n                \n                \n                pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n                pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n                pb_found_edge_r[z]       <= #TCQ 1'b1;\n                pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n              end\n            end else if (prev_sr_diff_r[z]) begin\n              \n              \n              \n              pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n              pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n              pb_last_tap_jitter_r[z]  <= #TCQ 1'b1;\n              pb_found_edge_r[z]       <= #TCQ 1'b1;\n              pb_found_first_edge_r[z] <= #TCQ 1'b1;\n              pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n            end else if (old_sr_diff_r[z] || pb_last_tap_jitter_r[z]) begin\n              \n              \n              \n              \n              \n              \n              \n              \n              pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n              pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n              pb_found_edge_r[z]       <= #TCQ 1'b1;\n              pb_found_first_edge_r[z] <= #TCQ 1'b1;\n            end\n          end\n        end else begin\n          \n          pb_found_edge_r[z]       <= #TCQ 1'b0;\n          pb_detect_edge_done_r[z] <= #TCQ 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  always @(posedge clk) begin\n    detect_edge_done_r <= #TCQ &pb_detect_edge_done_r;\n    found_edge_r       <= #TCQ |pb_found_edge_r;\n    found_edge_all_r   <= #TCQ &pb_found_edge_r;\n    found_stable_eye_r <= #TCQ &pb_found_stable_eye_r;\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  always @(posedge clk)\n    if (pb_detect_edge_setup)\n      found_stable_eye_last_r <= #TCQ 1'b0;\n    else if (detect_edge_done_r)\n      found_stable_eye_last_r <= #TCQ found_stable_eye_r;\n\n  \n  \n  \n\n  \n  always @(posedge clk)\n    if (rst)\n      idelay_tap_cnt_slice_r <= 5'h0;\n    else\n      idelay_tap_cnt_slice_r <= idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing];\n\n  always @(posedge clk)\n    if (rst || (SIM_CAL_OPTION == \"SKIP_CAL\")) begin \n      for (s = 0; s < RANKS; s = s + 1) begin\n        for (t = 0; t < DQS_WIDTH; t = t + 1) begin\n          idelay_tap_cnt_r[s][t] <= #TCQ idelaye2_init_val;\n        end\n      end\n    end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n      for (u = 0; u < RANKS; u = u + 1) begin\n        for (w = 0; w < DQS_WIDTH; w = w + 1) begin\n          if (cal1_dq_idel_ce) begin\n            if (cal1_dq_idel_inc)\n              idelay_tap_cnt_r[u][w] <= #TCQ idelay_tap_cnt_r[u][w] + 1;\n            else\n              idelay_tap_cnt_r[u][w] <= #TCQ idelay_tap_cnt_r[u][w] - 1;\n          end\n        end\n      end\n    end else if ((rnk_cnt_r == RANKS-1) && (RANKS == 2) &&\n                    rdlvl_rank_done_r && (cal1_state_r == CAL1_IDLE)) begin\n      for (f = 0; f < DQS_WIDTH; f = f + 1) begin\n        idelay_tap_cnt_r[rnk_cnt_r][f] <= #TCQ idelay_tap_cnt_r[(rnk_cnt_r-1)][f];\n      end\n    end else if (cal1_dq_idel_ce) begin\n      if (cal1_dq_idel_inc)\n        idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] <= #TCQ idelay_tap_cnt_slice_r + 5'h1;\n      else\n        idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] <= #TCQ idelay_tap_cnt_slice_r - 5'h1;\n    end else if (idelay_ld)\n      idelay_tap_cnt_r[0][wrcal_cnt] <= #TCQ 5'b00000;\n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r)\n      idelay_tap_limit_r <= #TCQ 1'b0;\n    else if (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_r] == 'd31)\n      idelay_tap_limit_r <= #TCQ 1'b1;\n\n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r ||\n        (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n      tap_cnt_cpt_r   <= #TCQ 'b0;\n    else if (cal1_dlyce_cpt_r) begin\n      if (cal1_dlyinc_cpt_r)\n        tap_cnt_cpt_r <= #TCQ tap_cnt_cpt_r + 1;\n      else if (tap_cnt_cpt_r != 'd0)\n        tap_cnt_cpt_r <= #TCQ tap_cnt_cpt_r - 1;\n    end\n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r ||\n       (cal1_state_r1 == CAL1_DQ_IDEL_TAP_INC) ||\n       (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n      tap_limit_cpt_r <= #TCQ 1'b0;\n    else if (tap_cnt_cpt_r == 6'd63)\n      tap_limit_cpt_r <= #TCQ 1'b1;\n\n   always @(posedge clk)\n     cal1_cnt_cpt_timing_r <= #TCQ cal1_cnt_cpt_r;\n\n   assign cal1_cnt_cpt_timing = {2'b00, cal1_cnt_cpt_r};\n\n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for (a = 0; a < RANKS; a = a + 1) begin: rst_rdlvl_dqs_tap_count_loop\n         for (b = 0; b < DQS_WIDTH; b = b + 1)\n           rdlvl_dqs_tap_cnt_r[a][b] <= #TCQ 'b0;\n       end\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (cal1_state_r1 == CAL1_NEXT_DQS)) begin\n       for (p = 0; p < RANKS; p = p +1) begin: rdlvl_dqs_tap_rank_cnt\n         for(q = 0; q < DQS_WIDTH; q = q +1) begin: rdlvl_dqs_tap_cnt\n           rdlvl_dqs_tap_cnt_r[p][q] <= #TCQ tap_cnt_cpt_r;\n         end\n       end\n     end else if (SIM_CAL_OPTION == \"SKIP_CAL\") begin\n       for (j = 0; j < RANKS; j = j +1) begin: rdlvl_dqs_tap_rnk_cnt\n         for(i = 0; i < DQS_WIDTH; i = i +1) begin: rdlvl_dqs_cnt\n           rdlvl_dqs_tap_cnt_r[j][i] <= #TCQ 6'd31;\n         end\n       end\n     end else if (cal1_state_r1 == CAL1_NEXT_DQS) begin\n       rdlvl_dqs_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing_r] <= #TCQ tap_cnt_cpt_r;\n     end\n   end\n\n\n  \n  \n  always @(posedge clk)\n    if (rst) begin\n      idel_tap_cnt_dq_pb_r   <= #TCQ 'b0;\n      idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n    end else\n      if (new_cnt_cpt_r) begin\n        idel_tap_cnt_dq_pb_r   <= #TCQ 'b0;\n        idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n      end else if (|cal1_dlyce_dq_r) begin\n        if (cal1_dlyinc_dq_r)\n          idel_tap_cnt_dq_pb_r <= #TCQ idel_tap_cnt_dq_pb_r + 1;\n        else\n          idel_tap_cnt_dq_pb_r <= #TCQ idel_tap_cnt_dq_pb_r - 1;\n\n        if (idel_tap_cnt_dq_pb_r == 31)\n          idel_tap_limit_dq_pb_r <= #TCQ 1'b1;\n        else\n          idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n      end\n\n\n  \n\n  always @(posedge clk) begin\n    cal1_state_r1 <= #TCQ cal1_state_r;\n    cal1_state_r2 <= #TCQ cal1_state_r1;\n    cal1_state_r3 <= #TCQ cal1_state_r2;\n  end\n\n  always @(posedge clk)\n    if (rst) begin\n      cal1_cnt_cpt_r        <= #TCQ 'b0;\n      cal1_dlyce_cpt_r      <= #TCQ 1'b0;\n      cal1_dlyinc_cpt_r     <= #TCQ 1'b0;\n      cal1_dq_idel_ce       <= #TCQ 1'b0;\n      cal1_dq_idel_inc      <= #TCQ 1'b0;\n      cal1_prech_req_r      <= #TCQ 1'b0;\n      cal1_state_r          <= #TCQ CAL1_IDLE;\n      cnt_idel_dec_cpt_r    <= #TCQ 6'bxxxxxx;\n      found_first_edge_r    <= #TCQ 1'b0;\n      found_second_edge_r   <= #TCQ 1'b0;\n      right_edge_taps_r     <= #TCQ 6'b000000;\n      first_edge_taps_r     <= #TCQ 6'bxxxxxx;\n      new_cnt_cpt_r         <= #TCQ 1'b0;\n      rdlvl_stg1_done_int       <= #TCQ 1'b0;\n      rdlvl_stg1_err        <= #TCQ 1'b0;\n      second_edge_taps_r    <= #TCQ 6'bxxxxxx;\n      store_sr_req_pulsed_r <= #TCQ 1'b0;\n      store_sr_req_r        <= #TCQ 1'b0;\n      rnk_cnt_r             <= #TCQ 2'b00;\n      rdlvl_rank_done_r     <= #TCQ 1'b0;\n      idel_dec_cnt          <= #TCQ 'd0;\n      rdlvl_last_byte_done_int  <= #TCQ 1'b0;\n      idel_pat_detect_valid_r <= #TCQ 1'b0;\n      mpr_rank_done_r       <= #TCQ 1'b0;\n      mpr_last_byte_done    <= #TCQ 1'b0;\n      idel_adj_inc          <= #TCQ 1'b0;\n      if (OCAL_EN == \"ON\")\n        mpr_rdlvl_done_r      <= #TCQ 1'b0;\n      else\n        mpr_rdlvl_done_r      <= #TCQ 1'b1;\n        mpr_dec_cpt_r           <= #TCQ 1'b0;\n        rdlvl_pi_incdec         <= #TCQ 1'b0;\n    end else begin\n      \n      \n      cal1_prech_req_r    <= #TCQ 1'b0;\n      cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n      cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n      cal1_dq_idel_ce     <= #TCQ 1'b0;\n      cal1_dq_idel_inc    <= #TCQ 1'b0;\n      new_cnt_cpt_r       <= #TCQ 1'b0;\n      store_sr_req_pulsed_r <= #TCQ 1'b0;\n      store_sr_req_r      <= #TCQ 1'b0;\n\n      case (cal1_state_r)\n\n        CAL1_IDLE: begin\n          rdlvl_rank_done_r    <= #TCQ 1'b0;\n          rdlvl_last_byte_done_int <= #TCQ 1'b0;\n          mpr_rank_done_r      <= #TCQ 1'b0;\n          mpr_last_byte_done   <= #TCQ 1'b0;\n          if (mpr_rdlvl_start && ~mpr_rdlvl_start_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n            cal1_state_r  <= #TCQ CAL1_MPR_NEW_DQS_WAIT;\n          end else begin\n            rdlvl_pi_incdec    <= #TCQ 1'b1;\n            if (rdlvl_stg1_start && ~rdlvl_stg1_start_r) begin\n              if (SIM_CAL_OPTION == \"SKIP_CAL\")\n                cal1_state_r  <= #TCQ CAL1_REGL_LOAD;\n              else if (SIM_CAL_OPTION == \"FAST_CAL\")\n                cal1_state_r  <= #TCQ CAL1_NEXT_DQS;\n              else begin\n                new_cnt_cpt_r <= #TCQ 1'b1;\n                cal1_state_r  <= #TCQ CAL1_NEW_DQS_WAIT;\n              end\n            end\n          end\n        end\n\n        CAL1_MPR_NEW_DQS_WAIT: begin\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          if (!cal1_wait_r && mpr_valid_r)\n            cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n        end\n\n        \n        \n        \n        CAL1_NEW_DQS_WAIT: begin\n          rdlvl_rank_done_r    <= #TCQ 1'b0;\n          rdlvl_last_byte_done_int <= #TCQ 1'b0;\n          mpr_rank_done_r      <= #TCQ 1'b0;\n          mpr_last_byte_done   <= #TCQ 1'b0;\n          cal1_prech_req_r     <= #TCQ 1'b0;\n          if (|pi_counter_read_val) begin \n            mpr_dec_cpt_r      <= #TCQ 1'b1;\n            cal1_state_r       <= #TCQ CAL1_IDEL_DEC_CPT;\n            cnt_idel_dec_cpt_r <= #TCQ pi_counter_read_val;\n            rdlvl_pi_incdec    <= #TCQ 1'b1;  \n          end else if (!cal1_wait_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n\n            \n            \n            \n            \n            store_sr_req_r <= #TCQ 1'b1;\n            \n            \n            if (PER_BIT_DESKEW == \"OFF\")\n              cal1_state_r <= #TCQ CAL1_STORE_FIRST_WAIT;\n            else if (PER_BIT_DESKEW == \"ON\")\n              cal1_state_r <= #TCQ CAL1_PB_STORE_FIRST_WAIT;\n          end else\n            rdlvl_pi_incdec    <= #TCQ 1'b1;  \n        end\n        \n        \n        \n\n        \n        CAL1_PB_STORE_FIRST_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE;\n\n        \n        CAL1_PB_DETECT_EDGE:\n          if (detect_edge_done_r) begin\n            if (found_stable_eye_r) begin\n              \n              \n              \n              \n              cnt_idel_dec_cpt_r <= #TCQ MIN_EYE_SIZE + 1;\n              cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT_LEFT;\n            end else begin\n              \n              \n              if (!tap_limit_cpt_r) begin\n                \n                \n                \n                store_sr_req_r <= #TCQ 1'b1;\n                cal1_state_r    <= #TCQ CAL1_PB_INC_CPT;\n              end else begin\n                \n                \n                \n                \n                \n                cnt_idel_dec_cpt_r <= #TCQ 6'd63;\n                cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT;\n              end\n            end\n          end\n\n        \n        CAL1_PB_INC_CPT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b1;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b1;\n          cal1_state_r      <= #TCQ CAL1_PB_INC_CPT_WAIT;\n        end\n\n        \n        \n        CAL1_PB_INC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE;\n\n          end\n        end\n        \n        \n        \n        CAL1_PB_DEC_CPT_LEFT:\n          if (cnt_idel_dec_cpt_r == 6'b000000)\n            cal1_state_r <= #TCQ CAL1_PB_DEC_CPT_LEFT_WAIT;\n          else begin\n            cal1_dlyce_cpt_r   <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r  <= #TCQ 1'b0;\n            cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          end\n\n        CAL1_PB_DEC_CPT_LEFT_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE_DQ;\n\n        \n        \n        \n        \n        \n        CAL1_PB_DETECT_EDGE_DQ:\n          if (detect_edge_done_r)\n            if (found_edge_all_r) begin\n              \n              \n              \n              \n              cnt_idel_dec_cpt_r <= #TCQ tap_cnt_cpt_r;\n              cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT;\n            end else\n              if (!idel_tap_limit_dq_pb_r)\n                \n                \n                cal1_state_r <= #TCQ CAL1_PB_INC_DQ;\n              else begin\n                \n                \n                cnt_idel_dec_cpt_r <= #TCQ tap_cnt_cpt_r;\n                cal1_state_r <= #TCQ CAL1_PB_DEC_CPT;\n              end\n\n        CAL1_PB_INC_DQ: begin\n          \n          cal1_dlyce_dq_r  <= #TCQ ~pb_found_edge_last_r;\n          cal1_dlyinc_dq_r <= #TCQ 1'b1;\n          cal1_state_r     <= #TCQ CAL1_PB_INC_DQ_WAIT;\n        end\n\n        CAL1_PB_INC_DQ_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE_DQ;\n\n        \n        CAL1_PB_DEC_CPT:\n          if (cnt_idel_dec_cpt_r == 6'b000000)\n            cal1_state_r <= #TCQ CAL1_PB_DEC_CPT_WAIT;\n          else begin\n            cal1_dlyce_cpt_r   <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r  <= #TCQ 1'b0;\n            cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          end\n\n        \n        \n        CAL1_PB_DEC_CPT_WAIT:\n          if (!cal1_wait_r) begin\n            store_sr_req_r <= #TCQ 1'b1;\n            cal1_state_r    <= #TCQ CAL1_STORE_FIRST_WAIT;\n          end\n\n        \n        \n        \n        \n        \n        \n        \n        \n        CAL1_STORE_FIRST_WAIT: begin\n          mpr_dec_cpt_r  <= #TCQ 1'b0;\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PAT_DETECT;\n        end\n\n        CAL1_VALID_WAIT: begin\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n        end\n\n        CAL1_MPR_PAT_DETECT: begin\n          rdlvl_pi_incdec <= #TCQ 1'b0;\n          \n          \n          if (idel_pat_detect_valid_r == 1'b0) begin\n            cal1_state_r  <= #TCQ CAL1_VALID_WAIT;\n            idel_pat_detect_valid_r <= #TCQ 1'b1;\n          end else if (idel_pat_detect_valid_r && idel_mpr_pat_detect_r) begin\n            cal1_state_r  <= #TCQ CAL1_DETECT_EDGE;\n            idel_dec_cnt  <= #TCQ 'd0;\n          end else if (!idelay_tap_limit_r)\n            cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_INC;\n          else\n            cal1_state_r  <= #TCQ CAL1_RDLVL_ERR;\n        end\n\n        CAL1_PAT_DETECT: begin\n          \n          \n          \n          \n          \n          rdlvl_pi_incdec <= #TCQ 1'b0;\n          if (detect_edge_done_r) begin\n            if (idel_pat_data_match) begin\n              case (idelay_adj)\n                2'b01: begin\n                  cal1_state_r <= CAL1_DQ_IDEL_TAP_INC;\n                  idel_dec_cnt <= #TCQ 5'd0;\n                  idel_adj_inc <= #TCQ 1'b1;\n                end\n                2'b10: begin   \n                  cal1_state_r  <= #TCQ  CAL1_DQ_IDEL_TAP_DEC ;\n                  idel_dec_cnt  <= #TCQ 5'd1;\n                  idel_adj_inc  <= #TCQ 1'b0;\n                end\n                default: begin\n                  cal1_state_r  <= #TCQ CAL1_DETECT_EDGE;\n                  idel_dec_cnt  <= #TCQ 5'd0;\n                  idel_adj_inc  <= #TCQ 1'b0;\n                end\n              endcase\n            end else if (!idelay_tap_limit_r) begin\n              cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_INC;\n            end else begin\n              cal1_state_r  <= #TCQ CAL1_RDLVL_ERR;\n            end\n          end\n        end\n\n        \n        \n        CAL1_DQ_IDEL_TAP_INC: begin\n          cal1_dq_idel_ce         <= #TCQ 1'b1;\n          cal1_dq_idel_inc        <= #TCQ 1'b1;\n          cal1_state_r            <= #TCQ CAL1_DQ_IDEL_TAP_INC_WAIT;\n          idel_pat_detect_valid_r <= #TCQ 1'b0;\n        end\n\n        CAL1_DQ_IDEL_TAP_INC_WAIT: begin\n          cal1_dq_idel_ce     <= #TCQ 1'b0;\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            idel_adj_inc        <= #TCQ 1'b0;\n            if (idel_adj_inc)\n              cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n            else  if (~mpr_rdlvl_done_r & (DRAM_TYPE == \"DDR3\"))\n              cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n            else\n              cal1_state_r <= #TCQ CAL1_PAT_DETECT;\n          end\n        end\n\n        \n        CAL1_DQ_IDEL_TAP_DEC: begin\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          cal1_state_r        <= #TCQ CAL1_DQ_IDEL_TAP_DEC_WAIT;\n          if (idel_dec_cnt >= 'd0)\n            cal1_dq_idel_ce     <= #TCQ 1'b1;\n          else\n            cal1_dq_idel_ce     <= #TCQ 1'b0;\n          if (idel_dec_cnt > 'd0)\n            idel_dec_cnt <= #TCQ idel_dec_cnt - 1;\n          else\n            idel_dec_cnt <= #TCQ idel_dec_cnt;\n        end\n\n        CAL1_DQ_IDEL_TAP_DEC_WAIT: begin\n          cal1_dq_idel_ce     <= #TCQ 1'b0;\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            if ((idel_dec_cnt > 'd0) || (pi_rdval_cnt > 'd0))\n              cal1_state_r <= #TCQ CAL1_DQ_IDEL_TAP_DEC;\n            else if (mpr_dec_cpt_r)\n              cal1_state_r <= #TCQ CAL1_STORE_FIRST_WAIT;\n            else\n              cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n          end\n        end\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        CAL1_DETECT_EDGE: begin\n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n\n          \n          \n          \n          \n          \n          idel_pat_detect_valid_r <= #TCQ 1'b0;\n          if (!store_sr_req_pulsed_r) begin\n            \n            store_sr_req_r        <= #TCQ 1'b1;\n            store_sr_req_pulsed_r <= #TCQ 1'b1;\n          end else begin\n            store_sr_req_r        <= #TCQ 1'b0;\n            store_sr_req_pulsed_r <= #TCQ 1'b1;\n          end\n\n          \n          \n          \n          if (detect_edge_done_r) begin\n            if (tap_limit_cpt_r)\n              \n              \n              \n              \n              \n              \n              \n              \n              cal1_state_r <= #TCQ CAL1_CALC_IDEL;\n            else if (found_edge_r) begin\n              \n              \n              \n              found_first_edge_r <= #TCQ 1'b1;\n\n              \n              \n              if (!found_first_edge_r && found_stable_eye_last_r) begin\n                if (tap_cnt_cpt_r == 'd0)\n                  right_edge_taps_r <= #TCQ 'd0;\n                else\n                  right_edge_taps_r <= #TCQ tap_cnt_cpt_r;\n              end\n\n              \n              \n              \n              \n              \n              \n              \n              if (found_first_edge_r && found_stable_eye_last_r) begin\n                found_second_edge_r <= #TCQ 1'b1;\n                second_edge_taps_r <= #TCQ tap_cnt_cpt_r - 1;\n                cal1_state_r <= #TCQ CAL1_CALC_IDEL;\n              end else begin\n                \n                \n                \n                \n                first_edge_taps_r <= #TCQ tap_cnt_cpt_r;\n                \n                cal1_state_r <= #TCQ CAL1_RD_STOP_FOR_PI_INC;\n              end\n            end else\n              \n              \n              \n              cal1_state_r <= #TCQ CAL1_RD_STOP_FOR_PI_INC;\n          end\n        end\n\n        \n        \n        CAL1_RD_STOP_FOR_PI_INC: begin\n          rdlvl_pi_incdec    <= #TCQ 1'b1;\n          if (!cal1_wait_r)\n            cal1_state_r    <= #TCQ CAL1_IDEL_INC_CPT;\n        end\n\n        \n        CAL1_IDEL_INC_CPT: begin\n          cal1_state_r        <= #TCQ CAL1_IDEL_INC_CPT_WAIT;\n          if (~tap_limit_cpt_r) begin\n            cal1_dlyce_cpt_r    <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r   <= #TCQ 1'b1;\n          end else begin\n            cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n            cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n          end\n        end\n\n        \n        CAL1_IDEL_INC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n            rdlvl_pi_incdec <= #TCQ 1'b0;    \n          end\n        end\n\n        \n        \n        \n        \n        \n        CAL1_CALC_IDEL: begin\n         \n          if (found_second_edge_r)\n            cnt_idel_dec_cpt_r\n              <=  #TCQ ((second_edge_taps_r -\n                         first_edge_taps_r)>>1) + 1;\n          else if (right_edge_taps_r > 6'd0)\n            \n            \n            \n            cnt_idel_dec_cpt_r\n              <=  #TCQ (tap_cnt_cpt_r - (right_edge_taps_r>>1));\n          else if (found_first_edge_r)\n            \n            cnt_idel_dec_cpt_r\n              <=  #TCQ ((tap_cnt_cpt_r - first_edge_taps_r)>>1);\n          else\n            cnt_idel_dec_cpt_r\n              <=  #TCQ (tap_cnt_cpt_r>>1);\n          \n          \n          \n          cal1_state_r <= #TCQ CAL1_CENTER_WAIT;\n          rdlvl_pi_incdec <= #TCQ 1'b1;\n        end\n\n        CAL1_CENTER_WAIT: begin\n          if(!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT;\n        end\n        \n        \n        \n        \n        \n        CAL1_IDEL_DEC_CPT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b1;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          \n          \n          cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          if (cnt_idel_dec_cpt_r == 6'b000001) begin\n            if (mpr_dec_cpt_r) begin\n              if (|idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing]) begin\n                idel_dec_cnt  <= #TCQ idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing];\n                cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_DEC;\n              end else\n                cal1_state_r  <= #TCQ CAL1_STORE_FIRST_WAIT;\n            end else\n              cal1_state_r <= #TCQ CAL1_NEXT_DQS;\n          end else\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT_WAIT;\n        end\n\n        CAL1_IDEL_DEC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT;\n        end\n\n        \n        \n        CAL1_NEXT_DQS: begin\n          \n            cal1_prech_req_r  <= #TCQ 1'b1;\n          \n          \n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          \n          found_first_edge_r  <= #TCQ 1'b0;\n          found_second_edge_r <= #TCQ 1'b0;\n          first_edge_taps_r <= #TCQ 'd0;\n          second_edge_taps_r <= #TCQ 'd0;\n          right_edge_taps_r    <= #TCQ 'd0;\n          if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n              (cal1_cnt_cpt_r >= DQS_WIDTH-1)) begin\n            if (mpr_rdlvl_done_r) begin\n              rdlvl_last_byte_done_int <= #TCQ 1'b1;\n              mpr_last_byte_done   <= #TCQ 1'b0;\n            end else begin\n              rdlvl_last_byte_done_int <= #TCQ 1'b0;\n              mpr_last_byte_done   <= #TCQ 1'b1;\n            end\n          end\n\n          \n          \n          if (prech_done) begin \n            if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n              \n              rdlvl_last_byte_done_int <= #TCQ 1'b0;\n              mpr_last_byte_done   <= #TCQ 1'b0;\n              cal1_state_r <= #TCQ CAL1_DONE; \n            end else if (cal1_cnt_cpt_r >= DQS_WIDTH-1) begin\n              if (~mpr_rdlvl_done_r) begin\n                mpr_rank_done_r <= #TCQ 1'b1;\n                \n                  \n                cal1_state_r <= #TCQ CAL1_DONE;\n                cal1_cnt_cpt_r <= #TCQ 'b0;\n                \n                  \n                  \n                  \n                  \n                  \n                \n              end else begin\n                \n                rdlvl_rank_done_r <= #TCQ 1'b1;\n                if (rnk_cnt_r == RANKS-1) begin\n                  \n                  cal1_state_r <= #TCQ CAL1_REGL_LOAD;\n                end else begin\n                  \n                  rnk_cnt_r      <= #TCQ rnk_cnt_r + 1;\n                  new_cnt_cpt_r  <= #TCQ 1'b1;\n                  cal1_cnt_cpt_r <= #TCQ 'b0;\n                  cal1_state_r   <= #TCQ CAL1_IDLE;\n                end\n              end\n            end else begin\n              \n              new_cnt_cpt_r  <= #TCQ 1'b1;\n              cal1_cnt_cpt_r <= #TCQ cal1_cnt_cpt_r + 1;\n              cal1_state_r   <= #TCQ CAL1_NEW_DQS_PREWAIT;\n            end\n          end\n        end\n\n        CAL1_NEW_DQS_PREWAIT: begin\n          if (!cal1_wait_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n            if (~mpr_rdlvl_done_r & (DRAM_TYPE == \"DDR3\"))\n                cal1_state_r  <= #TCQ CAL1_MPR_NEW_DQS_WAIT;\n            else\n              cal1_state_r   <= #TCQ CAL1_NEW_DQS_WAIT;\n          end\n        end\n\n        \n        CAL1_REGL_LOAD: begin\n          rdlvl_rank_done_r <= #TCQ 1'b0;\n          mpr_rank_done_r   <= #TCQ 1'b0;\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          cal1_cnt_cpt_r    <= #TCQ 'b0;\n          rnk_cnt_r         <= #TCQ 2'b00;\n          if ((regl_rank_cnt == RANKS-1) &&\n              ((regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1))) begin\n            cal1_state_r <= #TCQ CAL1_DONE;\n            rdlvl_last_byte_done_int <= #TCQ 1'b0;\n            mpr_last_byte_done   <= #TCQ 1'b0;\n          end else\n            cal1_state_r <= #TCQ CAL1_REGL_LOAD;\n        end\n\n        CAL1_RDLVL_ERR: begin\n          rdlvl_stg1_err <= #TCQ 1'b1;\n        end\n\n        \n        \n        CAL1_DONE: begin\n          mpr_rdlvl_done_r  <= #TCQ 1'b1;\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          if (~mpr_rdlvl_done_r && (OCAL_EN==\"ON\") && (DRAM_TYPE == \"DDR3\")) begin\n            rdlvl_stg1_done_int   <= #TCQ 1'b0;\n            cal1_state_r <= #TCQ CAL1_IDLE;\n          end else\n            rdlvl_stg1_done_int   <= #TCQ 1'b1;\n        end\n\n      endcase\n    end\n\n\n\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_ddr_phy_rdlvl. Module specification: This module implements a read leveling calibration algorithm for DDR memory interfaces. It adjusts the timing of read data capture to ensure proper alignment with the memory clock. The module takes inputs such as clock, reset, calibration start triggers, and read data, and outputs status signals, delay control signals, and calibration results. Key internal signals include counters for tracking calibration progress, flags for edge detection and pattern matching, and shift registers for storing read data. The module operates through several states, including initializing delays, detecting data patterns, finding valid edges of the data eye, and centering the read capture point. It supports multiple ranks and handles both DDR3 and DDR4 memory types. The calibration process involves incrementing delays, detecting data patterns, finding valid eye regions, and centering the read capture point within"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_rdlvl\n\nExplanation: This module implements a read leveling calibration algorithm for DDR memory interfaces. It adjusts the timing of read data capture to ensure proper alignment with the memory clock. The module performs edge detection, pattern matching, and delay adjustments on a per-byte and per-bit basis. It supports multiple ranks and handles both DDR3 and DDR4 memory types. The calibration process involves incrementing delays, detecting data patterns, finding valid eye regions, and centering the read capture point within the eye. The module uses both IDELAY and PHASER_IN delays to achieve fine-grained timing adjustments."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nBased on the provided Verilog code, here are the input and output ports of the mig_7series_v4_1_ddr_phy_rdlvl module:\n\nInput ports: clk, rst, mpr_rdlvl_start, rdlvl_stg1_start, prech_done, phy_if_empty, idelaye2_init_val, rd_data, dqs_po_dec_done, pi_counter_read_val, idelay_ld, wrcal_cnt, dbg_idel_up_all, dbg_idel_down_all, dbg_idel_up_cpt, dbg_idel_down_cpt, dbg_sel_idel_cpt, dbg_sel_all_idel_cpt.\n\nExplanation: These inputs include clock and reset signals, calibration start triggers, status signals from other memory controller components, read data, delay values, and debug control signals.\n\nOutput ports: mpr_rdlvl_done, mpr_last_byte_done, mpr_rnk_done, rdlvl_stg1_done, rdlvl_stg1_rnk_done, rdlvl_stg1_err, mpr_rdlvl_err, rdlvl_err, rdlvl_prech_req, rdlvl_last_byte_done, rdlvl_assrt_common, pi_fine_dly_dec_done, pi_en_stg2_f, pi_stg2_f_incdec, pi_stg2_load, pi_stg2_reg_l, pi_stg2_rdlvl_cnt, idelay_ce, idelay_inc, dlyval_dq, rdlvl_pi_incdec, dbg_cpt_first_edge_cnt, dbg_cpt_second_edge_cnt, dbg_cpt_tap_cnt, dbg_dq_idelay_tap_cnt, dbg_phy_rdlvl.\n\nExplanation: These outputs provide status signals for the read leveling process, error flags, delay control signals for fine-tuning, calibration results, and debug information for monitoring the calibration process."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: cal1_cnt_cpt_r, cal1_dlyce_cpt_r, cal1_dlyinc_cpt_r, cal1_prech_req_r, cal1_state_r, cnt_idel_dec_cpt_r, found_first_edge_r, found_second_edge_r, tap_cnt_cpt_r, tap_limit_cpt_r, sr_rise0_r, sr_fall0_r, sr_rise1_r, sr_fall1_r, sr_valid_r, store_sr_r, pat_data_match_r, detect_edge_done_r, found_edge_r, found_stable_eye_r, rdlvl_dqs_tap_cnt_r, rnk_cnt_r, rdlvl_rank_done_r.\n\nExplanation:\n- cal1_cnt_cpt_r: Counter for tracking the current DQS byte being calibrated\n- cal1_dlyce_cpt_r, cal1_dlyinc_cpt_r: Control signals for IDELAY adjustment\n- cal1_prech_req_r: Request signal for precharge operation\n- cal1_state_r: Current state of the calibration state machine\n- cnt_idel_dec_cpt_r: Counter for IDELAY decrements during centering\n- found_first_edge_r, found_second_edge_r: Flags indicating edge detection status\n- tap_cnt_cpt_r: Current tap count for IDELAY\n- tap_limit_cpt_r: Flag indicating if maximum tap count is reached\n- sr_rise0_r, sr_fall0_r, sr_rise1_r, sr_fall1_r: Shift registers for storing read data\n- sr_valid_r: Flag indicating valid data in shift registers\n- store_sr_r: Control signal to store shift register data\n- pat_data_match_r: Flag indicating a match with expected data pattern\n- detect_edge_done_r: Flag indicating completion of edge detection\n- found_edge_r: Flag indicating an edge has been found\n- found_stable_eye_r: Flag indicating a stable data eye has been found\n- rdlvl_dqs_tap_cnt_r: Array storing final tap counts for each DQS\n- rnk_cnt_r: Counter for tracking the current rank being calibrated\n- rdlvl_rank_done_r: Flag indicating completion of calibration for a rank"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\n(* use_dsp48 = \"no\" *)\n\nmodule mig_7series_v4_1_ddr_phy_rdlvl #\n  (\n   parameter TCQ             = 100,    \n   parameter nCK_PER_CLK     = 2,      \n   parameter CLK_PERIOD      = 3333,   \n   parameter DQ_WIDTH        = 64,     \n   parameter DQS_CNT_WIDTH   = 3,      \n   parameter DQS_WIDTH       = 8,      \n   parameter DRAM_WIDTH      = 8,      \n   parameter RANKS           = 1,      \n   parameter PER_BIT_DESKEW  = \"ON\",   \n   parameter SIM_CAL_OPTION  = \"NONE\", \n   parameter DEBUG_PORT      = \"OFF\",  \n   parameter DRAM_TYPE       = \"DDR3\",  \n   parameter OCAL_EN         = \"ON\",\n   parameter IDELAY_ADJ      = \"ON\",\n   parameter PI_DIV2_INCDEC  = \"TRUE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   \n   input                        mpr_rdlvl_start,\n   output                       mpr_rdlvl_done,\n   output reg                   mpr_last_byte_done,\n   output                       mpr_rnk_done,\n   input                        rdlvl_stg1_start,\n   output                       rdlvl_stg1_done ,\n   output                       rdlvl_stg1_rnk_done,\n   output reg                   rdlvl_stg1_err,\n   output                       mpr_rdlvl_err,\n   output                       rdlvl_err,\n   output reg                   rdlvl_prech_req,\n   output                       rdlvl_last_byte_done,\n   output reg                   rdlvl_assrt_common,\n   input                        prech_done,\n   input                        phy_if_empty,\n   input [4:0]                  idelaye2_init_val,\n   \n   input [2*nCK_PER_CLK*DQ_WIDTH-1:0] rd_data,\n   \n   input                        dqs_po_dec_done,\n   input [5:0]                  pi_counter_read_val,\n   \n   output reg                   pi_fine_dly_dec_done,\n   output reg                   pi_en_stg2_f,\n   output reg                   pi_stg2_f_incdec,\n   output reg                   pi_stg2_load,\n   output reg [5:0]             pi_stg2_reg_l,\n   output [DQS_CNT_WIDTH:0]     pi_stg2_rdlvl_cnt,\n   \n   \n   output                       idelay_ce,\n   output                       idelay_inc,\n   input                        idelay_ld,\n   input [DQS_CNT_WIDTH:0]      wrcal_cnt,\n   \n   output reg [5*RANKS*DQ_WIDTH-1:0] dlyval_dq,\n   \n   output reg                     rdlvl_pi_incdec,\n   \n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_first_edge_cnt,\n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_second_edge_cnt,\n   output [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_tap_cnt,\n   output [5*DQS_WIDTH*RANKS-1:0] dbg_dq_idelay_tap_cnt,\n\n   input                        dbg_idel_up_all,\n   input                        dbg_idel_down_all,\n   input                        dbg_idel_up_cpt,\n   input                        dbg_idel_down_cpt,\n   input [DQS_CNT_WIDTH-1:0]    dbg_sel_idel_cpt,\n   input                        dbg_sel_all_idel_cpt,\n   output [255:0]               dbg_phy_rdlvl\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  localparam MIN_EYE_SIZE = 16;\n\n  \n  localparam CAL_PAT_LEN = 8;\n  \n  localparam RD_SHIFT_LEN = CAL_PAT_LEN / (2*nCK_PER_CLK);\n\n  \n  \n  \n  localparam RD_SHIFT_COMP_DELAY = 5;\n\n  \n  \n  \n  \n  localparam SR_VALID_DELAY = (2 * RD_SHIFT_LEN) + RD_SHIFT_COMP_DELAY + 1;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  localparam PIPE_WAIT_CNT = (nCK_PER_CLK == 2) ? 31 : (SR_VALID_DELAY < 8) ? 16\n                                                     : (SR_VALID_DELAY + 8);\n\n  \n  \n  \n  \n  \n  localparam [11:0] DETECT_EDGE_SAMPLE_CNT0 = 12'h001; \n  localparam [11:0] DETECT_EDGE_SAMPLE_CNT1 = 12'h001;   \n\n  localparam [5:0] CAL1_IDLE                 = 6'h00;\n  localparam [5:0] CAL1_NEW_DQS_WAIT         = 6'h01;\n  localparam [5:0] CAL1_STORE_FIRST_WAIT     = 6'h02;\n  localparam [5:0] CAL1_PAT_DETECT           = 6'h03;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_INC      = 6'h04;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_INC_WAIT = 6'h05;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_DEC      = 6'h06;\n  localparam [5:0] CAL1_DQ_IDEL_TAP_DEC_WAIT = 6'h07;\n  localparam [5:0] CAL1_DETECT_EDGE          = 6'h08;\n  localparam [5:0] CAL1_IDEL_INC_CPT         = 6'h09;\n  localparam [5:0] CAL1_IDEL_INC_CPT_WAIT    = 6'h0A;\n  localparam [5:0] CAL1_CALC_IDEL            = 6'h0B;\n  localparam [5:0] CAL1_IDEL_DEC_CPT         = 6'h0C;\n  localparam [5:0] CAL1_IDEL_DEC_CPT_WAIT    = 6'h0D;\n  localparam [5:0] CAL1_NEXT_DQS             = 6'h0E;\n  localparam [5:0] CAL1_DONE                 = 6'h0F;\n  localparam [5:0] CAL1_PB_STORE_FIRST_WAIT  = 6'h10;\n  localparam [5:0] CAL1_PB_DETECT_EDGE       = 6'h11;\n  localparam [5:0] CAL1_PB_INC_CPT           = 6'h12;\n  localparam [5:0] CAL1_PB_INC_CPT_WAIT      = 6'h13;\n  localparam [5:0] CAL1_PB_DEC_CPT_LEFT      = 6'h14;\n  localparam [5:0] CAL1_PB_DEC_CPT_LEFT_WAIT = 6'h15;\n  localparam [5:0] CAL1_PB_DETECT_EDGE_DQ    = 6'h16;\n  localparam [5:0] CAL1_PB_INC_DQ            = 6'h17;\n  localparam [5:0] CAL1_PB_INC_DQ_WAIT       = 6'h18;\n  localparam [5:0] CAL1_PB_DEC_CPT           = 6'h19;\n  localparam [5:0] CAL1_PB_DEC_CPT_WAIT      = 6'h1A;\n  localparam [5:0] CAL1_REGL_LOAD            = 6'h1B;\n  localparam [5:0] CAL1_RDLVL_ERR            = 6'h1C;\n  localparam [5:0] CAL1_MPR_NEW_DQS_WAIT     = 6'h1D;\n  localparam [5:0] CAL1_VALID_WAIT           = 6'h1E;\n  localparam [5:0] CAL1_MPR_PAT_DETECT       = 6'h1F;\n  localparam [5:0] CAL1_NEW_DQS_PREWAIT      = 6'h20;\n  localparam [5:0] CAL1_RD_STOP_FOR_PI_INC   = 6'h21;\n  localparam [5:0] CAL1_CENTER_WAIT          = 6'h22;\n\n  integer    a;\n  integer    b;\n  integer    d;\n  integer    e;\n  integer    f;\n  integer    h;\n  integer    g;\n  integer    i;\n  integer    j;\n  integer    k;\n  integer    l;\n  integer    m;\n  integer    n;\n  integer    r;\n  integer    p;\n  integer    q;\n  integer    s;\n  integer    t;\n  integer    u;\n  integer    w;\n  integer    ce_i;\n  integer    ce_rnk_i;\n  integer    aa;\n  integer    bb;\n  integer    cc;\n  integer    dd;\n  genvar     x;\n  genvar     z;\n\n  reg [DQS_CNT_WIDTH:0]   cal1_cnt_cpt_r;\n  wire [DQS_CNT_WIDTH+2:0]cal1_cnt_cpt_timing;\n  reg [DQS_CNT_WIDTH:0]   cal1_cnt_cpt_timing_r;\n  reg                     cal1_dq_idel_ce;\n  reg                     cal1_dq_idel_inc;\n  reg                     cal1_dlyce_cpt_r;\n  reg                     cal1_dlyinc_cpt_r;\n  reg                     cal1_dlyce_dq_r;\n  reg                     cal1_dlyinc_dq_r;\n  reg                     cal1_wait_cnt_en_r;\n  reg [4:0]               cal1_wait_cnt_r;\n  reg                     cal1_wait_r;\n  reg [DQ_WIDTH-1:0]      dlyce_dq_r;\n  reg                     dlyinc_dq_r;\n  reg [4:0]               dlyval_dq_reg_r [0:RANKS-1][0:DQ_WIDTH-1];\n  reg                     cal1_prech_req_r;\n  reg [5:0]               cal1_state_r;\n  reg [5:0]               cal1_state_r1;\n  reg [5:0]               cal1_state_r2;\n  reg [5:0]               cal1_state_r3;\n  reg [5:0]               cnt_idel_dec_cpt_r;\n  reg [3:0]               cnt_shift_r;\n  reg                     detect_edge_done_r;\n  reg [5:0]               right_edge_taps_r;\n  reg [5:0]               first_edge_taps_r;\n  reg                     found_edge_r;\n  reg                     found_first_edge_r;\n  reg                     found_second_edge_r;\n  reg                     found_stable_eye_r;\n  reg                     found_stable_eye_last_r;\n  reg                     found_edge_all_r;\n  reg [5:0]               tap_cnt_cpt_r;\n  reg                     tap_limit_cpt_r;\n  reg [4:0]               idel_tap_cnt_dq_pb_r;\n  reg                     idel_tap_limit_dq_pb_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall0_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall1_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise0_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise1_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall2_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_fall3_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise2_r;\n  reg [DRAM_WIDTH-1:0]    mux_rd_rise3_r;\n  reg                     mux_rd_valid_r;\n  reg                     new_cnt_cpt_r;\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  old_sr_rise3_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_fall3_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_rise3_r;\n  reg [4:0]               pb_cnt_eye_size_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    pb_detect_edge_done_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_edge_last_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_edge_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_first_edge_r;\n  reg [DRAM_WIDTH-1:0]    pb_found_stable_eye_r;\n  reg [DRAM_WIDTH-1:0]    pb_last_tap_jitter_r;\n  reg             pi_en_stg2_f_timing;\n  reg             pi_stg2_f_incdec_timing;\n  reg             pi_stg2_load_timing;\n  reg [5:0]           pi_stg2_reg_l_timing;\n  reg [DRAM_WIDTH-1:0]    prev_sr_diff_r;\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  prev_sr_rise3_r [DRAM_WIDTH-1:0];\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_cyc2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_fall3_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    prev_sr_match_rise3_r;\n  wire [DQ_WIDTH-1:0]     rd_data_rise0;\n  wire [DQ_WIDTH-1:0]     rd_data_fall0;\n  wire [DQ_WIDTH-1:0]     rd_data_rise1;\n  wire [DQ_WIDTH-1:0]     rd_data_fall1;\n  wire [DQ_WIDTH-1:0]     rd_data_rise2;\n  wire [DQ_WIDTH-1:0]     rd_data_fall2;\n  wire [DQ_WIDTH-1:0]     rd_data_rise3;\n  wire [DQ_WIDTH-1:0]     rd_data_fall3;\n  reg                     samp_cnt_done_r;\n  reg                     samp_edge_cnt0_en_r;\n  reg [11:0]              samp_edge_cnt0_r;\n  reg                     samp_edge_cnt1_en_r;\n  reg [11:0]              samp_edge_cnt1_r;\n  reg [DQS_CNT_WIDTH:0]   rd_mux_sel_r;\n  reg [5:0]               second_edge_taps_r;\n  reg [RD_SHIFT_LEN-1:0]  sr_fall0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise0_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise1_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_fall3_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise2_r [DRAM_WIDTH-1:0];\n  reg [RD_SHIFT_LEN-1:0]  sr_rise3_r [DRAM_WIDTH-1:0];\n  reg                     store_sr_r;\n  reg                     store_sr_req_pulsed_r;\n  reg                     store_sr_req_r;\n  reg                     sr_valid_r;\n  reg                     sr_valid_r1;\n  reg                     sr_valid_r2;\n  reg [DRAM_WIDTH-1:0]    old_sr_diff_r;\n  reg [DRAM_WIDTH-1:0]    old_sr_match_cyc2_r;\n  reg                     pat0_data_match_r;\n  reg                     pat1_data_match_r;\n  wire                    pat_data_match_r;\n  wire [RD_SHIFT_LEN-1:0] pat0_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_fall3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_fall3 [3:0];\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall0_r;\n  reg                     pat0_match_fall0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall1_r;\n  reg                     pat0_match_fall1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall2_r;\n  reg                     pat0_match_fall2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_fall3_r;\n  reg                     pat0_match_fall3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise0_r;\n  reg                     pat0_match_rise0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise1_r;\n  reg                     pat0_match_rise1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise2_r;\n  reg                     pat0_match_rise2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat0_match_rise3_r;\n  reg                     pat0_match_rise3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall0_r;\n  reg                     pat1_match_fall0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall1_r;\n  reg                     pat1_match_fall1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall2_r;\n  reg                     pat1_match_fall2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_fall3_r;\n  reg                     pat1_match_fall3_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise0_r;\n  reg                     pat1_match_rise0_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise1_r;\n  reg                     pat1_match_rise1_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise2_r;\n  reg                     pat1_match_rise2_and_r;\n  reg [DRAM_WIDTH-1:0]    pat1_match_rise3_r;\n  reg                     pat1_match_rise3_and_r;\n  reg [4:0]               idelay_tap_cnt_r [0:RANKS-1][0:DQS_WIDTH-1];\n  reg [5*DQS_WIDTH*RANKS-1:0] idelay_tap_cnt_w;\n  reg [4:0]               idelay_tap_cnt_slice_r;\n  reg                     idelay_tap_limit_r;\n\n  wire [RD_SHIFT_LEN-1:0] pat0_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat0_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] pat1_rise3 [3:0];\n\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat0_fall3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall0 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall1 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall2 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_rise3 [3:0];\n  wire [RD_SHIFT_LEN-1:0] idel_pat1_fall3 [3:0];\n\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_rise3_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat0_match_fall3_r;\n\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall0_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall1_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall2_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_rise3_r;\n  reg [DRAM_WIDTH-1:0]    idel_pat1_match_fall3_r;\n\n  reg                     idel_pat0_match_rise0_and_r;\n  reg                     idel_pat0_match_fall0_and_r;\n  reg                     idel_pat0_match_rise1_and_r;\n  reg                     idel_pat0_match_fall1_and_r;\n  reg                     idel_pat0_match_rise2_and_r;\n  reg                     idel_pat0_match_fall2_and_r;\n  reg                     idel_pat0_match_rise3_and_r;\n  reg                     idel_pat0_match_fall3_and_r;\n\n  reg                     idel_pat1_match_rise0_and_r;\n  reg                     idel_pat1_match_fall0_and_r;\n  reg                     idel_pat1_match_rise1_and_r;\n  reg                     idel_pat1_match_fall1_and_r;\n  reg                     idel_pat1_match_rise2_and_r;\n  reg                     idel_pat1_match_fall2_and_r;\n  reg                     idel_pat1_match_rise3_and_r;\n  reg                     idel_pat1_match_fall3_and_r;\n\n  reg                     idel_pat0_data_match_r;\n  reg                     idel_pat1_data_match_r;\n\n  reg                     idel_pat_data_match;\n  reg                     idel_pat_data_match_r;\n\n  reg [4:0]               idel_dec_cnt;\n\n  reg [5:0]               rdlvl_dqs_tap_cnt_r [0:RANKS-1][0:DQS_WIDTH-1];\n  reg [1:0]               rnk_cnt_r;\n  reg                     rdlvl_rank_done_r;\n\n  reg [3:0]               done_cnt;\n  reg [1:0]               regl_rank_cnt;\n  reg [DQS_CNT_WIDTH:0]   regl_dqs_cnt;\n  reg [DQS_CNT_WIDTH:0]   regl_dqs_cnt_r;\n  wire [DQS_CNT_WIDTH+2:0]regl_dqs_cnt_timing;\n  reg                     regl_rank_done_r;\n  reg                     rdlvl_stg1_start_r;\n\n  reg                     dqs_po_dec_done_r1;\n  reg                     dqs_po_dec_done_r2;\n  reg                     fine_dly_dec_done_r1;\n  reg                     fine_dly_dec_done_r2;\n  reg                     fine_dly_dec_done_r3;\n  reg                     fine_dly_dec_done_r4;\n  reg [3:0]               wait_cnt_r;\n  reg [5:0]               pi_rdval_cnt;\n  reg                     pi_cnt_dec;\n\n  reg                     mpr_valid_r;\n  reg                     mpr_valid_r1;\n  reg                     mpr_valid_r2;\n  reg                     mpr_rd_rise0_prev_r;\n  reg                     mpr_rd_fall0_prev_r;\n  reg                     mpr_rd_rise1_prev_r;\n  reg                     mpr_rd_fall1_prev_r;\n  reg                     mpr_rd_rise2_prev_r;\n  reg                     mpr_rd_fall2_prev_r;\n  reg                     mpr_rd_rise3_prev_r;\n  reg                     mpr_rd_fall3_prev_r;\n  reg                     mpr_rdlvl_done_r;\n  reg                     mpr_rdlvl_done_r1;\n  reg                     mpr_rdlvl_done_r2;\n  reg                     mpr_rdlvl_start_r;\n  reg                     mpr_rank_done_r;\n  reg [2:0]               stable_idel_cnt;\n  reg                     inhibit_edge_detect_r;\n  reg                     idel_pat_detect_valid_r;\n  reg                     idel_mpr_pat_detect_r;\n  reg                     mpr_pat_detect_r;\n  reg                     mpr_dec_cpt_r;\n  reg                     idel_adj_inc;   \n  wire [1:0]              idelay_adj;\n  wire                    pb_detect_edge_setup;\n  wire                    pb_detect_edge;\n  \n  reg [6*DQS_WIDTH-1:0] dbg_cpt_first_edge_taps;\n  reg [6*DQS_WIDTH-1:0] dbg_cpt_second_edge_taps;\n  reg [6*DQS_WIDTH*RANKS-1:0] dbg_cpt_tap_cnt_w;\n  reg rdlvl_stg1_done_int;\n  reg rdlvl_stg1_done_int_r1, rdlvl_stg1_done_int_r2, rdlvl_stg1_done_int_r3;\n  reg rdlvl_last_byte_done_int;\n  reg rdlvl_last_byte_done_int_r1, rdlvl_last_byte_done_int_r2, rdlvl_last_byte_done_int_r3;\n\n\n  \n  \n  \n  \n  assign idelay_adj = (IDELAY_ADJ == \"ON\") ? 2'b10: 2'b00;\n\n  \n  \n  \n\n  always @(*) begin\n    for (d = 0; d < RANKS; d = d + 1) begin\n      for (e = 0; e < DQS_WIDTH; e = e + 1) begin\n        idelay_tap_cnt_w[(5*e+5*DQS_WIDTH*d)+:5] = idelay_tap_cnt_r[d][e];\n        dbg_cpt_tap_cnt_w[(6*e+6*DQS_WIDTH*d)+:6] = rdlvl_dqs_tap_cnt_r[d][e];\n      end\n    end\n  end\n\n  assign mpr_rdlvl_err         = rdlvl_stg1_err & (!mpr_rdlvl_done);\n  assign rdlvl_err              = rdlvl_stg1_err & (mpr_rdlvl_done);\n\n\n  assign dbg_phy_rdlvl[0]      = rdlvl_stg1_start;\n  assign dbg_phy_rdlvl[1]      = pat_data_match_r;\n  assign dbg_phy_rdlvl[2]      = mux_rd_valid_r;\n  assign dbg_phy_rdlvl[3]      = idelay_tap_limit_r;\n  assign dbg_phy_rdlvl[8:4]    = 'b0;\n  assign dbg_phy_rdlvl[14:9]   = cal1_state_r[5:0];\n  assign dbg_phy_rdlvl[20:15]  = cnt_idel_dec_cpt_r;\n  assign dbg_phy_rdlvl[21]     = found_first_edge_r;\n  assign dbg_phy_rdlvl[22]     = found_second_edge_r;\n  assign dbg_phy_rdlvl[23]     = found_edge_r;\n  assign dbg_phy_rdlvl[24]     = store_sr_r;\n  \n  \n  assign dbg_phy_rdlvl[40:25]  = 'b0;\n  assign dbg_phy_rdlvl[41]     = sr_valid_r;\n  assign dbg_phy_rdlvl[42]     = found_stable_eye_r;\n  assign dbg_phy_rdlvl[48:43]  = tap_cnt_cpt_r;\n  assign dbg_phy_rdlvl[54:49]  = first_edge_taps_r;\n  assign dbg_phy_rdlvl[60:55]  = second_edge_taps_r;\n  assign dbg_phy_rdlvl[64:61]  = cal1_cnt_cpt_timing_r;\n  assign dbg_phy_rdlvl[65]     = cal1_dlyce_cpt_r;\n  assign dbg_phy_rdlvl[66]     = cal1_dlyinc_cpt_r;\n  assign dbg_phy_rdlvl[67]     = found_edge_r;\n  assign dbg_phy_rdlvl[68]     = found_first_edge_r;\n  assign dbg_phy_rdlvl[73:69]  = 'b0;\n  assign dbg_phy_rdlvl[74]     = idel_pat_data_match;\n  assign dbg_phy_rdlvl[75]     = idel_pat0_data_match_r;\n  assign dbg_phy_rdlvl[76]     = idel_pat1_data_match_r;\n  assign dbg_phy_rdlvl[77]     = pat0_data_match_r;\n  assign dbg_phy_rdlvl[78]     = pat1_data_match_r;\n  assign dbg_phy_rdlvl[79+:5*DQS_WIDTH*RANKS] = idelay_tap_cnt_w;\n  assign dbg_phy_rdlvl[170+:8] = mux_rd_rise0_r;\n  assign dbg_phy_rdlvl[178+:8] = mux_rd_fall0_r;\n  assign dbg_phy_rdlvl[186+:8] = mux_rd_rise1_r;\n  assign dbg_phy_rdlvl[194+:8] = mux_rd_fall1_r;\n  assign dbg_phy_rdlvl[202+:8] = mux_rd_rise2_r;\n  assign dbg_phy_rdlvl[210+:8] = mux_rd_fall2_r;\n  assign dbg_phy_rdlvl[218+:8] = mux_rd_rise3_r;\n  assign dbg_phy_rdlvl[226+:8] = mux_rd_fall3_r;\n\n  \n  \n  \n\n  \n  assign dbg_cpt_first_edge_cnt  = dbg_cpt_first_edge_taps;\n  assign dbg_cpt_second_edge_cnt = dbg_cpt_second_edge_taps;\n  assign dbg_cpt_tap_cnt         = dbg_cpt_tap_cnt_w;\n  assign dbg_dq_idelay_tap_cnt   = idelay_tap_cnt_w;\n\n  \n\n  generate\n    always @(posedge clk)\n      if (rst || (rdlvl_stg1_start && ~rdlvl_stg1_start_r)) begin\n        dbg_cpt_first_edge_taps  <= #TCQ 'b0;\n        dbg_cpt_second_edge_taps <= #TCQ 'b0;\n      end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (cal1_state_r1 == CAL1_CALC_IDEL)) begin\n        \n          for (ce_i = 0; ce_i < DQS_WIDTH; ce_i = ce_i + 1) begin: gen_dbg_cpt_edge\n            if (found_first_edge_r)\n              dbg_cpt_first_edge_taps[(6*ce_i)+:6]\n                  <= #TCQ first_edge_taps_r;\n            if (found_second_edge_r)\n              dbg_cpt_second_edge_taps[(6*ce_i)+:6]\n                  <= #TCQ second_edge_taps_r;\n          end\n        \n      end else if (cal1_state_r == CAL1_CALC_IDEL) begin\n        \n        \n        \n          if (found_first_edge_r)\n            dbg_cpt_first_edge_taps[((cal1_cnt_cpt_timing <<2) + (cal1_cnt_cpt_timing <<1))+:6]\n              <= #TCQ first_edge_taps_r;\n          if (found_second_edge_r)\n            dbg_cpt_second_edge_taps[((cal1_cnt_cpt_timing <<2) + (cal1_cnt_cpt_timing <<1))+:6]\n              <= #TCQ second_edge_taps_r;\n      end\n  endgenerate\n\n  assign rdlvl_stg1_rnk_done = rdlvl_rank_done_r;\n  assign mpr_rnk_done        = mpr_rank_done_r;\n  assign mpr_rdlvl_done      = ((DRAM_TYPE == \"DDR3\") && (OCAL_EN == \"ON\")) ? \n                                mpr_rdlvl_done_r : 1'b1;\n\n   \n   \n   \n   \n   assign pi_stg2_rdlvl_cnt = (((PI_DIV2_INCDEC == \"TRUE\") && (cal1_state_r3 == CAL1_REGL_LOAD)) || ((PI_DIV2_INCDEC == \"FALSE\") && (cal1_state_r == CAL1_REGL_LOAD))) ? regl_dqs_cnt_r : cal1_cnt_cpt_r;\n   assign rdlvl_stg1_done   = (PI_DIV2_INCDEC == \"TRUE\") ? rdlvl_stg1_done_int_r3 : rdlvl_stg1_done_int;\n   assign rdlvl_last_byte_done = (PI_DIV2_INCDEC == \"TRUE\") ? rdlvl_last_byte_done_int_r3 : rdlvl_last_byte_done_int;\n\n   always @ (posedge clk) begin\n     rdlvl_stg1_done_int_r1 <= #TCQ rdlvl_stg1_done_int;\n     rdlvl_stg1_done_int_r2 <= #TCQ rdlvl_stg1_done_int_r1;\n     rdlvl_stg1_done_int_r3 <= #TCQ rdlvl_stg1_done_int_r2;\n     rdlvl_last_byte_done_int_r1 <= #TCQ rdlvl_last_byte_done_int;\n     rdlvl_last_byte_done_int_r2 <= #TCQ rdlvl_last_byte_done_int_r1;\n     rdlvl_last_byte_done_int_r3 <= #TCQ rdlvl_last_byte_done_int_r2;\n   end\n\n   assign idelay_ce  = cal1_dq_idel_ce;\n   assign idelay_inc = cal1_dq_idel_inc;\n\n  \n  \n  \n  \n\n  always @(posedge clk) begin\n    if (rst)\n      rdlvl_assrt_common <= #TCQ 1'b0;\n    else if ((SIM_CAL_OPTION == \"FAST_CAL\") & rdlvl_stg1_start &\n            !rdlvl_stg1_start_r)\n      rdlvl_assrt_common <= #TCQ 1'b1;\n    else if (!idel_pat_data_match_r & idel_pat_data_match)\n      rdlvl_assrt_common <= #TCQ 1'b0;\n  end\n\n  \n  \n  \n  \n\n  generate\n    if (nCK_PER_CLK == 4) begin: rd_data_div4_logic_clk\n      assign rd_data_rise0 = rd_data[DQ_WIDTH-1:0];\n      assign rd_data_fall0 = rd_data[2*DQ_WIDTH-1:DQ_WIDTH];\n      assign rd_data_rise1 = rd_data[3*DQ_WIDTH-1:2*DQ_WIDTH];\n      assign rd_data_fall1 = rd_data[4*DQ_WIDTH-1:3*DQ_WIDTH];\n      assign rd_data_rise2 = rd_data[5*DQ_WIDTH-1:4*DQ_WIDTH];\n      assign rd_data_fall2 = rd_data[6*DQ_WIDTH-1:5*DQ_WIDTH];\n      assign rd_data_rise3 = rd_data[7*DQ_WIDTH-1:6*DQ_WIDTH];\n      assign rd_data_fall3 = rd_data[8*DQ_WIDTH-1:7*DQ_WIDTH];\n    end else begin: rd_data_div2_logic_clk\n      assign rd_data_rise0 = rd_data[DQ_WIDTH-1:0];\n      assign rd_data_fall0 = rd_data[2*DQ_WIDTH-1:DQ_WIDTH];\n      assign rd_data_rise1 = rd_data[3*DQ_WIDTH-1:2*DQ_WIDTH];\n      assign rd_data_fall1 = rd_data[4*DQ_WIDTH-1:3*DQ_WIDTH];\n    end\n  endgenerate\n\n  always @(posedge clk) begin\n    rd_mux_sel_r <= #TCQ cal1_cnt_cpt_r;\n  end\n\n  \n  \n  \n  generate\n    genvar mux_i;\n    for (mux_i = 0; mux_i < DRAM_WIDTH; mux_i = mux_i + 1) begin: gen_mux_rd\n      always @(posedge clk) begin\n        mux_rd_rise0_r[mux_i] <= #TCQ rd_data_rise0[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall0_r[mux_i] <= #TCQ rd_data_fall0[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise1_r[mux_i] <= #TCQ rd_data_rise1[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall1_r[mux_i] <= #TCQ rd_data_fall1[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise2_r[mux_i] <= #TCQ rd_data_rise2[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall2_r[mux_i] <= #TCQ rd_data_fall2[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_rise3_r[mux_i] <= #TCQ rd_data_rise3[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n        mux_rd_fall3_r[mux_i] <= #TCQ rd_data_fall3[DRAM_WIDTH*rd_mux_sel_r +\n                                                    mux_i];\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n  \n  \n   always @(posedge clk)begin\n     if ((cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) ||\n        ((cal1_state_r == CAL1_MPR_PAT_DETECT) && (idel_pat_detect_valid_r)))begin\n       mpr_rd_rise0_prev_r <= #TCQ mux_rd_rise0_r[0];\n       mpr_rd_fall0_prev_r <= #TCQ mux_rd_fall0_r[0];\n       mpr_rd_rise1_prev_r <= #TCQ mux_rd_rise1_r[0];\n       mpr_rd_fall1_prev_r <= #TCQ mux_rd_fall1_r[0];\n       mpr_rd_rise2_prev_r <= #TCQ mux_rd_rise2_r[0];\n       mpr_rd_fall2_prev_r <= #TCQ mux_rd_fall2_r[0];\n       mpr_rd_rise3_prev_r <= #TCQ mux_rd_rise3_r[0];\n       mpr_rd_fall3_prev_r <= #TCQ mux_rd_fall3_r[0];\n     end\n   end\n\n   generate\n    if (nCK_PER_CLK == 4) begin: mpr_4to1\n   \n   always @(posedge clk) begin\n      if (rst | (cal1_state_r == CAL1_NEW_DQS_PREWAIT) |\n         \n         (mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) |\n         (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) |\n         (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) |\n         (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]) |\n         (mpr_rd_rise2_prev_r != mux_rd_rise2_r[0]) |\n         (mpr_rd_fall2_prev_r != mux_rd_fall2_r[0]) |\n         (mpr_rd_rise3_prev_r != mux_rd_rise3_r[0]) |\n         (mpr_rd_fall3_prev_r != mux_rd_fall3_r[0]))\n        stable_idel_cnt <= #TCQ 3'd0;\n      else if ((|idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing]) &\n               ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n               (idel_pat_detect_valid_r))) begin\n        if ((mpr_rd_rise0_prev_r == mux_rd_rise0_r[0]) &\n            (mpr_rd_fall0_prev_r == mux_rd_fall0_r[0]) &\n            (mpr_rd_rise1_prev_r == mux_rd_rise1_r[0]) &\n            (mpr_rd_fall1_prev_r == mux_rd_fall1_r[0]) &\n            (mpr_rd_rise2_prev_r == mux_rd_rise2_r[0]) &\n            (mpr_rd_fall2_prev_r == mux_rd_fall2_r[0]) &\n            (mpr_rd_rise3_prev_r == mux_rd_rise3_r[0]) &\n            (mpr_rd_fall3_prev_r == mux_rd_fall3_r[0]) &\n            (stable_idel_cnt < 3'd2))\n          stable_idel_cnt <= #TCQ stable_idel_cnt + 1;\n      end\n   end\n\n   always @(posedge clk) begin\n     if (rst |\n         (mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n          mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r &\n          mpr_rd_rise2_prev_r & ~mpr_rd_fall2_prev_r &\n          mpr_rd_rise3_prev_r & ~mpr_rd_fall3_prev_r))\n       inhibit_edge_detect_r <= 1'b1;\n     \n     \n     else if ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n              (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd1) &\n              (~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n               ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r &\n               ~mpr_rd_rise2_prev_r & mpr_rd_fall2_prev_r &\n               ~mpr_rd_rise3_prev_r & mpr_rd_fall3_prev_r))\n       inhibit_edge_detect_r <= 1'b0;\n   end\n\n   \n   always @(posedge clk)begin\n     if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n         inhibit_edge_detect_r)\n       idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n     \n     else if ((mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n               mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r &\n               mpr_rd_rise2_prev_r & ~mpr_rd_fall2_prev_r &\n               mpr_rd_rise3_prev_r & ~mpr_rd_fall3_prev_r) ||\n              ((stable_idel_cnt < 3'd2) & (cal1_state_r == CAL1_MPR_PAT_DETECT)\n               && (idel_pat_detect_valid_r)))\n              \n       idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n     \n     else if ((~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n               ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r &\n               ~mpr_rd_rise2_prev_r & mpr_rd_fall2_prev_r &\n               ~mpr_rd_rise3_prev_r & mpr_rd_fall3_prev_r) &\n               (stable_idel_cnt == 3'd2) &\n               ((mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) ||\n                (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) ||\n                (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) ||\n                (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]) ||\n                (mpr_rd_rise2_prev_r != mux_rd_rise2_r[0]) ||\n                (mpr_rd_fall2_prev_r != mux_rd_fall2_r[0]) ||\n                (mpr_rd_rise3_prev_r != mux_rd_rise3_r[0]) ||\n                (mpr_rd_fall3_prev_r != mux_rd_fall3_r[0])))\n       idel_mpr_pat_detect_r     <= #TCQ 1'b1;\n   end\n    end else if (nCK_PER_CLK == 2) begin: mpr_2to1\n      \n      always @(posedge clk) begin\n         if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n            (mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) |\n            (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) |\n            (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) |\n            (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0]))\n           stable_idel_cnt <= #TCQ 3'd0;\n         else if ((idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd0) &\n                  ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n                  (idel_pat_detect_valid_r))) begin\n           if ((mpr_rd_rise0_prev_r == mux_rd_rise0_r[0]) &\n               (mpr_rd_fall0_prev_r == mux_rd_fall0_r[0]) &\n               (mpr_rd_rise1_prev_r == mux_rd_rise1_r[0]) &\n               (mpr_rd_fall1_prev_r == mux_rd_fall1_r[0]) &\n               (stable_idel_cnt < 3'd2))\n             stable_idel_cnt <= #TCQ stable_idel_cnt + 1;\n         end\n      end\n\n      always @(posedge clk) begin\n        if (rst |\n            (mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n             mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r))\n          inhibit_edge_detect_r <= 1'b1;\n        else if ((cal1_state_r == CAL1_MPR_PAT_DETECT) &\n                 (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] > 5'd1) &\n                 (~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n                  ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r))\n          inhibit_edge_detect_r <= 1'b0;\n      end\n\n      \n      always @(posedge clk)begin\n        if (rst | (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) |\n            inhibit_edge_detect_r)\n          idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n        \n        else if ((mpr_rd_rise0_prev_r & ~mpr_rd_fall0_prev_r &\n                  mpr_rd_rise1_prev_r & ~mpr_rd_fall1_prev_r) ||\n                 ((stable_idel_cnt < 3'd2) & (cal1_state_r == CAL1_MPR_PAT_DETECT)\n                 & (idel_pat_detect_valid_r)))\n                 \n          idel_mpr_pat_detect_r     <= #TCQ 1'b0;\n        \n        else if ((~mpr_rd_rise0_prev_r & mpr_rd_fall0_prev_r &\n                  ~mpr_rd_rise1_prev_r & mpr_rd_fall1_prev_r) &\n                  (stable_idel_cnt == 3'd2) &\n                  ((mpr_rd_rise0_prev_r != mux_rd_rise0_r[0]) ||\n                   (mpr_rd_fall0_prev_r != mux_rd_fall0_r[0]) ||\n                   (mpr_rd_rise1_prev_r != mux_rd_rise1_r[0]) ||\n                   (mpr_rd_fall1_prev_r != mux_rd_fall1_r[0])))\n          idel_mpr_pat_detect_r     <= #TCQ 1'b1;\n      end\n    end\n  endgenerate\n\n\n\n  \n  always @(posedge clk)\n    mux_rd_valid_r <= #TCQ ~phy_if_empty;\n\n\n  \n  \n  \n  \n\n     always @(posedge clk) begin\n       dqs_po_dec_done_r1 <= #TCQ dqs_po_dec_done;\n       dqs_po_dec_done_r2 <= #TCQ dqs_po_dec_done_r1;\n       fine_dly_dec_done_r2 <= #TCQ fine_dly_dec_done_r1;\n       fine_dly_dec_done_r3 <= #TCQ fine_dly_dec_done_r2;\n       fine_dly_dec_done_r4 <= #TCQ fine_dly_dec_done_r3;\n       if (PI_DIV2_INCDEC == \"TRUE\")\n         pi_fine_dly_dec_done <= #TCQ fine_dly_dec_done_r4;\n       else\n       pi_fine_dly_dec_done <= #TCQ fine_dly_dec_done_r2;\n     end\n\n     always @(posedge clk) begin\n       if (rst || pi_cnt_dec)\n         wait_cnt_r <= #TCQ 'd8;\n       else if (dqs_po_dec_done_r2 && (wait_cnt_r > 'd0))\n         wait_cnt_r <= #TCQ wait_cnt_r - 1;\n     end\n\n     always @(posedge clk) begin\n     if (rst) begin\n       pi_rdval_cnt    <= #TCQ 'd0;\n     end else if (dqs_po_dec_done_r1 && ~dqs_po_dec_done_r2) begin\n       pi_rdval_cnt    <= #TCQ pi_counter_read_val;\n     end else if (pi_rdval_cnt > 'd0) begin\n       if (pi_cnt_dec)\n         pi_rdval_cnt  <= #TCQ pi_rdval_cnt - 1;\n       else\n         pi_rdval_cnt  <= #TCQ pi_rdval_cnt;\n     end else if (pi_rdval_cnt == 'd0) begin\n       pi_rdval_cnt    <= #TCQ pi_rdval_cnt;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (pi_rdval_cnt == 'd0))\n       pi_cnt_dec      <= #TCQ 1'b0;\n     else if (dqs_po_dec_done_r2 && (pi_rdval_cnt > 'd0)\n                  && (wait_cnt_r == 'd1))\n       pi_cnt_dec      <= #TCQ 1'b1;\n     else\n       pi_cnt_dec      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst) begin\n       fine_dly_dec_done_r1 <= #TCQ 1'b0;\n     end else if (((pi_cnt_dec == 'd1) && (pi_rdval_cnt == 'd1)) ||\n                  (dqs_po_dec_done_r2 && (pi_rdval_cnt == 'd0))) begin\n       fine_dly_dec_done_r1 <= #TCQ 1'b1;\n     end\n   end\n\n  \n  \n  \n\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      pi_en_stg2_f_timing     <= #TCQ 'b0;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end else if (pi_cnt_dec) begin\n      pi_en_stg2_f_timing     <= #TCQ 'b1;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end else if (cal1_dlyce_cpt_r) begin\n      if ((SIM_CAL_OPTION == \"NONE\") ||\n          (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n        \n        pi_en_stg2_f_timing     <= #TCQ 1'b1;\n        pi_stg2_f_incdec_timing <= #TCQ cal1_dlyinc_cpt_r;\n      end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n        \n        \n        \n        pi_en_stg2_f_timing     <= #TCQ 1'b1;\n        pi_stg2_f_incdec_timing <= #TCQ cal1_dlyinc_cpt_r;\n      end\n    end else begin\n      pi_en_stg2_f_timing     <= #TCQ 'b0;\n      pi_stg2_f_incdec_timing <= #TCQ 'b0;\n    end\n  end\n\n  \n  always @(posedge clk) begin\n    pi_en_stg2_f     <= #TCQ pi_en_stg2_f_timing;\n    pi_stg2_f_incdec <= #TCQ pi_stg2_f_incdec_timing;\n  end\n\n   \n   \n   always @(posedge clk) begin\n     if (rst)\n       done_cnt <= #TCQ 'b0;\n     else if (((cal1_state_r == CAL1_REGL_LOAD) &&\n               (cal1_state_r1 == CAL1_NEXT_DQS)) ||\n              ((done_cnt == 4'd1) && (cal1_state_r != CAL1_DONE)))\n       done_cnt <= #TCQ 4'b1010;\n     else if (done_cnt > 'b0)\n       done_cnt <= #TCQ done_cnt - 1;\n   end\n\n   \n   \n   \n   \n   always @(posedge clk) begin\n     if (rst || (regl_rank_done_r == 1'b1))\n       regl_rank_done_r <= #TCQ 1'b0;\n     else if ((regl_dqs_cnt == DQS_WIDTH-1) &&\n              (regl_rank_cnt != RANKS-1) &&\n              (done_cnt == 4'd1))\n       regl_rank_done_r <= #TCQ 1'b1;\n   end\n\n   \n   \n   \n   \n   \n   \n   assign regl_dqs_cnt_timing = {2'd0, regl_dqs_cnt};\n\n   \n   \n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0)) begin\n       pi_stg2_load_timing    <= #TCQ 'b0;\n       pi_stg2_reg_l_timing   <= #TCQ 'b0;\n     end else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n                  (regl_dqs_cnt <= DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       pi_stg2_load_timing  <= #TCQ 'b1;\n       pi_stg2_reg_l_timing <= #TCQ\n         rdlvl_dqs_tap_cnt_r[rnk_cnt_r][regl_dqs_cnt];\n     end else begin\n       pi_stg2_load_timing  <= #TCQ 'b0;\n       pi_stg2_reg_l_timing <= #TCQ 'b0;\n     end\n   end\n\n   \n   always @(posedge clk) begin\n     pi_stg2_load  <= #TCQ pi_stg2_load_timing;\n     pi_stg2_reg_l <= #TCQ pi_stg2_reg_l_timing;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0) ||\n         (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n       regl_rank_cnt   <= #TCQ 2'b00;\n     else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n              (regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       if (regl_rank_cnt == RANKS-1)\n         regl_rank_cnt  <= #TCQ regl_rank_cnt;\n       else\n         regl_rank_cnt <= #TCQ regl_rank_cnt + 1;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0) ||\n         (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n       regl_dqs_cnt    <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n     else if ((cal1_state_r == CAL1_REGL_LOAD) &&\n              (regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1)) begin\n       if (regl_rank_cnt == RANKS-1)\n         regl_dqs_cnt  <= #TCQ regl_dqs_cnt;\n       else\n         regl_dqs_cnt  <= #TCQ 'b0;\n     end else if ((cal1_state_r == CAL1_REGL_LOAD) && (regl_dqs_cnt != DQS_WIDTH-1)\n                  && (done_cnt == 4'd1))\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt + 1;\n     else\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt;\n   end\n\n\n   always @(posedge clk)\n     regl_dqs_cnt_r <= #TCQ regl_dqs_cnt;\n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  generate\n    for (z = 0; z < DQS_WIDTH; z = z + 1) begin: gen_dlyce_dq\n      always @(posedge clk)\n        if (rst)\n          dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n        else\n          if (SIM_CAL_OPTION == \"SKIP_CAL\")\n            \n            \n            dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n          else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n            \n            \n            \n            for (h = 0; h < DRAM_WIDTH; h = h + 1) begin\n              dlyce_dq_r[DRAM_WIDTH*z + h] <= #TCQ cal1_dlyce_dq_r;\n            end\n          end else if ((SIM_CAL_OPTION == \"NONE\") ||\n                   (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n            if (cal1_cnt_cpt_r == z) begin\n              for (g = 0; g < DRAM_WIDTH; g = g + 1) begin\n                dlyce_dq_r[DRAM_WIDTH*z + g]\n                <= #TCQ cal1_dlyce_dq_r;\n              end\n            end else\n              dlyce_dq_r[DRAM_WIDTH*z+:DRAM_WIDTH] <= #TCQ 'b0;\n          end\n    end\n  endgenerate\n\n  \n  always @(posedge clk)\n    if (rst)\n      dlyinc_dq_r <= #TCQ 1'b0;\n    else\n      dlyinc_dq_r <= #TCQ cal1_dlyinc_dq_r;\n\n\n  \n  \n  always @(posedge clk)\n    \n    if (rst | (SIM_CAL_OPTION == \"SKIP_CAL\")) begin\n      for (aa = 0; aa < RANKS; aa = aa + 1) begin: rst_dlyval_dq_reg_r\n        for (bb = 0; bb < DQ_WIDTH; bb = bb + 1)\n          dlyval_dq_reg_r[aa][bb] <= #TCQ 'b0;\n      end\n    end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n      for (n = 0; n < RANKS; n = n + 1) begin: gen_dlyval_dq_reg_rnk\n        for (r = 0; r < DQ_WIDTH; r = r + 1) begin: gen_dlyval_dq_reg\n          if (dlyce_dq_r[r]) begin\n            if (dlyinc_dq_r)\n              dlyval_dq_reg_r[n][r] <= #TCQ dlyval_dq_reg_r[n][r] + 5'h01;\n            else\n              dlyval_dq_reg_r[n][r] <= #TCQ dlyval_dq_reg_r[n][r] - 5'h01;\n          end\n        end\n      end\n    end else begin\n      if (dlyce_dq_r[cal1_cnt_cpt_r]) begin\n        if (dlyinc_dq_r)\n          dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] <= #TCQ\n            dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] + 5'h01;\n        else\n          dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] <= #TCQ\n            dlyval_dq_reg_r[rnk_cnt_r][cal1_cnt_cpt_r] - 5'h01;\n      end\n    end\n\n  \n  always @(posedge clk) begin\n    for (cc = 0; cc < RANKS; cc = cc + 1) begin: dlyval_dq_assgn\n      for (dd = 0; dd < DQ_WIDTH; dd = dd + 1)\n        dlyval_dq[((5*dd)+(cc*DQ_WIDTH*5))+:5] <= #TCQ dlyval_dq_reg_r[cc][dd];\n      end\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  \n    \n  always @(posedge clk)\n    if ((cal1_state_r == CAL1_NEW_DQS_WAIT) ||\n        (cal1_state_r == CAL1_MPR_NEW_DQS_WAIT) ||\n        (cal1_state_r == CAL1_NEW_DQS_PREWAIT) ||\n        (cal1_state_r == CAL1_VALID_WAIT) ||\n        (cal1_state_r == CAL1_PB_STORE_FIRST_WAIT) ||\n        (cal1_state_r == CAL1_PB_INC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_PB_DEC_CPT_LEFT_WAIT) ||\n        (cal1_state_r == CAL1_PB_INC_DQ_WAIT) ||\n        (cal1_state_r == CAL1_PB_DEC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_IDEL_INC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_IDEL_DEC_CPT_WAIT) ||\n        (cal1_state_r == CAL1_STORE_FIRST_WAIT) ||\n        (cal1_state_r == CAL1_DQ_IDEL_TAP_INC_WAIT) ||\n        (cal1_state_r == CAL1_DQ_IDEL_TAP_DEC_WAIT) ||\n        (cal1_state_r == CAL1_CENTER_WAIT) ||\n        (cal1_state_r == CAL1_RD_STOP_FOR_PI_INC))\n      cal1_wait_cnt_en_r <= #TCQ 1'b1;\n    else\n      cal1_wait_cnt_en_r <= #TCQ 1'b0;\n\n  always @(posedge clk)\n    if (!cal1_wait_cnt_en_r) begin\n      cal1_wait_cnt_r <= #TCQ 5'b00000;\n      cal1_wait_r     <= #TCQ 1'b1;\n    end else begin\n      if (cal1_wait_cnt_r != PIPE_WAIT_CNT - 1) begin\n        cal1_wait_cnt_r <= #TCQ cal1_wait_cnt_r + 1;\n        cal1_wait_r     <= #TCQ 1'b1;\n      end else begin\n        \n        \n        cal1_wait_cnt_r <= #TCQ 5'b00000;\n        cal1_wait_r     <= #TCQ 1'b0;\n      end\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst)\n      rdlvl_prech_req <= #TCQ 1'b0;\n    else\n      rdlvl_prech_req <= #TCQ cal1_prech_req_r;\n\n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n\n  generate\n    genvar rd_i;\n    if (nCK_PER_CLK == 4) begin: gen_sr_div4\n      if (RD_SHIFT_LEN == 1) begin: gen_sr_len_eq1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ mux_rd_rise0_r[rd_i];\n              sr_fall0_r[rd_i] <= #TCQ mux_rd_fall0_r[rd_i];\n              sr_rise1_r[rd_i] <= #TCQ mux_rd_rise1_r[rd_i];\n              sr_fall1_r[rd_i] <= #TCQ mux_rd_fall1_r[rd_i];\n              sr_rise2_r[rd_i] <= #TCQ mux_rd_rise2_r[rd_i];\n              sr_fall2_r[rd_i] <= #TCQ mux_rd_fall2_r[rd_i];\n              sr_rise3_r[rd_i] <= #TCQ mux_rd_rise3_r[rd_i];\n              sr_fall3_r[rd_i] <= #TCQ mux_rd_fall3_r[rd_i];\n            end\n          end\n        end\n      end else if (RD_SHIFT_LEN > 1) begin: gen_sr_len_gt1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {sr_rise0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {sr_fall0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {sr_rise1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {sr_fall1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall1_r[rd_i]};\n              sr_rise2_r[rd_i] <= #TCQ {sr_rise2_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise2_r[rd_i]};\n              sr_fall2_r[rd_i] <= #TCQ {sr_fall2_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall2_r[rd_i]};\n              sr_rise3_r[rd_i] <= #TCQ {sr_rise3_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise3_r[rd_i]};\n              sr_fall3_r[rd_i] <= #TCQ {sr_fall3_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall3_r[rd_i]};\n            end\n          end\n        end\n      end\n    end else if (nCK_PER_CLK == 2) begin: gen_sr_div2\n      if (RD_SHIFT_LEN == 1) begin: gen_sr_len_eq1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {mux_rd_fall1_r[rd_i]};\n            end\n          end\n        end\n      end else if (RD_SHIFT_LEN > 1) begin: gen_sr_len_gt1\n        for (rd_i = 0; rd_i < DRAM_WIDTH; rd_i = rd_i + 1) begin: gen_sr\n          always @(posedge clk) begin\n            if (mux_rd_valid_r) begin\n              sr_rise0_r[rd_i] <= #TCQ {sr_rise0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise0_r[rd_i]};\n              sr_fall0_r[rd_i] <= #TCQ {sr_fall0_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall0_r[rd_i]};\n              sr_rise1_r[rd_i] <= #TCQ {sr_rise1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_rise1_r[rd_i]};\n              sr_fall1_r[rd_i] <= #TCQ {sr_fall1_r[rd_i][RD_SHIFT_LEN-2:0],\n                                        mux_rd_fall1_r[rd_i]};\n            end\n          end\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  generate\n    if (nCK_PER_CLK == 4) begin: gen_pat_div4\n      \n\n      \n      assign {idel_pat0_rise0[3], idel_pat0_rise0[2],\n              idel_pat0_rise0[1], idel_pat0_rise0[0]} = 4'h1;\n      assign {idel_pat0_fall0[3], idel_pat0_fall0[2],\n              idel_pat0_fall0[1], idel_pat0_fall0[0]} = 4'h7;\n      assign {idel_pat0_rise1[3], idel_pat0_rise1[2],\n              idel_pat0_rise1[1], idel_pat0_rise1[0]} = 4'hE;\n      assign {idel_pat0_fall1[3], idel_pat0_fall1[2],\n              idel_pat0_fall1[1], idel_pat0_fall1[0]} = 4'hC;\n      assign {idel_pat0_rise2[3], idel_pat0_rise2[2],\n              idel_pat0_rise2[1], idel_pat0_rise2[0]} = 4'h9;\n      assign {idel_pat0_fall2[3], idel_pat0_fall2[2],\n              idel_pat0_fall2[1], idel_pat0_fall2[0]} = 4'h2;\n      assign {idel_pat0_rise3[3], idel_pat0_rise3[2],\n              idel_pat0_rise3[1], idel_pat0_rise3[0]} = 4'h4;\n      assign {idel_pat0_fall3[3], idel_pat0_fall3[2],\n              idel_pat0_fall3[1], idel_pat0_fall3[0]} = 4'hB;\n\n      \n      assign {idel_pat1_rise0[3], idel_pat1_rise0[2],\n              idel_pat1_rise0[1], idel_pat1_rise0[0]} = 4'h4;\n      assign {idel_pat1_fall0[3], idel_pat1_fall0[2],\n              idel_pat1_fall0[1], idel_pat1_fall0[0]} = 4'h9;\n      assign {idel_pat1_rise1[3], idel_pat1_rise1[2],\n              idel_pat1_rise1[1], idel_pat1_rise1[0]} = 4'h3;\n      assign {idel_pat1_fall1[3], idel_pat1_fall1[2],\n              idel_pat1_fall1[1], idel_pat1_fall1[0]} = 4'h7;\n      assign {idel_pat1_rise2[3], idel_pat1_rise2[2],\n              idel_pat1_rise2[1], idel_pat1_rise2[0]} = 4'hE;\n      assign {idel_pat1_fall2[3], idel_pat1_fall2[2],\n              idel_pat1_fall2[1], idel_pat1_fall2[0]} = 4'hC;\n      assign {idel_pat1_rise3[3], idel_pat1_rise3[2],\n              idel_pat1_rise3[1], idel_pat1_rise3[0]} = 4'h9;\n      assign {idel_pat1_fall3[3], idel_pat1_fall3[2],\n              idel_pat1_fall3[1], idel_pat1_fall3[0]} = 4'h2;\n\n\n      \n      assign {pat0_rise0[3], pat0_rise0[2],\n              pat0_rise0[1], pat0_rise0[0]} = 4'h7;\n      assign {pat0_fall0[3], pat0_fall0[2],\n              pat0_fall0[1], pat0_fall0[0]} = 4'hE;\n      assign {pat0_rise1[3], pat0_rise1[2],\n              pat0_rise1[1], pat0_rise1[0]} = 4'hC;\n      assign {pat0_fall1[3], pat0_fall1[2],\n              pat0_fall1[1], pat0_fall1[0]} = 4'h9;\n      assign {pat0_rise2[3], pat0_rise2[2],\n              pat0_rise2[1], pat0_rise2[0]} = 4'h2;\n      assign {pat0_fall2[3], pat0_fall2[2],\n              pat0_fall2[1], pat0_fall2[0]} = 4'h4;\n      assign {pat0_rise3[3], pat0_rise3[2],\n              pat0_rise3[1], pat0_rise3[0]} = 4'hB;\n      assign {pat0_fall3[3], pat0_fall3[2],\n              pat0_fall3[1], pat0_fall3[0]} = 4'h1;\n\n      \n      assign {pat1_rise0[3], pat1_rise0[2],\n              pat1_rise0[1], pat1_rise0[0]} = 4'h9;\n      assign {pat1_fall0[3], pat1_fall0[2],\n              pat1_fall0[1], pat1_fall0[0]} = 4'h3;\n      assign {pat1_rise1[3], pat1_rise1[2],\n              pat1_rise1[1], pat1_rise1[0]} = 4'h7;\n      assign {pat1_fall1[3], pat1_fall1[2],\n              pat1_fall1[1], pat1_fall1[0]} = 4'hE;\n      assign {pat1_rise2[3], pat1_rise2[2],\n              pat1_rise2[1], pat1_rise2[0]} = 4'hC;\n      assign {pat1_fall2[3], pat1_fall2[2],\n              pat1_fall2[1], pat1_fall2[0]} = 4'h9;\n      assign {pat1_rise3[3], pat1_rise3[2],\n              pat1_rise3[1], pat1_rise3[0]} = 4'h2;\n      assign {pat1_fall3[3], pat1_fall3[2],\n              pat1_fall3[1], pat1_fall3[0]} = 4'h4;\n\n    end else if (nCK_PER_CLK == 2) begin: gen_pat_div2\n\n            \n\n      \n      assign idel_pat0_rise0[3] = 2'b01;\n      assign idel_pat0_fall0[3] = 2'b00;\n      assign idel_pat0_rise1[3] = 2'b10;\n      assign idel_pat0_fall1[3] = 2'b11;\n\n      assign idel_pat0_rise0[2] = 2'b00;\n      assign idel_pat0_fall0[2] = 2'b10;\n      assign idel_pat0_rise1[2] = 2'b11;\n      assign idel_pat0_fall1[2] = 2'b10;\n\n      assign idel_pat0_rise0[1] = 2'b00;\n      assign idel_pat0_fall0[1] = 2'b11;\n      assign idel_pat0_rise1[1] = 2'b10;\n      assign idel_pat0_fall1[1] = 2'b01;\n\n      assign idel_pat0_rise0[0] = 2'b11;\n      assign idel_pat0_fall0[0] = 2'b10;\n      assign idel_pat0_rise1[0] = 2'b00;\n      assign idel_pat0_fall1[0] = 2'b01;\n\n\n      \n      assign idel_pat1_rise0[3] = 2'b01;\n      assign idel_pat1_fall0[3] = 2'b11;\n      assign idel_pat1_rise1[3] = 2'b01;\n      assign idel_pat1_fall1[3] = 2'b00;\n\n      assign idel_pat1_rise0[2] = 2'b11;\n      assign idel_pat1_fall0[2] = 2'b01;\n      assign idel_pat1_rise1[2] = 2'b00;\n      assign idel_pat1_fall1[2] = 2'b10;\n\n      assign idel_pat1_rise0[1] = 2'b01;\n      assign idel_pat1_fall0[1] = 2'b00;\n      assign idel_pat1_rise1[1] = 2'b10;\n      assign idel_pat1_fall1[1] = 2'b11;\n\n      assign idel_pat1_rise0[0] = 2'b00;\n      assign idel_pat1_fall0[0] = 2'b10;\n      assign idel_pat1_rise1[0] = 2'b11;\n      assign idel_pat1_fall1[0] = 2'b10;\n\n\n      \n      assign pat0_rise0[3] = 2'b00;\n      assign pat0_fall0[3] = 2'b10;\n      assign pat0_rise1[3] = 2'b11;\n      assign pat0_fall1[3] = 2'b10;\n\n      assign pat0_rise0[2] = 2'b10;\n      assign pat0_fall0[2] = 2'b11;\n      assign pat0_rise1[2] = 2'b10;\n      assign pat0_fall1[2] = 2'b00;\n\n      assign pat0_rise0[1] = 2'b11;\n      assign pat0_fall0[1] = 2'b10;\n      assign pat0_rise1[1] = 2'b01;\n      assign pat0_fall1[1] = 2'b00;\n\n      assign pat0_rise0[0] = 2'b10;\n      assign pat0_fall0[0] = 2'b00;\n      assign pat0_rise1[0] = 2'b01;\n      assign pat0_fall1[0] = 2'b11;\n\n      \n      assign pat1_rise0[3] = 2'b11;\n      assign pat1_fall0[3] = 2'b01;\n      assign pat1_rise1[3] = 2'b00;\n      assign pat1_fall1[3] = 2'b10;\n\n      assign pat1_rise0[2] = 2'b01;\n      assign pat1_fall0[2] = 2'b00;\n      assign pat1_rise1[2] = 2'b10;\n      assign pat1_fall1[2] = 2'b11;\n\n      assign pat1_rise0[1] = 2'b00;\n      assign pat1_fall0[1] = 2'b10;\n      assign pat1_rise1[1] = 2'b11;\n      assign pat1_fall1[1] = 2'b10;\n\n      assign pat1_rise0[0] = 2'b10;\n      assign pat1_fall0[0] = 2'b11;\n      assign pat1_rise1[0] = 2'b10;\n      assign pat1_fall1[0] = 2'b00;\n    end\n  endgenerate\n\n  \n  \n  \n  \n  \n  \n  generate\n    genvar pt_i;\n    if (nCK_PER_CLK == 4) begin: gen_pat_match_div4\n      for (pt_i = 0; pt_i < DRAM_WIDTH; pt_i = pt_i + 1) begin: gen_pat_match\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat0_rise0[pt_i%4])\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat0_fall0[pt_i%4])\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat0_rise1[pt_i%4])\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat0_fall1[pt_i%4])\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == idel_pat0_rise2[pt_i%4])\n            idel_pat0_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == idel_pat0_fall2[pt_i%4])\n            idel_pat0_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == idel_pat0_rise3[pt_i%4])\n            idel_pat0_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == idel_pat0_fall3[pt_i%4])\n            idel_pat0_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat1_rise0[pt_i%4])\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat1_fall0[pt_i%4])\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat1_rise1[pt_i%4])\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat1_fall1[pt_i%4])\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == idel_pat1_rise2[pt_i%4])\n            idel_pat1_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == idel_pat1_fall2[pt_i%4])\n            idel_pat1_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == idel_pat1_rise3[pt_i%4])\n            idel_pat1_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == idel_pat1_fall3[pt_i%4])\n            idel_pat1_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat0_rise0[pt_i%4])\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat0_fall0[pt_i%4])\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat0_rise1[pt_i%4])\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat0_fall1[pt_i%4])\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == pat0_rise2[pt_i%4])\n            pat0_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == pat0_fall2[pt_i%4])\n            pat0_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == pat0_rise3[pt_i%4])\n            pat0_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == pat0_fall3[pt_i%4])\n            pat0_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat1_rise0[pt_i%4])\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat1_fall0[pt_i%4])\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat1_rise1[pt_i%4])\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat1_fall1[pt_i%4])\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise2_r[pt_i] == pat1_rise2[pt_i%4])\n            pat1_match_rise2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall2_r[pt_i] == pat1_fall2[pt_i%4])\n            pat1_match_fall2_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall2_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise3_r[pt_i] == pat1_rise3[pt_i%4])\n            pat1_match_rise3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise3_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall3_r[pt_i] == pat1_fall3[pt_i%4])\n            pat1_match_fall3_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall3_r[pt_i] <= #TCQ 1'b0;\n        end\n\n      end\n\n      \n      always @(posedge clk) begin\n        idel_pat0_match_rise0_and_r <= #TCQ &idel_pat0_match_rise0_r;\n        idel_pat0_match_fall0_and_r <= #TCQ &idel_pat0_match_fall0_r;\n        idel_pat0_match_rise1_and_r <= #TCQ &idel_pat0_match_rise1_r;\n        idel_pat0_match_fall1_and_r <= #TCQ &idel_pat0_match_fall1_r;\n        idel_pat0_match_rise2_and_r <= #TCQ &idel_pat0_match_rise2_r;\n        idel_pat0_match_fall2_and_r <= #TCQ &idel_pat0_match_fall2_r;\n        idel_pat0_match_rise3_and_r <= #TCQ &idel_pat0_match_rise3_r;\n        idel_pat0_match_fall3_and_r <= #TCQ &idel_pat0_match_fall3_r;\n        idel_pat0_data_match_r <= #TCQ (idel_pat0_match_rise0_and_r &&\n                                        idel_pat0_match_fall0_and_r &&\n                                        idel_pat0_match_rise1_and_r &&\n                                        idel_pat0_match_fall1_and_r &&\n                                        idel_pat0_match_rise2_and_r &&\n                                        idel_pat0_match_fall2_and_r &&\n                                        idel_pat0_match_rise3_and_r &&\n                                        idel_pat0_match_fall3_and_r);\n      end\n\n      always @(posedge clk) begin\n        idel_pat1_match_rise0_and_r <= #TCQ &idel_pat1_match_rise0_r;\n        idel_pat1_match_fall0_and_r <= #TCQ &idel_pat1_match_fall0_r;\n        idel_pat1_match_rise1_and_r <= #TCQ &idel_pat1_match_rise1_r;\n        idel_pat1_match_fall1_and_r <= #TCQ &idel_pat1_match_fall1_r;\n        idel_pat1_match_rise2_and_r <= #TCQ &idel_pat1_match_rise2_r;\n        idel_pat1_match_fall2_and_r <= #TCQ &idel_pat1_match_fall2_r;\n        idel_pat1_match_rise3_and_r <= #TCQ &idel_pat1_match_rise3_r;\n        idel_pat1_match_fall3_and_r <= #TCQ &idel_pat1_match_fall3_r;\n        idel_pat1_data_match_r <= #TCQ (idel_pat1_match_rise0_and_r &&\n                                        idel_pat1_match_fall0_and_r &&\n                                        idel_pat1_match_rise1_and_r &&\n                                        idel_pat1_match_fall1_and_r &&\n                                        idel_pat1_match_rise2_and_r &&\n                                        idel_pat1_match_fall2_and_r &&\n                                        idel_pat1_match_rise3_and_r &&\n                                        idel_pat1_match_fall3_and_r);\n      end\n\n      always @(*)\n        idel_pat_data_match <= #TCQ idel_pat0_data_match_r |\n                                    idel_pat1_data_match_r;\n\n      always @(posedge clk)\n        idel_pat_data_match_r <= #TCQ idel_pat_data_match;\n\n      \n      always @(posedge clk) begin\n        pat0_match_rise0_and_r <= #TCQ &pat0_match_rise0_r;\n        pat0_match_fall0_and_r <= #TCQ &pat0_match_fall0_r;\n        pat0_match_rise1_and_r <= #TCQ &pat0_match_rise1_r;\n        pat0_match_fall1_and_r <= #TCQ &pat0_match_fall1_r;\n        pat0_match_rise2_and_r <= #TCQ &pat0_match_rise2_r;\n        pat0_match_fall2_and_r <= #TCQ &pat0_match_fall2_r;\n        pat0_match_rise3_and_r <= #TCQ &pat0_match_rise3_r;\n        pat0_match_fall3_and_r <= #TCQ &pat0_match_fall3_r;\n        pat0_data_match_r <= #TCQ (pat0_match_rise0_and_r &&\n                                   pat0_match_fall0_and_r &&\n                                   pat0_match_rise1_and_r &&\n                                   pat0_match_fall1_and_r &&\n                                   pat0_match_rise2_and_r &&\n                                   pat0_match_fall2_and_r &&\n                                   pat0_match_rise3_and_r &&\n                                   pat0_match_fall3_and_r);\n      end\n\n      always @(posedge clk) begin\n        pat1_match_rise0_and_r <= #TCQ &pat1_match_rise0_r;\n        pat1_match_fall0_and_r <= #TCQ &pat1_match_fall0_r;\n        pat1_match_rise1_and_r <= #TCQ &pat1_match_rise1_r;\n        pat1_match_fall1_and_r <= #TCQ &pat1_match_fall1_r;\n        pat1_match_rise2_and_r <= #TCQ &pat1_match_rise2_r;\n        pat1_match_fall2_and_r <= #TCQ &pat1_match_fall2_r;\n        pat1_match_rise3_and_r <= #TCQ &pat1_match_rise3_r;\n        pat1_match_fall3_and_r <= #TCQ &pat1_match_fall3_r;\n        pat1_data_match_r <= #TCQ (pat1_match_rise0_and_r &&\n                                   pat1_match_fall0_and_r &&\n                                   pat1_match_rise1_and_r &&\n                                   pat1_match_fall1_and_r &&\n                                   pat1_match_rise2_and_r &&\n                                   pat1_match_fall2_and_r &&\n                                   pat1_match_rise3_and_r &&\n                                   pat1_match_fall3_and_r);\n      end\n\n      assign pat_data_match_r = pat0_data_match_r | pat1_data_match_r;\n\n    end else if (nCK_PER_CLK == 2) begin: gen_pat_match_div2\n      for (pt_i = 0; pt_i < DRAM_WIDTH; pt_i = pt_i + 1) begin: gen_pat_match\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat0_rise0[pt_i%4])\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat0_fall0[pt_i%4])\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat0_rise1[pt_i%4])\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat0_fall1[pt_i%4])\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == idel_pat1_rise0[pt_i%4])\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == idel_pat1_fall0[pt_i%4])\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == idel_pat1_rise1[pt_i%4])\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == idel_pat1_fall1[pt_i%4])\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            idel_pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        \n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat0_rise0[pt_i%4])\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat0_fall0[pt_i%4])\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat0_rise1[pt_i%4])\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat0_fall1[pt_i%4])\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat0_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n        always @(posedge clk) begin\n          if (sr_rise0_r[pt_i] == pat1_rise0[pt_i%4])\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall0_r[pt_i] == pat1_fall0[pt_i%4])\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall0_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_rise1_r[pt_i] == pat1_rise1[pt_i%4])\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_rise1_r[pt_i] <= #TCQ 1'b0;\n\n          if (sr_fall1_r[pt_i] == pat1_fall1[pt_i%4])\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b1;\n          else\n            pat1_match_fall1_r[pt_i] <= #TCQ 1'b0;\n        end\n\n      end\n\n        \n      always @(posedge clk) begin\n        idel_pat0_match_rise0_and_r <= #TCQ &idel_pat0_match_rise0_r;\n        idel_pat0_match_fall0_and_r <= #TCQ &idel_pat0_match_fall0_r;\n        idel_pat0_match_rise1_and_r <= #TCQ &idel_pat0_match_rise1_r;\n        idel_pat0_match_fall1_and_r <= #TCQ &idel_pat0_match_fall1_r;\n        idel_pat0_data_match_r <= #TCQ (idel_pat0_match_rise0_and_r &&\n                                        idel_pat0_match_fall0_and_r &&\n                                        idel_pat0_match_rise1_and_r &&\n                                        idel_pat0_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        idel_pat1_match_rise0_and_r <= #TCQ &idel_pat1_match_rise0_r;\n        idel_pat1_match_fall0_and_r <= #TCQ &idel_pat1_match_fall0_r;\n        idel_pat1_match_rise1_and_r <= #TCQ &idel_pat1_match_rise1_r;\n        idel_pat1_match_fall1_and_r <= #TCQ &idel_pat1_match_fall1_r;\n        idel_pat1_data_match_r <= #TCQ (idel_pat1_match_rise0_and_r &&\n                                        idel_pat1_match_fall0_and_r &&\n                                        idel_pat1_match_rise1_and_r &&\n                                        idel_pat1_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        if (sr_valid_r2)\n          idel_pat_data_match <= #TCQ idel_pat0_data_match_r |\n                                      idel_pat1_data_match_r;\n      end\n\n      \n      \n\n      always @(posedge clk)\n        idel_pat_data_match_r <= #TCQ idel_pat_data_match;\n\n      \n      always @(posedge clk) begin\n        pat0_match_rise0_and_r <= #TCQ &pat0_match_rise0_r;\n        pat0_match_fall0_and_r <= #TCQ &pat0_match_fall0_r;\n        pat0_match_rise1_and_r <= #TCQ &pat0_match_rise1_r;\n        pat0_match_fall1_and_r <= #TCQ &pat0_match_fall1_r;\n        pat0_data_match_r <= #TCQ (pat0_match_rise0_and_r &&\n                                   pat0_match_fall0_and_r &&\n                                   pat0_match_rise1_and_r &&\n                                   pat0_match_fall1_and_r);\n      end\n\n      always @(posedge clk) begin\n        pat1_match_rise0_and_r <= #TCQ &pat1_match_rise0_r;\n        pat1_match_fall0_and_r <= #TCQ &pat1_match_fall0_r;\n        pat1_match_rise1_and_r <= #TCQ &pat1_match_rise1_r;\n        pat1_match_fall1_and_r <= #TCQ &pat1_match_fall1_r;\n        pat1_data_match_r <= #TCQ (pat1_match_rise0_and_r &&\n                                   pat1_match_fall0_and_r &&\n                                   pat1_match_rise1_and_r &&\n                                   pat1_match_fall1_and_r);\n      end\n\n      assign pat_data_match_r = pat0_data_match_r | pat1_data_match_r;\n\n    end\n\n  endgenerate\n\n\n  always @(posedge clk) begin\n    rdlvl_stg1_start_r <= #TCQ rdlvl_stg1_start;\n    mpr_rdlvl_done_r1  <= #TCQ mpr_rdlvl_done_r;\n    mpr_rdlvl_done_r2  <= #TCQ mpr_rdlvl_done_r1;\n    mpr_rdlvl_start_r  <= #TCQ mpr_rdlvl_start;\n  end\n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst || (mpr_rdlvl_done_r && ~rdlvl_stg1_start)) begin\n      cnt_shift_r <= #TCQ 'b1;\n      sr_valid_r  <= #TCQ 1'b0;\n      mpr_valid_r <= #TCQ 1'b0;\n    end else begin\n      if (mux_rd_valid_r && mpr_rdlvl_start && ~mpr_rdlvl_done_r) begin\n        if (cnt_shift_r == 'b0)\n          mpr_valid_r <= #TCQ 1'b1;\n        else begin\n          mpr_valid_r <= #TCQ 1'b0;\n          cnt_shift_r <= #TCQ cnt_shift_r + 1;\n        end\n      end else\n        mpr_valid_r <= #TCQ 1'b0;\n\n      if (mux_rd_valid_r && rdlvl_stg1_start) begin\n        if (cnt_shift_r == RD_SHIFT_LEN-1) begin\n          sr_valid_r <= #TCQ 1'b1;\n          cnt_shift_r <= #TCQ 'b0;\n        end else begin\n          sr_valid_r <= #TCQ 1'b0;\n          cnt_shift_r <= #TCQ cnt_shift_r + 1;\n        end\n      end else\n        \n        \n        \n        \n        sr_valid_r <= #TCQ 1'b0;\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  always @(posedge clk)\n    if (rst)\n      store_sr_r      <= #TCQ 1'b0;\n    else begin\n      if (store_sr_req_r)\n        store_sr_r <= #TCQ 1'b1;\n      else if ((sr_valid_r || mpr_valid_r) && store_sr_r)\n        store_sr_r <= #TCQ 1'b0;\n    end\n\n  \n  \n  \n  generate\n    if (nCK_PER_CLK == 4) begin: gen_old_sr_div4\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_old_sr\n      always @(posedge clk) begin\n        if (sr_valid_r || mpr_valid_r) begin\n          \n          prev_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n          prev_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n          prev_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n          prev_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          prev_sr_rise2_r[z] <= #TCQ sr_rise2_r[z];\n          prev_sr_fall2_r[z] <= #TCQ sr_fall2_r[z];\n          prev_sr_rise3_r[z] <= #TCQ sr_rise3_r[z];\n          prev_sr_fall3_r[z] <= #TCQ sr_fall3_r[z];\n        end\n        if ((sr_valid_r || mpr_valid_r) && store_sr_r) begin\n          old_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n          old_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n          old_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n          old_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          old_sr_rise2_r[z] <= #TCQ sr_rise2_r[z];\n          old_sr_fall2_r[z] <= #TCQ sr_fall2_r[z];\n          old_sr_rise3_r[z] <= #TCQ sr_rise3_r[z];\n          old_sr_fall3_r[z] <= #TCQ sr_fall3_r[z];\n        end\n      end\n    end\n    end else if (nCK_PER_CLK == 2) begin: gen_old_sr_div2\n      for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_old_sr\n        always @(posedge clk) begin\n          if (sr_valid_r || mpr_valid_r) begin\n            prev_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n            prev_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n            prev_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n            prev_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          end\n          if ((sr_valid_r || mpr_valid_r) && store_sr_r) begin\n            old_sr_rise0_r[z] <= #TCQ sr_rise0_r[z];\n            old_sr_fall0_r[z] <= #TCQ sr_fall0_r[z];\n            old_sr_rise1_r[z] <= #TCQ sr_rise1_r[z];\n            old_sr_fall1_r[z] <= #TCQ sr_fall1_r[z];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  \n\n  \n  always @(posedge clk) begin\n    sr_valid_r1  <= #TCQ sr_valid_r;\n    sr_valid_r2  <= #TCQ sr_valid_r1;\n    mpr_valid_r1 <= #TCQ mpr_valid_r;\n    mpr_valid_r2 <= #TCQ mpr_valid_r1;\n  end\n\n  generate\n    if (nCK_PER_CLK == 4) begin: gen_sr_match_div4\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_sr_match\n      always @(posedge clk) begin\n        \n        \n        \n        \n        \n        \n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise0_r[z] == old_sr_rise0_r[z]))\n          old_sr_match_rise0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise0_r[z] <= #TCQ old_sr_match_rise0_r[z];\n        else\n          old_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall0_r[z] == old_sr_fall0_r[z]))\n          old_sr_match_fall0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall0_r[z] <= #TCQ old_sr_match_fall0_r[z];\n        else\n          old_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise1_r[z] == old_sr_rise1_r[z]))\n          old_sr_match_rise1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise1_r[z] <= #TCQ old_sr_match_rise1_r[z];\n        else\n          old_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall1_r[z] == old_sr_fall1_r[z]))\n          old_sr_match_fall1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall1_r[z] <= #TCQ old_sr_match_fall1_r[z];\n        else\n          old_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise2_r[z] == old_sr_rise2_r[z]))\n          old_sr_match_rise2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise2_r[z] <= #TCQ old_sr_match_rise2_r[z];\n        else\n          old_sr_match_rise2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall2_r[z] == old_sr_fall2_r[z]))\n          old_sr_match_fall2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall2_r[z] <= #TCQ old_sr_match_fall2_r[z];\n        else\n          old_sr_match_fall2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise3_r[z] == old_sr_rise3_r[z]))\n          old_sr_match_rise3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_rise3_r[z] <= #TCQ old_sr_match_rise3_r[z];\n        else\n          old_sr_match_rise3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall3_r[z] == old_sr_fall3_r[z]))\n          old_sr_match_fall3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          old_sr_match_fall3_r[z] <= #TCQ old_sr_match_fall3_r[z];\n        else\n          old_sr_match_fall3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise0_r[z] == prev_sr_rise0_r[z]))\n          prev_sr_match_rise0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise0_r[z] <= #TCQ prev_sr_match_rise0_r[z];\n        else\n          prev_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall0_r[z] == prev_sr_fall0_r[z]))\n          prev_sr_match_fall0_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall0_r[z] <= #TCQ prev_sr_match_fall0_r[z];\n        else\n          prev_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise1_r[z] == prev_sr_rise1_r[z]))\n          prev_sr_match_rise1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise1_r[z] <= #TCQ prev_sr_match_rise1_r[z];\n        else\n          prev_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall1_r[z] == prev_sr_fall1_r[z]))\n          prev_sr_match_fall1_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall1_r[z] <= #TCQ prev_sr_match_fall1_r[z];\n        else\n          prev_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise2_r[z] == prev_sr_rise2_r[z]))\n          prev_sr_match_rise2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise2_r[z] <= #TCQ prev_sr_match_rise2_r[z];\n        else\n          prev_sr_match_rise2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall2_r[z] == prev_sr_fall2_r[z]))\n          prev_sr_match_fall2_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall2_r[z] <= #TCQ prev_sr_match_fall2_r[z];\n        else\n          prev_sr_match_fall2_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_rise3_r[z] == prev_sr_rise3_r[z]))\n          prev_sr_match_rise3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_rise3_r[z] <= #TCQ prev_sr_match_rise3_r[z];\n        else\n          prev_sr_match_rise3_r[z] <= #TCQ 1'b0;\n\n        if ((pat_data_match_r || mpr_valid_r1) && (sr_fall3_r[z] == prev_sr_fall3_r[z]))\n          prev_sr_match_fall3_r[z] <= #TCQ 1'b1;\n        else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n          prev_sr_match_fall3_r[z] <= #TCQ prev_sr_match_fall3_r[z];\n        else\n          prev_sr_match_fall3_r[z] <= #TCQ 1'b0;\n\n        \n        \n        \n          old_sr_match_cyc2_r[z] <= #TCQ\n                                    old_sr_match_rise0_r[z] &\n                                  old_sr_match_fall0_r[z] &\n                                  old_sr_match_rise1_r[z] &\n                                  old_sr_match_fall1_r[z] &\n                                  old_sr_match_rise2_r[z] &\n                                  old_sr_match_fall2_r[z] &\n                                  old_sr_match_rise3_r[z] &\n                                  old_sr_match_fall3_r[z];\n          prev_sr_match_cyc2_r[z] <= #TCQ\n                                     prev_sr_match_rise0_r[z] &\n                                   prev_sr_match_fall0_r[z] &\n                                   prev_sr_match_rise1_r[z] &\n                                   prev_sr_match_fall1_r[z] &\n                                   prev_sr_match_rise2_r[z] &\n                                   prev_sr_match_fall2_r[z] &\n                                   prev_sr_match_rise3_r[z] &\n                                   prev_sr_match_fall3_r[z];\n\n        \n        \n        \n        if (sr_valid_r2 || mpr_valid_r2) begin\n          old_sr_diff_r[z]  <= #TCQ ~old_sr_match_cyc2_r[z];\n          prev_sr_diff_r[z] <= #TCQ ~prev_sr_match_cyc2_r[z];\n        end else begin\n          old_sr_diff_r[z]  <= #TCQ 'b0;\n          prev_sr_diff_r[z] <= #TCQ 'b0;\n        end\n        end\n      end\n    end if (nCK_PER_CLK == 2) begin: gen_sr_match_div2\n      for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_sr_match\n        always @(posedge clk) begin\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise0_r[z] == old_sr_rise0_r[z]))\n            old_sr_match_rise0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_rise0_r[z] <= #TCQ old_sr_match_rise0_r[z];\n          else\n            old_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall0_r[z] == old_sr_fall0_r[z]))\n            old_sr_match_fall0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_fall0_r[z] <= #TCQ old_sr_match_fall0_r[z];\n          else\n            old_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise1_r[z] == old_sr_rise1_r[z]))\n            old_sr_match_rise1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_rise1_r[z] <= #TCQ old_sr_match_rise1_r[z];\n          else\n            old_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall1_r[z] == old_sr_fall1_r[z]))\n            old_sr_match_fall1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            old_sr_match_fall1_r[z] <= #TCQ old_sr_match_fall1_r[z];\n          else\n            old_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise0_r[z] == prev_sr_rise0_r[z]))\n            prev_sr_match_rise0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_rise0_r[z] <= #TCQ prev_sr_match_rise0_r[z];\n          else\n            prev_sr_match_rise0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall0_r[z] == prev_sr_fall0_r[z]))\n            prev_sr_match_fall0_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_fall0_r[z] <= #TCQ prev_sr_match_fall0_r[z];\n          else\n            prev_sr_match_fall0_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_rise1_r[z] == prev_sr_rise1_r[z]))\n            prev_sr_match_rise1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_rise1_r[z] <= #TCQ prev_sr_match_rise1_r[z];\n          else\n            prev_sr_match_rise1_r[z] <= #TCQ 1'b0;\n\n          if ((sr_valid_r || mpr_valid_r1) && (sr_fall1_r[z] == prev_sr_fall1_r[z]))\n            prev_sr_match_fall1_r[z] <= #TCQ 1'b1;\n          else if (~mpr_valid_r1 && mpr_rdlvl_start && ~mpr_rdlvl_done_r)\n            prev_sr_match_fall1_r[z] <= #TCQ prev_sr_match_fall1_r[z];\n          else\n            prev_sr_match_fall1_r[z] <= #TCQ 1'b0;\n\n          old_sr_match_cyc2_r[z] <= #TCQ\n                                    old_sr_match_rise0_r[z] &\n                                    old_sr_match_fall0_r[z] &\n                                    old_sr_match_rise1_r[z] &\n                                    old_sr_match_fall1_r[z];\n          prev_sr_match_cyc2_r[z] <= #TCQ\n                                     prev_sr_match_rise0_r[z] &\n                                     prev_sr_match_fall0_r[z] &\n                                     prev_sr_match_rise1_r[z] &\n                                     prev_sr_match_fall1_r[z];\n\n          \n          \n          \n          if (sr_valid_r2 || mpr_valid_r2) begin\n            old_sr_diff_r[z]  <= #TCQ ~old_sr_match_cyc2_r[z];\n            prev_sr_diff_r[z] <= #TCQ ~prev_sr_match_cyc2_r[z];\n          end else begin\n            old_sr_diff_r[z]  <= #TCQ 'b0;\n            prev_sr_diff_r[z] <= #TCQ 'b0;\n          end\n        end\n     end\n    end\n  endgenerate\n\n  \n  \n  \n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  always @(posedge clk)\n    samp_edge_cnt0_en_r <= #TCQ\n                          (cal1_state_r == CAL1_PAT_DETECT) ||\n                          (cal1_state_r == CAL1_DETECT_EDGE) ||\n                          (cal1_state_r == CAL1_PB_DETECT_EDGE) ||\n                          (cal1_state_r == CAL1_PB_DETECT_EDGE_DQ);\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt0_r <= #TCQ 'b0;\n    else begin\n      if (!samp_edge_cnt0_en_r)\n        \n        samp_edge_cnt0_r <= #TCQ 'b0;\n      else if (sr_valid_r2 || mpr_valid_r2)\n        \n        samp_edge_cnt0_r <= #TCQ samp_edge_cnt0_r + 1;\n    end\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt1_en_r <= #TCQ 1'b0;\n    else begin\n      \n      if ((samp_edge_cnt0_r == DETECT_EDGE_SAMPLE_CNT0) &&\n          (sr_valid_r2 || mpr_valid_r2))\n        samp_edge_cnt1_en_r <= #TCQ 1'b1;\n      else\n        samp_edge_cnt1_en_r <= #TCQ 1'b0;\n    end\n\n  \n  always @(posedge clk)\n    if (rst)\n      samp_edge_cnt1_r <= #TCQ 'b0;\n    else\n      if (!samp_edge_cnt0_en_r)\n        samp_edge_cnt1_r <= #TCQ 'b0;\n      else if (samp_edge_cnt1_en_r)\n        samp_edge_cnt1_r <= #TCQ samp_edge_cnt1_r + 1;\n\n  always @(posedge clk)\n    if (rst)\n      samp_cnt_done_r <= #TCQ 1'b0;\n    else begin\n      if (!samp_edge_cnt0_en_r)\n        samp_cnt_done_r <= #TCQ 'b0;\n      else if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n               (SIM_CAL_OPTION == \"FAST_WIN_DETECT\")) begin\n        if (samp_edge_cnt0_r == SR_VALID_DELAY-1)\n          \n          \n          samp_cnt_done_r <= #TCQ 1'b1;\n      end else begin\n        if (samp_edge_cnt1_r == DETECT_EDGE_SAMPLE_CNT1)\n          samp_cnt_done_r <= #TCQ 1'b1;\n      end\n    end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  assign pb_detect_edge_setup\n    = (cal1_state_r == CAL1_STORE_FIRST_WAIT) ||\n      (cal1_state_r == CAL1_PB_STORE_FIRST_WAIT) ||\n      (cal1_state_r == CAL1_PB_DEC_CPT_LEFT_WAIT);\n\n  assign pb_detect_edge\n    = (cal1_state_r == CAL1_PAT_DETECT) ||\n      (cal1_state_r == CAL1_DETECT_EDGE) ||\n      (cal1_state_r == CAL1_PB_DETECT_EDGE) ||\n      (cal1_state_r == CAL1_PB_DETECT_EDGE_DQ);\n\n  generate\n    for (z = 0; z < DRAM_WIDTH; z = z + 1) begin: gen_track_left_edge\n      always @(posedge clk) begin\n        if (pb_detect_edge_setup) begin\n          \n          \n          pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n          pb_detect_edge_done_r[z] <= #TCQ 1'b0;\n          pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n          pb_last_tap_jitter_r[z]  <= #TCQ 1'b0;\n          pb_found_edge_last_r[z]  <= #TCQ 1'b0;\n          pb_found_edge_r[z]       <= #TCQ 1'b0;\n          pb_found_first_edge_r[z] <= #TCQ 1'b0;\n        end else if (pb_detect_edge) begin\n          \n          \n          \n          pb_found_edge_last_r[z] <= #TCQ pb_found_edge_r[z];\n\n          if (!pb_detect_edge_done_r[z]) begin\n            if (samp_cnt_done_r) begin\n              \n              \n              \n              \n              \n              \n              pb_last_tap_jitter_r[z]  <= #TCQ 1'b0;\n              pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n              if (!pb_found_edge_r[z] && !pb_last_tap_jitter_r[z]) begin\n                \n                \n                \n                if (pb_cnt_eye_size_r[z] != MIN_EYE_SIZE-1)\n                  pb_cnt_eye_size_r[z] <= #TCQ pb_cnt_eye_size_r[z] + 1;\n                else \n                  \n                  pb_found_stable_eye_r[z] <= #TCQ 1'b1;\n              end else begin\n                \n                \n                \n                \n                \n                pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n                pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n                pb_found_edge_r[z]       <= #TCQ 1'b1;\n                pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n              end\n            end else if (prev_sr_diff_r[z]) begin\n              \n              \n              \n              pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n              pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n              pb_last_tap_jitter_r[z]  <= #TCQ 1'b1;\n              pb_found_edge_r[z]       <= #TCQ 1'b1;\n              pb_found_first_edge_r[z] <= #TCQ 1'b1;\n              pb_detect_edge_done_r[z] <= #TCQ 1'b1;\n            end else if (old_sr_diff_r[z] || pb_last_tap_jitter_r[z]) begin\n              \n              \n              \n              \n              \n              \n              \n              \n              pb_cnt_eye_size_r[z]     <= #TCQ 5'd0;\n              pb_found_stable_eye_r[z] <= #TCQ 1'b0;\n              pb_found_edge_r[z]       <= #TCQ 1'b1;\n              pb_found_first_edge_r[z] <= #TCQ 1'b1;\n            end\n          end\n        end else begin\n          \n          pb_found_edge_r[z]       <= #TCQ 1'b0;\n          pb_detect_edge_done_r[z] <= #TCQ 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  \n  \n  always @(posedge clk) begin\n    detect_edge_done_r <= #TCQ &pb_detect_edge_done_r;\n    found_edge_r       <= #TCQ |pb_found_edge_r;\n    found_edge_all_r   <= #TCQ &pb_found_edge_r;\n    found_stable_eye_r <= #TCQ &pb_found_stable_eye_r;\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  always @(posedge clk)\n    if (pb_detect_edge_setup)\n      found_stable_eye_last_r <= #TCQ 1'b0;\n    else if (detect_edge_done_r)\n      found_stable_eye_last_r <= #TCQ found_stable_eye_r;\n\n  \n  \n  \n\n  \n  always @(posedge clk)\n    if (rst)\n      idelay_tap_cnt_slice_r <= 5'h0;\n    else\n      idelay_tap_cnt_slice_r <= idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing];\n\n  always @(posedge clk)\n    if (rst || (SIM_CAL_OPTION == \"SKIP_CAL\")) begin \n      for (s = 0; s < RANKS; s = s + 1) begin\n        for (t = 0; t < DQS_WIDTH; t = t + 1) begin\n          idelay_tap_cnt_r[s][t] <= #TCQ idelaye2_init_val;\n        end\n      end\n    end else if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n      for (u = 0; u < RANKS; u = u + 1) begin\n        for (w = 0; w < DQS_WIDTH; w = w + 1) begin\n          if (cal1_dq_idel_ce) begin\n            if (cal1_dq_idel_inc)\n              idelay_tap_cnt_r[u][w] <= #TCQ idelay_tap_cnt_r[u][w] + 1;\n            else\n              idelay_tap_cnt_r[u][w] <= #TCQ idelay_tap_cnt_r[u][w] - 1;\n          end\n        end\n      end\n    end else if ((rnk_cnt_r == RANKS-1) && (RANKS == 2) &&\n                    rdlvl_rank_done_r && (cal1_state_r == CAL1_IDLE)) begin\n      for (f = 0; f < DQS_WIDTH; f = f + 1) begin\n        idelay_tap_cnt_r[rnk_cnt_r][f] <= #TCQ idelay_tap_cnt_r[(rnk_cnt_r-1)][f];\n      end\n    end else if (cal1_dq_idel_ce) begin\n      if (cal1_dq_idel_inc)\n        idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] <= #TCQ idelay_tap_cnt_slice_r + 5'h1;\n      else\n        idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing] <= #TCQ idelay_tap_cnt_slice_r - 5'h1;\n    end else if (idelay_ld)\n      idelay_tap_cnt_r[0][wrcal_cnt] <= #TCQ 5'b00000;\n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r)\n      idelay_tap_limit_r <= #TCQ 1'b0;\n    else if (idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_r] == 'd31)\n      idelay_tap_limit_r <= #TCQ 1'b1;\n\n  \n  \n  \n  \n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r ||\n        (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n      tap_cnt_cpt_r   <= #TCQ 'b0;\n    else if (cal1_dlyce_cpt_r) begin\n      if (cal1_dlyinc_cpt_r)\n        tap_cnt_cpt_r <= #TCQ tap_cnt_cpt_r + 1;\n      else if (tap_cnt_cpt_r != 'd0)\n        tap_cnt_cpt_r <= #TCQ tap_cnt_cpt_r - 1;\n    end\n\n  always @(posedge clk)\n    if (rst || new_cnt_cpt_r ||\n       (cal1_state_r1 == CAL1_DQ_IDEL_TAP_INC) ||\n       (mpr_rdlvl_done_r1 && ~mpr_rdlvl_done_r2))\n      tap_limit_cpt_r <= #TCQ 1'b0;\n    else if (tap_cnt_cpt_r == 6'd63)\n      tap_limit_cpt_r <= #TCQ 1'b1;\n\n   always @(posedge clk)\n     cal1_cnt_cpt_timing_r <= #TCQ cal1_cnt_cpt_r;\n\n   assign cal1_cnt_cpt_timing = {2'b00, cal1_cnt_cpt_r};\n\n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for (a = 0; a < RANKS; a = a + 1) begin: rst_rdlvl_dqs_tap_count_loop\n         for (b = 0; b < DQS_WIDTH; b = b + 1)\n           rdlvl_dqs_tap_cnt_r[a][b] <= #TCQ 'b0;\n       end\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (cal1_state_r1 == CAL1_NEXT_DQS)) begin\n       for (p = 0; p < RANKS; p = p +1) begin: rdlvl_dqs_tap_rank_cnt\n         for(q = 0; q < DQS_WIDTH; q = q +1) begin: rdlvl_dqs_tap_cnt\n           rdlvl_dqs_tap_cnt_r[p][q] <= #TCQ tap_cnt_cpt_r;\n         end\n       end\n     end else if (SIM_CAL_OPTION == \"SKIP_CAL\") begin\n       for (j = 0; j < RANKS; j = j +1) begin: rdlvl_dqs_tap_rnk_cnt\n         for(i = 0; i < DQS_WIDTH; i = i +1) begin: rdlvl_dqs_cnt\n           rdlvl_dqs_tap_cnt_r[j][i] <= #TCQ 6'd31;\n         end\n       end\n     end else if (cal1_state_r1 == CAL1_NEXT_DQS) begin\n       rdlvl_dqs_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing_r] <= #TCQ tap_cnt_cpt_r;\n     end\n   end\n\n\n  \n  \n  always @(posedge clk)\n    if (rst) begin\n      idel_tap_cnt_dq_pb_r   <= #TCQ 'b0;\n      idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n    end else\n      if (new_cnt_cpt_r) begin\n        idel_tap_cnt_dq_pb_r   <= #TCQ 'b0;\n        idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n      end else if (|cal1_dlyce_dq_r) begin\n        if (cal1_dlyinc_dq_r)\n          idel_tap_cnt_dq_pb_r <= #TCQ idel_tap_cnt_dq_pb_r + 1;\n        else\n          idel_tap_cnt_dq_pb_r <= #TCQ idel_tap_cnt_dq_pb_r - 1;\n\n        if (idel_tap_cnt_dq_pb_r == 31)\n          idel_tap_limit_dq_pb_r <= #TCQ 1'b1;\n        else\n          idel_tap_limit_dq_pb_r <= #TCQ 1'b0;\n      end\n\n\n  \n\n  always @(posedge clk) begin\n    cal1_state_r1 <= #TCQ cal1_state_r;\n    cal1_state_r2 <= #TCQ cal1_state_r1;\n    cal1_state_r3 <= #TCQ cal1_state_r2;\n  end\n\n  always @(posedge clk)\n    if (rst) begin\n      cal1_cnt_cpt_r        <= #TCQ 'b0;\n      cal1_dlyce_cpt_r      <= #TCQ 1'b0;\n      cal1_dlyinc_cpt_r     <= #TCQ 1'b0;\n      cal1_dq_idel_ce       <= #TCQ 1'b0;\n      cal1_dq_idel_inc      <= #TCQ 1'b0;\n      cal1_prech_req_r      <= #TCQ 1'b0;\n      cal1_state_r          <= #TCQ CAL1_IDLE;\n      cnt_idel_dec_cpt_r    <= #TCQ 6'bxxxxxx;\n      found_first_edge_r    <= #TCQ 1'b0;\n      found_second_edge_r   <= #TCQ 1'b0;\n      right_edge_taps_r     <= #TCQ 6'b000000;\n      first_edge_taps_r     <= #TCQ 6'bxxxxxx;\n      new_cnt_cpt_r         <= #TCQ 1'b0;\n      rdlvl_stg1_done_int       <= #TCQ 1'b0;\n      rdlvl_stg1_err        <= #TCQ 1'b0;\n      second_edge_taps_r    <= #TCQ 6'bxxxxxx;\n      store_sr_req_pulsed_r <= #TCQ 1'b0;\n      store_sr_req_r        <= #TCQ 1'b0;\n      rnk_cnt_r             <= #TCQ 2'b00;\n      rdlvl_rank_done_r     <= #TCQ 1'b0;\n      idel_dec_cnt          <= #TCQ 'd0;\n      rdlvl_last_byte_done_int  <= #TCQ 1'b0;\n      idel_pat_detect_valid_r <= #TCQ 1'b0;\n      mpr_rank_done_r       <= #TCQ 1'b0;\n      mpr_last_byte_done    <= #TCQ 1'b0;\n      idel_adj_inc          <= #TCQ 1'b0;\n      if (OCAL_EN == \"ON\")\n        mpr_rdlvl_done_r      <= #TCQ 1'b0;\n      else\n        mpr_rdlvl_done_r      <= #TCQ 1'b1;\n        mpr_dec_cpt_r           <= #TCQ 1'b0;\n        rdlvl_pi_incdec         <= #TCQ 1'b0;\n    end else begin\n      \n      \n      cal1_prech_req_r    <= #TCQ 1'b0;\n      cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n      cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n      cal1_dq_idel_ce     <= #TCQ 1'b0;\n      cal1_dq_idel_inc    <= #TCQ 1'b0;\n      new_cnt_cpt_r       <= #TCQ 1'b0;\n      store_sr_req_pulsed_r <= #TCQ 1'b0;\n      store_sr_req_r      <= #TCQ 1'b0;\n\n      case (cal1_state_r)\n\n        CAL1_IDLE: begin\n          rdlvl_rank_done_r    <= #TCQ 1'b0;\n          rdlvl_last_byte_done_int <= #TCQ 1'b0;\n          mpr_rank_done_r      <= #TCQ 1'b0;\n          mpr_last_byte_done   <= #TCQ 1'b0;\n          if (mpr_rdlvl_start && ~mpr_rdlvl_start_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n            cal1_state_r  <= #TCQ CAL1_MPR_NEW_DQS_WAIT;\n          end else begin\n            rdlvl_pi_incdec    <= #TCQ 1'b1;\n            if (rdlvl_stg1_start && ~rdlvl_stg1_start_r) begin\n              if (SIM_CAL_OPTION == \"SKIP_CAL\")\n                cal1_state_r  <= #TCQ CAL1_REGL_LOAD;\n              else if (SIM_CAL_OPTION == \"FAST_CAL\")\n                cal1_state_r  <= #TCQ CAL1_NEXT_DQS;\n              else begin\n                new_cnt_cpt_r <= #TCQ 1'b1;\n                cal1_state_r  <= #TCQ CAL1_NEW_DQS_WAIT;\n              end\n            end\n          end\n        end\n\n        CAL1_MPR_NEW_DQS_WAIT: begin\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          if (!cal1_wait_r && mpr_valid_r)\n            cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n        end\n\n        \n        \n        \n        CAL1_NEW_DQS_WAIT: begin\n          rdlvl_rank_done_r    <= #TCQ 1'b0;\n          rdlvl_last_byte_done_int <= #TCQ 1'b0;\n          mpr_rank_done_r      <= #TCQ 1'b0;\n          mpr_last_byte_done   <= #TCQ 1'b0;\n          cal1_prech_req_r     <= #TCQ 1'b0;\n          if (|pi_counter_read_val) begin \n            mpr_dec_cpt_r      <= #TCQ 1'b1;\n            cal1_state_r       <= #TCQ CAL1_IDEL_DEC_CPT;\n            cnt_idel_dec_cpt_r <= #TCQ pi_counter_read_val;\n            rdlvl_pi_incdec    <= #TCQ 1'b1;  \n          end else if (!cal1_wait_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n\n            \n            \n            \n            \n            store_sr_req_r <= #TCQ 1'b1;\n            \n            \n            if (PER_BIT_DESKEW == \"OFF\")\n              cal1_state_r <= #TCQ CAL1_STORE_FIRST_WAIT;\n            else if (PER_BIT_DESKEW == \"ON\")\n              cal1_state_r <= #TCQ CAL1_PB_STORE_FIRST_WAIT;\n          end else\n            rdlvl_pi_incdec    <= #TCQ 1'b1;  \n        end\n        \n        \n        \n\n        \n        CAL1_PB_STORE_FIRST_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE;\n\n        \n        CAL1_PB_DETECT_EDGE:\n          if (detect_edge_done_r) begin\n            if (found_stable_eye_r) begin\n              \n              \n              \n              \n              cnt_idel_dec_cpt_r <= #TCQ MIN_EYE_SIZE + 1;\n              cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT_LEFT;\n            end else begin\n              \n              \n              if (!tap_limit_cpt_r) begin\n                \n                \n                \n                store_sr_req_r <= #TCQ 1'b1;\n                cal1_state_r    <= #TCQ CAL1_PB_INC_CPT;\n              end else begin\n                \n                \n                \n                \n                \n                cnt_idel_dec_cpt_r <= #TCQ 6'd63;\n                cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT;\n              end\n            end\n          end\n\n        \n        CAL1_PB_INC_CPT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b1;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b1;\n          cal1_state_r      <= #TCQ CAL1_PB_INC_CPT_WAIT;\n        end\n\n        \n        \n        CAL1_PB_INC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE;\n\n          end\n        end\n        \n        \n        \n        CAL1_PB_DEC_CPT_LEFT:\n          if (cnt_idel_dec_cpt_r == 6'b000000)\n            cal1_state_r <= #TCQ CAL1_PB_DEC_CPT_LEFT_WAIT;\n          else begin\n            cal1_dlyce_cpt_r   <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r  <= #TCQ 1'b0;\n            cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          end\n\n        CAL1_PB_DEC_CPT_LEFT_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE_DQ;\n\n        \n        \n        \n        \n        \n        CAL1_PB_DETECT_EDGE_DQ:\n          if (detect_edge_done_r)\n            if (found_edge_all_r) begin\n              \n              \n              \n              \n              cnt_idel_dec_cpt_r <= #TCQ tap_cnt_cpt_r;\n              cal1_state_r       <= #TCQ CAL1_PB_DEC_CPT;\n            end else\n              if (!idel_tap_limit_dq_pb_r)\n                \n                \n                cal1_state_r <= #TCQ CAL1_PB_INC_DQ;\n              else begin\n                \n                \n                cnt_idel_dec_cpt_r <= #TCQ tap_cnt_cpt_r;\n                cal1_state_r <= #TCQ CAL1_PB_DEC_CPT;\n              end\n\n        CAL1_PB_INC_DQ: begin\n          \n          cal1_dlyce_dq_r  <= #TCQ ~pb_found_edge_last_r;\n          cal1_dlyinc_dq_r <= #TCQ 1'b1;\n          cal1_state_r     <= #TCQ CAL1_PB_INC_DQ_WAIT;\n        end\n\n        CAL1_PB_INC_DQ_WAIT:\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PB_DETECT_EDGE_DQ;\n\n        \n        CAL1_PB_DEC_CPT:\n          if (cnt_idel_dec_cpt_r == 6'b000000)\n            cal1_state_r <= #TCQ CAL1_PB_DEC_CPT_WAIT;\n          else begin\n            cal1_dlyce_cpt_r   <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r  <= #TCQ 1'b0;\n            cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          end\n\n        \n        \n        CAL1_PB_DEC_CPT_WAIT:\n          if (!cal1_wait_r) begin\n            store_sr_req_r <= #TCQ 1'b1;\n            cal1_state_r    <= #TCQ CAL1_STORE_FIRST_WAIT;\n          end\n\n        \n        \n        \n        \n        \n        \n        \n        \n        CAL1_STORE_FIRST_WAIT: begin\n          mpr_dec_cpt_r  <= #TCQ 1'b0;\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_PAT_DETECT;\n        end\n\n        CAL1_VALID_WAIT: begin\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n        end\n\n        CAL1_MPR_PAT_DETECT: begin\n          rdlvl_pi_incdec <= #TCQ 1'b0;\n          \n          \n          if (idel_pat_detect_valid_r == 1'b0) begin\n            cal1_state_r  <= #TCQ CAL1_VALID_WAIT;\n            idel_pat_detect_valid_r <= #TCQ 1'b1;\n          end else if (idel_pat_detect_valid_r && idel_mpr_pat_detect_r) begin\n            cal1_state_r  <= #TCQ CAL1_DETECT_EDGE;\n            idel_dec_cnt  <= #TCQ 'd0;\n          end else if (!idelay_tap_limit_r)\n            cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_INC;\n          else\n            cal1_state_r  <= #TCQ CAL1_RDLVL_ERR;\n        end\n\n        CAL1_PAT_DETECT: begin\n          \n          \n          \n          \n          \n          rdlvl_pi_incdec <= #TCQ 1'b0;\n          if (detect_edge_done_r) begin\n            if (idel_pat_data_match) begin\n              case (idelay_adj)\n                2'b01: begin\n                  cal1_state_r <= CAL1_DQ_IDEL_TAP_INC;\n                  idel_dec_cnt <= #TCQ 5'd0;\n                  idel_adj_inc <= #TCQ 1'b1;\n                end\n                2'b10: begin   \n                  cal1_state_r  <= #TCQ  CAL1_DQ_IDEL_TAP_DEC ;\n                  idel_dec_cnt  <= #TCQ 5'd1;\n                  idel_adj_inc  <= #TCQ 1'b0;\n                end\n                default: begin\n                  cal1_state_r  <= #TCQ CAL1_DETECT_EDGE;\n                  idel_dec_cnt  <= #TCQ 5'd0;\n                  idel_adj_inc  <= #TCQ 1'b0;\n                end\n              endcase\n            end else if (!idelay_tap_limit_r) begin\n              cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_INC;\n            end else begin\n              cal1_state_r  <= #TCQ CAL1_RDLVL_ERR;\n            end\n          end\n        end\n\n        \n        \n        CAL1_DQ_IDEL_TAP_INC: begin\n          cal1_dq_idel_ce         <= #TCQ 1'b1;\n          cal1_dq_idel_inc        <= #TCQ 1'b1;\n          cal1_state_r            <= #TCQ CAL1_DQ_IDEL_TAP_INC_WAIT;\n          idel_pat_detect_valid_r <= #TCQ 1'b0;\n        end\n\n        CAL1_DQ_IDEL_TAP_INC_WAIT: begin\n          cal1_dq_idel_ce     <= #TCQ 1'b0;\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            idel_adj_inc        <= #TCQ 1'b0;\n            if (idel_adj_inc)\n              cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n            else  if (~mpr_rdlvl_done_r & (DRAM_TYPE == \"DDR3\"))\n              cal1_state_r <= #TCQ CAL1_MPR_PAT_DETECT;\n            else\n              cal1_state_r <= #TCQ CAL1_PAT_DETECT;\n          end\n        end\n\n        \n        CAL1_DQ_IDEL_TAP_DEC: begin\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          cal1_state_r        <= #TCQ CAL1_DQ_IDEL_TAP_DEC_WAIT;\n          if (idel_dec_cnt >= 'd0)\n            cal1_dq_idel_ce     <= #TCQ 1'b1;\n          else\n            cal1_dq_idel_ce     <= #TCQ 1'b0;\n          if (idel_dec_cnt > 'd0)\n            idel_dec_cnt <= #TCQ idel_dec_cnt - 1;\n          else\n            idel_dec_cnt <= #TCQ idel_dec_cnt;\n        end\n\n        CAL1_DQ_IDEL_TAP_DEC_WAIT: begin\n          cal1_dq_idel_ce     <= #TCQ 1'b0;\n          cal1_dq_idel_inc    <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            if ((idel_dec_cnt > 'd0) || (pi_rdval_cnt > 'd0))\n              cal1_state_r <= #TCQ CAL1_DQ_IDEL_TAP_DEC;\n            else if (mpr_dec_cpt_r)\n              cal1_state_r <= #TCQ CAL1_STORE_FIRST_WAIT;\n            else\n              cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n          end\n        end\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        CAL1_DETECT_EDGE: begin\n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n          \n\n          \n          \n          \n          \n          \n          idel_pat_detect_valid_r <= #TCQ 1'b0;\n          if (!store_sr_req_pulsed_r) begin\n            \n            store_sr_req_r        <= #TCQ 1'b1;\n            store_sr_req_pulsed_r <= #TCQ 1'b1;\n          end else begin\n            store_sr_req_r        <= #TCQ 1'b0;\n            store_sr_req_pulsed_r <= #TCQ 1'b1;\n          end\n\n          \n          \n          \n          if (detect_edge_done_r) begin\n            if (tap_limit_cpt_r)\n              \n              \n              \n              \n              \n              \n              \n              \n              cal1_state_r <= #TCQ CAL1_CALC_IDEL;\n            else if (found_edge_r) begin\n              \n              \n              \n              found_first_edge_r <= #TCQ 1'b1;\n\n              \n              \n              if (!found_first_edge_r && found_stable_eye_last_r) begin\n                if (tap_cnt_cpt_r == 'd0)\n                  right_edge_taps_r <= #TCQ 'd0;\n                else\n                  right_edge_taps_r <= #TCQ tap_cnt_cpt_r;\n              end\n\n              \n              \n              \n              \n              \n              \n              \n              if (found_first_edge_r && found_stable_eye_last_r) begin\n                found_second_edge_r <= #TCQ 1'b1;\n                second_edge_taps_r <= #TCQ tap_cnt_cpt_r - 1;\n                cal1_state_r <= #TCQ CAL1_CALC_IDEL;\n              end else begin\n                \n                \n                \n                \n                first_edge_taps_r <= #TCQ tap_cnt_cpt_r;\n                \n                cal1_state_r <= #TCQ CAL1_RD_STOP_FOR_PI_INC;\n              end\n            end else\n              \n              \n              \n              cal1_state_r <= #TCQ CAL1_RD_STOP_FOR_PI_INC;\n          end\n        end\n\n        \n        \n        CAL1_RD_STOP_FOR_PI_INC: begin\n          rdlvl_pi_incdec    <= #TCQ 1'b1;\n          if (!cal1_wait_r)\n            cal1_state_r    <= #TCQ CAL1_IDEL_INC_CPT;\n        end\n\n        \n        CAL1_IDEL_INC_CPT: begin\n          cal1_state_r        <= #TCQ CAL1_IDEL_INC_CPT_WAIT;\n          if (~tap_limit_cpt_r) begin\n            cal1_dlyce_cpt_r    <= #TCQ 1'b1;\n            cal1_dlyinc_cpt_r   <= #TCQ 1'b1;\n          end else begin\n            cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n            cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n          end\n        end\n\n        \n        CAL1_IDEL_INC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r    <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r   <= #TCQ 1'b0;\n          if (!cal1_wait_r) begin\n            cal1_state_r <= #TCQ CAL1_DETECT_EDGE;\n            rdlvl_pi_incdec <= #TCQ 1'b0;    \n          end\n        end\n\n        \n        \n        \n        \n        \n        CAL1_CALC_IDEL: begin\n         \n          if (found_second_edge_r)\n            cnt_idel_dec_cpt_r\n              <=  #TCQ ((second_edge_taps_r -\n                         first_edge_taps_r)>>1) + 1;\n          else if (right_edge_taps_r > 6'd0)\n            \n            \n            \n            cnt_idel_dec_cpt_r\n              <=  #TCQ (tap_cnt_cpt_r - (right_edge_taps_r>>1));\n          else if (found_first_edge_r)\n            \n            cnt_idel_dec_cpt_r\n              <=  #TCQ ((tap_cnt_cpt_r - first_edge_taps_r)>>1);\n          else\n            cnt_idel_dec_cpt_r\n              <=  #TCQ (tap_cnt_cpt_r>>1);\n          \n          \n          \n          cal1_state_r <= #TCQ CAL1_CENTER_WAIT;\n          rdlvl_pi_incdec <= #TCQ 1'b1;\n        end\n\n        CAL1_CENTER_WAIT: begin\n          if(!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT;\n        end\n        \n        \n        \n        \n        \n        CAL1_IDEL_DEC_CPT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b1;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          \n          \n          cnt_idel_dec_cpt_r <= #TCQ cnt_idel_dec_cpt_r - 1;\n          if (cnt_idel_dec_cpt_r == 6'b000001) begin\n            if (mpr_dec_cpt_r) begin\n              if (|idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing]) begin\n                idel_dec_cnt  <= #TCQ idelay_tap_cnt_r[rnk_cnt_r][cal1_cnt_cpt_timing];\n                cal1_state_r  <= #TCQ CAL1_DQ_IDEL_TAP_DEC;\n              end else\n                cal1_state_r  <= #TCQ CAL1_STORE_FIRST_WAIT;\n            end else\n              cal1_state_r <= #TCQ CAL1_NEXT_DQS;\n          end else\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT_WAIT;\n        end\n\n        CAL1_IDEL_DEC_CPT_WAIT: begin\n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          if (!cal1_wait_r)\n            cal1_state_r <= #TCQ CAL1_IDEL_DEC_CPT;\n        end\n\n        \n        \n        CAL1_NEXT_DQS: begin\n          \n            cal1_prech_req_r  <= #TCQ 1'b1;\n          \n          \n          cal1_dlyce_cpt_r  <= #TCQ 1'b0;\n          cal1_dlyinc_cpt_r <= #TCQ 1'b0;\n          \n          found_first_edge_r  <= #TCQ 1'b0;\n          found_second_edge_r <= #TCQ 1'b0;\n          first_edge_taps_r <= #TCQ 'd0;\n          second_edge_taps_r <= #TCQ 'd0;\n          right_edge_taps_r    <= #TCQ 'd0;\n          if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n              (cal1_cnt_cpt_r >= DQS_WIDTH-1)) begin\n            if (mpr_rdlvl_done_r) begin\n              rdlvl_last_byte_done_int <= #TCQ 1'b1;\n              mpr_last_byte_done   <= #TCQ 1'b0;\n            end else begin\n              rdlvl_last_byte_done_int <= #TCQ 1'b0;\n              mpr_last_byte_done   <= #TCQ 1'b1;\n            end\n          end\n\n          \n          \n          if (prech_done) begin \n            if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n              \n              rdlvl_last_byte_done_int <= #TCQ 1'b0;\n              mpr_last_byte_done   <= #TCQ 1'b0;\n              cal1_state_r <= #TCQ CAL1_DONE; \n            end else if (cal1_cnt_cpt_r >= DQS_WIDTH-1) begin\n              if (~mpr_rdlvl_done_r) begin\n                mpr_rank_done_r <= #TCQ 1'b1;\n                \n                  \n                cal1_state_r <= #TCQ CAL1_DONE;\n                cal1_cnt_cpt_r <= #TCQ 'b0;\n                \n                  \n                  \n                  \n                  \n                  \n                \n              end else begin\n                \n                rdlvl_rank_done_r <= #TCQ 1'b1;\n                if (rnk_cnt_r == RANKS-1) begin\n                  \n                  cal1_state_r <= #TCQ CAL1_REGL_LOAD;\n                end else begin\n                  \n                  rnk_cnt_r      <= #TCQ rnk_cnt_r + 1;\n                  new_cnt_cpt_r  <= #TCQ 1'b1;\n                  cal1_cnt_cpt_r <= #TCQ 'b0;\n                  cal1_state_r   <= #TCQ CAL1_IDLE;\n                end\n              end\n            end else begin\n              \n              new_cnt_cpt_r  <= #TCQ 1'b1;\n              cal1_cnt_cpt_r <= #TCQ cal1_cnt_cpt_r + 1;\n              cal1_state_r   <= #TCQ CAL1_NEW_DQS_PREWAIT;\n            end\n          end\n        end\n\n        CAL1_NEW_DQS_PREWAIT: begin\n          if (!cal1_wait_r) begin\n            rdlvl_pi_incdec <= #TCQ 1'b0;\n            if (~mpr_rdlvl_done_r & (DRAM_TYPE == \"DDR3\"))\n                cal1_state_r  <= #TCQ CAL1_MPR_NEW_DQS_WAIT;\n            else\n              cal1_state_r   <= #TCQ CAL1_NEW_DQS_WAIT;\n          end\n        end\n\n        \n        CAL1_REGL_LOAD: begin\n          rdlvl_rank_done_r <= #TCQ 1'b0;\n          mpr_rank_done_r   <= #TCQ 1'b0;\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          cal1_cnt_cpt_r    <= #TCQ 'b0;\n          rnk_cnt_r         <= #TCQ 2'b00;\n          if ((regl_rank_cnt == RANKS-1) &&\n              ((regl_dqs_cnt == DQS_WIDTH-1) && (done_cnt == 4'd1))) begin\n            cal1_state_r <= #TCQ CAL1_DONE;\n            rdlvl_last_byte_done_int <= #TCQ 1'b0;\n            mpr_last_byte_done   <= #TCQ 1'b0;\n          end else\n            cal1_state_r <= #TCQ CAL1_REGL_LOAD;\n        end\n\n        CAL1_RDLVL_ERR: begin\n          rdlvl_stg1_err <= #TCQ 1'b1;\n        end\n\n        \n        \n        CAL1_DONE: begin\n          mpr_rdlvl_done_r  <= #TCQ 1'b1;\n          cal1_prech_req_r  <= #TCQ 1'b0;\n          if (~mpr_rdlvl_done_r && (OCAL_EN==\"ON\") && (DRAM_TYPE == \"DDR3\")) begin\n            rdlvl_stg1_done_int   <= #TCQ 1'b0;\n            cal1_state_r <= #TCQ CAL1_IDLE;\n          end else\n            rdlvl_stg1_done_int   <= #TCQ 1'b1;\n        end\n\n      endcase\n    end\n\n\n\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_ddr_phy_rdlvl. Module specification: This module implements a read leveling calibration algorithm for DDR memory interfaces. It adjusts the timing of read data capture to ensure proper alignment with the memory clock. The module takes inputs such as clock, reset, calibration start triggers, and read data, and outputs status signals, delay control signals, and calibration results. Key internal signals include counters for tracking calibration progress, flags for edge detection and pattern matching, and shift registers for storing read data. The module operates through several states, including initializing delays, detecting data patterns, finding valid edges of the data eye, and centering the read capture point. It supports multiple ranks and handles both DDR3 and DDR4 memory types. The calibration process involves incrementing delays, detecting data patterns, finding valid eye regions, and centering the read capture point within"
                }
            ]
        }
    ]
}