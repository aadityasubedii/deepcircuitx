{
    "spec": "Module name: mig_7series_v4_1_ddr_phy_wrlvl. Module specification: This module implements write leveling functionality for a DDR memory interface, adjusting DQS signal timing relative to the clock for optimal data capture during writes. It uses a state machine to incrementally adjust fine and coarse delay taps, detecting edges in received data to determine optimal timing. The module supports multiple ranks and includes features for initial calibration, fine-tuning, and error handling. Key inputs include clk, rst, phy_ctl_ready, wr_level_start, and rd_data_rise0, while outputs include wrlvl_byte_done, wr_level_done, and various debug signals. Internal signals such as wl_state_r, wl_tap_count_r, and corse_cnt manage the state machine and delay adjustments. The module",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_wrlvl\n\nExplanation: This module implements the write leveling functionality for a DDR memory interface. It adjusts the timing of DQS (data strobe) signals relative to the clock signal to ensure proper data capture during writes. The module uses a state machine to incrementally adjust both fine and coarse delay taps, detecting edges in the received data to determine optimal timing. It supports multiple ranks and includes features for initial calibration, fine-tuning, and error handling. The module also implements fast calibration options and provides debug outputs for monitoring the write leveling process."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, rst, phy_ctl_ready, wr_level_start, wl_sm_start, wrlvl_final, wrlvl_byte_redo, wrcal_cnt, early1_data, early2_data, oclkdelay_calib_cnt, oclkdelay_calib_done, rd_data_rise0, po_counter_read_val.\n\nExplanation:\n- clk: System clock input\n- rst: Reset signal\n- phy_ctl_ready: PHY control ready signal\n- wr_level_start: Write leveling start signal\n- wl_sm_start: Write leveling state machine start signal\n- wrlvl_final: Final write leveling signal\n- wrlvl_byte_redo: Signal to redo write leveling for a specific byte\n- wrcal_cnt: Write calibration count\n- early1_data, early2_data: Early data signals for timing adjustment\n- oclkdelay_calib_cnt: Output clock delay calibration count\n- oclkdelay_calib_done: Output clock delay calibration done signal\n- rd_data_rise0: Read data on rising edge\n- po_counter_read_val: Phase offset counter read value\n\nOutput ports:\nwrlvl_byte_done, dqs_po_dec_done, wr_level_done, wrlvl_rank_done, done_dqs_tap_inc, po_stg2_wl_cnt, dqs_po_stg2_f_incdec, dqs_po_en_stg2_f, dqs_wl_po_stg2_c_incdec, dqs_wl_po_en_stg2_c, wrlvl_err, wl_po_coarse_cnt, wl_po_fine_cnt, dbg_wl_tap_cnt, dbg_wl_edge_detect_valid, dbg_rd_data_edge_detect, dbg_dqs_count, dbg_wl_state, dbg_wrlvl_fine_tap_cnt, dbg_wrlvl_coarse_tap_cnt, dbg_phy_wrlvl.\n\nExplanation:\n- wrlvl_byte_done: Write leveling byte done signal\n- dqs_po_dec_done: DQS phase offset decrement done signal\n- wr_level_done: Write leveling done signal\n- wrlvl_rank_done: Write leveling rank done signal\n- done_dqs_tap_inc: DQS tap increment done signal\n- po_stg2_wl_cnt: Phase offset stage 2 write leveling count\n- dqs_po_stg2_f_incdec: DQS phase offset stage 2 fine increment/decrement signal\n- dqs_po_en_stg2_f: DQS phase offset stage 2 fine enable signal\n- dqs_wl_po_stg2_c_incdec: DQS write leveling phase offset stage 2 coarse increment/decrement signal\n- dqs_wl_po_en_stg2_c: DQS write leveling phase offset stage 2 coarse enable signal\n- wrlvl_err: Write leveling error signal\n- wl_po_coarse_cnt: Write leveling phase offset coarse count\n- wl_po_fine_cnt: Write leveling phase offset fine count\n- Various debug outputs (dbg_*): Signals for monitoring and debugging the write leveling process"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nwl_state_r, wl_state_r1, wl_tap_count_r, fine_dec_cnt, corse_cnt, fine_inc, corse_dec, corse_inc, dqs_count_r, rank_cnt_r, rd_data_rise_wl_r, rd_data_previous_r, rd_data_edge_detect_r, wr_level_done_r, wrlvl_rank_done_r, wr_level_start_r, inhibit_edge_detect_r, wl_edge_detect_valid_r, stable_cnt, flag_ck_negedge, flag_init, wl_dqs_tap_count_r, smallest, largest, final_val, po_dec_cnt, done_dqs_dec, po_rdval_cnt, po_cnt_dec, po_dec_done, dual_rnk_dec, fast_cal_fine_cnt, fast_cal_coarse_cnt, wrlvl_byte_redo_r, wrlvl_redo_corse_inc, wrlvl_final_r, final_corse_dec, wrlvl_tap_done_r, wait_cnt, incdec_wait_cnt.\n\nExplanation:\n- wl_state_r, wl_state_r1: Current and previous states of the write leveling state machine\n- wl_tap_count_r: Counter for fine delay taps\n- fine_dec_cnt: Counter for fine delay decrements\n- corse_cnt: Array to store coarse delay counts for each DQS\n- fine_inc, corse_dec, corse_inc: Arrays to store fine/coarse increment/decrement values for each DQS\n- dqs_count_r: Counter for current DQS being processed\n- rank_cnt_r: Counter for current rank being processed\n- rd_data_rise_wl_r: Registered read data on rising edge for write leveling\n- rd_data_previous_r: Previous read data for edge detection\n- rd_data_edge_detect_r: Edge detection signal for read data\n- wr_level_done_r: Write leveling done signal (registered)\n- wrlvl_rank_done_r: Write leveling rank done signal (registered)\n- wr_level_start_r: Write leveling start signal (registered)\n- inhibit_edge_detect_r: Signal to inhibit edge detection\n- wl_edge_detect_valid_r: Valid signal for write leveling edge detection\n- stable_cnt: Counter for stable data detection\n- flag_ck_negedge: Flag for clock negative edge detection\n- flag_init: Flag for initialization state\n- wl_dqs_tap_count_r: Array to store tap counts for each DQS and rank\n- smallest, largest: Arrays to store smallest and largest tap values for each DQS\n- final_val: Array to store final tap values for each DQS\n- po_dec_cnt: Array to store phase offset decrement counts for each DQS\n- done_dqs_dec: Signal indicating DQS decrement is done\n- po_rdval_cnt: Counter for phase offset read value\n- po_cnt_dec: Signal to decrement phase offset counter\n- po_dec_done: Signal indicating phase offset decrement is done\n- dual_rnk_dec: Flag for dual rank decrement\n- fast_cal_fine_cnt, fast_cal_coarse_cnt: Counters for fast calibration mode\n- wrlvl_byte_redo_r: Registered signal for byte redo\n- wrlvl_redo_corse_inc: Counter for coarse increments during byte redo\n- wrlvl_final_r: Registered final write leveling signal\n- final_corse_dec: Flag for final coarse decrement\n- wrlvl_tap_done_r: Signal indicating write leveling tap adjustment is done\n- wait_cnt: Counter for wait states\n- incdec_wait_cnt: Counter for increment/decrement wait states"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule mig_7series_v4_1_ddr_phy_wrlvl #\n  (\n   parameter TCQ = 100,\n   parameter DQS_CNT_WIDTH     = 3,\n   parameter DQ_WIDTH          = 64,\n   parameter DQS_WIDTH         = 2,\n   parameter DRAM_WIDTH        = 8,\n   parameter RANKS             = 1,\n   parameter nCK_PER_CLK       = 4,\n   parameter CLK_PERIOD        = 4,\n   parameter SIM_CAL_OPTION    = \"NONE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   input                        phy_ctl_ready,\n   input                        wr_level_start,\n   input                        wl_sm_start,\n   input                        wrlvl_final,\n   input                        wrlvl_byte_redo,\n   input [DQS_CNT_WIDTH:0]      wrcal_cnt,\n   input                        early1_data,\n   input                        early2_data,\n   input [DQS_CNT_WIDTH:0]      oclkdelay_calib_cnt,\n   input                        oclkdelay_calib_done,\n   input [(DQ_WIDTH)-1:0]       rd_data_rise0,\n   output reg                   wrlvl_byte_done,\n    output reg dqs_po_dec_done ,\n   output                       phy_ctl_rdy_dly,\n    output reg wr_level_done ,\n   \n   output                       wrlvl_rank_done,\n   output                       done_dqs_tap_inc,\n   output [DQS_CNT_WIDTH:0]     po_stg2_wl_cnt,\n   \n   \n   output reg                   dqs_po_stg2_f_incdec,\n   \n   output reg                   dqs_po_en_stg2_f,\n   \n   \n   \n   \n   output reg                   dqs_wl_po_stg2_c_incdec,\n   \n   output reg                   dqs_wl_po_en_stg2_c,\n   \n   input [8:0]                  po_counter_read_val,\n\n\n   \n   output reg                   wrlvl_err,\n   output reg [3*DQS_WIDTH-1:0] wl_po_coarse_cnt,\n   output reg [6*DQS_WIDTH-1:0] wl_po_fine_cnt,\n   \n   output [5:0]                 dbg_wl_tap_cnt,\n   output                       dbg_wl_edge_detect_valid,\n   output [(DQS_WIDTH)-1:0]     dbg_rd_data_edge_detect,\n   output [DQS_CNT_WIDTH:0]     dbg_dqs_count,\n   output [4:0]                 dbg_wl_state,\n   output [6*DQS_WIDTH-1:0]     dbg_wrlvl_fine_tap_cnt,\n   output [3*DQS_WIDTH-1:0]     dbg_wrlvl_coarse_tap_cnt,\n   output [255:0]               dbg_phy_wrlvl   \n   );\n\n\n   localparam WL_IDLE               = 5'h0;\n   localparam WL_INIT               = 5'h1;\n   localparam WL_INIT_FINE_INC      = 5'h2;\n   localparam WL_INIT_FINE_INC_WAIT1= 5'h3;\n   localparam WL_INIT_FINE_INC_WAIT = 5'h4;\n   localparam WL_INIT_FINE_DEC      = 5'h5;\n   localparam WL_INIT_FINE_DEC_WAIT = 5'h6;\n   localparam WL_FINE_INC           = 5'h7;\n   localparam WL_WAIT               = 5'h8;\n   localparam WL_EDGE_CHECK         = 5'h9;\n   localparam WL_DQS_CHECK          = 5'hA;\n   localparam WL_DQS_CNT            = 5'hB;\n   localparam WL_2RANK_TAP_DEC      = 5'hC;\n   localparam WL_2RANK_DQS_CNT      = 5'hD;\n   localparam WL_FINE_DEC           = 5'hE;\n   localparam WL_FINE_DEC_WAIT      = 5'hF;\n   localparam WL_CORSE_INC          = 5'h10;\n   localparam WL_CORSE_INC_WAIT     = 5'h11;\n   localparam WL_CORSE_INC_WAIT1    = 5'h12;\n   localparam WL_CORSE_INC_WAIT2    = 5'h13;\n   localparam WL_CORSE_DEC          = 5'h14;\n   localparam WL_CORSE_DEC_WAIT     = 5'h15;\n   localparam WL_CORSE_DEC_WAIT1    = 5'h16;\n   localparam WL_FINE_INC_WAIT      = 5'h17;\n   localparam WL_2RANK_FINAL_TAP    = 5'h18;\n   localparam WL_INIT_FINE_DEC_WAIT1= 5'h19;\n   localparam WL_FINE_DEC_WAIT1     = 5'h1A;\n   localparam WL_CORSE_INC_WAIT_TMP = 5'h1B;\n\n   localparam  COARSE_TAPS = 7;\n   \n   localparam FAST_CAL_FINE   = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 45 : 48;\n   localparam FAST_CAL_COARSE = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 1 : 2;\n   localparam REDO_COARSE = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 2 : 5;\n\n\n   integer     i, j, k, l, p, q, r, s, t, m, n, u, v, w, x,y;\n\n   reg                   phy_ctl_ready_r1;\n   reg                   phy_ctl_ready_r2;\n   reg                   phy_ctl_ready_r3;\n   reg                   phy_ctl_ready_r4;\n   reg                   phy_ctl_ready_r5;\n   reg                   phy_ctl_ready_r6;\n   (* max_fanout = 50 *) reg [DQS_CNT_WIDTH:0] dqs_count_r;\n   reg [1:0]             rank_cnt_r;\n   reg [DQS_WIDTH-1:0]   rd_data_rise_wl_r;\n   reg [DQS_WIDTH-1:0]   rd_data_previous_r;\n   reg [DQS_WIDTH-1:0]   rd_data_edge_detect_r;\n   reg                   wr_level_done_r;\n   reg                   wrlvl_rank_done_r;\n   reg                   wr_level_start_r;\n   reg [4:0]             wl_state_r, wl_state_r1;\n   reg                   inhibit_edge_detect_r;\n   reg                   wl_edge_detect_valid_r;\n   reg [5:0]             wl_tap_count_r;\n   reg [5:0]             fine_dec_cnt;\n   reg [5:0]             fine_inc[0:DQS_WIDTH-1];  \n   reg [2:0]             corse_dec[0:DQS_WIDTH-1];\n   reg [2:0]             corse_inc[0:DQS_WIDTH-1];\n   reg                   dq_cnt_inc;\n   reg [3:0]             stable_cnt;\n   reg                   flag_ck_negedge;\n   \n   reg                   flag_init;\n   reg [2:0]             corse_cnt[0:DQS_WIDTH-1];\n   reg [3*DQS_WIDTH-1:0] corse_cnt_dbg;\n   reg [2:0]             wl_corse_cnt[0:RANKS-1][0:DQS_WIDTH-1];\n   \n   reg [2:0]             final_coarse_tap[0:DQS_WIDTH-1];\n   reg [5:0]             add_smallest[0:DQS_WIDTH-1];\n   reg [5:0]             add_largest[0:DQS_WIDTH-1];\n \n   \n   reg                   wr_level_done_r1;\n   reg                   wr_level_done_r2;\n   reg                   wr_level_done_r3;\n   reg                   wr_level_done_r4;\n   reg                   wr_level_done_r5;\n   reg [5:0]             wl_dqs_tap_count_r[0:RANKS-1][0:DQS_WIDTH-1];\n   reg [5:0]             smallest[0:DQS_WIDTH-1];\n   reg [5:0]             largest[0:DQS_WIDTH-1];\n   reg [5:0]             final_val[0:DQS_WIDTH-1];\n   reg [5:0]             po_dec_cnt[0:DQS_WIDTH-1];\n   reg                   done_dqs_dec;\n   reg [8:0]             po_rdval_cnt;\n   reg                   po_cnt_dec;\n   reg                   po_dec_done;\n   reg                   dual_rnk_dec;\n   wire [DQS_CNT_WIDTH+2:0] dqs_count_w;\n   reg [5:0]             fast_cal_fine_cnt;\n   reg [2:0]             fast_cal_coarse_cnt;\n   reg                   wrlvl_byte_redo_r;\n   reg [2:0]             wrlvl_redo_corse_inc;\n   reg                   wrlvl_final_r;\n   reg                   final_corse_dec;\n   wire [DQS_CNT_WIDTH+2:0] oclk_count_w;\n   reg                   wrlvl_tap_done_r ;\n   reg [3:0]             wait_cnt;\n   reg [3:0]             incdec_wait_cnt;\n \n\n\n  \n   assign dbg_wl_edge_detect_valid = wl_edge_detect_valid_r;\n   assign dbg_rd_data_edge_detect  = rd_data_edge_detect_r;\n   assign dbg_wl_tap_cnt           = wl_tap_count_r;\n   assign dbg_dqs_count            = dqs_count_r;\n   assign dbg_wl_state             = wl_state_r;\n   assign dbg_wrlvl_fine_tap_cnt   = wl_po_fine_cnt;\n   assign dbg_wrlvl_coarse_tap_cnt = wl_po_coarse_cnt;\n\n   always @(*) begin\n     for (v = 0; v < DQS_WIDTH; v = v + 1)\n       corse_cnt_dbg[3*v+:3] = corse_cnt[v];\n   end\n  \n   assign dbg_phy_wrlvl[0+:27]  = corse_cnt_dbg;\n   assign dbg_phy_wrlvl[27+:5]  = wl_state_r;\n   assign dbg_phy_wrlvl[32+:4]  = dqs_count_r;\n   assign dbg_phy_wrlvl[36+:9]  = rd_data_rise_wl_r;\n   assign dbg_phy_wrlvl[45+:9]  = rd_data_previous_r;\n   assign dbg_phy_wrlvl[54+:4]  = stable_cnt;\n   assign dbg_phy_wrlvl[58]     = 'd0;\n   assign dbg_phy_wrlvl[59]     = flag_ck_negedge;\n\n   assign dbg_phy_wrlvl [60]    = wl_edge_detect_valid_r;\n   assign dbg_phy_wrlvl [61+:6] = wl_tap_count_r;\n   assign dbg_phy_wrlvl [67+:9] = rd_data_edge_detect_r;\n   assign dbg_phy_wrlvl [76+:54]  = wl_po_fine_cnt;\n   assign dbg_phy_wrlvl [130+:27] = wl_po_coarse_cnt;\n  \n\n   \n   \n   \n   \n   assign po_stg2_wl_cnt = dqs_count_r;\n\n   assign wrlvl_rank_done = wrlvl_rank_done_r;\n   \n   assign done_dqs_tap_inc = done_dqs_dec;\n   \n   assign phy_ctl_rdy_dly = phy_ctl_ready_r6;\n   \n   always @(posedge clk) begin\n     phy_ctl_ready_r1  <= #TCQ phy_ctl_ready;\n     phy_ctl_ready_r2  <= #TCQ phy_ctl_ready_r1;\n     phy_ctl_ready_r3  <= #TCQ phy_ctl_ready_r2;\n     phy_ctl_ready_r4  <= #TCQ phy_ctl_ready_r3;\n     phy_ctl_ready_r5  <= #TCQ phy_ctl_ready_r4;\n     phy_ctl_ready_r6  <= #TCQ phy_ctl_ready_r5;\n     wrlvl_byte_redo_r <= #TCQ wrlvl_byte_redo;\n     wrlvl_final_r     <= #TCQ wrlvl_final;\n     if ((wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n       wr_level_done  <= #TCQ 1'b0;\n     else\n       wr_level_done  <= #TCQ done_dqs_dec;\n   end\n\n\n\n   always @(posedge clk) begin\n     if(rst) begin\n       wrlvl_tap_done_r <= #TCQ 1'b0 ;\n     end else begin\n       if(wrlvl_tap_done_r == 1'b0) begin\n         if(oclkdelay_calib_done) begin\n\t   wrlvl_tap_done_r <= #TCQ 1'b1 ;\n\t end\n       end\n     end\n   end\n   \n   always @(posedge clk) begin\n     if (rst || po_cnt_dec)\n       wait_cnt <= #TCQ 'd8;\n     else if (phy_ctl_ready_r6 && (wait_cnt > 'd0))\n       wait_cnt <= #TCQ wait_cnt - 1;\n   end\n   \n   always @(posedge clk) begin\n     if (rst) begin\n       po_rdval_cnt    <= #TCQ 'd0;\n     end else if (phy_ctl_ready_r5 && ~phy_ctl_ready_r6) begin\n       po_rdval_cnt    <= #TCQ po_counter_read_val;\n     end else if (po_rdval_cnt > 'd0) begin\n       if (po_cnt_dec)\n         po_rdval_cnt  <= #TCQ po_rdval_cnt - 1;\n       else            \n         po_rdval_cnt  <= #TCQ po_rdval_cnt;\n     end else if (po_rdval_cnt == 'd0) begin\n       po_rdval_cnt    <= #TCQ po_rdval_cnt;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (po_rdval_cnt == 'd0))\n       po_cnt_dec      <= #TCQ 1'b0;\n     else if (phy_ctl_ready_r6 && (po_rdval_cnt > 'd0) && (wait_cnt == 'd1))\n       po_cnt_dec      <= #TCQ 1'b1;\n     else\n       po_cnt_dec      <= #TCQ 1'b0;\n     end\n   \n   always @(posedge clk) begin\n     if (rst)\n       po_dec_done <= #TCQ 1'b0;\n     else if (((po_cnt_dec == 'd1) && (po_rdval_cnt == 'd1)) || \n              (phy_ctl_ready_r6 && (po_rdval_cnt == 'd0))) begin\n       po_dec_done <= #TCQ 1'b1;\n     end\n   end\n\n   \n   always @(posedge clk) begin\n     dqs_po_dec_done  <= #TCQ po_dec_done;\n     wr_level_done_r1 <= #TCQ wr_level_done_r;\n     wr_level_done_r2 <= #TCQ wr_level_done_r1;\n     wr_level_done_r3 <= #TCQ wr_level_done_r2;\n     wr_level_done_r4 <= #TCQ wr_level_done_r3;\n     wr_level_done_r5 <= #TCQ wr_level_done_r4;\n     for (l = 0; l < DQS_WIDTH; l = l + 1) begin \n       wl_po_coarse_cnt[3*l+:3] <= #TCQ final_coarse_tap[l];\n       if ((RANKS == 1) || ~oclkdelay_calib_done)\n         wl_po_fine_cnt[6*l+:6] <= #TCQ smallest[l];\n       else \n         wl_po_fine_cnt[6*l+:6] <= #TCQ final_val[l];\n     end\n   end\n   \n   generate\n   if (RANKS == 2) begin: dual_rank\n     always @(posedge clk) begin\n       if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n         done_dqs_dec <= #TCQ 1'b0;\n       else if ((SIM_CAL_OPTION == \"FAST_CAL\") || ~oclkdelay_calib_done)\n         done_dqs_dec <= #TCQ wr_level_done_r;\n       else if (wr_level_done_r5 && (wl_state_r == WL_IDLE))\n         done_dqs_dec <= #TCQ 1'b1;\n     end\n   end else begin: single_rank\n     always @(posedge clk) begin\n       if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n         done_dqs_dec <= #TCQ 1'b0;\n       else if (~oclkdelay_calib_done)\n         done_dqs_dec <= #TCQ wr_level_done_r;\n       else if (wr_level_done_r3 && ~wr_level_done_r4)\n         done_dqs_dec <= #TCQ 1'b1;\n     end\n   end\n   endgenerate\n   \n   always @(posedge clk)\n     if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r))\n       wrlvl_byte_done <= #TCQ 1'b0;\n     else if (wrlvl_byte_redo && wr_level_done_r3 && ~wr_level_done_r4)\n       wrlvl_byte_done <= #TCQ 1'b1;\n  \n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for (k = 0; k < RANKS; k = k + 1) begin: rst_wl_dqs_tap_count_loop\n         for (n = 0; n < DQS_WIDTH; n = n + 1) begin\n           wl_corse_cnt[k][n]       <= #TCQ 'b0;\n           wl_dqs_tap_count_r[k][n] <= #TCQ 'b0;\n         end\n       end\n     end else if ((wl_state_r == WL_DQS_CNT) | (wl_state_r == WL_WAIT) | \n                  (wl_state_r == WL_FINE_DEC_WAIT1) |\n                  (wl_state_r == WL_2RANK_TAP_DEC)) begin\n         wl_dqs_tap_count_r[rank_cnt_r][dqs_count_r] <= #TCQ wl_tap_count_r;\n         wl_corse_cnt[rank_cnt_r][dqs_count_r]       <= #TCQ corse_cnt[dqs_count_r];\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (wl_state_r == WL_DQS_CHECK)) begin\n       for (p = 0; p < RANKS; p = p +1) begin: dqs_tap_rank_cnt   \n         for(q = 0; q < DQS_WIDTH; q = q +1) begin: dqs_tap_dqs_cnt\n           wl_dqs_tap_count_r[p][q] <= #TCQ wl_tap_count_r;\n           wl_corse_cnt[p][q]       <= #TCQ corse_cnt[0];\n         end\n       end\n     end\n   end\n   \n   \n   \n   \n   \n   \n   \n\n   generate\n   genvar cnt;\n   if (RANKS == 2) begin \n     for(cnt = 0; cnt < DQS_WIDTH; cnt = cnt +1) begin: coarse_dqs_cnt\n       always @(posedge clk) begin\n         if (rst) begin\n           \n           add_smallest[cnt]         <= #TCQ 'd0;\n           add_largest[cnt]          <= #TCQ 'd0;\n           final_coarse_tap[cnt]     <= #TCQ 'd0;\n         end else if (wr_level_done_r1 & ~wr_level_done_r2) begin\n           if (~oclkdelay_calib_done) begin\n\t    for(y = 0 ; y < DQS_WIDTH; y = y+1) begin\n              final_coarse_tap[y] <= #TCQ wl_corse_cnt[0][y]; \n              add_smallest[y]     <= #TCQ 'd0;\n              add_largest[y]      <= #TCQ 'd0;\n\t     end\n           end else \n\t   if (wl_corse_cnt[0][cnt] == wl_corse_cnt[1][cnt]) begin\n           \n           \n             \n             final_coarse_tap[cnt]     <= #TCQ wl_corse_cnt[1][cnt];\n             add_smallest[cnt]         <= #TCQ 'd0;\n             add_largest[cnt]          <= #TCQ 'd0;\n           end else if (wl_corse_cnt[0][cnt] < wl_corse_cnt[1][cnt]) begin\n           \n           \n           \n             \n             final_coarse_tap[cnt]     <= #TCQ wl_corse_cnt[1][cnt] - 1;\n             if (|wl_corse_cnt[0][cnt])\n               \n               \n               \n               add_largest[cnt] <= #TCQ 'd38;\n             else\n               \n               \n               \n               add_largest[cnt] <= #TCQ 'd34;\n           end else if (wl_corse_cnt[0][cnt] > wl_corse_cnt[1][cnt]) begin\n           \n           \n           \n             \n             final_coarse_tap[cnt]   <= #TCQ wl_corse_cnt[1][cnt];\n             if (|wl_corse_cnt[1][cnt])\n               \n               \n               \n               add_smallest[cnt] <= #TCQ 'd38;\n             else\n               \n               \n               \n               add_smallest[cnt] <= #TCQ 'd34;\n           end\n         end\n       end\n     end\n   end else begin\n \n     always @(posedge clk) begin\n       \n       for(w = 0; w < DQS_WIDTH; w = w + 1) begin\n         final_coarse_tap[w] <= #TCQ wl_corse_cnt[0][w];\n         add_smallest[w]     <= #TCQ 'd0;\n         add_largest[w]      <= #TCQ 'd0;\n       end\n     end\n   end\n   endgenerate\n\n   \n   \n   \n   \n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for(x = 0; x < DQS_WIDTH; x = x +1) begin\n         smallest[x] <= #TCQ 'b0;\n         largest[x]  <= #TCQ 'b0;\n       end\n     end else if ((wl_state_r == WL_DQS_CNT) & wrlvl_byte_redo) begin\n       smallest[dqs_count_r] <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n       largest[dqs_count_r]  <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n     end else if ((wl_state_r == WL_DQS_CNT) | \n                  (wl_state_r == WL_2RANK_TAP_DEC)) begin\n       smallest[dqs_count_r] <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n       largest[dqs_count_r]  <= #TCQ wl_dqs_tap_count_r[RANKS-1][dqs_count_r];\n     end else if (((SIM_CAL_OPTION == \"FAST_CAL\") | \n                   (~oclkdelay_calib_done & ~wrlvl_byte_redo)) & \n                  wr_level_done_r1 & ~wr_level_done_r2) begin\n       for(i = 0; i < DQS_WIDTH; i = i +1) begin: smallest_dqs\n         smallest[i] <= #TCQ wl_dqs_tap_count_r[0][i];\n         largest[i]  <= #TCQ wl_dqs_tap_count_r[0][i];\n       end\n     end\n   end\n\n   \n\n   genvar wr_i;\n   generate\n     for (wr_i = 0; wr_i < DQS_WIDTH; wr_i = wr_i +1) begin: gen_final_tap\n      always @(posedge clk) begin\n        if (rst)\n          final_val[wr_i] <= #TCQ 'b0;\n        else if (wr_level_done_r2 && ~wr_level_done_r3) begin\n          if (~oclkdelay_calib_done)\n            final_val[wr_i] <= #TCQ (smallest[wr_i] + add_smallest[wr_i]); \n          else if ((smallest[wr_i] + add_smallest[wr_i]) < \n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ ((smallest[wr_i] + add_smallest[wr_i]) +\n                                     (((largest[wr_i] + add_largest[wr_i]) -\n                                     (smallest[wr_i] + add_smallest[wr_i]))/2));\n          else if ((smallest[wr_i] + add_smallest[wr_i]) >\n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ ((largest[wr_i] + add_largest[wr_i]) +\n                                     (((smallest[wr_i] + add_smallest[wr_i]) -\n                                     (largest[wr_i] + add_largest[wr_i]))/2));\n          else if ((smallest[wr_i] + add_smallest[wr_i]) ==\n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ (largest[wr_i] + add_largest[wr_i]);\n        end\n      end\n     end\n   endgenerate\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   \n   \n   always @(posedge clk) begin\n     if (rst) begin\n     \n       dqs_po_stg2_f_incdec   <= #TCQ 1'b0;\n       dqs_po_en_stg2_f       <= #TCQ 1'b0;\n     \n     \n     \n     end else if (po_cnt_dec || (wl_state_r == WL_INIT_FINE_DEC) ||\n                  (wl_state_r == WL_FINE_DEC)) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     \n     end else if ((wl_state_r == WL_INIT_FINE_INC) ||\n                  (wl_state_r == WL_FINE_INC)) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b1;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     end else begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b0; \n     end\n   end\n   \n\n   \n   always @(posedge clk) begin\n     if (rst) begin\n     \n     \n     \n       dqs_wl_po_stg2_c_incdec   <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c       <= #TCQ 1'b0;\n     end else if (wl_state_r == WL_CORSE_INC) begin\n     \n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b1;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b1;\n     end else begin\n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b0; \n     end\n   end\n     \n\n   \n   \n   \n\ngenvar rd_i;\ngenerate\n  for(rd_i = 0; rd_i < DQS_WIDTH; rd_i = rd_i +1)begin: gen_rd\n   always @(posedge clk)\n     rd_data_rise_wl_r[rd_i] <=\n     #TCQ |rd_data_rise0[(rd_i*DRAM_WIDTH)+DRAM_WIDTH-1:rd_i*DRAM_WIDTH];\n  end\nendgenerate\n\n\n   \n   always @(posedge clk)begin\n     if ((wl_state_r == WL_INIT) || \n         \n\t\t ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) & (wl_state_r == WL_INIT_FINE_INC)) ||\n         (wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT1) || (wl_state_r == WL_FINE_DEC_WAIT) ||\n         (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) || (wl_state_r == WL_CORSE_INC_WAIT_TMP) || \n         (wl_state_r == WL_CORSE_INC_WAIT1) || (wl_state_r == WL_CORSE_INC_WAIT2) ||\n         ((wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)))\n       rd_data_previous_r         <= #TCQ rd_data_rise_wl_r;\n   end\n   \n   \n   always @(posedge clk)begin\n      if (rst | (wl_state_r == WL_DQS_CNT) |\n         (wl_state_r == WL_2RANK_TAP_DEC) |\n         (wl_state_r == WL_FINE_DEC) |\n         (rd_data_previous_r[dqs_count_r] != rd_data_rise_wl_r[dqs_count_r]) |\n         (wl_state_r1 == WL_INIT_FINE_DEC))\n        stable_cnt <= #TCQ 'd0;\n      else if ((wl_tap_count_r > 6'd0) & \n         (((wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)) |\n         ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) & (wl_state_r == WL_INIT_FINE_INC)))) begin\n        if ((rd_data_previous_r[dqs_count_r] == rd_data_rise_wl_r[dqs_count_r])\n           & (stable_cnt < 'd14))\n          stable_cnt <= #TCQ stable_cnt + 1;\n      end\n   end\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   always @(posedge clk)begin\n      if (rst | (wl_state_r == WL_DQS_CNT) |\n         (wl_state_r == WL_DQS_CHECK) | wr_level_done_r |\n         (wl_state_r1 == WL_INIT_FINE_DEC))\n        flag_ck_negedge <= #TCQ 1'd0;\n      else if ((rd_data_previous_r[dqs_count_r] && ((stable_cnt > 'd0) |\n              (wl_state_r == WL_FINE_DEC) | (wl_state_r == WL_FINE_DEC_WAIT) | (wl_state_r == WL_FINE_DEC_WAIT1))) |\n\t\t\t  (wl_state_r == WL_CORSE_INC)) \n        flag_ck_negedge <= #TCQ 1'd1;\n      else if (~rd_data_previous_r[dqs_count_r] && (stable_cnt == 'd14))\n               \n        flag_ck_negedge <= #TCQ 1'd0;\n   end\n   \n   \n   always @(posedge clk) begin\n     if (rst)\n       flag_init <= #TCQ 1'b1;\n     else if ((wl_state_r == WL_WAIT) && ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) ||\n              (wl_state_r1 == WL_INIT_FINE_DEC_WAIT)))\n       flag_init <= #TCQ 1'b0;\n   end\n\n   \n   always @(posedge clk)begin\n     if (rst | flag_ck_negedge | flag_init | (wl_tap_count_r < 'd1) |\n         inhibit_edge_detect_r)\n       rd_data_edge_detect_r     <= #TCQ {DQS_WIDTH{1'b0}};\n     else if (rd_data_edge_detect_r[dqs_count_r] == 1'b1) begin\n       if ((wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT) || (wl_state_r == WL_FINE_DEC_WAIT1) ||\n           (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) || (wl_state_r == WL_CORSE_INC_WAIT_TMP) ||\n           (wl_state_r == WL_CORSE_INC_WAIT1) || (wl_state_r == WL_CORSE_INC_WAIT2))\n         rd_data_edge_detect_r <= #TCQ {DQS_WIDTH{1'b0}};\n       else\n         rd_data_edge_detect_r <= #TCQ rd_data_edge_detect_r;\n     end else if (rd_data_previous_r[dqs_count_r] && (stable_cnt < 'd14))\n       rd_data_edge_detect_r     <= #TCQ {DQS_WIDTH{1'b0}};\n     else\n       rd_data_edge_detect_r <= #TCQ (~rd_data_previous_r & rd_data_rise_wl_r);\n   end\n\n\n  \n  \n   always@(posedge clk) begin\n     wr_level_start_r <= #TCQ wr_level_start;\n   end\n\n   \n   \n   assign dqs_count_w = {2'b00, dqs_count_r};\n\n   assign oclk_count_w = {2'b00, oclkdelay_calib_cnt};\n   \n   always @(posedge clk) begin\n     if (rst)\n       incdec_wait_cnt <= #TCQ 'd0;\n     else if ((wl_state_r == WL_FINE_DEC_WAIT1) ||\n             (wl_state_r == WL_INIT_FINE_DEC_WAIT1) ||\n             (wl_state_r == WL_CORSE_INC_WAIT_TMP))\n       incdec_wait_cnt <= #TCQ incdec_wait_cnt + 1;\n     else\n       incdec_wait_cnt <= #TCQ 'd0;\n   end\n   \n \n   \n   \n   \n   \n   \n   \n   always @(posedge clk) begin\n      if(rst)begin\n         wrlvl_err              <= #TCQ 1'b0;\n         wr_level_done_r        <= #TCQ 1'b0;\n         wrlvl_rank_done_r      <= #TCQ 1'b0;\n         dqs_count_r            <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n         dq_cnt_inc             <= #TCQ 1'b1;\n         rank_cnt_r             <= #TCQ 2'b00;\n         wl_state_r             <= #TCQ WL_IDLE;\n         wl_state_r1            <= #TCQ WL_IDLE;\n         inhibit_edge_detect_r  <= #TCQ 1'b1;\n         wl_edge_detect_valid_r <= #TCQ 1'b0;\n         wl_tap_count_r         <= #TCQ 6'd0;\n         fine_dec_cnt           <= #TCQ 6'd0;\n         for (r = 0; r < DQS_WIDTH; r = r + 1) begin\n           fine_inc[r]          <= #TCQ 6'b0;\n           corse_dec[r]         <= #TCQ 3'b0;\n           corse_inc[r]         <= #TCQ 3'b0;\n           corse_cnt[r]         <= #TCQ 3'b0;\n         end\n         dual_rnk_dec           <= #TCQ 1'b0;\n         fast_cal_fine_cnt      <= #TCQ FAST_CAL_FINE;\n         fast_cal_coarse_cnt    <= #TCQ FAST_CAL_COARSE;\n         final_corse_dec        <= #TCQ 1'b0;\n         \n         wrlvl_redo_corse_inc   <= #TCQ 'd0;\n      end else begin\n         wl_state_r1            <= #TCQ wl_state_r;\n         case (wl_state_r)\n           \n           WL_IDLE: begin\n              wrlvl_rank_done_r      <= #TCQ 1'd0;\n              inhibit_edge_detect_r  <= #TCQ 1'b1;\n              if (wrlvl_byte_redo && ~wrlvl_byte_redo_r) begin\n                wr_level_done_r      <= #TCQ 1'b0;\n                dqs_count_r          <= #TCQ wrcal_cnt;\n                corse_cnt[wrcal_cnt] <= #TCQ final_coarse_tap[wrcal_cnt];\n                wl_tap_count_r       <= #TCQ smallest[wrcal_cnt];\n                if (early1_data && \n                    (((final_coarse_tap[wrcal_cnt] < 'd6) && (CLK_PERIOD/nCK_PER_CLK <= 2500)) ||\n                    ((final_coarse_tap[wrcal_cnt] < 'd3) && (CLK_PERIOD/nCK_PER_CLK > 2500))))\n                  wrlvl_redo_corse_inc <= #TCQ REDO_COARSE;\n                else if (early2_data && (final_coarse_tap[wrcal_cnt] < 'd2))\n                  wrlvl_redo_corse_inc <= #TCQ 3'd6;\n                else begin\n                  wl_state_r   <= #TCQ WL_IDLE;\n                  wrlvl_err    <= #TCQ 1'b1;\n                end\n              end else if (wrlvl_final && ~wrlvl_final_r) begin\n                wr_level_done_r <= #TCQ 1'b0;\n                dqs_count_r     <= #TCQ 'd0;\n              end\n\t\t\t\t\t\t\t\n              if(!wr_level_done_r & wr_level_start_r & wl_sm_start) begin\n                if (SIM_CAL_OPTION == \"FAST_CAL\")\n                  wl_state_r <= #TCQ WL_FINE_INC;\n                else\n                  wl_state_r <= #TCQ WL_INIT;\n              end\n           end\n           \n           WL_INIT: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              inhibit_edge_detect_r  <= #TCQ 1'b1;\n              wrlvl_rank_done_r      <= #TCQ 1'd0;\n              \n              if (wrlvl_final)\n                corse_cnt[dqs_count_w ]  <= #TCQ final_coarse_tap[dqs_count_w ]; \n              if (wrlvl_byte_redo) begin\n                if (|wl_tap_count_r) begin\n                  wl_state_r   <= #TCQ WL_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end else if ((corse_cnt[dqs_count_w] + wrlvl_redo_corse_inc) <= 'd7)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r   <= #TCQ WL_IDLE;\n                  wrlvl_err    <= #TCQ 1'b1;\n                end\n              end else if(wl_sm_start)\n                wl_state_r <= #TCQ WL_INIT_FINE_INC;\n           end\n           \n           \n           \n           \n           \n           \n           \n           WL_INIT_FINE_INC: begin\n              wl_state_r   <= #TCQ WL_INIT_FINE_INC_WAIT1;\n              wl_tap_count_r <= #TCQ wl_tap_count_r + 1'b1;\n              final_corse_dec <= #TCQ 1'b0;\n           end\n\n           WL_INIT_FINE_INC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_INIT_FINE_INC_WAIT;\n           end\n\n           \n           \n           \n           \n           \n           \n           \n           WL_INIT_FINE_INC_WAIT: begin\n              if (wl_sm_start) begin\n                if (stable_cnt < 'd14)\n                  wl_state_r   <= #TCQ WL_INIT_FINE_INC;\n                else if (~rd_data_previous_r[dqs_count_r]) begin\n                  wl_state_r             <= #TCQ WL_WAIT;\n                  inhibit_edge_detect_r  <= #TCQ 1'b0;\n                end else begin\n                  wl_state_r   <= #TCQ WL_INIT_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end\n              end\n           end\n\n           \n           \n           \n           \n           \n           WL_INIT_FINE_DEC: begin\n              wl_tap_count_r <= #TCQ 'd0;\n              wl_state_r   <= #TCQ WL_INIT_FINE_DEC_WAIT1;\n              if (fine_dec_cnt > 6'd0)\n                fine_dec_cnt <= #TCQ fine_dec_cnt - 1;\n              else\n                fine_dec_cnt <= #TCQ fine_dec_cnt;\n           end\n           \n           WL_INIT_FINE_DEC_WAIT1: begin\n             if (incdec_wait_cnt == 'd8)\n               wl_state_r   <= #TCQ WL_INIT_FINE_DEC_WAIT;\n           end\n           \n           WL_INIT_FINE_DEC_WAIT: begin\n              if (fine_dec_cnt > 6'd0) begin\n                wl_state_r             <= #TCQ WL_INIT_FINE_DEC;\n                inhibit_edge_detect_r  <= #TCQ 1'b1;\n              end else begin\n                wl_state_r             <= #TCQ WL_WAIT;\n                inhibit_edge_detect_r  <= #TCQ 1'b0;\n              end\n           end\n           \n           \n           WL_FINE_INC: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                wl_state_r <= #TCQ WL_FINE_INC_WAIT;\n                if (fast_cal_fine_cnt > 'd0)\n                  fast_cal_fine_cnt <= #TCQ fast_cal_fine_cnt - 1;\n                else\n                  fast_cal_fine_cnt <= #TCQ fast_cal_fine_cnt;\n              end else if (wr_level_done_r5) begin\n                wl_tap_count_r <= #TCQ 'd0;\n                wl_state_r <= #TCQ WL_FINE_INC_WAIT;\n                if (|fine_inc[dqs_count_w])\n                      fine_inc[dqs_count_w] <= #TCQ fine_inc[dqs_count_w] - 1;\n              end else begin\n                wl_state_r <= #TCQ WL_WAIT;\n                wl_tap_count_r <= #TCQ wl_tap_count_r + 1'b1;\n              end\n           end\n           \n           WL_FINE_INC_WAIT: begin\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_fine_cnt > 'd0)\n                  wl_state_r <= #TCQ WL_FINE_INC;\n                else if (fast_cal_coarse_cnt > 'd0)\n                  wl_state_r <= #TCQ WL_CORSE_INC;\n                else\n                  wl_state_r <= #TCQ WL_DQS_CNT;\n              end else if (|fine_inc[dqs_count_w])\n                wl_state_r   <= #TCQ WL_FINE_INC;\n              else if (dqs_count_r == (DQS_WIDTH-1))\n                wl_state_r   <= #TCQ WL_IDLE;\n              else begin\n                wl_state_r   <= #TCQ WL_2RANK_FINAL_TAP;\n                dqs_count_r  <= #TCQ dqs_count_r + 1;\n              end\n           end\n           \n           WL_FINE_DEC: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              wl_tap_count_r <= #TCQ 'd0;\n              wl_state_r   <= #TCQ WL_FINE_DEC_WAIT1;\n              if (fine_dec_cnt > 6'd0)\n                fine_dec_cnt <= #TCQ fine_dec_cnt - 1;\n              else\n                fine_dec_cnt <= #TCQ fine_dec_cnt;\n           end\n           \n           WL_FINE_DEC_WAIT1: begin\n             if (incdec_wait_cnt == 'd8)\n               wl_state_r   <= #TCQ WL_FINE_DEC_WAIT;\n           end\n           \n           WL_FINE_DEC_WAIT: begin\n              if (fine_dec_cnt > 6'd0)\n                wl_state_r   <= #TCQ WL_FINE_DEC;\n              \n              \n              else if (dual_rnk_dec) begin \n                if (|corse_dec[dqs_count_r])\n                  wl_state_r <= #TCQ WL_CORSE_DEC;\n                else\n                  wl_state_r <= #TCQ WL_2RANK_DQS_CNT;\n              end else if (wrlvl_byte_redo) begin\n                if ((corse_cnt[dqs_count_w] + wrlvl_redo_corse_inc) <= 'd7)\n                  wl_state_r <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r <= #TCQ WL_IDLE;\n                  wrlvl_err  <= #TCQ 1'b1;\n                end\n              end else\n                wl_state_r <= #TCQ WL_CORSE_INC;\n           end\n           \n           WL_CORSE_DEC: begin\n              wl_state_r   <= #TCQ WL_CORSE_DEC_WAIT;\n              dual_rnk_dec <= #TCQ 1'b0;\n              if (|corse_dec[dqs_count_r])\n                corse_dec[dqs_count_r] <= #TCQ corse_dec[dqs_count_r] - 1;\n              else\n                corse_dec[dqs_count_r]  <= #TCQ corse_dec[dqs_count_r];\n           end\n           \n           WL_CORSE_DEC_WAIT: begin\n              if (wl_sm_start) begin\n              \n              \n              if (|corse_dec[dqs_count_r])\n                wl_state_r <= #TCQ WL_CORSE_DEC_WAIT1;\n                else\n                wl_state_r <= #TCQ WL_2RANK_DQS_CNT;\n              end\n           end\n           \n           WL_CORSE_DEC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_DEC;\n           end\n           \n           WL_CORSE_INC: begin\n              wl_state_r <= #TCQ WL_CORSE_INC_WAIT_TMP;\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_coarse_cnt > 'd0)\n                  fast_cal_coarse_cnt <= #TCQ fast_cal_coarse_cnt - 1;\n                else\n                  fast_cal_coarse_cnt <= #TCQ fast_cal_coarse_cnt;\n              end else if (wrlvl_byte_redo) begin\n                corse_cnt[dqs_count_w] <= #TCQ corse_cnt[dqs_count_w] + 1;\n                if (|wrlvl_redo_corse_inc)                             \n                  wrlvl_redo_corse_inc <= #TCQ wrlvl_redo_corse_inc - 1;\n              end else if (~wr_level_done_r5)\n                corse_cnt[dqs_count_r] <= #TCQ corse_cnt[dqs_count_r] + 1;\n              else if (|corse_inc[dqs_count_w])                             \n                corse_inc[dqs_count_w] <= #TCQ corse_inc[dqs_count_w] - 1;\n           end\n\n           WL_CORSE_INC_WAIT_TMP: begin\n             if (incdec_wait_cnt == 'd8)\n             wl_state_r <= #TCQ WL_CORSE_INC_WAIT;\n           end\n           \n           WL_CORSE_INC_WAIT: begin\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_coarse_cnt > 'd0)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else\n                  wl_state_r <= #TCQ WL_DQS_CNT;\n              end else if (wrlvl_byte_redo) begin\n                if (|wrlvl_redo_corse_inc)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r            <= #TCQ WL_INIT_FINE_INC;\n                  inhibit_edge_detect_r <= #TCQ 1'b1;\n                end\n              end else if (~wr_level_done_r5 && wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT1;\n              else if (wr_level_done_r5) begin\n                if (|corse_inc[dqs_count_r])\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else if (|fine_inc[dqs_count_w]) \n                  wl_state_r   <= #TCQ WL_FINE_INC;\n                else if (dqs_count_r == (DQS_WIDTH-1))\n                  wl_state_r   <= #TCQ WL_IDLE;\n                else begin\n                  wl_state_r   <= #TCQ WL_2RANK_FINAL_TAP;\n                  dqs_count_r  <= #TCQ dqs_count_r + 1;\n                end\n              end\n           end\n           \n           WL_CORSE_INC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT2;\n           end\n\n           WL_CORSE_INC_WAIT2: begin\n             if (wl_sm_start)\n                wl_state_r <= #TCQ WL_WAIT;\n           end\n           \n           WL_WAIT: begin\n              if (wl_sm_start)\n              wl_state_r <= #TCQ WL_EDGE_CHECK;\n           end\n           \n           WL_EDGE_CHECK: begin \n              if (wl_edge_detect_valid_r == 1'b0) begin\n                wl_state_r <= #TCQ WL_WAIT;\n                wl_edge_detect_valid_r <= #TCQ 1'b1;\n              end\n              \n              else if(rd_data_edge_detect_r[dqs_count_r] &&\n                      wl_edge_detect_valid_r)\n                begin\n                  wl_tap_count_r <= #TCQ wl_tap_count_r;\n                  if ((SIM_CAL_OPTION == \"FAST_CAL\") || (RANKS < 2) ||\n                      ~oclkdelay_calib_done)\n                    wl_state_r <= #TCQ WL_DQS_CNT;\n                  else\n                    wl_state_r <= #TCQ WL_2RANK_TAP_DEC;\n                end\n              \n              \n              else if((~wrlvl_tap_done_r) && (wl_tap_count_r > 6'd55)) begin\n                if (corse_cnt[dqs_count_r] < COARSE_TAPS) begin\n                  wl_state_r   <= #TCQ WL_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end  else begin\n                  wrlvl_err <= #TCQ 1'b1;\n                  wl_state_r   <= #TCQ WL_IDLE;\n                end\n\t      end else begin\n\t          if (wl_tap_count_r < 6'd56)  \n                    wl_state_r <= #TCQ WL_FINE_INC;\n\t          else if (corse_cnt[dqs_count_r] < COARSE_TAPS) begin\n                    wl_state_r   <= #TCQ WL_FINE_DEC;\n                    fine_dec_cnt <= #TCQ wl_tap_count_r;\n                  end else begin\n                   wrlvl_err <= #TCQ 1'b1;\n                   wl_state_r   <= #TCQ WL_IDLE;\n                  end\n\t      end\n           end\n\n           WL_2RANK_TAP_DEC: begin\n              wl_state_r    <= #TCQ WL_FINE_DEC;\n              fine_dec_cnt  <= #TCQ wl_tap_count_r;\n              for (m = 0; m < DQS_WIDTH; m = m + 1)\n                corse_dec[m] <= #TCQ corse_cnt[m];\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              dual_rnk_dec <= #TCQ 1'b1;\n           end\n           \n           WL_DQS_CNT: begin\n              if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                  (dqs_count_r == (DQS_WIDTH-1)) ||\n                  wrlvl_byte_redo) begin\n                dqs_count_r <= #TCQ dqs_count_r;\n                dq_cnt_inc  <= #TCQ 1'b0;\n              end else begin\n                dqs_count_r <= #TCQ dqs_count_r + 1'b1;\n                dq_cnt_inc  <= #TCQ 1'b1;\n              end\n              wl_state_r <= #TCQ WL_DQS_CHECK;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n           end\n           \n           WL_2RANK_DQS_CNT: begin\n              if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                 (dqs_count_r == (DQS_WIDTH-1))) begin\n                dqs_count_r <= #TCQ dqs_count_r;\n                dq_cnt_inc  <= #TCQ 1'b0;\n              end else begin\n                dqs_count_r <= #TCQ dqs_count_r + 1'b1;\n                dq_cnt_inc  <= #TCQ 1'b1;\n              end\n              wl_state_r <= #TCQ WL_DQS_CHECK;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              dual_rnk_dec <= #TCQ 1'b0;\n           end   \n           \n           WL_DQS_CHECK: begin \n              wl_tap_count_r <= #TCQ 'd0;\n              if (dq_cnt_inc == 1'b0)begin\n                wrlvl_rank_done_r <= #TCQ 1'd1;\n                for (t = 0; t < DQS_WIDTH; t = t + 1)\n                  corse_cnt[t] <= #TCQ 3'b0;\n                if ((SIM_CAL_OPTION == \"FAST_CAL\") || (RANKS < 2) || ~oclkdelay_calib_done) begin\n                  wl_state_r  <= #TCQ WL_IDLE;\n                  if (wrlvl_byte_redo)\n                    dqs_count_r <= #TCQ dqs_count_r;\n                  else \n                  dqs_count_r <= #TCQ 'd0;\n                end else if (rank_cnt_r == RANKS-1) begin\n                  dqs_count_r <= #TCQ dqs_count_r;\n                  if (RANKS > 1)\n                    wl_state_r  <= #TCQ WL_2RANK_FINAL_TAP;\n                  else\n                    wl_state_r  <= #TCQ WL_IDLE;\n                end else begin\n                  wl_state_r  <= #TCQ WL_INIT;\n                  dqs_count_r <= #TCQ 'd0;\n                end\n                if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                    (rank_cnt_r == RANKS-1)) begin\n                  wr_level_done_r <= #TCQ 1'd1;\n                  rank_cnt_r      <= #TCQ 2'b00;\n                end else begin\n                  wr_level_done_r <= #TCQ 1'd0;\n                  rank_cnt_r      <= #TCQ rank_cnt_r + 1'b1;\n                end\n              end else\n                wl_state_r  <= #TCQ WL_INIT;\n           end\n           \n           WL_2RANK_FINAL_TAP: begin\n              if (wr_level_done_r4 && ~wr_level_done_r5) begin\n                for(u = 0; u < DQS_WIDTH; u = u + 1) begin\n                  corse_inc[u] <= #TCQ final_coarse_tap[u];\n                  fine_inc[u]  <= #TCQ final_val[u];\n                end\n                dqs_count_r    <= #TCQ 'd0;\n              end else if (wr_level_done_r5) begin\n                if (|corse_inc[dqs_count_r])\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else if (|fine_inc[dqs_count_w])\n                  wl_state_r   <= #TCQ WL_FINE_INC;\n              end  \n           end\n        endcase\n     end\n   end \n\nendmodule\n              \n                 \n                \n   \n     \n\n   \n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: mig_7series_v4_1_ddr_phy_wrlvl. Module specification: This module implements write leveling functionality for a DDR memory interface, adjusting DQS signal timing relative to the clock for optimal data capture during writes. It uses a state machine to incrementally adjust fine and coarse delay taps, detecting edges in received data to determine optimal timing. The module supports multiple ranks and includes features for initial calibration, fine-tuning, and error handling. Key inputs include clk, rst, phy_ctl_ready, wr_level_start, and rd_data_rise0, while outputs include wrlvl_byte_done, wr_level_done, and various debug signals. Internal signals such as wl_state_r, wl_tap_count_r, and corse_cnt manage the state machine and delay adjustments. The module"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: mig_7series_v4_1_ddr_phy_wrlvl\n\nExplanation: This module implements the write leveling functionality for a DDR memory interface. It adjusts the timing of DQS (data strobe) signals relative to the clock signal to ensure proper data capture during writes. The module uses a state machine to incrementally adjust both fine and coarse delay taps, detecting edges in the received data to determine optimal timing. It supports multiple ranks and includes features for initial calibration, fine-tuning, and error handling. The module also implements fast calibration options and provides debug outputs for monitoring the write leveling process."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, rst, phy_ctl_ready, wr_level_start, wl_sm_start, wrlvl_final, wrlvl_byte_redo, wrcal_cnt, early1_data, early2_data, oclkdelay_calib_cnt, oclkdelay_calib_done, rd_data_rise0, po_counter_read_val.\n\nExplanation:\n- clk: System clock input\n- rst: Reset signal\n- phy_ctl_ready: PHY control ready signal\n- wr_level_start: Write leveling start signal\n- wl_sm_start: Write leveling state machine start signal\n- wrlvl_final: Final write leveling signal\n- wrlvl_byte_redo: Signal to redo write leveling for a specific byte\n- wrcal_cnt: Write calibration count\n- early1_data, early2_data: Early data signals for timing adjustment\n- oclkdelay_calib_cnt: Output clock delay calibration count\n- oclkdelay_calib_done: Output clock delay calibration done signal\n- rd_data_rise0: Read data on rising edge\n- po_counter_read_val: Phase offset counter read value\n\nOutput ports:\nwrlvl_byte_done, dqs_po_dec_done, wr_level_done, wrlvl_rank_done, done_dqs_tap_inc, po_stg2_wl_cnt, dqs_po_stg2_f_incdec, dqs_po_en_stg2_f, dqs_wl_po_stg2_c_incdec, dqs_wl_po_en_stg2_c, wrlvl_err, wl_po_coarse_cnt, wl_po_fine_cnt, dbg_wl_tap_cnt, dbg_wl_edge_detect_valid, dbg_rd_data_edge_detect, dbg_dqs_count, dbg_wl_state, dbg_wrlvl_fine_tap_cnt, dbg_wrlvl_coarse_tap_cnt, dbg_phy_wrlvl.\n\nExplanation:\n- wrlvl_byte_done: Write leveling byte done signal\n- dqs_po_dec_done: DQS phase offset decrement done signal\n- wr_level_done: Write leveling done signal\n- wrlvl_rank_done: Write leveling rank done signal\n- done_dqs_tap_inc: DQS tap increment done signal\n- po_stg2_wl_cnt: Phase offset stage 2 write leveling count\n- dqs_po_stg2_f_incdec: DQS phase offset stage 2 fine increment/decrement signal\n- dqs_po_en_stg2_f: DQS phase offset stage 2 fine enable signal\n- dqs_wl_po_stg2_c_incdec: DQS write leveling phase offset stage 2 coarse increment/decrement signal\n- dqs_wl_po_en_stg2_c: DQS write leveling phase offset stage 2 coarse enable signal\n- wrlvl_err: Write leveling error signal\n- wl_po_coarse_cnt: Write leveling phase offset coarse count\n- wl_po_fine_cnt: Write leveling phase offset fine count\n- Various debug outputs (dbg_*): Signals for monitoring and debugging the write leveling process"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nwl_state_r, wl_state_r1, wl_tap_count_r, fine_dec_cnt, corse_cnt, fine_inc, corse_dec, corse_inc, dqs_count_r, rank_cnt_r, rd_data_rise_wl_r, rd_data_previous_r, rd_data_edge_detect_r, wr_level_done_r, wrlvl_rank_done_r, wr_level_start_r, inhibit_edge_detect_r, wl_edge_detect_valid_r, stable_cnt, flag_ck_negedge, flag_init, wl_dqs_tap_count_r, smallest, largest, final_val, po_dec_cnt, done_dqs_dec, po_rdval_cnt, po_cnt_dec, po_dec_done, dual_rnk_dec, fast_cal_fine_cnt, fast_cal_coarse_cnt, wrlvl_byte_redo_r, wrlvl_redo_corse_inc, wrlvl_final_r, final_corse_dec, wrlvl_tap_done_r, wait_cnt, incdec_wait_cnt.\n\nExplanation:\n- wl_state_r, wl_state_r1: Current and previous states of the write leveling state machine\n- wl_tap_count_r: Counter for fine delay taps\n- fine_dec_cnt: Counter for fine delay decrements\n- corse_cnt: Array to store coarse delay counts for each DQS\n- fine_inc, corse_dec, corse_inc: Arrays to store fine/coarse increment/decrement values for each DQS\n- dqs_count_r: Counter for current DQS being processed\n- rank_cnt_r: Counter for current rank being processed\n- rd_data_rise_wl_r: Registered read data on rising edge for write leveling\n- rd_data_previous_r: Previous read data for edge detection\n- rd_data_edge_detect_r: Edge detection signal for read data\n- wr_level_done_r: Write leveling done signal (registered)\n- wrlvl_rank_done_r: Write leveling rank done signal (registered)\n- wr_level_start_r: Write leveling start signal (registered)\n- inhibit_edge_detect_r: Signal to inhibit edge detection\n- wl_edge_detect_valid_r: Valid signal for write leveling edge detection\n- stable_cnt: Counter for stable data detection\n- flag_ck_negedge: Flag for clock negative edge detection\n- flag_init: Flag for initialization state\n- wl_dqs_tap_count_r: Array to store tap counts for each DQS and rank\n- smallest, largest: Arrays to store smallest and largest tap values for each DQS\n- final_val: Array to store final tap values for each DQS\n- po_dec_cnt: Array to store phase offset decrement counts for each DQS\n- done_dqs_dec: Signal indicating DQS decrement is done\n- po_rdval_cnt: Counter for phase offset read value\n- po_cnt_dec: Signal to decrement phase offset counter\n- po_dec_done: Signal indicating phase offset decrement is done\n- dual_rnk_dec: Flag for dual rank decrement\n- fast_cal_fine_cnt, fast_cal_coarse_cnt: Counters for fast calibration mode\n- wrlvl_byte_redo_r: Registered signal for byte redo\n- wrlvl_redo_corse_inc: Counter for coarse increments during byte redo\n- wrlvl_final_r: Registered final write leveling signal\n- final_corse_dec: Flag for final coarse decrement\n- wrlvl_tap_done_r: Signal indicating write leveling tap adjustment is done\n- wait_cnt: Counter for wait states\n- incdec_wait_cnt: Counter for increment/decrement wait states"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps/1ps\n\nmodule mig_7series_v4_1_ddr_phy_wrlvl #\n  (\n   parameter TCQ = 100,\n   parameter DQS_CNT_WIDTH     = 3,\n   parameter DQ_WIDTH          = 64,\n   parameter DQS_WIDTH         = 2,\n   parameter DRAM_WIDTH        = 8,\n   parameter RANKS             = 1,\n   parameter nCK_PER_CLK       = 4,\n   parameter CLK_PERIOD        = 4,\n   parameter SIM_CAL_OPTION    = \"NONE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   input                        phy_ctl_ready,\n   input                        wr_level_start,\n   input                        wl_sm_start,\n   input                        wrlvl_final,\n   input                        wrlvl_byte_redo,\n   input [DQS_CNT_WIDTH:0]      wrcal_cnt,\n   input                        early1_data,\n   input                        early2_data,\n   input [DQS_CNT_WIDTH:0]      oclkdelay_calib_cnt,\n   input                        oclkdelay_calib_done,\n   input [(DQ_WIDTH)-1:0]       rd_data_rise0,\n   output reg                   wrlvl_byte_done,\n    output reg dqs_po_dec_done ,\n   output                       phy_ctl_rdy_dly,\n    output reg wr_level_done ,\n   \n   output                       wrlvl_rank_done,\n   output                       done_dqs_tap_inc,\n   output [DQS_CNT_WIDTH:0]     po_stg2_wl_cnt,\n   \n   \n   output reg                   dqs_po_stg2_f_incdec,\n   \n   output reg                   dqs_po_en_stg2_f,\n   \n   \n   \n   \n   output reg                   dqs_wl_po_stg2_c_incdec,\n   \n   output reg                   dqs_wl_po_en_stg2_c,\n   \n   input [8:0]                  po_counter_read_val,\n\n\n   \n   output reg                   wrlvl_err,\n   output reg [3*DQS_WIDTH-1:0] wl_po_coarse_cnt,\n   output reg [6*DQS_WIDTH-1:0] wl_po_fine_cnt,\n   \n   output [5:0]                 dbg_wl_tap_cnt,\n   output                       dbg_wl_edge_detect_valid,\n   output [(DQS_WIDTH)-1:0]     dbg_rd_data_edge_detect,\n   output [DQS_CNT_WIDTH:0]     dbg_dqs_count,\n   output [4:0]                 dbg_wl_state,\n   output [6*DQS_WIDTH-1:0]     dbg_wrlvl_fine_tap_cnt,\n   output [3*DQS_WIDTH-1:0]     dbg_wrlvl_coarse_tap_cnt,\n   output [255:0]               dbg_phy_wrlvl   \n   );\n\n\n   localparam WL_IDLE               = 5'h0;\n   localparam WL_INIT               = 5'h1;\n   localparam WL_INIT_FINE_INC      = 5'h2;\n   localparam WL_INIT_FINE_INC_WAIT1= 5'h3;\n   localparam WL_INIT_FINE_INC_WAIT = 5'h4;\n   localparam WL_INIT_FINE_DEC      = 5'h5;\n   localparam WL_INIT_FINE_DEC_WAIT = 5'h6;\n   localparam WL_FINE_INC           = 5'h7;\n   localparam WL_WAIT               = 5'h8;\n   localparam WL_EDGE_CHECK         = 5'h9;\n   localparam WL_DQS_CHECK          = 5'hA;\n   localparam WL_DQS_CNT            = 5'hB;\n   localparam WL_2RANK_TAP_DEC      = 5'hC;\n   localparam WL_2RANK_DQS_CNT      = 5'hD;\n   localparam WL_FINE_DEC           = 5'hE;\n   localparam WL_FINE_DEC_WAIT      = 5'hF;\n   localparam WL_CORSE_INC          = 5'h10;\n   localparam WL_CORSE_INC_WAIT     = 5'h11;\n   localparam WL_CORSE_INC_WAIT1    = 5'h12;\n   localparam WL_CORSE_INC_WAIT2    = 5'h13;\n   localparam WL_CORSE_DEC          = 5'h14;\n   localparam WL_CORSE_DEC_WAIT     = 5'h15;\n   localparam WL_CORSE_DEC_WAIT1    = 5'h16;\n   localparam WL_FINE_INC_WAIT      = 5'h17;\n   localparam WL_2RANK_FINAL_TAP    = 5'h18;\n   localparam WL_INIT_FINE_DEC_WAIT1= 5'h19;\n   localparam WL_FINE_DEC_WAIT1     = 5'h1A;\n   localparam WL_CORSE_INC_WAIT_TMP = 5'h1B;\n\n   localparam  COARSE_TAPS = 7;\n   \n   localparam FAST_CAL_FINE   = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 45 : 48;\n   localparam FAST_CAL_COARSE = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 1 : 2;\n   localparam REDO_COARSE = (CLK_PERIOD/nCK_PER_CLK <= 2500) ? 2 : 5;\n\n\n   integer     i, j, k, l, p, q, r, s, t, m, n, u, v, w, x,y;\n\n   reg                   phy_ctl_ready_r1;\n   reg                   phy_ctl_ready_r2;\n   reg                   phy_ctl_ready_r3;\n   reg                   phy_ctl_ready_r4;\n   reg                   phy_ctl_ready_r5;\n   reg                   phy_ctl_ready_r6;\n   (* max_fanout = 50 *) reg [DQS_CNT_WIDTH:0] dqs_count_r;\n   reg [1:0]             rank_cnt_r;\n   reg [DQS_WIDTH-1:0]   rd_data_rise_wl_r;\n   reg [DQS_WIDTH-1:0]   rd_data_previous_r;\n   reg [DQS_WIDTH-1:0]   rd_data_edge_detect_r;\n   reg                   wr_level_done_r;\n   reg                   wrlvl_rank_done_r;\n   reg                   wr_level_start_r;\n   reg [4:0]             wl_state_r, wl_state_r1;\n   reg                   inhibit_edge_detect_r;\n   reg                   wl_edge_detect_valid_r;\n   reg [5:0]             wl_tap_count_r;\n   reg [5:0]             fine_dec_cnt;\n   reg [5:0]             fine_inc[0:DQS_WIDTH-1];  \n   reg [2:0]             corse_dec[0:DQS_WIDTH-1];\n   reg [2:0]             corse_inc[0:DQS_WIDTH-1];\n   reg                   dq_cnt_inc;\n   reg [3:0]             stable_cnt;\n   reg                   flag_ck_negedge;\n   \n   reg                   flag_init;\n   reg [2:0]             corse_cnt[0:DQS_WIDTH-1];\n   reg [3*DQS_WIDTH-1:0] corse_cnt_dbg;\n   reg [2:0]             wl_corse_cnt[0:RANKS-1][0:DQS_WIDTH-1];\n   \n   reg [2:0]             final_coarse_tap[0:DQS_WIDTH-1];\n   reg [5:0]             add_smallest[0:DQS_WIDTH-1];\n   reg [5:0]             add_largest[0:DQS_WIDTH-1];\n \n   \n   reg                   wr_level_done_r1;\n   reg                   wr_level_done_r2;\n   reg                   wr_level_done_r3;\n   reg                   wr_level_done_r4;\n   reg                   wr_level_done_r5;\n   reg [5:0]             wl_dqs_tap_count_r[0:RANKS-1][0:DQS_WIDTH-1];\n   reg [5:0]             smallest[0:DQS_WIDTH-1];\n   reg [5:0]             largest[0:DQS_WIDTH-1];\n   reg [5:0]             final_val[0:DQS_WIDTH-1];\n   reg [5:0]             po_dec_cnt[0:DQS_WIDTH-1];\n   reg                   done_dqs_dec;\n   reg [8:0]             po_rdval_cnt;\n   reg                   po_cnt_dec;\n   reg                   po_dec_done;\n   reg                   dual_rnk_dec;\n   wire [DQS_CNT_WIDTH+2:0] dqs_count_w;\n   reg [5:0]             fast_cal_fine_cnt;\n   reg [2:0]             fast_cal_coarse_cnt;\n   reg                   wrlvl_byte_redo_r;\n   reg [2:0]             wrlvl_redo_corse_inc;\n   reg                   wrlvl_final_r;\n   reg                   final_corse_dec;\n   wire [DQS_CNT_WIDTH+2:0] oclk_count_w;\n   reg                   wrlvl_tap_done_r ;\n   reg [3:0]             wait_cnt;\n   reg [3:0]             incdec_wait_cnt;\n \n\n\n  \n   assign dbg_wl_edge_detect_valid = wl_edge_detect_valid_r;\n   assign dbg_rd_data_edge_detect  = rd_data_edge_detect_r;\n   assign dbg_wl_tap_cnt           = wl_tap_count_r;\n   assign dbg_dqs_count            = dqs_count_r;\n   assign dbg_wl_state             = wl_state_r;\n   assign dbg_wrlvl_fine_tap_cnt   = wl_po_fine_cnt;\n   assign dbg_wrlvl_coarse_tap_cnt = wl_po_coarse_cnt;\n\n   always @(*) begin\n     for (v = 0; v < DQS_WIDTH; v = v + 1)\n       corse_cnt_dbg[3*v+:3] = corse_cnt[v];\n   end\n  \n   assign dbg_phy_wrlvl[0+:27]  = corse_cnt_dbg;\n   assign dbg_phy_wrlvl[27+:5]  = wl_state_r;\n   assign dbg_phy_wrlvl[32+:4]  = dqs_count_r;\n   assign dbg_phy_wrlvl[36+:9]  = rd_data_rise_wl_r;\n   assign dbg_phy_wrlvl[45+:9]  = rd_data_previous_r;\n   assign dbg_phy_wrlvl[54+:4]  = stable_cnt;\n   assign dbg_phy_wrlvl[58]     = 'd0;\n   assign dbg_phy_wrlvl[59]     = flag_ck_negedge;\n\n   assign dbg_phy_wrlvl [60]    = wl_edge_detect_valid_r;\n   assign dbg_phy_wrlvl [61+:6] = wl_tap_count_r;\n   assign dbg_phy_wrlvl [67+:9] = rd_data_edge_detect_r;\n   assign dbg_phy_wrlvl [76+:54]  = wl_po_fine_cnt;\n   assign dbg_phy_wrlvl [130+:27] = wl_po_coarse_cnt;\n  \n\n   \n   \n   \n   \n   assign po_stg2_wl_cnt = dqs_count_r;\n\n   assign wrlvl_rank_done = wrlvl_rank_done_r;\n   \n   assign done_dqs_tap_inc = done_dqs_dec;\n   \n   assign phy_ctl_rdy_dly = phy_ctl_ready_r6;\n   \n   always @(posedge clk) begin\n     phy_ctl_ready_r1  <= #TCQ phy_ctl_ready;\n     phy_ctl_ready_r2  <= #TCQ phy_ctl_ready_r1;\n     phy_ctl_ready_r3  <= #TCQ phy_ctl_ready_r2;\n     phy_ctl_ready_r4  <= #TCQ phy_ctl_ready_r3;\n     phy_ctl_ready_r5  <= #TCQ phy_ctl_ready_r4;\n     phy_ctl_ready_r6  <= #TCQ phy_ctl_ready_r5;\n     wrlvl_byte_redo_r <= #TCQ wrlvl_byte_redo;\n     wrlvl_final_r     <= #TCQ wrlvl_final;\n     if ((wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n       wr_level_done  <= #TCQ 1'b0;\n     else\n       wr_level_done  <= #TCQ done_dqs_dec;\n   end\n\n\n\n   always @(posedge clk) begin\n     if(rst) begin\n       wrlvl_tap_done_r <= #TCQ 1'b0 ;\n     end else begin\n       if(wrlvl_tap_done_r == 1'b0) begin\n         if(oclkdelay_calib_done) begin\n\t   wrlvl_tap_done_r <= #TCQ 1'b1 ;\n\t end\n       end\n     end\n   end\n   \n   always @(posedge clk) begin\n     if (rst || po_cnt_dec)\n       wait_cnt <= #TCQ 'd8;\n     else if (phy_ctl_ready_r6 && (wait_cnt > 'd0))\n       wait_cnt <= #TCQ wait_cnt - 1;\n   end\n   \n   always @(posedge clk) begin\n     if (rst) begin\n       po_rdval_cnt    <= #TCQ 'd0;\n     end else if (phy_ctl_ready_r5 && ~phy_ctl_ready_r6) begin\n       po_rdval_cnt    <= #TCQ po_counter_read_val;\n     end else if (po_rdval_cnt > 'd0) begin\n       if (po_cnt_dec)\n         po_rdval_cnt  <= #TCQ po_rdval_cnt - 1;\n       else            \n         po_rdval_cnt  <= #TCQ po_rdval_cnt;\n     end else if (po_rdval_cnt == 'd0) begin\n       po_rdval_cnt    <= #TCQ po_rdval_cnt;\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (po_rdval_cnt == 'd0))\n       po_cnt_dec      <= #TCQ 1'b0;\n     else if (phy_ctl_ready_r6 && (po_rdval_cnt > 'd0) && (wait_cnt == 'd1))\n       po_cnt_dec      <= #TCQ 1'b1;\n     else\n       po_cnt_dec      <= #TCQ 1'b0;\n     end\n   \n   always @(posedge clk) begin\n     if (rst)\n       po_dec_done <= #TCQ 1'b0;\n     else if (((po_cnt_dec == 'd1) && (po_rdval_cnt == 'd1)) || \n              (phy_ctl_ready_r6 && (po_rdval_cnt == 'd0))) begin\n       po_dec_done <= #TCQ 1'b1;\n     end\n   end\n\n   \n   always @(posedge clk) begin\n     dqs_po_dec_done  <= #TCQ po_dec_done;\n     wr_level_done_r1 <= #TCQ wr_level_done_r;\n     wr_level_done_r2 <= #TCQ wr_level_done_r1;\n     wr_level_done_r3 <= #TCQ wr_level_done_r2;\n     wr_level_done_r4 <= #TCQ wr_level_done_r3;\n     wr_level_done_r5 <= #TCQ wr_level_done_r4;\n     for (l = 0; l < DQS_WIDTH; l = l + 1) begin \n       wl_po_coarse_cnt[3*l+:3] <= #TCQ final_coarse_tap[l];\n       if ((RANKS == 1) || ~oclkdelay_calib_done)\n         wl_po_fine_cnt[6*l+:6] <= #TCQ smallest[l];\n       else \n         wl_po_fine_cnt[6*l+:6] <= #TCQ final_val[l];\n     end\n   end\n   \n   generate\n   if (RANKS == 2) begin: dual_rank\n     always @(posedge clk) begin\n       if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n         done_dqs_dec <= #TCQ 1'b0;\n       else if ((SIM_CAL_OPTION == \"FAST_CAL\") || ~oclkdelay_calib_done)\n         done_dqs_dec <= #TCQ wr_level_done_r;\n       else if (wr_level_done_r5 && (wl_state_r == WL_IDLE))\n         done_dqs_dec <= #TCQ 1'b1;\n     end\n   end else begin: single_rank\n     always @(posedge clk) begin\n       if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r) ||\n         (wrlvl_final && ~wrlvl_final_r))\n         done_dqs_dec <= #TCQ 1'b0;\n       else if (~oclkdelay_calib_done)\n         done_dqs_dec <= #TCQ wr_level_done_r;\n       else if (wr_level_done_r3 && ~wr_level_done_r4)\n         done_dqs_dec <= #TCQ 1'b1;\n     end\n   end\n   endgenerate\n   \n   always @(posedge clk)\n     if (rst || (wrlvl_byte_redo && ~wrlvl_byte_redo_r))\n       wrlvl_byte_done <= #TCQ 1'b0;\n     else if (wrlvl_byte_redo && wr_level_done_r3 && ~wr_level_done_r4)\n       wrlvl_byte_done <= #TCQ 1'b1;\n  \n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for (k = 0; k < RANKS; k = k + 1) begin: rst_wl_dqs_tap_count_loop\n         for (n = 0; n < DQS_WIDTH; n = n + 1) begin\n           wl_corse_cnt[k][n]       <= #TCQ 'b0;\n           wl_dqs_tap_count_r[k][n] <= #TCQ 'b0;\n         end\n       end\n     end else if ((wl_state_r == WL_DQS_CNT) | (wl_state_r == WL_WAIT) | \n                  (wl_state_r == WL_FINE_DEC_WAIT1) |\n                  (wl_state_r == WL_2RANK_TAP_DEC)) begin\n         wl_dqs_tap_count_r[rank_cnt_r][dqs_count_r] <= #TCQ wl_tap_count_r;\n         wl_corse_cnt[rank_cnt_r][dqs_count_r]       <= #TCQ corse_cnt[dqs_count_r];\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (wl_state_r == WL_DQS_CHECK)) begin\n       for (p = 0; p < RANKS; p = p +1) begin: dqs_tap_rank_cnt   \n         for(q = 0; q < DQS_WIDTH; q = q +1) begin: dqs_tap_dqs_cnt\n           wl_dqs_tap_count_r[p][q] <= #TCQ wl_tap_count_r;\n           wl_corse_cnt[p][q]       <= #TCQ corse_cnt[0];\n         end\n       end\n     end\n   end\n   \n   \n   \n   \n   \n   \n   \n\n   generate\n   genvar cnt;\n   if (RANKS == 2) begin \n     for(cnt = 0; cnt < DQS_WIDTH; cnt = cnt +1) begin: coarse_dqs_cnt\n       always @(posedge clk) begin\n         if (rst) begin\n           \n           add_smallest[cnt]         <= #TCQ 'd0;\n           add_largest[cnt]          <= #TCQ 'd0;\n           final_coarse_tap[cnt]     <= #TCQ 'd0;\n         end else if (wr_level_done_r1 & ~wr_level_done_r2) begin\n           if (~oclkdelay_calib_done) begin\n\t    for(y = 0 ; y < DQS_WIDTH; y = y+1) begin\n              final_coarse_tap[y] <= #TCQ wl_corse_cnt[0][y]; \n              add_smallest[y]     <= #TCQ 'd0;\n              add_largest[y]      <= #TCQ 'd0;\n\t     end\n           end else \n\t   if (wl_corse_cnt[0][cnt] == wl_corse_cnt[1][cnt]) begin\n           \n           \n             \n             final_coarse_tap[cnt]     <= #TCQ wl_corse_cnt[1][cnt];\n             add_smallest[cnt]         <= #TCQ 'd0;\n             add_largest[cnt]          <= #TCQ 'd0;\n           end else if (wl_corse_cnt[0][cnt] < wl_corse_cnt[1][cnt]) begin\n           \n           \n           \n             \n             final_coarse_tap[cnt]     <= #TCQ wl_corse_cnt[1][cnt] - 1;\n             if (|wl_corse_cnt[0][cnt])\n               \n               \n               \n               add_largest[cnt] <= #TCQ 'd38;\n             else\n               \n               \n               \n               add_largest[cnt] <= #TCQ 'd34;\n           end else if (wl_corse_cnt[0][cnt] > wl_corse_cnt[1][cnt]) begin\n           \n           \n           \n             \n             final_coarse_tap[cnt]   <= #TCQ wl_corse_cnt[1][cnt];\n             if (|wl_corse_cnt[1][cnt])\n               \n               \n               \n               add_smallest[cnt] <= #TCQ 'd38;\n             else\n               \n               \n               \n               add_smallest[cnt] <= #TCQ 'd34;\n           end\n         end\n       end\n     end\n   end else begin\n \n     always @(posedge clk) begin\n       \n       for(w = 0; w < DQS_WIDTH; w = w + 1) begin\n         final_coarse_tap[w] <= #TCQ wl_corse_cnt[0][w];\n         add_smallest[w]     <= #TCQ 'd0;\n         add_largest[w]      <= #TCQ 'd0;\n       end\n     end\n   end\n   endgenerate\n\n   \n   \n   \n   \n   \n   always @(posedge clk) begin\n     if (rst) begin\n       for(x = 0; x < DQS_WIDTH; x = x +1) begin\n         smallest[x] <= #TCQ 'b0;\n         largest[x]  <= #TCQ 'b0;\n       end\n     end else if ((wl_state_r == WL_DQS_CNT) & wrlvl_byte_redo) begin\n       smallest[dqs_count_r] <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n       largest[dqs_count_r]  <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n     end else if ((wl_state_r == WL_DQS_CNT) | \n                  (wl_state_r == WL_2RANK_TAP_DEC)) begin\n       smallest[dqs_count_r] <= #TCQ wl_dqs_tap_count_r[0][dqs_count_r];\n       largest[dqs_count_r]  <= #TCQ wl_dqs_tap_count_r[RANKS-1][dqs_count_r];\n     end else if (((SIM_CAL_OPTION == \"FAST_CAL\") | \n                   (~oclkdelay_calib_done & ~wrlvl_byte_redo)) & \n                  wr_level_done_r1 & ~wr_level_done_r2) begin\n       for(i = 0; i < DQS_WIDTH; i = i +1) begin: smallest_dqs\n         smallest[i] <= #TCQ wl_dqs_tap_count_r[0][i];\n         largest[i]  <= #TCQ wl_dqs_tap_count_r[0][i];\n       end\n     end\n   end\n\n   \n\n   genvar wr_i;\n   generate\n     for (wr_i = 0; wr_i < DQS_WIDTH; wr_i = wr_i +1) begin: gen_final_tap\n      always @(posedge clk) begin\n        if (rst)\n          final_val[wr_i] <= #TCQ 'b0;\n        else if (wr_level_done_r2 && ~wr_level_done_r3) begin\n          if (~oclkdelay_calib_done)\n            final_val[wr_i] <= #TCQ (smallest[wr_i] + add_smallest[wr_i]); \n          else if ((smallest[wr_i] + add_smallest[wr_i]) < \n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ ((smallest[wr_i] + add_smallest[wr_i]) +\n                                     (((largest[wr_i] + add_largest[wr_i]) -\n                                     (smallest[wr_i] + add_smallest[wr_i]))/2));\n          else if ((smallest[wr_i] + add_smallest[wr_i]) >\n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ ((largest[wr_i] + add_largest[wr_i]) +\n                                     (((smallest[wr_i] + add_smallest[wr_i]) -\n                                     (largest[wr_i] + add_largest[wr_i]))/2));\n          else if ((smallest[wr_i] + add_smallest[wr_i]) ==\n                   (largest[wr_i] + add_largest[wr_i]))\n            final_val[wr_i] <= #TCQ (largest[wr_i] + add_largest[wr_i]);\n        end\n      end\n     end\n   endgenerate\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   \n   \n   always @(posedge clk) begin\n     if (rst) begin\n     \n       dqs_po_stg2_f_incdec   <= #TCQ 1'b0;\n       dqs_po_en_stg2_f       <= #TCQ 1'b0;\n     \n     \n     \n     end else if (po_cnt_dec || (wl_state_r == WL_INIT_FINE_DEC) ||\n                  (wl_state_r == WL_FINE_DEC)) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     \n     end else if ((wl_state_r == WL_INIT_FINE_INC) ||\n                  (wl_state_r == WL_FINE_INC)) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b1;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     end else begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b0; \n     end\n   end\n   \n\n   \n   always @(posedge clk) begin\n     if (rst) begin\n     \n     \n     \n       dqs_wl_po_stg2_c_incdec   <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c       <= #TCQ 1'b0;\n     end else if (wl_state_r == WL_CORSE_INC) begin\n     \n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b1;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b1;\n     end else begin\n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b0; \n     end\n   end\n     \n\n   \n   \n   \n\ngenvar rd_i;\ngenerate\n  for(rd_i = 0; rd_i < DQS_WIDTH; rd_i = rd_i +1)begin: gen_rd\n   always @(posedge clk)\n     rd_data_rise_wl_r[rd_i] <=\n     #TCQ |rd_data_rise0[(rd_i*DRAM_WIDTH)+DRAM_WIDTH-1:rd_i*DRAM_WIDTH];\n  end\nendgenerate\n\n\n   \n   always @(posedge clk)begin\n     if ((wl_state_r == WL_INIT) || \n         \n\t\t ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) & (wl_state_r == WL_INIT_FINE_INC)) ||\n         (wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT1) || (wl_state_r == WL_FINE_DEC_WAIT) ||\n         (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) || (wl_state_r == WL_CORSE_INC_WAIT_TMP) || \n         (wl_state_r == WL_CORSE_INC_WAIT1) || (wl_state_r == WL_CORSE_INC_WAIT2) ||\n         ((wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)))\n       rd_data_previous_r         <= #TCQ rd_data_rise_wl_r;\n   end\n   \n   \n   always @(posedge clk)begin\n      if (rst | (wl_state_r == WL_DQS_CNT) |\n         (wl_state_r == WL_2RANK_TAP_DEC) |\n         (wl_state_r == WL_FINE_DEC) |\n         (rd_data_previous_r[dqs_count_r] != rd_data_rise_wl_r[dqs_count_r]) |\n         (wl_state_r1 == WL_INIT_FINE_DEC))\n        stable_cnt <= #TCQ 'd0;\n      else if ((wl_tap_count_r > 6'd0) & \n         (((wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)) |\n         ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) & (wl_state_r == WL_INIT_FINE_INC)))) begin\n        if ((rd_data_previous_r[dqs_count_r] == rd_data_rise_wl_r[dqs_count_r])\n           & (stable_cnt < 'd14))\n          stable_cnt <= #TCQ stable_cnt + 1;\n      end\n   end\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   always @(posedge clk)begin\n      if (rst | (wl_state_r == WL_DQS_CNT) |\n         (wl_state_r == WL_DQS_CHECK) | wr_level_done_r |\n         (wl_state_r1 == WL_INIT_FINE_DEC))\n        flag_ck_negedge <= #TCQ 1'd0;\n      else if ((rd_data_previous_r[dqs_count_r] && ((stable_cnt > 'd0) |\n              (wl_state_r == WL_FINE_DEC) | (wl_state_r == WL_FINE_DEC_WAIT) | (wl_state_r == WL_FINE_DEC_WAIT1))) |\n\t\t\t  (wl_state_r == WL_CORSE_INC)) \n        flag_ck_negedge <= #TCQ 1'd1;\n      else if (~rd_data_previous_r[dqs_count_r] && (stable_cnt == 'd14))\n               \n        flag_ck_negedge <= #TCQ 1'd0;\n   end\n   \n   \n   always @(posedge clk) begin\n     if (rst)\n       flag_init <= #TCQ 1'b1;\n     else if ((wl_state_r == WL_WAIT) && ((wl_state_r1 == WL_INIT_FINE_INC_WAIT) ||\n              (wl_state_r1 == WL_INIT_FINE_DEC_WAIT)))\n       flag_init <= #TCQ 1'b0;\n   end\n\n   \n   always @(posedge clk)begin\n     if (rst | flag_ck_negedge | flag_init | (wl_tap_count_r < 'd1) |\n         inhibit_edge_detect_r)\n       rd_data_edge_detect_r     <= #TCQ {DQS_WIDTH{1'b0}};\n     else if (rd_data_edge_detect_r[dqs_count_r] == 1'b1) begin\n       if ((wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT) || (wl_state_r == WL_FINE_DEC_WAIT1) ||\n           (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) || (wl_state_r == WL_CORSE_INC_WAIT_TMP) ||\n           (wl_state_r == WL_CORSE_INC_WAIT1) || (wl_state_r == WL_CORSE_INC_WAIT2))\n         rd_data_edge_detect_r <= #TCQ {DQS_WIDTH{1'b0}};\n       else\n         rd_data_edge_detect_r <= #TCQ rd_data_edge_detect_r;\n     end else if (rd_data_previous_r[dqs_count_r] && (stable_cnt < 'd14))\n       rd_data_edge_detect_r     <= #TCQ {DQS_WIDTH{1'b0}};\n     else\n       rd_data_edge_detect_r <= #TCQ (~rd_data_previous_r & rd_data_rise_wl_r);\n   end\n\n\n  \n  \n   always@(posedge clk) begin\n     wr_level_start_r <= #TCQ wr_level_start;\n   end\n\n   \n   \n   assign dqs_count_w = {2'b00, dqs_count_r};\n\n   assign oclk_count_w = {2'b00, oclkdelay_calib_cnt};\n   \n   always @(posedge clk) begin\n     if (rst)\n       incdec_wait_cnt <= #TCQ 'd0;\n     else if ((wl_state_r == WL_FINE_DEC_WAIT1) ||\n             (wl_state_r == WL_INIT_FINE_DEC_WAIT1) ||\n             (wl_state_r == WL_CORSE_INC_WAIT_TMP))\n       incdec_wait_cnt <= #TCQ incdec_wait_cnt + 1;\n     else\n       incdec_wait_cnt <= #TCQ 'd0;\n   end\n   \n \n   \n   \n   \n   \n   \n   \n   always @(posedge clk) begin\n      if(rst)begin\n         wrlvl_err              <= #TCQ 1'b0;\n         wr_level_done_r        <= #TCQ 1'b0;\n         wrlvl_rank_done_r      <= #TCQ 1'b0;\n         dqs_count_r            <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n         dq_cnt_inc             <= #TCQ 1'b1;\n         rank_cnt_r             <= #TCQ 2'b00;\n         wl_state_r             <= #TCQ WL_IDLE;\n         wl_state_r1            <= #TCQ WL_IDLE;\n         inhibit_edge_detect_r  <= #TCQ 1'b1;\n         wl_edge_detect_valid_r <= #TCQ 1'b0;\n         wl_tap_count_r         <= #TCQ 6'd0;\n         fine_dec_cnt           <= #TCQ 6'd0;\n         for (r = 0; r < DQS_WIDTH; r = r + 1) begin\n           fine_inc[r]          <= #TCQ 6'b0;\n           corse_dec[r]         <= #TCQ 3'b0;\n           corse_inc[r]         <= #TCQ 3'b0;\n           corse_cnt[r]         <= #TCQ 3'b0;\n         end\n         dual_rnk_dec           <= #TCQ 1'b0;\n         fast_cal_fine_cnt      <= #TCQ FAST_CAL_FINE;\n         fast_cal_coarse_cnt    <= #TCQ FAST_CAL_COARSE;\n         final_corse_dec        <= #TCQ 1'b0;\n         \n         wrlvl_redo_corse_inc   <= #TCQ 'd0;\n      end else begin\n         wl_state_r1            <= #TCQ wl_state_r;\n         case (wl_state_r)\n           \n           WL_IDLE: begin\n              wrlvl_rank_done_r      <= #TCQ 1'd0;\n              inhibit_edge_detect_r  <= #TCQ 1'b1;\n              if (wrlvl_byte_redo && ~wrlvl_byte_redo_r) begin\n                wr_level_done_r      <= #TCQ 1'b0;\n                dqs_count_r          <= #TCQ wrcal_cnt;\n                corse_cnt[wrcal_cnt] <= #TCQ final_coarse_tap[wrcal_cnt];\n                wl_tap_count_r       <= #TCQ smallest[wrcal_cnt];\n                if (early1_data && \n                    (((final_coarse_tap[wrcal_cnt] < 'd6) && (CLK_PERIOD/nCK_PER_CLK <= 2500)) ||\n                    ((final_coarse_tap[wrcal_cnt] < 'd3) && (CLK_PERIOD/nCK_PER_CLK > 2500))))\n                  wrlvl_redo_corse_inc <= #TCQ REDO_COARSE;\n                else if (early2_data && (final_coarse_tap[wrcal_cnt] < 'd2))\n                  wrlvl_redo_corse_inc <= #TCQ 3'd6;\n                else begin\n                  wl_state_r   <= #TCQ WL_IDLE;\n                  wrlvl_err    <= #TCQ 1'b1;\n                end\n              end else if (wrlvl_final && ~wrlvl_final_r) begin\n                wr_level_done_r <= #TCQ 1'b0;\n                dqs_count_r     <= #TCQ 'd0;\n              end\n\t\t\t\t\t\t\t\n              if(!wr_level_done_r & wr_level_start_r & wl_sm_start) begin\n                if (SIM_CAL_OPTION == \"FAST_CAL\")\n                  wl_state_r <= #TCQ WL_FINE_INC;\n                else\n                  wl_state_r <= #TCQ WL_INIT;\n              end\n           end\n           \n           WL_INIT: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              inhibit_edge_detect_r  <= #TCQ 1'b1;\n              wrlvl_rank_done_r      <= #TCQ 1'd0;\n              \n              if (wrlvl_final)\n                corse_cnt[dqs_count_w ]  <= #TCQ final_coarse_tap[dqs_count_w ]; \n              if (wrlvl_byte_redo) begin\n                if (|wl_tap_count_r) begin\n                  wl_state_r   <= #TCQ WL_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end else if ((corse_cnt[dqs_count_w] + wrlvl_redo_corse_inc) <= 'd7)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r   <= #TCQ WL_IDLE;\n                  wrlvl_err    <= #TCQ 1'b1;\n                end\n              end else if(wl_sm_start)\n                wl_state_r <= #TCQ WL_INIT_FINE_INC;\n           end\n           \n           \n           \n           \n           \n           \n           \n           WL_INIT_FINE_INC: begin\n              wl_state_r   <= #TCQ WL_INIT_FINE_INC_WAIT1;\n              wl_tap_count_r <= #TCQ wl_tap_count_r + 1'b1;\n              final_corse_dec <= #TCQ 1'b0;\n           end\n\n           WL_INIT_FINE_INC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_INIT_FINE_INC_WAIT;\n           end\n\n           \n           \n           \n           \n           \n           \n           \n           WL_INIT_FINE_INC_WAIT: begin\n              if (wl_sm_start) begin\n                if (stable_cnt < 'd14)\n                  wl_state_r   <= #TCQ WL_INIT_FINE_INC;\n                else if (~rd_data_previous_r[dqs_count_r]) begin\n                  wl_state_r             <= #TCQ WL_WAIT;\n                  inhibit_edge_detect_r  <= #TCQ 1'b0;\n                end else begin\n                  wl_state_r   <= #TCQ WL_INIT_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end\n              end\n           end\n\n           \n           \n           \n           \n           \n           WL_INIT_FINE_DEC: begin\n              wl_tap_count_r <= #TCQ 'd0;\n              wl_state_r   <= #TCQ WL_INIT_FINE_DEC_WAIT1;\n              if (fine_dec_cnt > 6'd0)\n                fine_dec_cnt <= #TCQ fine_dec_cnt - 1;\n              else\n                fine_dec_cnt <= #TCQ fine_dec_cnt;\n           end\n           \n           WL_INIT_FINE_DEC_WAIT1: begin\n             if (incdec_wait_cnt == 'd8)\n               wl_state_r   <= #TCQ WL_INIT_FINE_DEC_WAIT;\n           end\n           \n           WL_INIT_FINE_DEC_WAIT: begin\n              if (fine_dec_cnt > 6'd0) begin\n                wl_state_r             <= #TCQ WL_INIT_FINE_DEC;\n                inhibit_edge_detect_r  <= #TCQ 1'b1;\n              end else begin\n                wl_state_r             <= #TCQ WL_WAIT;\n                inhibit_edge_detect_r  <= #TCQ 1'b0;\n              end\n           end\n           \n           \n           WL_FINE_INC: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                wl_state_r <= #TCQ WL_FINE_INC_WAIT;\n                if (fast_cal_fine_cnt > 'd0)\n                  fast_cal_fine_cnt <= #TCQ fast_cal_fine_cnt - 1;\n                else\n                  fast_cal_fine_cnt <= #TCQ fast_cal_fine_cnt;\n              end else if (wr_level_done_r5) begin\n                wl_tap_count_r <= #TCQ 'd0;\n                wl_state_r <= #TCQ WL_FINE_INC_WAIT;\n                if (|fine_inc[dqs_count_w])\n                      fine_inc[dqs_count_w] <= #TCQ fine_inc[dqs_count_w] - 1;\n              end else begin\n                wl_state_r <= #TCQ WL_WAIT;\n                wl_tap_count_r <= #TCQ wl_tap_count_r + 1'b1;\n              end\n           end\n           \n           WL_FINE_INC_WAIT: begin\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_fine_cnt > 'd0)\n                  wl_state_r <= #TCQ WL_FINE_INC;\n                else if (fast_cal_coarse_cnt > 'd0)\n                  wl_state_r <= #TCQ WL_CORSE_INC;\n                else\n                  wl_state_r <= #TCQ WL_DQS_CNT;\n              end else if (|fine_inc[dqs_count_w])\n                wl_state_r   <= #TCQ WL_FINE_INC;\n              else if (dqs_count_r == (DQS_WIDTH-1))\n                wl_state_r   <= #TCQ WL_IDLE;\n              else begin\n                wl_state_r   <= #TCQ WL_2RANK_FINAL_TAP;\n                dqs_count_r  <= #TCQ dqs_count_r + 1;\n              end\n           end\n           \n           WL_FINE_DEC: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              wl_tap_count_r <= #TCQ 'd0;\n              wl_state_r   <= #TCQ WL_FINE_DEC_WAIT1;\n              if (fine_dec_cnt > 6'd0)\n                fine_dec_cnt <= #TCQ fine_dec_cnt - 1;\n              else\n                fine_dec_cnt <= #TCQ fine_dec_cnt;\n           end\n           \n           WL_FINE_DEC_WAIT1: begin\n             if (incdec_wait_cnt == 'd8)\n               wl_state_r   <= #TCQ WL_FINE_DEC_WAIT;\n           end\n           \n           WL_FINE_DEC_WAIT: begin\n              if (fine_dec_cnt > 6'd0)\n                wl_state_r   <= #TCQ WL_FINE_DEC;\n              \n              \n              else if (dual_rnk_dec) begin \n                if (|corse_dec[dqs_count_r])\n                  wl_state_r <= #TCQ WL_CORSE_DEC;\n                else\n                  wl_state_r <= #TCQ WL_2RANK_DQS_CNT;\n              end else if (wrlvl_byte_redo) begin\n                if ((corse_cnt[dqs_count_w] + wrlvl_redo_corse_inc) <= 'd7)\n                  wl_state_r <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r <= #TCQ WL_IDLE;\n                  wrlvl_err  <= #TCQ 1'b1;\n                end\n              end else\n                wl_state_r <= #TCQ WL_CORSE_INC;\n           end\n           \n           WL_CORSE_DEC: begin\n              wl_state_r   <= #TCQ WL_CORSE_DEC_WAIT;\n              dual_rnk_dec <= #TCQ 1'b0;\n              if (|corse_dec[dqs_count_r])\n                corse_dec[dqs_count_r] <= #TCQ corse_dec[dqs_count_r] - 1;\n              else\n                corse_dec[dqs_count_r]  <= #TCQ corse_dec[dqs_count_r];\n           end\n           \n           WL_CORSE_DEC_WAIT: begin\n              if (wl_sm_start) begin\n              \n              \n              if (|corse_dec[dqs_count_r])\n                wl_state_r <= #TCQ WL_CORSE_DEC_WAIT1;\n                else\n                wl_state_r <= #TCQ WL_2RANK_DQS_CNT;\n              end\n           end\n           \n           WL_CORSE_DEC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_DEC;\n           end\n           \n           WL_CORSE_INC: begin\n              wl_state_r <= #TCQ WL_CORSE_INC_WAIT_TMP;\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_coarse_cnt > 'd0)\n                  fast_cal_coarse_cnt <= #TCQ fast_cal_coarse_cnt - 1;\n                else\n                  fast_cal_coarse_cnt <= #TCQ fast_cal_coarse_cnt;\n              end else if (wrlvl_byte_redo) begin\n                corse_cnt[dqs_count_w] <= #TCQ corse_cnt[dqs_count_w] + 1;\n                if (|wrlvl_redo_corse_inc)                             \n                  wrlvl_redo_corse_inc <= #TCQ wrlvl_redo_corse_inc - 1;\n              end else if (~wr_level_done_r5)\n                corse_cnt[dqs_count_r] <= #TCQ corse_cnt[dqs_count_r] + 1;\n              else if (|corse_inc[dqs_count_w])                             \n                corse_inc[dqs_count_w] <= #TCQ corse_inc[dqs_count_w] - 1;\n           end\n\n           WL_CORSE_INC_WAIT_TMP: begin\n             if (incdec_wait_cnt == 'd8)\n             wl_state_r <= #TCQ WL_CORSE_INC_WAIT;\n           end\n           \n           WL_CORSE_INC_WAIT: begin\n              if (SIM_CAL_OPTION == \"FAST_CAL\") begin\n                if (fast_cal_coarse_cnt > 'd0)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else\n                  wl_state_r <= #TCQ WL_DQS_CNT;\n              end else if (wrlvl_byte_redo) begin\n                if (|wrlvl_redo_corse_inc)\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else begin\n                  wl_state_r            <= #TCQ WL_INIT_FINE_INC;\n                  inhibit_edge_detect_r <= #TCQ 1'b1;\n                end\n              end else if (~wr_level_done_r5 && wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT1;\n              else if (wr_level_done_r5) begin\n                if (|corse_inc[dqs_count_r])\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else if (|fine_inc[dqs_count_w]) \n                  wl_state_r   <= #TCQ WL_FINE_INC;\n                else if (dqs_count_r == (DQS_WIDTH-1))\n                  wl_state_r   <= #TCQ WL_IDLE;\n                else begin\n                  wl_state_r   <= #TCQ WL_2RANK_FINAL_TAP;\n                  dqs_count_r  <= #TCQ dqs_count_r + 1;\n                end\n              end\n           end\n           \n           WL_CORSE_INC_WAIT1: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT2;\n           end\n\n           WL_CORSE_INC_WAIT2: begin\n             if (wl_sm_start)\n                wl_state_r <= #TCQ WL_WAIT;\n           end\n           \n           WL_WAIT: begin\n              if (wl_sm_start)\n              wl_state_r <= #TCQ WL_EDGE_CHECK;\n           end\n           \n           WL_EDGE_CHECK: begin \n              if (wl_edge_detect_valid_r == 1'b0) begin\n                wl_state_r <= #TCQ WL_WAIT;\n                wl_edge_detect_valid_r <= #TCQ 1'b1;\n              end\n              \n              else if(rd_data_edge_detect_r[dqs_count_r] &&\n                      wl_edge_detect_valid_r)\n                begin\n                  wl_tap_count_r <= #TCQ wl_tap_count_r;\n                  if ((SIM_CAL_OPTION == \"FAST_CAL\") || (RANKS < 2) ||\n                      ~oclkdelay_calib_done)\n                    wl_state_r <= #TCQ WL_DQS_CNT;\n                  else\n                    wl_state_r <= #TCQ WL_2RANK_TAP_DEC;\n                end\n              \n              \n              else if((~wrlvl_tap_done_r) && (wl_tap_count_r > 6'd55)) begin\n                if (corse_cnt[dqs_count_r] < COARSE_TAPS) begin\n                  wl_state_r   <= #TCQ WL_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end  else begin\n                  wrlvl_err <= #TCQ 1'b1;\n                  wl_state_r   <= #TCQ WL_IDLE;\n                end\n\t      end else begin\n\t          if (wl_tap_count_r < 6'd56)  \n                    wl_state_r <= #TCQ WL_FINE_INC;\n\t          else if (corse_cnt[dqs_count_r] < COARSE_TAPS) begin\n                    wl_state_r   <= #TCQ WL_FINE_DEC;\n                    fine_dec_cnt <= #TCQ wl_tap_count_r;\n                  end else begin\n                   wrlvl_err <= #TCQ 1'b1;\n                   wl_state_r   <= #TCQ WL_IDLE;\n                  end\n\t      end\n           end\n\n           WL_2RANK_TAP_DEC: begin\n              wl_state_r    <= #TCQ WL_FINE_DEC;\n              fine_dec_cnt  <= #TCQ wl_tap_count_r;\n              for (m = 0; m < DQS_WIDTH; m = m + 1)\n                corse_dec[m] <= #TCQ corse_cnt[m];\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              dual_rnk_dec <= #TCQ 1'b1;\n           end\n           \n           WL_DQS_CNT: begin\n              if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                  (dqs_count_r == (DQS_WIDTH-1)) ||\n                  wrlvl_byte_redo) begin\n                dqs_count_r <= #TCQ dqs_count_r;\n                dq_cnt_inc  <= #TCQ 1'b0;\n              end else begin\n                dqs_count_r <= #TCQ dqs_count_r + 1'b1;\n                dq_cnt_inc  <= #TCQ 1'b1;\n              end\n              wl_state_r <= #TCQ WL_DQS_CHECK;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n           end\n           \n           WL_2RANK_DQS_CNT: begin\n              if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                 (dqs_count_r == (DQS_WIDTH-1))) begin\n                dqs_count_r <= #TCQ dqs_count_r;\n                dq_cnt_inc  <= #TCQ 1'b0;\n              end else begin\n                dqs_count_r <= #TCQ dqs_count_r + 1'b1;\n                dq_cnt_inc  <= #TCQ 1'b1;\n              end\n              wl_state_r <= #TCQ WL_DQS_CHECK;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              dual_rnk_dec <= #TCQ 1'b0;\n           end   \n           \n           WL_DQS_CHECK: begin \n              wl_tap_count_r <= #TCQ 'd0;\n              if (dq_cnt_inc == 1'b0)begin\n                wrlvl_rank_done_r <= #TCQ 1'd1;\n                for (t = 0; t < DQS_WIDTH; t = t + 1)\n                  corse_cnt[t] <= #TCQ 3'b0;\n                if ((SIM_CAL_OPTION == \"FAST_CAL\") || (RANKS < 2) || ~oclkdelay_calib_done) begin\n                  wl_state_r  <= #TCQ WL_IDLE;\n                  if (wrlvl_byte_redo)\n                    dqs_count_r <= #TCQ dqs_count_r;\n                  else \n                  dqs_count_r <= #TCQ 'd0;\n                end else if (rank_cnt_r == RANKS-1) begin\n                  dqs_count_r <= #TCQ dqs_count_r;\n                  if (RANKS > 1)\n                    wl_state_r  <= #TCQ WL_2RANK_FINAL_TAP;\n                  else\n                    wl_state_r  <= #TCQ WL_IDLE;\n                end else begin\n                  wl_state_r  <= #TCQ WL_INIT;\n                  dqs_count_r <= #TCQ 'd0;\n                end\n                if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                    (rank_cnt_r == RANKS-1)) begin\n                  wr_level_done_r <= #TCQ 1'd1;\n                  rank_cnt_r      <= #TCQ 2'b00;\n                end else begin\n                  wr_level_done_r <= #TCQ 1'd0;\n                  rank_cnt_r      <= #TCQ rank_cnt_r + 1'b1;\n                end\n              end else\n                wl_state_r  <= #TCQ WL_INIT;\n           end\n           \n           WL_2RANK_FINAL_TAP: begin\n              if (wr_level_done_r4 && ~wr_level_done_r5) begin\n                for(u = 0; u < DQS_WIDTH; u = u + 1) begin\n                  corse_inc[u] <= #TCQ final_coarse_tap[u];\n                  fine_inc[u]  <= #TCQ final_val[u];\n                end\n                dqs_count_r    <= #TCQ 'd0;\n              end else if (wr_level_done_r5) begin\n                if (|corse_inc[dqs_count_r])\n                  wl_state_r   <= #TCQ WL_CORSE_INC;\n                else if (|fine_inc[dqs_count_w])\n                  wl_state_r   <= #TCQ WL_FINE_INC;\n              end  \n           end\n        endcase\n     end\n   end \n\nendmodule\n              \n                 \n                \n   \n     \n\n   \n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: mig_7series_v4_1_ddr_phy_wrlvl. Module specification: This module implements write leveling functionality for a DDR memory interface, adjusting DQS signal timing relative to the clock for optimal data capture during writes. It uses a state machine to incrementally adjust fine and coarse delay taps, detecting edges in received data to determine optimal timing. The module supports multiple ranks and includes features for initial calibration, fine-tuning, and error handling. Key inputs include clk, rst, phy_ctl_ready, wr_level_start, and rd_data_rise0, while outputs include wrlvl_byte_done, wr_level_done, and various debug signals. Internal signals such as wl_state_r, wl_tap_count_r, and corse_cnt manage the state machine and delay adjustments. The module"
                }
            ]
        }
    ]
}