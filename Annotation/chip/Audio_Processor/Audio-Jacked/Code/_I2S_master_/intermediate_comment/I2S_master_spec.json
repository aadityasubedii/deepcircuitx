{
    "spec": "Module name: I2S_master\n\nModule specification: The I2S_master module functions as the master node of an Inter-IC Sound (I2S) protocol responsible for generating timing signals and managing data transitions for an I2S data line. \n\nInput Ports: \n1. clk: The master clock driving the transitions of signals and states within the module. \n2. rst: The reset signal returning the module states to their initial values when it is high. \n3. data_in: The digital audio data input, which influences the module's generated output according to the I2S protocol.\n\nOutput Ports: \n1. m_clk: The master clock output, oscillating at each clk input clock edge.\n2. LR_clk: The Left/Right clock of the I2S protocol, toggling at every complete stereo data transmission.\n3. s_clk: The serial clock of the I2S protocol, controlling bit shifting and reading in the data stream.\n4. DONE: The signal indicating the completion of one I2S data stream passing process.\n5. data_out: The I2S protocol-compliant output data stream.\n\nInternal Signals: \n1. LR_count, s_count, s_max, shift_count_0, shift_count_1: These counters and control signals coordinate and manage the timing and indexing of broadcasted data.\n2. NS and PS: These state signals control the transitions between different operational states that the module can exist in.\n\nStates: \nThe module operates in one of three states (IDLE, CHAN_0, CHAN_1). In the IDLE state, no active transmission takes place. In the CHAN_0 and CHAN_1 states, corresponding Channels 0 and 1 data is respectively transmitted. How each state functions is defined by several blocks of code. Constant parameters determine the data frame width, the base clock frequency, the sample rate, and the type of output signal channel. The states change based on the state transition block controlled by the master clock and the reset signal. The reset signal forces the system to transition to the IDLE state. Data output generation and handshaking signals are managed by another block, with the state being updated at each negative edge of the serial clock to toggle the DONE signal and broadcast data from the data_in input to the data_out output. A final block updates the values of m_clk, LR_clk, and s_clk with the positive edge of the primary clock, and the state of s_clk further influences the values of LR_clk and LR_count.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: I2S_master. Explanation: The I2S_master module appears to function as an I2S (Inter-IC Sound) protocol master. Depending on the provided parameters and input data, the module generates I2S timing signals, such as Master Clock (m_clk), Left/Right Clock (LR_clk), and Serial Clock (s_clk). It also seems to manage data transition (data_out), representing the I2S data line, and a handshaking signal (DONE) to synchronize other components. The module configures I2S transmission by choosing one of three states: IDLE, CHANNEL_0, or CHANNEL_1; during these states, different actions are performed based on clock edges and counts. The module handles reset signal processing for these signals ensuring the system returns to an initial state on reset."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports:\n1. clk: This is the master clock input to the module. The transitions of this clock drive the update of the other signals and states in the module.\n2. rst: This is the reset signal. When high, it resets the various states and signals in the module to their initial values.\n3. data_in: This is the digital audio data input to the module. Its width is defined by the parameter DIN_W. The state machines within the module use it to generate I2S protocol-compliant data.\n\nOutput Ports:\n1. m_clk: This is the master clock output. It oscillates at each positive edge of the input clock, clk.\n2. LR_clk: This is the Left/Right clock signal for the I2S protocol. It toggles every time a complete stereo sample has been transmitted.\n3. s_clk: This is the serial clock for the I2S protocol. It drives the shifting and reading of bits in the I2S data stream.\n4. DONE: This signal indicates the completion of one I2S data stream passing process. It turns high when a data frame (16 in this case) transmission is done.\n5. data_out: This is the output data stream. The module generates it by manipulating the data_in input according to the I2S protocol. Its value gets updated at each negative edge of the s_clk clock signal."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal Signals and Their Explanations:\n\n1. LR_count: This is a counter dedicated to controlling the Left/Right channel switching in the I2S protocol. It increments at every data bit transmitted until it reaches a set maximum, after which it resets to 0 and triggers a change in the LR_clk signal.\n\n2. s_count, s_max: These signals manage the clocking of the serial data out over the I2S protocol. s_count is a counter that increments at every clk edge and is used to control when s_clk, the serial clock for the I2S protocol, toggles. s_max is a constant value calculated during initialization and is used as the limit value for s_count to reach before toggling the s_clk signal.\n\n3. shift_count_0, shift_count_1: These are counters used to index the broadcasting of data_in during IDLE, CHANNEL_0, and CHANNEL_1 states, transmitting one bit at each negative edge of s_clk. They count from 0 up to 15 (a total of 16 bits, as indicated in the code).\n\n4. NS, PS: NS stands for the Next State and PS stands for the Present State. These signals are used to control the state machine transitions between the three states: IDLE, CHANNEL_0, and CHANNEL_1. They get updated at every clock edge, and the transitions define the module's behavior based on specific criteria.\n\n5. IDLE, CHAN_0, CHAN_1: These constants define the three operational states of the I2S_master module. IDLE is the state with no active transmission, CHAN_0 and CHAN_1 represent the states when Channel 0 and Channel 1 data is being transmitted respectively."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n`timescale 1ns / 1ps\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule I2S_master #(parameter Fs       = 8000,\t\t\t\n\t\t\t\t\t\t  parameter DIN_W    = 16,\t\t\t\t\n\t\t\t\t\t\t  parameter FPGA_CLK = 100000000,\t\n\t\t\t\t\t\t  parameter LR_SAM   = 1)\t\t\t\t\n  (input      clk, \n\tinput\t\t  rst,\n\tinput      [(DIN_W-1):0] data_in,\t\n\toutput reg m_clk, \t\t\t\t\t\t\n\toutput reg LR_clk, \t\t\t\t\t\t\n\toutput reg s_clk,\t\t\t\t\t\t\t\n\toutput reg DONE,\t\t\t\t\t\t\t\n\toutput reg data_out);\t\t\t\t\t\n\n\n\treg [$clog2(DIN_W * LR_SAM):0] LR_count;\t\t\t\t\t\t\n\treg [$clog2((FPGA_CLK*LR_SAM)/(2*Fs*DIN_W)):0] s_count;\n\treg [$clog2((FPGA_CLK*LR_SAM)/(2*Fs*DIN_W)):0] s_max;\n\treg [$clog2(DIN_W)-1:0] shift_count_0;\n\treg [$clog2(DIN_W)-1:0] shift_count_1;\n\t\n\t\n\n\treg [1:0] NS, PS;\n\t\n\t\n\n\tparameter IDLE   = 2'b00,\n\t\t\t\t CHAN_0 = 2'b01,\n\t\t\t\t CHAN_1 = 2'b10;\n\t\n\t\nalways @ (posedge clk) begin\n\t\ts_max <= (FPGA_CLK*LR_SAM)/(2*Fs*DIN_W); \n\tend\n\t\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk) begin\n\tif (rst) PS <= IDLE;\n\telse PS <= NS;\nend\n\n\n\n\n\nalways @ (posedge clk) begin\n\tcase (PS) \n\t\tIDLE:   begin\n\t\t\tNS <= CHAN_0;\n\t\tend\n\t\tCHAN_0:  begin\n\t\t\tNS <= (shift_count_0 == 15) ? CHAN_1 : CHAN_0;\n\t\tend\n\t\tCHAN_1: begin\n\t\t\tNS <= (shift_count_1 == 15) ? CHAN_0 : CHAN_1;\n\t\tend\n\tendcase\nend\n\n\n\n\n\nalways @ (negedge s_clk) begin\n\tcase (PS) \n\t\tIDLE:   begin\n\t\t\tDONE <= 0;\n\t\t\tshift_count_0 <= 0;\n\t\t\tshift_count_1 <= 0;\n\t\t\tdata_out <= 0;\n\t\tend\n\t\tCHAN_0:  begin\n\t\t\t\t\n\t\t\tif (shift_count_0 < DIN_W-1) begin\n\t\t\t\tshift_count_0 <= shift_count_0 + 1;\n\t\t\t\tdata_out <= data_in[shift_count_0];\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count_0 <= 0;\n\t\t\t\tdata_out <= data_in[shift_count_0];\n\t\t\tend\n\t\t\t\n\t\t\tif (shift_count_0 == 15) DONE <= 1;\n\t\t\telse DONE <= 0;\n\t\tend\n\t\t\n\t\tCHAN_1: begin\n\t\t\t\n\t\t\tif (shift_count_1 < DIN_W-1) begin\n\t\t\t\tshift_count_1 <= shift_count_1 + 1;\n\t\t\t\tdata_out <= data_in[shift_count_1];\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count_1 <= 0;\n\t\t\t\tdata_out <= data_in[shift_count_1];\n\t\t\tend\n\t\t\t\n\t\t\tif (shift_count_1 == 15) DONE <= 1;\n\t\t\telse DONE <= 0;\n\t\tend\n\tendcase\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\talways @ (posedge clk) begin\n\t\tif (rst) m_clk <= 0;\n\t\telse m_clk <= ~m_clk;\n\tend\t\n\t\n\t\n\n\n\n\n\n\talways @ (s_clk) begin\n\t\tif (rst) begin\n\t\t\tLR_count <= 0;\n\t\t\tLR_clk <= 0;\n\t\tend\n\t\telse if (s_clk == 0) begin      \n\t\t\n\t\t\n\t\t\tif (LR_count < (DIN_W-1) * LR_SAM) begin\n\t\t\t\tLR_count <= LR_count + 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tLR_count <= 0;\n\t\t\t\tLR_clk <= ~LR_clk;\n\t\t\tend\n\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tLR_count <= LR_count;\n\t\t\tLR_clk <= LR_clk;\n\t\t\tend\n\tend\n\t\n\n\n\n\n\n\n\talways @ (posedge clk) begin\n\t\tif (rst) begin\n\t\t\ts_count <= 0;\n\t\t\ts_clk <= 0;\n\t\tend\n\t\telse begin \n\t\t\tif (s_count < s_max) begin\n\t\t\t\ts_count <= s_count + 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\ts_count <= 0;\n\t\t\t\ts_clk <= ~s_clk;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: I2S_master\n\nModule specification: The I2S_master module functions as the master node of an Inter-IC Sound (I2S) protocol responsible for generating timing signals and managing data transitions for an I2S data line. \n\nInput Ports: \n1. clk: The master clock driving the transitions of signals and states within the module. \n2. rst: The reset signal returning the module states to their initial values when it is high. \n3. data_in: The digital audio data input, which influences the module's generated output according to the I2S protocol.\n\nOutput Ports: \n1. m_clk: The master clock output, oscillating at each clk input clock edge.\n2. LR_clk: The Left/Right clock of the I2S protocol, toggling at every complete stereo data transmission.\n3. s_clk: The serial clock of the I2S protocol, controlling bit shifting and reading in the data stream.\n4. DONE: The signal indicating the completion of one I2S data stream passing process.\n5. data_out: The I2S protocol-compliant output data stream.\n\nInternal Signals: \n1. LR_count, s_count, s_max, shift_count_0, shift_count_1: These counters and control signals coordinate and manage the timing and indexing of broadcasted data.\n2. NS and PS: These state signals control the transitions between different operational states that the module can exist in.\n\nStates: \nThe module operates in one of three states (IDLE, CHAN_0, CHAN_1). In the IDLE state, no active transmission takes place. In the CHAN_0 and CHAN_1 states, corresponding Channels 0 and 1 data is respectively transmitted. How each state functions is defined by several blocks of code. Constant parameters determine the data frame width, the base clock frequency, the sample rate, and the type of output signal channel. The states change based on the state transition block controlled by the master clock and the reset signal. The reset signal forces the system to transition to the IDLE state. Data output generation and handshaking signals are managed by another block, with the state being updated at each negative edge of the serial clock to toggle the DONE signal and broadcast data from the data_in input to the data_out output. A final block updates the values of m_clk, LR_clk, and s_clk with the positive edge of the primary clock, and the state of s_clk further influences the values of LR_clk and LR_count."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: I2S_master. Explanation: The I2S_master module appears to function as an I2S (Inter-IC Sound) protocol master. Depending on the provided parameters and input data, the module generates I2S timing signals, such as Master Clock (m_clk), Left/Right Clock (LR_clk), and Serial Clock (s_clk). It also seems to manage data transition (data_out), representing the I2S data line, and a handshaking signal (DONE) to synchronize other components. The module configures I2S transmission by choosing one of three states: IDLE, CHANNEL_0, or CHANNEL_1; during these states, different actions are performed based on clock edges and counts. The module handles reset signal processing for these signals ensuring the system returns to an initial state on reset."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports:\n1. clk: This is the master clock input to the module. The transitions of this clock drive the update of the other signals and states in the module.\n2. rst: This is the reset signal. When high, it resets the various states and signals in the module to their initial values.\n3. data_in: This is the digital audio data input to the module. Its width is defined by the parameter DIN_W. The state machines within the module use it to generate I2S protocol-compliant data.\n\nOutput Ports:\n1. m_clk: This is the master clock output. It oscillates at each positive edge of the input clock, clk.\n2. LR_clk: This is the Left/Right clock signal for the I2S protocol. It toggles every time a complete stereo sample has been transmitted.\n3. s_clk: This is the serial clock for the I2S protocol. It drives the shifting and reading of bits in the I2S data stream.\n4. DONE: This signal indicates the completion of one I2S data stream passing process. It turns high when a data frame (16 in this case) transmission is done.\n5. data_out: This is the output data stream. The module generates it by manipulating the data_in input according to the I2S protocol. Its value gets updated at each negative edge of the s_clk clock signal."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal Signals and Their Explanations:\n\n1. LR_count: This is a counter dedicated to controlling the Left/Right channel switching in the I2S protocol. It increments at every data bit transmitted until it reaches a set maximum, after which it resets to 0 and triggers a change in the LR_clk signal.\n\n2. s_count, s_max: These signals manage the clocking of the serial data out over the I2S protocol. s_count is a counter that increments at every clk edge and is used to control when s_clk, the serial clock for the I2S protocol, toggles. s_max is a constant value calculated during initialization and is used as the limit value for s_count to reach before toggling the s_clk signal.\n\n3. shift_count_0, shift_count_1: These are counters used to index the broadcasting of data_in during IDLE, CHANNEL_0, and CHANNEL_1 states, transmitting one bit at each negative edge of s_clk. They count from 0 up to 15 (a total of 16 bits, as indicated in the code).\n\n4. NS, PS: NS stands for the Next State and PS stands for the Present State. These signals are used to control the state machine transitions between the three states: IDLE, CHANNEL_0, and CHANNEL_1. They get updated at every clock edge, and the transitions define the module's behavior based on specific criteria.\n\n5. IDLE, CHAN_0, CHAN_1: These constants define the three operational states of the I2S_master module. IDLE is the state with no active transmission, CHAN_0 and CHAN_1 represent the states when Channel 0 and Channel 1 data is being transmitted respectively."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>`timescale 1ns / 1ps\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule I2S_master #(parameter Fs       = 8000,\t\t\t\n\t\t\t\t\t\t  parameter DIN_W    = 16,\t\t\t\t\n\t\t\t\t\t\t  parameter FPGA_CLK = 100000000,\t\n\t\t\t\t\t\t  parameter LR_SAM   = 1)\t\t\t\t\n  (input      clk, \n\tinput\t\t  rst,\n\tinput      [(DIN_W-1):0] data_in,\t\n\toutput reg m_clk, \t\t\t\t\t\t\n\toutput reg LR_clk, \t\t\t\t\t\t\n\toutput reg s_clk,\t\t\t\t\t\t\t\n\toutput reg DONE,\t\t\t\t\t\t\t\n\toutput reg data_out);\t\t\t\t\t\n\n\n\treg [$clog2(DIN_W * LR_SAM):0] LR_count;\t\t\t\t\t\t\n\treg [$clog2((FPGA_CLK*LR_SAM)/(2*Fs*DIN_W)):0] s_count;\n\treg [$clog2((FPGA_CLK*LR_SAM)/(2*Fs*DIN_W)):0] s_max;\n\treg [$clog2(DIN_W)-1:0] shift_count_0;\n\treg [$clog2(DIN_W)-1:0] shift_count_1;\n\t\n\t\n\n\treg [1:0] NS, PS;\n\t\n\t\n\n\tparameter IDLE   = 2'b00,\n\t\t\t\t CHAN_0 = 2'b01,\n\t\t\t\t CHAN_1 = 2'b10;\n\t\n\t\nalways @ (posedge clk) begin\n\t\ts_max <= (FPGA_CLK*LR_SAM)/(2*Fs*DIN_W); \n\tend\n\t\n\n\n\n\n\n\n\n\n\nalways @ (posedge clk) begin\n\tif (rst) PS <= IDLE;\n\telse PS <= NS;\nend\n\n\n\n\n\nalways @ (posedge clk) begin\n\tcase (PS) \n\t\tIDLE:   begin\n\t\t\tNS <= CHAN_0;\n\t\tend\n\t\tCHAN_0:  begin\n\t\t\tNS <= (shift_count_0 == 15) ? CHAN_1 : CHAN_0;\n\t\tend\n\t\tCHAN_1: begin\n\t\t\tNS <= (shift_count_1 == 15) ? CHAN_0 : CHAN_1;\n\t\tend\n\tendcase\nend\n\n\n\n\n\nalways @ (negedge s_clk) begin\n\tcase (PS) \n\t\tIDLE:   begin\n\t\t\tDONE <= 0;\n\t\t\tshift_count_0 <= 0;\n\t\t\tshift_count_1 <= 0;\n\t\t\tdata_out <= 0;\n\t\tend\n\t\tCHAN_0:  begin\n\t\t\t\t\n\t\t\tif (shift_count_0 < DIN_W-1) begin\n\t\t\t\tshift_count_0 <= shift_count_0 + 1;\n\t\t\t\tdata_out <= data_in[shift_count_0];\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count_0 <= 0;\n\t\t\t\tdata_out <= data_in[shift_count_0];\n\t\t\tend\n\t\t\t\n\t\t\tif (shift_count_0 == 15) DONE <= 1;\n\t\t\telse DONE <= 0;\n\t\tend\n\t\t\n\t\tCHAN_1: begin\n\t\t\t\n\t\t\tif (shift_count_1 < DIN_W-1) begin\n\t\t\t\tshift_count_1 <= shift_count_1 + 1;\n\t\t\t\tdata_out <= data_in[shift_count_1];\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_count_1 <= 0;\n\t\t\t\tdata_out <= data_in[shift_count_1];\n\t\t\tend\n\t\t\t\n\t\t\tif (shift_count_1 == 15) DONE <= 1;\n\t\t\telse DONE <= 0;\n\t\tend\n\tendcase\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\talways @ (posedge clk) begin\n\t\tif (rst) m_clk <= 0;\n\t\telse m_clk <= ~m_clk;\n\tend\t\n\t\n\t\n\n\n\n\n\n\talways @ (s_clk) begin\n\t\tif (rst) begin\n\t\t\tLR_count <= 0;\n\t\t\tLR_clk <= 0;\n\t\tend\n\t\telse if (s_clk == 0) begin      \n\t\t\n\t\t\n\t\t\tif (LR_count < (DIN_W-1) * LR_SAM) begin\n\t\t\t\tLR_count <= LR_count + 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tLR_count <= 0;\n\t\t\t\tLR_clk <= ~LR_clk;\n\t\t\tend\n\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tLR_count <= LR_count;\n\t\t\tLR_clk <= LR_clk;\n\t\t\tend\n\tend\n\t\n\n\n\n\n\n\n\talways @ (posedge clk) begin\n\t\tif (rst) begin\n\t\t\ts_count <= 0;\n\t\t\ts_clk <= 0;\n\t\tend\n\t\telse begin \n\t\t\tif (s_count < s_max) begin\n\t\t\t\ts_count <= s_count + 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\ts_count <= 0;\n\t\t\t\ts_clk <= ~s_clk;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: I2S_master\n\nModule specification: The I2S_master module functions as the master node of an Inter-IC Sound (I2S) protocol responsible for generating timing signals and managing data transitions for an I2S data line. \n\nInput Ports: \n1. clk: The master clock driving the transitions of signals and states within the module. \n2. rst: The reset signal returning the module states to their initial values when it is high. \n3. data_in: The digital audio data input, which influences the module's generated output according to the I2S protocol.\n\nOutput Ports: \n1. m_clk: The master clock output, oscillating at each clk input clock edge.\n2. LR_clk: The Left/Right clock of the I2S protocol, toggling at every complete stereo data transmission.\n3. s_clk: The serial clock of the I2S protocol, controlling bit shifting and reading in the data stream.\n4. DONE: The signal indicating the completion of one I2S data stream passing process.\n5. data_out: The I2S protocol-compliant output data stream.\n\nInternal Signals: \n1. LR_count, s_count, s_max, shift_count_0, shift_count_1: These counters and control signals coordinate and manage the timing and indexing of broadcasted data.\n2. NS and PS: These state signals control the transitions between different operational states that the module can exist in.\n\nStates: \nThe module operates in one of three states (IDLE, CHAN_0, CHAN_1). In the IDLE state, no active transmission takes place. In the CHAN_0 and CHAN_1 states, corresponding Channels 0 and 1 data is respectively transmitted. How each state functions is defined by several blocks of code. Constant parameters determine the data frame width, the base clock frequency, the sample rate, and the type of output signal channel. The states change based on the state transition block controlled by the master clock and the reset signal. The reset signal forces the system to transition to the IDLE state. Data output generation and handshaking signals are managed by another block, with the state being updated at each negative edge of the serial clock to toggle the DONE signal and broadcast data from the data_in input to the data_out output. A final block updates the values of m_clk, LR_clk, and s_clk with the positive edge of the primary clock, and the state of s_clk further influences the values of LR_clk and LR_count."
                }
            ]
        }
    ]
}