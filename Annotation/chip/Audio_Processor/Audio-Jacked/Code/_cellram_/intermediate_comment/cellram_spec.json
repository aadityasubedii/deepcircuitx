{
    "spec": "Module name: cellram. Module specification: The cellram module simulates a Cellular RAM (PSRAM) device, implementing synchronous and asynchronous access modes with configurable burst operations and timing parameters. It has input ports for clock (clk), control signals (adv_n, cre, ce_n, oe_n, we_n), byte enables (lb_n, ub_n), address (addr), and data (dq), with output ports for wait signal (o_wait) and bidirectional data (dq). Internal signals manage memory operations, configuration registers, state machines, and timing checks. The module consists of several blocks: memory array management, configuration register handling, asynchronous and synchronous access control, burst operations, refresh management, and extensive timing checks. It includes features such as deep power-down mode, partial array refresh, and software-controlled register access. The module uses include files for parameters",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: cellram\n\nExplanation: This module simulates a Cellular RAM (PSRAM) device. It implements the functionality of a memory chip with synchronous and asynchronous access modes, configurable burst operations, and various timing parameters. The module includes features such as read and write operations, configuration register access, deep power-down mode, and partial array refresh. It also performs timing checks to ensure proper operation according to the device specifications. The module uses include files for parameters and incorporates a separate path delay module for signal timing control."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, adv_n, cre, ce_n, oe_n, we_n, lb_n, ub_n, addr, dq\n\nExplanation:\n- clk: Clock input for synchronous operations\n- adv_n: Address valid signal (active low)\n- cre: Configuration register enable\n- ce_n: Chip enable (active low)\n- oe_n: Output enable (active low)\n- we_n: Write enable (active low)\n- lb_n, ub_n: Lower byte and upper byte enables (active low)\n- addr: Address input bus\n- dq: Bidirectional data bus\n\nOutput ports:\no_wait, dq\n\nExplanation:\n- o_wait: Wait signal output for indicating when the device is ready\n- dq: Bidirectional data bus (shared with input)\n\nThe module uses a bidirectional port (dq) for both input and output data transfer. The o_wait signal is the only dedicated output port, used to indicate the device's readiness state to the controller."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nclk_in, adv_n_in, cre_in, zz_n_in, wait_o, par_enabled, dq_out, dq_in, memory, memory_addr, memory_index, memory_used, software_access_unlock, software_access_which_reg, software_access_rcr_write, async_state, async_wr_lockout, data_out_enable, data_out_valid, wait_out_enable, wait_out_valid, async_cre, async_addr, deep_power_down_exit, tow_check, tavh_check, sync_access, last_access, last_ce, sync_addr, sync_burst_length_override, sync_cre, sync_we_n, sync_latency_cntr, wait_out, sync_wait, sync_wait_q, random_delay, Sync2AsyncConfig, row_count, rbc, rbc_by, rbc_dq, ref_collision, next_by_out, by_out, next_data_out, data_out.\n\nExplanation:\n1. clk_in, adv_n_in, cre_in: Buffered input signals for clock, address valid, and configuration register enable.\n2. zz_n_in: Internal signal for deep power-down control.\n3. wait_o: Internal wait signal connected to the output.\n4. par_enabled: Flag for partial array refresh feature.\n5. dq_out, dq_in: Internal signals for data output and input.\n6. memory, memory_addr, memory_index, memory_used: Signals for managing the internal memory array.\n7. software_access_unlock, software_access_which_reg, software_access_rcr_write: Signals for controlling software access to configuration registers.\n8. async_state: State machine for asynchronous operations.\n9. async_wr_lockout: Signal to prevent unwanted writes in asynchronous mode.\n10. data_out_enable, data_out_valid, wait_out_enable, wait_out_valid: Control signals for data output and wait signal generation.\n11. async_cre, async_addr: Latched signals for asynchronous configuration register and address inputs.\n12. deep_power_down_exit, tow_check, tavh_check: Flags for various timing checks and mode transitions.\n13. sync_access, last_access, last_ce: Flags for synchronous access control and previous access state.\n14. sync_addr, sync_burst_length_override, sync_cre, sync_we_n, sync_latency_cntr: Signals for synchronous operation control.\n15. wait_out, sync_wait, sync_wait_q: Signals for managing the wait output in different modes.\n16. random_delay: Variable for introducing random delays in synchronous read operations.\n17. Sync2AsyncConfig: Counter for synchronous to asynchronous mode transition.\n18. row_count, rbc, rbc_by, rbc_dq: Signals for managing row boundary crossings and related data.\n19. ref_collision: Signal for tracking refresh collisions.\n20. next_by_out, by_out, next_data_out, data_out: Signals for managing byte enable and data output operations."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\nmodule cellram (\n    clk, \n    adv_n,\n    cre, \n    o_wait,\n    ce_n,\n    oe_n,\n    we_n,\n    lb_n,\n    ub_n,\n    addr,\n    dq \n); \n\n`include \"cellram_parameters.vh\"\n\n    \n    `define DQ_PER_BY (DQ_BITS/BY_BITS)\n\n    \n    parameter DEBUG         =    'h1;\n    \n    \n    input                         clk;\n    input                         adv_n;\n    input                         cre;\n    output                        o_wait; \n    input                         ce_n;\n    input                         oe_n;\n    input                         we_n;\n    input                         lb_n;\n    input                         ub_n;\n    wire            [BY_BITS-1:0] by_n = {ub_n, lb_n};\n    input       [ADDR_BITS-1 : 0] addr;\n    inout         [DQ_BITS-1 : 0] dq;\n\n    wire                   [31:0] dq_out;\n    wire            [DQ_BITS-1:0] dq_in    = dq;\n    assign                        dq       = dq_out[DQ_BITS-1:0];\n    wire clk_in;\n    wire adv_n_in;\n    wire cre_in;\n    wire zz_n_in;\n    wire wait_o;\n    reg  par_enabled;\n    assign                        clk_in   = clk;\n    assign                        adv_n_in = adv_n;\n    assign                        cre_in   = (GENERATION == CR20) ? cre | dq_in[DQ_BITS-1] : cre;\n    assign                        zz_n_in  = 1'b1;\n    assign                        o_wait   = wait_o;\n    initial                       par_enabled <= 1'b1; \n\n    \n    reg             [DQ_BITS-1:0] memory [0:1<<MEM_BITS-1];\n    reg           [ADDR_BITS-1:0] memory_addr [0:1<<MEM_BITS-1];\n    reg              [MEM_BITS:0] memory_index;\n    reg              [MEM_BITS:0] memory_used;\n\n    \n    reg                     [1:0] software_access_unlock;\n    reg                     [1:0] software_access_which_reg;\n    reg                           software_access_rcr_write;\n\n    \n    parameter                     IDLE   = 0;\n    parameter                     WR     = 1;\n    parameter                     RD     = 2;\n    parameter                     CFG_RD = 3;\n    parameter                     CFG_WR = 4;\n\n    \n    reg                     [2:0] async_state;\n    reg                           async_wr_lockout;\n    wire                          data_out_enable;\n    wire                          data_out_valid;\n    wire                          wait_out_enable;\n    wire                          wait_out_valid;\n    reg                           async_cre;\n    reg           [ADDR_BITS-1:0] async_addr;\n    reg                           deep_power_down_exit;\n    reg                           tow_check;\n    reg                           tavh_check;\n\n    \n    reg                           sync_access;\n    reg                           last_access;\n    reg                           last_ce;\n    reg           [ADDR_BITS-1:0] sync_addr;\n    reg                           sync_burst_length_override;\n    reg                           sync_cre;\n    reg                           sync_we_n;\n    reg                     [3:0] sync_latency_cntr;\n    reg                           wait_out;\n    reg                           sync_wait;\n    reg                           sync_wait_q;\n    integer                       random_delay;\n    integer                       i;\n\n    \n    reg                   [2:0]   Sync2AsyncConfig;\n\n    \n    integer                       row_count;\n    reg                           rbc;\n    reg             [BY_BITS-1:0] rbc_by;\n    reg             [DQ_BITS-1:0] rbc_dq;\n\n    \n    time                          ref_collision;\n\n    \n    reg             [DQ_BITS-1:0] next_by_out;\n    reg             [DQ_BITS-1:0] by_out;\n    reg             [DQ_BITS-1:0] next_data_out;\n    reg             [DQ_BITS-1:0] data_out;\n    \n    \n    reg                     [2:0] burst_length;\n    reg                           burst_wrap_n;\n    reg                     [1:0] drive_strength;\n    reg                           clock_configuration;\n    reg                           wait_configuration;\n    reg                           cr20wait;\n    reg                           cr20wait_code;\n    reg                           wait_polarity;\n    reg                     [3:0] latency_counter;\n    reg                           initial_latency;\n    reg                           operating_mode;\n    wire                   [15:0] bus_conf_register = {operating_mode, initial_latency, latency_counter[2:0], wait_polarity, cr20wait, wait_configuration, 1'b0, clock_configuration, drive_strength, burst_wrap_n, burst_length};\n\n    \n    reg                     [2:0] partial_array_refresh;\n    reg                           deep_power_down_n;\n    reg                     [1:0] case_temp;\n    reg                           page_mode;\n    reg             [ADDR_BITS:0] partial_address_offset;\n    reg             [ADDR_BITS:0] partial_address_size;\n    wire                    [7:0] ref_conf_register = {page_mode, case_temp, deep_power_down_n, 1'b0, partial_array_refresh};\n\n\n    \n    wire                   [15:0] didr_conf_register = DIDR_DEFAULT[15:0];\n\n    \n    realtime                      tm_clk_pos;\n    realtime                      tm_clk_neg;\n    realtime                      tm_clk_period;\n    realtime                      tm_ce_n;\n    realtime                      tm_tcw;\n    realtime                      tm_tdpd;\n    realtime                      tm_tdpdx;\n    realtime                      tm_adv_n;\n    realtime                      tm_adv_n_pos;\n    realtime                      tm_adv_n_neg;\n    realtime                      tm_we_n;\n    realtime                      tm_by_n;\n    realtime                      tm_tbw;\n    realtime                      tm_cre;\n    realtime                      tm_async_cre;\n    realtime                      tm_addr;\n    realtime                      tm_async_addr;\n    realtime                      tm_upper_addr;\n    realtime                      tm_dq_tdw; \n    realtime                      tm_page_addr3;\n    realtime                      tm_page_addr2;\n    realtime                      tm_page_addr1;\n    realtime                      tm_page_addr0;\n    realtime                      tm_write_end;\n    realtime                      tm_power_up;\n    realtime                      tm_data_out;\n    realtime                      tm_data_delay;\n\n\n    \n    assign wait_o = wait_out_enable ? (wait_out_valid ? wait_out : 1'bx) : 1'bz;\n\n    \n    wire [31:0] dq_out_buf = (data_out_valid ? data_out : {32{1'bx}} );\n    bufif1 buf_dq [31:0]  (dq_out, dq_out_buf, {{32 - DQ_BITS{1'b0}} , {DQ_BITS{data_out_enable}} & by_out});\n\n    \n    wire clk2waite;\n    wire adv2dqe;\n    wire adv2dq;\n    wire adv2wi;\n    wire zz2pd;\n    wire ce2dqe;\n    wire ce2dq;\n    wire ce2cem;\n    wire ce2wi;\n    wire ce2waite;\n    wire ce2wait;\n    wire ce2rst;\n    wire oe2dqe;\n    wire oe2dq;\n    wire soe2dq;\n    wire oe2waite;\n    wire oe2wait;\n    wire we2dqe;\n    wire we2dq;\n    wire we2waite;\n    wire by2dqe;\n    wire by2dq;\n    wire addr2dq;\n    wire addr2wi;\n    wire saddr2dq;\n    wire variable_sync;\n\n    \n    wire #1 last_clk   = clk_in;\n    wire #1 last_adv_n = adv_n_in;\n    wire #1 last_oe_n  = oe_n;\n    wire #1 last_ce_n  = ce_n;\n    wire #1 last_ce2wi = ce2wi;\n    wire #1 last_we_n  = we_n;\n    wire #1 last_cre   = cre_in;\n    wire   [BY_BITS-1:0] #1 last_by_n = by_n;\n    wire   [DQ_BITS-1:0] #1 last_dq   = dq_in;\n\n    \n    initial begin\n        $timeformat (-9, 3, \" ns\", 1);\n        sync_access <= 1'b0;\n        software_access_rcr_write = 1'b0;\n        async_wr_lockout = 0;\n        ref_collision <= 0;\n        tm_power_up <= 0.0;\n        register_write(BCR, BCR_DEFAULT, 1'b0);\n        register_write(RCR, RCR_DEFAULT, 1'b0);\n        memory_used = 0;\n    end\n\n    always @(ce_n) begin\n        if (!ce_n) begin\n            if (DEBUG[0]) \n                $display(\"===============================================================\");\n            wait_out <= wait_polarity;\n        end else begin\n            if (!rbc && (sync_latency_cntr > 0)) begin\n                memory_write(sync_addr, {BY_BITS{1'b0}}, {DQ_BITS{1'bx}});\n                $display (\"%t ERROR: Data at address 'h%h has been corrupted because CE# was deasserted prior to the first data transfer.\", $realtime, sync_addr);\n            end\n            last_ce <= 1'b1;\n            sync_latency_cntr <= 0;\n            random_delay <= 0;\n            row_count <= 0;\n            rbc <= 0;\n        end\n\n        \n        if (!last_ce_n && ce_n) begin\n            if (!deep_power_down_n) begin \n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Deep Power Down Entry\", $realtime);\n                memory_used = 0;\n            end\n            if (deep_power_down_exit) begin\n                if ($realtime - tm_tdpdx < tDPDX)\n                    $display (\"%t ERROR: tDPDX violation on CE# by %t\", $realtime, tm_tdpdx + tDPDX - $realtime);\n                deep_power_down_exit <= 1'b0;\n                tm_power_up <= $realtime;\n            end\n        end else if (last_ce_n && !ce_n) begin\n            \n            \n            if ((GENERATION > CR10) && !deep_power_down_n) begin\n                register_write(RCR, ref_conf_register | 16'h0010, 1'b0);\n            end\n        end\n    end\n\n\n    \n    always @(adv_n_in or addr) begin\n        if (!adv_n_in) begin\n            async_addr <= addr;\n            tm_async_addr <= $realtime;\n        end\n    end\n    always @(adv_n_in or addr[ADDR_BITS-1:4]) begin\n        if (!adv_n_in) begin\n            tm_upper_addr <= $realtime;\n        end\n    end\n\n    \n    always @(adv_n_in or cre_in) begin\n        if (!adv_n_in) begin\n            async_cre <= cre_in;\n            tm_async_cre <= $realtime;\n        end\n    end\n\n    cellram_pathdelay cellram_pathdelay0 (\n        clk_in,\n        adv_n_in,\n        zz_n_in,\n        ce_n, \n        oe_n, \n        we_n, \n        by_n, \n        async_addr,\n        clk2waite,\n        adv2dqe,\n        adv2dq,\n        adv2wi,\n        zz2pd,\n        ce2dqe, \n        ce2dq,\n        ce2cem,\n        ce2wi,\n        ce2waite,\n        ce2wait,\n        ce2rst,\n        oe2dqe,\n        oe2dq,\n        soe2dq,\n        oe2waite,\n        oe2wait,\n        we2dqe,\n        we2dq,\n        we2waite,\n        by2dqe,\n        by2dq,\n        addr2dq,\n        addr2wi,\n        saddr2dq\n    );\n\n    assign data_out_enable = ce2dqe && oe2dqe && we2dqe && by2dqe;\n    assign variable_sync   = !operating_mode && !initial_latency && sync_access; \n    assign data_out_valid  = we2dq && ((!variable_sync && ce2dq && oe2dq && by2dq && adv2dq && addr2dq) || (variable_sync && soe2dq && saddr2dq));\n    assign wait_out_enable = cr20wait_code ? ce2waite && (oe2waite || clk2waite) && we2waite : ce2waite;\n    assign wait_out_valid  = cr20wait_code ? ce2wait  && (oe2wait  || clk2waite) : ce2wait;\n\n    always @(posedge clk) sync_access <= !ce_n;\n    always @(negedge adv_n or posedge ce_n) begin \n        sync_access <= 1'b0; \n    end\n\n    \n    always @(sync_access or ce2wi or we_n or oe_n or by_n or zz_n_in or async_cre or async_addr) begin\n        if (sync_access) begin\n            software_access_unlock <= 2'b0;\n            async_state = IDLE;\n        end else begin\n\n            \n            if ((async_state == WR) && ((last_ce2wi && !ce2wi) || (!last_we_n && we_n) || |(~last_by_n & by_n))) begin\n                if ($realtime - tm_tcw < tCW) \n                    $display (\"%t ERROR:   tCW violation on CE# by %t\", $realtime, tm_tcw + tCW - $realtime);\n                if ($realtime - tm_adv_n_neg < tVS) \n                    $display (\"%t ERROR:   tVS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tVS - $realtime);\n                if ($realtime - tm_tbw < tBW) \n                    $display (\"%t ERROR:   tBW violation on BY# by %t\", $realtime, tm_tbw + tBW - $realtime);\n                if ($realtime - tm_we_n < tWP)\n                    $display (\"%t ERROR:   tWP violation on WE# by %t\", $realtime, tm_we_n + tWP - $realtime);\n                if ($realtime - tm_async_cre < tAW) \n                    $display (\"%t ERROR:   tAW violation on CRE by %t\", $realtime, tm_async_cre + tAW - $realtime);\n                if ($realtime - tm_async_addr < tAW)\n                    $display (\"%t ERROR:   tAW violation on ADDR by %t\", $realtime, tm_async_addr + tAW - $realtime);\n                if ($realtime - tm_dq_tdw < tDW) \n                    $display (\"%t ERROR:   tDW violation on DQ by %t\", $realtime, tm_dq_tdw + tDW - $realtime);\n                if (($realtime - tm_async_addr < tWC) || ($realtime - tm_tcw < tWC))\n                    $display (\"%t ERROR:   tWC violation on ADDR\", $realtime);\n\n                if ((async_addr == {ADDR_BITS{1'b1}}) && (software_access_unlock == 2)) begin\n                    case (last_dq[1:0])\n                       (2'b00 & RCR_MASK[17:16])  : software_access_which_reg <= RCR;\n                       (2'b10 & DIDR_MASK[17:16]) : software_access_which_reg <= DIDR;\n                       (2'b01 & BCR_MASK[17:16])  : software_access_which_reg <= BCR;\n                       default: $display (\"%t ERROR: Async - Illegal Register Select = %h\", $realtime, last_dq[1:0]);\n                    endcase\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Unlock = %d, Register Select = %h\", $realtime, software_access_unlock, last_dq[1:0]);\n                    software_access_unlock <= software_access_unlock + 1;\n                end else if ((async_addr == {ADDR_BITS{1'b1}}) && (software_access_unlock == 3)) begin\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Write, Data = %h\", $realtime, last_dq[15:0]);\n                    register_write(software_access_which_reg, last_dq[15:0], 1'b1);\n                    software_access_unlock <= 2'b0;\n                end else begin\n                    memory_write(async_addr, last_by_n, last_dq);\n                    software_access_unlock <= 2'b0;\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Write data latched, addr = %h, Mask = %h, Data = %h\", $realtime, async_addr, last_by_n, last_dq);\n                end\n                async_state = IDLE;\n                async_wr_lockout = 1;\n                tavh_check <= #tAVH 1'b0;\n                tow_check <= #tOW 1'b1;\n            end\n\n            \n            if ((async_state == CFG_WR) && ((last_ce2wi && !ce2wi) || (!last_we_n && we_n))) begin\n                if ($realtime - tm_tcw < tCW) \n                    $display (\"%t ERROR:   tCW violation on CE# by %t\", $realtime, tm_tcw + tCW - $realtime);\n                if ($realtime - tm_adv_n_neg < tVS) \n                    $display (\"%t ERROR:   tVS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tVS - $realtime);\n                if ($realtime - tm_tbw < tBW) \n                    $display (\"%t ERROR:   tBW violation on BY# by %t\", $realtime, tm_tbw + tBW - $realtime);\n                if ($realtime - tm_we_n < tWP)\n                    $display (\"%t ERROR:   tWP violation on WE# by %t\", $realtime, tm_we_n + tWP - $realtime);\n                if ($realtime - tm_async_cre < tAW) \n                    $display (\"%t ERROR:   tAW violation on CRE by %t\", $realtime, tm_async_cre + tAW - $realtime);\n                if ($realtime - tm_async_addr < tAW)\n                    $display (\"%t ERROR:   tAW violation on ADDR by %t\", $realtime, tm_async_addr + tAW - $realtime);\n                if ($realtime - tm_dq_tdw < tDW) \n                    $display (\"%t ERROR:   tDW violation on DQ by %t\", $realtime, tm_dq_tdw + tDW - $realtime);\n                if (($realtime - tm_async_addr < tWC) || ($realtime - tm_tcw < tWC))\n                    $display (\"%t ERROR:   tWC violation on ADDR\", $realtime);\n\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Write data latched, Register Select = %h, Data = %h\", $realtime, async_addr>>REG_SEL, async_addr);\n                register_write(async_addr>>REG_SEL, async_addr[15:0], 1'b1);\n                software_access_unlock <= 2'b0;\n                async_state = IDLE;\n                async_wr_lockout = 1;\n                tow_check <= #tOW 1'b1;\n                tavh_check <= #tAVH 1'b0;\n                tm_write_end = $realtime;\n           end\n\n            \n            if (async_state == RD) begin\n                if (last_ce2wi && !ce2wi) begin\n                    if (($realtime - tm_upper_addr < tRC) || ($realtime - tm_tcw < tRC))\n                        $display (\"%t ERROR:   tRC violation on ADDR\", $realtime);\n                    if ($realtime - tm_page_addr3 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr3 + tPC - $realtime);\n                    if ($realtime - tm_page_addr2 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr2 + tPC - $realtime);\n                    if ($realtime - tm_page_addr1 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr1 + tPC - $realtime);\n                    if ($realtime - tm_page_addr0 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr0 + tPC - $realtime);\n                    async_state = IDLE;\n                end else if (!last_oe_n && oe_n) begin\n                    async_state = IDLE;\n                end\n            end\n\n            \n            if (!last_we_n && we_n) begin\n                async_wr_lockout = 0;\n            end\n            \n            if (last_ce2wi && !ce2wi) begin\n                tavh_check <= #tAVH 1'b0;\n            end\n\n            \n            if (!async_wr_lockout && ce2wi && !we_n && !async_cre) begin\n                if (async_state == WR) begin\n                    $display (\"%t ERROR: Async - Illegal or unintended Page Mode Write.\", $realtime);\n                end\n                async_state = WR;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Write\", $realtime);\n            end\n            if (!async_wr_lockout && ce2wi && !we_n && (async_cre || !zz_n_in) && ((GENERATION != CR20) || oe_n)) begin\n                if (async_state == CFG_WR) begin\n                    $display (\"%t ERROR: Async - Page Mode Configuration Register Write is Illegal.\", $realtime);\n                end\n                async_state = CFG_WR;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Write\", $realtime);\n            end\n            if (ce2wi && !oe_n && we_n && !async_cre) begin\n                next_data_out = {DQ_BITS{1'bx}};\n                if (!page_mode && (async_state == RD))\n                    $display (\"%t ERROR: Async - Illegal or unintended Page Mode Read.  Page mode is disabled in BCR\", $realtime);\n                if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                    $display (\"%t ERROR: Async - BY# must be LOW during READ cycles.\", $realtime);\n                if (async_addr == {ADDR_BITS{1'b1}} && (software_access_unlock == 3)) begin\n                    case (software_access_which_reg)\n                        RCR  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                        DIDR : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                        BCR  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                    endcase\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Read, Data = %h\", $realtime, next_data_out);\n                    software_access_unlock <= 2'b0;\n                end else begin \n                    next_data_out = memory_read(async_addr);\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Read, addr = %h, Data = %h\", $realtime, async_addr, next_data_out);\n                    if (async_addr == {ADDR_BITS{1'b1}}) begin\n                        if (software_access_unlock < 2) begin\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO: Async - Software Access Unlock = %d\", $realtime, software_access_unlock);\n                            software_access_unlock <= software_access_unlock + 1;\n                        end\n                    end else begin\n                        software_access_unlock <= 2'b0;\n                    end\n                end\n                data_out <= #tOH {DQ_BITS{1'bx}};\n                if (async_state == RD) begin\n                    data_out <= #tAPA next_data_out;\n                end else begin\n                    data_out <= #tOE next_data_out;\n                end\n                async_state = RD;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n            end\n            if (ce2wi && !oe_n && we_n && async_cre) begin\n                next_data_out = {DQ_BITS{1'bx}};\n                if (async_state == RD)\n                    $display (\"%t ERROR: Async - Page Mode Configuration Register Read is Illegal.\", $realtime);\n                if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                    $display (\"%t ERROR: Async - BY# must be LOW during READ cycles.\", $realtime);\n                if (!CRE_READ)\n                    $display (\"%t ERROR: Async - Access using CRE is WRITE only.\", $realtime);\n                case (async_addr>>REG_SEL)\n                    (RCR  & RCR_MASK[17:16])  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                    (DIDR & DIDR_MASK[17:16]) : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                    (BCR  & BCR_MASK[17:16])  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                    default: $display (\"%t ERROR: Async - Illegal Register Select = %h\", $realtime, async_addr>>REG_SEL);\n                endcase\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Read, Register Select = %h, Data = %h\", $realtime, async_addr>>REG_SEL, next_data_out);\n                software_access_unlock <= 2'b0;\n                data_out <= #tOH {DQ_BITS{1'bx}};\n                data_out <= #tOE next_data_out;\n                async_state = RD;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n            end\n\n            if (ce2wi) begin\n                next_by_out = 0;\n                for (i=0; i<BY_BITS; i=i+1) begin\n                    next_by_out = next_by_out | ({`DQ_PER_BY{!by_n[i]}}<<(i*`DQ_PER_BY));\n                end\n                by_out <= #tOH next_by_out;\n            end\n        end\n    end\n\n    always @(par_enabled or partial_address_offset or partial_address_size) begin : corrupt_memory\n        integer i;\n        if (par_enabled) begin\n            i = 0;\n            \n            if (partial_address_size > 0) begin\n                for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                    if ((memory_addr[memory_index] > partial_address_offset) && (memory_addr[memory_index] < partial_address_offset + partial_address_size)) begin\n                        memory_addr[i] = memory_addr[memory_index];\n                        memory[i] = memory[memory_index];\n                        i = i + 1;\n                    end\n                end\n            end\n            \n            for (memory_index=i; memory_index<memory_used; memory_index=memory_index+1) begin\n                memory_addr[memory_index] = 'bx;\n                memory[memory_index] = {DQ_BITS{1'bx}};\n            end\n            memory_used = i;\n        end\n    end\n\n    function memory_addr_exists;\n        input [ADDR_BITS-1:0] addr;\n        begin : index\n            memory_addr_exists = 0;\n            for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                if (memory_addr[memory_index] == addr) begin\n                    memory_addr_exists = 1;\n                    disable index;\n                end\n            end\n        end\n    endfunction\n\n    task memory_write;\n        input [ADDR_BITS-1:0] addr;\n        input [BY_BITS-1:0] data_mask;\n        input [DQ_BITS-1:0] data;\n\n        reg [DQ_BITS-1:0] bit_mask;\n        reg [DQ_BITS-1:0] write_data;\n        integer i;\n        begin : memory_write_task\n            if (par_enabled && (partial_address_size == 0)) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is NULL\", $realtime, addr);\n                disable memory_write_task; \n            end else if (par_enabled && ((addr < partial_address_offset) || (addr > partial_address_offset + partial_address_size - 1))) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is %h - %h\", $realtime, addr, partial_address_offset, partial_address_offset + partial_address_size - 1);\n                disable memory_write_task; \n            end else if (addr > (1<<ADDR_BITS) - 1) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Max Address is %h\", $realtime, addr, (1<<ADDR_BITS) - 1);\n                disable memory_write_task; \n            end else if (data_mask == {BY_BITS{1'b1}}) begin\n                disable memory_write_task; \n            end else if (data_mask == {BY_BITS{1'b0}}) begin\n                write_data = {DQ_BITS{1'b1}} & data;\n            end else begin\n                bit_mask = 0;\n                for (i=0; i<BY_BITS; i=i+1) begin\n                    bit_mask = bit_mask | ({`DQ_PER_BY{!data_mask[i]}}<<(i*`DQ_PER_BY));\n                end\n                write_data = (data & bit_mask) | (memory_read(addr) & ~bit_mask);\n            end\n\n            if (memory_used == 1<<MEM_BITS) begin\n                $display (\"%t ERROR: Memory overflow.  Write to Address %h with Data %h will be lost.\\nYou must increase the MEM_BITS parameter.\", $realtime, addr, data);\n                $stop(0);\n            end else begin\n                if (!memory_addr_exists(addr)) begin\n                    memory_used = memory_used + 1;\n                end\n                memory_addr[memory_index] = addr;\n                memory[memory_index] = write_data;\n            end\n        end\n    endtask\n\n    function [DQ_BITS-1:0] memory_read;\n        input [ADDR_BITS-1:0] addr;\n        begin\n            if (partial_address_size == 0) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is NULL\", $realtime, addr);\n                memory_read = {DQ_BITS{1'bx}};\n            end else if ((addr < partial_address_offset) || (addr > partial_address_offset + partial_address_size - 1)) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is %h - %h\", $realtime, addr, partial_address_offset, partial_address_offset + partial_address_size - 1);\n                memory_read = {DQ_BITS{1'bx}};\n            end else begin\n                if (memory_addr_exists(addr)) begin\n                    memory_read = memory[memory_index];\n                end else begin\n                    memory_read = {DQ_BITS{1'bx}};\n                end\n            end\n        end\n    endfunction\n\n    task register_write;\n        input  [1:0] select;\n        input [15:0] opcode;\n        input        report;\n        begin\n\n            case(select)\n                BCR: begin\n                    burst_length        = opcode[2:0];\n                    burst_wrap_n        = opcode[3];\n                    drive_strength      = opcode[5:4];\n                    clock_configuration = opcode[6];\n                    wait_configuration  = opcode[8];   \n                    cr20wait            = opcode[9];\n                    cr20wait_code       = (cr20wait == CR20WAIT_POLARITY);\n                    wait_polarity       = opcode[10];\n                    latency_counter     = (opcode[13:11] == 3'b000) ? 4'd8 : opcode[13:11];\n                    initial_latency     = opcode[14];\n                    if (!operating_mode && opcode[15]) begin \n                        Sync2AsyncConfig = latency_counter;\n                    end\n                    operating_mode      = opcode[15]; \n                end\n                RCR: begin\n                    partial_array_refresh = opcode[2:0];\n                    if (software_access_unlock) begin\n                        if ((GENERATION == CR10) && (deep_power_down_n ^ opcode[4]))\n                            $display (\"%t ERROR: Deep Power Down cannot be enabled or disabled using the software access sequence\", $realtime);\n                    end\n                    \n                    if (!deep_power_down_n && opcode[4]) begin\n                        if (GENERATION == CR10) begin\n                            tm_power_up <= $realtime;\n                        end else begin\n                            if ($realtime - tm_tdpd < tDPD)\n                                $display (\"%t ERROR:  tDPD violation on CE# by %t\", $realtime, tm_tdpd + tDPD - $realtime);\n                            deep_power_down_exit <= 1'b1;\n                            tm_tdpdx <= $realtime;\n                        end\n                        if (DEBUG[0]) \n                            $display (\"%t  INFO: Deep Power Down Exit\", $realtime);\n                    end\n                    deep_power_down_n     = opcode[4];\n                    case_temp             = opcode[6:5];\n                    page_mode             = opcode[7];\n                end\n            endcase\n\n            if (report) begin\n                case(select)\n                    (BCR & BCR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = BCR\", $realtime);\n                        if ((~BCR_MASK & opcode) !== (~BCR_MASK & BCR_DEFAULT))\n                            $display (\"%t ERROR: Reserved bits in BCR cannot be changed from their default value.\", $realtime);\n\n                        if (&BCR_MASK[2:0]) begin\n                            casex ({(GENERATION > CR10), burst_length})\n                                4'bx001:$display (\"%t  INFO: Burst Length =  4 words\", $realtime);\n                                4'bx010:$display (\"%t  INFO: Burst Length =  8 words\", $realtime);\n                                4'bx011:$display (\"%t  INFO: Burst Length = 16 words\", $realtime);\n                                4'b1100:$display (\"%t  INFO: Burst Length = 32 words\", $realtime);\n                                4'bx111:$display (\"%t  INFO: Burst Length = continuous\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Burst Length = %h\", $realtime, burst_length);\n                            endcase\n                        end\n\n                        if (BCR_MASK[3]) begin\n                            case (burst_wrap_n)\n                                1'b0   :$display (\"%t  INFO: Burst Wrap = Burst wraps within the burst length\", $realtime);\n                                1'b1   :$display (\"%t  INFO: Burst Wrap = Burst no wrap\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Burst Wrap = %h\", $realtime, burst_wrap_n);\n                            endcase\n                        end\n\n                        if (|BCR_MASK[5:4]) begin\n                            case (drive_strength & BCR_MASK[5:4])\n                                2'b00  :$display (\"%t  INFO: Drive Strength = Full\", $realtime);  \n                                2'b01  :$display (\"%t  INFO: Drive Strength = 1/2\", $realtime);  \n                                2'b10  :$display (\"%t  INFO: Drive Strength = 1/4\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Drive Strength = %h\", $realtime, drive_strength);\n                            endcase\n                        end\n\n                        if (BCR_MASK[6]) begin\n                            case (clock_configuration)\n                                1'b1   :$display (\"%t  INFO: Clock Configuration = Rising edge\", $realtime); \n                                default:$display (\"%t ERROR: Illegal Clock Configuration = %h\", $realtime, clock_configuration);\n                            endcase\n                        end\n\n                        if (BCR_MASK[8]) begin\n                            case (wait_configuration)\n                                1'b0   :$display (\"%t  INFO: WAIT Configuration = Asserted during delay\", $realtime); \n                                1'b1   :$display (\"%t  INFO: WAIT Configuration = Asserted one data cycle before delay\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal WAIT Configuration = %h\", $realtime, wait_configuration);\n                            endcase\n                        end\n\n                        if (BCR_MASK[9]) begin\n                            case (cr20wait_code)\n                                1'b0   :$display (\"%t  INFO: CR1.5 WAIT Behavior\", $realtime); \n                                1'b1   :$display (\"%t  INFO: CR2.0 WAIT Behavior\", $realtime);\n                                default:$display (\"%t ERROR: Illegal CR2.0 WAIT Behavior = %h\", $realtime, cr20wait_code);\n                            endcase\n                        end\n\n                        if (BCR_MASK[10]) begin\n                            case (wait_polarity)\n                                1'b0   :$display (\"%t  INFO: Wait Polarity = Active LOW\", $realtime); \n                                1'b1   :$display (\"%t  INFO: Wait Polarity = Active HIGH\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Wait Polarity = %h\", $realtime, wait_polarity);\n                            endcase\n                        end\n\n                        if (&BCR_MASK[13:11]) begin\n                            casex ({initial_latency, latency_counter})\n                                5'hx2  :$display (\"%t  INFO: Latency Counter = Code 2\", $realtime);\n                                5'hx3  :$display (\"%t  INFO: Latency Counter = Code 3\", $realtime);   \n                                5'h14  :$display (\"%t  INFO: Latency Counter = Code 4\", $realtime);\n                                5'h15  :$display (\"%t  INFO: Latency Counter = Code 5\", $realtime);\n                                5'h16  :$display (\"%t  INFO: Latency Counter = Code 6\", $realtime);\n                                5'h18  :$display (\"%t  INFO: Latency Counter = Code 8\", $realtime);\n                                default:$display (\"%t ERROR: Illegal Latency Counter = %h\", $realtime, latency_counter);\n                            endcase\n                        end\n\n                        if (BCR_MASK[14]) begin\n                            case (initial_latency)\n                                1'b0   :$display (\"%t  INFO: Initial Access Latency = Variable\", $realtime);  \n                                1'b1   :$display (\"%t  INFO: Initial Access Latency = Fixed\", $realtime);\n                                default:$display (\"%t ERROR: Illegal Initial Access Latency = %h\", $realtime, initial_latency);\n                            endcase\n                        end\n\n                        if (BCR_MASK[15]) begin\n                            case (operating_mode)\n                                1'b0   :$display (\"%t  INFO: Operating Mode = Synchronous burst access mode\", $realtime);\n                                1'b1   :$display (\"%t  INFO: Operating Mode = Asynchronous access mode\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Operating Mode = %h\", $realtime, operating_mode);\n                            endcase\n                        end\n                    end\n\n                    (RCR & RCR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = RCR\", $realtime);\n                        if ((~RCR_MASK & opcode) !== (~RCR_MASK & RCR_DEFAULT))\n                            $display (\"%t ERROR: Reserved bits in RCR cannot be changed from their default value.\", $realtime);\n\n                        if (RCR_MASK[2:0]) begin\n                            case (partial_array_refresh)\n                               3'b000 : begin $display (\"%t  INFO: Partial Array Refresh =       Full array\", $realtime); partial_address_size = 1<<(ADDR_BITS-0); partial_address_offset = 0; end\n                               3'b001 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/2 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-1); partial_address_offset = 0; end\n                               3'b010 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/4 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-2); partial_address_offset = 0; end\n                               3'b011 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/8 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-3); partial_address_offset = 0; end\n                               3'b100 : begin $display (\"%t  INFO: Partial Array Refresh =             None\", $realtime); partial_address_size = 0;                partial_address_offset = 0; end\n                               3'b101 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/2 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-1); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               3'b110 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/4 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-2); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               3'b111 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/8 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-3); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               default: begin $display (\"%t ERROR: Illegal Partial Array Refresh = %h\", $realtime, partial_array_refresh); end\n                            endcase\n                        end\n\n                        if (RCR_MASK[4]) begin\n                            case (deep_power_down_n)\n                               1'b0   : $display (\"%t  INFO: Deep Power Down = DPD Enable\", $realtime);\n                               1'b1   : $display (\"%t  INFO: Deep Power Down = DPD Disable\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Deep Power Down = %h\", $realtime, deep_power_down_n);\n                            endcase\n                        end\n\n                        if (&RCR_MASK[6:5]) begin\n                            case (case_temp)\n                               2'b00  : $display (\"%t  INFO: Maximum Case Temp = 70 degrees C\", $realtime);\n                               2'b01  : $display (\"%t  INFO: Maximum Case Temp = 45 degrees C\", $realtime);\n                               2'b10  : $display (\"%t  INFO: Maximum Case Temp = 15 degrees C\", $realtime);\n                               2'b11  : $display (\"%t  INFO: Maximum Case Temp = 85 degrees C\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Maximum Case Temp = %h\", $realtime, case_temp);\n                            endcase\n                        end\n\n                        if (RCR_MASK[7]) begin\n                            case (page_mode)\n                               1'b0   : $display (\"%t  INFO: Page Mode = Page Mode Disabled\", $realtime);\n                               1'b1   : $display (\"%t  INFO: Page Mode = Page Mode Enable\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Page Mode = %h\", $realtime, page_mode);\n                            endcase\n                        end\n                    end\n                    (DIDR & DIDR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = DIDR\", $realtime);\n                        $display (\"%t ERROR: DIDR Configuration Register is read-only\", $realtime);\n                    end\n                    default: begin\n                        $display (\"%t ERROR: Illegal Register Select = %d\", $realtime, select);\n                    end\n                endcase\n            end\n        end\n    endtask\n\n    \n    always @(posedge clk_in) begin\n        if (!operating_mode || Sync2AsyncConfig) begin \n\n            if (!ce_n) begin\n                if (!adv_n_in) begin \n                    sync_addr = addr;\n                    \n                    sync_burst_length_override = (dq_in[DQ_BITS-2] && (GENERATION == CR20));\n                    sync_cre = cre_in;\n                    sync_we_n = we_n;\n\n                    if (!rbc && (sync_latency_cntr > 0)) \n                        $display (\"%t ERROR: Illegal burst interrupt.  Burst interrupt is illegal until after the first data word has been transferred.\", $realtime);\n                    last_access <= 1'b1;\n                    last_ce <= 1'b0;\n                    random_delay <= 0;\n                    row_count <= 0;\n                    rbc <= 0;\n\n                    if (!sync_we_n) begin \n                        if (DEBUG[0]) begin\n                            if (sync_cre) begin\n                                $display (\"%t  INFO:  Sync - Configuration Register Write\", $realtime);\n                            end else begin\n                                $display (\"%t  INFO:  Sync - Write\", $realtime);\n                            end\n                        end\n                    end else begin \n                        if (DEBUG[0]) begin\n                            if (sync_cre) begin\n                                $display (\"%t  INFO:  Sync - Configuration Register Read\", $realtime);\n                            end else begin\n                                $display (\"%t  INFO:  Sync - Read\", $realtime);\n                            end\n                        end\n                        \n                        if (!initial_latency && ($time - ref_collision >= tCEM)) begin\n                            ref_collision <= $time;\n                            random_delay = ($random % latency_counter);\n                            if (DEBUG[0] && (random_delay > 0)) \n                                $display (\"%t  INFO:  Sync - Read refresh collision of %d clocks has occurred.\", $realtime, random_delay);\n                        end\n                    end\n                    sync_latency_cntr = !sync_we_n + random_delay + latency_counter + 1;\n                    sync_wait = wait_polarity;\n                    sync_wait_q = wait_polarity;\n                end\n\n                if (!sync_we_n) begin\n                    if ((!sync_cre) && (oe_n !== 1))\n                        $display (\"%t ERROR: Sync - OE# must be driven high during sync writes\", $realtime);\n                end else begin\n                    if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                        $display (\"%t ERROR: Sync - BY# must be LOW during READ cycles.\", $realtime);\n                end\n\n                if (row_count > 0) begin\n                    if (row_count == 1) begin\n                        $display (\"%t ERROR: CE# must go HIGH before the third CLK after the WAIT period asserts with BCR[8] = 0, or before the fourth CLK after WAIT asserts with BCR[8] = 1\", $realtime);\n                    end else begin\n                        row_count = row_count - 1;\n                    end\n                end else if (rbc) begin\n                    if (sync_latency_cntr == 2*latency_counter + 2 + !sync_we_n) begin\n                        rbc_by = by_n;\n                        rbc_dq = dq_in;\n                    end else if (sync_latency_cntr == 2) begin\n                        if (!sync_we_n) begin\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Write, addr = %h, Mask = %h, Data = %h - Row Boundary Crossing\", $realtime, sync_addr, rbc_by, rbc_dq);\n                            memory_write(sync_addr, rbc_by, rbc_dq);\n                            sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                        end\n                        rbc <= 0;\n                    end\n                end else if (sync_latency_cntr < 2) begin \n                    next_by_out = 0;\n                    for (i=0; i<BY_BITS; i=i+1) begin\n                        next_by_out = next_by_out | ({`DQ_PER_BY{!by_n[i]}}<<(i*`DQ_PER_BY));\n                    end\n                    by_out   <= #tKOH next_by_out;\n                    data_out <= #tKOH {DQ_BITS{1'bx}};\n\n                    if (!sync_we_n) begin \n                        if (sync_cre) begin \n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Configuration Register Write data latched, Register Select = %h, Data = %h\", $realtime, sync_addr>>REG_SEL, sync_addr);\n                            register_write(sync_addr>>REG_SEL, sync_addr[15:0], 1'b1);\n                        end else begin \n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Write, addr = %h, Mask = %h, Data = %h\", $realtime, sync_addr, by_n, dq_in);\n                            memory_write(sync_addr, by_n, dq_in);\n                        end\n                    end else begin \n                        if (sync_cre) begin \n                            case (sync_addr>>REG_SEL)\n                                (RCR  & RCR_MASK[17:16])  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                                (DIDR & DIDR_MASK[17:16]) : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                                (BCR  & BCR_MASK[17:16])  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                                default: $display (\"%t ERROR:  Sync - Illegal Register Select = %h\", $realtime, sync_addr>>REG_SEL);\n                            endcase\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Configuration Register Read, Register Select = %h, Data = %h\", $realtime, sync_addr>>REG_SEL, next_data_out);\n                            data_out <= #tACLK next_data_out;\n                        end else begin \n                            next_data_out = memory_read(sync_addr);\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Read, addr = %h, Data = %h\", $realtime, sync_addr, next_data_out);\n                            data_out <= #tACLK next_data_out;\n                        end\n                    end\n\n                    \n                    if (!sync_cre) begin\n                        \n                        \n                        if (!burst_wrap_n && (sync_we_n || (GENERATION > CR10))) begin \n                            case (burst_length | {3{sync_burst_length_override}}) \n                                3'b001 : sync_addr[         1:0] = sync_addr[         1:0] + 1;\n                                3'b010 : sync_addr[         2:0] = sync_addr[         2:0] + 1;\n                                3'b011 : sync_addr[         3:0] = sync_addr[         3:0] + 1;\n                                3'b100 : sync_addr[         4:0] = sync_addr[         4:0] + 1;\n                                3'b111 : sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                            endcase\n                            $display (\"%t  INFO:  Sync - increment addr = %h\", $realtime, sync_addr);\n                        end else begin \n                            if (sync_addr[COL_BITS-1:0] == {COL_BITS{1'b1}}) begin\n                                sync_wait = wait_polarity;\n                                \n                                if (!initial_latency && (GENERATION == CR10)) begin\n                                    rbc <= 1;\n                                    sync_latency_cntr = 2*latency_counter + 3 + !sync_we_n;\n                                end else begin\n                                    row_count = 3 + (sync_we_n | !cr20wait_code);\n                                end\n                            end\n                            sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                        end\n                    end\n                end\n\n                if (sync_latency_cntr == (!sync_we_n + 2)) begin\n                    sync_wait = !wait_polarity;\n                \n                end else if (cr20wait_code && !sync_we_n && burst_wrap_n && (sync_addr[COL_BITS-1:0] == {COL_BITS{1'b1}})) begin\n                    sync_wait = wait_polarity;\n                end\n            end\n        end\n\n        if (sync_latency_cntr > 0) begin\n            sync_latency_cntr <= sync_latency_cntr - 1;\n        end\n\n        if (Sync2AsyncConfig > 0) begin\n            Sync2AsyncConfig <= Sync2AsyncConfig - 1;\n        end\n\n        if (wait_configuration) begin \n            wait_out <= #tKHTL sync_wait;\n        end else begin\n            wait_out <= #tKHTL sync_wait_q;\n        end\n\n        sync_wait_q <= sync_wait;\n    end\n\n\n    \n    always @(posedge clk_in) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_ce_n < tCSP)\n                $display (\"%t ERROR:  tCSP violation on CE# by %t\", $realtime, tm_ce_n + tCSP - $realtime);\n            if (!ce_n) begin\n                if ($realtime - tm_adv_n < tSP)\n                    $display (\"%t ERROR:   tSP violation on ADV# by %t\", $realtime, tm_adv_n + tSP - $realtime);\n                if (adv_n_in) begin\n                    if ($realtime - tm_by_n < tSP)\n                        $display (\"%t ERROR:   tSP violation on BY# by %t\", $realtime, tm_by_n + tSP - $realtime);\n                end else begin\n                    if ($realtime - tm_we_n < tSP)\n                        $display (\"%t ERROR:   tSP violation on WE# by %t\", $realtime, tm_we_n + tSP - $realtime);\n                    if ($realtime - tm_cre < tSP)\n                        $display (\"%t ERROR:   tSP violation on CRE by %t\", $realtime, tm_cre + tSP - $realtime);\n                    if ($realtime - tm_addr < tSP) \n                        $display (\"%t ERROR:   tSP violation on ADDR by %t\", $realtime, tm_addr + tSP - $realtime);\n                end\n\n                tm_clk_period = min_clk_period(initial_latency, latency_counter[2:0]);\n                if (tm_clk_period == 0.0)\n                    $display (\"%t ERROR: Illegal latency counter = %h\", $realtime, latency_counter);\n                if ($realtime - tm_clk_pos < tm_clk_period)\n                    $display (\"%t ERROR: Clock Period must be >= %f while Latency Counter = %h.  Actual Clock Period = %f\", $realtime, tm_clk_period, latency_counter, $realtime - tm_clk_pos);\n\n                if ($realtime - tm_clk_pos < tCLK)\n                    $display (\"%t ERROR:  tCLK minimum violation on CLK by %t\", $realtime, tm_clk_pos + tCLK - $realtime);\n                if ($realtime - tm_clk_neg < tKP)\n                    $display (\"%t ERROR:   tKP minimum violation on CLK by %t\", $realtime, tm_clk_neg + tKP - $realtime);\n            end\n        end\n        tm_clk_pos = $realtime - 0.0001;  \n    end\n\n    always @(negedge clk_in) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_clk_pos < tKP)\n                $display (\"%t ERROR:   tKP minimum violation on CLK by %t\", $realtime, tm_clk_pos + tKP - $realtime);\n        end\n        tm_clk_neg = $realtime - 0.0001;  \n    end\n\n    always @(ce_n) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_clk_pos < tHD) \n                $display (\"%t ERROR:   tHD violation on CE# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n        end\n        if (!ce_n) begin\n            if (last_access) begin\n                if ($realtime - tm_ce_n < tCBPH)\n                    $display (\"%t ERROR: tCBPH violation on CE# by %t\", $realtime, tm_ce_n + tCBPH - $realtime);\n            end else begin\n                if ($realtime - tm_ce_n < tCPH)\n                    $display (\"%t ERROR:  tCPH violation on CE# by %t\", $realtime, tm_ce_n + tCPH - $realtime);\n                if ($realtime - tm_write_end < tWR)\n                    $display (\"%t ERROR:   tWR violation on CE# by %t\", $realtime, tm_write_end + tWR - $realtime);\n            end\n            if ($realtime - tm_power_up < tPU)\n                $display (\"%t  WARN:   tPU violation on CE# by %t\", $realtime, tm_power_up + tPU - $realtime);\n        end\n        tm_ce_n = $realtime;\n        tm_tcw  <= $realtime;\n        tm_tdpd <= $realtime;\n    end\n\n    always @(adv_n_in) begin\n        if (!ce_n) begin\n            if ($realtime - tm_clk_pos < tHD) \n                $display (\"%t ERROR:   tHD violation on ADV# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            if (adv_n_in) begin\n                if (!sync_access) begin\n                    if ($realtime - tm_ce_n < tCVS)\n                        $display (\"%t ERROR:  tCVS violation on CE# by %t\", $realtime, tm_ce_n + tCVS - $realtime);\n                    if ($realtime - tm_adv_n < tVP)\n                        $display (\"%t ERROR:   tVP violation on ADV# by %t\", $realtime, tm_adv_n + tVP - $realtime);\n                    if ($realtime - tm_cre < tAVS)\n                        $display (\"%t ERROR:  tAVS violation on CRE by %t\", $realtime, tm_cre + tAVS - $realtime);\n                    if ($realtime - tm_addr < tAVS)\n                        $display (\"%t ERROR:  tAVS violation on ADDR by %t\", $realtime, tm_addr + tAVS - $realtime);\n                end\n                if (!sync_access | initial_latency) begin\n                    if ($realtime - tm_cre < tAVH)\n                        $display (\"%t ERROR:  tAVH violation on CRE by %t\", $realtime, tm_cre + tAVH - $realtime);\n                    if ($realtime - tm_addr < tAVH)\n                        $display (\"%t ERROR:  tAVH violation on ADDR by %t\", $realtime, tm_addr + tAVH - $realtime);\n                end\n            end else begin\n                if ($realtime - tm_adv_n < tVPH)\n                    $display (\"%t ERROR:   tVPH violation on ADV# by %t\", $realtime, tm_adv_n + tVPH - $realtime);\n            end\n        end\n        if (adv_n_in) begin\n            tm_adv_n_pos = $realtime;\n        end else begin\n            tm_adv_n_neg <= $realtime;\n        end\n        tm_adv_n = $realtime;\n    end\n\n    always @(we_n) begin\n        if (!ce_n) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on WE# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access) begin\n                if (!we_n) begin\n                    if ($realtime - tm_we_n < tWPH)\n                        $display (\"%t ERROR:   tWPH violation on WE# by %t\", $realtime, tm_we_n + tWPH - $realtime);\n                end\n            end\n        end\n        tm_we_n <= $realtime;\n    end\n\n    \n    always @(we_n or ce2wi) begin\n        if (!sync_access && !we_n && ce2wi) begin\n            if ($realtime - tm_adv_n_neg < tAS)\n                $display (\"%t ERROR:   tAS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tAS - $realtime);\n            if ($realtime - tm_async_addr < tAS)\n                $display (\"%t ERROR:   tAS violation on ADDR by %t\", $realtime, tm_async_addr + tAS - $realtime);\n        end\n    end\n\n    always @(by_n) begin\n        if (!ce_n) begin\n            if (adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on BY# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n        end\n        tm_by_n = $realtime;\n        tm_tbw <= $realtime;\n    end\n\n    always @(cre_in) begin\n        if (!ce_n | tavh_check) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on CRE by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access | initial_latency) begin\n                if ($realtime - tm_adv_n_pos < tAVH) \n                    $display (\"%t ERROR:  tAVH violation on CRE by %t\", $realtime, tm_adv_n_pos + tAVH - $realtime);\n            end\n        end\n        tm_cre = $realtime;\n    end\n\n    always @(addr) begin\n        if (!ce_n | tavh_check) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on ADDR by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access | initial_latency) begin\n                if ($realtime - tm_adv_n_pos < tAVH) \n                    $display (\"%t ERROR:  tAVH violation on ADDR by %t\", $realtime, tm_adv_n_pos + tAVH - $realtime);\n            end\n        end\n        tm_addr = $realtime;\n    end\n\n    task addr_timing_check;\n    input i;\n    integer i;\n    begin\n        if (!ce_n && !adv_n_in && !oe_n && we_n && (by_n == {BY_BITS{1'b0}})) begin\n            case (i)\n                3: begin if ($realtime - tm_page_addr3 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr3 + tPC - $realtime); tm_page_addr3 <= $realtime; end\n                2: begin if ($realtime - tm_page_addr2 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr2 + tPC - $realtime); tm_page_addr2 <= $realtime; end\n                1: begin if ($realtime - tm_page_addr1 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr1 + tPC - $realtime); tm_page_addr1 <= $realtime; end\n                0: begin if ($realtime - tm_page_addr0 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr0 + tPC - $realtime); tm_page_addr0 <= $realtime; end\n            endcase\n        end\n    end\n    endtask\n\n    always @(addr[3]) addr_timing_check(3);\n    always @(addr[2]) addr_timing_check(2);\n    always @(addr[1]) addr_timing_check(1);\n    always @(addr[0]) addr_timing_check(0);\n\n    always @(dq_in) begin\n        if (!sync_access) begin\n            if ($realtime - tm_write_end < tDH) \n                $display (\"%t ERROR:  tDH violation on DQ by %t\", $realtime, tm_write_end + tDH - $realtime);\n        end\n        tm_dq_tdw <= $realtime;\n    end\n\n    \n    always @(posedge tow_check) begin\n        if (!oe_n) begin\n            if (dq_in !== {DQ_BITS{1'bz}})\n                $display (\"%t ERROR:  tOW violation on DQ\", $realtime);\n        end\n        tow_check <= 1'b0;\n    end\n\n\n    \n    always @(posedge ce2cem) begin\n        if (deep_power_down_exit !== 1'b1)\n            $display (\"%t ERROR:  tCEM violation on CE#\", $realtime);\n    end\n\nendmodule\n\nmodule cellram_pathdelay (\n    clk,\n    adv_n,\n    zz_n,\n    ce_n,\n    oe_n,\n    we_n,\n    by_n,\n    addr, \n    clk2waite,\n    adv2dqe,\n    adv2dq,\n    adv2wi,\n    zz2pd,\n    ce2dqe,\n    ce2dq,\n    ce2cem,\n    ce2wi,\n    ce2waite,\n    ce2wait,\n    ce2rst,\n    oe2dqe,\n    oe2dq,\n    soe2dq,\n    oe2waite,\n    oe2wait,\n    we2dqe,\n    we2dq,\n    we2waite,\n    by2dqe, \n    by2dq,\n    addr2dq,\n    addr2wi,\n    saddr2dq\n);\n    `include \"cellram_parameters.vh\"\n\n    input clk;\n    input adv_n;\n    input zz_n;\n    input ce_n;\n    input oe_n;\n    input we_n;\n    input [BY_BITS-1:0] by_n;\n    input [ADDR_BITS-1:0] addr;\n    output clk2waite;\n    output adv2dqe;\n    output adv2dq;\n    output adv2wi;\n    output zz2pd;\n    output ce2dqe;\n    output ce2dq;\n    output ce2cem;\n    output ce2wi;\n    output ce2waite;\n    output ce2wait;\n    output ce2rst;\n    output oe2dqe;\n    output oe2dq;\n    output soe2dq;\n    output oe2waite;\n    output oe2wait;\n    output we2dqe;\n    output we2waite;\n    output we2dq;\n    output by2dqe;\n    output by2dq;\n    output addr2dq;\n    output addr2wi;\n    output saddr2dq;\n\n    reg adv2dqr, addr2dqr, addr2wir, saddr2dqr, clk2waiter;\n\n    always @(negedge adv_n) begin\n        if (!adv_n) begin\n            adv2dqr <= 1'b0;\n            adv2dqr <= #(1) 1'b1;\n        end\n    end\n\n    always @(addr[ADDR_BITS-1:4]) begin\n        addr2dqr <= 1'b0;\n        addr2dqr <= #(1) 1'b1;\n    end\n\n    always @(addr) begin\n        addr2wir <= 1'b0;\n        addr2wir <= #(1) 1'b1;\n    end\n\n    always @(posedge clk) begin \n        if (!adv_n) begin\n            saddr2dqr <= 1'b0;\n            saddr2dqr <= #(1) 1'b1;\n        end\n    end\n\n    always @(posedge ce_n or posedge clk) begin\n        clk2waiter <= !ce_n;\n    end\n\n    assign clk2waite = clk2waiter;\n    assign adv2dqe   = adv_n;\n    assign adv2dq    = adv2dqr;\n    assign adv2wi    = adv2dqr;\n    assign zz2pd     = !zz_n;\n    assign ce2dqe    = !ce_n;\n    assign ce2dq     = !ce_n;\n    assign ce2cem    = !ce_n;\n    assign ce2wi     = !ce_n;\n    assign ce2waite  = !ce_n;\n    assign ce2wait   = !ce_n;\n    assign ce2rst    = ce_n;\n    assign oe2dqe    = !oe_n;\n    assign oe2dq     = !oe_n;\n    assign soe2dq    = !oe_n;\n    assign oe2waite  = !oe_n;\n    assign oe2wait   = !oe_n;\n    assign we2dqe    = we_n;\n    assign we2dq     = we_n;\n    assign we2waite  = we_n;\n    \n    \n    assign by2dqe    = !(&by_n);\n    assign by2dq     = !(&by_n);\n    assign addr2dq   = addr2dqr;\n    assign addr2wi   = addr2wir;\n    assign saddr2dq  = saddr2dqr;\n\n    specify\n        specparam PATHPULSE$ = 0; \n\n        (clk   =>clk2waite) = (   tKHTL,  tHZ);\n        (adv_n =>  adv2dqe) = (    tALZ, tAHZ);\n        (negedge adv_n => (adv2dq +: adv_n)) = (tAADV,  tOH);\n        (negedge adv_n => (adv2wi +: adv_n)) = (tWI,  0);\n        (zz_n  =>    zz2pd) = (    tDPD,    0);\n        (ce_n  =>   ce2dqe) = (     tLZ,  tHZ);\n        (ce_n  =>    ce2dq) = (     tCO,    0);\n        (ce_n  =>   ce2cem) = (    tCEM,    0);\n        (ce_n  =>    ce2wi) = (     tWI,    0);\n        (ce_n  => ce2waite) = (tCEW_MIN,  tHZ);\n        (ce_n  =>  ce2wait) = (tCEW_MAX,    0);\n        (ce_n  =>   ce2rst) = (      15,    0);\n        (oe_n  =>   oe2dqe) = (    tOLZ, tOHZ);\n        (oe_n  =>    oe2dq) = (     tOE,    0);\n        (oe_n  =>   soe2dq) = (    tBOE,    0);\n        (oe_n  => oe2waite) = (tOEW_MIN,  tHZ);\n        (oe_n  =>  oe2wait) = (tOEW_MAX,    0);\n        (we_n  =>   we2dqe) = (       0, tWHZ);\n        (we_n  =>    we2dq) = (       0,    0);\n        (we_n  => we2waite) = (       0,    0);\n        (by_n  *>   by2dqe) = (    tBLZ, tBHZ);\n        (by_n  *>    by2dq) = (     tBA,    0);\n        (addr  *>  addr2dq) = (     tAA,  tOH);\n        (addr  *>  addr2wi) = (     tWI,    0);\n        (posedge clk   => (saddr2dq +: clk)) = (tABA,  tKOH);\n    endspecify\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: cellram. Module specification: The cellram module simulates a Cellular RAM (PSRAM) device, implementing synchronous and asynchronous access modes with configurable burst operations and timing parameters. It has input ports for clock (clk), control signals (adv_n, cre, ce_n, oe_n, we_n), byte enables (lb_n, ub_n), address (addr), and data (dq), with output ports for wait signal (o_wait) and bidirectional data (dq). Internal signals manage memory operations, configuration registers, state machines, and timing checks. The module consists of several blocks: memory array management, configuration register handling, asynchronous and synchronous access control, burst operations, refresh management, and extensive timing checks. It includes features such as deep power-down mode, partial array refresh, and software-controlled register access. The module uses include files for parameters"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: cellram\n\nExplanation: This module simulates a Cellular RAM (PSRAM) device. It implements the functionality of a memory chip with synchronous and asynchronous access modes, configurable burst operations, and various timing parameters. The module includes features such as read and write operations, configuration register access, deep power-down mode, and partial array refresh. It also performs timing checks to ensure proper operation according to the device specifications. The module uses include files for parameters and incorporates a separate path delay module for signal timing control."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, adv_n, cre, ce_n, oe_n, we_n, lb_n, ub_n, addr, dq\n\nExplanation:\n- clk: Clock input for synchronous operations\n- adv_n: Address valid signal (active low)\n- cre: Configuration register enable\n- ce_n: Chip enable (active low)\n- oe_n: Output enable (active low)\n- we_n: Write enable (active low)\n- lb_n, ub_n: Lower byte and upper byte enables (active low)\n- addr: Address input bus\n- dq: Bidirectional data bus\n\nOutput ports:\no_wait, dq\n\nExplanation:\n- o_wait: Wait signal output for indicating when the device is ready\n- dq: Bidirectional data bus (shared with input)\n\nThe module uses a bidirectional port (dq) for both input and output data transfer. The o_wait signal is the only dedicated output port, used to indicate the device's readiness state to the controller."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nclk_in, adv_n_in, cre_in, zz_n_in, wait_o, par_enabled, dq_out, dq_in, memory, memory_addr, memory_index, memory_used, software_access_unlock, software_access_which_reg, software_access_rcr_write, async_state, async_wr_lockout, data_out_enable, data_out_valid, wait_out_enable, wait_out_valid, async_cre, async_addr, deep_power_down_exit, tow_check, tavh_check, sync_access, last_access, last_ce, sync_addr, sync_burst_length_override, sync_cre, sync_we_n, sync_latency_cntr, wait_out, sync_wait, sync_wait_q, random_delay, Sync2AsyncConfig, row_count, rbc, rbc_by, rbc_dq, ref_collision, next_by_out, by_out, next_data_out, data_out.\n\nExplanation:\n1. clk_in, adv_n_in, cre_in: Buffered input signals for clock, address valid, and configuration register enable.\n2. zz_n_in: Internal signal for deep power-down control.\n3. wait_o: Internal wait signal connected to the output.\n4. par_enabled: Flag for partial array refresh feature.\n5. dq_out, dq_in: Internal signals for data output and input.\n6. memory, memory_addr, memory_index, memory_used: Signals for managing the internal memory array.\n7. software_access_unlock, software_access_which_reg, software_access_rcr_write: Signals for controlling software access to configuration registers.\n8. async_state: State machine for asynchronous operations.\n9. async_wr_lockout: Signal to prevent unwanted writes in asynchronous mode.\n10. data_out_enable, data_out_valid, wait_out_enable, wait_out_valid: Control signals for data output and wait signal generation.\n11. async_cre, async_addr: Latched signals for asynchronous configuration register and address inputs.\n12. deep_power_down_exit, tow_check, tavh_check: Flags for various timing checks and mode transitions.\n13. sync_access, last_access, last_ce: Flags for synchronous access control and previous access state.\n14. sync_addr, sync_burst_length_override, sync_cre, sync_we_n, sync_latency_cntr: Signals for synchronous operation control.\n15. wait_out, sync_wait, sync_wait_q: Signals for managing the wait output in different modes.\n16. random_delay: Variable for introducing random delays in synchronous read operations.\n17. Sync2AsyncConfig: Counter for synchronous to asynchronous mode transition.\n18. row_count, rbc, rbc_by, rbc_dq: Signals for managing row boundary crossings and related data.\n19. ref_collision: Signal for tracking refresh collisions.\n20. next_by_out, by_out, next_data_out, data_out: Signals for managing byte enable and data output operations."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\nmodule cellram (\n    clk, \n    adv_n,\n    cre, \n    o_wait,\n    ce_n,\n    oe_n,\n    we_n,\n    lb_n,\n    ub_n,\n    addr,\n    dq \n); \n\n`include \"cellram_parameters.vh\"\n\n    \n    `define DQ_PER_BY (DQ_BITS/BY_BITS)\n\n    \n    parameter DEBUG         =    'h1;\n    \n    \n    input                         clk;\n    input                         adv_n;\n    input                         cre;\n    output                        o_wait; \n    input                         ce_n;\n    input                         oe_n;\n    input                         we_n;\n    input                         lb_n;\n    input                         ub_n;\n    wire            [BY_BITS-1:0] by_n = {ub_n, lb_n};\n    input       [ADDR_BITS-1 : 0] addr;\n    inout         [DQ_BITS-1 : 0] dq;\n\n    wire                   [31:0] dq_out;\n    wire            [DQ_BITS-1:0] dq_in    = dq;\n    assign                        dq       = dq_out[DQ_BITS-1:0];\n    wire clk_in;\n    wire adv_n_in;\n    wire cre_in;\n    wire zz_n_in;\n    wire wait_o;\n    reg  par_enabled;\n    assign                        clk_in   = clk;\n    assign                        adv_n_in = adv_n;\n    assign                        cre_in   = (GENERATION == CR20) ? cre | dq_in[DQ_BITS-1] : cre;\n    assign                        zz_n_in  = 1'b1;\n    assign                        o_wait   = wait_o;\n    initial                       par_enabled <= 1'b1; \n\n    \n    reg             [DQ_BITS-1:0] memory [0:1<<MEM_BITS-1];\n    reg           [ADDR_BITS-1:0] memory_addr [0:1<<MEM_BITS-1];\n    reg              [MEM_BITS:0] memory_index;\n    reg              [MEM_BITS:0] memory_used;\n\n    \n    reg                     [1:0] software_access_unlock;\n    reg                     [1:0] software_access_which_reg;\n    reg                           software_access_rcr_write;\n\n    \n    parameter                     IDLE   = 0;\n    parameter                     WR     = 1;\n    parameter                     RD     = 2;\n    parameter                     CFG_RD = 3;\n    parameter                     CFG_WR = 4;\n\n    \n    reg                     [2:0] async_state;\n    reg                           async_wr_lockout;\n    wire                          data_out_enable;\n    wire                          data_out_valid;\n    wire                          wait_out_enable;\n    wire                          wait_out_valid;\n    reg                           async_cre;\n    reg           [ADDR_BITS-1:0] async_addr;\n    reg                           deep_power_down_exit;\n    reg                           tow_check;\n    reg                           tavh_check;\n\n    \n    reg                           sync_access;\n    reg                           last_access;\n    reg                           last_ce;\n    reg           [ADDR_BITS-1:0] sync_addr;\n    reg                           sync_burst_length_override;\n    reg                           sync_cre;\n    reg                           sync_we_n;\n    reg                     [3:0] sync_latency_cntr;\n    reg                           wait_out;\n    reg                           sync_wait;\n    reg                           sync_wait_q;\n    integer                       random_delay;\n    integer                       i;\n\n    \n    reg                   [2:0]   Sync2AsyncConfig;\n\n    \n    integer                       row_count;\n    reg                           rbc;\n    reg             [BY_BITS-1:0] rbc_by;\n    reg             [DQ_BITS-1:0] rbc_dq;\n\n    \n    time                          ref_collision;\n\n    \n    reg             [DQ_BITS-1:0] next_by_out;\n    reg             [DQ_BITS-1:0] by_out;\n    reg             [DQ_BITS-1:0] next_data_out;\n    reg             [DQ_BITS-1:0] data_out;\n    \n    \n    reg                     [2:0] burst_length;\n    reg                           burst_wrap_n;\n    reg                     [1:0] drive_strength;\n    reg                           clock_configuration;\n    reg                           wait_configuration;\n    reg                           cr20wait;\n    reg                           cr20wait_code;\n    reg                           wait_polarity;\n    reg                     [3:0] latency_counter;\n    reg                           initial_latency;\n    reg                           operating_mode;\n    wire                   [15:0] bus_conf_register = {operating_mode, initial_latency, latency_counter[2:0], wait_polarity, cr20wait, wait_configuration, 1'b0, clock_configuration, drive_strength, burst_wrap_n, burst_length};\n\n    \n    reg                     [2:0] partial_array_refresh;\n    reg                           deep_power_down_n;\n    reg                     [1:0] case_temp;\n    reg                           page_mode;\n    reg             [ADDR_BITS:0] partial_address_offset;\n    reg             [ADDR_BITS:0] partial_address_size;\n    wire                    [7:0] ref_conf_register = {page_mode, case_temp, deep_power_down_n, 1'b0, partial_array_refresh};\n\n\n    \n    wire                   [15:0] didr_conf_register = DIDR_DEFAULT[15:0];\n\n    \n    realtime                      tm_clk_pos;\n    realtime                      tm_clk_neg;\n    realtime                      tm_clk_period;\n    realtime                      tm_ce_n;\n    realtime                      tm_tcw;\n    realtime                      tm_tdpd;\n    realtime                      tm_tdpdx;\n    realtime                      tm_adv_n;\n    realtime                      tm_adv_n_pos;\n    realtime                      tm_adv_n_neg;\n    realtime                      tm_we_n;\n    realtime                      tm_by_n;\n    realtime                      tm_tbw;\n    realtime                      tm_cre;\n    realtime                      tm_async_cre;\n    realtime                      tm_addr;\n    realtime                      tm_async_addr;\n    realtime                      tm_upper_addr;\n    realtime                      tm_dq_tdw; \n    realtime                      tm_page_addr3;\n    realtime                      tm_page_addr2;\n    realtime                      tm_page_addr1;\n    realtime                      tm_page_addr0;\n    realtime                      tm_write_end;\n    realtime                      tm_power_up;\n    realtime                      tm_data_out;\n    realtime                      tm_data_delay;\n\n\n    \n    assign wait_o = wait_out_enable ? (wait_out_valid ? wait_out : 1'bx) : 1'bz;\n\n    \n    wire [31:0] dq_out_buf = (data_out_valid ? data_out : {32{1'bx}} );\n    bufif1 buf_dq [31:0]  (dq_out, dq_out_buf, {{32 - DQ_BITS{1'b0}} , {DQ_BITS{data_out_enable}} & by_out});\n\n    \n    wire clk2waite;\n    wire adv2dqe;\n    wire adv2dq;\n    wire adv2wi;\n    wire zz2pd;\n    wire ce2dqe;\n    wire ce2dq;\n    wire ce2cem;\n    wire ce2wi;\n    wire ce2waite;\n    wire ce2wait;\n    wire ce2rst;\n    wire oe2dqe;\n    wire oe2dq;\n    wire soe2dq;\n    wire oe2waite;\n    wire oe2wait;\n    wire we2dqe;\n    wire we2dq;\n    wire we2waite;\n    wire by2dqe;\n    wire by2dq;\n    wire addr2dq;\n    wire addr2wi;\n    wire saddr2dq;\n    wire variable_sync;\n\n    \n    wire #1 last_clk   = clk_in;\n    wire #1 last_adv_n = adv_n_in;\n    wire #1 last_oe_n  = oe_n;\n    wire #1 last_ce_n  = ce_n;\n    wire #1 last_ce2wi = ce2wi;\n    wire #1 last_we_n  = we_n;\n    wire #1 last_cre   = cre_in;\n    wire   [BY_BITS-1:0] #1 last_by_n = by_n;\n    wire   [DQ_BITS-1:0] #1 last_dq   = dq_in;\n\n    \n    initial begin\n        $timeformat (-9, 3, \" ns\", 1);\n        sync_access <= 1'b0;\n        software_access_rcr_write = 1'b0;\n        async_wr_lockout = 0;\n        ref_collision <= 0;\n        tm_power_up <= 0.0;\n        register_write(BCR, BCR_DEFAULT, 1'b0);\n        register_write(RCR, RCR_DEFAULT, 1'b0);\n        memory_used = 0;\n    end\n\n    always @(ce_n) begin\n        if (!ce_n) begin\n            if (DEBUG[0]) \n                $display(\"===============================================================\");\n            wait_out <= wait_polarity;\n        end else begin\n            if (!rbc && (sync_latency_cntr > 0)) begin\n                memory_write(sync_addr, {BY_BITS{1'b0}}, {DQ_BITS{1'bx}});\n                $display (\"%t ERROR: Data at address 'h%h has been corrupted because CE# was deasserted prior to the first data transfer.\", $realtime, sync_addr);\n            end\n            last_ce <= 1'b1;\n            sync_latency_cntr <= 0;\n            random_delay <= 0;\n            row_count <= 0;\n            rbc <= 0;\n        end\n\n        \n        if (!last_ce_n && ce_n) begin\n            if (!deep_power_down_n) begin \n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Deep Power Down Entry\", $realtime);\n                memory_used = 0;\n            end\n            if (deep_power_down_exit) begin\n                if ($realtime - tm_tdpdx < tDPDX)\n                    $display (\"%t ERROR: tDPDX violation on CE# by %t\", $realtime, tm_tdpdx + tDPDX - $realtime);\n                deep_power_down_exit <= 1'b0;\n                tm_power_up <= $realtime;\n            end\n        end else if (last_ce_n && !ce_n) begin\n            \n            \n            if ((GENERATION > CR10) && !deep_power_down_n) begin\n                register_write(RCR, ref_conf_register | 16'h0010, 1'b0);\n            end\n        end\n    end\n\n\n    \n    always @(adv_n_in or addr) begin\n        if (!adv_n_in) begin\n            async_addr <= addr;\n            tm_async_addr <= $realtime;\n        end\n    end\n    always @(adv_n_in or addr[ADDR_BITS-1:4]) begin\n        if (!adv_n_in) begin\n            tm_upper_addr <= $realtime;\n        end\n    end\n\n    \n    always @(adv_n_in or cre_in) begin\n        if (!adv_n_in) begin\n            async_cre <= cre_in;\n            tm_async_cre <= $realtime;\n        end\n    end\n\n    cellram_pathdelay cellram_pathdelay0 (\n        clk_in,\n        adv_n_in,\n        zz_n_in,\n        ce_n, \n        oe_n, \n        we_n, \n        by_n, \n        async_addr,\n        clk2waite,\n        adv2dqe,\n        adv2dq,\n        adv2wi,\n        zz2pd,\n        ce2dqe, \n        ce2dq,\n        ce2cem,\n        ce2wi,\n        ce2waite,\n        ce2wait,\n        ce2rst,\n        oe2dqe,\n        oe2dq,\n        soe2dq,\n        oe2waite,\n        oe2wait,\n        we2dqe,\n        we2dq,\n        we2waite,\n        by2dqe,\n        by2dq,\n        addr2dq,\n        addr2wi,\n        saddr2dq\n    );\n\n    assign data_out_enable = ce2dqe && oe2dqe && we2dqe && by2dqe;\n    assign variable_sync   = !operating_mode && !initial_latency && sync_access; \n    assign data_out_valid  = we2dq && ((!variable_sync && ce2dq && oe2dq && by2dq && adv2dq && addr2dq) || (variable_sync && soe2dq && saddr2dq));\n    assign wait_out_enable = cr20wait_code ? ce2waite && (oe2waite || clk2waite) && we2waite : ce2waite;\n    assign wait_out_valid  = cr20wait_code ? ce2wait  && (oe2wait  || clk2waite) : ce2wait;\n\n    always @(posedge clk) sync_access <= !ce_n;\n    always @(negedge adv_n or posedge ce_n) begin \n        sync_access <= 1'b0; \n    end\n\n    \n    always @(sync_access or ce2wi or we_n or oe_n or by_n or zz_n_in or async_cre or async_addr) begin\n        if (sync_access) begin\n            software_access_unlock <= 2'b0;\n            async_state = IDLE;\n        end else begin\n\n            \n            if ((async_state == WR) && ((last_ce2wi && !ce2wi) || (!last_we_n && we_n) || |(~last_by_n & by_n))) begin\n                if ($realtime - tm_tcw < tCW) \n                    $display (\"%t ERROR:   tCW violation on CE# by %t\", $realtime, tm_tcw + tCW - $realtime);\n                if ($realtime - tm_adv_n_neg < tVS) \n                    $display (\"%t ERROR:   tVS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tVS - $realtime);\n                if ($realtime - tm_tbw < tBW) \n                    $display (\"%t ERROR:   tBW violation on BY# by %t\", $realtime, tm_tbw + tBW - $realtime);\n                if ($realtime - tm_we_n < tWP)\n                    $display (\"%t ERROR:   tWP violation on WE# by %t\", $realtime, tm_we_n + tWP - $realtime);\n                if ($realtime - tm_async_cre < tAW) \n                    $display (\"%t ERROR:   tAW violation on CRE by %t\", $realtime, tm_async_cre + tAW - $realtime);\n                if ($realtime - tm_async_addr < tAW)\n                    $display (\"%t ERROR:   tAW violation on ADDR by %t\", $realtime, tm_async_addr + tAW - $realtime);\n                if ($realtime - tm_dq_tdw < tDW) \n                    $display (\"%t ERROR:   tDW violation on DQ by %t\", $realtime, tm_dq_tdw + tDW - $realtime);\n                if (($realtime - tm_async_addr < tWC) || ($realtime - tm_tcw < tWC))\n                    $display (\"%t ERROR:   tWC violation on ADDR\", $realtime);\n\n                if ((async_addr == {ADDR_BITS{1'b1}}) && (software_access_unlock == 2)) begin\n                    case (last_dq[1:0])\n                       (2'b00 & RCR_MASK[17:16])  : software_access_which_reg <= RCR;\n                       (2'b10 & DIDR_MASK[17:16]) : software_access_which_reg <= DIDR;\n                       (2'b01 & BCR_MASK[17:16])  : software_access_which_reg <= BCR;\n                       default: $display (\"%t ERROR: Async - Illegal Register Select = %h\", $realtime, last_dq[1:0]);\n                    endcase\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Unlock = %d, Register Select = %h\", $realtime, software_access_unlock, last_dq[1:0]);\n                    software_access_unlock <= software_access_unlock + 1;\n                end else if ((async_addr == {ADDR_BITS{1'b1}}) && (software_access_unlock == 3)) begin\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Write, Data = %h\", $realtime, last_dq[15:0]);\n                    register_write(software_access_which_reg, last_dq[15:0], 1'b1);\n                    software_access_unlock <= 2'b0;\n                end else begin\n                    memory_write(async_addr, last_by_n, last_dq);\n                    software_access_unlock <= 2'b0;\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Write data latched, addr = %h, Mask = %h, Data = %h\", $realtime, async_addr, last_by_n, last_dq);\n                end\n                async_state = IDLE;\n                async_wr_lockout = 1;\n                tavh_check <= #tAVH 1'b0;\n                tow_check <= #tOW 1'b1;\n            end\n\n            \n            if ((async_state == CFG_WR) && ((last_ce2wi && !ce2wi) || (!last_we_n && we_n))) begin\n                if ($realtime - tm_tcw < tCW) \n                    $display (\"%t ERROR:   tCW violation on CE# by %t\", $realtime, tm_tcw + tCW - $realtime);\n                if ($realtime - tm_adv_n_neg < tVS) \n                    $display (\"%t ERROR:   tVS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tVS - $realtime);\n                if ($realtime - tm_tbw < tBW) \n                    $display (\"%t ERROR:   tBW violation on BY# by %t\", $realtime, tm_tbw + tBW - $realtime);\n                if ($realtime - tm_we_n < tWP)\n                    $display (\"%t ERROR:   tWP violation on WE# by %t\", $realtime, tm_we_n + tWP - $realtime);\n                if ($realtime - tm_async_cre < tAW) \n                    $display (\"%t ERROR:   tAW violation on CRE by %t\", $realtime, tm_async_cre + tAW - $realtime);\n                if ($realtime - tm_async_addr < tAW)\n                    $display (\"%t ERROR:   tAW violation on ADDR by %t\", $realtime, tm_async_addr + tAW - $realtime);\n                if ($realtime - tm_dq_tdw < tDW) \n                    $display (\"%t ERROR:   tDW violation on DQ by %t\", $realtime, tm_dq_tdw + tDW - $realtime);\n                if (($realtime - tm_async_addr < tWC) || ($realtime - tm_tcw < tWC))\n                    $display (\"%t ERROR:   tWC violation on ADDR\", $realtime);\n\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Write data latched, Register Select = %h, Data = %h\", $realtime, async_addr>>REG_SEL, async_addr);\n                register_write(async_addr>>REG_SEL, async_addr[15:0], 1'b1);\n                software_access_unlock <= 2'b0;\n                async_state = IDLE;\n                async_wr_lockout = 1;\n                tow_check <= #tOW 1'b1;\n                tavh_check <= #tAVH 1'b0;\n                tm_write_end = $realtime;\n           end\n\n            \n            if (async_state == RD) begin\n                if (last_ce2wi && !ce2wi) begin\n                    if (($realtime - tm_upper_addr < tRC) || ($realtime - tm_tcw < tRC))\n                        $display (\"%t ERROR:   tRC violation on ADDR\", $realtime);\n                    if ($realtime - tm_page_addr3 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr3 + tPC - $realtime);\n                    if ($realtime - tm_page_addr2 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr2 + tPC - $realtime);\n                    if ($realtime - tm_page_addr1 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr1 + tPC - $realtime);\n                    if ($realtime - tm_page_addr0 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr0 + tPC - $realtime);\n                    async_state = IDLE;\n                end else if (!last_oe_n && oe_n) begin\n                    async_state = IDLE;\n                end\n            end\n\n            \n            if (!last_we_n && we_n) begin\n                async_wr_lockout = 0;\n            end\n            \n            if (last_ce2wi && !ce2wi) begin\n                tavh_check <= #tAVH 1'b0;\n            end\n\n            \n            if (!async_wr_lockout && ce2wi && !we_n && !async_cre) begin\n                if (async_state == WR) begin\n                    $display (\"%t ERROR: Async - Illegal or unintended Page Mode Write.\", $realtime);\n                end\n                async_state = WR;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Write\", $realtime);\n            end\n            if (!async_wr_lockout && ce2wi && !we_n && (async_cre || !zz_n_in) && ((GENERATION != CR20) || oe_n)) begin\n                if (async_state == CFG_WR) begin\n                    $display (\"%t ERROR: Async - Page Mode Configuration Register Write is Illegal.\", $realtime);\n                end\n                async_state = CFG_WR;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Write\", $realtime);\n            end\n            if (ce2wi && !oe_n && we_n && !async_cre) begin\n                next_data_out = {DQ_BITS{1'bx}};\n                if (!page_mode && (async_state == RD))\n                    $display (\"%t ERROR: Async - Illegal or unintended Page Mode Read.  Page mode is disabled in BCR\", $realtime);\n                if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                    $display (\"%t ERROR: Async - BY# must be LOW during READ cycles.\", $realtime);\n                if (async_addr == {ADDR_BITS{1'b1}} && (software_access_unlock == 3)) begin\n                    case (software_access_which_reg)\n                        RCR  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                        DIDR : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                        BCR  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                    endcase\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Software Access Read, Data = %h\", $realtime, next_data_out);\n                    software_access_unlock <= 2'b0;\n                end else begin \n                    next_data_out = memory_read(async_addr);\n                    if (DEBUG[0]) \n                        $display (\"%t  INFO: Async - Read, addr = %h, Data = %h\", $realtime, async_addr, next_data_out);\n                    if (async_addr == {ADDR_BITS{1'b1}}) begin\n                        if (software_access_unlock < 2) begin\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO: Async - Software Access Unlock = %d\", $realtime, software_access_unlock);\n                            software_access_unlock <= software_access_unlock + 1;\n                        end\n                    end else begin\n                        software_access_unlock <= 2'b0;\n                    end\n                end\n                data_out <= #tOH {DQ_BITS{1'bx}};\n                if (async_state == RD) begin\n                    data_out <= #tAPA next_data_out;\n                end else begin\n                    data_out <= #tOE next_data_out;\n                end\n                async_state = RD;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n            end\n            if (ce2wi && !oe_n && we_n && async_cre) begin\n                next_data_out = {DQ_BITS{1'bx}};\n                if (async_state == RD)\n                    $display (\"%t ERROR: Async - Page Mode Configuration Register Read is Illegal.\", $realtime);\n                if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                    $display (\"%t ERROR: Async - BY# must be LOW during READ cycles.\", $realtime);\n                if (!CRE_READ)\n                    $display (\"%t ERROR: Async - Access using CRE is WRITE only.\", $realtime);\n                case (async_addr>>REG_SEL)\n                    (RCR  & RCR_MASK[17:16])  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                    (DIDR & DIDR_MASK[17:16]) : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                    (BCR  & BCR_MASK[17:16])  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                    default: $display (\"%t ERROR: Async - Illegal Register Select = %h\", $realtime, async_addr>>REG_SEL);\n                endcase\n                if (DEBUG[0]) \n                    $display (\"%t  INFO: Async - Configuration Register Read, Register Select = %h, Data = %h\", $realtime, async_addr>>REG_SEL, next_data_out);\n                software_access_unlock <= 2'b0;\n                data_out <= #tOH {DQ_BITS{1'bx}};\n                data_out <= #tOE next_data_out;\n                async_state = RD;\n                last_access <= 1'b0;\n                last_ce <= 1'b0;\n                tavh_check <= 1'b1;\n            end\n\n            if (ce2wi) begin\n                next_by_out = 0;\n                for (i=0; i<BY_BITS; i=i+1) begin\n                    next_by_out = next_by_out | ({`DQ_PER_BY{!by_n[i]}}<<(i*`DQ_PER_BY));\n                end\n                by_out <= #tOH next_by_out;\n            end\n        end\n    end\n\n    always @(par_enabled or partial_address_offset or partial_address_size) begin : corrupt_memory\n        integer i;\n        if (par_enabled) begin\n            i = 0;\n            \n            if (partial_address_size > 0) begin\n                for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                    if ((memory_addr[memory_index] > partial_address_offset) && (memory_addr[memory_index] < partial_address_offset + partial_address_size)) begin\n                        memory_addr[i] = memory_addr[memory_index];\n                        memory[i] = memory[memory_index];\n                        i = i + 1;\n                    end\n                end\n            end\n            \n            for (memory_index=i; memory_index<memory_used; memory_index=memory_index+1) begin\n                memory_addr[memory_index] = 'bx;\n                memory[memory_index] = {DQ_BITS{1'bx}};\n            end\n            memory_used = i;\n        end\n    end\n\n    function memory_addr_exists;\n        input [ADDR_BITS-1:0] addr;\n        begin : index\n            memory_addr_exists = 0;\n            for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                if (memory_addr[memory_index] == addr) begin\n                    memory_addr_exists = 1;\n                    disable index;\n                end\n            end\n        end\n    endfunction\n\n    task memory_write;\n        input [ADDR_BITS-1:0] addr;\n        input [BY_BITS-1:0] data_mask;\n        input [DQ_BITS-1:0] data;\n\n        reg [DQ_BITS-1:0] bit_mask;\n        reg [DQ_BITS-1:0] write_data;\n        integer i;\n        begin : memory_write_task\n            if (par_enabled && (partial_address_size == 0)) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is NULL\", $realtime, addr);\n                disable memory_write_task; \n            end else if (par_enabled && ((addr < partial_address_offset) || (addr > partial_address_offset + partial_address_size - 1))) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is %h - %h\", $realtime, addr, partial_address_offset, partial_address_offset + partial_address_size - 1);\n                disable memory_write_task; \n            end else if (addr > (1<<ADDR_BITS) - 1) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Max Address is %h\", $realtime, addr, (1<<ADDR_BITS) - 1);\n                disable memory_write_task; \n            end else if (data_mask == {BY_BITS{1'b1}}) begin\n                disable memory_write_task; \n            end else if (data_mask == {BY_BITS{1'b0}}) begin\n                write_data = {DQ_BITS{1'b1}} & data;\n            end else begin\n                bit_mask = 0;\n                for (i=0; i<BY_BITS; i=i+1) begin\n                    bit_mask = bit_mask | ({`DQ_PER_BY{!data_mask[i]}}<<(i*`DQ_PER_BY));\n                end\n                write_data = (data & bit_mask) | (memory_read(addr) & ~bit_mask);\n            end\n\n            if (memory_used == 1<<MEM_BITS) begin\n                $display (\"%t ERROR: Memory overflow.  Write to Address %h with Data %h will be lost.\\nYou must increase the MEM_BITS parameter.\", $realtime, addr, data);\n                $stop(0);\n            end else begin\n                if (!memory_addr_exists(addr)) begin\n                    memory_used = memory_used + 1;\n                end\n                memory_addr[memory_index] = addr;\n                memory[memory_index] = write_data;\n            end\n        end\n    endtask\n\n    function [DQ_BITS-1:0] memory_read;\n        input [ADDR_BITS-1:0] addr;\n        begin\n            if (partial_address_size == 0) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is NULL\", $realtime, addr);\n                memory_read = {DQ_BITS{1'bx}};\n            end else if ((addr < partial_address_offset) || (addr > partial_address_offset + partial_address_size - 1)) begin\n                $display (\"%t  WARN: Illegal Address = %h.  Address range is %h - %h\", $realtime, addr, partial_address_offset, partial_address_offset + partial_address_size - 1);\n                memory_read = {DQ_BITS{1'bx}};\n            end else begin\n                if (memory_addr_exists(addr)) begin\n                    memory_read = memory[memory_index];\n                end else begin\n                    memory_read = {DQ_BITS{1'bx}};\n                end\n            end\n        end\n    endfunction\n\n    task register_write;\n        input  [1:0] select;\n        input [15:0] opcode;\n        input        report;\n        begin\n\n            case(select)\n                BCR: begin\n                    burst_length        = opcode[2:0];\n                    burst_wrap_n        = opcode[3];\n                    drive_strength      = opcode[5:4];\n                    clock_configuration = opcode[6];\n                    wait_configuration  = opcode[8];   \n                    cr20wait            = opcode[9];\n                    cr20wait_code       = (cr20wait == CR20WAIT_POLARITY);\n                    wait_polarity       = opcode[10];\n                    latency_counter     = (opcode[13:11] == 3'b000) ? 4'd8 : opcode[13:11];\n                    initial_latency     = opcode[14];\n                    if (!operating_mode && opcode[15]) begin \n                        Sync2AsyncConfig = latency_counter;\n                    end\n                    operating_mode      = opcode[15]; \n                end\n                RCR: begin\n                    partial_array_refresh = opcode[2:0];\n                    if (software_access_unlock) begin\n                        if ((GENERATION == CR10) && (deep_power_down_n ^ opcode[4]))\n                            $display (\"%t ERROR: Deep Power Down cannot be enabled or disabled using the software access sequence\", $realtime);\n                    end\n                    \n                    if (!deep_power_down_n && opcode[4]) begin\n                        if (GENERATION == CR10) begin\n                            tm_power_up <= $realtime;\n                        end else begin\n                            if ($realtime - tm_tdpd < tDPD)\n                                $display (\"%t ERROR:  tDPD violation on CE# by %t\", $realtime, tm_tdpd + tDPD - $realtime);\n                            deep_power_down_exit <= 1'b1;\n                            tm_tdpdx <= $realtime;\n                        end\n                        if (DEBUG[0]) \n                            $display (\"%t  INFO: Deep Power Down Exit\", $realtime);\n                    end\n                    deep_power_down_n     = opcode[4];\n                    case_temp             = opcode[6:5];\n                    page_mode             = opcode[7];\n                end\n            endcase\n\n            if (report) begin\n                case(select)\n                    (BCR & BCR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = BCR\", $realtime);\n                        if ((~BCR_MASK & opcode) !== (~BCR_MASK & BCR_DEFAULT))\n                            $display (\"%t ERROR: Reserved bits in BCR cannot be changed from their default value.\", $realtime);\n\n                        if (&BCR_MASK[2:0]) begin\n                            casex ({(GENERATION > CR10), burst_length})\n                                4'bx001:$display (\"%t  INFO: Burst Length =  4 words\", $realtime);\n                                4'bx010:$display (\"%t  INFO: Burst Length =  8 words\", $realtime);\n                                4'bx011:$display (\"%t  INFO: Burst Length = 16 words\", $realtime);\n                                4'b1100:$display (\"%t  INFO: Burst Length = 32 words\", $realtime);\n                                4'bx111:$display (\"%t  INFO: Burst Length = continuous\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Burst Length = %h\", $realtime, burst_length);\n                            endcase\n                        end\n\n                        if (BCR_MASK[3]) begin\n                            case (burst_wrap_n)\n                                1'b0   :$display (\"%t  INFO: Burst Wrap = Burst wraps within the burst length\", $realtime);\n                                1'b1   :$display (\"%t  INFO: Burst Wrap = Burst no wrap\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Burst Wrap = %h\", $realtime, burst_wrap_n);\n                            endcase\n                        end\n\n                        if (|BCR_MASK[5:4]) begin\n                            case (drive_strength & BCR_MASK[5:4])\n                                2'b00  :$display (\"%t  INFO: Drive Strength = Full\", $realtime);  \n                                2'b01  :$display (\"%t  INFO: Drive Strength = 1/2\", $realtime);  \n                                2'b10  :$display (\"%t  INFO: Drive Strength = 1/4\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Drive Strength = %h\", $realtime, drive_strength);\n                            endcase\n                        end\n\n                        if (BCR_MASK[6]) begin\n                            case (clock_configuration)\n                                1'b1   :$display (\"%t  INFO: Clock Configuration = Rising edge\", $realtime); \n                                default:$display (\"%t ERROR: Illegal Clock Configuration = %h\", $realtime, clock_configuration);\n                            endcase\n                        end\n\n                        if (BCR_MASK[8]) begin\n                            case (wait_configuration)\n                                1'b0   :$display (\"%t  INFO: WAIT Configuration = Asserted during delay\", $realtime); \n                                1'b1   :$display (\"%t  INFO: WAIT Configuration = Asserted one data cycle before delay\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal WAIT Configuration = %h\", $realtime, wait_configuration);\n                            endcase\n                        end\n\n                        if (BCR_MASK[9]) begin\n                            case (cr20wait_code)\n                                1'b0   :$display (\"%t  INFO: CR1.5 WAIT Behavior\", $realtime); \n                                1'b1   :$display (\"%t  INFO: CR2.0 WAIT Behavior\", $realtime);\n                                default:$display (\"%t ERROR: Illegal CR2.0 WAIT Behavior = %h\", $realtime, cr20wait_code);\n                            endcase\n                        end\n\n                        if (BCR_MASK[10]) begin\n                            case (wait_polarity)\n                                1'b0   :$display (\"%t  INFO: Wait Polarity = Active LOW\", $realtime); \n                                1'b1   :$display (\"%t  INFO: Wait Polarity = Active HIGH\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Wait Polarity = %h\", $realtime, wait_polarity);\n                            endcase\n                        end\n\n                        if (&BCR_MASK[13:11]) begin\n                            casex ({initial_latency, latency_counter})\n                                5'hx2  :$display (\"%t  INFO: Latency Counter = Code 2\", $realtime);\n                                5'hx3  :$display (\"%t  INFO: Latency Counter = Code 3\", $realtime);   \n                                5'h14  :$display (\"%t  INFO: Latency Counter = Code 4\", $realtime);\n                                5'h15  :$display (\"%t  INFO: Latency Counter = Code 5\", $realtime);\n                                5'h16  :$display (\"%t  INFO: Latency Counter = Code 6\", $realtime);\n                                5'h18  :$display (\"%t  INFO: Latency Counter = Code 8\", $realtime);\n                                default:$display (\"%t ERROR: Illegal Latency Counter = %h\", $realtime, latency_counter);\n                            endcase\n                        end\n\n                        if (BCR_MASK[14]) begin\n                            case (initial_latency)\n                                1'b0   :$display (\"%t  INFO: Initial Access Latency = Variable\", $realtime);  \n                                1'b1   :$display (\"%t  INFO: Initial Access Latency = Fixed\", $realtime);\n                                default:$display (\"%t ERROR: Illegal Initial Access Latency = %h\", $realtime, initial_latency);\n                            endcase\n                        end\n\n                        if (BCR_MASK[15]) begin\n                            case (operating_mode)\n                                1'b0   :$display (\"%t  INFO: Operating Mode = Synchronous burst access mode\", $realtime);\n                                1'b1   :$display (\"%t  INFO: Operating Mode = Asynchronous access mode\", $realtime);  \n                                default:$display (\"%t ERROR: Illegal Operating Mode = %h\", $realtime, operating_mode);\n                            endcase\n                        end\n                    end\n\n                    (RCR & RCR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = RCR\", $realtime);\n                        if ((~RCR_MASK & opcode) !== (~RCR_MASK & RCR_DEFAULT))\n                            $display (\"%t ERROR: Reserved bits in RCR cannot be changed from their default value.\", $realtime);\n\n                        if (RCR_MASK[2:0]) begin\n                            case (partial_array_refresh)\n                               3'b000 : begin $display (\"%t  INFO: Partial Array Refresh =       Full array\", $realtime); partial_address_size = 1<<(ADDR_BITS-0); partial_address_offset = 0; end\n                               3'b001 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/2 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-1); partial_address_offset = 0; end\n                               3'b010 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/4 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-2); partial_address_offset = 0; end\n                               3'b011 : begin $display (\"%t  INFO: Partial Array Refresh = Bottom 1/8 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-3); partial_address_offset = 0; end\n                               3'b100 : begin $display (\"%t  INFO: Partial Array Refresh =             None\", $realtime); partial_address_size = 0;                partial_address_offset = 0; end\n                               3'b101 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/2 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-1); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               3'b110 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/4 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-2); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               3'b111 : begin $display (\"%t  INFO: Partial Array Refresh =    Top 1/8 array\", $realtime); partial_address_size = 1<<(ADDR_BITS-3); partial_address_offset = (1<<ADDR_BITS) - partial_address_size; end\n                               default: begin $display (\"%t ERROR: Illegal Partial Array Refresh = %h\", $realtime, partial_array_refresh); end\n                            endcase\n                        end\n\n                        if (RCR_MASK[4]) begin\n                            case (deep_power_down_n)\n                               1'b0   : $display (\"%t  INFO: Deep Power Down = DPD Enable\", $realtime);\n                               1'b1   : $display (\"%t  INFO: Deep Power Down = DPD Disable\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Deep Power Down = %h\", $realtime, deep_power_down_n);\n                            endcase\n                        end\n\n                        if (&RCR_MASK[6:5]) begin\n                            case (case_temp)\n                               2'b00  : $display (\"%t  INFO: Maximum Case Temp = 70 degrees C\", $realtime);\n                               2'b01  : $display (\"%t  INFO: Maximum Case Temp = 45 degrees C\", $realtime);\n                               2'b10  : $display (\"%t  INFO: Maximum Case Temp = 15 degrees C\", $realtime);\n                               2'b11  : $display (\"%t  INFO: Maximum Case Temp = 85 degrees C\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Maximum Case Temp = %h\", $realtime, case_temp);\n                            endcase\n                        end\n\n                        if (RCR_MASK[7]) begin\n                            case (page_mode)\n                               1'b0   : $display (\"%t  INFO: Page Mode = Page Mode Disabled\", $realtime);\n                               1'b1   : $display (\"%t  INFO: Page Mode = Page Mode Enable\", $realtime);\n                               default: $display (\"%t ERROR: Illegal Page Mode = %h\", $realtime, page_mode);\n                            endcase\n                        end\n                    end\n                    (DIDR & DIDR_MASK[17:16]): begin\n                        $display (\"%t  INFO: Register Select = DIDR\", $realtime);\n                        $display (\"%t ERROR: DIDR Configuration Register is read-only\", $realtime);\n                    end\n                    default: begin\n                        $display (\"%t ERROR: Illegal Register Select = %d\", $realtime, select);\n                    end\n                endcase\n            end\n        end\n    endtask\n\n    \n    always @(posedge clk_in) begin\n        if (!operating_mode || Sync2AsyncConfig) begin \n\n            if (!ce_n) begin\n                if (!adv_n_in) begin \n                    sync_addr = addr;\n                    \n                    sync_burst_length_override = (dq_in[DQ_BITS-2] && (GENERATION == CR20));\n                    sync_cre = cre_in;\n                    sync_we_n = we_n;\n\n                    if (!rbc && (sync_latency_cntr > 0)) \n                        $display (\"%t ERROR: Illegal burst interrupt.  Burst interrupt is illegal until after the first data word has been transferred.\", $realtime);\n                    last_access <= 1'b1;\n                    last_ce <= 1'b0;\n                    random_delay <= 0;\n                    row_count <= 0;\n                    rbc <= 0;\n\n                    if (!sync_we_n) begin \n                        if (DEBUG[0]) begin\n                            if (sync_cre) begin\n                                $display (\"%t  INFO:  Sync - Configuration Register Write\", $realtime);\n                            end else begin\n                                $display (\"%t  INFO:  Sync - Write\", $realtime);\n                            end\n                        end\n                    end else begin \n                        if (DEBUG[0]) begin\n                            if (sync_cre) begin\n                                $display (\"%t  INFO:  Sync - Configuration Register Read\", $realtime);\n                            end else begin\n                                $display (\"%t  INFO:  Sync - Read\", $realtime);\n                            end\n                        end\n                        \n                        if (!initial_latency && ($time - ref_collision >= tCEM)) begin\n                            ref_collision <= $time;\n                            random_delay = ($random % latency_counter);\n                            if (DEBUG[0] && (random_delay > 0)) \n                                $display (\"%t  INFO:  Sync - Read refresh collision of %d clocks has occurred.\", $realtime, random_delay);\n                        end\n                    end\n                    sync_latency_cntr = !sync_we_n + random_delay + latency_counter + 1;\n                    sync_wait = wait_polarity;\n                    sync_wait_q = wait_polarity;\n                end\n\n                if (!sync_we_n) begin\n                    if ((!sync_cre) && (oe_n !== 1))\n                        $display (\"%t ERROR: Sync - OE# must be driven high during sync writes\", $realtime);\n                end else begin\n                    if ((GENERATION > CR10) && (by_n !== {BY_BITS{1'b0}}))\n                        $display (\"%t ERROR: Sync - BY# must be LOW during READ cycles.\", $realtime);\n                end\n\n                if (row_count > 0) begin\n                    if (row_count == 1) begin\n                        $display (\"%t ERROR: CE# must go HIGH before the third CLK after the WAIT period asserts with BCR[8] = 0, or before the fourth CLK after WAIT asserts with BCR[8] = 1\", $realtime);\n                    end else begin\n                        row_count = row_count - 1;\n                    end\n                end else if (rbc) begin\n                    if (sync_latency_cntr == 2*latency_counter + 2 + !sync_we_n) begin\n                        rbc_by = by_n;\n                        rbc_dq = dq_in;\n                    end else if (sync_latency_cntr == 2) begin\n                        if (!sync_we_n) begin\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Write, addr = %h, Mask = %h, Data = %h - Row Boundary Crossing\", $realtime, sync_addr, rbc_by, rbc_dq);\n                            memory_write(sync_addr, rbc_by, rbc_dq);\n                            sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                        end\n                        rbc <= 0;\n                    end\n                end else if (sync_latency_cntr < 2) begin \n                    next_by_out = 0;\n                    for (i=0; i<BY_BITS; i=i+1) begin\n                        next_by_out = next_by_out | ({`DQ_PER_BY{!by_n[i]}}<<(i*`DQ_PER_BY));\n                    end\n                    by_out   <= #tKOH next_by_out;\n                    data_out <= #tKOH {DQ_BITS{1'bx}};\n\n                    if (!sync_we_n) begin \n                        if (sync_cre) begin \n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Configuration Register Write data latched, Register Select = %h, Data = %h\", $realtime, sync_addr>>REG_SEL, sync_addr);\n                            register_write(sync_addr>>REG_SEL, sync_addr[15:0], 1'b1);\n                        end else begin \n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Write, addr = %h, Mask = %h, Data = %h\", $realtime, sync_addr, by_n, dq_in);\n                            memory_write(sync_addr, by_n, dq_in);\n                        end\n                    end else begin \n                        if (sync_cre) begin \n                            case (sync_addr>>REG_SEL)\n                                (RCR  & RCR_MASK[17:16])  : next_data_out = ref_conf_register | (RCR<<REG_SEL);\n                                (DIDR & DIDR_MASK[17:16]) : next_data_out = didr_conf_register | (DIDR<<REG_SEL);\n                                (BCR  & BCR_MASK[17:16])  : next_data_out = bus_conf_register | (BCR<<REG_SEL);\n                                default: $display (\"%t ERROR:  Sync - Illegal Register Select = %h\", $realtime, sync_addr>>REG_SEL);\n                            endcase\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Configuration Register Read, Register Select = %h, Data = %h\", $realtime, sync_addr>>REG_SEL, next_data_out);\n                            data_out <= #tACLK next_data_out;\n                        end else begin \n                            next_data_out = memory_read(sync_addr);\n                            if (DEBUG[0]) \n                                $display (\"%t  INFO:  Sync - Read, addr = %h, Data = %h\", $realtime, sync_addr, next_data_out);\n                            data_out <= #tACLK next_data_out;\n                        end\n                    end\n\n                    \n                    if (!sync_cre) begin\n                        \n                        \n                        if (!burst_wrap_n && (sync_we_n || (GENERATION > CR10))) begin \n                            case (burst_length | {3{sync_burst_length_override}}) \n                                3'b001 : sync_addr[         1:0] = sync_addr[         1:0] + 1;\n                                3'b010 : sync_addr[         2:0] = sync_addr[         2:0] + 1;\n                                3'b011 : sync_addr[         3:0] = sync_addr[         3:0] + 1;\n                                3'b100 : sync_addr[         4:0] = sync_addr[         4:0] + 1;\n                                3'b111 : sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                            endcase\n                            $display (\"%t  INFO:  Sync - increment addr = %h\", $realtime, sync_addr);\n                        end else begin \n                            if (sync_addr[COL_BITS-1:0] == {COL_BITS{1'b1}}) begin\n                                sync_wait = wait_polarity;\n                                \n                                if (!initial_latency && (GENERATION == CR10)) begin\n                                    rbc <= 1;\n                                    sync_latency_cntr = 2*latency_counter + 3 + !sync_we_n;\n                                end else begin\n                                    row_count = 3 + (sync_we_n | !cr20wait_code);\n                                end\n                            end\n                            sync_addr[COL_BITS-1:0] = sync_addr[COL_BITS-1:0] + 1;\n                        end\n                    end\n                end\n\n                if (sync_latency_cntr == (!sync_we_n + 2)) begin\n                    sync_wait = !wait_polarity;\n                \n                end else if (cr20wait_code && !sync_we_n && burst_wrap_n && (sync_addr[COL_BITS-1:0] == {COL_BITS{1'b1}})) begin\n                    sync_wait = wait_polarity;\n                end\n            end\n        end\n\n        if (sync_latency_cntr > 0) begin\n            sync_latency_cntr <= sync_latency_cntr - 1;\n        end\n\n        if (Sync2AsyncConfig > 0) begin\n            Sync2AsyncConfig <= Sync2AsyncConfig - 1;\n        end\n\n        if (wait_configuration) begin \n            wait_out <= #tKHTL sync_wait;\n        end else begin\n            wait_out <= #tKHTL sync_wait_q;\n        end\n\n        sync_wait_q <= sync_wait;\n    end\n\n\n    \n    always @(posedge clk_in) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_ce_n < tCSP)\n                $display (\"%t ERROR:  tCSP violation on CE# by %t\", $realtime, tm_ce_n + tCSP - $realtime);\n            if (!ce_n) begin\n                if ($realtime - tm_adv_n < tSP)\n                    $display (\"%t ERROR:   tSP violation on ADV# by %t\", $realtime, tm_adv_n + tSP - $realtime);\n                if (adv_n_in) begin\n                    if ($realtime - tm_by_n < tSP)\n                        $display (\"%t ERROR:   tSP violation on BY# by %t\", $realtime, tm_by_n + tSP - $realtime);\n                end else begin\n                    if ($realtime - tm_we_n < tSP)\n                        $display (\"%t ERROR:   tSP violation on WE# by %t\", $realtime, tm_we_n + tSP - $realtime);\n                    if ($realtime - tm_cre < tSP)\n                        $display (\"%t ERROR:   tSP violation on CRE by %t\", $realtime, tm_cre + tSP - $realtime);\n                    if ($realtime - tm_addr < tSP) \n                        $display (\"%t ERROR:   tSP violation on ADDR by %t\", $realtime, tm_addr + tSP - $realtime);\n                end\n\n                tm_clk_period = min_clk_period(initial_latency, latency_counter[2:0]);\n                if (tm_clk_period == 0.0)\n                    $display (\"%t ERROR: Illegal latency counter = %h\", $realtime, latency_counter);\n                if ($realtime - tm_clk_pos < tm_clk_period)\n                    $display (\"%t ERROR: Clock Period must be >= %f while Latency Counter = %h.  Actual Clock Period = %f\", $realtime, tm_clk_period, latency_counter, $realtime - tm_clk_pos);\n\n                if ($realtime - tm_clk_pos < tCLK)\n                    $display (\"%t ERROR:  tCLK minimum violation on CLK by %t\", $realtime, tm_clk_pos + tCLK - $realtime);\n                if ($realtime - tm_clk_neg < tKP)\n                    $display (\"%t ERROR:   tKP minimum violation on CLK by %t\", $realtime, tm_clk_neg + tKP - $realtime);\n            end\n        end\n        tm_clk_pos = $realtime - 0.0001;  \n    end\n\n    always @(negedge clk_in) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_clk_pos < tKP)\n                $display (\"%t ERROR:   tKP minimum violation on CLK by %t\", $realtime, tm_clk_pos + tKP - $realtime);\n        end\n        tm_clk_neg = $realtime - 0.0001;  \n    end\n\n    always @(ce_n) begin\n        if ($realtime > tCLK) begin\n            if ($realtime - tm_clk_pos < tHD) \n                $display (\"%t ERROR:   tHD violation on CE# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n        end\n        if (!ce_n) begin\n            if (last_access) begin\n                if ($realtime - tm_ce_n < tCBPH)\n                    $display (\"%t ERROR: tCBPH violation on CE# by %t\", $realtime, tm_ce_n + tCBPH - $realtime);\n            end else begin\n                if ($realtime - tm_ce_n < tCPH)\n                    $display (\"%t ERROR:  tCPH violation on CE# by %t\", $realtime, tm_ce_n + tCPH - $realtime);\n                if ($realtime - tm_write_end < tWR)\n                    $display (\"%t ERROR:   tWR violation on CE# by %t\", $realtime, tm_write_end + tWR - $realtime);\n            end\n            if ($realtime - tm_power_up < tPU)\n                $display (\"%t  WARN:   tPU violation on CE# by %t\", $realtime, tm_power_up + tPU - $realtime);\n        end\n        tm_ce_n = $realtime;\n        tm_tcw  <= $realtime;\n        tm_tdpd <= $realtime;\n    end\n\n    always @(adv_n_in) begin\n        if (!ce_n) begin\n            if ($realtime - tm_clk_pos < tHD) \n                $display (\"%t ERROR:   tHD violation on ADV# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            if (adv_n_in) begin\n                if (!sync_access) begin\n                    if ($realtime - tm_ce_n < tCVS)\n                        $display (\"%t ERROR:  tCVS violation on CE# by %t\", $realtime, tm_ce_n + tCVS - $realtime);\n                    if ($realtime - tm_adv_n < tVP)\n                        $display (\"%t ERROR:   tVP violation on ADV# by %t\", $realtime, tm_adv_n + tVP - $realtime);\n                    if ($realtime - tm_cre < tAVS)\n                        $display (\"%t ERROR:  tAVS violation on CRE by %t\", $realtime, tm_cre + tAVS - $realtime);\n                    if ($realtime - tm_addr < tAVS)\n                        $display (\"%t ERROR:  tAVS violation on ADDR by %t\", $realtime, tm_addr + tAVS - $realtime);\n                end\n                if (!sync_access | initial_latency) begin\n                    if ($realtime - tm_cre < tAVH)\n                        $display (\"%t ERROR:  tAVH violation on CRE by %t\", $realtime, tm_cre + tAVH - $realtime);\n                    if ($realtime - tm_addr < tAVH)\n                        $display (\"%t ERROR:  tAVH violation on ADDR by %t\", $realtime, tm_addr + tAVH - $realtime);\n                end\n            end else begin\n                if ($realtime - tm_adv_n < tVPH)\n                    $display (\"%t ERROR:   tVPH violation on ADV# by %t\", $realtime, tm_adv_n + tVPH - $realtime);\n            end\n        end\n        if (adv_n_in) begin\n            tm_adv_n_pos = $realtime;\n        end else begin\n            tm_adv_n_neg <= $realtime;\n        end\n        tm_adv_n = $realtime;\n    end\n\n    always @(we_n) begin\n        if (!ce_n) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on WE# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access) begin\n                if (!we_n) begin\n                    if ($realtime - tm_we_n < tWPH)\n                        $display (\"%t ERROR:   tWPH violation on WE# by %t\", $realtime, tm_we_n + tWPH - $realtime);\n                end\n            end\n        end\n        tm_we_n <= $realtime;\n    end\n\n    \n    always @(we_n or ce2wi) begin\n        if (!sync_access && !we_n && ce2wi) begin\n            if ($realtime - tm_adv_n_neg < tAS)\n                $display (\"%t ERROR:   tAS violation on ADV# by %t\", $realtime, tm_adv_n_neg + tAS - $realtime);\n            if ($realtime - tm_async_addr < tAS)\n                $display (\"%t ERROR:   tAS violation on ADDR by %t\", $realtime, tm_async_addr + tAS - $realtime);\n        end\n    end\n\n    always @(by_n) begin\n        if (!ce_n) begin\n            if (adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on BY# by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n        end\n        tm_by_n = $realtime;\n        tm_tbw <= $realtime;\n    end\n\n    always @(cre_in) begin\n        if (!ce_n | tavh_check) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on CRE by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access | initial_latency) begin\n                if ($realtime - tm_adv_n_pos < tAVH) \n                    $display (\"%t ERROR:  tAVH violation on CRE by %t\", $realtime, tm_adv_n_pos + tAVH - $realtime);\n            end\n        end\n        tm_cre = $realtime;\n    end\n\n    always @(addr) begin\n        if (!ce_n | tavh_check) begin\n            if (!adv_n_in) begin\n                if ($realtime - tm_clk_pos < tHD) \n                    $display (\"%t ERROR:   tHD violation on ADDR by %t\", $realtime, tm_clk_pos + tHD - $realtime);\n            end\n            if (!sync_access | initial_latency) begin\n                if ($realtime - tm_adv_n_pos < tAVH) \n                    $display (\"%t ERROR:  tAVH violation on ADDR by %t\", $realtime, tm_adv_n_pos + tAVH - $realtime);\n            end\n        end\n        tm_addr = $realtime;\n    end\n\n    task addr_timing_check;\n    input i;\n    integer i;\n    begin\n        if (!ce_n && !adv_n_in && !oe_n && we_n && (by_n == {BY_BITS{1'b0}})) begin\n            case (i)\n                3: begin if ($realtime - tm_page_addr3 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr3 + tPC - $realtime); tm_page_addr3 <= $realtime; end\n                2: begin if ($realtime - tm_page_addr2 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr2 + tPC - $realtime); tm_page_addr2 <= $realtime; end\n                1: begin if ($realtime - tm_page_addr1 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr1 + tPC - $realtime); tm_page_addr1 <= $realtime; end\n                0: begin if ($realtime - tm_page_addr0 < tPC) $display (\"%t ERROR:   tPC violation on ADDR bit %d by %t\", $realtime, i, tm_page_addr0 + tPC - $realtime); tm_page_addr0 <= $realtime; end\n            endcase\n        end\n    end\n    endtask\n\n    always @(addr[3]) addr_timing_check(3);\n    always @(addr[2]) addr_timing_check(2);\n    always @(addr[1]) addr_timing_check(1);\n    always @(addr[0]) addr_timing_check(0);\n\n    always @(dq_in) begin\n        if (!sync_access) begin\n            if ($realtime - tm_write_end < tDH) \n                $display (\"%t ERROR:  tDH violation on DQ by %t\", $realtime, tm_write_end + tDH - $realtime);\n        end\n        tm_dq_tdw <= $realtime;\n    end\n\n    \n    always @(posedge tow_check) begin\n        if (!oe_n) begin\n            if (dq_in !== {DQ_BITS{1'bz}})\n                $display (\"%t ERROR:  tOW violation on DQ\", $realtime);\n        end\n        tow_check <= 1'b0;\n    end\n\n\n    \n    always @(posedge ce2cem) begin\n        if (deep_power_down_exit !== 1'b1)\n            $display (\"%t ERROR:  tCEM violation on CE#\", $realtime);\n    end\n\nendmodule\n\nmodule cellram_pathdelay (\n    clk,\n    adv_n,\n    zz_n,\n    ce_n,\n    oe_n,\n    we_n,\n    by_n,\n    addr, \n    clk2waite,\n    adv2dqe,\n    adv2dq,\n    adv2wi,\n    zz2pd,\n    ce2dqe,\n    ce2dq,\n    ce2cem,\n    ce2wi,\n    ce2waite,\n    ce2wait,\n    ce2rst,\n    oe2dqe,\n    oe2dq,\n    soe2dq,\n    oe2waite,\n    oe2wait,\n    we2dqe,\n    we2dq,\n    we2waite,\n    by2dqe, \n    by2dq,\n    addr2dq,\n    addr2wi,\n    saddr2dq\n);\n    `include \"cellram_parameters.vh\"\n\n    input clk;\n    input adv_n;\n    input zz_n;\n    input ce_n;\n    input oe_n;\n    input we_n;\n    input [BY_BITS-1:0] by_n;\n    input [ADDR_BITS-1:0] addr;\n    output clk2waite;\n    output adv2dqe;\n    output adv2dq;\n    output adv2wi;\n    output zz2pd;\n    output ce2dqe;\n    output ce2dq;\n    output ce2cem;\n    output ce2wi;\n    output ce2waite;\n    output ce2wait;\n    output ce2rst;\n    output oe2dqe;\n    output oe2dq;\n    output soe2dq;\n    output oe2waite;\n    output oe2wait;\n    output we2dqe;\n    output we2waite;\n    output we2dq;\n    output by2dqe;\n    output by2dq;\n    output addr2dq;\n    output addr2wi;\n    output saddr2dq;\n\n    reg adv2dqr, addr2dqr, addr2wir, saddr2dqr, clk2waiter;\n\n    always @(negedge adv_n) begin\n        if (!adv_n) begin\n            adv2dqr <= 1'b0;\n            adv2dqr <= #(1) 1'b1;\n        end\n    end\n\n    always @(addr[ADDR_BITS-1:4]) begin\n        addr2dqr <= 1'b0;\n        addr2dqr <= #(1) 1'b1;\n    end\n\n    always @(addr) begin\n        addr2wir <= 1'b0;\n        addr2wir <= #(1) 1'b1;\n    end\n\n    always @(posedge clk) begin \n        if (!adv_n) begin\n            saddr2dqr <= 1'b0;\n            saddr2dqr <= #(1) 1'b1;\n        end\n    end\n\n    always @(posedge ce_n or posedge clk) begin\n        clk2waiter <= !ce_n;\n    end\n\n    assign clk2waite = clk2waiter;\n    assign adv2dqe   = adv_n;\n    assign adv2dq    = adv2dqr;\n    assign adv2wi    = adv2dqr;\n    assign zz2pd     = !zz_n;\n    assign ce2dqe    = !ce_n;\n    assign ce2dq     = !ce_n;\n    assign ce2cem    = !ce_n;\n    assign ce2wi     = !ce_n;\n    assign ce2waite  = !ce_n;\n    assign ce2wait   = !ce_n;\n    assign ce2rst    = ce_n;\n    assign oe2dqe    = !oe_n;\n    assign oe2dq     = !oe_n;\n    assign soe2dq    = !oe_n;\n    assign oe2waite  = !oe_n;\n    assign oe2wait   = !oe_n;\n    assign we2dqe    = we_n;\n    assign we2dq     = we_n;\n    assign we2waite  = we_n;\n    \n    \n    assign by2dqe    = !(&by_n);\n    assign by2dq     = !(&by_n);\n    assign addr2dq   = addr2dqr;\n    assign addr2wi   = addr2wir;\n    assign saddr2dq  = saddr2dqr;\n\n    specify\n        specparam PATHPULSE$ = 0; \n\n        (clk   =>clk2waite) = (   tKHTL,  tHZ);\n        (adv_n =>  adv2dqe) = (    tALZ, tAHZ);\n        (negedge adv_n => (adv2dq +: adv_n)) = (tAADV,  tOH);\n        (negedge adv_n => (adv2wi +: adv_n)) = (tWI,  0);\n        (zz_n  =>    zz2pd) = (    tDPD,    0);\n        (ce_n  =>   ce2dqe) = (     tLZ,  tHZ);\n        (ce_n  =>    ce2dq) = (     tCO,    0);\n        (ce_n  =>   ce2cem) = (    tCEM,    0);\n        (ce_n  =>    ce2wi) = (     tWI,    0);\n        (ce_n  => ce2waite) = (tCEW_MIN,  tHZ);\n        (ce_n  =>  ce2wait) = (tCEW_MAX,    0);\n        (ce_n  =>   ce2rst) = (      15,    0);\n        (oe_n  =>   oe2dqe) = (    tOLZ, tOHZ);\n        (oe_n  =>    oe2dq) = (     tOE,    0);\n        (oe_n  =>   soe2dq) = (    tBOE,    0);\n        (oe_n  => oe2waite) = (tOEW_MIN,  tHZ);\n        (oe_n  =>  oe2wait) = (tOEW_MAX,    0);\n        (we_n  =>   we2dqe) = (       0, tWHZ);\n        (we_n  =>    we2dq) = (       0,    0);\n        (we_n  => we2waite) = (       0,    0);\n        (by_n  *>   by2dqe) = (    tBLZ, tBHZ);\n        (by_n  *>    by2dq) = (     tBA,    0);\n        (addr  *>  addr2dq) = (     tAA,  tOH);\n        (addr  *>  addr2wi) = (     tWI,    0);\n        (posedge clk   => (saddr2dq +: clk)) = (tABA,  tKOH);\n    endspecify\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: cellram. Module specification: The cellram module simulates a Cellular RAM (PSRAM) device, implementing synchronous and asynchronous access modes with configurable burst operations and timing parameters. It has input ports for clock (clk), control signals (adv_n, cre, ce_n, oe_n, we_n), byte enables (lb_n, ub_n), address (addr), and data (dq), with output ports for wait signal (o_wait) and bidirectional data (dq). Internal signals manage memory operations, configuration registers, state machines, and timing checks. The module consists of several blocks: memory array management, configuration register handling, asynchronous and synchronous access control, burst operations, refresh management, and extensive timing checks. It includes features such as deep power-down mode, partial array refresh, and software-controlled register access. The module uses include files for parameters"
                }
            ]
        }
    ]
}