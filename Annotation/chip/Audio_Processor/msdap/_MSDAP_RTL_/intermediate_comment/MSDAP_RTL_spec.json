{
    "spec": "Module name: shift_acc. Module specification: The shift_acc module implements a 40-bit shift accumulator with load, clear, and shift functionalities. It has input ports for shift_enable (controls shifting), load (enables loading new data), clear (resets accumulator), sclk (clock input), and blk_in[39:0] (40-bit input data). The output port is blk_out[39:0] (40-bit output data). Internally, it uses a 40-bit register shift_acc_reg to store and manipulate data. The module's main block is a synchronous always block triggered on the positive edge of sclk. This block handles clearing the accumulator, loading new data with optional shifting, and maintaining the current value based on input signals. The module can perform right shifts when enabled, making it suitable for digital signal processing applications that require accumulation and shifting operations.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nBased on the given code, I'll answer your questions for each module:\n\n1. Module name: shift_acc\nExplanation: This module implements a shift accumulator. It can load, clear, and shift data based on input signals. The accumulator register is 40 bits wide and can perform right shifts when enabled.\n\n2. Module name: rj_memory\nExplanation: This module implements a 16x16-bit memory with write and read functionality. It stores and retrieves 16-bit data based on the provided address and control signals.\n\n3. Module name: PISO\nExplanation: This module implements a Parallel-In Serial-Out shift register. It takes a 40-bit parallel input and outputs it serially based on control signals. It also provides an output ready signal.\n\n4. Module name: MSDAP_controller\nExplanation: This is the main controller module for the MSDAP (likely Multi-Stage Digital Audio Processor). It manages various stages of operation including startup, reading data, computing, and sleep modes. It controls memory accesses and coordinates different parts of the system.\n\n5. Module name: MSDAP\nExplanation: This is the top-level module that integrates all other components. It implements a digital audio processing system with left and right channel inputs and outputs, coordinating data flow between various sub-modules.\n\n6. Module name: data_memory\nExplanation: This module implements a 256x16-bit memory for storing input data. It includes a zero detection feature and provides read/write functionality.\n\n7. Module name: coeff_memory\nExplanation: This module implements a 512x16-bit memory for storing coefficient data. It provides read/write functionality for coefficient access.\n\n8. Module name: alu_controller\nExplanation: This module controls the arithmetic logic unit operations. It manages address generation, enables signals for various components, and controls the computation flow for both left and right channels.\n\n9. Module name: adder\nExplanation: This module implements a 40-bit adder/subtractor. It can perform addition or subtraction based on a control signal.\n\n10. Module name: SIPO\nExplanation: This module implements a Serial-In Parallel-Out shift register. It takes serial inputs for left and right channels and outputs 16-bit parallel data for each channel."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the shift_acc module, here are the answers to your questions:\n\nInput ports: shift_enable, load, clear, sclk, blk_in[39:0]. \nExplanation: \n- shift_enable: Controls the shifting operation\n- load: Enables loading of new data\n- clear: Resets the accumulator\n- sclk: Clock input\n- blk_in[39:0]: 40-bit input data\n\nOutput ports: blk_out[39:0]. \nExplanation: \n- blk_out[39:0]: 40-bit output data from the accumulator\n\nThis module implements a 40-bit shift accumulator that can load new data, clear its contents, and perform right shifts based on the control signals. The accumulator is synchronized to the sclk (clock) input."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nBased on the given code for the shift_acc module, here are the answers to your questions:\n\nInternal signals: shift_acc_reg[39:0]. \nExplanation: \n- shift_acc_reg[39:0]: This is a 40-bit register that serves as the main storage element for the shift accumulator. It holds the current value of the accumulator and is updated based on the input signals. The register can be loaded with new data, cleared to zero, or shifted right depending on the control signals.\n\nThis internal register is crucial for the module's functionality as it stores the accumulated value and allows for shifting operations. It is updated on each positive edge of the sclk signal according to the conditions specified by the input control signals."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n`timescale 1ns / 1ps\n\nmodule shift_acc(\n    input shift_enable,\n    input load,\n    input clear,\n    input sclk,\n    input [39:0] blk_in,\n    output [39:0] blk_out\n    );\n\n\treg [39:0] shift_acc_reg;\n\t\n\talways @(posedge sclk)\n\tbegin\n\t\tif (clear)\n\t\t\tshift_acc_reg = 40'd0;\n\t\tif (load && shift_enable)\n\t\t\tshift_acc_reg = {blk_in[39], blk_in[39:1]};\n\t\telse if (load && !shift_enable)\n\t\t\tshift_acc_reg = blk_in;\n\t\telse\n\t\t\tshift_acc_reg = shift_acc_reg;\n\tend\n\n\tassign blk_out = shift_acc_reg;\n\t\t\t\nendmodule\n\nmodule rj_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\tinput [3:0] rj_wr_addr, rj_rd_addr,\n\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\toutput [15:0] rj_data);\n\n\treg [15:0] rj_mem [0:15];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\trj_mem[rj_wr_addr] = data_in;\n\t\telse\n\t\t\trj_mem[rj_wr_addr] = rj_mem[rj_wr_addr];\t\t\n\tend\n\n\tassign rj_data = (rd_en) ? rj_mem[rj_rd_addr] : 16'd0;\nendmodule\n\nmodule PISO (Sclk, Clear, Frame, Shifted, Serial_out, p2s_enable, OutReady);\ninput Sclk, Clear, p2s_enable, Frame;\ninput [39:0] Shifted;\noutput reg Serial_out, OutReady;\nreg [5:0] bit_count; \n\nreg out_rdy, frame_flag;\nreg [39:0] piso_reg;\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(Clear == 1'b1)\n\t\tbegin\n\t\t\tbit_count = 6'd40;\n\t\t\tpiso_reg = 40'd0;\n\t\t\tout_rdy = 1'b0;\n\t\t\tframe_flag = 1'b0;\n\t\t\tOutReady = 1'b0;\n\t\t\tSerial_out = 1'b0;\n\t\tend\n\t\telse if (p2s_enable == 1'b1)\n\t\tbegin\n\t\t\tpiso_reg = Shifted;\n\t\t\tout_rdy = 1'b1;\n\t\tend\n\t\telse if (Frame == 1'b1 && out_rdy == 1'b1 && frame_flag == 1'b0)\n\t\tbegin\n\t\t\tbit_count = bit_count - 1'b1;\n\t\t\tSerial_out = piso_reg [bit_count];\n\t\t\tframe_flag = 1'b1;\n\t\t\tout_rdy = 1'b0;\n\t\t\tOutReady = 1'b1;\n\t\tend\n\t\telse if (frame_flag == 1'b1)\n\t\tbegin\n\t\t\tbit_count = bit_count - 1'b1;\n\t\t\tSerial_out = piso_reg [bit_count];\n\t\t\tOutReady = 1'b1;\n\t\t\tif (bit_count == 6'd0)\n\t\t\t\tframe_flag = 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tbit_count = 6'd40;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tSerial_out = 1'b0;\n\t\t\tOutReady = 1'b0;\n\t\tend\n\tend\nendmodule\n\nmodule MSDAP_controller (input Sclk, Dclk, Start, Reset_n, Frame, input_rdy_flag, zero_flag_L, zero_flag_R,\n\t\t\t\t\t\t\t\t output reg [3:0] rj_wr_addr,\n\t\t\t\t\t\t       output reg [8:0] coeff_wr_addr,\n\t\t\t\t\t\t       output reg [7:0] data_wr_addr,\n\t\t\t\t\t\t       output reg rj_en, coeff_en, data_en, Clear,\n\t\t\t\t\t\t       output Frame_out, Dclk_out, Sclk_out,\n\t\t\t\t\t\t       output reg compute_enable, sleep_flag, InReady);\n\t\n\tparameter [3:0] Startup = 4'd0, Wait_rj = 4'd1, Read_rj = 4'd2,\n\t\t\t\t\t    Wait_coeff = 4'd3, Read_coeff = 4'd4, Wait_input = 4'd5,\n\t\t\t\t\t    Compute = 4'd6, Reset = 4'd7, Sleep = 4'd8;\n   \n\treg [3:0] pr_state, next_state;\n\treg [15:0] real_count;\n\n\treg [4:0] rj_count;\n\treg [9:0] coeff_count;\n\treg [7:0] data_count;\n\t\n\treg taken;\n\t\n\tassign Frame_out = Frame;\n\tassign Dclk_out = Dclk;\n\tassign Sclk_out = Sclk;\n\t\n\talways @(negedge Sclk or negedge Reset_n)\t\t\n\tbegin\n\t\tif (!Reset_n)\n\t\tbegin\n\t\t\tif (pr_state > 4'd4)\n\t\t\t\tpr_state = Reset;\n\t\t\telse\n\t\t\t\tpr_state = next_state;\n\t\tend\n\t\telse\n\t\tpr_state = next_state;\n\tend\n\t\n\talways @(negedge Sclk or posedge Start)\n\tbegin\n\t\tif (Start == 1'b1)\n\t\t\tnext_state = Startup;\n\t\telse\n\t\tbegin\n\t\tcase (pr_state)\n\t\t\tStartup:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b0;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tnext_state = Wait_rj;\n\t\t\t\t\t\t\treal_count = 16'd0;\n\t\t\t\t\t\t\trj_count = 4'd0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tWait_rj:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\trj_count = 4'd0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\tif (Frame == 1'b1)\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Wait_rj;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\tRead_rj:\tbegin\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\tif (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (rj_count < 5'd16)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\trj_en = 1'b1;\n\t\t\t\t\t\t\t\t\trj_wr_addr = rj_count;\n\t\t\t\t\t\t\t\t\trj_count = rj_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tif (rj_count == 5'd16)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tnext_state = Wait_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\trj_wr_addr = rj_wr_addr;\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tWait_coeff: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (Frame == 1'b1)\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Wait_coeff;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\tRead_coeff: begin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tif (coeff_count < 10'h200)\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\tcoeff_en = 1'b1;\n\t\t\t\t\t\t\t\t\t\tcoeff_wr_addr = coeff_count;\n\t\t\t\t\t\t\t\t\t\tcoeff_count = coeff_count + 1'b1;\n\t\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tif (coeff_count == 10'h200)\n\t\t\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\t\tcoeff_wr_addr = coeff_wr_addr;\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\tend\n\n\t\t\tWait_input: begin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\t\telse if (Frame == 1'b1)\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\t\tend\n\t\t\n\t\t\tCompute:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\t\tnext_state = Reset;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (zero_flag_L && zero_flag_R)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\t\t\t\tsleep_flag = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tdata_en = 1'b1;\n\t\t\t\t\t\t\t\t\tdata_wr_addr = data_count;\n\t\t\t\t\t\t\t\t\tdata_count = data_count + 1'b1;\n\t\t\t\t\t\t\t\t\treal_count = real_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\t\tcompute_enable = 1'b1;\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tReset:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b0;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tSleep:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b1;\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (zero_flag_L && zero_flag_R)\n\t\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\t\tdata_en = 1'b1;\n\t\t\t\t\t\t\t\t\tcompute_enable = 1'b1;\n\t\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\t\tdata_wr_addr = data_count;\n\t\t\t\t\t\t\t\t\tdata_count = data_count + 1'b1;\n\t\t\t\t\t\t\t\t\treal_count = real_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\tendcase\n\t\tend\n\tend\nendmodule\n\nmodule MSDAP(input Dclk, Sclk, Reset_n, Frame, Start, InputL, InputR,\n\t\t\t\t output InReady, OutReady, OutputL, OutputR);\n\t\t\t\t \n\t\n\twire Frame_in, Dclk_in, Clear, input_rdy_flag;\n\twire [15:0] data_L, data_R;\n\t\n\t\n\twire rj_en, coeff_en, data_en;\t\t\t\t\n\twire rj_en_L, coeff_en_L, xin_en_L; \t\t\n\twire rj_en_R, coeff_en_R, xin_en_R;\n\twire [3:0] rj_wr_addr, rj_addr_L, rj_addr_R;\n\twire [8:0] coeff_wr_addr, coeff_addr_L, coeff_addr_R;\n\twire [7:0] data_wr_addr, xin_addr_L, xin_addr_R;\n\twire [15:0] rj_data_L, coeff_data_L, xin_data_L;\n\twire [15:0] rj_data_R, coeff_data_R, xin_data_R;\n\twire zero_flag_L, zero_flag_R;\n\t\n\t\n\twire compute_enable, sleep_flag, Sclk_in;\n\t\n\t\n\twire [39:0] add_inp_L, add_inp_R;\n\twire add_sub_L, adder_en_L, shift_enable_L, load_L, clear_L, p2s_enable_L;\n\twire add_sub_R, adder_en_R, shift_enable_R, load_R, clear_R, p2s_enable_R;\n\t\n\t\n\twire [39:0] shifted_L, shifted_R, sum_L, sum_R;\n\t\n\t\n\twire OutReadyL, OutReadyR;\n\t\n\tassign add_inp_L = (xin_data_L[15]) ? {8'hFF, xin_data_L, 16'h0000} : {8'h00, xin_data_L, 16'h0000};\n\tassign add_inp_R = (xin_data_R[15]) ? {8'hFF, xin_data_R, 16'h0000} : {8'h00, xin_data_R, 16'h0000};\n\t\n\t\n\tSIPO SIPO_uut (.Frame(Frame_in), .Dclk(Dclk_in), .Clear(Clear),\n\t\t\t\t\t.InputL(InputL), .InputR(InputR), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t.data_L(data_L), .data_R(data_R));\n\t\n\trj_memory rj_L (.wr_en(rj_en), .rd_en(rj_en_L), .Sclk(Sclk_in),\n\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .rj_rd_addr(rj_addr_L),\n\t\t\t\t\t.data_in(data_L), .rj_data(rj_data_L));\n\t\n\trj_memory rj_R (.wr_en(rj_en), .rd_en(rj_en_R), .Sclk(Sclk_in),\n\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .rj_rd_addr(rj_addr_R),\n\t\t\t\t\t.data_in(data_R), .rj_data(rj_data_R));\n\t\t\t\t\t\n\tcoeff_memory coeff_L (.wr_en(coeff_en), .rd_en(coeff_en_L), .Sclk(Sclk_in),\n\t\t\t\t\t\t  .coeff_wr_addr(coeff_wr_addr), .coeff_rd_addr(coeff_addr_L),\n\t\t\t\t\t\t  .data_in(data_L), .coeff_data(coeff_data_L));\n\t\n\tcoeff_memory coeff_R (.wr_en(coeff_en), .rd_en(coeff_en_R), .Sclk(Sclk_in),\n\t\t\t\t\t\t  .coeff_wr_addr(coeff_wr_addr), .coeff_rd_addr(coeff_addr_R),\n\t\t\t\t\t\t  .data_in(data_R), .coeff_data(coeff_data_R));\n\n\tdata_memory xin_L (.wr_en(data_en), .rd_en(xin_en_L), .Sclk(Sclk_in), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t   .data_wr_addr(data_wr_addr), .data_rd_addr(xin_addr_L),\n\t\t\t\t\t   .data_in(data_L), .xin_data(xin_data_L), .zero_flag(zero_flag_L));\n\n\tdata_memory xin_R (.wr_en(data_en), .rd_en(xin_en_R), .Sclk(Sclk_in), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t   .data_wr_addr(data_wr_addr), .data_rd_addr(xin_addr_R),\n\t\t\t\t\t   .data_in(data_R), .xin_data(xin_data_R), .zero_flag(zero_flag_R));\n\t\t\t\t\t   \n\tMSDAP_controller main_ctrl (.Sclk(Sclk), .Dclk(Dclk), .Start(Start), .Reset_n(Reset_n),\n\t\t\t\t\t\t\t\t.Frame(Frame), .input_rdy_flag(input_rdy_flag), .zero_flag_L(zero_flag_L), .zero_flag_R(zero_flag_R),\n\t\t\t\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .coeff_wr_addr(coeff_wr_addr), .data_wr_addr(data_wr_addr),\n\t\t\t\t\t\t\t\t.rj_en(rj_en), .coeff_en(coeff_en), .data_en(data_en), .Clear(Clear),\n\t\t\t\t\t\t\t\t.Frame_out(Frame_in), .Dclk_out(Dclk_in), .Sclk_out(Sclk_in),\n\t\t\t\t\t\t\t\t.compute_enable(compute_enable), .sleep_flag(sleep_flag),\n\t\t\t\t\t\t\t\t.InReady(InReady));\n\t\n\talu_controller alu_ctrl (.compute_enable(compute_enable), .Clear(Clear), .Sclk(Sclk_in), .sleep_flag(sleep_flag),\n\t\t\t\t\t\t\t .rj_data_L(rj_data_L), .coeff_data_L(coeff_data_L), .xin_data_L(xin_data_L),\n\t\t\t\t\t\t\t .rj_data_R(rj_data_R), .coeff_data_R(coeff_data_R), .xin_data_R(xin_data_R),\n\t\t\t\t\t\t\t .add_inp_L(add_inp_L), .add_inp_R(add_inp_R),\n\t\t\t\t\t\t\t .rj_addr_L(rj_addr_L), .coeff_addr_L(coeff_addr_L), .xin_addr_L(xin_addr_L),\n\t\t\t\t\t\t\t .rj_addr_R(rj_addr_R), .coeff_addr_R(coeff_addr_R), .xin_addr_R(xin_addr_R),\n\t\t\t\t\t\t\t .rj_en_L(rj_en_L), .coeff_en_L(coeff_en_L), .xin_en_L(xin_en_L),\n\t\t\t\t\t\t\t .rj_en_R(rj_en_R), .coeff_en_R(coeff_en_R), .xin_en_R(xin_en_R),\n\t\t\t\t\t\t\t .add_sub_L(add_sub_L), .adder_en_L(adder_en_L), .shift_enable_L(shift_enable_L), .load_L(load_L), .clear_L(clear_L), .p2s_enable_L(p2s_enable_L),\n\t\t\t\t\t\t\t .add_sub_R(add_sub_R), .adder_en_R(adder_en_R), .shift_enable_R(shift_enable_R), .load_R(load_R), .clear_R(clear_R), .p2s_enable_R(p2s_enable_R));\n\t\t\t\t\t\t\t \n\tadder add_L (.a(add_inp_L), .b(shifted_L), .add_sub(add_sub_L), .adder_en(adder_en_L), .sum(sum_L));\n\t\n\tadder add_R (.a(add_inp_R), .b(shifted_R), .add_sub(add_sub_R), .adder_en(adder_en_R), .sum(sum_R));\n\t\n\tshift_acc shift_acc_L (.shift_enable(shift_enable_L), .load(load_L), .clear(clear_L), .sclk(Sclk_in), .blk_in(sum_L), .blk_out(shifted_L));\n\t\n\tshift_acc shift_acc_R (.shift_enable(shift_enable_R), .load(load_R), .clear(clear_R), .sclk(Sclk_in), .blk_in(sum_R), .blk_out(shifted_R));\n\t\n\tPISO PISO_L (.Sclk(Sclk_in), .Clear(Clear), .Frame(Frame_in), .Shifted(shifted_L), .Serial_out(OutputL), .p2s_enable(p2s_enable_L), .OutReady(OutReadyL));\n\t\n\tPISO PISO_R (.Sclk(Sclk_in), .Clear(Clear), .Frame(Frame_in), .Shifted(shifted_R), .Serial_out(OutputR), .p2s_enable(p2s_enable_R), .OutReady(OutReadyR));\n\n\tassign OutReady = OutReadyL || OutReadyR;\n\t\nendmodule\n\nmodule data_memory (input wr_en, rd_en, Sclk, input_rdy_flag,\n\t\t\t\t\tinput [7:0] data_wr_addr, data_rd_addr,\n\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\toutput [15:0] xin_data,\n\t\t\t\t\toutput reg zero_flag);\n\n\treg [15:0] data_mem [0:255];\n\treg [11:0] zero_cnt;\n\t\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\tdata_mem[data_wr_addr] = data_in;\n\t\telse\n\t\t\tdata_mem[data_wr_addr] = data_mem[data_wr_addr];\n\tend\n\n\talways @(posedge input_rdy_flag)\n\tbegin\n\t\tif (data_in == 16'd0)\n\t\tbegin\n\t\t\tzero_cnt = zero_cnt + 1'b1;\n\t\t\tif (zero_cnt == 12'd800)\n\t\t\t\tzero_flag = 1'b1;\n\t\t\telse if (zero_cnt > 12'd800)\n\t\t\tbegin\n\t\t\t\tzero_cnt = 12'd800;\n\t\t\t\tzero_flag = 1'b1;\n\t\t\tend\n\t\tend\t\t\n\t\telse if (data_in != 16'd0)\n\t\tbegin\n\t\t\tzero_cnt = 12'd0;\n\t\t\tzero_flag = 1'b0;\n\t\tend\n\tend\n\n\tassign xin_data = (rd_en) ? data_mem[data_rd_addr] : 16'd0;\nendmodule\n\nmodule coeff_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\t\tinput [8:0] coeff_wr_addr, coeff_rd_addr,\n\t\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\t\toutput [15:0] coeff_data);\n\n\treg [15:0] coeff_mem [0:511];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\tcoeff_mem[coeff_wr_addr] = data_in;\n\t\telse\n\t\t\tcoeff_mem[coeff_wr_addr] = coeff_mem[coeff_wr_addr];\t\t\n\tend\n\n\tassign coeff_data = (rd_en) ? coeff_mem[coeff_rd_addr] : 16'd0;\nendmodule\n\nmodule alu_controller (\n\tinput compute_enable,\n\tinput Clear,\n\tinput Sclk,\n\tinput sleep_flag,\n\t\n\tinput [15:0] rj_data_L, coeff_data_L, xin_data_L,\n\tinput [15:0] rj_data_R, coeff_data_R, xin_data_R,\n\t\n\toutput [39:0] add_inp_L, add_inp_R,\n\t\n\toutput reg [3:0] rj_addr_L,\n\toutput reg [8:0] coeff_addr_L,\n\toutput reg [7:0] xin_addr_L,\n\t\n\toutput reg [3:0] rj_addr_R,\n\toutput reg [8:0] coeff_addr_R,\n\toutput reg [7:0] xin_addr_R,\n\t\n\toutput reg rj_en_L, coeff_en_L, xin_en_L,\n\toutput reg rj_en_R, coeff_en_R, xin_en_R,\n\t\n\toutput reg add_sub_L, adder_en_L, shift_enable_L, load_L, clear_L, p2s_enable_L,\n\toutput reg add_sub_R, adder_en_R, shift_enable_R, load_R, clear_R, p2s_enable_R\n\t);\n\t\n\tparameter initial_state = 2'b00, comp_state = 2'b01, sleep_state = 2'b10;\n\t\n\treg [1:0] pr_state_L, next_state_L;\n\treg [1:0] pr_state_R, next_state_R;\n\t\n\treg [7:0] x_count_L, x_index_L;\n\treg [7:0] x_count_R, x_index_R;\n\t\n\treg [7:0] k_L, k_R;\n\t\n\treg xmem_overflow_L, start_comp_L, compute_status_L, out_done_L;\n\treg xmem_overflow_R, start_comp_R, compute_status_R, out_done_R;\n\t\n\t\n\t\n\tassign add_inp_L = (xin_data_L[15]) ? {8'hFF, xin_data_L, 16'h0000} : {8'h00, xin_data_L, 16'h0000};\n\tassign add_inp_R = (xin_data_R[15]) ? {8'hFF, xin_data_R, 16'h0000} : {8'h00, xin_data_R, 16'h0000};\n\t\n\t\t\n\talways @(Clear, next_state_L)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\t\tpr_state_L <= initial_state;\n\t\telse\n\t\t\tpr_state_L <= next_state_L;\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\t\n\t\tcase (pr_state_L)\n\t\t\tinitial_state:\n\t\t\t\tbegin\n\t\t\t\t\txmem_overflow_L <= 1'b0;\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\t\t\tx_count_L <= 8'd1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\t\tx_count_L <= x_count_L;\n\t\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\n\t\t\tcomp_state:\n\t\t\t\tbegin\n\t\t\t\t\tif (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_L <= x_count_L + 1'b1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\t\tif (x_count_L == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_L <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\t\tif (rj_addr_L == 4'hF && coeff_addr_L == 9'h1FF && k_L == rj_data_L)\n\t\t\t\t\t\t\tcompute_status_L <= 1'b0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcompute_status_L <= compute_status_L;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b1)\n\t\t\t\t\t\tnext_state_L <= sleep_state;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\tend\n\t\t\t\n\t\t\tsleep_state:\n\t\t\t\tbegin\n\t\t\t\t\tx_count_L <= x_count_L;\n\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\tcompute_status_L <= 1'b0;\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_L <= x_count_L + 1'b1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\t\tif (x_count_L == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_L <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_L <= sleep_state;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tdefault:\tnext_state_L <= initial_state;\n\t\tendcase\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\tif (out_done_L)\n\t\tbegin\n\t\t\tp2s_enable_L = 1'b1;\n\t\t\trj_addr_L = 4'd0;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tk_L = 8'd0;\n\t\t\tout_done_L = 1'b0;\n\t\t\tclear_L = 1'b1;\n\t\tend\n\t\telse\n\t\t\tp2s_enable_L = 1'b0;\n\t\t\n\t\tif (start_comp_L == 1'b1)\n\t\tbegin\n\t\t\tout_done_L = 1'b0;\n\t\t\trj_addr_L = 4'd0;\n\t\t\trj_en_L = 1'b1;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tcoeff_en_L = 1'b1;\n\t\t\txin_en_L = 1'b0;\n\t\t\tadder_en_L = 1'b0;\n\t\t\tshift_enable_L = 1'b0;\n\t\t\tk_L = 8'd0;\n\t\t\tclear_L = 1'b1;\n\t\t\tload_L = 1'b0;\n\t\tend\n\t\telse if (compute_status_L == 1'b1)\n\t\tbegin\n\t\t\tif (k_L == rj_data_L)\n\t\t\tbegin\n\t\t\t\txin_en_L = 1'b0;\n\t\t\t\tshift_enable_L = 1'b1;\n\t\t\t\tclear_L = 1'b0;\n\t\t\t\tload_L = 1'b1;\n\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\tk_L = 8'd0;\n\t\t\t\tif (rj_addr_L < 4'd15)\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_L = rj_addr_L + 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_L = 4'd0;\n\t\t\t\t\tout_done_L = 1'b1;\n\t\t\t\t\tcoeff_addr_L = 9'd0;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tshift_enable_L = 1'b0;\n\t\t\t\tclear_L = 1'b0;\n\t\t\t\tload_L = 1'b0;\n\t\t\t\txin_en_L = 1'b0;\n\t\t\t\tx_index_L = coeff_data_L[7:0];\n\t\t\t\tadd_sub_L = coeff_data_L[8];\n\t\t\t\tif (x_count_L - 1'b1 >= x_index_L)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = x_count_L - 1'b1 - x_index_L;\n\t\t\t\t\txin_en_L = 1'b1;\n\t\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\t\tload_L = 1'b1;\n\t\t\t\tend\n\t\t\t\telse if (x_count_L - 1'b1 < x_index_L && xmem_overflow_L == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = x_count_L - 1'b1 + (9'd256 - x_index_L);\n\t\t\t\t\txin_en_L = 1'b1;\n\t\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\t\tload_L = 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = xin_addr_L;\n\t\t\t\t\tadder_en_L = 1'b0;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif (coeff_addr_L < 9'h1FF)\n\t\t\t\t\tcoeff_addr_L = coeff_addr_L + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tcoeff_addr_L = coeff_addr_L;\n\t\t\t\t\n\t\t\t\tk_L = k_L + 1'b1;\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trj_addr_L = 4'd0;\n\t\t\trj_en_L = 1'b0;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tcoeff_en_L = 1'b0;\n\t\t\txin_en_L = 1'b0;\n\t\t\tadder_en_L = 1'b0;\n\t\t\tshift_enable_L = 1'b0;\n\t\t\tk_L = 8'd0;\n\t\t\tload_L = 1'b0;\n\t\t\tclear_L = 1'b1;\n\t\tend\n\tend\n\t\n\t\n\n\n\n\t\n\t\n\t\n\t\n\talways @(Clear, next_state_R)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\t\tpr_state_R <= initial_state;\n\t\telse\n\t\t\tpr_state_R <= next_state_R;\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\t\n\t\tcase (pr_state_R)\n\t\t\tinitial_state:\n\t\t\t\tbegin\n\t\t\t\t\txmem_overflow_R <= 1'b0;\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\telse if (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\t\t\tx_count_R <= 8'd1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\t\tx_count_R <= x_count_R;\n\t\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\n\t\t\tcomp_state:\n\t\t\t\tbegin\n\t\t\t\t\tif (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_R <= x_count_R + 1'b1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\t\tif (x_count_R == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_R <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\t\tif (rj_addr_R == 4'hF && coeff_addr_R == 9'h1FF && k_R == rj_data_R)\n\t\t\t\t\t\t\tcompute_status_R <= 1'b0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcompute_status_R <= compute_status_R;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\tend\n\t\t\t\n\t\t\tsleep_state:\n\t\t\t\tbegin\n\t\t\t\t\tx_count_R <= x_count_R;\n\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\tcompute_status_R <= 1'b0;\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_R <= x_count_R + 1'b1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\t\tif (x_count_R == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_R <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_R <= sleep_state;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tbegin\n\t\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\tif (out_done_R)\n\t\tbegin\n\t\t\tp2s_enable_R = 1'b1;\n\t\t\trj_addr_R = 4'd0;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tk_R = 8'd0;\n\t\t\tout_done_R = 1'b0;\n\t\tend\n\t\telse\n\t\t\tp2s_enable_R = 1'b0;\n\t\t\n\t\tif (start_comp_R == 1'b1)\n\t\tbegin\n\t\t\tout_done_R = 1'b0;\n\t\t\trj_addr_R = 4'd0;\n\t\t\trj_en_R = 1'b1;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tcoeff_en_R = 1'b1;\n\t\t\txin_en_R = 1'b0;\n\t\t\tadder_en_R = 1'b0;\n\t\t\tshift_enable_R = 1'b0;\n\t\t\tk_R = 8'd0;\n\t\t\tclear_R = 1'b1;\n\t\t\tload_R = 1'b0;\n\t\tend\n\t\telse if (compute_status_R == 1'b1)\n\t\tbegin\n\t\t\tif (k_R == rj_data_R)\n\t\t\tbegin\n\t\t\t\txin_en_R = 1'b0;\n\t\t\t\tshift_enable_R = 1'b1;\n\t\t\t\tclear_R = 1'b0;\n\t\t\t\tload_R = 1'b1;\n\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\tk_R = 8'd0;\n\t\t\t\tif (rj_addr_R < 4'd15)\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_R = rj_addr_R + 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_R = 4'd0;\n\t\t\t\t\tout_done_R = 1'b1;\n\t\t\t\t\tcoeff_addr_R = 9'd0;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tshift_enable_R = 1'b0;\n\t\t\t\tclear_R = 1'b0;\n\t\t\t\tload_R = 1'b0;\n\t\t\t\txin_en_R = 1'b0;\n\t\t\t\tx_index_R = coeff_data_R[7:0];\n\t\t\t\tadd_sub_R = coeff_data_R[8];\n\t\t\t\tif (x_count_R - 1'b1 >= x_index_R)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = x_count_R - 1'b1 - x_index_R;\n\t\t\t\t\txin_en_R = 1'b1;\n\t\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\t\tload_R = 1'b1;\n\t\t\t\tend\n\t\t\t\telse if (x_count_R - 1'b1 < x_index_R && xmem_overflow_R == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = x_count_R - 1'b1 + (9'd256 - x_index_R);\n\t\t\t\t\txin_en_R = 1'b1;\n\t\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\t\tload_R = 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = xin_addr_R;\n\t\t\t\t\tadder_en_R = 1'b0;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif (coeff_addr_R < 9'h1FF)\n\t\t\t\t\tcoeff_addr_R = coeff_addr_R + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tcoeff_addr_R = coeff_addr_R;\n\t\t\t\t\n\t\t\t\tk_R = k_R + 1'b1;\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trj_addr_R = 4'd0;\n\t\t\trj_en_R = 1'b0;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tcoeff_en_R = 1'b0;\n\t\t\txin_en_R = 1'b0;\n\t\t\tadder_en_R = 1'b0;\n\t\t\tshift_enable_R = 1'b0;\n\t\t\tk_R = 8'd0;\n\t\t\tload_R = 1'b0;\n\t\t\tclear_R = 1'b1;\n\t\tend\n\tend\n\t\n\t\n\n\n\n\t\nendmodule\n\nmodule adder(\n\tinput [39:0] a,\n    input [39:0] b,\n    input add_sub,\n\tinput adder_en,\n    output [39:0] sum\n    );\n\n\t\tassign sum = (add_sub == 1'b1) ? (b - a) : \n\t\t\t\t\t\t (add_sub == 1'b0) ? (b + a) :\n\t\t\t\t\t\t \tsum;\t\n\nendmodule\n\nmodule SIPO (Frame, Dclk, Clear, InputL, InputR, data_L, data_R, input_rdy_flag);\n\tinput Frame, Dclk, Clear, InputL, InputR;\n\toutput reg input_rdy_flag;\n\toutput reg [15:0] data_L;\n\toutput reg [15:0] data_R;\n\treg [3:0] bit_count;\n\treg frame_status;\n\n\talways @(negedge Dclk or posedge Clear)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\tbegin\n\t\t\tbit_count = 4'd15;\n\t\t\t\n\t\t\t\n\t\t\tdata_L = 16'd0;\n\t\t\tdata_R = 16'd0;\t\t\t\n\t\t\tinput_rdy_flag = 1'b0;\n\t\t\tframe_status = 1'b0;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tif (Frame == 1'b1)\n\t\t\tbegin\n\t\t\t\tbit_count = 4'd15;\n\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\tdata_L [bit_count] = InputL;\n\t\t\t\tdata_R [bit_count] = InputR;\n\t\t\t\tframe_status = 1'b1;\n\t\t\tend\n\t\t\telse if (frame_status == 1'b1)\n\t\t\tbegin\n\t\t\t\tbit_count = bit_count - 1'b1;\n\t\t\t\tdata_L [bit_count] = InputL;\n\t\t\t\tdata_R [bit_count] = InputR;\n\t\t\t\tif (bit_count == 4'd0)\n\t\t\t\tbegin\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tinput_rdy_flag = 1'b1;\n\t\t\t\t\tframe_status = 1'b0;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\t\tframe_status = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tbit_count = 4'd15;\n\t\t\t\tdata_L = 16'd0;\n\t\t\t\tdata_R = 16'd0;\t\t\t\n\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\tframe_status = 1'b0;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: shift_acc. Module specification: The shift_acc module implements a 40-bit shift accumulator with load, clear, and shift functionalities. It has input ports for shift_enable (controls shifting), load (enables loading new data), clear (resets accumulator), sclk (clock input), and blk_in[39:0] (40-bit input data). The output port is blk_out[39:0] (40-bit output data). Internally, it uses a 40-bit register shift_acc_reg to store and manipulate data. The module's main block is a synchronous always block triggered on the positive edge of sclk. This block handles clearing the accumulator, loading new data with optional shifting, and maintaining the current value based on input signals. The module can perform right shifts when enabled, making it suitable for digital signal processing applications that require accumulation and shifting operations."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nBased on the given code, I'll answer your questions for each module:\n\n1. Module name: shift_acc\nExplanation: This module implements a shift accumulator. It can load, clear, and shift data based on input signals. The accumulator register is 40 bits wide and can perform right shifts when enabled.\n\n2. Module name: rj_memory\nExplanation: This module implements a 16x16-bit memory with write and read functionality. It stores and retrieves 16-bit data based on the provided address and control signals.\n\n3. Module name: PISO\nExplanation: This module implements a Parallel-In Serial-Out shift register. It takes a 40-bit parallel input and outputs it serially based on control signals. It also provides an output ready signal.\n\n4. Module name: MSDAP_controller\nExplanation: This is the main controller module for the MSDAP (likely Multi-Stage Digital Audio Processor). It manages various stages of operation including startup, reading data, computing, and sleep modes. It controls memory accesses and coordinates different parts of the system.\n\n5. Module name: MSDAP\nExplanation: This is the top-level module that integrates all other components. It implements a digital audio processing system with left and right channel inputs and outputs, coordinating data flow between various sub-modules.\n\n6. Module name: data_memory\nExplanation: This module implements a 256x16-bit memory for storing input data. It includes a zero detection feature and provides read/write functionality.\n\n7. Module name: coeff_memory\nExplanation: This module implements a 512x16-bit memory for storing coefficient data. It provides read/write functionality for coefficient access.\n\n8. Module name: alu_controller\nExplanation: This module controls the arithmetic logic unit operations. It manages address generation, enables signals for various components, and controls the computation flow for both left and right channels.\n\n9. Module name: adder\nExplanation: This module implements a 40-bit adder/subtractor. It can perform addition or subtraction based on a control signal.\n\n10. Module name: SIPO\nExplanation: This module implements a Serial-In Parallel-Out shift register. It takes serial inputs for left and right channels and outputs 16-bit parallel data for each channel."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nBased on the given Verilog code for the shift_acc module, here are the answers to your questions:\n\nInput ports: shift_enable, load, clear, sclk, blk_in[39:0]. \nExplanation: \n- shift_enable: Controls the shifting operation\n- load: Enables loading of new data\n- clear: Resets the accumulator\n- sclk: Clock input\n- blk_in[39:0]: 40-bit input data\n\nOutput ports: blk_out[39:0]. \nExplanation: \n- blk_out[39:0]: 40-bit output data from the accumulator\n\nThis module implements a 40-bit shift accumulator that can load new data, clear its contents, and perform right shifts based on the control signals. The accumulator is synchronized to the sclk (clock) input."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nBased on the given code for the shift_acc module, here are the answers to your questions:\n\nInternal signals: shift_acc_reg[39:0]. \nExplanation: \n- shift_acc_reg[39:0]: This is a 40-bit register that serves as the main storage element for the shift accumulator. It holds the current value of the accumulator and is updated based on the input signals. The register can be loaded with new data, cleared to zero, or shifted right depending on the control signals.\n\nThis internal register is crucial for the module's functionality as it stores the accumulated value and allows for shifting operations. It is updated on each positive edge of the sclk signal according to the conditions specified by the input control signals."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>`timescale 1ns / 1ps\n\nmodule shift_acc(\n    input shift_enable,\n    input load,\n    input clear,\n    input sclk,\n    input [39:0] blk_in,\n    output [39:0] blk_out\n    );\n\n\treg [39:0] shift_acc_reg;\n\t\n\talways @(posedge sclk)\n\tbegin\n\t\tif (clear)\n\t\t\tshift_acc_reg = 40'd0;\n\t\tif (load && shift_enable)\n\t\t\tshift_acc_reg = {blk_in[39], blk_in[39:1]};\n\t\telse if (load && !shift_enable)\n\t\t\tshift_acc_reg = blk_in;\n\t\telse\n\t\t\tshift_acc_reg = shift_acc_reg;\n\tend\n\n\tassign blk_out = shift_acc_reg;\n\t\t\t\nendmodule\n\nmodule rj_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\tinput [3:0] rj_wr_addr, rj_rd_addr,\n\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\toutput [15:0] rj_data);\n\n\treg [15:0] rj_mem [0:15];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\trj_mem[rj_wr_addr] = data_in;\n\t\telse\n\t\t\trj_mem[rj_wr_addr] = rj_mem[rj_wr_addr];\t\t\n\tend\n\n\tassign rj_data = (rd_en) ? rj_mem[rj_rd_addr] : 16'd0;\nendmodule\n\nmodule PISO (Sclk, Clear, Frame, Shifted, Serial_out, p2s_enable, OutReady);\ninput Sclk, Clear, p2s_enable, Frame;\ninput [39:0] Shifted;\noutput reg Serial_out, OutReady;\nreg [5:0] bit_count; \n\nreg out_rdy, frame_flag;\nreg [39:0] piso_reg;\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(Clear == 1'b1)\n\t\tbegin\n\t\t\tbit_count = 6'd40;\n\t\t\tpiso_reg = 40'd0;\n\t\t\tout_rdy = 1'b0;\n\t\t\tframe_flag = 1'b0;\n\t\t\tOutReady = 1'b0;\n\t\t\tSerial_out = 1'b0;\n\t\tend\n\t\telse if (p2s_enable == 1'b1)\n\t\tbegin\n\t\t\tpiso_reg = Shifted;\n\t\t\tout_rdy = 1'b1;\n\t\tend\n\t\telse if (Frame == 1'b1 && out_rdy == 1'b1 && frame_flag == 1'b0)\n\t\tbegin\n\t\t\tbit_count = bit_count - 1'b1;\n\t\t\tSerial_out = piso_reg [bit_count];\n\t\t\tframe_flag = 1'b1;\n\t\t\tout_rdy = 1'b0;\n\t\t\tOutReady = 1'b1;\n\t\tend\n\t\telse if (frame_flag == 1'b1)\n\t\tbegin\n\t\t\tbit_count = bit_count - 1'b1;\n\t\t\tSerial_out = piso_reg [bit_count];\n\t\t\tOutReady = 1'b1;\n\t\t\tif (bit_count == 6'd0)\n\t\t\t\tframe_flag = 1'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tbit_count = 6'd40;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tSerial_out = 1'b0;\n\t\t\tOutReady = 1'b0;\n\t\tend\n\tend\nendmodule\n\nmodule MSDAP_controller (input Sclk, Dclk, Start, Reset_n, Frame, input_rdy_flag, zero_flag_L, zero_flag_R,\n\t\t\t\t\t\t\t\t output reg [3:0] rj_wr_addr,\n\t\t\t\t\t\t       output reg [8:0] coeff_wr_addr,\n\t\t\t\t\t\t       output reg [7:0] data_wr_addr,\n\t\t\t\t\t\t       output reg rj_en, coeff_en, data_en, Clear,\n\t\t\t\t\t\t       output Frame_out, Dclk_out, Sclk_out,\n\t\t\t\t\t\t       output reg compute_enable, sleep_flag, InReady);\n\t\n\tparameter [3:0] Startup = 4'd0, Wait_rj = 4'd1, Read_rj = 4'd2,\n\t\t\t\t\t    Wait_coeff = 4'd3, Read_coeff = 4'd4, Wait_input = 4'd5,\n\t\t\t\t\t    Compute = 4'd6, Reset = 4'd7, Sleep = 4'd8;\n   \n\treg [3:0] pr_state, next_state;\n\treg [15:0] real_count;\n\n\treg [4:0] rj_count;\n\treg [9:0] coeff_count;\n\treg [7:0] data_count;\n\t\n\treg taken;\n\t\n\tassign Frame_out = Frame;\n\tassign Dclk_out = Dclk;\n\tassign Sclk_out = Sclk;\n\t\n\talways @(negedge Sclk or negedge Reset_n)\t\t\n\tbegin\n\t\tif (!Reset_n)\n\t\tbegin\n\t\t\tif (pr_state > 4'd4)\n\t\t\t\tpr_state = Reset;\n\t\t\telse\n\t\t\t\tpr_state = next_state;\n\t\tend\n\t\telse\n\t\tpr_state = next_state;\n\tend\n\t\n\talways @(negedge Sclk or posedge Start)\n\tbegin\n\t\tif (Start == 1'b1)\n\t\t\tnext_state = Startup;\n\t\telse\n\t\tbegin\n\t\tcase (pr_state)\n\t\t\tStartup:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b0;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tnext_state = Wait_rj;\n\t\t\t\t\t\t\treal_count = 16'd0;\n\t\t\t\t\t\t\trj_count = 4'd0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tWait_rj:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\trj_count = 4'd0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\tif (Frame == 1'b1)\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Wait_rj;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\tRead_rj:\tbegin\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\tif (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (rj_count < 5'd16)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\trj_en = 1'b1;\n\t\t\t\t\t\t\t\t\trj_wr_addr = rj_count;\n\t\t\t\t\t\t\t\t\trj_count = rj_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tif (rj_count == 5'd16)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tnext_state = Wait_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\trj_wr_addr = rj_wr_addr;\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Read_rj;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tWait_coeff: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_count = 9'd0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (Frame == 1'b1)\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Wait_coeff;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\tRead_coeff: begin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tif (coeff_count < 10'h200)\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\tcoeff_en = 1'b1;\n\t\t\t\t\t\t\t\t\t\tcoeff_wr_addr = coeff_count;\n\t\t\t\t\t\t\t\t\t\tcoeff_count = coeff_count + 1'b1;\n\t\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tif (coeff_count == 10'h200)\n\t\t\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\t\tcoeff_wr_addr = coeff_wr_addr;\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Read_coeff;\n\t\t\t\t\t\t\tend\n\n\t\t\tWait_input: begin\n\t\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\t\telse if (Frame == 1'b1)\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\t\tend\n\t\t\n\t\t\tCompute:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\t\tnext_state = Reset;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (zero_flag_L && zero_flag_R)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\t\t\t\tsleep_flag = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tdata_en = 1'b1;\n\t\t\t\t\t\t\t\t\tdata_wr_addr = data_count;\n\t\t\t\t\t\t\t\t\tdata_count = data_count + 1'b1;\n\t\t\t\t\t\t\t\t\treal_count = real_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\t\tcompute_enable = 1'b1;\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tReset:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = 8'd0;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b1;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b0;\n\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\tdata_count = 8'd0;\n\t\t\t\t\t\t\ttaken = 1'b0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Wait_input;\n\t\t\t\t\t\tend\n\t\t\t\n\t\t\tSleep:\tbegin\n\t\t\t\t\t\t\trj_wr_addr = 4'd0;\n\t\t\t\t\t\t\tcoeff_wr_addr = 9'd0;\n\t\t\t\t\t\t\tdata_wr_addr = data_wr_addr;\n\t\t\t\t\t\t\trj_en = 1'b0;\n\t\t\t\t\t\t\tcoeff_en = 1'b0;\n\t\t\t\t\t\t\tdata_en = 1'b0;\n\t\t\t\t\t\t\tClear = 1'b0;\n\t\t\t\t\t\t\tcompute_enable = 1'b0;\n\t\t\t\t\t\t\tInReady = 1'b1;\n\t\t\t\t\t\t\tsleep_flag = 1'b1;\n\t\t\t\t\t\t\tif (Reset_n == 1'b0)\n\t\t\t\t\t\t\t\tnext_state = Reset;\n\t\t\t\t\t\t\telse if (input_rdy_flag == 1'b1 && taken == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (zero_flag_L && zero_flag_R)\n\t\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\ttaken = 1'b1;\n\t\t\t\t\t\t\t\t\tdata_en = 1'b1;\n\t\t\t\t\t\t\t\t\tcompute_enable = 1'b1;\n\t\t\t\t\t\t\t\t\tsleep_flag = 1'b0;\n\t\t\t\t\t\t\t\t\tdata_wr_addr = data_count;\n\t\t\t\t\t\t\t\t\tdata_count = data_count + 1'b1;\n\t\t\t\t\t\t\t\t\treal_count = real_count + 1'b1;\n\t\t\t\t\t\t\t\t\tnext_state = Compute;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = Sleep;\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\tendcase\n\t\tend\n\tend\nendmodule\n\nmodule MSDAP(input Dclk, Sclk, Reset_n, Frame, Start, InputL, InputR,\n\t\t\t\t output InReady, OutReady, OutputL, OutputR);\n\t\t\t\t \n\t\n\twire Frame_in, Dclk_in, Clear, input_rdy_flag;\n\twire [15:0] data_L, data_R;\n\t\n\t\n\twire rj_en, coeff_en, data_en;\t\t\t\t\n\twire rj_en_L, coeff_en_L, xin_en_L; \t\t\n\twire rj_en_R, coeff_en_R, xin_en_R;\n\twire [3:0] rj_wr_addr, rj_addr_L, rj_addr_R;\n\twire [8:0] coeff_wr_addr, coeff_addr_L, coeff_addr_R;\n\twire [7:0] data_wr_addr, xin_addr_L, xin_addr_R;\n\twire [15:0] rj_data_L, coeff_data_L, xin_data_L;\n\twire [15:0] rj_data_R, coeff_data_R, xin_data_R;\n\twire zero_flag_L, zero_flag_R;\n\t\n\t\n\twire compute_enable, sleep_flag, Sclk_in;\n\t\n\t\n\twire [39:0] add_inp_L, add_inp_R;\n\twire add_sub_L, adder_en_L, shift_enable_L, load_L, clear_L, p2s_enable_L;\n\twire add_sub_R, adder_en_R, shift_enable_R, load_R, clear_R, p2s_enable_R;\n\t\n\t\n\twire [39:0] shifted_L, shifted_R, sum_L, sum_R;\n\t\n\t\n\twire OutReadyL, OutReadyR;\n\t\n\tassign add_inp_L = (xin_data_L[15]) ? {8'hFF, xin_data_L, 16'h0000} : {8'h00, xin_data_L, 16'h0000};\n\tassign add_inp_R = (xin_data_R[15]) ? {8'hFF, xin_data_R, 16'h0000} : {8'h00, xin_data_R, 16'h0000};\n\t\n\t\n\tSIPO SIPO_uut (.Frame(Frame_in), .Dclk(Dclk_in), .Clear(Clear),\n\t\t\t\t\t.InputL(InputL), .InputR(InputR), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t.data_L(data_L), .data_R(data_R));\n\t\n\trj_memory rj_L (.wr_en(rj_en), .rd_en(rj_en_L), .Sclk(Sclk_in),\n\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .rj_rd_addr(rj_addr_L),\n\t\t\t\t\t.data_in(data_L), .rj_data(rj_data_L));\n\t\n\trj_memory rj_R (.wr_en(rj_en), .rd_en(rj_en_R), .Sclk(Sclk_in),\n\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .rj_rd_addr(rj_addr_R),\n\t\t\t\t\t.data_in(data_R), .rj_data(rj_data_R));\n\t\t\t\t\t\n\tcoeff_memory coeff_L (.wr_en(coeff_en), .rd_en(coeff_en_L), .Sclk(Sclk_in),\n\t\t\t\t\t\t  .coeff_wr_addr(coeff_wr_addr), .coeff_rd_addr(coeff_addr_L),\n\t\t\t\t\t\t  .data_in(data_L), .coeff_data(coeff_data_L));\n\t\n\tcoeff_memory coeff_R (.wr_en(coeff_en), .rd_en(coeff_en_R), .Sclk(Sclk_in),\n\t\t\t\t\t\t  .coeff_wr_addr(coeff_wr_addr), .coeff_rd_addr(coeff_addr_R),\n\t\t\t\t\t\t  .data_in(data_R), .coeff_data(coeff_data_R));\n\n\tdata_memory xin_L (.wr_en(data_en), .rd_en(xin_en_L), .Sclk(Sclk_in), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t   .data_wr_addr(data_wr_addr), .data_rd_addr(xin_addr_L),\n\t\t\t\t\t   .data_in(data_L), .xin_data(xin_data_L), .zero_flag(zero_flag_L));\n\n\tdata_memory xin_R (.wr_en(data_en), .rd_en(xin_en_R), .Sclk(Sclk_in), .input_rdy_flag(input_rdy_flag),\n\t\t\t\t\t   .data_wr_addr(data_wr_addr), .data_rd_addr(xin_addr_R),\n\t\t\t\t\t   .data_in(data_R), .xin_data(xin_data_R), .zero_flag(zero_flag_R));\n\t\t\t\t\t   \n\tMSDAP_controller main_ctrl (.Sclk(Sclk), .Dclk(Dclk), .Start(Start), .Reset_n(Reset_n),\n\t\t\t\t\t\t\t\t.Frame(Frame), .input_rdy_flag(input_rdy_flag), .zero_flag_L(zero_flag_L), .zero_flag_R(zero_flag_R),\n\t\t\t\t\t\t\t\t.rj_wr_addr(rj_wr_addr), .coeff_wr_addr(coeff_wr_addr), .data_wr_addr(data_wr_addr),\n\t\t\t\t\t\t\t\t.rj_en(rj_en), .coeff_en(coeff_en), .data_en(data_en), .Clear(Clear),\n\t\t\t\t\t\t\t\t.Frame_out(Frame_in), .Dclk_out(Dclk_in), .Sclk_out(Sclk_in),\n\t\t\t\t\t\t\t\t.compute_enable(compute_enable), .sleep_flag(sleep_flag),\n\t\t\t\t\t\t\t\t.InReady(InReady));\n\t\n\talu_controller alu_ctrl (.compute_enable(compute_enable), .Clear(Clear), .Sclk(Sclk_in), .sleep_flag(sleep_flag),\n\t\t\t\t\t\t\t .rj_data_L(rj_data_L), .coeff_data_L(coeff_data_L), .xin_data_L(xin_data_L),\n\t\t\t\t\t\t\t .rj_data_R(rj_data_R), .coeff_data_R(coeff_data_R), .xin_data_R(xin_data_R),\n\t\t\t\t\t\t\t .add_inp_L(add_inp_L), .add_inp_R(add_inp_R),\n\t\t\t\t\t\t\t .rj_addr_L(rj_addr_L), .coeff_addr_L(coeff_addr_L), .xin_addr_L(xin_addr_L),\n\t\t\t\t\t\t\t .rj_addr_R(rj_addr_R), .coeff_addr_R(coeff_addr_R), .xin_addr_R(xin_addr_R),\n\t\t\t\t\t\t\t .rj_en_L(rj_en_L), .coeff_en_L(coeff_en_L), .xin_en_L(xin_en_L),\n\t\t\t\t\t\t\t .rj_en_R(rj_en_R), .coeff_en_R(coeff_en_R), .xin_en_R(xin_en_R),\n\t\t\t\t\t\t\t .add_sub_L(add_sub_L), .adder_en_L(adder_en_L), .shift_enable_L(shift_enable_L), .load_L(load_L), .clear_L(clear_L), .p2s_enable_L(p2s_enable_L),\n\t\t\t\t\t\t\t .add_sub_R(add_sub_R), .adder_en_R(adder_en_R), .shift_enable_R(shift_enable_R), .load_R(load_R), .clear_R(clear_R), .p2s_enable_R(p2s_enable_R));\n\t\t\t\t\t\t\t \n\tadder add_L (.a(add_inp_L), .b(shifted_L), .add_sub(add_sub_L), .adder_en(adder_en_L), .sum(sum_L));\n\t\n\tadder add_R (.a(add_inp_R), .b(shifted_R), .add_sub(add_sub_R), .adder_en(adder_en_R), .sum(sum_R));\n\t\n\tshift_acc shift_acc_L (.shift_enable(shift_enable_L), .load(load_L), .clear(clear_L), .sclk(Sclk_in), .blk_in(sum_L), .blk_out(shifted_L));\n\t\n\tshift_acc shift_acc_R (.shift_enable(shift_enable_R), .load(load_R), .clear(clear_R), .sclk(Sclk_in), .blk_in(sum_R), .blk_out(shifted_R));\n\t\n\tPISO PISO_L (.Sclk(Sclk_in), .Clear(Clear), .Frame(Frame_in), .Shifted(shifted_L), .Serial_out(OutputL), .p2s_enable(p2s_enable_L), .OutReady(OutReadyL));\n\t\n\tPISO PISO_R (.Sclk(Sclk_in), .Clear(Clear), .Frame(Frame_in), .Shifted(shifted_R), .Serial_out(OutputR), .p2s_enable(p2s_enable_R), .OutReady(OutReadyR));\n\n\tassign OutReady = OutReadyL || OutReadyR;\n\t\nendmodule\n\nmodule data_memory (input wr_en, rd_en, Sclk, input_rdy_flag,\n\t\t\t\t\tinput [7:0] data_wr_addr, data_rd_addr,\n\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\toutput [15:0] xin_data,\n\t\t\t\t\toutput reg zero_flag);\n\n\treg [15:0] data_mem [0:255];\n\treg [11:0] zero_cnt;\n\t\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\tdata_mem[data_wr_addr] = data_in;\n\t\telse\n\t\t\tdata_mem[data_wr_addr] = data_mem[data_wr_addr];\n\tend\n\n\talways @(posedge input_rdy_flag)\n\tbegin\n\t\tif (data_in == 16'd0)\n\t\tbegin\n\t\t\tzero_cnt = zero_cnt + 1'b1;\n\t\t\tif (zero_cnt == 12'd800)\n\t\t\t\tzero_flag = 1'b1;\n\t\t\telse if (zero_cnt > 12'd800)\n\t\t\tbegin\n\t\t\t\tzero_cnt = 12'd800;\n\t\t\t\tzero_flag = 1'b1;\n\t\t\tend\n\t\tend\t\t\n\t\telse if (data_in != 16'd0)\n\t\tbegin\n\t\t\tzero_cnt = 12'd0;\n\t\t\tzero_flag = 1'b0;\n\t\tend\n\tend\n\n\tassign xin_data = (rd_en) ? data_mem[data_rd_addr] : 16'd0;\nendmodule\n\nmodule coeff_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\t\tinput [8:0] coeff_wr_addr, coeff_rd_addr,\n\t\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\t\toutput [15:0] coeff_data);\n\n\treg [15:0] coeff_mem [0:511];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\tcoeff_mem[coeff_wr_addr] = data_in;\n\t\telse\n\t\t\tcoeff_mem[coeff_wr_addr] = coeff_mem[coeff_wr_addr];\t\t\n\tend\n\n\tassign coeff_data = (rd_en) ? coeff_mem[coeff_rd_addr] : 16'd0;\nendmodule\n\nmodule alu_controller (\n\tinput compute_enable,\n\tinput Clear,\n\tinput Sclk,\n\tinput sleep_flag,\n\t\n\tinput [15:0] rj_data_L, coeff_data_L, xin_data_L,\n\tinput [15:0] rj_data_R, coeff_data_R, xin_data_R,\n\t\n\toutput [39:0] add_inp_L, add_inp_R,\n\t\n\toutput reg [3:0] rj_addr_L,\n\toutput reg [8:0] coeff_addr_L,\n\toutput reg [7:0] xin_addr_L,\n\t\n\toutput reg [3:0] rj_addr_R,\n\toutput reg [8:0] coeff_addr_R,\n\toutput reg [7:0] xin_addr_R,\n\t\n\toutput reg rj_en_L, coeff_en_L, xin_en_L,\n\toutput reg rj_en_R, coeff_en_R, xin_en_R,\n\t\n\toutput reg add_sub_L, adder_en_L, shift_enable_L, load_L, clear_L, p2s_enable_L,\n\toutput reg add_sub_R, adder_en_R, shift_enable_R, load_R, clear_R, p2s_enable_R\n\t);\n\t\n\tparameter initial_state = 2'b00, comp_state = 2'b01, sleep_state = 2'b10;\n\t\n\treg [1:0] pr_state_L, next_state_L;\n\treg [1:0] pr_state_R, next_state_R;\n\t\n\treg [7:0] x_count_L, x_index_L;\n\treg [7:0] x_count_R, x_index_R;\n\t\n\treg [7:0] k_L, k_R;\n\t\n\treg xmem_overflow_L, start_comp_L, compute_status_L, out_done_L;\n\treg xmem_overflow_R, start_comp_R, compute_status_R, out_done_R;\n\t\n\t\n\t\n\tassign add_inp_L = (xin_data_L[15]) ? {8'hFF, xin_data_L, 16'h0000} : {8'h00, xin_data_L, 16'h0000};\n\tassign add_inp_R = (xin_data_R[15]) ? {8'hFF, xin_data_R, 16'h0000} : {8'h00, xin_data_R, 16'h0000};\n\t\n\t\t\n\talways @(Clear, next_state_L)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\t\tpr_state_L <= initial_state;\n\t\telse\n\t\t\tpr_state_L <= next_state_L;\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\t\n\t\tcase (pr_state_L)\n\t\t\tinitial_state:\n\t\t\t\tbegin\n\t\t\t\t\txmem_overflow_L <= 1'b0;\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\t\t\tx_count_L <= 8'd1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\t\tx_count_L <= x_count_L;\n\t\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\n\t\t\tcomp_state:\n\t\t\t\tbegin\n\t\t\t\t\tif (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_L <= x_count_L + 1'b1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\t\tif (x_count_L == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_L <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\t\tif (rj_addr_L == 4'hF && coeff_addr_L == 9'h1FF && k_L == rj_data_L)\n\t\t\t\t\t\t\tcompute_status_L <= 1'b0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcompute_status_L <= compute_status_L;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b1)\n\t\t\t\t\t\tnext_state_L <= sleep_state;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\tend\n\t\t\t\n\t\t\tsleep_state:\n\t\t\t\tbegin\n\t\t\t\t\tx_count_L <= x_count_L;\n\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\tstart_comp_L <= 1'b0;\n\t\t\t\t\tcompute_status_L <= 1'b0;\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_L <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_L <= x_count_L + 1'b1;\n\t\t\t\t\t\tstart_comp_L <= 1'b1;\n\t\t\t\t\t\tcompute_status_L <= 1'b1;\n\t\t\t\t\t\tif (x_count_L == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_L <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_L <= xmem_overflow_L;\n\t\t\t\t\t\tnext_state_L <= comp_state;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_L <= sleep_state;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tdefault:\tnext_state_L <= initial_state;\n\t\tendcase\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\tif (out_done_L)\n\t\tbegin\n\t\t\tp2s_enable_L = 1'b1;\n\t\t\trj_addr_L = 4'd0;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tk_L = 8'd0;\n\t\t\tout_done_L = 1'b0;\n\t\t\tclear_L = 1'b1;\n\t\tend\n\t\telse\n\t\t\tp2s_enable_L = 1'b0;\n\t\t\n\t\tif (start_comp_L == 1'b1)\n\t\tbegin\n\t\t\tout_done_L = 1'b0;\n\t\t\trj_addr_L = 4'd0;\n\t\t\trj_en_L = 1'b1;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tcoeff_en_L = 1'b1;\n\t\t\txin_en_L = 1'b0;\n\t\t\tadder_en_L = 1'b0;\n\t\t\tshift_enable_L = 1'b0;\n\t\t\tk_L = 8'd0;\n\t\t\tclear_L = 1'b1;\n\t\t\tload_L = 1'b0;\n\t\tend\n\t\telse if (compute_status_L == 1'b1)\n\t\tbegin\n\t\t\tif (k_L == rj_data_L)\n\t\t\tbegin\n\t\t\t\txin_en_L = 1'b0;\n\t\t\t\tshift_enable_L = 1'b1;\n\t\t\t\tclear_L = 1'b0;\n\t\t\t\tload_L = 1'b1;\n\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\tk_L = 8'd0;\n\t\t\t\tif (rj_addr_L < 4'd15)\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_L = rj_addr_L + 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_L = 4'd0;\n\t\t\t\t\tout_done_L = 1'b1;\n\t\t\t\t\tcoeff_addr_L = 9'd0;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tshift_enable_L = 1'b0;\n\t\t\t\tclear_L = 1'b0;\n\t\t\t\tload_L = 1'b0;\n\t\t\t\txin_en_L = 1'b0;\n\t\t\t\tx_index_L = coeff_data_L[7:0];\n\t\t\t\tadd_sub_L = coeff_data_L[8];\n\t\t\t\tif (x_count_L - 1'b1 >= x_index_L)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = x_count_L - 1'b1 - x_index_L;\n\t\t\t\t\txin_en_L = 1'b1;\n\t\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\t\tload_L = 1'b1;\n\t\t\t\tend\n\t\t\t\telse if (x_count_L - 1'b1 < x_index_L && xmem_overflow_L == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = x_count_L - 1'b1 + (9'd256 - x_index_L);\n\t\t\t\t\txin_en_L = 1'b1;\n\t\t\t\t\tadder_en_L = 1'b1;\n\t\t\t\t\tload_L = 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_L = xin_addr_L;\n\t\t\t\t\tadder_en_L = 1'b0;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif (coeff_addr_L < 9'h1FF)\n\t\t\t\t\tcoeff_addr_L = coeff_addr_L + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tcoeff_addr_L = coeff_addr_L;\n\t\t\t\t\n\t\t\t\tk_L = k_L + 1'b1;\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trj_addr_L = 4'd0;\n\t\t\trj_en_L = 1'b0;\n\t\t\tcoeff_addr_L = 9'd0;\n\t\t\tcoeff_en_L = 1'b0;\n\t\t\txin_en_L = 1'b0;\n\t\t\tadder_en_L = 1'b0;\n\t\t\tshift_enable_L = 1'b0;\n\t\t\tk_L = 8'd0;\n\t\t\tload_L = 1'b0;\n\t\t\tclear_L = 1'b1;\n\t\tend\n\tend\n\t\n\t\n\n\n\n\t\n\t\n\t\n\t\n\talways @(Clear, next_state_R)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\t\tpr_state_R <= initial_state;\n\t\telse\n\t\t\tpr_state_R <= next_state_R;\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\t\n\t\tcase (pr_state_R)\n\t\t\tinitial_state:\n\t\t\t\tbegin\n\t\t\t\t\txmem_overflow_R <= 1'b0;\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\telse if (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\t\t\tx_count_R <= 8'd1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\t\tx_count_R <= x_count_R;\n\t\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\n\t\t\tcomp_state:\n\t\t\t\tbegin\n\t\t\t\t\tif (compute_enable == 1'b1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_R <= x_count_R + 1'b1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\t\tif (x_count_R == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_R <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\t\tif (rj_addr_R == 4'hF && coeff_addr_R == 9'h1FF && k_R == rj_data_R)\n\t\t\t\t\t\t\tcompute_status_R <= 1'b0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcompute_status_R <= compute_status_R;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\tend\n\t\t\t\n\t\t\tsleep_state:\n\t\t\t\tbegin\n\t\t\t\t\tx_count_R <= x_count_R;\n\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\tstart_comp_R <= 1'b0;\n\t\t\t\t\tcompute_status_R <= 1'b0;\n\t\t\t\t\tif (Clear == 1'b1)\n\t\t\t\t\t\tnext_state_R <= initial_state;\n\t\t\t\t\telse if (sleep_flag == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tx_count_R <= x_count_R + 1'b1;\n\t\t\t\t\t\tstart_comp_R <= 1'b1;\n\t\t\t\t\t\tcompute_status_R <= 1'b1;\n\t\t\t\t\t\tif (x_count_R == 8'hFF)\n\t\t\t\t\t\t\txmem_overflow_R <= 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmem_overflow_R <= xmem_overflow_R;\n\t\t\t\t\t\tnext_state_R <= comp_state;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state_R <= sleep_state;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tbegin\n\t\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge Sclk)\n\tbegin\n\t\tif (out_done_R)\n\t\tbegin\n\t\t\tp2s_enable_R = 1'b1;\n\t\t\trj_addr_R = 4'd0;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tk_R = 8'd0;\n\t\t\tout_done_R = 1'b0;\n\t\tend\n\t\telse\n\t\t\tp2s_enable_R = 1'b0;\n\t\t\n\t\tif (start_comp_R == 1'b1)\n\t\tbegin\n\t\t\tout_done_R = 1'b0;\n\t\t\trj_addr_R = 4'd0;\n\t\t\trj_en_R = 1'b1;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tcoeff_en_R = 1'b1;\n\t\t\txin_en_R = 1'b0;\n\t\t\tadder_en_R = 1'b0;\n\t\t\tshift_enable_R = 1'b0;\n\t\t\tk_R = 8'd0;\n\t\t\tclear_R = 1'b1;\n\t\t\tload_R = 1'b0;\n\t\tend\n\t\telse if (compute_status_R == 1'b1)\n\t\tbegin\n\t\t\tif (k_R == rj_data_R)\n\t\t\tbegin\n\t\t\t\txin_en_R = 1'b0;\n\t\t\t\tshift_enable_R = 1'b1;\n\t\t\t\tclear_R = 1'b0;\n\t\t\t\tload_R = 1'b1;\n\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\tk_R = 8'd0;\n\t\t\t\tif (rj_addr_R < 4'd15)\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_R = rj_addr_R + 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trj_addr_R = 4'd0;\n\t\t\t\t\tout_done_R = 1'b1;\n\t\t\t\t\tcoeff_addr_R = 9'd0;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tshift_enable_R = 1'b0;\n\t\t\t\tclear_R = 1'b0;\n\t\t\t\tload_R = 1'b0;\n\t\t\t\txin_en_R = 1'b0;\n\t\t\t\tx_index_R = coeff_data_R[7:0];\n\t\t\t\tadd_sub_R = coeff_data_R[8];\n\t\t\t\tif (x_count_R - 1'b1 >= x_index_R)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = x_count_R - 1'b1 - x_index_R;\n\t\t\t\t\txin_en_R = 1'b1;\n\t\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\t\tload_R = 1'b1;\n\t\t\t\tend\n\t\t\t\telse if (x_count_R - 1'b1 < x_index_R && xmem_overflow_R == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = x_count_R - 1'b1 + (9'd256 - x_index_R);\n\t\t\t\t\txin_en_R = 1'b1;\n\t\t\t\t\tadder_en_R = 1'b1;\n\t\t\t\t\tload_R = 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\txin_addr_R = xin_addr_R;\n\t\t\t\t\tadder_en_R = 1'b0;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif (coeff_addr_R < 9'h1FF)\n\t\t\t\t\tcoeff_addr_R = coeff_addr_R + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tcoeff_addr_R = coeff_addr_R;\n\t\t\t\t\n\t\t\t\tk_R = k_R + 1'b1;\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trj_addr_R = 4'd0;\n\t\t\trj_en_R = 1'b0;\n\t\t\tcoeff_addr_R = 9'd0;\n\t\t\tcoeff_en_R = 1'b0;\n\t\t\txin_en_R = 1'b0;\n\t\t\tadder_en_R = 1'b0;\n\t\t\tshift_enable_R = 1'b0;\n\t\t\tk_R = 8'd0;\n\t\t\tload_R = 1'b0;\n\t\t\tclear_R = 1'b1;\n\t\tend\n\tend\n\t\n\t\n\n\n\n\t\nendmodule\n\nmodule adder(\n\tinput [39:0] a,\n    input [39:0] b,\n    input add_sub,\n\tinput adder_en,\n    output [39:0] sum\n    );\n\n\t\tassign sum = (add_sub == 1'b1) ? (b - a) : \n\t\t\t\t\t\t (add_sub == 1'b0) ? (b + a) :\n\t\t\t\t\t\t \tsum;\t\n\nendmodule\n\nmodule SIPO (Frame, Dclk, Clear, InputL, InputR, data_L, data_R, input_rdy_flag);\n\tinput Frame, Dclk, Clear, InputL, InputR;\n\toutput reg input_rdy_flag;\n\toutput reg [15:0] data_L;\n\toutput reg [15:0] data_R;\n\treg [3:0] bit_count;\n\treg frame_status;\n\n\talways @(negedge Dclk or posedge Clear)\n\tbegin\n\t\tif (Clear == 1'b1)\n\t\tbegin\n\t\t\tbit_count = 4'd15;\n\t\t\t\n\t\t\t\n\t\t\tdata_L = 16'd0;\n\t\t\tdata_R = 16'd0;\t\t\t\n\t\t\tinput_rdy_flag = 1'b0;\n\t\t\tframe_status = 1'b0;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tif (Frame == 1'b1)\n\t\t\tbegin\n\t\t\t\tbit_count = 4'd15;\n\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\tdata_L [bit_count] = InputL;\n\t\t\t\tdata_R [bit_count] = InputR;\n\t\t\t\tframe_status = 1'b1;\n\t\t\tend\n\t\t\telse if (frame_status == 1'b1)\n\t\t\tbegin\n\t\t\t\tbit_count = bit_count - 1'b1;\n\t\t\t\tdata_L [bit_count] = InputL;\n\t\t\t\tdata_R [bit_count] = InputR;\n\t\t\t\tif (bit_count == 4'd0)\n\t\t\t\tbegin\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tinput_rdy_flag = 1'b1;\n\t\t\t\t\tframe_status = 1'b0;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\t\tframe_status = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tbit_count = 4'd15;\n\t\t\t\tdata_L = 16'd0;\n\t\t\t\tdata_R = 16'd0;\t\t\t\n\t\t\t\tinput_rdy_flag = 1'b0;\n\t\t\t\tframe_status = 1'b0;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: shift_acc. Module specification: The shift_acc module implements a 40-bit shift accumulator with load, clear, and shift functionalities. It has input ports for shift_enable (controls shifting), load (enables loading new data), clear (resets accumulator), sclk (clock input), and blk_in[39:0] (40-bit input data). The output port is blk_out[39:0] (40-bit output data). Internally, it uses a 40-bit register shift_acc_reg to store and manipulate data. The module's main block is a synchronous always block triggered on the positive edge of sclk. This block handles clearing the accumulator, loading new data with optional shifting, and maintaining the current value based on input signals. The module can perform right shifts when enabled, making it suitable for digital signal processing applications that require accumulation and shifting operations."
                }
            ]
        }
    ]
}