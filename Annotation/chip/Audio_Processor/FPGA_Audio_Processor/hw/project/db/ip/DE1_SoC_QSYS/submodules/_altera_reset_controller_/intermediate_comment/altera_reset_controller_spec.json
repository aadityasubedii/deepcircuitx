{
    "spec": "Module name: altera_reset_controller.\n\nModule specification: \nThe altera_reset_controller module is a highly configurable RTL design serving as a reset controller, managing and synchronizing reset signals in the hardware. \nIts inputs include up to 16 individual reset and reset request signals, a clock signal, and a number parameters that define the behavior and configuration of the module itself. \nThese parameters govern the number of reset signals, whether to use a reset request input for each reset, the number of edges to synchronize, depths on synchronization, wait times, early de-assert times and adaptive reset requests. The reset inputs are hardware reset signals sources while the reset request inputs serve as request signals for each reset input. The clock signal times the synchronous behavior of the module.\nThe outputs of this module are a synchronized reset signal and a reset request that merge the input signals based on certain configurations.\nFurther, there are a string of internal signals and parameters that guide the behavior of the module. These include, but are not limited to, parameters that check if the output reset is asynchronous, some parameters and signals for various timing calculations, a unified reset and request reset signal, pre-final stage output reset and request reset processing signals and a series of logic and synchronization registers.\nThe code is segmented into various blocks with the initial part of the code setting up these inputs, parameters and internal signals. This is followed by logic that merges the reset and reset request inputs, then the synchronization of the reset and reset request inputs. The process of generating pre-final stage output signals, the final stage of computation of the output reset and request signals based on multiple parameters and dependencies with complex synchronization logic is done next. The logic of output reset is further enhanced and developed in the next stages if there is no RESET_REQUEST_PRESENT or for adaptive reset requests scenario. This intricate process ensures the accurate synchronization and triggering of reset signals for systems with multiple sources of potential reset triggers.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller. \nExplanation: This module seems to serve as a reset controller used for managing reset signals in the hardware. The parameter list suggests significant configurability, including the number of reset inputs and various timing configurations. It deals with merging multiple reset and reset request signals, synchronizes these signals (if necessary, based on the parameters), and manages early reset conditions. Its outputs are a synchronized reset signal and a reset request. It uses several internal parameters and wiring schemes to master the timing of the reset and reset requests as configured."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports: \n\n1. reset_in0 to reset_in15: These are direct reset signals that can be triggered independently. They are merged inside the module to create a single reset input.\n\n2. reset_req_in0 to reset_req_in15: These are corresponding reset request inputs for each direct reset input.\n\n3. clk: This is the clock signal which governs the synchronous logic inside the module.\n\n4. NUM_RESET_INPUTS, USE_RESET_REQUEST_INX (where X ranges from 0 to 15), OUTPUT_RESET_SYNC_EDGES, SYNC_DEPTH, RESET_REQUEST_PRESENT, RESET_REQ_WAIT_TIME, MIN_RST_ASSERTION_TIME, RESET_REQ_EARLY_DSRT_TIME, ADAPT_RESET_REQUEST: These are parameters that control aspects such as the number of resets, whether or not to use a reset request input, depths on synchronization, wait times, early de-assert times, etc.\n\nExplanation: Reset inputs are sources of hardware reset signals. These can come from different sources, like a user pressing a reset button, or another system module causing a reset. Reset request inputs are request signals for each reset input. The clock signal is for timing the synchronous behavior of the module. The parameters define the behavior and configuration of the module itself. \n\nOutput Ports: \n\n1. reset_out: This output represents the synchronized result of the combined reset input signals.\n\n2. reset_req: This output emits the early reset request signal representing the combined reset request input signals.\n\nExplanation: The reset output is a merged version of all input resets that is synchronized according to the parameters set. This signal is used by other modules to reset their states. The reset request signal is created in a similar way, used to signal other modules that a reset is going to happen soon."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: \n\n1. ASYNC_RESET\n2. MIN_METASTABLE\n3. RSTREQ_ASRT_SYNC_TAP\n4. LARGER\n5. ASSERTION_CHAIN_LENGTH\n6. RESET_REQ_DRST_TAP\n7. merged_reset\n8. merged_reset_req_in\n9. reset_out_pre\n10. reset_req_pre\n11. altera_reset_synchronizer_int_chain\n12. r_sync_rst_chain\n13. r_sync_rst\n14. r_early_rst\n15. reset_out_pre2\n\nExplanation: \n\n1. ASYNC_RESET: This is a local parameter that checks if the output reset is asynchronous, based on the OUTPUT_RESET_SYNC_EDGES parameter.\n\n2. MIN_METASTABLE: This local parameter is assigned a default value of 3 and is used in timing calculations throughout the module.\n\n3. RSTREQ_ASRT_SYNC_TAP: This local parameter is calculated based on the MIN_METASTABLE and RESET_REQ_WAIT_TIME parameters and used for synchronization of reset requests.\n\n4. LARGER: This local parameter calculates which parameter, RESET_REQ_WAIT_TIME or RESET_REQ_EARLY_DSRT_TIME, is larger, and used in the calculation of the ASSERTION_CHAIN_LENGTH.\n\n5. ASSERTION_CHAIN_LENGTH: This defines the length of the reset assertion chain, calculated based on other parameters.\n\n6. RESET_REQ_DRST_TAP: It calculates the reset request early deassert time.\n\n7. merged_reset: This signal is the combined reset of all the individual reset inputs.\n\n8. merged_reset_req_in: This signal is the merged result of all the individual reset request inputs as per their usage configuration.\n\n9. reset_out_pre: This signal holds the pre-final stage of the output reset processing, which is fed into further processing or directly output depending on logic conditions.\n\n10. reset_req_pre: This signal holds the pre-final stage of the reset request processing, similar to reset_out_pre.\n\n11. altera_reset_synchronizer_int_chain: This register chain is involved in reset synchronization logic.\n\n12. r_sync_rst_chain: This register chain is involved in another part of the reset synchronization logic.\n\n13. r_sync_rst: This register evolves with sync reset logic based on altera_reset_synchronizer_int_chain and r_sync_rst_chain register's states.\n\n14. r_early_rst: This register evolves with early reset logic based on r_sync_rst_chain register's states and reset request signal reset_req_pre.\n\n15. reset_out_pre2: This is used in a specific condition when there is no formal RESET_REQUEST_PRESENT but adaptive reset requests are allowed, and holds the processed output reset after passing through an additional level of synchronization.\n"
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_reset_controller.\n\nModule specification: \nThe altera_reset_controller module is a highly configurable RTL design serving as a reset controller, managing and synchronizing reset signals in the hardware. \nIts inputs include up to 16 individual reset and reset request signals, a clock signal, and a number parameters that define the behavior and configuration of the module itself. \nThese parameters govern the number of reset signals, whether to use a reset request input for each reset, the number of edges to synchronize, depths on synchronization, wait times, early de-assert times and adaptive reset requests. The reset inputs are hardware reset signals sources while the reset request inputs serve as request signals for each reset input. The clock signal times the synchronous behavior of the module.\nThe outputs of this module are a synchronized reset signal and a reset request that merge the input signals based on certain configurations.\nFurther, there are a string of internal signals and parameters that guide the behavior of the module. These include, but are not limited to, parameters that check if the output reset is asynchronous, some parameters and signals for various timing calculations, a unified reset and request reset signal, pre-final stage output reset and request reset processing signals and a series of logic and synchronization registers.\nThe code is segmented into various blocks with the initial part of the code setting up these inputs, parameters and internal signals. This is followed by logic that merges the reset and reset request inputs, then the synchronization of the reset and reset request inputs. The process of generating pre-final stage output signals, the final stage of computation of the output reset and request signals based on multiple parameters and dependencies with complex synchronization logic is done next. The logic of output reset is further enhanced and developed in the next stages if there is no RESET_REQUEST_PRESENT or for adaptive reset requests scenario. This intricate process ensures the accurate synchronization and triggering of reset signals for systems with multiple sources of potential reset triggers."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller. \nExplanation: This module seems to serve as a reset controller used for managing reset signals in the hardware. The parameter list suggests significant configurability, including the number of reset inputs and various timing configurations. It deals with merging multiple reset and reset request signals, synchronizes these signals (if necessary, based on the parameters), and manages early reset conditions. Its outputs are a synchronized reset signal and a reset request. It uses several internal parameters and wiring schemes to master the timing of the reset and reset requests as configured."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports: \n\n1. reset_in0 to reset_in15: These are direct reset signals that can be triggered independently. They are merged inside the module to create a single reset input.\n\n2. reset_req_in0 to reset_req_in15: These are corresponding reset request inputs for each direct reset input.\n\n3. clk: This is the clock signal which governs the synchronous logic inside the module.\n\n4. NUM_RESET_INPUTS, USE_RESET_REQUEST_INX (where X ranges from 0 to 15), OUTPUT_RESET_SYNC_EDGES, SYNC_DEPTH, RESET_REQUEST_PRESENT, RESET_REQ_WAIT_TIME, MIN_RST_ASSERTION_TIME, RESET_REQ_EARLY_DSRT_TIME, ADAPT_RESET_REQUEST: These are parameters that control aspects such as the number of resets, whether or not to use a reset request input, depths on synchronization, wait times, early de-assert times, etc.\n\nExplanation: Reset inputs are sources of hardware reset signals. These can come from different sources, like a user pressing a reset button, or another system module causing a reset. Reset request inputs are request signals for each reset input. The clock signal is for timing the synchronous behavior of the module. The parameters define the behavior and configuration of the module itself. \n\nOutput Ports: \n\n1. reset_out: This output represents the synchronized result of the combined reset input signals.\n\n2. reset_req: This output emits the early reset request signal representing the combined reset request input signals.\n\nExplanation: The reset output is a merged version of all input resets that is synchronized according to the parameters set. This signal is used by other modules to reset their states. The reset request signal is created in a similar way, used to signal other modules that a reset is going to happen soon."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: \n\n1. ASYNC_RESET\n2. MIN_METASTABLE\n3. RSTREQ_ASRT_SYNC_TAP\n4. LARGER\n5. ASSERTION_CHAIN_LENGTH\n6. RESET_REQ_DRST_TAP\n7. merged_reset\n8. merged_reset_req_in\n9. reset_out_pre\n10. reset_req_pre\n11. altera_reset_synchronizer_int_chain\n12. r_sync_rst_chain\n13. r_sync_rst\n14. r_early_rst\n15. reset_out_pre2\n\nExplanation: \n\n1. ASYNC_RESET: This is a local parameter that checks if the output reset is asynchronous, based on the OUTPUT_RESET_SYNC_EDGES parameter.\n\n2. MIN_METASTABLE: This local parameter is assigned a default value of 3 and is used in timing calculations throughout the module.\n\n3. RSTREQ_ASRT_SYNC_TAP: This local parameter is calculated based on the MIN_METASTABLE and RESET_REQ_WAIT_TIME parameters and used for synchronization of reset requests.\n\n4. LARGER: This local parameter calculates which parameter, RESET_REQ_WAIT_TIME or RESET_REQ_EARLY_DSRT_TIME, is larger, and used in the calculation of the ASSERTION_CHAIN_LENGTH.\n\n5. ASSERTION_CHAIN_LENGTH: This defines the length of the reset assertion chain, calculated based on other parameters.\n\n6. RESET_REQ_DRST_TAP: It calculates the reset request early deassert time.\n\n7. merged_reset: This signal is the combined reset of all the individual reset inputs.\n\n8. merged_reset_req_in: This signal is the merged result of all the individual reset request inputs as per their usage configuration.\n\n9. reset_out_pre: This signal holds the pre-final stage of the output reset processing, which is fed into further processing or directly output depending on logic conditions.\n\n10. reset_req_pre: This signal holds the pre-final stage of the reset request processing, similar to reset_out_pre.\n\n11. altera_reset_synchronizer_int_chain: This register chain is involved in reset synchronization logic.\n\n12. r_sync_rst_chain: This register chain is involved in another part of the reset synchronization logic.\n\n13. r_sync_rst: This register evolves with sync reset logic based on altera_reset_synchronizer_int_chain and r_sync_rst_chain register's states.\n\n14. r_early_rst: This register evolves with early reset logic based on r_sync_rst_chain register's states and reset request signal reset_req_pre.\n\n15. reset_out_pre2: This is used in a specific condition when there is no formal RESET_REQUEST_PRESENT but adaptive reset requests are allowed, and holds the processed output reset after passing through an additional level of synchronization.\n"
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_reset_controller.\n\nModule specification: \nThe altera_reset_controller module is a highly configurable RTL design serving as a reset controller, managing and synchronizing reset signals in the hardware. \nIts inputs include up to 16 individual reset and reset request signals, a clock signal, and a number parameters that define the behavior and configuration of the module itself. \nThese parameters govern the number of reset signals, whether to use a reset request input for each reset, the number of edges to synchronize, depths on synchronization, wait times, early de-assert times and adaptive reset requests. The reset inputs are hardware reset signals sources while the reset request inputs serve as request signals for each reset input. The clock signal times the synchronous behavior of the module.\nThe outputs of this module are a synchronized reset signal and a reset request that merge the input signals based on certain configurations.\nFurther, there are a string of internal signals and parameters that guide the behavior of the module. These include, but are not limited to, parameters that check if the output reset is asynchronous, some parameters and signals for various timing calculations, a unified reset and request reset signal, pre-final stage output reset and request reset processing signals and a series of logic and synchronization registers.\nThe code is segmented into various blocks with the initial part of the code setting up these inputs, parameters and internal signals. This is followed by logic that merges the reset and reset request inputs, then the synchronization of the reset and reset request inputs. The process of generating pre-final stage output signals, the final stage of computation of the output reset and request signals based on multiple parameters and dependencies with complex synchronization logic is done next. The logic of output reset is further enhanced and developed in the next stages if there is no RESET_REQUEST_PRESENT or for adaptive reset requests scenario. This intricate process ensures the accurate synchronization and triggering of reset signals for systems with multiple sources of potential reset triggers."
                }
            ]
        }
    ]
}