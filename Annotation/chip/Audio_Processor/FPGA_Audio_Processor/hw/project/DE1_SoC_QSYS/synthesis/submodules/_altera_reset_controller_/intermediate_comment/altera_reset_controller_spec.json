{
    "spec": "Module name: altera_reset_controller. \n\nModule specification: The altera_reset_controller is a module designed to manage and synchronize reset signals in a digital system, using various parameters to allow adaptive configuration. The module's functionality includes the acceptance of multiple reset signals and reset requests, using these inputs to assert an output reset and reset request signal depending on the system state and parameters.\n\nInput ports include 16 reset signals (reset_in0 to reset_in15) serving as external reset signals, and 16 reset request signals (reset_req_in0 to reset_req_in15) serving to assert the request for reset. Additionally, a clock input (clk) is included, which is required for system synchronization.\n\nOutput ports include a reset output signal (reset_out) that merges all reset inputs post synchronization. A reset request output signal (reset_req) is also provided, which is determined by the earliest of reset requests.\n\nSeveral internal signals are parallelly managed within the altera_reset_controller like ASYNC_RESET, reset_out_pre, altera_reset_synchronizer_int_chain, r_sync_rst_chain. These are utilized in synchronization, merging reset inputs, manage metastability and also generate final reset and reset request signal.\n\nThe code is divided into several blocks including parameter definition, input-output definition, internal parameter definition, and signal synchronization. This includes synchronizers for reset and reset request signals. The module also includes the code for managing reset and reset request chains internally. In the end, it has the code to generate final reset and reset request signals through several conditions and parameters. The module is well organized and detailed in nature, providing a comprehensive solution for complex reset signal synchronization.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller. \nExplanation: This module is a reset controller intended to manage and synchronize reset signals, possibly in a larger digital system. Various input parameters and local parameters allow flexibility in its configuration, allowing it to adapt to different system constraints. The module accepts multiple reset signals and reset request signals. It uses these inputs along with its internal configuration to generate an output reset signal and reset request signal. The module further includes inbuilt synchronizers to synchronize these reset signals with a clock to prevent metastability. It also provides different mechanisms to control the assertion and deassertion of the reset signal based on the various parameters provided."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset_in0 to reset_in15: These are the reset input signals. They are expected to be external reset signals that should restart the state machines or counters etc. in hardware.\n2. reset_req_in0 to reset_req_in15: These are the reset requests. When a request is made, and if the resource is not occupied already by a higher priority reset request, the output reset signal will be asserted immediately, and de-asserted after the requisite number of wait intervals, dictated by the module's parameters.\n3. clk: The clock input, which is used to synchronize the actions of the system.\n\nOutput ports: \n1. reset_out: This is the reset output signal. It corresponds to the merged reset signal after accounting for reset requests and applying needed synchronization. \n2. reset_req: This is the reset request output signal. This is determined by the earliest of reset requests and some conditions, so that the final output reset signal resets as quickly as possible after a request arrives.\n\nExplanation: In the Verilog module, the reset_in and reset_req_in inputs are handled inside the module to give reset_out and reset_req signals. Inputs are synchronized, potentially delayed, and then merged to give just one output reset and one reset request signal. Reset controller makes sure that reset signals behave as expected even when they arrive unexpectedly or very close to the clock edge."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: \n1. ASYNC_RESET \n2. MIN_METASTABLE \n3. RSTREQ_ASRT_SYNC_TAP \n4. LARGER \n5. ASSERTION_CHAIN_LENGTH \n6. RESET_REQ_DRST_TAP \n7. merged_reset \n8. merged_reset_req_in \n9. reset_out_pre \n10.reset_req_pre\n11. altera_reset_synchronizer_int_chain\n12. r_sync_rst_chain \n13. r_sync_rst\n14. r_early_rst\n15. reset_out_pre2\n\nExplanation: \n\n1. ASYNC_RESET: This signal is a parameter that controls whether the reset signal is synchronized with the clock or not.\n\n2. MIN_METASTABLE: This parameter is utilized to tolerate metastability in the system, which is a state when a signal input falls right near or on the clock edge, leading to uncertainty.\n\n3. RSTREQ_ASRT_SYNC_TAP: This constant derived from MIN_METASTABLE represents how many clock cycles it takes for a reset request to assert.\n\n4. LARGER: This is a derived parameter that contains the larger of two other parameters - RESET_REQ_WAIT_TIME and RESET_REQ_EARLY_DSRT_TIME.\n\n5. ASSERTION_CHAIN_LENGTH: This is computed based on different parameters and represents the length of the reset assertion chain.\n\n6. RESET_REQ_DRST_TAP: This is just one more than parameter RESET_REQ_EARLY_DSRT_TIME.\n\n7. merged_reset: This wire is the result of OR'ing all reset inputs.\n\n8. merged_reset_req_in: Similar to merged_reset, this is the OR'ed result of reset requests.\n\n9. reset_out_pre, reset_req_pre: These are reset and reset request signals after passing through the reset synchronizer logic.\n\n10. altera_reset_synchronizer_int_chain: This is a shift register chain that used to detect a high to low transition in the reset_out_pre signal.\n\n11. r_sync_rst_chain: Another shift register chain that is used to delay reset_out_pre by a defined number of clock cycles.\n\n12. r_sync_rst, r_early_rst: These are the final reset and reset request signals right before they are outputted.\n\n13. reset_out_pre2: In some conditions, reset_out_pre is passed thru one more synchronizer stage to generate this signal and used for reset_out."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_reset_controller. \n\nModule specification: The altera_reset_controller is a module designed to manage and synchronize reset signals in a digital system, using various parameters to allow adaptive configuration. The module's functionality includes the acceptance of multiple reset signals and reset requests, using these inputs to assert an output reset and reset request signal depending on the system state and parameters.\n\nInput ports include 16 reset signals (reset_in0 to reset_in15) serving as external reset signals, and 16 reset request signals (reset_req_in0 to reset_req_in15) serving to assert the request for reset. Additionally, a clock input (clk) is included, which is required for system synchronization.\n\nOutput ports include a reset output signal (reset_out) that merges all reset inputs post synchronization. A reset request output signal (reset_req) is also provided, which is determined by the earliest of reset requests.\n\nSeveral internal signals are parallelly managed within the altera_reset_controller like ASYNC_RESET, reset_out_pre, altera_reset_synchronizer_int_chain, r_sync_rst_chain. These are utilized in synchronization, merging reset inputs, manage metastability and also generate final reset and reset request signal.\n\nThe code is divided into several blocks including parameter definition, input-output definition, internal parameter definition, and signal synchronization. This includes synchronizers for reset and reset request signals. The module also includes the code for managing reset and reset request chains internally. In the end, it has the code to generate final reset and reset request signals through several conditions and parameters. The module is well organized and detailed in nature, providing a comprehensive solution for complex reset signal synchronization."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_reset_controller. \nExplanation: This module is a reset controller intended to manage and synchronize reset signals, possibly in a larger digital system. Various input parameters and local parameters allow flexibility in its configuration, allowing it to adapt to different system constraints. The module accepts multiple reset signals and reset request signals. It uses these inputs along with its internal configuration to generate an output reset signal and reset request signal. The module further includes inbuilt synchronizers to synchronize these reset signals with a clock to prevent metastability. It also provides different mechanisms to control the assertion and deassertion of the reset signal based on the various parameters provided."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: \n1. reset_in0 to reset_in15: These are the reset input signals. They are expected to be external reset signals that should restart the state machines or counters etc. in hardware.\n2. reset_req_in0 to reset_req_in15: These are the reset requests. When a request is made, and if the resource is not occupied already by a higher priority reset request, the output reset signal will be asserted immediately, and de-asserted after the requisite number of wait intervals, dictated by the module's parameters.\n3. clk: The clock input, which is used to synchronize the actions of the system.\n\nOutput ports: \n1. reset_out: This is the reset output signal. It corresponds to the merged reset signal after accounting for reset requests and applying needed synchronization. \n2. reset_req: This is the reset request output signal. This is determined by the earliest of reset requests and some conditions, so that the final output reset signal resets as quickly as possible after a request arrives.\n\nExplanation: In the Verilog module, the reset_in and reset_req_in inputs are handled inside the module to give reset_out and reset_req signals. Inputs are synchronized, potentially delayed, and then merged to give just one output reset and one reset request signal. Reset controller makes sure that reset signals behave as expected even when they arrive unexpectedly or very close to the clock edge."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: \n1. ASYNC_RESET \n2. MIN_METASTABLE \n3. RSTREQ_ASRT_SYNC_TAP \n4. LARGER \n5. ASSERTION_CHAIN_LENGTH \n6. RESET_REQ_DRST_TAP \n7. merged_reset \n8. merged_reset_req_in \n9. reset_out_pre \n10.reset_req_pre\n11. altera_reset_synchronizer_int_chain\n12. r_sync_rst_chain \n13. r_sync_rst\n14. r_early_rst\n15. reset_out_pre2\n\nExplanation: \n\n1. ASYNC_RESET: This signal is a parameter that controls whether the reset signal is synchronized with the clock or not.\n\n2. MIN_METASTABLE: This parameter is utilized to tolerate metastability in the system, which is a state when a signal input falls right near or on the clock edge, leading to uncertainty.\n\n3. RSTREQ_ASRT_SYNC_TAP: This constant derived from MIN_METASTABLE represents how many clock cycles it takes for a reset request to assert.\n\n4. LARGER: This is a derived parameter that contains the larger of two other parameters - RESET_REQ_WAIT_TIME and RESET_REQ_EARLY_DSRT_TIME.\n\n5. ASSERTION_CHAIN_LENGTH: This is computed based on different parameters and represents the length of the reset assertion chain.\n\n6. RESET_REQ_DRST_TAP: This is just one more than parameter RESET_REQ_EARLY_DSRT_TIME.\n\n7. merged_reset: This wire is the result of OR'ing all reset inputs.\n\n8. merged_reset_req_in: Similar to merged_reset, this is the OR'ed result of reset requests.\n\n9. reset_out_pre, reset_req_pre: These are reset and reset request signals after passing through the reset synchronizer logic.\n\n10. altera_reset_synchronizer_int_chain: This is a shift register chain that used to detect a high to low transition in the reset_out_pre signal.\n\n11. r_sync_rst_chain: Another shift register chain that is used to delay reset_out_pre by a defined number of clock cycles.\n\n12. r_sync_rst, r_early_rst: These are the final reset and reset request signals right before they are outputted.\n\n13. reset_out_pre2: In some conditions, reset_out_pre is passed thru one more synchronizer stage to generate this signal and used for reset_out."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1 ns / 1 ns\n\nmodule altera_reset_controller\n#(\n    parameter NUM_RESET_INPUTS              = 6,\n    parameter USE_RESET_REQUEST_IN0 = 0,\n    parameter USE_RESET_REQUEST_IN1 = 0,\n    parameter USE_RESET_REQUEST_IN2 = 0,\n    parameter USE_RESET_REQUEST_IN3 = 0,\n    parameter USE_RESET_REQUEST_IN4 = 0,\n    parameter USE_RESET_REQUEST_IN5 = 0,\n    parameter USE_RESET_REQUEST_IN6 = 0,\n    parameter USE_RESET_REQUEST_IN7 = 0,\n    parameter USE_RESET_REQUEST_IN8 = 0,\n    parameter USE_RESET_REQUEST_IN9 = 0,\n    parameter USE_RESET_REQUEST_IN10 = 0,\n    parameter USE_RESET_REQUEST_IN11 = 0,\n    parameter USE_RESET_REQUEST_IN12 = 0,\n    parameter USE_RESET_REQUEST_IN13 = 0,\n    parameter USE_RESET_REQUEST_IN14 = 0,\n    parameter USE_RESET_REQUEST_IN15 = 0,\n    parameter OUTPUT_RESET_SYNC_EDGES       = \"deassert\",\n    parameter SYNC_DEPTH                    = 2,\n    parameter RESET_REQUEST_PRESENT         = 0,\n    parameter RESET_REQ_WAIT_TIME           = 3,\n    parameter MIN_RST_ASSERTION_TIME        = 11,\n    parameter RESET_REQ_EARLY_DSRT_TIME     = 4,\n    parameter ADAPT_RESET_REQUEST          = 0\n)\n(\n    \n    \n    \n    input reset_in0,\n    input reset_in1,\n    input reset_in2,\n    input reset_in3,\n    input reset_in4,\n    input reset_in5,\n    input reset_in6,\n    input reset_in7,\n    input reset_in8,\n    input reset_in9,\n    input reset_in10,\n    input reset_in11,\n    input reset_in12,\n    input reset_in13,\n    input reset_in14,\n    input reset_in15,\n    input reset_req_in0,\n    input reset_req_in1,\n    input reset_req_in2,\n    input reset_req_in3,\n    input reset_req_in4,\n    input reset_req_in5,\n    input reset_req_in6,\n    input reset_req_in7,\n    input reset_req_in8,\n    input reset_req_in9,\n    input reset_req_in10,\n    input reset_req_in11,\n    input reset_req_in12,\n    input reset_req_in13,\n    input reset_req_in14,\n    input reset_req_in15,\n\n\n    input  clk,\n    output reg reset_out,\n    output reg reset_req\n);\n\n   \n   localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n   \n   \n   \n   localparam MIN_METASTABLE = 3;\n   localparam RSTREQ_ASRT_SYNC_TAP = MIN_METASTABLE + RESET_REQ_WAIT_TIME;\n\n   localparam LARGER = RESET_REQ_WAIT_TIME > RESET_REQ_EARLY_DSRT_TIME ? RESET_REQ_WAIT_TIME : RESET_REQ_EARLY_DSRT_TIME;\n\n   localparam ASSERTION_CHAIN_LENGTH =  (MIN_METASTABLE > LARGER) ? \n                                            MIN_RST_ASSERTION_TIME + 1 :\n                                        (\n                                        (MIN_RST_ASSERTION_TIME > LARGER)? \n                                            MIN_RST_ASSERTION_TIME + (LARGER - MIN_METASTABLE + 1) + 1 :\n                                            MIN_RST_ASSERTION_TIME + RESET_REQ_EARLY_DSRT_TIME + RESET_REQ_WAIT_TIME - MIN_METASTABLE + 2\n                                        );\n\n   localparam RESET_REQ_DRST_TAP = RESET_REQ_EARLY_DSRT_TIME + 1;\n   \n\n   wire merged_reset;\n   wire merged_reset_req_in;\n   wire reset_out_pre;\n   wire reset_req_pre;\n\n   \n   (*preserve*) reg  [RSTREQ_ASRT_SYNC_TAP: 0]  altera_reset_synchronizer_int_chain;\n   reg [ASSERTION_CHAIN_LENGTH-1: 0]            r_sync_rst_chain;\n   reg                                          r_sync_rst;\n   reg                                          r_early_rst;\n\n    \n    \n    \n    assign merged_reset = (  \n                              reset_in0 | \n                              reset_in1 | \n                              reset_in2 | \n                              reset_in3 | \n                              reset_in4 | \n                              reset_in5 | \n                              reset_in6 | \n                              reset_in7 | \n                              reset_in8 | \n                              reset_in9 | \n                              reset_in10 | \n                              reset_in11 | \n                              reset_in12 | \n                              reset_in13 | \n                              reset_in14 | \n                              reset_in15\n                          );\n\n    assign merged_reset_req_in = (\n                              ( (USE_RESET_REQUEST_IN0 == 1) ? reset_req_in0 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN1 == 1) ? reset_req_in1 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN2 == 1) ? reset_req_in2 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN3 == 1) ? reset_req_in3 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN4 == 1) ? reset_req_in4 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN5 == 1) ? reset_req_in5 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN6 == 1) ? reset_req_in6 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN7 == 1) ? reset_req_in7 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN8 == 1) ? reset_req_in8 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN9 == 1) ? reset_req_in9 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN10 == 1) ? reset_req_in10 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN11 == 1) ? reset_req_in11 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN12 == 1) ? reset_req_in12 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN13 == 1) ? reset_req_in13 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN14 == 1) ? reset_req_in14 : 1'b0)  |\n                              ( (USE_RESET_REQUEST_IN15 == 1) ? reset_req_in15 : 1'b0) \n                            );\n\n\n    \n    \n    \n    \n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\" && (RESET_REQUEST_PRESENT==0)) begin\n\n        assign reset_out_pre = merged_reset;\n        assign reset_req_pre = merged_reset_req_in;\n\n    end else begin\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(RESET_REQUEST_PRESENT? 1'b1 : ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out_pre)\n        );\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_req_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset_req_in),\n            .reset_out  (reset_req_pre)\n        );\n\n    end\n    endgenerate\n\n    generate if ( ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==0) )|\n                  ( (ADAPT_RESET_REQUEST == 1) && (OUTPUT_RESET_SYNC_EDGES != \"deassert\") ) ) begin\n        always @* begin\n            reset_out = reset_out_pre;\n            reset_req = reset_req_pre;\n        end\n    end else if ( (RESET_REQUEST_PRESENT == 0) && (ADAPT_RESET_REQUEST==1) ) begin\n\n        wire reset_out_pre2;\n\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH+1),\n            .ASYNC_RESET(0)\n        )\n        alt_rst_sync_uq2\n        (\n            .clk        (clk),\n            .reset_in   (reset_out_pre),\n            .reset_out  (reset_out_pre2)\n        );\n\n        always @* begin\n            reset_out = reset_out_pre2;\n            reset_req = reset_req_pre;\n        end\n\n    end\n    else begin\n\n    \n    initial\n    begin\n        altera_reset_synchronizer_int_chain <= {RSTREQ_ASRT_SYNC_TAP{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP:0] <= \n            {altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP-1:0], reset_out_pre}; \n    end\n\n    \n    initial\n    begin\n        r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n\n    always @(posedge clk)\n    begin\n        if (altera_reset_synchronizer_int_chain[MIN_METASTABLE-1] == 1'b1)\n        begin\n            r_sync_rst_chain <= {ASSERTION_CHAIN_LENGTH{1'b1}};\n    end\n    else\n    begin\n        r_sync_rst_chain <= {1'b0, r_sync_rst_chain[ASSERTION_CHAIN_LENGTH-1:1]};\n    end\n    end\n\n    \n    \n\n    always @(posedge clk)\n    begin\n        case ({altera_reset_synchronizer_int_chain[RSTREQ_ASRT_SYNC_TAP], r_sync_rst_chain[1], r_sync_rst})\n            3'b000:   r_sync_rst <= 1'b0; \n            3'b001:   r_sync_rst <= 1'b0;\n            3'b010:   r_sync_rst <= 1'b0;\n            3'b011:   r_sync_rst <= 1'b1;\n            3'b100:   r_sync_rst <= 1'b1; \n            3'b101:   r_sync_rst <= 1'b1;\n            3'b110:   r_sync_rst <= 1'b1;\n            3'b111:   r_sync_rst <= 1'b1; \n            default:  r_sync_rst <= 1'b1;\n        endcase\n\n        case ({r_sync_rst_chain[1], r_sync_rst_chain[RESET_REQ_DRST_TAP] | reset_req_pre})\n            2'b00:   r_early_rst <= 1'b0; \n            2'b01:   r_early_rst <= 1'b1; \n            2'b10:   r_early_rst <= 1'b0; \n            2'b11:   r_early_rst <= 1'b1; \n            default: r_early_rst <= 1'b1;\n        endcase\n    end\n\n    always @* begin\n        reset_out = r_sync_rst;\n        reset_req = r_early_rst;\n    end\n\n    end\n    endgenerate\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_reset_controller. \n\nModule specification: The altera_reset_controller is a module designed to manage and synchronize reset signals in a digital system, using various parameters to allow adaptive configuration. The module's functionality includes the acceptance of multiple reset signals and reset requests, using these inputs to assert an output reset and reset request signal depending on the system state and parameters.\n\nInput ports include 16 reset signals (reset_in0 to reset_in15) serving as external reset signals, and 16 reset request signals (reset_req_in0 to reset_req_in15) serving to assert the request for reset. Additionally, a clock input (clk) is included, which is required for system synchronization.\n\nOutput ports include a reset output signal (reset_out) that merges all reset inputs post synchronization. A reset request output signal (reset_req) is also provided, which is determined by the earliest of reset requests.\n\nSeveral internal signals are parallelly managed within the altera_reset_controller like ASYNC_RESET, reset_out_pre, altera_reset_synchronizer_int_chain, r_sync_rst_chain. These are utilized in synchronization, merging reset inputs, manage metastability and also generate final reset and reset request signal.\n\nThe code is divided into several blocks including parameter definition, input-output definition, internal parameter definition, and signal synchronization. This includes synchronizers for reset and reset request signals. The module also includes the code for managing reset and reset request chains internally. In the end, it has the code to generate final reset and reset request signals through several conditions and parameters. The module is well organized and detailed in nature, providing a comprehensive solution for complex reset signal synchronization."
                }
            ]
        }
    ]
}