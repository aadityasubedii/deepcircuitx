{
    "spec": "Module name: DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck. \n\nModule specification: The DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck is a JTAG debug module for a NIOS II system that shifts and stores data based on the JTAG instructions received and the state of certain controls. Functionality is segmented mainly within a single major \"always\" block, parameterized by the rising edge of the JTAG clock. This block is responsible for determining the size of the data register based on instruction received, loading different data into the shift register based on instruction and the control signal states, and shifting the register based on size determined and the input test data.\n\nInput ports include the MonDReg and break_readreg for storing monitor data and breakpoint read data respectively, signals indicating which data breakpoint has been hit (dbrk_hit0_latch to dbrk_hit3_latch), debugack for acknowledging the debug process, ir_in for storing JTAG instruction register, jtag_state_rti indicating the state of the JTAG state machine, monitor_error and monitor_ready signals, reset_n and resetlatch for module reset functionality, tck as clock input, and tdi as test data input. Additional inputs include control signals for trace memory operations, trigger breakpoint type and its state, and JTAG state machine controls.\n\nOutput ports comprise of ir_out representing the value of instruction register, jrst_n corresponding to the active low reset signal, sr as primary output storing/shifting data based on operations within the module, st_ready_test_idle to indicate JTAG TAP Controller's state, and tdo for testing data output.\n\nInternally, the module uses signals including DRsize for determining data register size, debugack_sync and monitor_ready_sync for synchronized value of debug acknowledgment and monitor ready signals respectively, sr as data storage, tdo to connect the first bit of sr to the tdo output port, and unxcomplemented_resetxx1 and unxcomplemented_resetxx2, both being timing safety signals for module reset. Synchronization of the debugack and monitor_ready signals is provided by instantiated Altera standard synchronizer modules.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck.\nExplanation: This is a JTAG debug module for a NIOS II system. The purpose of this module is to shift and store the appropriate data based on the JTAG instructions received and state of certain controls (like vs_cdr, vs_sdr, vs_uir). The module is mainly used for debugging, monitoring and tracing operations. This hardware component aids in real-time tracing and debugging functionalities of the system while connected via a JTAG interface. The data register (dr) sizes are adjusted for each different instruction code. It also syncs with input signals like debugack and monitor_ready using the altera_std_synchronizer."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. MonDReg[31:0]: This is a 32-bit wide input register used to store monitor data.\n\n2. break_readreg[31:0]: A 32-bit wide input register used to store breakpoint read data.\n\n3. dbrk_hit0_latch-dbrk_hit3_latch: These ports are used for indicating if the corresponding data breakpoint has been hit.\n\n4. debugack: This signal is used to acknowledge the debug process.\n\n5. ir_in[1:0]: This is an input register where the JTAG instruction register values are stored. \n\n6. jtag_state_rti: This signal indicates the state of the JTAG state machine.\n\n7. monitor_error: This signal indicates the presence of any monitor errors.\n\n8. monitor_ready: This signal indicates when the monitor is ready.\n\n9. reset_n: This is the reset signal for the JTAG module. It controls resetting the module.\n\n10. resetlatch: This indicates the status of the latch which is used to reset the module.\n\n11. tck: This is the clock input signal for the JTAG module.\n\n12. tdi: This is the test data input signal for JTAG. \n\n13. tracemem_on, tracemem_trcdata[35:0], tracemem_tw, trc_im_addr[6:0], trc_on, trc_wrap: These signals are related to trace memory operations. \n\n14. trigbrktype: This indicates the type of trigger breakpoint used.\n\n15. trigger_state_1: This indicates the state of the trigger.\n\n16. vs_cdr, vs_sdr, vs_uir: Control signals for various states in the JTAG state machine.\n\n \nOutput Ports:\n\n1. ir_out[1:0]: This output represents the value of the instruction register based on inputs and internal control signals.\n\n2. jrst_n: Active low reset signal, derived from the input reset signal reset_n, used for internal and timing operations.\n\n3. sr[37:0]: This is the primary output of the module. It stores and shifts out the data based on the operations performed in the module.  \n\n4. st_ready_test_idle: Signal to indicate the Status of JTAG TAP Controller if it is ready for testing or idle.\n\n5. tdo: The test data output signal for the JTAG interface. \n\n6. Other module-specific output wires: wires like debugack_sync, monitor_ready_sync etc., These are used as synchronizer outputs for input signals debugack and monitor_ready.\n"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal Signals: DRsize, debugack_sync, ir_out, monitor_ready_sync, sr, tdo, unxcomplemented_resetxx1, unxcomplemented_resetxx2.\n \nExplanation: \n\n1. DRsize: It is a 3-bit wide internal register. It is used to determine the size of the Data register based on the received instruction. \n\n2. debugack_sync: This internal wire is used to store the synchronized value of debug acknowledgment signal. The debugack signal is synchronized to the module's clock (tck) to ensure it's timing safe.\n\n3. ir_out: It is a 2-bit wide internal register, used to store the output for instruction register. The values are derived based on internal control signals and debugack_sync and monitor_ready_sync.\n\n4. monitor_ready_sync: This internal wire is used to store the synchronized value of the monitor ready signal. Like debugack, the signal monitor_ready is synchronized to the module's clock (tck) to ensure timing safety.\n\n5. sr: SR is a 38-bit wide internal register. It is used to store and shift out the data according to the specific operations performed in the module. It is the primary data storage of this module.\n\n6. tdo: This internal wire is used to connect the first bit of the shift register (sr) to the tdo output port. Tdo (Test Data Out) is a standard JTAG port.\n\n7. unxcomplemented_resetxx1, unxcomplemented_resetxx2: These are internal wires which store the value of the reset signal for use in the Altera standard synchronizers."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck (\n                                                       \n                                                        MonDReg,\n                                                        break_readreg,\n                                                        dbrk_hit0_latch,\n                                                        dbrk_hit1_latch,\n                                                        dbrk_hit2_latch,\n                                                        dbrk_hit3_latch,\n                                                        debugack,\n                                                        ir_in,\n                                                        jtag_state_rti,\n                                                        monitor_error,\n                                                        monitor_ready,\n                                                        reset_n,\n                                                        resetlatch,\n                                                        tck,\n                                                        tdi,\n                                                        tracemem_on,\n                                                        tracemem_trcdata,\n                                                        tracemem_tw,\n                                                        trc_im_addr,\n                                                        trc_on,\n                                                        trc_wrap,\n                                                        trigbrktype,\n                                                        trigger_state_1,\n                                                        vs_cdr,\n                                                        vs_sdr,\n                                                        vs_uir,\n\n                                                       \n                                                        ir_out,\n                                                        jrst_n,\n                                                        sr,\n                                                        st_ready_test_idle,\n                                                        tdo\n                                                     )\n;\n\n  output  [  1: 0] ir_out;\n  output           jrst_n;\n  output  [ 37: 0] sr;\n  output           st_ready_test_idle;\n  output           tdo;\n  input   [ 31: 0] MonDReg;\n  input   [ 31: 0] break_readreg;\n  input            dbrk_hit0_latch;\n  input            dbrk_hit1_latch;\n  input            dbrk_hit2_latch;\n  input            dbrk_hit3_latch;\n  input            debugack;\n  input   [  1: 0] ir_in;\n  input            jtag_state_rti;\n  input            monitor_error;\n  input            monitor_ready;\n  input            reset_n;\n  input            resetlatch;\n  input            tck;\n  input            tdi;\n  input            tracemem_on;\n  input   [ 35: 0] tracemem_trcdata;\n  input            tracemem_tw;\n  input   [  6: 0] trc_im_addr;\n  input            trc_on;\n  input            trc_wrap;\n  input            trigbrktype;\n  input            trigger_state_1;\n  input            vs_cdr;\n  input            vs_sdr;\n  input            vs_uir;\n\n\nreg     [  2: 0] DRsize ;\nwire             debugack_sync;\nreg     [  1: 0] ir_out;\nwire             jrst_n;\nwire             monitor_ready_sync;\nreg     [ 37: 0] sr ;\nwire             st_ready_test_idle;\nwire             tdo;\nwire             unxcomplemented_resetxx1;\nwire             unxcomplemented_resetxx2;\n  always @(posedge tck)\n    begin\n      if (vs_cdr)\n          case (ir_in)\n          \n              2'b00: begin\n                  sr[35] <= debugack_sync;\n                  sr[34] <= monitor_error;\n                  sr[33] <= resetlatch;\n                  sr[32 : 1] <= MonDReg;\n                  sr[0] <= monitor_ready_sync;\n              end \n          \n              2'b01: begin\n                  sr[35 : 0] <= tracemem_trcdata;\n                  sr[37] <= tracemem_tw;\n                  sr[36] <= tracemem_on;\n              end \n          \n              2'b10: begin\n                  sr[37] <= trigger_state_1;\n                  sr[36] <= dbrk_hit3_latch;\n                  sr[35] <= dbrk_hit2_latch;\n                  sr[34] <= dbrk_hit1_latch;\n                  sr[33] <= dbrk_hit0_latch;\n                  sr[32 : 1] <= break_readreg;\n                  sr[0] <= trigbrktype;\n              end \n          \n              2'b11: begin\n                  sr[15 : 2] <= trc_im_addr;\n                  sr[1] <= trc_wrap;\n                  sr[0] <= trc_on;\n              end \n          \n          endcase \n      if (vs_sdr)\n          case (DRsize)\n          \n              3'b000: begin\n                  sr <= {tdi, sr[37 : 2], tdi};\n              end \n          \n              3'b001: begin\n                  sr <= {tdi, sr[37 : 9], tdi, sr[7 : 1]};\n              end \n          \n              3'b010: begin\n                  sr <= {tdi, sr[37 : 17], tdi, sr[15 : 1]};\n              end \n          \n              3'b011: begin\n                  sr <= {tdi, sr[37 : 33], tdi, sr[31 : 1]};\n              end \n          \n              3'b100: begin\n                  sr <= {tdi, sr[37],         tdi, sr[35 : 1]};\n              end \n          \n              3'b101: begin\n                  sr <= {tdi, sr[37 : 1]};\n              end \n          \n              default: begin\n                  sr <= {tdi, sr[37 : 2], tdi};\n              end \n          \n          endcase \n      if (vs_uir)\n          case (ir_in)\n          \n              2'b00: begin\n                  DRsize <= 3'b100;\n              end \n          \n              2'b01: begin\n                  DRsize <= 3'b101;\n              end \n          \n              2'b10: begin\n                  DRsize <= 3'b101;\n              end \n          \n              2'b11: begin\n                  DRsize <= 3'b010;\n              end \n          \n          endcase \n    end\n\n\n  assign tdo = sr[0];\n  assign st_ready_test_idle = jtag_state_rti;\n  assign unxcomplemented_resetxx1 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer1\n    (\n      .clk (tck),\n      .din (debugack),\n      .dout (debugack_sync),\n      .reset_n (unxcomplemented_resetxx1)\n    );\n\n  defparam the_altera_std_synchronizer1.depth = 2;\n\n  assign unxcomplemented_resetxx2 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer2\n    (\n      .clk (tck),\n      .din (monitor_ready),\n      .dout (monitor_ready_sync),\n      .reset_n (unxcomplemented_resetxx2)\n    );\n\n  defparam the_altera_std_synchronizer2.depth = 2;\n\n  always @(posedge tck or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          ir_out <= 2'b0;\n      else \n        ir_out <= {debugack_sync, monitor_ready_sync};\n    end\n\n\n\n\n\n  assign jrst_n = reset_n;\n\n\n\n\n\n\n\n\nendmodule\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck. \n\nModule specification: The DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck is a JTAG debug module for a NIOS II system that shifts and stores data based on the JTAG instructions received and the state of certain controls. Functionality is segmented mainly within a single major \"always\" block, parameterized by the rising edge of the JTAG clock. This block is responsible for determining the size of the data register based on instruction received, loading different data into the shift register based on instruction and the control signal states, and shifting the register based on size determined and the input test data.\n\nInput ports include the MonDReg and break_readreg for storing monitor data and breakpoint read data respectively, signals indicating which data breakpoint has been hit (dbrk_hit0_latch to dbrk_hit3_latch), debugack for acknowledging the debug process, ir_in for storing JTAG instruction register, jtag_state_rti indicating the state of the JTAG state machine, monitor_error and monitor_ready signals, reset_n and resetlatch for module reset functionality, tck as clock input, and tdi as test data input. Additional inputs include control signals for trace memory operations, trigger breakpoint type and its state, and JTAG state machine controls.\n\nOutput ports comprise of ir_out representing the value of instruction register, jrst_n corresponding to the active low reset signal, sr as primary output storing/shifting data based on operations within the module, st_ready_test_idle to indicate JTAG TAP Controller's state, and tdo for testing data output.\n\nInternally, the module uses signals including DRsize for determining data register size, debugack_sync and monitor_ready_sync for synchronized value of debug acknowledgment and monitor ready signals respectively, sr as data storage, tdo to connect the first bit of sr to the tdo output port, and unxcomplemented_resetxx1 and unxcomplemented_resetxx2, both being timing safety signals for module reset. Synchronization of the debugack and monitor_ready signals is provided by instantiated Altera standard synchronizer modules."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck.\nExplanation: This is a JTAG debug module for a NIOS II system. The purpose of this module is to shift and store the appropriate data based on the JTAG instructions received and state of certain controls (like vs_cdr, vs_sdr, vs_uir). The module is mainly used for debugging, monitoring and tracing operations. This hardware component aids in real-time tracing and debugging functionalities of the system while connected via a JTAG interface. The data register (dr) sizes are adjusted for each different instruction code. It also syncs with input signals like debugack and monitor_ready using the altera_std_synchronizer."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput Ports:\n\n1. MonDReg[31:0]: This is a 32-bit wide input register used to store monitor data.\n\n2. break_readreg[31:0]: A 32-bit wide input register used to store breakpoint read data.\n\n3. dbrk_hit0_latch-dbrk_hit3_latch: These ports are used for indicating if the corresponding data breakpoint has been hit.\n\n4. debugack: This signal is used to acknowledge the debug process.\n\n5. ir_in[1:0]: This is an input register where the JTAG instruction register values are stored. \n\n6. jtag_state_rti: This signal indicates the state of the JTAG state machine.\n\n7. monitor_error: This signal indicates the presence of any monitor errors.\n\n8. monitor_ready: This signal indicates when the monitor is ready.\n\n9. reset_n: This is the reset signal for the JTAG module. It controls resetting the module.\n\n10. resetlatch: This indicates the status of the latch which is used to reset the module.\n\n11. tck: This is the clock input signal for the JTAG module.\n\n12. tdi: This is the test data input signal for JTAG. \n\n13. tracemem_on, tracemem_trcdata[35:0], tracemem_tw, trc_im_addr[6:0], trc_on, trc_wrap: These signals are related to trace memory operations. \n\n14. trigbrktype: This indicates the type of trigger breakpoint used.\n\n15. trigger_state_1: This indicates the state of the trigger.\n\n16. vs_cdr, vs_sdr, vs_uir: Control signals for various states in the JTAG state machine.\n\n \nOutput Ports:\n\n1. ir_out[1:0]: This output represents the value of the instruction register based on inputs and internal control signals.\n\n2. jrst_n: Active low reset signal, derived from the input reset signal reset_n, used for internal and timing operations.\n\n3. sr[37:0]: This is the primary output of the module. It stores and shifts out the data based on the operations performed in the module.  \n\n4. st_ready_test_idle: Signal to indicate the Status of JTAG TAP Controller if it is ready for testing or idle.\n\n5. tdo: The test data output signal for the JTAG interface. \n\n6. Other module-specific output wires: wires like debugack_sync, monitor_ready_sync etc., These are used as synchronizer outputs for input signals debugack and monitor_ready.\n"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal Signals: DRsize, debugack_sync, ir_out, monitor_ready_sync, sr, tdo, unxcomplemented_resetxx1, unxcomplemented_resetxx2.\n \nExplanation: \n\n1. DRsize: It is a 3-bit wide internal register. It is used to determine the size of the Data register based on the received instruction. \n\n2. debugack_sync: This internal wire is used to store the synchronized value of debug acknowledgment signal. The debugack signal is synchronized to the module's clock (tck) to ensure it's timing safe.\n\n3. ir_out: It is a 2-bit wide internal register, used to store the output for instruction register. The values are derived based on internal control signals and debugack_sync and monitor_ready_sync.\n\n4. monitor_ready_sync: This internal wire is used to store the synchronized value of the monitor ready signal. Like debugack, the signal monitor_ready is synchronized to the module's clock (tck) to ensure timing safety.\n\n5. sr: SR is a 38-bit wide internal register. It is used to store and shift out the data according to the specific operations performed in the module. It is the primary data storage of this module.\n\n6. tdo: This internal wire is used to connect the first bit of the shift register (sr) to the tdo output port. Tdo (Test Data Out) is a standard JTAG port.\n\n7. unxcomplemented_resetxx1, unxcomplemented_resetxx2: These are internal wires which store the value of the reset signal for use in the Altera standard synchronizers."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\n\n\n\n\nmodule DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck (\n                                                       \n                                                        MonDReg,\n                                                        break_readreg,\n                                                        dbrk_hit0_latch,\n                                                        dbrk_hit1_latch,\n                                                        dbrk_hit2_latch,\n                                                        dbrk_hit3_latch,\n                                                        debugack,\n                                                        ir_in,\n                                                        jtag_state_rti,\n                                                        monitor_error,\n                                                        monitor_ready,\n                                                        reset_n,\n                                                        resetlatch,\n                                                        tck,\n                                                        tdi,\n                                                        tracemem_on,\n                                                        tracemem_trcdata,\n                                                        tracemem_tw,\n                                                        trc_im_addr,\n                                                        trc_on,\n                                                        trc_wrap,\n                                                        trigbrktype,\n                                                        trigger_state_1,\n                                                        vs_cdr,\n                                                        vs_sdr,\n                                                        vs_uir,\n\n                                                       \n                                                        ir_out,\n                                                        jrst_n,\n                                                        sr,\n                                                        st_ready_test_idle,\n                                                        tdo\n                                                     )\n;\n\n  output  [  1: 0] ir_out;\n  output           jrst_n;\n  output  [ 37: 0] sr;\n  output           st_ready_test_idle;\n  output           tdo;\n  input   [ 31: 0] MonDReg;\n  input   [ 31: 0] break_readreg;\n  input            dbrk_hit0_latch;\n  input            dbrk_hit1_latch;\n  input            dbrk_hit2_latch;\n  input            dbrk_hit3_latch;\n  input            debugack;\n  input   [  1: 0] ir_in;\n  input            jtag_state_rti;\n  input            monitor_error;\n  input            monitor_ready;\n  input            reset_n;\n  input            resetlatch;\n  input            tck;\n  input            tdi;\n  input            tracemem_on;\n  input   [ 35: 0] tracemem_trcdata;\n  input            tracemem_tw;\n  input   [  6: 0] trc_im_addr;\n  input            trc_on;\n  input            trc_wrap;\n  input            trigbrktype;\n  input            trigger_state_1;\n  input            vs_cdr;\n  input            vs_sdr;\n  input            vs_uir;\n\n\nreg     [  2: 0] DRsize ;\nwire             debugack_sync;\nreg     [  1: 0] ir_out;\nwire             jrst_n;\nwire             monitor_ready_sync;\nreg     [ 37: 0] sr ;\nwire             st_ready_test_idle;\nwire             tdo;\nwire             unxcomplemented_resetxx1;\nwire             unxcomplemented_resetxx2;\n  always @(posedge tck)\n    begin\n      if (vs_cdr)\n          case (ir_in)\n          \n              2'b00: begin\n                  sr[35] <= debugack_sync;\n                  sr[34] <= monitor_error;\n                  sr[33] <= resetlatch;\n                  sr[32 : 1] <= MonDReg;\n                  sr[0] <= monitor_ready_sync;\n              end \n          \n              2'b01: begin\n                  sr[35 : 0] <= tracemem_trcdata;\n                  sr[37] <= tracemem_tw;\n                  sr[36] <= tracemem_on;\n              end \n          \n              2'b10: begin\n                  sr[37] <= trigger_state_1;\n                  sr[36] <= dbrk_hit3_latch;\n                  sr[35] <= dbrk_hit2_latch;\n                  sr[34] <= dbrk_hit1_latch;\n                  sr[33] <= dbrk_hit0_latch;\n                  sr[32 : 1] <= break_readreg;\n                  sr[0] <= trigbrktype;\n              end \n          \n              2'b11: begin\n                  sr[15 : 2] <= trc_im_addr;\n                  sr[1] <= trc_wrap;\n                  sr[0] <= trc_on;\n              end \n          \n          endcase \n      if (vs_sdr)\n          case (DRsize)\n          \n              3'b000: begin\n                  sr <= {tdi, sr[37 : 2], tdi};\n              end \n          \n              3'b001: begin\n                  sr <= {tdi, sr[37 : 9], tdi, sr[7 : 1]};\n              end \n          \n              3'b010: begin\n                  sr <= {tdi, sr[37 : 17], tdi, sr[15 : 1]};\n              end \n          \n              3'b011: begin\n                  sr <= {tdi, sr[37 : 33], tdi, sr[31 : 1]};\n              end \n          \n              3'b100: begin\n                  sr <= {tdi, sr[37],         tdi, sr[35 : 1]};\n              end \n          \n              3'b101: begin\n                  sr <= {tdi, sr[37 : 1]};\n              end \n          \n              default: begin\n                  sr <= {tdi, sr[37 : 2], tdi};\n              end \n          \n          endcase \n      if (vs_uir)\n          case (ir_in)\n          \n              2'b00: begin\n                  DRsize <= 3'b100;\n              end \n          \n              2'b01: begin\n                  DRsize <= 3'b101;\n              end \n          \n              2'b10: begin\n                  DRsize <= 3'b101;\n              end \n          \n              2'b11: begin\n                  DRsize <= 3'b010;\n              end \n          \n          endcase \n    end\n\n\n  assign tdo = sr[0];\n  assign st_ready_test_idle = jtag_state_rti;\n  assign unxcomplemented_resetxx1 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer1\n    (\n      .clk (tck),\n      .din (debugack),\n      .dout (debugack_sync),\n      .reset_n (unxcomplemented_resetxx1)\n    );\n\n  defparam the_altera_std_synchronizer1.depth = 2;\n\n  assign unxcomplemented_resetxx2 = jrst_n;\n  altera_std_synchronizer the_altera_std_synchronizer2\n    (\n      .clk (tck),\n      .din (monitor_ready),\n      .dout (monitor_ready_sync),\n      .reset_n (unxcomplemented_resetxx2)\n    );\n\n  defparam the_altera_std_synchronizer2.depth = 2;\n\n  always @(posedge tck or negedge jrst_n)\n    begin\n      if (jrst_n == 0)\n          ir_out <= 2'b0;\n      else \n        ir_out <= {debugack_sync, monitor_ready_sync};\n    end\n\n\n\n\n\n  assign jrst_n = reset_n;\n\n\n\n\n\n\n\n\nendmodule\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck. \n\nModule specification: The DE1_SoC_QSYS_nios2_qsys_jtag_debug_module_tck is a JTAG debug module for a NIOS II system that shifts and stores data based on the JTAG instructions received and the state of certain controls. Functionality is segmented mainly within a single major \"always\" block, parameterized by the rising edge of the JTAG clock. This block is responsible for determining the size of the data register based on instruction received, loading different data into the shift register based on instruction and the control signal states, and shifting the register based on size determined and the input test data.\n\nInput ports include the MonDReg and break_readreg for storing monitor data and breakpoint read data respectively, signals indicating which data breakpoint has been hit (dbrk_hit0_latch to dbrk_hit3_latch), debugack for acknowledging the debug process, ir_in for storing JTAG instruction register, jtag_state_rti indicating the state of the JTAG state machine, monitor_error and monitor_ready signals, reset_n and resetlatch for module reset functionality, tck as clock input, and tdi as test data input. Additional inputs include control signals for trace memory operations, trigger breakpoint type and its state, and JTAG state machine controls.\n\nOutput ports comprise of ir_out representing the value of instruction register, jrst_n corresponding to the active low reset signal, sr as primary output storing/shifting data based on operations within the module, st_ready_test_idle to indicate JTAG TAP Controller's state, and tdo for testing data output.\n\nInternally, the module uses signals including DRsize for determining data register size, debugack_sync and monitor_ready_sync for synchronized value of debug acknowledgment and monitor ready signals respectively, sr as data storage, tdo to connect the first bit of sr to the tdo output port, and unxcomplemented_resetxx1 and unxcomplemented_resetxx2, both being timing safety signals for module reset. Synchronization of the debugack and monitor_ready signals is provided by instantiated Altera standard synchronizer modules."
                }
            ]
        }
    ]
}