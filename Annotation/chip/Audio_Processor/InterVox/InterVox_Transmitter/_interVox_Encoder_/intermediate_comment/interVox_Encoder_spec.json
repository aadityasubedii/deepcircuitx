{
    "spec": "Module name: interVox_Encoder. Module specification: The interVox_Encoder module is an audio encoder for intercom or voice communication systems. It processes input audio data, performs bi-phase encoding, and manages control signals. The module has input ports for clock, reset, audio data (BCLK_IN, LRCLK_IN, SDATA_IN), user controls (SW, BTN_C, BTN_D, BTN_L, BTN_R), and output ports for encoded data (DATA_O), clock signals (MCLK_O, LRCLK_O, BCLK_O), and status indicators (LED, NXT_FRAME). Internal signals include state registers (currentState, syncing, synced), control flags (biPhaseEna), data buffers (left, right, dspData), and counters (bitCn",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: interVox_Encoder\n\nExplanation: This module appears to be an audio encoder for an intercom or voice communication system. It processes input audio data, performs bi-phase encoding, and manages various control signals. The module handles audio input/output, clock signals, and data synchronization. It includes sub-modules for edge detection, bi-phase encoding, and memory operations. The encoder seems to work with stereo audio (left and right channels) and also handles some DSP data. It has user interface elements like switches and buttons for control, and LEDs for output display. The module operates in different states and manages data buffering and timing for the encoding process."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclock, reset, io_BCLK_IN, io_LRCLK_IN, io_SDATA_IN, io_SW, io_BTN_C, io_BTN_D, io_BTN_L, io_BTN_R\n\nExplanation:\n- clock: System clock input\n- reset: System reset input\n- io_BCLK_IN: Bit clock input for audio data\n- io_LRCLK_IN: Left/Right clock input for audio data\n- io_SDATA_IN: Serial data input for audio\n- io_SW: 16-bit switch input for user control\n- io_BTN_C, io_BTN_D, io_BTN_L, io_BTN_R: Button inputs for user control\n\nOutput ports:\nio_MCLK_O, io_DATA_O, io_LRCLK_O, io_BCLK_O, io_SDATA_O, io_NXT_FRAME, io_LED\n\nExplanation:\n- io_MCLK_O: Master clock output (same as input clock)\n- io_DATA_O: Encoded data output\n- io_LRCLK_O: Left/Right clock output (same as input)\n- io_BCLK_O: Bit clock output (same as input)\n- io_SDATA_O: Serial data output (same as input)\n- io_NXT_FRAME: Next frame indicator\n- io_LED: 16-bit LED output for status display"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\ncurrentState, syncing, synced, biPhaseEna, leds, left, right, dspData, bitCntr\n\nExplanation:\n1. currentState: 2-bit register to track the current state of the encoder's operation.\n2. syncing: 1-bit register indicating whether the module is in the process of synchronizing.\n3. synced: 1-bit register indicating whether the module has successfully synchronized.\n4. biPhaseEna: 1-bit register enabling the bi-phase encoding process.\n5. leds: 16-bit register storing the current state of LED outputs.\n6. left: 16-bit register storing the left channel audio data.\n7. right: 16-bit register storing the right channel audio data.\n8. dspData: 16-bit register storing DSP (Digital Signal Processing) data.\n9. bitCntr: 8-bit counter used for tracking bit positions during data processing.\n\nThese internal signals collectively manage the state, synchronization, data storage, and control of the intercom voice encoder module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\nmodule RWSmem(\n  input         clock,\n  input         io_write,\n  input  [63:0] io_dataIn,\n  output [63:0] io_dataOut\n);\n`ifdef RANDOMIZE_MEM_INIT\n  reg [63:0] _RAND_0;\n`endif \n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n`endif \n  reg [63:0] mem [0:0]; \n  wire  mem_rdwrPort_r_en; \n  wire  mem_rdwrPort_r_addr; \n  wire [63:0] mem_rdwrPort_r_data; \n  wire [63:0] mem_rdwrPort_w_data; \n  wire  mem_rdwrPort_w_addr; \n  wire  mem_rdwrPort_w_mask; \n  wire  mem_rdwrPort_w_en; \n  reg  mem_rdwrPort_r_en_pipe_0;\n  reg  mem_rdwrPort_r_addr_pipe_0;\n  assign mem_rdwrPort_r_en = mem_rdwrPort_r_en_pipe_0;\n  assign mem_rdwrPort_r_addr = mem_rdwrPort_r_addr_pipe_0;\n  assign mem_rdwrPort_r_data = mem[mem_rdwrPort_r_addr]; \n  assign mem_rdwrPort_w_data = io_dataIn;\n  assign mem_rdwrPort_w_addr = 1'h0;\n  assign mem_rdwrPort_w_mask = io_write;\n  assign mem_rdwrPort_w_en = 1'h1 & io_write;\n  assign io_dataOut = mem_rdwrPort_r_data; \n  always @(posedge clock) begin\n    if (mem_rdwrPort_w_en & mem_rdwrPort_w_mask) begin\n      mem[mem_rdwrPort_w_addr] <= mem_rdwrPort_w_data; \n    end\n    mem_rdwrPort_r_en_pipe_0 <= 1'h1 & ~io_write;\n    if (1'h1 & ~io_write) begin\n      mem_rdwrPort_r_addr_pipe_0 <= 1'h0;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_MEM_INIT\n  _RAND_0 = {2{`RANDOM}};\n  for (initvar = 0; initvar < 1; initvar = initvar+1)\n    mem[initvar] = _RAND_0[63:0];\n`endif \n`ifdef RANDOMIZE_REG_INIT\n  _RAND_1 = {1{`RANDOM}};\n  mem_rdwrPort_r_en_pipe_0 = _RAND_1[0:0];\n  _RAND_2 = {1{`RANDOM}};\n  mem_rdwrPort_r_addr_pipe_0 = _RAND_2[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule biPhaseEncoder(\n  input         clock,\n  input         reset,\n  output        io_DATA_OUT,\n  input  [63:0] io_AUDIOINPUT,\n  input  [63:0] io_DSPINPUT,\n  input         io_ENA,\n  input         io_CLK\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [63:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n  reg [31:0] _RAND_5;\n  reg [31:0] _RAND_6;\n  reg [31:0] _RAND_7;\n`endif \n  reg  outReg; \n  reg [63:0] stereoData; \n  reg [15:0] dspData; \n  reg [7:0] bitCntr_enc; \n  reg  hasNone; \n  reg [5:0] dataIndex; \n  reg  ndexR; \n  reg  enabled; \n  wire [7:0] _bitCntr_enc_T_1 = bitCntr_enc + 8'h1; \n  wire  _outReg_T = ~outReg; \n  wire  _GEN_0 = bitCntr_enc == 8'h3 ? ~outReg : outReg; \n  wire  _GEN_1 = bitCntr_enc == 8'h4 ? _outReg_T : _GEN_0; \n  wire  _GEN_2 = bitCntr_enc == 8'h5 ? _outReg_T : _GEN_1; \n  wire [5:0] _dataIndex_T_1 = dataIndex + 6'h1; \n  wire [5:0] _GEN_3 = ndexR ? _dataIndex_T_1 : dataIndex; \n  wire [5:0] _T_10 = 6'h3e - dataIndex; \n  wire [63:0] _T_11 = stereoData >> _T_10; \n  wire  _GEN_4 = ~_T_11[0] | hasNone; \n  wire  _GEN_5 = ndexR ? _GEN_4 : hasNone; \n  wire  _GEN_6 = bitCntr_enc < 8'h35 ? _GEN_5 : hasNone; \n  wire [5:0] _T_19 = dataIndex - 6'h18; \n  wire [5:0] _T_21 = 6'h26 - _T_19; \n  wire [63:0] _T_22 = stereoData >> _T_21; \n  wire  _GEN_7 = ~_T_22[0] | _GEN_6; \n  wire  _GEN_8 = ndexR ? _GEN_7 : _GEN_6; \n  wire  _GEN_9 = bitCntr_enc >= 8'h35 & bitCntr_enc < 8'h65 ? _GEN_8 : _GEN_6; \n  wire [5:0] _T_30 = dataIndex - 6'h30; \n  wire [15:0] _T_31 = dspData >> _T_30; \n  wire  _GEN_10 = ~_T_31[0] | _GEN_9; \n  wire  _GEN_11 = ndexR ? _GEN_10 : _GEN_9; \n  wire  _GEN_12 = bitCntr_enc >= 8'h65 & bitCntr_enc <= 8'h7f ? _GEN_11 : _GEN_9; \n  wire  _GEN_13 = hasNone ? outReg : _outReg_T; \n  wire  _GEN_14 = hasNone ? 1'h0 : _GEN_12; \n  wire [5:0] _GEN_16 = bitCntr_enc > 8'h5 ? _GEN_3 : dataIndex; \n  wire [63:0] _GEN_34 = reset ? 64'h0 : io_DSPINPUT; \n  assign io_DATA_OUT = outReg; \n  always @(posedge clock) begin\n    if (reset) begin \n      outReg <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          outReg <= _GEN_13;\n        end else begin\n          outReg <= _GEN_2;\n        end\n      end\n    end\n    if (reset) begin \n      stereoData <= 64'h0; \n    end else begin\n      stereoData <= io_AUDIOINPUT; \n    end\n    dspData <= _GEN_34[15:0]; \n    if (reset) begin \n      bitCntr_enc <= 8'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          bitCntr_enc <= 8'h0; \n        end else begin\n          bitCntr_enc <= _bitCntr_enc_T_1; \n        end\n      end\n    end\n    if (reset) begin \n      hasNone <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          hasNone <= _GEN_14;\n        end\n      end\n    end\n    if (reset) begin \n      dataIndex <= 6'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          dataIndex <= 6'h0; \n        end else begin\n          dataIndex <= _GEN_16;\n        end\n      end\n    end\n    if (reset) begin \n      ndexR <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          ndexR <= ~ndexR; \n        end\n      end\n    end\n    if (reset) begin \n      enabled <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          enabled <= 1'h0; \n        end else begin\n          enabled <= io_ENA; \n        end\n      end else begin\n        enabled <= io_ENA; \n      end\n    end else begin\n      enabled <= io_ENA; \n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  outReg = _RAND_0[0:0];\n  _RAND_1 = {2{`RANDOM}};\n  stereoData = _RAND_1[63:0];\n  _RAND_2 = {1{`RANDOM}};\n  dspData = _RAND_2[15:0];\n  _RAND_3 = {1{`RANDOM}};\n  bitCntr_enc = _RAND_3[7:0];\n  _RAND_4 = {1{`RANDOM}};\n  hasNone = _RAND_4[0:0];\n  _RAND_5 = {1{`RANDOM}};\n  dataIndex = _RAND_5[5:0];\n  _RAND_6 = {1{`RANDOM}};\n  ndexR = _RAND_6[0:0];\n  _RAND_7 = {1{`RANDOM}};\n  enabled = _RAND_7[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule edgeDetector(\n  input   clock,\n  input   reset,\n  input   io_INPUT,\n  output  io_TRAIL,\n  output  io_RISE,\n  output  io_CHANGE\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n`endif \n  reg [1:0] inBufr; \n  reg [1:0] inBufrPrev; \n  reg  trailing; \n  reg  rising; \n  reg  change; \n  wire [1:0] _inBufr_T_1 = inBufr + 2'h1; \n  wire [1:0] _inBufr_T_3 = inBufr - 2'h1; \n  wire  _GEN_8 = inBufr[0] ^ inBufr[1] | change; \n  wire  _T_8 = inBufr == 2'h1; \n  wire  _GEN_9 = inBufrPrev == 2'h0 & inBufr == 2'h1 ? 1'h0 : trailing; \n  wire  _GEN_10 = inBufrPrev == 2'h0 & inBufr == 2'h1 | rising; \n  wire  _GEN_11 = inBufrPrev == 2'h0 & inBufr == 2'h1 | _GEN_8; \n  wire  _GEN_12 = inBufrPrev == 2'h2 & _T_8 | _GEN_9; \n  wire  _GEN_14 = inBufrPrev == 2'h2 & _T_8 | _GEN_11; \n  assign io_TRAIL = trailing; \n  assign io_RISE = rising; \n  assign io_CHANGE = change; \n  always @(posedge clock) begin\n    if (reset) begin \n      inBufr <= 2'h0; \n    end else if (io_INPUT) begin \n      if (inBufr < 2'h2) begin \n        inBufr <= _inBufr_T_1; \n      end\n    end else if (~io_INPUT) begin \n      if (inBufr > 2'h0) begin \n        inBufr <= _inBufr_T_3; \n      end\n    end\n    if (reset) begin \n      inBufrPrev <= 2'h0; \n    end else if (io_INPUT) begin \n      if (inBufr < 2'h2) begin \n        inBufrPrev <= inBufr; \n      end\n    end else if (~io_INPUT) begin \n      if (inBufr > 2'h0) begin \n        inBufrPrev <= inBufr; \n      end\n    end\n    if (reset) begin \n      trailing <= 1'h0; \n    end else if (trailing) begin \n      trailing <= 1'h0; \n    end else begin\n      trailing <= _GEN_12;\n    end\n    if (reset) begin \n      rising <= 1'h0; \n    end else if (rising) begin \n      rising <= 1'h0; \n    end else if (inBufrPrev == 2'h2 & _T_8) begin \n      rising <= 1'h0; \n    end else begin\n      rising <= _GEN_10;\n    end\n    if (reset) begin \n      change <= 1'h0; \n    end else if (change) begin \n      change <= 1'h0; \n    end else begin\n      change <= _GEN_14;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  inBufr = _RAND_0[1:0];\n  _RAND_1 = {1{`RANDOM}};\n  inBufrPrev = _RAND_1[1:0];\n  _RAND_2 = {1{`RANDOM}};\n  trailing = _RAND_2[0:0];\n  _RAND_3 = {1{`RANDOM}};\n  rising = _RAND_3[0:0];\n  _RAND_4 = {1{`RANDOM}};\n  change = _RAND_4[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule interVox_Encoder(\n  input         clock,\n  input         reset,\n  output        io_MCLK_O,\n  input         io_BCLK_IN,\n  input         io_LRCLK_IN,\n  input         io_SDATA_IN,\n  output        io_DATA_O,\n  output        io_LRCLK_O,\n  output        io_BCLK_O,\n  output        io_SDATA_O,\n  output        io_NXT_FRAME,\n  input  [15:0] io_SW,\n  output [15:0] io_LED,\n  input         io_BTN_C,\n  input         io_BTN_D,\n  input         io_BTN_L,\n  input         io_BTN_R\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n  reg [31:0] _RAND_5;\n  reg [31:0] _RAND_6;\n  reg [31:0] _RAND_7;\n  reg [31:0] _RAND_8;\n`endif \n  wire  BFR_clock; \n  wire  BFR_io_write; \n  wire [63:0] BFR_io_dataIn; \n  wire [63:0] BFR_io_dataOut; \n  wire  BFR1_clock; \n  wire  BFR1_io_write; \n  wire [63:0] BFR1_io_dataIn; \n  wire [63:0] BFR1_io_dataOut; \n  wire  biPhaseEncoder_clock; \n  wire  biPhaseEncoder_reset; \n  wire  biPhaseEncoder_io_DATA_OUT; \n  wire [63:0] biPhaseEncoder_io_AUDIOINPUT; \n  wire [63:0] biPhaseEncoder_io_DSPINPUT; \n  wire  biPhaseEncoder_io_ENA; \n  wire  biPhaseEncoder_io_CLK; \n  wire  LREDGE_clock; \n  wire  LREDGE_reset; \n  wire  LREDGE_io_INPUT; \n  wire  LREDGE_io_TRAIL; \n  wire  LREDGE_io_RISE; \n  wire  LREDGE_io_CHANGE; \n  wire  BCLKEDGE_clock; \n  wire  BCLKEDGE_reset; \n  wire  BCLKEDGE_io_INPUT; \n  wire  BCLKEDGE_io_TRAIL; \n  wire  BCLKEDGE_io_RISE; \n  wire  BCLKEDGE_io_CHANGE; \n  wire  DATAEDGE_clock; \n  wire  DATAEDGE_reset; \n  wire  DATAEDGE_io_INPUT; \n  wire  DATAEDGE_io_TRAIL; \n  wire  DATAEDGE_io_RISE; \n  wire  DATAEDGE_io_CHANGE; \n  reg [1:0] currentState; \n  reg  syncing; \n  reg  synced; \n  reg  biPhaseEna; \n  reg [15:0] leds; \n  reg [15:0] left; \n  reg [15:0] right; \n  reg [15:0] dspData; \n  reg [7:0] bitCntr; \n  wire  _GEN_0 = LREDGE_io_TRAIL | syncing; \n  wire [7:0] _bitCntr_T_1 = bitCntr + 8'h1; \n  wire  _GEN_1 = LREDGE_io_RISE | synced; \n  wire [7:0] _GEN_2 = LREDGE_io_RISE ? 8'h0 : _bitCntr_T_1; \n  wire [7:0] _GEN_3 = syncing ? _GEN_2 : bitCntr; \n  wire [7:0] _GEN_6 = ~synced ? _GEN_3 : bitCntr; \n  wire  _T_8 = BCLKEDGE_io_RISE; \n  wire  _T_11 = ~io_SDATA_IN; \n  wire [7:0] _BFR_io_dataIn_T_1 = bitCntr - 8'h1e; \n  wire [7:0] _BFR_io_dataIn_T_3 = 8'h27 - _BFR_io_dataIn_T_1; \n  wire [255:0] _BFR_io_dataIn_T_4 = 256'h0 << _BFR_io_dataIn_T_3; \n  wire [255:0] _GEN_89 = {{192'd0}, BFR_io_dataOut}; \n  wire [255:0] _BFR_io_dataIn_T_5 = _GEN_89 | _BFR_io_dataIn_T_4; \n  wire [255:0] _GEN_8 = ~io_SDATA_IN ? _BFR_io_dataIn_T_5 : 256'h0; \n  wire [255:0] _BFR_io_dataIn_T_10 = 256'h1 << _BFR_io_dataIn_T_3; \n  wire [255:0] _BFR_io_dataIn_T_11 = _GEN_89 | _BFR_io_dataIn_T_10; \n  wire [255:0] _GEN_9 = io_SDATA_IN ? _BFR_io_dataIn_T_11 : _GEN_8; \n  wire [7:0] _BFR_io_dataIn_T_15 = 8'h3f - _bitCntr_T_1; \n  wire [255:0] _BFR_io_dataIn_T_16 = 256'h0 << _BFR_io_dataIn_T_15; \n  wire [255:0] _BFR_io_dataIn_T_17 = _GEN_89 | _BFR_io_dataIn_T_16; \n  wire [255:0] _GEN_10 = _T_11 ? _BFR_io_dataIn_T_17 : 256'h0; \n  wire [255:0] _BFR_io_dataIn_T_22 = 256'h1 << _BFR_io_dataIn_T_15; \n  wire [255:0] _BFR_io_dataIn_T_23 = _GEN_89 | _BFR_io_dataIn_T_22; \n  wire [255:0] _GEN_11 = io_SDATA_IN ? _BFR_io_dataIn_T_23 : _GEN_10; \n  wire [255:0] _GEN_13 = bitCntr > 8'h1f ? _GEN_9 : _GEN_11; \n  wire [15:0] _GEN_14 = io_BTN_L ? io_SW : left; \n  wire [15:0] _GEN_15 = io_BTN_L ? left : leds; \n  wire [15:0] _GEN_16 = io_BTN_R ? io_SW : right; \n  wire [15:0] _GEN_17 = io_BTN_R ? right : _GEN_15; \n  wire [15:0] _GEN_18 = io_BTN_C ? io_SW : dspData; \n  wire [15:0] _GEN_19 = io_BTN_C ? dspData : _GEN_17; \n  wire [62:0] _GEN_93 = {left, 47'h0}; \n  wire [78:0] _BFR_io_dataIn_T_24 = {{16'd0}, _GEN_93}; \n  wire [38:0] _GEN_94 = {right, 23'h0}; \n  wire [46:0] _BFR_io_dataIn_T_25 = {{8'd0}, _GEN_94}; \n  wire [78:0] _GEN_95 = {{32'd0}, _BFR_io_dataIn_T_25}; \n  wire [78:0] _BFR_io_dataIn_T_26 = _BFR_io_dataIn_T_24 | _GEN_95; \n  wire [255:0] _GEN_21 = io_SW == 16'h0 ? _GEN_13 : {{177'd0}, _BFR_io_dataIn_T_26}; \n  wire [15:0] _GEN_22 = io_SW == 16'h0 ? left : _GEN_14; \n  wire [15:0] _GEN_23 = io_SW == 16'h0 ? leds : _GEN_19; \n  wire [15:0] _GEN_24 = io_SW == 16'h0 ? right : _GEN_16; \n  wire [15:0] _GEN_25 = io_SW == 16'h0 ? dspData : _GEN_18; \n  wire  _T_18 = bitCntr == 8'h3f; \n  wire [63:0] _leds_T = {{47'd0}, BFR1_io_dataOut[63:47]}; \n  wire [63:0] _leds_T_1 = _leds_T & 64'hffff; \n  wire [63:0] _GEN_26 = io_BTN_D ? _leds_T_1 : {{48'd0}, _GEN_23}; \n  wire [63:0] _GEN_29 = BFR_io_dataOut; \n  wire [255:0] _GEN_30 = bitCntr == 8'h3f ? 256'h0 : _GEN_21; \n  wire [63:0] _GEN_31 = bitCntr == 8'h3f ? _GEN_26 : {{48'd0}, _GEN_23}; \n  wire [7:0] _GEN_32 = bitCntr == 8'h3f ? 8'h0 : _bitCntr_T_1; \n  wire  _GEN_33 = BCLKEDGE_io_RISE | biPhaseEna; \n  wire [7:0] _GEN_34 = BCLKEDGE_io_RISE ? _GEN_32 : _GEN_6; \n  wire [255:0] _GEN_36 = BCLKEDGE_io_RISE ? _GEN_30 : 256'h0; \n  wire [15:0] _GEN_37 = BCLKEDGE_io_RISE ? _GEN_22 : left; \n  wire [63:0] _GEN_38 = BCLKEDGE_io_RISE ? _GEN_31 : {{48'd0}, leds}; \n  wire [15:0] _GEN_39 = BCLKEDGE_io_RISE ? _GEN_24 : right; \n  wire [15:0] _GEN_40 = BCLKEDGE_io_RISE ? _GEN_25 : dspData; \n  wire  _GEN_41 = BCLKEDGE_io_RISE & _T_18; \n  wire [63:0] _GEN_42 = BCLKEDGE_io_RISE ? _GEN_29 : BFR_io_dataOut; \n  wire  _GEN_44 = synced ? _GEN_33 : biPhaseEna; \n  wire [7:0] _GEN_45 = synced ? _GEN_34 : _GEN_6; \n  wire  _GEN_46 = synced & _T_8; \n  wire [255:0] _GEN_47 = synced ? _GEN_36 : 256'h0; \n  wire [15:0] _GEN_48 = synced ? _GEN_37 : left; \n  wire [63:0] _GEN_49 = synced ? _GEN_38 : {{48'd0}, leds}; \n  wire [15:0] _GEN_50 = synced ? _GEN_39 : right; \n  wire [15:0] _GEN_51 = synced ? _GEN_40 : dspData; \n  wire  _GEN_52 = synced & _GEN_41; \n  wire [63:0] _GEN_53 = synced ? _GEN_42 : BFR_io_dataOut; \n  wire [255:0] _GEN_58 = 2'h2 == currentState ? _GEN_47 : 256'h0; \n  wire [63:0] _GEN_60 = 2'h2 == currentState ? _GEN_49 : {{48'd0}, leds}; \n  wire [63:0] _GEN_64 = 2'h2 == currentState ? _GEN_53 : BFR_io_dataOut; \n  wire  _GEN_69 = 2'h1 == currentState ? 1'h0 : 2'h2 == currentState & _GEN_46; \n  wire [255:0] _GEN_70 = 2'h1 == currentState ? 256'h0 : _GEN_58; \n  wire [63:0] _GEN_72 = 2'h1 == currentState ? {{48'd0}, leds} : _GEN_60; \n  wire  _GEN_75 = 2'h1 == currentState ? 1'h0 : 2'h2 == currentState & _GEN_52; \n  wire [63:0] _GEN_76 = 2'h1 == currentState ? BFR_io_dataOut : _GEN_64; \n  wire [255:0] _GEN_82 = 2'h0 == currentState ? 256'h0 : _GEN_70; \n  wire [63:0] _GEN_84 = 2'h0 == currentState ? {{48'd0}, leds} : _GEN_72; \n  wire [63:0] _GEN_97 = reset ? 64'h0 : _GEN_84; \n  RWSmem BFR ( \n    .clock(BFR_clock),\n    .io_write(BFR_io_write),\n    .io_dataIn(BFR_io_dataIn),\n    .io_dataOut(BFR_io_dataOut)\n  );\n  RWSmem BFR1 ( \n    .clock(BFR1_clock),\n    .io_write(BFR1_io_write),\n    .io_dataIn(BFR1_io_dataIn),\n    .io_dataOut(BFR1_io_dataOut)\n  );\n  biPhaseEncoder biPhaseEncoder ( \n    .clock(biPhaseEncoder_clock),\n    .reset(biPhaseEncoder_reset),\n    .io_DATA_OUT(biPhaseEncoder_io_DATA_OUT),\n    .io_AUDIOINPUT(biPhaseEncoder_io_AUDIOINPUT),\n    .io_DSPINPUT(biPhaseEncoder_io_DSPINPUT),\n    .io_ENA(biPhaseEncoder_io_ENA),\n    .io_CLK(biPhaseEncoder_io_CLK)\n  );\n  edgeDetector LREDGE ( \n    .clock(LREDGE_clock),\n    .reset(LREDGE_reset),\n    .io_INPUT(LREDGE_io_INPUT),\n    .io_TRAIL(LREDGE_io_TRAIL),\n    .io_RISE(LREDGE_io_RISE),\n    .io_CHANGE(LREDGE_io_CHANGE)\n  );\n  edgeDetector BCLKEDGE ( \n    .clock(BCLKEDGE_clock),\n    .reset(BCLKEDGE_reset),\n    .io_INPUT(BCLKEDGE_io_INPUT),\n    .io_TRAIL(BCLKEDGE_io_TRAIL),\n    .io_RISE(BCLKEDGE_io_RISE),\n    .io_CHANGE(BCLKEDGE_io_CHANGE)\n  );\n  edgeDetector DATAEDGE ( \n    .clock(DATAEDGE_clock),\n    .reset(DATAEDGE_reset),\n    .io_INPUT(DATAEDGE_io_INPUT),\n    .io_TRAIL(DATAEDGE_io_TRAIL),\n    .io_RISE(DATAEDGE_io_RISE),\n    .io_CHANGE(DATAEDGE_io_CHANGE)\n  );\n  assign io_MCLK_O = clock; \n  assign io_DATA_O = biPhaseEncoder_io_DATA_OUT; \n  assign io_LRCLK_O = io_LRCLK_IN; \n  assign io_BCLK_O = io_BCLK_IN; \n  assign io_SDATA_O = io_SDATA_IN; \n  assign io_NXT_FRAME = BCLKEDGE_io_CHANGE; \n  assign io_LED = leds; \n  assign BFR_clock = clock;\n  assign BFR_io_write = 2'h0 == currentState ? 1'h0 : _GEN_69; \n  assign BFR_io_dataIn = _GEN_82[63:0];\n  assign BFR1_clock = clock;\n  assign BFR1_io_write = 2'h0 == currentState ? 1'h0 : _GEN_75; \n  assign BFR1_io_dataIn = 2'h0 == currentState ? BFR_io_dataOut : _GEN_76; \n  assign biPhaseEncoder_clock = clock;\n  assign biPhaseEncoder_reset = reset;\n  assign biPhaseEncoder_io_AUDIOINPUT = BFR1_io_dataOut; \n  assign biPhaseEncoder_io_DSPINPUT = {{48'd0}, dspData}; \n  assign biPhaseEncoder_io_ENA = biPhaseEna; \n  assign biPhaseEncoder_io_CLK = BCLKEDGE_io_CHANGE; \n  assign LREDGE_clock = clock;\n  assign LREDGE_reset = reset;\n  assign LREDGE_io_INPUT = io_LRCLK_IN; \n  assign BCLKEDGE_clock = clock;\n  assign BCLKEDGE_reset = reset;\n  assign BCLKEDGE_io_INPUT = io_BCLK_IN; \n  assign DATAEDGE_clock = clock;\n  assign DATAEDGE_reset = reset;\n  assign DATAEDGE_io_INPUT = io_SDATA_IN; \n  always @(posedge clock) begin\n    if (reset) begin \n      currentState <= 2'h0; \n    end else if (2'h0 == currentState) begin \n      currentState <= 2'h2; \n    end else if (2'h1 == currentState) begin \n      currentState <= 2'h2; \n    end\n    if (reset) begin \n      syncing <= 1'h0; \n    end else if (~synced) begin \n      syncing <= _GEN_0;\n    end\n    if (reset) begin \n      synced <= 1'h0; \n    end else if (~synced) begin \n      if (syncing) begin \n        synced <= _GEN_1;\n      end\n    end\n    if (reset) begin \n      biPhaseEna <= 1'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          biPhaseEna <= _GEN_44;\n        end\n      end\n    end\n    leds <= _GEN_97[15:0]; \n    if (reset) begin \n      left <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          left <= _GEN_48;\n        end\n      end\n    end\n    if (reset) begin \n      right <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          right <= _GEN_50;\n        end\n      end\n    end\n    if (reset) begin \n      dspData <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          dspData <= _GEN_51;\n        end\n      end\n    end\n    if (reset) begin \n      bitCntr <= 8'h0; \n    end else if (2'h0 == currentState) begin \n      bitCntr <= _GEN_6;\n    end else if (2'h1 == currentState) begin \n      bitCntr <= _GEN_6;\n    end else if (2'h2 == currentState) begin \n      bitCntr <= _GEN_45;\n    end else begin\n      bitCntr <= _GEN_6;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  currentState = _RAND_0[1:0];\n  _RAND_1 = {1{`RANDOM}};\n  syncing = _RAND_1[0:0];\n  _RAND_2 = {1{`RANDOM}};\n  synced = _RAND_2[0:0];\n  _RAND_3 = {1{`RANDOM}};\n  biPhaseEna = _RAND_3[0:0];\n  _RAND_4 = {1{`RANDOM}};\n  leds = _RAND_4[15:0];\n  _RAND_5 = {1{`RANDOM}};\n  left = _RAND_5[15:0];\n  _RAND_6 = {1{`RANDOM}};\n  right = _RAND_6[15:0];\n  _RAND_7 = {1{`RANDOM}};\n  dspData = _RAND_7[15:0];\n  _RAND_8 = {1{`RANDOM}};\n  bitCntr = _RAND_8[7:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: interVox_Encoder. Module specification: The interVox_Encoder module is an audio encoder for intercom or voice communication systems. It processes input audio data, performs bi-phase encoding, and manages control signals. The module has input ports for clock, reset, audio data (BCLK_IN, LRCLK_IN, SDATA_IN), user controls (SW, BTN_C, BTN_D, BTN_L, BTN_R), and output ports for encoded data (DATA_O), clock signals (MCLK_O, LRCLK_O, BCLK_O), and status indicators (LED, NXT_FRAME). Internal signals include state registers (currentState, syncing, synced), control flags (biPhaseEna), data buffers (left, right, dspData), and counters (bitCn"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: interVox_Encoder\n\nExplanation: This module appears to be an audio encoder for an intercom or voice communication system. It processes input audio data, performs bi-phase encoding, and manages various control signals. The module handles audio input/output, clock signals, and data synchronization. It includes sub-modules for edge detection, bi-phase encoding, and memory operations. The encoder seems to work with stereo audio (left and right channels) and also handles some DSP data. It has user interface elements like switches and buttons for control, and LEDs for output display. The module operates in different states and manages data buffering and timing for the encoding process."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclock, reset, io_BCLK_IN, io_LRCLK_IN, io_SDATA_IN, io_SW, io_BTN_C, io_BTN_D, io_BTN_L, io_BTN_R\n\nExplanation:\n- clock: System clock input\n- reset: System reset input\n- io_BCLK_IN: Bit clock input for audio data\n- io_LRCLK_IN: Left/Right clock input for audio data\n- io_SDATA_IN: Serial data input for audio\n- io_SW: 16-bit switch input for user control\n- io_BTN_C, io_BTN_D, io_BTN_L, io_BTN_R: Button inputs for user control\n\nOutput ports:\nio_MCLK_O, io_DATA_O, io_LRCLK_O, io_BCLK_O, io_SDATA_O, io_NXT_FRAME, io_LED\n\nExplanation:\n- io_MCLK_O: Master clock output (same as input clock)\n- io_DATA_O: Encoded data output\n- io_LRCLK_O: Left/Right clock output (same as input)\n- io_BCLK_O: Bit clock output (same as input)\n- io_SDATA_O: Serial data output (same as input)\n- io_NXT_FRAME: Next frame indicator\n- io_LED: 16-bit LED output for status display"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\ncurrentState, syncing, synced, biPhaseEna, leds, left, right, dspData, bitCntr\n\nExplanation:\n1. currentState: 2-bit register to track the current state of the encoder's operation.\n2. syncing: 1-bit register indicating whether the module is in the process of synchronizing.\n3. synced: 1-bit register indicating whether the module has successfully synchronized.\n4. biPhaseEna: 1-bit register enabling the bi-phase encoding process.\n5. leds: 16-bit register storing the current state of LED outputs.\n6. left: 16-bit register storing the left channel audio data.\n7. right: 16-bit register storing the right channel audio data.\n8. dspData: 16-bit register storing DSP (Digital Signal Processing) data.\n9. bitCntr: 8-bit counter used for tracking bit positions during data processing.\n\nThese internal signals collectively manage the state, synchronization, data storage, and control of the intercom voice encoder module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>module RWSmem(\n  input         clock,\n  input         io_write,\n  input  [63:0] io_dataIn,\n  output [63:0] io_dataOut\n);\n`ifdef RANDOMIZE_MEM_INIT\n  reg [63:0] _RAND_0;\n`endif \n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n`endif \n  reg [63:0] mem [0:0]; \n  wire  mem_rdwrPort_r_en; \n  wire  mem_rdwrPort_r_addr; \n  wire [63:0] mem_rdwrPort_r_data; \n  wire [63:0] mem_rdwrPort_w_data; \n  wire  mem_rdwrPort_w_addr; \n  wire  mem_rdwrPort_w_mask; \n  wire  mem_rdwrPort_w_en; \n  reg  mem_rdwrPort_r_en_pipe_0;\n  reg  mem_rdwrPort_r_addr_pipe_0;\n  assign mem_rdwrPort_r_en = mem_rdwrPort_r_en_pipe_0;\n  assign mem_rdwrPort_r_addr = mem_rdwrPort_r_addr_pipe_0;\n  assign mem_rdwrPort_r_data = mem[mem_rdwrPort_r_addr]; \n  assign mem_rdwrPort_w_data = io_dataIn;\n  assign mem_rdwrPort_w_addr = 1'h0;\n  assign mem_rdwrPort_w_mask = io_write;\n  assign mem_rdwrPort_w_en = 1'h1 & io_write;\n  assign io_dataOut = mem_rdwrPort_r_data; \n  always @(posedge clock) begin\n    if (mem_rdwrPort_w_en & mem_rdwrPort_w_mask) begin\n      mem[mem_rdwrPort_w_addr] <= mem_rdwrPort_w_data; \n    end\n    mem_rdwrPort_r_en_pipe_0 <= 1'h1 & ~io_write;\n    if (1'h1 & ~io_write) begin\n      mem_rdwrPort_r_addr_pipe_0 <= 1'h0;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_MEM_INIT\n  _RAND_0 = {2{`RANDOM}};\n  for (initvar = 0; initvar < 1; initvar = initvar+1)\n    mem[initvar] = _RAND_0[63:0];\n`endif \n`ifdef RANDOMIZE_REG_INIT\n  _RAND_1 = {1{`RANDOM}};\n  mem_rdwrPort_r_en_pipe_0 = _RAND_1[0:0];\n  _RAND_2 = {1{`RANDOM}};\n  mem_rdwrPort_r_addr_pipe_0 = _RAND_2[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule biPhaseEncoder(\n  input         clock,\n  input         reset,\n  output        io_DATA_OUT,\n  input  [63:0] io_AUDIOINPUT,\n  input  [63:0] io_DSPINPUT,\n  input         io_ENA,\n  input         io_CLK\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [63:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n  reg [31:0] _RAND_5;\n  reg [31:0] _RAND_6;\n  reg [31:0] _RAND_7;\n`endif \n  reg  outReg; \n  reg [63:0] stereoData; \n  reg [15:0] dspData; \n  reg [7:0] bitCntr_enc; \n  reg  hasNone; \n  reg [5:0] dataIndex; \n  reg  ndexR; \n  reg  enabled; \n  wire [7:0] _bitCntr_enc_T_1 = bitCntr_enc + 8'h1; \n  wire  _outReg_T = ~outReg; \n  wire  _GEN_0 = bitCntr_enc == 8'h3 ? ~outReg : outReg; \n  wire  _GEN_1 = bitCntr_enc == 8'h4 ? _outReg_T : _GEN_0; \n  wire  _GEN_2 = bitCntr_enc == 8'h5 ? _outReg_T : _GEN_1; \n  wire [5:0] _dataIndex_T_1 = dataIndex + 6'h1; \n  wire [5:0] _GEN_3 = ndexR ? _dataIndex_T_1 : dataIndex; \n  wire [5:0] _T_10 = 6'h3e - dataIndex; \n  wire [63:0] _T_11 = stereoData >> _T_10; \n  wire  _GEN_4 = ~_T_11[0] | hasNone; \n  wire  _GEN_5 = ndexR ? _GEN_4 : hasNone; \n  wire  _GEN_6 = bitCntr_enc < 8'h35 ? _GEN_5 : hasNone; \n  wire [5:0] _T_19 = dataIndex - 6'h18; \n  wire [5:0] _T_21 = 6'h26 - _T_19; \n  wire [63:0] _T_22 = stereoData >> _T_21; \n  wire  _GEN_7 = ~_T_22[0] | _GEN_6; \n  wire  _GEN_8 = ndexR ? _GEN_7 : _GEN_6; \n  wire  _GEN_9 = bitCntr_enc >= 8'h35 & bitCntr_enc < 8'h65 ? _GEN_8 : _GEN_6; \n  wire [5:0] _T_30 = dataIndex - 6'h30; \n  wire [15:0] _T_31 = dspData >> _T_30; \n  wire  _GEN_10 = ~_T_31[0] | _GEN_9; \n  wire  _GEN_11 = ndexR ? _GEN_10 : _GEN_9; \n  wire  _GEN_12 = bitCntr_enc >= 8'h65 & bitCntr_enc <= 8'h7f ? _GEN_11 : _GEN_9; \n  wire  _GEN_13 = hasNone ? outReg : _outReg_T; \n  wire  _GEN_14 = hasNone ? 1'h0 : _GEN_12; \n  wire [5:0] _GEN_16 = bitCntr_enc > 8'h5 ? _GEN_3 : dataIndex; \n  wire [63:0] _GEN_34 = reset ? 64'h0 : io_DSPINPUT; \n  assign io_DATA_OUT = outReg; \n  always @(posedge clock) begin\n    if (reset) begin \n      outReg <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          outReg <= _GEN_13;\n        end else begin\n          outReg <= _GEN_2;\n        end\n      end\n    end\n    if (reset) begin \n      stereoData <= 64'h0; \n    end else begin\n      stereoData <= io_AUDIOINPUT; \n    end\n    dspData <= _GEN_34[15:0]; \n    if (reset) begin \n      bitCntr_enc <= 8'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          bitCntr_enc <= 8'h0; \n        end else begin\n          bitCntr_enc <= _bitCntr_enc_T_1; \n        end\n      end\n    end\n    if (reset) begin \n      hasNone <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          hasNone <= _GEN_14;\n        end\n      end\n    end\n    if (reset) begin \n      dataIndex <= 6'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          dataIndex <= 6'h0; \n        end else begin\n          dataIndex <= _GEN_16;\n        end\n      end\n    end\n    if (reset) begin \n      ndexR <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc > 8'h5) begin \n          ndexR <= ~ndexR; \n        end\n      end\n    end\n    if (reset) begin \n      enabled <= 1'h0; \n    end else if (io_CLK) begin \n      if (enabled) begin \n        if (bitCntr_enc == 8'h7f) begin \n          enabled <= 1'h0; \n        end else begin\n          enabled <= io_ENA; \n        end\n      end else begin\n        enabled <= io_ENA; \n      end\n    end else begin\n      enabled <= io_ENA; \n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  outReg = _RAND_0[0:0];\n  _RAND_1 = {2{`RANDOM}};\n  stereoData = _RAND_1[63:0];\n  _RAND_2 = {1{`RANDOM}};\n  dspData = _RAND_2[15:0];\n  _RAND_3 = {1{`RANDOM}};\n  bitCntr_enc = _RAND_3[7:0];\n  _RAND_4 = {1{`RANDOM}};\n  hasNone = _RAND_4[0:0];\n  _RAND_5 = {1{`RANDOM}};\n  dataIndex = _RAND_5[5:0];\n  _RAND_6 = {1{`RANDOM}};\n  ndexR = _RAND_6[0:0];\n  _RAND_7 = {1{`RANDOM}};\n  enabled = _RAND_7[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule edgeDetector(\n  input   clock,\n  input   reset,\n  input   io_INPUT,\n  output  io_TRAIL,\n  output  io_RISE,\n  output  io_CHANGE\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n`endif \n  reg [1:0] inBufr; \n  reg [1:0] inBufrPrev; \n  reg  trailing; \n  reg  rising; \n  reg  change; \n  wire [1:0] _inBufr_T_1 = inBufr + 2'h1; \n  wire [1:0] _inBufr_T_3 = inBufr - 2'h1; \n  wire  _GEN_8 = inBufr[0] ^ inBufr[1] | change; \n  wire  _T_8 = inBufr == 2'h1; \n  wire  _GEN_9 = inBufrPrev == 2'h0 & inBufr == 2'h1 ? 1'h0 : trailing; \n  wire  _GEN_10 = inBufrPrev == 2'h0 & inBufr == 2'h1 | rising; \n  wire  _GEN_11 = inBufrPrev == 2'h0 & inBufr == 2'h1 | _GEN_8; \n  wire  _GEN_12 = inBufrPrev == 2'h2 & _T_8 | _GEN_9; \n  wire  _GEN_14 = inBufrPrev == 2'h2 & _T_8 | _GEN_11; \n  assign io_TRAIL = trailing; \n  assign io_RISE = rising; \n  assign io_CHANGE = change; \n  always @(posedge clock) begin\n    if (reset) begin \n      inBufr <= 2'h0; \n    end else if (io_INPUT) begin \n      if (inBufr < 2'h2) begin \n        inBufr <= _inBufr_T_1; \n      end\n    end else if (~io_INPUT) begin \n      if (inBufr > 2'h0) begin \n        inBufr <= _inBufr_T_3; \n      end\n    end\n    if (reset) begin \n      inBufrPrev <= 2'h0; \n    end else if (io_INPUT) begin \n      if (inBufr < 2'h2) begin \n        inBufrPrev <= inBufr; \n      end\n    end else if (~io_INPUT) begin \n      if (inBufr > 2'h0) begin \n        inBufrPrev <= inBufr; \n      end\n    end\n    if (reset) begin \n      trailing <= 1'h0; \n    end else if (trailing) begin \n      trailing <= 1'h0; \n    end else begin\n      trailing <= _GEN_12;\n    end\n    if (reset) begin \n      rising <= 1'h0; \n    end else if (rising) begin \n      rising <= 1'h0; \n    end else if (inBufrPrev == 2'h2 & _T_8) begin \n      rising <= 1'h0; \n    end else begin\n      rising <= _GEN_10;\n    end\n    if (reset) begin \n      change <= 1'h0; \n    end else if (change) begin \n      change <= 1'h0; \n    end else begin\n      change <= _GEN_14;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  inBufr = _RAND_0[1:0];\n  _RAND_1 = {1{`RANDOM}};\n  inBufrPrev = _RAND_1[1:0];\n  _RAND_2 = {1{`RANDOM}};\n  trailing = _RAND_2[0:0];\n  _RAND_3 = {1{`RANDOM}};\n  rising = _RAND_3[0:0];\n  _RAND_4 = {1{`RANDOM}};\n  change = _RAND_4[0:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\nmodule interVox_Encoder(\n  input         clock,\n  input         reset,\n  output        io_MCLK_O,\n  input         io_BCLK_IN,\n  input         io_LRCLK_IN,\n  input         io_SDATA_IN,\n  output        io_DATA_O,\n  output        io_LRCLK_O,\n  output        io_BCLK_O,\n  output        io_SDATA_O,\n  output        io_NXT_FRAME,\n  input  [15:0] io_SW,\n  output [15:0] io_LED,\n  input         io_BTN_C,\n  input         io_BTN_D,\n  input         io_BTN_L,\n  input         io_BTN_R\n);\n`ifdef RANDOMIZE_REG_INIT\n  reg [31:0] _RAND_0;\n  reg [31:0] _RAND_1;\n  reg [31:0] _RAND_2;\n  reg [31:0] _RAND_3;\n  reg [31:0] _RAND_4;\n  reg [31:0] _RAND_5;\n  reg [31:0] _RAND_6;\n  reg [31:0] _RAND_7;\n  reg [31:0] _RAND_8;\n`endif \n  wire  BFR_clock; \n  wire  BFR_io_write; \n  wire [63:0] BFR_io_dataIn; \n  wire [63:0] BFR_io_dataOut; \n  wire  BFR1_clock; \n  wire  BFR1_io_write; \n  wire [63:0] BFR1_io_dataIn; \n  wire [63:0] BFR1_io_dataOut; \n  wire  biPhaseEncoder_clock; \n  wire  biPhaseEncoder_reset; \n  wire  biPhaseEncoder_io_DATA_OUT; \n  wire [63:0] biPhaseEncoder_io_AUDIOINPUT; \n  wire [63:0] biPhaseEncoder_io_DSPINPUT; \n  wire  biPhaseEncoder_io_ENA; \n  wire  biPhaseEncoder_io_CLK; \n  wire  LREDGE_clock; \n  wire  LREDGE_reset; \n  wire  LREDGE_io_INPUT; \n  wire  LREDGE_io_TRAIL; \n  wire  LREDGE_io_RISE; \n  wire  LREDGE_io_CHANGE; \n  wire  BCLKEDGE_clock; \n  wire  BCLKEDGE_reset; \n  wire  BCLKEDGE_io_INPUT; \n  wire  BCLKEDGE_io_TRAIL; \n  wire  BCLKEDGE_io_RISE; \n  wire  BCLKEDGE_io_CHANGE; \n  wire  DATAEDGE_clock; \n  wire  DATAEDGE_reset; \n  wire  DATAEDGE_io_INPUT; \n  wire  DATAEDGE_io_TRAIL; \n  wire  DATAEDGE_io_RISE; \n  wire  DATAEDGE_io_CHANGE; \n  reg [1:0] currentState; \n  reg  syncing; \n  reg  synced; \n  reg  biPhaseEna; \n  reg [15:0] leds; \n  reg [15:0] left; \n  reg [15:0] right; \n  reg [15:0] dspData; \n  reg [7:0] bitCntr; \n  wire  _GEN_0 = LREDGE_io_TRAIL | syncing; \n  wire [7:0] _bitCntr_T_1 = bitCntr + 8'h1; \n  wire  _GEN_1 = LREDGE_io_RISE | synced; \n  wire [7:0] _GEN_2 = LREDGE_io_RISE ? 8'h0 : _bitCntr_T_1; \n  wire [7:0] _GEN_3 = syncing ? _GEN_2 : bitCntr; \n  wire [7:0] _GEN_6 = ~synced ? _GEN_3 : bitCntr; \n  wire  _T_8 = BCLKEDGE_io_RISE; \n  wire  _T_11 = ~io_SDATA_IN; \n  wire [7:0] _BFR_io_dataIn_T_1 = bitCntr - 8'h1e; \n  wire [7:0] _BFR_io_dataIn_T_3 = 8'h27 - _BFR_io_dataIn_T_1; \n  wire [255:0] _BFR_io_dataIn_T_4 = 256'h0 << _BFR_io_dataIn_T_3; \n  wire [255:0] _GEN_89 = {{192'd0}, BFR_io_dataOut}; \n  wire [255:0] _BFR_io_dataIn_T_5 = _GEN_89 | _BFR_io_dataIn_T_4; \n  wire [255:0] _GEN_8 = ~io_SDATA_IN ? _BFR_io_dataIn_T_5 : 256'h0; \n  wire [255:0] _BFR_io_dataIn_T_10 = 256'h1 << _BFR_io_dataIn_T_3; \n  wire [255:0] _BFR_io_dataIn_T_11 = _GEN_89 | _BFR_io_dataIn_T_10; \n  wire [255:0] _GEN_9 = io_SDATA_IN ? _BFR_io_dataIn_T_11 : _GEN_8; \n  wire [7:0] _BFR_io_dataIn_T_15 = 8'h3f - _bitCntr_T_1; \n  wire [255:0] _BFR_io_dataIn_T_16 = 256'h0 << _BFR_io_dataIn_T_15; \n  wire [255:0] _BFR_io_dataIn_T_17 = _GEN_89 | _BFR_io_dataIn_T_16; \n  wire [255:0] _GEN_10 = _T_11 ? _BFR_io_dataIn_T_17 : 256'h0; \n  wire [255:0] _BFR_io_dataIn_T_22 = 256'h1 << _BFR_io_dataIn_T_15; \n  wire [255:0] _BFR_io_dataIn_T_23 = _GEN_89 | _BFR_io_dataIn_T_22; \n  wire [255:0] _GEN_11 = io_SDATA_IN ? _BFR_io_dataIn_T_23 : _GEN_10; \n  wire [255:0] _GEN_13 = bitCntr > 8'h1f ? _GEN_9 : _GEN_11; \n  wire [15:0] _GEN_14 = io_BTN_L ? io_SW : left; \n  wire [15:0] _GEN_15 = io_BTN_L ? left : leds; \n  wire [15:0] _GEN_16 = io_BTN_R ? io_SW : right; \n  wire [15:0] _GEN_17 = io_BTN_R ? right : _GEN_15; \n  wire [15:0] _GEN_18 = io_BTN_C ? io_SW : dspData; \n  wire [15:0] _GEN_19 = io_BTN_C ? dspData : _GEN_17; \n  wire [62:0] _GEN_93 = {left, 47'h0}; \n  wire [78:0] _BFR_io_dataIn_T_24 = {{16'd0}, _GEN_93}; \n  wire [38:0] _GEN_94 = {right, 23'h0}; \n  wire [46:0] _BFR_io_dataIn_T_25 = {{8'd0}, _GEN_94}; \n  wire [78:0] _GEN_95 = {{32'd0}, _BFR_io_dataIn_T_25}; \n  wire [78:0] _BFR_io_dataIn_T_26 = _BFR_io_dataIn_T_24 | _GEN_95; \n  wire [255:0] _GEN_21 = io_SW == 16'h0 ? _GEN_13 : {{177'd0}, _BFR_io_dataIn_T_26}; \n  wire [15:0] _GEN_22 = io_SW == 16'h0 ? left : _GEN_14; \n  wire [15:0] _GEN_23 = io_SW == 16'h0 ? leds : _GEN_19; \n  wire [15:0] _GEN_24 = io_SW == 16'h0 ? right : _GEN_16; \n  wire [15:0] _GEN_25 = io_SW == 16'h0 ? dspData : _GEN_18; \n  wire  _T_18 = bitCntr == 8'h3f; \n  wire [63:0] _leds_T = {{47'd0}, BFR1_io_dataOut[63:47]}; \n  wire [63:0] _leds_T_1 = _leds_T & 64'hffff; \n  wire [63:0] _GEN_26 = io_BTN_D ? _leds_T_1 : {{48'd0}, _GEN_23}; \n  wire [63:0] _GEN_29 = BFR_io_dataOut; \n  wire [255:0] _GEN_30 = bitCntr == 8'h3f ? 256'h0 : _GEN_21; \n  wire [63:0] _GEN_31 = bitCntr == 8'h3f ? _GEN_26 : {{48'd0}, _GEN_23}; \n  wire [7:0] _GEN_32 = bitCntr == 8'h3f ? 8'h0 : _bitCntr_T_1; \n  wire  _GEN_33 = BCLKEDGE_io_RISE | biPhaseEna; \n  wire [7:0] _GEN_34 = BCLKEDGE_io_RISE ? _GEN_32 : _GEN_6; \n  wire [255:0] _GEN_36 = BCLKEDGE_io_RISE ? _GEN_30 : 256'h0; \n  wire [15:0] _GEN_37 = BCLKEDGE_io_RISE ? _GEN_22 : left; \n  wire [63:0] _GEN_38 = BCLKEDGE_io_RISE ? _GEN_31 : {{48'd0}, leds}; \n  wire [15:0] _GEN_39 = BCLKEDGE_io_RISE ? _GEN_24 : right; \n  wire [15:0] _GEN_40 = BCLKEDGE_io_RISE ? _GEN_25 : dspData; \n  wire  _GEN_41 = BCLKEDGE_io_RISE & _T_18; \n  wire [63:0] _GEN_42 = BCLKEDGE_io_RISE ? _GEN_29 : BFR_io_dataOut; \n  wire  _GEN_44 = synced ? _GEN_33 : biPhaseEna; \n  wire [7:0] _GEN_45 = synced ? _GEN_34 : _GEN_6; \n  wire  _GEN_46 = synced & _T_8; \n  wire [255:0] _GEN_47 = synced ? _GEN_36 : 256'h0; \n  wire [15:0] _GEN_48 = synced ? _GEN_37 : left; \n  wire [63:0] _GEN_49 = synced ? _GEN_38 : {{48'd0}, leds}; \n  wire [15:0] _GEN_50 = synced ? _GEN_39 : right; \n  wire [15:0] _GEN_51 = synced ? _GEN_40 : dspData; \n  wire  _GEN_52 = synced & _GEN_41; \n  wire [63:0] _GEN_53 = synced ? _GEN_42 : BFR_io_dataOut; \n  wire [255:0] _GEN_58 = 2'h2 == currentState ? _GEN_47 : 256'h0; \n  wire [63:0] _GEN_60 = 2'h2 == currentState ? _GEN_49 : {{48'd0}, leds}; \n  wire [63:0] _GEN_64 = 2'h2 == currentState ? _GEN_53 : BFR_io_dataOut; \n  wire  _GEN_69 = 2'h1 == currentState ? 1'h0 : 2'h2 == currentState & _GEN_46; \n  wire [255:0] _GEN_70 = 2'h1 == currentState ? 256'h0 : _GEN_58; \n  wire [63:0] _GEN_72 = 2'h1 == currentState ? {{48'd0}, leds} : _GEN_60; \n  wire  _GEN_75 = 2'h1 == currentState ? 1'h0 : 2'h2 == currentState & _GEN_52; \n  wire [63:0] _GEN_76 = 2'h1 == currentState ? BFR_io_dataOut : _GEN_64; \n  wire [255:0] _GEN_82 = 2'h0 == currentState ? 256'h0 : _GEN_70; \n  wire [63:0] _GEN_84 = 2'h0 == currentState ? {{48'd0}, leds} : _GEN_72; \n  wire [63:0] _GEN_97 = reset ? 64'h0 : _GEN_84; \n  RWSmem BFR ( \n    .clock(BFR_clock),\n    .io_write(BFR_io_write),\n    .io_dataIn(BFR_io_dataIn),\n    .io_dataOut(BFR_io_dataOut)\n  );\n  RWSmem BFR1 ( \n    .clock(BFR1_clock),\n    .io_write(BFR1_io_write),\n    .io_dataIn(BFR1_io_dataIn),\n    .io_dataOut(BFR1_io_dataOut)\n  );\n  biPhaseEncoder biPhaseEncoder ( \n    .clock(biPhaseEncoder_clock),\n    .reset(biPhaseEncoder_reset),\n    .io_DATA_OUT(biPhaseEncoder_io_DATA_OUT),\n    .io_AUDIOINPUT(biPhaseEncoder_io_AUDIOINPUT),\n    .io_DSPINPUT(biPhaseEncoder_io_DSPINPUT),\n    .io_ENA(biPhaseEncoder_io_ENA),\n    .io_CLK(biPhaseEncoder_io_CLK)\n  );\n  edgeDetector LREDGE ( \n    .clock(LREDGE_clock),\n    .reset(LREDGE_reset),\n    .io_INPUT(LREDGE_io_INPUT),\n    .io_TRAIL(LREDGE_io_TRAIL),\n    .io_RISE(LREDGE_io_RISE),\n    .io_CHANGE(LREDGE_io_CHANGE)\n  );\n  edgeDetector BCLKEDGE ( \n    .clock(BCLKEDGE_clock),\n    .reset(BCLKEDGE_reset),\n    .io_INPUT(BCLKEDGE_io_INPUT),\n    .io_TRAIL(BCLKEDGE_io_TRAIL),\n    .io_RISE(BCLKEDGE_io_RISE),\n    .io_CHANGE(BCLKEDGE_io_CHANGE)\n  );\n  edgeDetector DATAEDGE ( \n    .clock(DATAEDGE_clock),\n    .reset(DATAEDGE_reset),\n    .io_INPUT(DATAEDGE_io_INPUT),\n    .io_TRAIL(DATAEDGE_io_TRAIL),\n    .io_RISE(DATAEDGE_io_RISE),\n    .io_CHANGE(DATAEDGE_io_CHANGE)\n  );\n  assign io_MCLK_O = clock; \n  assign io_DATA_O = biPhaseEncoder_io_DATA_OUT; \n  assign io_LRCLK_O = io_LRCLK_IN; \n  assign io_BCLK_O = io_BCLK_IN; \n  assign io_SDATA_O = io_SDATA_IN; \n  assign io_NXT_FRAME = BCLKEDGE_io_CHANGE; \n  assign io_LED = leds; \n  assign BFR_clock = clock;\n  assign BFR_io_write = 2'h0 == currentState ? 1'h0 : _GEN_69; \n  assign BFR_io_dataIn = _GEN_82[63:0];\n  assign BFR1_clock = clock;\n  assign BFR1_io_write = 2'h0 == currentState ? 1'h0 : _GEN_75; \n  assign BFR1_io_dataIn = 2'h0 == currentState ? BFR_io_dataOut : _GEN_76; \n  assign biPhaseEncoder_clock = clock;\n  assign biPhaseEncoder_reset = reset;\n  assign biPhaseEncoder_io_AUDIOINPUT = BFR1_io_dataOut; \n  assign biPhaseEncoder_io_DSPINPUT = {{48'd0}, dspData}; \n  assign biPhaseEncoder_io_ENA = biPhaseEna; \n  assign biPhaseEncoder_io_CLK = BCLKEDGE_io_CHANGE; \n  assign LREDGE_clock = clock;\n  assign LREDGE_reset = reset;\n  assign LREDGE_io_INPUT = io_LRCLK_IN; \n  assign BCLKEDGE_clock = clock;\n  assign BCLKEDGE_reset = reset;\n  assign BCLKEDGE_io_INPUT = io_BCLK_IN; \n  assign DATAEDGE_clock = clock;\n  assign DATAEDGE_reset = reset;\n  assign DATAEDGE_io_INPUT = io_SDATA_IN; \n  always @(posedge clock) begin\n    if (reset) begin \n      currentState <= 2'h0; \n    end else if (2'h0 == currentState) begin \n      currentState <= 2'h2; \n    end else if (2'h1 == currentState) begin \n      currentState <= 2'h2; \n    end\n    if (reset) begin \n      syncing <= 1'h0; \n    end else if (~synced) begin \n      syncing <= _GEN_0;\n    end\n    if (reset) begin \n      synced <= 1'h0; \n    end else if (~synced) begin \n      if (syncing) begin \n        synced <= _GEN_1;\n      end\n    end\n    if (reset) begin \n      biPhaseEna <= 1'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          biPhaseEna <= _GEN_44;\n        end\n      end\n    end\n    leds <= _GEN_97[15:0]; \n    if (reset) begin \n      left <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          left <= _GEN_48;\n        end\n      end\n    end\n    if (reset) begin \n      right <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          right <= _GEN_50;\n        end\n      end\n    end\n    if (reset) begin \n      dspData <= 16'h0; \n    end else if (!(2'h0 == currentState)) begin \n      if (!(2'h1 == currentState)) begin \n        if (2'h2 == currentState) begin \n          dspData <= _GEN_51;\n        end\n      end\n    end\n    if (reset) begin \n      bitCntr <= 8'h0; \n    end else if (2'h0 == currentState) begin \n      bitCntr <= _GEN_6;\n    end else if (2'h1 == currentState) begin \n      bitCntr <= _GEN_6;\n    end else if (2'h2 == currentState) begin \n      bitCntr <= _GEN_45;\n    end else begin\n      bitCntr <= _GEN_6;\n    end\n  end\n\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_INVALID_ASSIGN\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_REG_INIT\n`define RANDOMIZE\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n`define RANDOMIZE\n`endif\n`ifndef RANDOM\n`define RANDOM $random\n`endif\n`ifdef RANDOMIZE_MEM_INIT\n  integer initvar;\n`endif\n`ifndef SYNTHESIS\n`ifdef FIRRTL_BEFORE_INITIAL\n`FIRRTL_BEFORE_INITIAL\n`endif\ninitial begin\n  `ifdef RANDOMIZE\n    `ifdef INIT_RANDOM\n      `INIT_RANDOM\n    `endif\n    `ifndef VERILATOR\n      `ifdef RANDOMIZE_DELAY\n        #`RANDOMIZE_DELAY begin end\n      `else\n        #0.002 begin end\n      `endif\n    `endif\n`ifdef RANDOMIZE_REG_INIT\n  _RAND_0 = {1{`RANDOM}};\n  currentState = _RAND_0[1:0];\n  _RAND_1 = {1{`RANDOM}};\n  syncing = _RAND_1[0:0];\n  _RAND_2 = {1{`RANDOM}};\n  synced = _RAND_2[0:0];\n  _RAND_3 = {1{`RANDOM}};\n  biPhaseEna = _RAND_3[0:0];\n  _RAND_4 = {1{`RANDOM}};\n  leds = _RAND_4[15:0];\n  _RAND_5 = {1{`RANDOM}};\n  left = _RAND_5[15:0];\n  _RAND_6 = {1{`RANDOM}};\n  right = _RAND_6[15:0];\n  _RAND_7 = {1{`RANDOM}};\n  dspData = _RAND_7[15:0];\n  _RAND_8 = {1{`RANDOM}};\n  bitCntr = _RAND_8[7:0];\n`endif \n  `endif \nend \n`ifdef FIRRTL_AFTER_INITIAL\n`FIRRTL_AFTER_INITIAL\n`endif\n`endif \nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: interVox_Encoder. Module specification: The interVox_Encoder module is an audio encoder for intercom or voice communication systems. It processes input audio data, performs bi-phase encoding, and manages control signals. The module has input ports for clock, reset, audio data (BCLK_IN, LRCLK_IN, SDATA_IN), user controls (SW, BTN_C, BTN_D, BTN_L, BTN_R), and output ports for encoded data (DATA_O), clock signals (MCLK_O, LRCLK_O, BCLK_O), and status indicators (LED, NXT_FRAME). Internal signals include state registers (currentState, syncing, synced), control flags (biPhaseEna), data buffers (left, right, dspData), and counters (bitCn"
                }
            ]
        }
    ]
}