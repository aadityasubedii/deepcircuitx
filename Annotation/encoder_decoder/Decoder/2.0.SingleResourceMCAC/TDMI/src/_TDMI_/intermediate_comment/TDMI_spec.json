{
    "spec": "Module name: TDMI. Module specification: The TDMI (Time Division Multiplexed Input) module is designed for handling serial data input with synchronization requirements and testability support. It reads serial data `data_in` on every rising edge of a clock, which is chosen based on the `test_mode` input to decide between `ser_clk` (operation clock) and `clk` (test clock). The module detects the start of a data frame via the `frame_sync` signal and increments channels and data bits accordingly, interfacing with a Wishbone bus for data transfer and control. Input ports include `reset`, `ser_clk`, `data_in`, `frame_sync`, `scan_in0` to `scan_in4` (for scan chain), `scan_enable`, `test_mode`, `clk`, and Wishbone bus signals such as `i_wb_adr` and `i_wb_dat`. Output ports are `new_data_int` (a new data available interrupt), `scan_out0` to `scan_out4` (scan chain outputs), and Wishbone bus responses including `o_wb_dat` (output data), `o_wb_ack` (data transaction acknowledgment), and `o_wb_err` (error indication fixed at 0). Internally, the module uses signals such as `sys_clk` and `serial_clk` for timing, and various registers like `ch_count` and `bit_count` for tracking data state and `data_out_buf` for assembling incoming serial data. The code includes multiple blocks: clock selection and buffer instantiation defining operational or test mode clock handling, data processing and state management in response to clock edges for reading and buffering data, and another block handling Wishbone bus interactions, enabling data readout, module control via bus commands, and interrupt management.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: TDMI.\nExplanation: The TDMI module appears to be designed for handling data input in a serial format with specific synchronization requirements. It can selectively operate in normal or test mode, defined by the input `test_mode`. When in normal mode, the module uses the `ser_clk` for operations; in test mode, it uses a regular `clk`. This module reads serial data `data_in` on each rising edge of the selected clock and expects a frame sync signal `frame_sync` to mark the beginning of a data frame. The module buffers this data and counts both bits and channels, providing data and channel information to a wishbone bus interface. This interface allows reading of complete data values or channel information, and supports commands to begin or halt operations. Additionally, the module generates an interrupt `new_data_int` when new data is ready, indicating to external systems that new data has been captured and stored."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: `reset, ser_clk, data_in, frame_sync, scan_in0, scan_in1, scan_in2, scan_in3, scan_in4, scan_enable, test_mode, clk, i_wb_adr, i_wb_sel, i_wb_we, i_wb_dat, i_wb_cyc, i_wb_stb`. \nExplanation:\n- `reset`: Used to reset the internal states of the module, setting registers to their default values.\n- `ser_clk`: The clock input used for serial data operations in normal mode. It dictates the pace at which `data_in` is sampled.\n- `data_in`: Serial data input which is read on each rising edge of the clock selected by `test_mode`.\n- `frame_sync`: Signal input to indicate the beginning of a new data frame in the serial data stream.\n- `scan_in0, scan_in1, scan_in2, scan_in3, scan_in4`: Inputs for scan chain data, potentially used for testing or daisy-chaining purposes.\n- `scan_enable`: Enables scanning inputs, likely used in a testing or debug configuration.\n- `test_mode`: Switch to select between normal operation and test mode, changing the clock input between `ser_clk` and `clk`.\n- `clk`: System clock, used in test mode and for synchronization of internal operations not related to the serial data input.\n- `i_wb_adr, i_wb_sel, i_wb_we, i_wb_dat, i_wb_cyc, i_wb_stb`: Wishbone bus interface signals for addressing, data handling, and transaction control.\n\nOutput ports: `new_data_int, scan_out0, scan_out1, scan_out2, scan_out3, scan_out4, o_wb_dat, o_wb_ack, o_wb_err`.\nExplanation:\n- `new_data_int`: Interrupt output that signals when new data is available in the buffers, notifying external systems to read it.\n- `scan_out0, scan_out1, scan_out2, scan_out3, scan_out4`: Outputs for scan chain data, potentially used for extending scan chains or for testing outputs.\n- `o_wb_dat`: Data output to the Wishbone bus, conveying the buffered serial data or channel information depending on the bus address provided.\n- `o_wb_ack`: Acknowledgment signal for the Wishbone bus, indicating that a read or write operation has been successfully completed.\n- `o_wb_err`: Error signal for the Wishbone bus, indicating any errors in the bus operations (constantly set to 0 in this design, implying no error reporting)."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: `sys_clk, serial_clk, selected_clk, ch_count, bit_count, prev_frame_sync, data_out_buf, ch_buf_1, ch_buf_2, data_buf_1, data_buf_2, start_read, int_buf_1, int_set, bit_count_buf, tdmi_begin, fs_start`.\n\nExplanation:\n- `sys_clk`: Buffer output of the system clock `clk`. Used for internal operations and timing that are independent of the serial data reading.\n- `serial_clk`: Inverted output of `selected_clk`, used as the clock source for serial data operations.\n- `selected_clk`: Based on `test_mode`, it selects between `clk` (test mode) and `ser_clk` (normal mode for serial data operations).\n- `ch_count`: Counts the channel or frame number as data is being read; increments after a complete data frame is read.\n- `bit_count`: Tracks the bit position within the current data byte being read from `data_in`.\n- `prev_frame_sync`: Stores the previous state of the `frame_sync` to detect rising edges indicating the start of a new data batch.\n- `data_out_buf`: Stores the incoming bits from `data_in` to form a complete byte.\n- `ch_buf_1, ch_buf_2`: Buffers for transferring channel count to the output in a pipelined manner.\n- `data_buf_1, data_buf_2`: Buffers for transferring data bytes to the output; ensures stable output data through pipelining.\n- `start_read`: Controls the readiness of the buffer to be read via the Wishbone interface.\n- `int_buf_1, int_set`: Manage internal flags to generate a new data available interrupt (`new_data_int`).\n- `bit_count_buf`: Buffer for `bit_count` used to handle changes across different clock domains.\n- `tdmi_begin`: Controls the activation/deactivation of the serial data reading logic based on external control signals.\n- `fs_start`: Flag set upon detecting the start of a frame, used for managing data reads and interrupt generation."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule TDMI (\n\t\tinput reset,\n\t\tinput ser_clk,\n\t\tinput data_in,\n\t\tinput frame_sync,\n\t\tinput scan_in0,\n\t\tinput scan_in1,\n\t\tinput scan_in2,\n\t\tinput scan_in3,\n\t\tinput scan_in4,\n\t\tinput scan_enable,\n\t\tinput test_mode,\n\t\toutput reg new_data_int,\n\t\toutput scan_out0,\n\t\toutput scan_out1,\n\t\toutput scan_out2,\n\t\toutput scan_out3,\n\t\toutput scan_out4,\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tinput\t\tclk,\n\t\tinput       [31:0]          i_wb_adr,\t\n\t\tinput       [3:0] \t    i_wb_sel,\t\n\t\tinput                       i_wb_we,\t\n\t\toutput reg  [31:0] \t    o_wb_dat,\t\n\t\tinput       [31:0] \t    i_wb_dat,\t\n\t\tinput                       i_wb_cyc,\t\n\t\tinput                       i_wb_stb,\t\n\t\toutput\t                o_wb_ack,\t\n\t\toutput                      o_wb_err\t\n);\n\n`include \"../include/register_addresses.vh\"\t\t\n\n\nwire \t sys_clk, serial_clk;\t\t\nwire\t selected_clk;\t\t\t\n\nreg [4:0] \tch_count;\t\t\t\nreg [2:0] \tbit_count;\t\t\t\nreg\t\tprev_frame_sync;\t\t\nreg [7:0]\tdata_out_buf;\t\t\nreg [4:0] \tch_buf_1, ch_buf_2;\t\nreg [7:0] \tdata_buf_1, data_buf_2; \nreg\t\tstart_read;\nreg\t\tint_buf_1;\nreg\t\tint_set;\nreg [2:0]\tbit_count_buf;\nreg\t\ttdmi_begin;\nreg\t\tfs_start;\n\nassign o_wb_ack = (i_wb_we) ? (i_wb_stb & i_wb_cyc) : (i_wb_stb & i_wb_cyc & start_read) ;\t\n\nassign o_wb_err = 1'b0;\t\t\t\t\n\nCLKBUFX4 clk_buf_1 (\t\t\t\t\n\t.A(clk),\n\t.Y(sys_clk)\n);\n\nassign selected_clk = (test_mode) ? (clk) : (ser_clk);\t\n\nCLKINVX4 clk_buf_2 (\t\t\t\t\t\t\t\n\t.A(selected_clk),\n\t.Y(serial_clk)\n);\n\n\n\n\nalways@ (posedge serial_clk, posedge reset) begin\n\tif (reset) begin\t\t\t\t\t\t\n\t\tch_count\t\t<= 5'b00000;\n\t\tbit_count\t\t<= 3'b111;\t\t\t\n\t\tprev_frame_sync \t<= 1'b0;\n\t\tdata_out_buf \t<= 8'h00;\n\t\tfs_start\t\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\t\n\t\t\t\tch_count <= 5'b00000;\t\t\t\n\t\t\t\tdata_out_buf[7] <= data_in;\t\t\n\t\t\t\tbit_count <= 3'b110;\t\t\t\n\t\t\t\tfs_start <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tdata_out_buf[bit_count] <= data_in;\t\n\t\t\t\tbit_count <= bit_count - 3'b001;\t\n\t\t\t\tif (bit_count == 3'b111) begin\t\n\t\t\t\t\tch_count <= ch_count + 5'b00001;\t\n\t\t\t\tend\n\t\t\tend\n\t\t\tprev_frame_sync <= frame_sync;\t\t\n\t\tend\n\tend\nend\n\n\nalways@ (posedge sys_clk, posedge reset) begin\n\n\tif (reset) begin\n\t\tdata_buf_1\t<= 8'h00;\n\t\tdata_buf_2\t<= 8'h00;\n\t\tch_buf_1\t<= 5'b00000;\n\t\tch_buf_2\t<= 5'b00000;\n\t\to_wb_dat\t<= 32'h00000000;\n\t\tint_buf_1   <= 1'b0;\n\t\tint_set\t<= 1'b0;\n\t\tnew_data_int <= 1'b0;\n\t\tstart_read <= 1'b0;\n\t\tbit_count_buf <= 3'b000;\n\t\ttdmi_begin\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tbit_count_buf <= bit_count;\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\n\t\t\t\tint_buf_1 <= 1'b0;\n\t\t\t\tint_set <= int_set;\n\t\t\tend else if ((bit_count_buf != 3'b111) || (bit_count != 3'b111)) begin\n\t\t\t\tint_set <= 1'b0;\n\t\t\t\tint_buf_1 <= int_buf_1;\n\t\t\tend else if (~int_set & fs_start) begin\n\t\t\t\tint_buf_1 <= 1'b1;\t\n\t\t\t\tint_set <= 1'b1;\n\t\t\tend\n\t\t\tnew_data_int <= int_buf_1;\n\t\t\tif (bit_count == 3'b111) begin\n\t\t\t\tch_buf_1 <= ch_count;\t\n\t\t\t\tdata_buf_1 <= data_out_buf; \n\t\t\tend\n\t\t\tdata_buf_2 <= data_buf_1;\t\n\t\t\tch_buf_2 <= ch_buf_1;\n\t\tend\n\t\tif (i_wb_stb & i_wb_cyc & (~i_wb_we)) begin\t\n\t\t\tcase (i_wb_adr[15:0])\t\t\t\t\n\t\t\t\tTDMI_ALL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_CHANNEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {27'h0000000, ch_buf_2[4:0]};\t\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_DATA:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {24'h00000, data_buf_2};\t\t\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\tendcase\n\t\t\tstart_read <= 1'b1;\n\t\t\tint_buf_1 <= 1'b0;\t\n\t\tend else if (i_wb_stb & i_wb_cyc & i_wb_we) begin\n\t\t\tcase (i_wb_adr[15:0])\n\t\t\t\tTDMI_START:\n\t\t\t\t\tbegin\n\t\t\t\t\t\ttdmi_begin <= i_wb_dat[0];\n\t\t\t\t\tend\n\t\t\t\tdefault:\ttdmi_begin <= 1'b0;\n\t\t\tendcase\n\t\t\tstart_read <= 1'b0;\n\t\tend else begin\n\t\t\tstart_read <= 1'b0;\n\t\tend\n\tend\nend\n\n\nendmodule \n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: TDMI. Module specification: The TDMI (Time Division Multiplexed Input) module is designed for handling serial data input with synchronization requirements and testability support. It reads serial data `data_in` on every rising edge of a clock, which is chosen based on the `test_mode` input to decide between `ser_clk` (operation clock) and `clk` (test clock). The module detects the start of a data frame via the `frame_sync` signal and increments channels and data bits accordingly, interfacing with a Wishbone bus for data transfer and control. Input ports include `reset`, `ser_clk`, `data_in`, `frame_sync`, `scan_in0` to `scan_in4` (for scan chain), `scan_enable`, `test_mode`, `clk`, and Wishbone bus signals such as `i_wb_adr` and `i_wb_dat`. Output ports are `new_data_int` (a new data available interrupt), `scan_out0` to `scan_out4` (scan chain outputs), and Wishbone bus responses including `o_wb_dat` (output data), `o_wb_ack` (data transaction acknowledgment), and `o_wb_err` (error indication fixed at 0). Internally, the module uses signals such as `sys_clk` and `serial_clk` for timing, and various registers like `ch_count` and `bit_count` for tracking data state and `data_out_buf` for assembling incoming serial data. The code includes multiple blocks: clock selection and buffer instantiation defining operational or test mode clock handling, data processing and state management in response to clock edges for reading and buffering data, and another block handling Wishbone bus interactions, enabling data readout, module control via bus commands, and interrupt management."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: TDMI.\nExplanation: The TDMI module appears to be designed for handling data input in a serial format with specific synchronization requirements. It can selectively operate in normal or test mode, defined by the input `test_mode`. When in normal mode, the module uses the `ser_clk` for operations; in test mode, it uses a regular `clk`. This module reads serial data `data_in` on each rising edge of the selected clock and expects a frame sync signal `frame_sync` to mark the beginning of a data frame. The module buffers this data and counts both bits and channels, providing data and channel information to a wishbone bus interface. This interface allows reading of complete data values or channel information, and supports commands to begin or halt operations. Additionally, the module generates an interrupt `new_data_int` when new data is ready, indicating to external systems that new data has been captured and stored."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: `reset, ser_clk, data_in, frame_sync, scan_in0, scan_in1, scan_in2, scan_in3, scan_in4, scan_enable, test_mode, clk, i_wb_adr, i_wb_sel, i_wb_we, i_wb_dat, i_wb_cyc, i_wb_stb`. \nExplanation:\n- `reset`: Used to reset the internal states of the module, setting registers to their default values.\n- `ser_clk`: The clock input used for serial data operations in normal mode. It dictates the pace at which `data_in` is sampled.\n- `data_in`: Serial data input which is read on each rising edge of the clock selected by `test_mode`.\n- `frame_sync`: Signal input to indicate the beginning of a new data frame in the serial data stream.\n- `scan_in0, scan_in1, scan_in2, scan_in3, scan_in4`: Inputs for scan chain data, potentially used for testing or daisy-chaining purposes.\n- `scan_enable`: Enables scanning inputs, likely used in a testing or debug configuration.\n- `test_mode`: Switch to select between normal operation and test mode, changing the clock input between `ser_clk` and `clk`.\n- `clk`: System clock, used in test mode and for synchronization of internal operations not related to the serial data input.\n- `i_wb_adr, i_wb_sel, i_wb_we, i_wb_dat, i_wb_cyc, i_wb_stb`: Wishbone bus interface signals for addressing, data handling, and transaction control.\n\nOutput ports: `new_data_int, scan_out0, scan_out1, scan_out2, scan_out3, scan_out4, o_wb_dat, o_wb_ack, o_wb_err`.\nExplanation:\n- `new_data_int`: Interrupt output that signals when new data is available in the buffers, notifying external systems to read it.\n- `scan_out0, scan_out1, scan_out2, scan_out3, scan_out4`: Outputs for scan chain data, potentially used for extending scan chains or for testing outputs.\n- `o_wb_dat`: Data output to the Wishbone bus, conveying the buffered serial data or channel information depending on the bus address provided.\n- `o_wb_ack`: Acknowledgment signal for the Wishbone bus, indicating that a read or write operation has been successfully completed.\n- `o_wb_err`: Error signal for the Wishbone bus, indicating any errors in the bus operations (constantly set to 0 in this design, implying no error reporting)."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: `sys_clk, serial_clk, selected_clk, ch_count, bit_count, prev_frame_sync, data_out_buf, ch_buf_1, ch_buf_2, data_buf_1, data_buf_2, start_read, int_buf_1, int_set, bit_count_buf, tdmi_begin, fs_start`.\n\nExplanation:\n- `sys_clk`: Buffer output of the system clock `clk`. Used for internal operations and timing that are independent of the serial data reading.\n- `serial_clk`: Inverted output of `selected_clk`, used as the clock source for serial data operations.\n- `selected_clk`: Based on `test_mode`, it selects between `clk` (test mode) and `ser_clk` (normal mode for serial data operations).\n- `ch_count`: Counts the channel or frame number as data is being read; increments after a complete data frame is read.\n- `bit_count`: Tracks the bit position within the current data byte being read from `data_in`.\n- `prev_frame_sync`: Stores the previous state of the `frame_sync` to detect rising edges indicating the start of a new data batch.\n- `data_out_buf`: Stores the incoming bits from `data_in` to form a complete byte.\n- `ch_buf_1, ch_buf_2`: Buffers for transferring channel count to the output in a pipelined manner.\n- `data_buf_1, data_buf_2`: Buffers for transferring data bytes to the output; ensures stable output data through pipelining.\n- `start_read`: Controls the readiness of the buffer to be read via the Wishbone interface.\n- `int_buf_1, int_set`: Manage internal flags to generate a new data available interrupt (`new_data_int`).\n- `bit_count_buf`: Buffer for `bit_count` used to handle changes across different clock domains.\n- `tdmi_begin`: Controls the activation/deactivation of the serial data reading logic based on external control signals.\n- `fs_start`: Flag set upon detecting the start of a frame, used for managing data reads and interrupt generation."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule TDMI (\n\t\tinput reset,\n\t\tinput ser_clk,\n\t\tinput data_in,\n\t\tinput frame_sync,\n\t\tinput scan_in0,\n\t\tinput scan_in1,\n\t\tinput scan_in2,\n\t\tinput scan_in3,\n\t\tinput scan_in4,\n\t\tinput scan_enable,\n\t\tinput test_mode,\n\t\toutput reg new_data_int,\n\t\toutput scan_out0,\n\t\toutput scan_out1,\n\t\toutput scan_out2,\n\t\toutput scan_out3,\n\t\toutput scan_out4,\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tinput\t\tclk,\n\t\tinput       [31:0]          i_wb_adr,\t\n\t\tinput       [3:0] \t    i_wb_sel,\t\n\t\tinput                       i_wb_we,\t\n\t\toutput reg  [31:0] \t    o_wb_dat,\t\n\t\tinput       [31:0] \t    i_wb_dat,\t\n\t\tinput                       i_wb_cyc,\t\n\t\tinput                       i_wb_stb,\t\n\t\toutput\t                o_wb_ack,\t\n\t\toutput                      o_wb_err\t\n);\n\n`include \"../include/register_addresses.vh\"\t\t\n\n\nwire \t sys_clk, serial_clk;\t\t\nwire\t selected_clk;\t\t\t\n\nreg [4:0] \tch_count;\t\t\t\nreg [2:0] \tbit_count;\t\t\t\nreg\t\tprev_frame_sync;\t\t\nreg [7:0]\tdata_out_buf;\t\t\nreg [4:0] \tch_buf_1, ch_buf_2;\t\nreg [7:0] \tdata_buf_1, data_buf_2; \nreg\t\tstart_read;\nreg\t\tint_buf_1;\nreg\t\tint_set;\nreg [2:0]\tbit_count_buf;\nreg\t\ttdmi_begin;\nreg\t\tfs_start;\n\nassign o_wb_ack = (i_wb_we) ? (i_wb_stb & i_wb_cyc) : (i_wb_stb & i_wb_cyc & start_read) ;\t\n\nassign o_wb_err = 1'b0;\t\t\t\t\n\nCLKBUFX4 clk_buf_1 (\t\t\t\t\n\t.A(clk),\n\t.Y(sys_clk)\n);\n\nassign selected_clk = (test_mode) ? (clk) : (ser_clk);\t\n\nCLKINVX4 clk_buf_2 (\t\t\t\t\t\t\t\n\t.A(selected_clk),\n\t.Y(serial_clk)\n);\n\n\n\n\nalways@ (posedge serial_clk, posedge reset) begin\n\tif (reset) begin\t\t\t\t\t\t\n\t\tch_count\t\t<= 5'b00000;\n\t\tbit_count\t\t<= 3'b111;\t\t\t\n\t\tprev_frame_sync \t<= 1'b0;\n\t\tdata_out_buf \t<= 8'h00;\n\t\tfs_start\t\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\t\n\t\t\t\tch_count <= 5'b00000;\t\t\t\n\t\t\t\tdata_out_buf[7] <= data_in;\t\t\n\t\t\t\tbit_count <= 3'b110;\t\t\t\n\t\t\t\tfs_start <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tdata_out_buf[bit_count] <= data_in;\t\n\t\t\t\tbit_count <= bit_count - 3'b001;\t\n\t\t\t\tif (bit_count == 3'b111) begin\t\n\t\t\t\t\tch_count <= ch_count + 5'b00001;\t\n\t\t\t\tend\n\t\t\tend\n\t\t\tprev_frame_sync <= frame_sync;\t\t\n\t\tend\n\tend\nend\n\n\nalways@ (posedge sys_clk, posedge reset) begin\n\n\tif (reset) begin\n\t\tdata_buf_1\t<= 8'h00;\n\t\tdata_buf_2\t<= 8'h00;\n\t\tch_buf_1\t<= 5'b00000;\n\t\tch_buf_2\t<= 5'b00000;\n\t\to_wb_dat\t<= 32'h00000000;\n\t\tint_buf_1   <= 1'b0;\n\t\tint_set\t<= 1'b0;\n\t\tnew_data_int <= 1'b0;\n\t\tstart_read <= 1'b0;\n\t\tbit_count_buf <= 3'b000;\n\t\ttdmi_begin\t<= 1'b0;\n\tend else begin\n\t\tif (tdmi_begin) begin\n\t\t\tbit_count_buf <= bit_count;\n\t\t\tif ((~prev_frame_sync) & frame_sync) begin\n\t\t\t\tint_buf_1 <= 1'b0;\n\t\t\t\tint_set <= int_set;\n\t\t\tend else if ((bit_count_buf != 3'b111) || (bit_count != 3'b111)) begin\n\t\t\t\tint_set <= 1'b0;\n\t\t\t\tint_buf_1 <= int_buf_1;\n\t\t\tend else if (~int_set & fs_start) begin\n\t\t\t\tint_buf_1 <= 1'b1;\t\n\t\t\t\tint_set <= 1'b1;\n\t\t\tend\n\t\t\tnew_data_int <= int_buf_1;\n\t\t\tif (bit_count == 3'b111) begin\n\t\t\t\tch_buf_1 <= ch_count;\t\n\t\t\t\tdata_buf_1 <= data_out_buf; \n\t\t\tend\n\t\t\tdata_buf_2 <= data_buf_1;\t\n\t\t\tch_buf_2 <= ch_buf_1;\n\t\tend\n\t\tif (i_wb_stb & i_wb_cyc & (~i_wb_we)) begin\t\n\t\t\tcase (i_wb_adr[15:0])\t\t\t\t\n\t\t\t\tTDMI_ALL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_CHANNEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {27'h0000000, ch_buf_2[4:0]};\t\t\n\t\t\t\t\tend\n\t\t\t\tTDMI_DATA:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {24'h00000, data_buf_2};\t\t\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\to_wb_dat <= {19'h00000, ch_buf_2, data_buf_2};\t\n\t\t\t\t\tend\n\t\t\tendcase\n\t\t\tstart_read <= 1'b1;\n\t\t\tint_buf_1 <= 1'b0;\t\n\t\tend else if (i_wb_stb & i_wb_cyc & i_wb_we) begin\n\t\t\tcase (i_wb_adr[15:0])\n\t\t\t\tTDMI_START:\n\t\t\t\t\tbegin\n\t\t\t\t\t\ttdmi_begin <= i_wb_dat[0];\n\t\t\t\t\tend\n\t\t\t\tdefault:\ttdmi_begin <= 1'b0;\n\t\t\tendcase\n\t\t\tstart_read <= 1'b0;\n\t\tend else begin\n\t\t\tstart_read <= 1'b0;\n\t\tend\n\tend\nend\n\n\nendmodule \n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: TDMI. Module specification: The TDMI (Time Division Multiplexed Input) module is designed for handling serial data input with synchronization requirements and testability support. It reads serial data `data_in` on every rising edge of a clock, which is chosen based on the `test_mode` input to decide between `ser_clk` (operation clock) and `clk` (test clock). The module detects the start of a data frame via the `frame_sync` signal and increments channels and data bits accordingly, interfacing with a Wishbone bus for data transfer and control. Input ports include `reset`, `ser_clk`, `data_in`, `frame_sync`, `scan_in0` to `scan_in4` (for scan chain), `scan_enable`, `test_mode`, `clk`, and Wishbone bus signals such as `i_wb_adr` and `i_wb_dat`. Output ports are `new_data_int` (a new data available interrupt), `scan_out0` to `scan_out4` (scan chain outputs), and Wishbone bus responses including `o_wb_dat` (output data), `o_wb_ack` (data transaction acknowledgment), and `o_wb_err` (error indication fixed at 0). Internally, the module uses signals such as `sys_clk` and `serial_clk` for timing, and various registers like `ch_count` and `bit_count` for tracking data state and `data_out_buf` for assembling incoming serial data. The code includes multiple blocks: clock selection and buffer instantiation defining operational or test mode clock handling, data processing and state management in response to clock edges for reading and buffering data, and another block handling Wishbone bus interactions, enabling data readout, module control via bus commands, and interrupt management."
                }
            ]
        }
    ]
}