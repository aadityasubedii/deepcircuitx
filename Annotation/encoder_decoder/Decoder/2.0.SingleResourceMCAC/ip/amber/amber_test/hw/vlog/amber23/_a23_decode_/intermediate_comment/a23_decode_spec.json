{
    "spec": "Module name: a23_decode. Module specification: The a23_decode module is responsible for decoding ARM instructions in an ARM processor. It takes inputs such as clock (i_clk), read data (i_read_data), fetch stall signals (i_fetch_stall), interrupt requests (i_irq, i_firq), abort signals (i_dabt, i_iabt, i_adex), execute address (i_execute_address), abort status (i_abt_status), execute status bits (i_execute_status_bits), and multiply done signal (i_multiply_done). The module generates numerous output signals including decoded instruction information, register selection signals, ALU and barrel shifter control signals, memory access control signals, status bits and mode control signals, coprocessor operation signals, and abort handling signals. Internally, it uses various signals to manage instruction decoding, execution control, and state",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: a23_decode\n\nExplanation: This module is responsible for decoding ARM instructions in an ARM processor. It takes various inputs such as clock, read data, fetch stall signals, interrupt requests, and status bits. The module decodes the instruction, determines the operation to be performed, and generates control signals for other parts of the processor. It handles different instruction types including data processing, memory operations, branch instructions, and coprocessor operations. The module also manages the processor's state machine, which controls the execution flow of instructions and handles interrupts. Overall, it plays a crucial role in instruction decoding and execution control within the ARM processor."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: i_clk, i_read_data, i_fetch_stall, i_irq, i_firq, i_dabt, i_iabt, i_adex, i_execute_address, i_abt_status, i_execute_status_bits, i_multiply_done.\n\nExplanation:\n- i_clk: Clock input\n- i_read_data: Data read from memory\n- i_fetch_stall: Signal to stall instruction fetch\n- i_irq, i_firq: Interrupt request signals\n- i_dabt, i_iabt: Data and instruction abort signals\n- i_adex: Address exception signal\n- i_execute_address: Address of executing instruction\n- i_abt_status: Abort status\n- i_execute_status_bits: Status bits of executing instruction\n- i_multiply_done: Signal indicating multiplication completion\n\nOutput ports: o_read_data, o_read_data_alignment, o_imm32, o_imm_shift_amount, o_shift_imm_zero, o_condition, o_exclusive_exec, o_data_access_exec, o_status_bits_mode, o_status_bits_irq_mask, o_status_bits_firq_mask, o_rm_sel, o_rds_sel, o_rn_sel, o_rm_sel_nxt, o_rds_sel_nxt, o_rn_sel_nxt, o_barrel_shift_amount_sel, o_barrel_shift_data_sel, o_barrel_shift_function, o_alu_function, o_use_carry_in, o_multiply_function, o_interrupt_vector_sel, o_address_sel, o_pc_sel, o_byte_enable_sel, o_status_bits_sel, o_reg_write_sel, o_user_mode_regs_load, o_user_mode_regs_store_nxt, o_firq_not_user_mode, o_write_data_wen, o_base_address_wen, o_pc_wen, o_reg_bank_wen, o_reg_bank_wsel, o_status_bits_flags_wen, o_status_bits_mode_wen, o_status_bits_irq_mask_wen, o_status_bits_firq_mask_wen, o_copro_opcode1, o_copro_opcode2, o_copro_crn, o_copro_crm, o_copro_num, o_copro_operation, o_copro_write_data_wen, o_iabt_trigger, o_iabt_address, o_iabt_status, o_dabt_trigger, o_dabt_address, o_dabt_status.\n\nExplanation:\nThese output ports provide control signals, data, and status information for various components of the processor, including:\n- Decoded instruction information (e.g., o_imm32, o_condition)\n- Register selection signals (e.g., o_rm_sel, o_rds_sel, o_rn_sel)\n- ALU and barrel shifter control signals (e.g., o_alu_function, o_barrel_shift_function)\n- Memory access control signals (e.g., o_byte_enable_sel, o_write_data_wen)\n- Status bits and mode control signals (e.g., o_status_bits_mode, o_status_bits_flags_wen)\n- Coprocessor operation signals (e.g., o_copro_opcode1, o_copro_operation)\n- Abort and exception handling signals (e.g., o_iabt_trigger, o_dabt_address)\n\nThese outputs are used to control the execution of instructions and manage the processor's state."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\ninstruction, instruction_iabt, instruction_adex, instruction_address, instruction_iabt_status, instruction_sel, itype, opcode, imm8, offset12, offset24, shift_imm, opcode_compare, mem_op, load_op, store_op, write_pc, immediate_shifter_operand, rds_use_rs, branch, mem_op_pre_indexed, mem_op_post_indexed, imm32_nxt, imm_shift_amount_nxt, shift_imm_zero_nxt, condition_nxt, exclusive_exec_nxt, data_access_exec_nxt, shift_extend, barrel_shift_function_nxt, alu_function_nxt, use_carry_in_nxt, multiply_function_nxt, status_bits_mode_nxt, status_bits_irq_mask_nxt, status_bits_firq_mask_nxt, barrel_shift_amount_sel_nxt, barrel_shift_data_sel_nxt, address_sel_nxt, pc_sel_nxt, byte_enable_sel_nxt, status_bits_sel_nxt, reg_write_sel_nxt, user_mode_regs_load_nxt, firq_not_user_mode_nxt, alu_swap_sel_nxt, alu_not_sel_nxt, alu_cin_sel_nxt, alu_cout_sel_nxt, alu_out_sel_nxt, write_data_wen_nxt, copro_write_data_wen_nxt, base_address_wen_nxt, pc_wen_nxt, reg_bank_wsel_nxt, status_bits_flags_wen_nxt, status_bits_mode_wen_nxt, status_bits_irq_mask_wen_nxt, status_bits_firq_mask_wen_nxt, saved_current_instruction_wen, pre_fetch_instruction_wen, control_state, control_state_nxt, dabt, dabt_reg, dabt_reg_d1, iabt_reg, adex_reg, abt_address_reg, abt_status_reg, saved_current_instruction, saved_current_instruction_iabt, saved_current_instruction_adex, saved_current_instruction_address, saved_current_instruction_iabt_status, pre_fetch_instruction, pre_fetch_instruction_iabt, pre_fetch_instruction_adex, pre_fetch_instruction_address, pre_fetch_instruction_iabt_status, instruction_valid, instruction_execute, mtrans_reg, mtrans_reg_d1, mtrans_reg_d2, mtrans_instruction_nxt, mtrans_base_reg_change, mtrans_num_registers, use_saved_current_instruction, use_pre_fetch_instruction, interrupt, interrupt_mode, next_interrupt, irq, firq, firq_request, irq_request, swi_request, und_request, dabt_request, copro_operation_nxt, mtrans_r15, mtrans_r15_nxt, restore_base_address, restore_base_address_nxt, regop_set_flags.\n\nExplanation:\nThese internal signals serve various purposes in the module:\n- instruction-related signals (e.g., instruction, instruction_iabt) hold and manage instruction data and associated information.\n- Control signals (e.g., mem_op, load_op, write_pc) indicate specific operations or conditions.\n- Next-cycle value signals (e.g., imm32_nxt, barrel_shift_function_nxt) store values for the next clock cycle.\n- State-related signals (e.g., control_state, control_state_nxt) manage the module's state machine.\n- Interrupt and exception-related signals (e.g., irq, firq, dabt) handle various interrupt and exception conditions.\n- Instruction type and operation signals (e.g., itype, opcode) classify and identify instruction types and operations.\n- Register and data manipulation signals (e.g., reg_bank_wsel_nxt, alu_out_sel_nxt) control register selection and ALU operations.\n- Memory access signals (e.g., mem_op_pre_indexed, byte_enable_sel_nxt) manage memory operations.\n- Status and mode signals (e.g., status_bits_mode_nxt, firq_not_user_mode_nxt) handle processor status and operating modes.\n\nThese signals work together to decode instructions, control execution flow, manage interrupts and exceptions, and generate control signals for other parts of the processor."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"global_defines.vh\"\n\nmodule a23_decode\n(\ninput                       i_clk,\ninput       [31:0]          i_read_data,\ninput                       i_fetch_stall,                  \ninput                       i_irq,                          \ninput                       i_firq,                         \ninput                       i_dabt,                         \ninput                       i_iabt,                         \ninput                       i_adex,                         \ninput       [31:0]          i_execute_address,              \n                                                            \n                                                            \ninput       [7:0]           i_abt_status,                   \ninput       [31:0]          i_execute_status_bits,          \ninput                       i_multiply_done,                \n\n\n\n\n\noutput reg  [31:0]          o_read_data = 1'd0,\noutput reg  [4:0]           o_read_data_alignment = 1'd0,  \n\noutput reg  [31:0]          o_imm32 = 'd0,\noutput reg  [4:0]           o_imm_shift_amount = 'd0,\noutput reg                  o_shift_imm_zero = 'd0,\noutput wire [3:0]           o_condition,\noutput reg                  o_exclusive_exec = 'd0,         \noutput reg                  o_data_access_exec = 'd0,       \n                                                            \noutput wire [1:0]           o_status_bits_mode,\noutput wire                 o_status_bits_irq_mask,\noutput wire                 o_status_bits_firq_mask,\n\noutput reg  [3:0]           o_rm_sel = 'd0,\noutput reg  [3:0]           o_rds_sel = 'd0,\noutput reg  [3:0]           o_rn_sel = 'd0,\noutput      [3:0]           o_rm_sel_nxt,\noutput      [3:0]           o_rds_sel_nxt,\noutput      [3:0]           o_rn_sel_nxt,\noutput reg  [1:0]           o_barrel_shift_amount_sel = 'd0,\noutput reg  [1:0]           o_barrel_shift_data_sel = 'd0,\noutput reg  [1:0]           o_barrel_shift_function = 'd0,\noutput reg  [8:0]           o_alu_function = 'd0,\noutput reg                  o_use_carry_in = 'd0,\noutput reg  [1:0]           o_multiply_function = 'd0,\noutput reg  [2:0]           o_interrupt_vector_sel = 'd0,\noutput wire [3:0]           o_address_sel,\noutput wire [1:0]           o_pc_sel,\noutput reg  [1:0]           o_byte_enable_sel = 'd0,        \noutput reg  [2:0]           o_status_bits_sel = 'd0,\noutput reg  [2:0]           o_reg_write_sel,\noutput reg                  o_user_mode_regs_load,\noutput reg                  o_user_mode_regs_store_nxt,\noutput reg                  o_firq_not_user_mode,\n\noutput reg                  o_write_data_wen = 'd0,\noutput reg                  o_base_address_wen = 'd0,       \n                                                            \noutput wire                 o_pc_wen,\noutput reg  [14:0]          o_reg_bank_wen = 'd0,\noutput reg  [3:0]           o_reg_bank_wsel = 'd0,\noutput reg                  o_status_bits_flags_wen = 'd0,\noutput reg                  o_status_bits_mode_wen = 'd0,\noutput reg                  o_status_bits_irq_mask_wen = 'd0,\noutput reg                  o_status_bits_firq_mask_wen = 'd0,\n\n\n\n\noutput reg  [2:0]           o_copro_opcode1 = 'd0,\noutput reg  [2:0]           o_copro_opcode2 = 'd0,\noutput reg  [3:0]           o_copro_crn = 'd0,\noutput reg  [3:0]           o_copro_crm = 'd0,\noutput reg  [3:0]           o_copro_num = 'd0,\noutput reg  [1:0]           o_copro_operation = 'd0, \n                                                     \n                                                     \noutput reg                  o_copro_write_data_wen = 'd0,\noutput                      o_iabt_trigger,\noutput      [31:0]          o_iabt_address,\noutput      [7:0]           o_iabt_status,\noutput                      o_dabt_trigger,\noutput      [31:0]          o_dabt_address,\noutput      [7:0]           o_dabt_status\n\n\n);\n\n`include \"a23_localparams.vh\"\n`include \"a23_functions.vh\"\n\nlocalparam [4:0] RST_WAIT1      = 5'd0,\n                 RST_WAIT2      = 5'd1,\n                 INT_WAIT1      = 5'd2,\n                 INT_WAIT2      = 5'd3,\n                 EXECUTE        = 5'd4,\n                 PRE_FETCH_EXEC = 5'd5,  \n                 MEM_WAIT1      = 5'd6,  \n                                         \n                 MEM_WAIT2      = 5'd7,\n                 PC_STALL1      = 5'd8,  \n                                         \n                                         \n                 PC_STALL2      = 5'd9,\n                 MTRANS_EXEC1   = 5'd10,\n                 MTRANS_EXEC2   = 5'd11,\n                 MTRANS_EXEC3   = 5'd12,\n                 MTRANS_EXEC3B  = 5'd13,\n                 MTRANS_EXEC4   = 5'd14,\n                 MTRANS5_ABORT  = 5'd15,\n                 MULT_PROC1     = 5'd16,  \n                 MULT_PROC2     = 5'd17,  \n                 MULT_STORE     = 5'd19,  \n                 MULT_ACCUMU    = 5'd20,  \n                 SWAP_WRITE     = 5'd22,\n                 SWAP_WAIT1     = 5'd23,\n                 SWAP_WAIT2     = 5'd24,\n                 COPRO_WAIT     = 5'd25;\n\n\n\n\n\nwire    [31:0]         instruction;\nwire                   instruction_iabt;        \nwire                   instruction_adex;        \nwire    [31:0]         instruction_address;     \n                                                \nwire    [7:0]          instruction_iabt_status; \nwire    [1:0]          instruction_sel;\nreg     [3:0]          itype;\nwire    [3:0]          opcode;\nwire    [7:0]          imm8;\nwire    [31:0]         offset12;\nwire    [31:0]         offset24;\nwire    [4:0]          shift_imm;\n\nwire                   opcode_compare;\nwire                   mem_op;\nwire                   load_op;\nwire                   store_op;\nwire                   write_pc;\nwire                   immediate_shifter_operand;\nwire                   rds_use_rs;\nwire                   branch;\nwire                   mem_op_pre_indexed;\nwire                   mem_op_post_indexed;\n\n\nwire    [31:0]         imm32_nxt;\nwire    [4:0]          imm_shift_amount_nxt;\nwire                   shift_imm_zero_nxt;\nwire    [3:0]          condition_nxt;\nreg                    exclusive_exec_nxt;\nreg                    data_access_exec_nxt;\nwire                   shift_extend;\n\nreg     [1:0]          barrel_shift_function_nxt;\nwire    [8:0]          alu_function_nxt;\nreg                    use_carry_in_nxt;\nreg     [1:0]          multiply_function_nxt;\nreg     [1:0]          status_bits_mode_nxt;\nreg                    status_bits_irq_mask_nxt;\nreg                    status_bits_firq_mask_nxt;\n\nreg     [1:0]          barrel_shift_amount_sel_nxt;\nreg     [1:0]          barrel_shift_data_sel_nxt;\nreg     [3:0]          address_sel_nxt;\nreg     [1:0]          pc_sel_nxt;\nreg     [1:0]          byte_enable_sel_nxt;\nreg     [2:0]          status_bits_sel_nxt;\nreg     [2:0]          reg_write_sel_nxt;\nreg                    user_mode_regs_load_nxt;\nwire                   firq_not_user_mode_nxt;\n\n\nreg                    alu_swap_sel_nxt;\nreg                    alu_not_sel_nxt;\nreg     [1:0]          alu_cin_sel_nxt;\nreg                    alu_cout_sel_nxt;\nreg     [3:0]          alu_out_sel_nxt;\n\nreg                    write_data_wen_nxt;\nreg                    copro_write_data_wen_nxt;\nreg                    base_address_wen_nxt;\nreg                    pc_wen_nxt;\nreg     [3:0]          reg_bank_wsel_nxt;\nreg                    status_bits_flags_wen_nxt;\nreg                    status_bits_mode_wen_nxt;\nreg                    status_bits_irq_mask_wen_nxt;\nreg                    status_bits_firq_mask_wen_nxt;\n\nreg                    saved_current_instruction_wen;   \nreg                    pre_fetch_instruction_wen;       \n\nreg     [4:0]          control_state = RST_WAIT1;\nreg     [4:0]          control_state_nxt;\n\n\nwire                   dabt;\nreg                    dabt_reg = 'd0;\nreg                    dabt_reg_d1;\nreg                    iabt_reg = 'd0;\nreg                    adex_reg = 'd0;\nreg     [31:0]         abt_address_reg = 'd0;\nreg     [7:0]          abt_status_reg = 'd0;\nreg     [31:0]         saved_current_instruction = 'd0;\nreg                    saved_current_instruction_iabt = 'd0;          \nreg                    saved_current_instruction_adex = 'd0;          \nreg     [31:0]         saved_current_instruction_address = 'd0;       \nreg     [7:0]          saved_current_instruction_iabt_status = 'd0;   \nreg     [31:0]         pre_fetch_instruction = 'd0;\nreg                    pre_fetch_instruction_iabt = 'd0;              \nreg                    pre_fetch_instruction_adex = 'd0;              \nreg     [31:0]         pre_fetch_instruction_address = 'd0;           \nreg     [7:0]          pre_fetch_instruction_iabt_status = 'd0;       \n\nwire                   instruction_valid;\nwire                   instruction_execute;\n\nreg     [3:0]          mtrans_reg;              \nreg     [3:0]          mtrans_reg_d1 = 'd0;     \nreg     [3:0]          mtrans_reg_d2 = 'd0;     \nreg     [31:0]         mtrans_instruction_nxt;\n\nwire   [31:0]          mtrans_base_reg_change;\nwire   [4:0]           mtrans_num_registers;\nwire                   use_saved_current_instruction;\nwire                   use_pre_fetch_instruction;\nwire                   interrupt;\nwire   [1:0]           interrupt_mode;\nwire   [2:0]           next_interrupt;\nreg                    irq = 'd0;\nreg                    firq = 'd0;\nwire                   firq_request;\nwire                   irq_request;\nwire                   swi_request;\nwire                   und_request;\nwire                   dabt_request;\nreg    [1:0]           copro_operation_nxt;\nreg                    mtrans_r15 = 'd0;\nreg                    mtrans_r15_nxt;\nreg                    restore_base_address = 'd0;\nreg                    restore_base_address_nxt;\n\nwire                   regop_set_flags;\n\n\n\n\n\nreg  [3:0]           condition_r = 4'he;             \nreg  [1:0]           status_bits_mode_r = 2'b11;     \nreg                  status_bits_irq_mask_r = 1'd1;\nreg                  status_bits_firq_mask_r = 1'd1;\nreg  [3:0]           address_sel_r = 4'd2;\nreg  [1:0]           pc_sel_r = 2'd2;\nreg                  pc_wen_r = 1'd1;\n\nassign o_condition              = condition_r;\nassign o_status_bits_mode       = status_bits_mode_r;\nassign o_status_bits_irq_mask   = status_bits_irq_mask_r;\nassign o_status_bits_firq_mask  = status_bits_firq_mask_r;\nassign o_address_sel            = address_sel_r;\nassign o_pc_sel                 = pc_sel_r;\nassign o_pc_wen                 = pc_wen_r;\n\n\n\n\n\n\n\nassign o_iabt_trigger     = instruction_iabt && status_bits_mode_r == SVC && control_state == INT_WAIT1;\nassign o_iabt_address     = instruction_address;\nassign o_iabt_status      = instruction_iabt_status;\n\nassign o_dabt_trigger     = dabt_reg && !dabt_reg_d1;\nassign o_dabt_address     = abt_address_reg;\nassign o_dabt_status      = abt_status_reg;\n\n\n\n\n\n\n\n\n\n\n\n\n\nassign use_saved_current_instruction =  instruction_execute &&\n                          ( control_state == MEM_WAIT1     ||\n                            control_state == MEM_WAIT2     ||\n                            control_state == MTRANS_EXEC1  ||\n                            control_state == MTRANS_EXEC2  ||\n                            control_state == MTRANS_EXEC3  ||\n                            control_state == MTRANS_EXEC3B ||\n                            control_state == MTRANS_EXEC4  ||\n                            control_state == MTRANS5_ABORT ||\n                            control_state == MULT_PROC1    ||\n                            control_state == MULT_PROC2    ||\n                            control_state == MULT_ACCUMU   ||\n                            control_state == MULT_STORE    ||\n                            control_state == INT_WAIT1     ||\n                            control_state == INT_WAIT2     ||\n                            control_state == SWAP_WRITE    ||\n                            control_state == SWAP_WAIT1    ||\n                            control_state == SWAP_WAIT2    ||\n                            control_state == COPRO_WAIT     );\n\nassign use_pre_fetch_instruction = control_state == PRE_FETCH_EXEC;\n\n\nassign instruction_sel  =         use_saved_current_instruction  ? 2'd1 :  \n                                  use_pre_fetch_instruction      ? 2'd2 :  \n                                                                   2'd0 ;  \n\nassign instruction      =         instruction_sel == 2'd0 ? o_read_data               :\n                                  instruction_sel == 2'd1 ? saved_current_instruction :\n                                                            pre_fetch_instruction     ;\n\n\nassign instruction_iabt =         instruction_sel == 2'd0 ? iabt_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt :\n                                                            pre_fetch_instruction_iabt     ;\n\nassign instruction_address =      instruction_sel == 2'd0 ? abt_address_reg                   :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_address :\n                                                            pre_fetch_instruction_address     ;\n\nassign instruction_iabt_status =  instruction_sel == 2'd0 ? abt_status_reg                        :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt_status :\n                                                            pre_fetch_instruction_iabt_status     ;\n\n\nassign instruction_adex =         instruction_sel == 2'd0 ? adex_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_adex :\n                                                            pre_fetch_instruction_adex     ;\n\n\nalways @*\n    casez ({instruction[27:20], instruction[7:4]})\n        12'b00010?001001 : itype = SWAP;\n        12'b000000??1001 : itype = MULT;\n        12'b00?????????? : itype = REGOP;\n        12'b01?????????? : itype = TRANS;\n        12'b100????????? : itype = MTRANS;\n        12'b101????????? : itype = BRANCH;\n        12'b110????????? : itype = CODTRANS;\n        12'b1110???????0 : itype = COREGOP;\n        12'b1110???????1 : itype = CORTRANS;\n        default:           itype = SWI;\n    endcase\n\n\n\n\n\n\nassign opcode        = instruction[24:21];\nassign condition_nxt = instruction[31:28];\n\nassign o_rm_sel_nxt    = instruction[3:0];\n\nassign o_rn_sel_nxt    = branch  ? 4'd15              : \n                                   instruction[19:16] ;\n\nassign o_rds_sel_nxt   = control_state == SWAP_WRITE  ? instruction[3:0]   : \n                         itype == MTRANS              ? mtrans_reg         :\n                         branch                       ? 4'd15              : \n                         rds_use_rs                   ? instruction[11:8]  :\n                                                        instruction[15:12] ;\n\n\nassign shift_imm     = instruction[11:7];\n\n\nassign shift_extend  = !instruction[25] && !instruction[4] && !(|instruction[11:7]) && instruction[6:5] == 2'b11;\n\nassign offset12      = { 20'h0, instruction[11:0]};\nassign offset24      = {{6{instruction[23]}}, instruction[23:0], 2'd0 }; \nassign imm8          = instruction[7:0];\n\nassign immediate_shifter_operand = instruction[25];\nassign rds_use_rs                = (itype == REGOP && !instruction[25] && instruction[4]) ||\n                                   (itype == MULT &&\n                                    (control_state == MULT_PROC1  ||\n                                     control_state == MULT_PROC2  ||\n                                     instruction_valid && !interrupt )) ;\nassign branch                    = itype == BRANCH;\nassign opcode_compare =\n            opcode == CMP ||\n            opcode == CMN ||\n            opcode == TEQ ||\n            opcode == TST ;\n\n\nassign mem_op               = itype == TRANS;\nassign load_op              = mem_op && instruction[20];\nassign store_op             = mem_op && !instruction[20];\nassign write_pc             = pc_wen_nxt && pc_sel_nxt != 2'd0;\nassign regop_set_flags      = itype == REGOP && instruction[20];\n\nassign mem_op_pre_indexed   =  instruction[24] && instruction[21];\nassign mem_op_post_indexed  = !instruction[24];\n\nassign imm32_nxt            =  \n                               itype == MULT               ? {  32'd0                      } :\n\n                               \n                               itype == MTRANS             ? {  mtrans_base_reg_change     } :\n                               itype == BRANCH             ? {  offset24                   } :\n                               itype == TRANS              ? {  offset12                   } :\n                               instruction[11:8] == 4'h0  ? {            24'h0, imm8[7:0] } :\n                               instruction[11:8] == 4'h1  ? { imm8[1:0], 24'h0, imm8[7:2] } :\n                               instruction[11:8] == 4'h2  ? { imm8[3:0], 24'h0, imm8[7:4] } :\n                               instruction[11:8] == 4'h3  ? { imm8[5:0], 24'h0, imm8[7:6] } :\n                               instruction[11:8] == 4'h4  ? { imm8[7:0], 24'h0            } :\n                               instruction[11:8] == 4'h5  ? { 2'h0,  imm8[7:0], 22'h0     } :\n                               instruction[11:8] == 4'h6  ? { 4'h0,  imm8[7:0], 20'h0     } :\n                               instruction[11:8] == 4'h7  ? { 6'h0,  imm8[7:0], 18'h0     } :\n                               instruction[11:8] == 4'h8  ? { 8'h0,  imm8[7:0], 16'h0     } :\n                               instruction[11:8] == 4'h9  ? { 10'h0, imm8[7:0], 14'h0     } :\n                               instruction[11:8] == 4'ha  ? { 12'h0, imm8[7:0], 12'h0     } :\n                               instruction[11:8] == 4'hb  ? { 14'h0, imm8[7:0], 10'h0     } :\n                               instruction[11:8] == 4'hc  ? { 16'h0, imm8[7:0], 8'h0      } :\n                               instruction[11:8] == 4'hd  ? { 18'h0, imm8[7:0], 6'h0      } :\n                               instruction[11:8] == 4'he  ? { 20'h0, imm8[7:0], 4'h0      } :\n                                                            { 22'h0, imm8[7:0], 2'h0      } ;\n\n\nassign imm_shift_amount_nxt = shift_imm ;\n\n       \n       \nassign shift_imm_zero_nxt   = imm_shift_amount_nxt == 5'd0 &&       \n                              barrel_shift_amount_sel_nxt == 2'd2;  \n\nassign alu_function_nxt     = { alu_swap_sel_nxt,\n                                alu_not_sel_nxt,\n                                alu_cin_sel_nxt,\n                                alu_cout_sel_nxt,\n                                alu_out_sel_nxt  };\n\n\n\n\n\n\n   \n   \n   \nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_reg = 4'h0 ;\n    16'b??????????????10 : mtrans_reg = 4'h1 ;\n    16'b?????????????100 : mtrans_reg = 4'h2 ;\n    16'b????????????1000 : mtrans_reg = 4'h3 ;\n    16'b???????????10000 : mtrans_reg = 4'h4 ;\n    16'b??????????100000 : mtrans_reg = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg = 4'h6 ;\n    16'b????????10000000 : mtrans_reg = 4'h7 ;\n    16'b???????100000000 : mtrans_reg = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg = 4'ha ;\n    16'b????100000000000 : mtrans_reg = 4'hb ;\n    16'b???1000000000000 : mtrans_reg = 4'hc ;\n    16'b??10000000000000 : mtrans_reg = 4'hd ;\n    16'b?100000000000000 : mtrans_reg = 4'he ;\n    default              : mtrans_reg = 4'hf ;\n    endcase\n\n\nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase\n\n\n\nassign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;\n\n\nassign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};\n\n\n\n\n\nassign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = itype == SWI;\nassign dabt_request = dabt_reg;\n\n\n\n\nassign und_request  =   itype == CODTRANS ||\n                        itype == COREGOP  ||\n                      ( itype == CORTRANS && instruction[11:8] != 4'd15 );\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \nassign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  \n\n        \n        \n        \nassign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 ;   \n\n\nassign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;\n\n\n\n\n\n\n\nalways @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    exclusive_exec_nxt              = 1'd0;\n    data_access_exec_nxt            = 1'd0;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    mtrans_r15_nxt                  = mtrans_r15;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    address_sel_nxt                 = 'd0;\n    pc_sel_nxt                      = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    user_mode_regs_load_nxt         = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wsel_nxt               = 'hF;  \n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt )\n        begin\n        if ( itype == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt      = 2'd1; \n                    address_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wsel_nxt = instruction[15:12];\n                end\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_function_nxt  = instruction[6:5];\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shifter_operand && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shifter_operand && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt  = 4'd6; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n            end\n\n        \n        if ( mem_op )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( itype == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( o_rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 2'd1;\n                else\n                    reg_bank_wsel_nxt = o_rn_sel_nxt;\n                end\n\n                \n            if ( mem_op_post_indexed )\n               address_sel_nxt = 4'd4; \n            else\n               address_sel_nxt = 4'd1; \n\n            if ( instruction[25] && itype ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( itype == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n        if ( itype == BRANCH )\n            begin\n            pc_sel_nxt      = 2'd1; \n            address_sel_nxt = 4'd1; \n            alu_out_sel_nxt = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wsel_nxt  = 4'd14;  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n        if ( itype == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n            mtrans_r15_nxt                  = instruction[15];  \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] ) \n                begin\n                if ( instruction[24] )    \n                    address_sel_nxt = 4'd7; \n                else\n                    address_sel_nxt = 4'd4; \n                end\n            else \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    address_sel_nxt  = 4'd6; \n                else\n                    address_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            \n            \n            if ( {instruction[22:20],instruction[15]} == 4'b1010 )\n                user_mode_regs_load_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20]} == 3'b100 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wsel_nxt  = o_rn_sel_nxt;\n            end\n\n\n        if ( itype == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( itype == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            barrel_shift_data_sel_nxt       = 2'd2; \n            address_sel_nxt                 = 4'd4; \n            exclusive_exec_nxt              = 1'd1; \n            end\n\n\n        \n        if ( itype == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            address_sel_nxt                 = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( itype == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wsel_nxt               = 4'd14;  \n\n            address_sel_nxt                 = 4'd2;            \n            pc_sel_nxt                      = 2'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end\n\n    \n    \n    \n    \n    \n    \n    if ( instruction_valid && interrupt &&  next_interrupt != 3'd6 )\n        begin\n        \n        \n        \n        saved_current_instruction_wen   = 1'd1;\n\n        \n        \n        if ( next_interrupt == 3'd4 )\n            reg_write_sel_nxt               = 3'd7;            \n        else\n            reg_write_sel_nxt               = 3'd1;            \n\n        reg_bank_wsel_nxt               = 4'd14;           \n\n        address_sel_nxt                 = 4'd2;            \n        pc_sel_nxt                      = 2'd2;            \n\n        status_bits_mode_nxt            = interrupt_mode;  \n        status_bits_mode_wen_nxt        = 1'd1;\n\n        \n        status_bits_irq_mask_nxt        = 1'd1;\n        status_bits_irq_mask_wen_nxt    = 1'd1;\n\n        \n        if ( next_interrupt == 3'd2 ) \n            begin\n            status_bits_firq_mask_nxt        = 1'd1;\n            status_bits_firq_mask_wen_nxt    = 1'd1;\n            end\n        end\n\n\n    \n    \n    if ( control_state == MEM_WAIT1 )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n        end\n\n\n    \n    if ( control_state == MEM_WAIT2 && load_op )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n        barrel_shift_amount_sel_nxt = 2'd3;  \n\n        \n        if ( i_execute_address[1:0] != 2'd0 )\n            barrel_shift_function_nxt = ROR;\n\n        \n        if ( itype == TRANS && instruction[22] )\n            alu_out_sel_nxt             = 4'd3;  \n\n        if ( !dabt )  \n            begin\n            \n            if (instruction[15:12]  == 4'd15)\n                begin\n                pc_sel_nxt      = 2'd1; \n                address_sel_nxt = 4'd1; \n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd5;  \n            pc_wen_nxt                  = 1'd0;  \n            data_access_exec_nxt        = 1'd1;  \n                                                 \n\n            if ( !instruction[20] ) \n                write_data_wen_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20],mtrans_r15} == 4'b1010 )\n                user_mode_regs_load_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20]} == 3'b100 )\n                o_user_mode_regs_store_nxt = 1'd1;\n            end\n        end\n\n\n        \n    if ( control_state == MTRANS_EXEC2 )\n        begin\n        address_sel_nxt             = 4'd5;  \n        pc_wen_nxt                  = 1'd0;  \n        data_access_exec_nxt        = 1'd1;  \n                                             \n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        \n        if ( instruction[20] ) \n            begin\n            \n            \n            if ( !dabt )\n                reg_bank_wsel_nxt = mtrans_reg_d2;\n            end\n        else \n            write_data_wen_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n\n        \n    if ( control_state == MTRANS_EXEC3 && instruction_execute )\n        begin\n        address_sel_nxt             = 4'd3; \n        pc_wen_nxt                  = 1'd0;  \n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        \n        \n        if ( instruction[20] && !dabt ) \n            reg_bank_wsel_nxt = mtrans_reg_d2;\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n       end\n\n    \n    if ( control_state == MTRANS_EXEC3B && instruction_execute )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        address_sel_nxt             = 4'd3;  \n        pc_wen_nxt                  = 1'd0;  \n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n    if ( control_state == MTRANS_EXEC4 )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        if ( instruction[20] ) \n            begin\n            if (!dabt) \n                begin\n                if ( mtrans_reg_d2 == 4'd15 ) \n                    begin\n                    address_sel_nxt = 4'd1; \n                    pc_sel_nxt      = 2'd1; \n                    pc_wen_nxt      = 1'd1; \n\n                    \n                    \n                    \n                    \n                    if ( instruction[22] )\n                         begin\n                         status_bits_sel_nxt           = 3'd1; \n                         status_bits_flags_wen_nxt     = 1'd1;\n\n                         \n                         if ( i_execute_status_bits[1:0] != USR )\n                            begin\n                            status_bits_mode_wen_nxt      = 1'd1;\n                            status_bits_irq_mask_wen_nxt  = 1'd1;\n                            status_bits_firq_mask_wen_nxt = 1'd1;\n                            end\n                         end\n                    end\n                else\n                    begin\n                    reg_bank_wsel_nxt = mtrans_reg_d2;\n                    end\n                end\n            end\n\n           \n        if ( dabt )\n            begin\n            pc_wen_nxt = 1'd0;  \n            end\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n\n    \n    if ( control_state == MTRANS5_ABORT )\n        begin\n        \n        \n        if (restore_base_address) \n            begin\n            reg_write_sel_nxt = 3'd6;                        \n            reg_bank_wsel_nxt  = instruction[19:16];         \n            end\n        end\n\n\n        \n    if ( control_state == MULT_PROC1 && instruction_execute )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n        pc_wen_nxt                  = 1'd0;  \n        multiply_function_nxt       = o_multiply_function;\n        end\n\n\n        \n        \n        \n    if ( control_state == MULT_PROC2 )\n        begin\n        \n        \n        pc_wen_nxt              = 1'd0;  \n        address_sel_nxt         = 4'd3;  \n        multiply_function_nxt   = o_multiply_function;\n        end\n\n\n    \n    \n    if ( control_state == MULT_STORE )\n        begin\n        reg_write_sel_nxt     = 3'd2; \n        multiply_function_nxt = o_multiply_function;\n\n        if ( itype == MULT ) \n            reg_bank_wsel_nxt      = instruction[19:16]; \n        else  \n            reg_bank_wsel_nxt      = instruction[15:12]; \n\n        if ( instruction[20] )  \n            begin\n            status_bits_sel_nxt       = 3'd4; \n            status_bits_flags_wen_nxt = 1'd1;\n            end\n        end\n\n        \n    if ( control_state == MULT_ACCUMU )\n        begin\n        multiply_function_nxt = o_multiply_function;\n        pc_wen_nxt            = 1'd0;  \n        address_sel_nxt       = 4'd3;  \n        end\n\n    \n    if ( control_state == SWAP_WRITE && instruction_execute )\n        begin\n        barrel_shift_data_sel_nxt       = 2'd2; \n        address_sel_nxt                 = 4'd4; \n        write_data_wen_nxt              = 1'd1;\n        data_access_exec_nxt            = 1'd1; \n                                                \n\n        if ( instruction[22] )\n            byte_enable_sel_nxt = 2'd1;         \n\n        if ( instruction_execute )                         \n            pc_wen_nxt                  = 1'd0; \n\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        end\n\n\n    \n    if ( control_state == SWAP_WAIT1 )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n        barrel_shift_amount_sel_nxt = 2'd3;  \n\n        \n        if ( i_execute_address[1:0] != 2'd0 )\n            barrel_shift_function_nxt = ROR;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n\n        \n        if ( instruction[22] )\n            alu_out_sel_nxt = 4'd3;  \n\n        if ( !dabt )\n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                pc_sel_nxt      = 2'd1; \n                address_sel_nxt = 4'd1; \n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n            end\n        end\n\n    \n    if ( control_state == COPRO_WAIT && instruction_execute )\n        begin\n        pre_fetch_instruction_wen = 1'd1;\n\n        if ( instruction[20] ) \n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                \n                \n                status_bits_sel_nxt           = 3'd3;  \n                status_bits_flags_wen_nxt     = 1'd1;\n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                   begin\n                   status_bits_mode_wen_nxt      = 1'd1;\n                   status_bits_irq_mask_wen_nxt  = 1'd1;\n                   status_bits_firq_mask_wen_nxt = 1'd1;\n                   end\n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n\n            reg_write_sel_nxt = 3'd5;     \n            end\n        else \n            begin\n            copro_operation_nxt      = 2'd2;  \n            end\n        end\n\n\n    \n    \n    \n    \n    \n    if ( control_state == INT_WAIT1 )\n        status_bits_mode_nxt            = status_bits_mode_r;   \n\n    end\n\n\n\n\nassign firq_not_user_mode_nxt = !user_mode_regs_load_nxt && status_bits_mode_nxt == FIRQ;\n\n\n\n\n\n\n\nassign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );\n\nassign instruction_valid = (control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                     \n                     \n                    (!instruction_execute && (control_state == PC_STALL1    ||\n                                              control_state == MEM_WAIT1    ||\n                                              control_state == COPRO_WAIT   ||\n                                              control_state == SWAP_WRITE   ||\n                                              control_state == MULT_PROC1   ||\n                                              control_state == MTRANS_EXEC1 ||\n                                              control_state == MTRANS_EXEC3 ||\n                                              control_state == MTRANS_EXEC3B  ) );\n\n\n always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS5_ABORT ) control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if (mtrans_instruction_nxt[15:0] != 16'd0)\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            control_state_nxt = MTRANS_EXEC3;\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        control_state_nxt = MTRANS_EXEC3;\n\n    if ( control_state == MTRANS_EXEC3 )     control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC3B )    control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC4  )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS5_ABORT;\n        else if (write_pc) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( mem_op )  \n             control_state_nxt = MEM_WAIT1;\n        if ( write_pc )\n             control_state_nxt = PC_STALL1;\n        if ( itype == MTRANS )\n            begin\n            if ( mtrans_num_registers != 5'd0 )\n                begin\n                \n                if ( mtrans_num_registers == 5'd1 )\n                    control_state_nxt = MTRANS_EXEC3B;\n                else\n                    control_state_nxt = MTRANS_EXEC1;\n                end\n            else\n                control_state_nxt = MTRANS_EXEC3;\n            end\n\n        if ( itype == MULT )\n                control_state_nxt = MULT_PROC1;\n\n        if ( itype == SWAP )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( itype == CORTRANS && !und_request )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt )\n                control_state_nxt = INT_WAIT1;\n        end\n    end\n\n\n\n\n\nalways @ ( posedge i_clk )\n    if (!i_fetch_stall)\n        begin\n        o_read_data                 <= i_read_data;\n        o_read_data_alignment       <= {i_execute_address[1:0], 3'd0};\n        abt_address_reg             <= i_execute_address;\n        iabt_reg                    <= i_iabt;\n        adex_reg                    <= i_adex;\n        abt_status_reg              <= i_abt_status;\n        status_bits_mode_r          <= status_bits_mode_nxt;\n        status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n        status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n        o_imm32                     <= imm32_nxt;\n        o_imm_shift_amount          <= imm_shift_amount_nxt;\n        o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n                                        \n                                        \n                                        \n                                        \n                                        \n        condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n        o_exclusive_exec            <= exclusive_exec_nxt;\n        o_data_access_exec          <= data_access_exec_nxt;\n\n        o_rm_sel                    <= o_rm_sel_nxt;\n        o_rds_sel                   <= o_rds_sel_nxt;\n        o_rn_sel                    <= o_rn_sel_nxt;\n        o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n        o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n        o_barrel_shift_function     <= barrel_shift_function_nxt;\n        o_alu_function              <= alu_function_nxt;\n        o_use_carry_in              <= use_carry_in_nxt;\n        o_multiply_function         <= multiply_function_nxt;\n        o_interrupt_vector_sel      <= next_interrupt;\n        address_sel_r               <= address_sel_nxt;\n        pc_sel_r                    <= pc_sel_nxt;\n        o_byte_enable_sel           <= byte_enable_sel_nxt;\n        o_status_bits_sel           <= status_bits_sel_nxt;\n        o_reg_write_sel             <= reg_write_sel_nxt;\n        o_user_mode_regs_load       <= user_mode_regs_load_nxt;\n        o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n        o_write_data_wen            <= write_data_wen_nxt;\n        o_base_address_wen          <= base_address_wen_nxt;\n        pc_wen_r                    <= pc_wen_nxt;\n        o_reg_bank_wsel             <= reg_bank_wsel_nxt;\n        o_reg_bank_wen              <= decode ( reg_bank_wsel_nxt );\n        o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n        o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n        o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n        o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n        o_copro_opcode1             <= instruction[23:21];\n        o_copro_opcode2             <= instruction[7:5];\n        o_copro_crn                 <= instruction[19:16];\n        o_copro_crm                 <= instruction[3:0];\n        o_copro_num                 <= instruction[11:8];\n        o_copro_operation           <= copro_operation_nxt;\n        o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n        mtrans_r15                  <= mtrans_r15_nxt;\n        restore_base_address        <= restore_base_address_nxt;\n        control_state               <= control_state_nxt;\n        mtrans_reg_d1               <= mtrans_reg;\n        mtrans_reg_d2               <= mtrans_reg_d1;\n        end\n\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        \n        \n        \n        \n        \n        if      (itype == MTRANS)\n            begin\n            saved_current_instruction              <= mtrans_instruction_nxt;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n        else if (saved_current_instruction_wen)\n            begin\n            saved_current_instruction              <= instruction;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n\n        if      (pre_fetch_instruction_wen)\n            begin\n            pre_fetch_instruction                  <= o_read_data;\n            pre_fetch_instruction_iabt             <= iabt_reg;\n            pre_fetch_instruction_adex             <= adex_reg;\n            pre_fetch_instruction_address          <= abt_address_reg;\n            pre_fetch_instruction_iabt_status      <= abt_status_reg;\n            end\n        end\n\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        irq   <= i_irq;\n        firq  <= i_firq;\n\n        if ( control_state == INT_WAIT1 && status_bits_mode_r == SVC )\n            begin\n            dabt_reg  <= 1'd0;\n            end\n        else\n            begin\n            dabt_reg  <= dabt_reg || i_dabt;\n            end\n\n        dabt_reg_d1  <= dabt_reg;\n        end\n\nassign dabt = dabt_reg || i_dabt;\n\n\n\n\n\n\n\n`include \"debug_functions.vh\"\n\na23_decompile  u_decompile (\n    .i_clk                      ( i_clk                            ),\n    .i_fetch_stall              ( i_fetch_stall                    ),\n    .i_instruction              ( instruction                      ),\n    .i_instruction_valid        ( instruction_valid                ),\n    .i_instruction_execute      ( instruction_execute              ),\n    .i_instruction_address      ( instruction_address              ),\n    .i_interrupt                ( {3{interrupt}} & next_interrupt  ),\n    .i_interrupt_state          ( control_state == INT_WAIT2       ),\n    .i_instruction_undefined    ( und_request                      ),\n    .i_pc_sel                   ( pc_sel_r                         ),\n    .i_pc_wen                   ( pc_wen_r                         ));\n\n\n\nwire    [(15*8)-1:0]    xCONTROL_STATE;\nwire    [(15*8)-1:0]    xMODE;\n\nassign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_EXEC3   ? \"MTRANS_EXEC3\"   :\n                               control_state == MTRANS_EXEC3B  ? \"MTRANS_EXEC3B\"  :\n                               control_state == MTRANS_EXEC4   ? \"MTRANS_EXEC4\"   :\n                               control_state == MTRANS5_ABORT  ? \"MTRANS5_ABORT\"  :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;\n\nassign xMODE  = mode_name ( status_bits_mode_r );\n\nalways @( posedge i_clk )\n    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n        begin\n        `TB_ERROR_MESSAGE\n        $display(\"Instruction with x's =%08h\", instruction);\n        end\n\n\nendmodule\n\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: a23_decode. Module specification: The a23_decode module is responsible for decoding ARM instructions in an ARM processor. It takes inputs such as clock (i_clk), read data (i_read_data), fetch stall signals (i_fetch_stall), interrupt requests (i_irq, i_firq), abort signals (i_dabt, i_iabt, i_adex), execute address (i_execute_address), abort status (i_abt_status), execute status bits (i_execute_status_bits), and multiply done signal (i_multiply_done). The module generates numerous output signals including decoded instruction information, register selection signals, ALU and barrel shifter control signals, memory access control signals, status bits and mode control signals, coprocessor operation signals, and abort handling signals. Internally, it uses various signals to manage instruction decoding, execution control, and state"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: a23_decode\n\nExplanation: This module is responsible for decoding ARM instructions in an ARM processor. It takes various inputs such as clock, read data, fetch stall signals, interrupt requests, and status bits. The module decodes the instruction, determines the operation to be performed, and generates control signals for other parts of the processor. It handles different instruction types including data processing, memory operations, branch instructions, and coprocessor operations. The module also manages the processor's state machine, which controls the execution flow of instructions and handles interrupts. Overall, it plays a crucial role in instruction decoding and execution control within the ARM processor."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: i_clk, i_read_data, i_fetch_stall, i_irq, i_firq, i_dabt, i_iabt, i_adex, i_execute_address, i_abt_status, i_execute_status_bits, i_multiply_done.\n\nExplanation:\n- i_clk: Clock input\n- i_read_data: Data read from memory\n- i_fetch_stall: Signal to stall instruction fetch\n- i_irq, i_firq: Interrupt request signals\n- i_dabt, i_iabt: Data and instruction abort signals\n- i_adex: Address exception signal\n- i_execute_address: Address of executing instruction\n- i_abt_status: Abort status\n- i_execute_status_bits: Status bits of executing instruction\n- i_multiply_done: Signal indicating multiplication completion\n\nOutput ports: o_read_data, o_read_data_alignment, o_imm32, o_imm_shift_amount, o_shift_imm_zero, o_condition, o_exclusive_exec, o_data_access_exec, o_status_bits_mode, o_status_bits_irq_mask, o_status_bits_firq_mask, o_rm_sel, o_rds_sel, o_rn_sel, o_rm_sel_nxt, o_rds_sel_nxt, o_rn_sel_nxt, o_barrel_shift_amount_sel, o_barrel_shift_data_sel, o_barrel_shift_function, o_alu_function, o_use_carry_in, o_multiply_function, o_interrupt_vector_sel, o_address_sel, o_pc_sel, o_byte_enable_sel, o_status_bits_sel, o_reg_write_sel, o_user_mode_regs_load, o_user_mode_regs_store_nxt, o_firq_not_user_mode, o_write_data_wen, o_base_address_wen, o_pc_wen, o_reg_bank_wen, o_reg_bank_wsel, o_status_bits_flags_wen, o_status_bits_mode_wen, o_status_bits_irq_mask_wen, o_status_bits_firq_mask_wen, o_copro_opcode1, o_copro_opcode2, o_copro_crn, o_copro_crm, o_copro_num, o_copro_operation, o_copro_write_data_wen, o_iabt_trigger, o_iabt_address, o_iabt_status, o_dabt_trigger, o_dabt_address, o_dabt_status.\n\nExplanation:\nThese output ports provide control signals, data, and status information for various components of the processor, including:\n- Decoded instruction information (e.g., o_imm32, o_condition)\n- Register selection signals (e.g., o_rm_sel, o_rds_sel, o_rn_sel)\n- ALU and barrel shifter control signals (e.g., o_alu_function, o_barrel_shift_function)\n- Memory access control signals (e.g., o_byte_enable_sel, o_write_data_wen)\n- Status bits and mode control signals (e.g., o_status_bits_mode, o_status_bits_flags_wen)\n- Coprocessor operation signals (e.g., o_copro_opcode1, o_copro_operation)\n- Abort and exception handling signals (e.g., o_iabt_trigger, o_dabt_address)\n\nThese outputs are used to control the execution of instructions and manage the processor's state."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\ninstruction, instruction_iabt, instruction_adex, instruction_address, instruction_iabt_status, instruction_sel, itype, opcode, imm8, offset12, offset24, shift_imm, opcode_compare, mem_op, load_op, store_op, write_pc, immediate_shifter_operand, rds_use_rs, branch, mem_op_pre_indexed, mem_op_post_indexed, imm32_nxt, imm_shift_amount_nxt, shift_imm_zero_nxt, condition_nxt, exclusive_exec_nxt, data_access_exec_nxt, shift_extend, barrel_shift_function_nxt, alu_function_nxt, use_carry_in_nxt, multiply_function_nxt, status_bits_mode_nxt, status_bits_irq_mask_nxt, status_bits_firq_mask_nxt, barrel_shift_amount_sel_nxt, barrel_shift_data_sel_nxt, address_sel_nxt, pc_sel_nxt, byte_enable_sel_nxt, status_bits_sel_nxt, reg_write_sel_nxt, user_mode_regs_load_nxt, firq_not_user_mode_nxt, alu_swap_sel_nxt, alu_not_sel_nxt, alu_cin_sel_nxt, alu_cout_sel_nxt, alu_out_sel_nxt, write_data_wen_nxt, copro_write_data_wen_nxt, base_address_wen_nxt, pc_wen_nxt, reg_bank_wsel_nxt, status_bits_flags_wen_nxt, status_bits_mode_wen_nxt, status_bits_irq_mask_wen_nxt, status_bits_firq_mask_wen_nxt, saved_current_instruction_wen, pre_fetch_instruction_wen, control_state, control_state_nxt, dabt, dabt_reg, dabt_reg_d1, iabt_reg, adex_reg, abt_address_reg, abt_status_reg, saved_current_instruction, saved_current_instruction_iabt, saved_current_instruction_adex, saved_current_instruction_address, saved_current_instruction_iabt_status, pre_fetch_instruction, pre_fetch_instruction_iabt, pre_fetch_instruction_adex, pre_fetch_instruction_address, pre_fetch_instruction_iabt_status, instruction_valid, instruction_execute, mtrans_reg, mtrans_reg_d1, mtrans_reg_d2, mtrans_instruction_nxt, mtrans_base_reg_change, mtrans_num_registers, use_saved_current_instruction, use_pre_fetch_instruction, interrupt, interrupt_mode, next_interrupt, irq, firq, firq_request, irq_request, swi_request, und_request, dabt_request, copro_operation_nxt, mtrans_r15, mtrans_r15_nxt, restore_base_address, restore_base_address_nxt, regop_set_flags.\n\nExplanation:\nThese internal signals serve various purposes in the module:\n- instruction-related signals (e.g., instruction, instruction_iabt) hold and manage instruction data and associated information.\n- Control signals (e.g., mem_op, load_op, write_pc) indicate specific operations or conditions.\n- Next-cycle value signals (e.g., imm32_nxt, barrel_shift_function_nxt) store values for the next clock cycle.\n- State-related signals (e.g., control_state, control_state_nxt) manage the module's state machine.\n- Interrupt and exception-related signals (e.g., irq, firq, dabt) handle various interrupt and exception conditions.\n- Instruction type and operation signals (e.g., itype, opcode) classify and identify instruction types and operations.\n- Register and data manipulation signals (e.g., reg_bank_wsel_nxt, alu_out_sel_nxt) control register selection and ALU operations.\n- Memory access signals (e.g., mem_op_pre_indexed, byte_enable_sel_nxt) manage memory operations.\n- Status and mode signals (e.g., status_bits_mode_nxt, firq_not_user_mode_nxt) handle processor status and operating modes.\n\nThese signals work together to decode instructions, control execution flow, manage interrupts and exceptions, and generate control signals for other parts of the processor."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"global_defines.vh\"\n\nmodule a23_decode\n(\ninput                       i_clk,\ninput       [31:0]          i_read_data,\ninput                       i_fetch_stall,                  \ninput                       i_irq,                          \ninput                       i_firq,                         \ninput                       i_dabt,                         \ninput                       i_iabt,                         \ninput                       i_adex,                         \ninput       [31:0]          i_execute_address,              \n                                                            \n                                                            \ninput       [7:0]           i_abt_status,                   \ninput       [31:0]          i_execute_status_bits,          \ninput                       i_multiply_done,                \n\n\n\n\n\noutput reg  [31:0]          o_read_data = 1'd0,\noutput reg  [4:0]           o_read_data_alignment = 1'd0,  \n\noutput reg  [31:0]          o_imm32 = 'd0,\noutput reg  [4:0]           o_imm_shift_amount = 'd0,\noutput reg                  o_shift_imm_zero = 'd0,\noutput wire [3:0]           o_condition,\noutput reg                  o_exclusive_exec = 'd0,         \noutput reg                  o_data_access_exec = 'd0,       \n                                                            \noutput wire [1:0]           o_status_bits_mode,\noutput wire                 o_status_bits_irq_mask,\noutput wire                 o_status_bits_firq_mask,\n\noutput reg  [3:0]           o_rm_sel = 'd0,\noutput reg  [3:0]           o_rds_sel = 'd0,\noutput reg  [3:0]           o_rn_sel = 'd0,\noutput      [3:0]           o_rm_sel_nxt,\noutput      [3:0]           o_rds_sel_nxt,\noutput      [3:0]           o_rn_sel_nxt,\noutput reg  [1:0]           o_barrel_shift_amount_sel = 'd0,\noutput reg  [1:0]           o_barrel_shift_data_sel = 'd0,\noutput reg  [1:0]           o_barrel_shift_function = 'd0,\noutput reg  [8:0]           o_alu_function = 'd0,\noutput reg                  o_use_carry_in = 'd0,\noutput reg  [1:0]           o_multiply_function = 'd0,\noutput reg  [2:0]           o_interrupt_vector_sel = 'd0,\noutput wire [3:0]           o_address_sel,\noutput wire [1:0]           o_pc_sel,\noutput reg  [1:0]           o_byte_enable_sel = 'd0,        \noutput reg  [2:0]           o_status_bits_sel = 'd0,\noutput reg  [2:0]           o_reg_write_sel,\noutput reg                  o_user_mode_regs_load,\noutput reg                  o_user_mode_regs_store_nxt,\noutput reg                  o_firq_not_user_mode,\n\noutput reg                  o_write_data_wen = 'd0,\noutput reg                  o_base_address_wen = 'd0,       \n                                                            \noutput wire                 o_pc_wen,\noutput reg  [14:0]          o_reg_bank_wen = 'd0,\noutput reg  [3:0]           o_reg_bank_wsel = 'd0,\noutput reg                  o_status_bits_flags_wen = 'd0,\noutput reg                  o_status_bits_mode_wen = 'd0,\noutput reg                  o_status_bits_irq_mask_wen = 'd0,\noutput reg                  o_status_bits_firq_mask_wen = 'd0,\n\n\n\n\noutput reg  [2:0]           o_copro_opcode1 = 'd0,\noutput reg  [2:0]           o_copro_opcode2 = 'd0,\noutput reg  [3:0]           o_copro_crn = 'd0,\noutput reg  [3:0]           o_copro_crm = 'd0,\noutput reg  [3:0]           o_copro_num = 'd0,\noutput reg  [1:0]           o_copro_operation = 'd0, \n                                                     \n                                                     \noutput reg                  o_copro_write_data_wen = 'd0,\noutput                      o_iabt_trigger,\noutput      [31:0]          o_iabt_address,\noutput      [7:0]           o_iabt_status,\noutput                      o_dabt_trigger,\noutput      [31:0]          o_dabt_address,\noutput      [7:0]           o_dabt_status\n\n\n);\n\n`include \"a23_localparams.vh\"\n`include \"a23_functions.vh\"\n\nlocalparam [4:0] RST_WAIT1      = 5'd0,\n                 RST_WAIT2      = 5'd1,\n                 INT_WAIT1      = 5'd2,\n                 INT_WAIT2      = 5'd3,\n                 EXECUTE        = 5'd4,\n                 PRE_FETCH_EXEC = 5'd5,  \n                 MEM_WAIT1      = 5'd6,  \n                                         \n                 MEM_WAIT2      = 5'd7,\n                 PC_STALL1      = 5'd8,  \n                                         \n                                         \n                 PC_STALL2      = 5'd9,\n                 MTRANS_EXEC1   = 5'd10,\n                 MTRANS_EXEC2   = 5'd11,\n                 MTRANS_EXEC3   = 5'd12,\n                 MTRANS_EXEC3B  = 5'd13,\n                 MTRANS_EXEC4   = 5'd14,\n                 MTRANS5_ABORT  = 5'd15,\n                 MULT_PROC1     = 5'd16,  \n                 MULT_PROC2     = 5'd17,  \n                 MULT_STORE     = 5'd19,  \n                 MULT_ACCUMU    = 5'd20,  \n                 SWAP_WRITE     = 5'd22,\n                 SWAP_WAIT1     = 5'd23,\n                 SWAP_WAIT2     = 5'd24,\n                 COPRO_WAIT     = 5'd25;\n\n\n\n\n\nwire    [31:0]         instruction;\nwire                   instruction_iabt;        \nwire                   instruction_adex;        \nwire    [31:0]         instruction_address;     \n                                                \nwire    [7:0]          instruction_iabt_status; \nwire    [1:0]          instruction_sel;\nreg     [3:0]          itype;\nwire    [3:0]          opcode;\nwire    [7:0]          imm8;\nwire    [31:0]         offset12;\nwire    [31:0]         offset24;\nwire    [4:0]          shift_imm;\n\nwire                   opcode_compare;\nwire                   mem_op;\nwire                   load_op;\nwire                   store_op;\nwire                   write_pc;\nwire                   immediate_shifter_operand;\nwire                   rds_use_rs;\nwire                   branch;\nwire                   mem_op_pre_indexed;\nwire                   mem_op_post_indexed;\n\n\nwire    [31:0]         imm32_nxt;\nwire    [4:0]          imm_shift_amount_nxt;\nwire                   shift_imm_zero_nxt;\nwire    [3:0]          condition_nxt;\nreg                    exclusive_exec_nxt;\nreg                    data_access_exec_nxt;\nwire                   shift_extend;\n\nreg     [1:0]          barrel_shift_function_nxt;\nwire    [8:0]          alu_function_nxt;\nreg                    use_carry_in_nxt;\nreg     [1:0]          multiply_function_nxt;\nreg     [1:0]          status_bits_mode_nxt;\nreg                    status_bits_irq_mask_nxt;\nreg                    status_bits_firq_mask_nxt;\n\nreg     [1:0]          barrel_shift_amount_sel_nxt;\nreg     [1:0]          barrel_shift_data_sel_nxt;\nreg     [3:0]          address_sel_nxt;\nreg     [1:0]          pc_sel_nxt;\nreg     [1:0]          byte_enable_sel_nxt;\nreg     [2:0]          status_bits_sel_nxt;\nreg     [2:0]          reg_write_sel_nxt;\nreg                    user_mode_regs_load_nxt;\nwire                   firq_not_user_mode_nxt;\n\n\nreg                    alu_swap_sel_nxt;\nreg                    alu_not_sel_nxt;\nreg     [1:0]          alu_cin_sel_nxt;\nreg                    alu_cout_sel_nxt;\nreg     [3:0]          alu_out_sel_nxt;\n\nreg                    write_data_wen_nxt;\nreg                    copro_write_data_wen_nxt;\nreg                    base_address_wen_nxt;\nreg                    pc_wen_nxt;\nreg     [3:0]          reg_bank_wsel_nxt;\nreg                    status_bits_flags_wen_nxt;\nreg                    status_bits_mode_wen_nxt;\nreg                    status_bits_irq_mask_wen_nxt;\nreg                    status_bits_firq_mask_wen_nxt;\n\nreg                    saved_current_instruction_wen;   \nreg                    pre_fetch_instruction_wen;       \n\nreg     [4:0]          control_state = RST_WAIT1;\nreg     [4:0]          control_state_nxt;\n\n\nwire                   dabt;\nreg                    dabt_reg = 'd0;\nreg                    dabt_reg_d1;\nreg                    iabt_reg = 'd0;\nreg                    adex_reg = 'd0;\nreg     [31:0]         abt_address_reg = 'd0;\nreg     [7:0]          abt_status_reg = 'd0;\nreg     [31:0]         saved_current_instruction = 'd0;\nreg                    saved_current_instruction_iabt = 'd0;          \nreg                    saved_current_instruction_adex = 'd0;          \nreg     [31:0]         saved_current_instruction_address = 'd0;       \nreg     [7:0]          saved_current_instruction_iabt_status = 'd0;   \nreg     [31:0]         pre_fetch_instruction = 'd0;\nreg                    pre_fetch_instruction_iabt = 'd0;              \nreg                    pre_fetch_instruction_adex = 'd0;              \nreg     [31:0]         pre_fetch_instruction_address = 'd0;           \nreg     [7:0]          pre_fetch_instruction_iabt_status = 'd0;       \n\nwire                   instruction_valid;\nwire                   instruction_execute;\n\nreg     [3:0]          mtrans_reg;              \nreg     [3:0]          mtrans_reg_d1 = 'd0;     \nreg     [3:0]          mtrans_reg_d2 = 'd0;     \nreg     [31:0]         mtrans_instruction_nxt;\n\nwire   [31:0]          mtrans_base_reg_change;\nwire   [4:0]           mtrans_num_registers;\nwire                   use_saved_current_instruction;\nwire                   use_pre_fetch_instruction;\nwire                   interrupt;\nwire   [1:0]           interrupt_mode;\nwire   [2:0]           next_interrupt;\nreg                    irq = 'd0;\nreg                    firq = 'd0;\nwire                   firq_request;\nwire                   irq_request;\nwire                   swi_request;\nwire                   und_request;\nwire                   dabt_request;\nreg    [1:0]           copro_operation_nxt;\nreg                    mtrans_r15 = 'd0;\nreg                    mtrans_r15_nxt;\nreg                    restore_base_address = 'd0;\nreg                    restore_base_address_nxt;\n\nwire                   regop_set_flags;\n\n\n\n\n\nreg  [3:0]           condition_r = 4'he;             \nreg  [1:0]           status_bits_mode_r = 2'b11;     \nreg                  status_bits_irq_mask_r = 1'd1;\nreg                  status_bits_firq_mask_r = 1'd1;\nreg  [3:0]           address_sel_r = 4'd2;\nreg  [1:0]           pc_sel_r = 2'd2;\nreg                  pc_wen_r = 1'd1;\n\nassign o_condition              = condition_r;\nassign o_status_bits_mode       = status_bits_mode_r;\nassign o_status_bits_irq_mask   = status_bits_irq_mask_r;\nassign o_status_bits_firq_mask  = status_bits_firq_mask_r;\nassign o_address_sel            = address_sel_r;\nassign o_pc_sel                 = pc_sel_r;\nassign o_pc_wen                 = pc_wen_r;\n\n\n\n\n\n\n\nassign o_iabt_trigger     = instruction_iabt && status_bits_mode_r == SVC && control_state == INT_WAIT1;\nassign o_iabt_address     = instruction_address;\nassign o_iabt_status      = instruction_iabt_status;\n\nassign o_dabt_trigger     = dabt_reg && !dabt_reg_d1;\nassign o_dabt_address     = abt_address_reg;\nassign o_dabt_status      = abt_status_reg;\n\n\n\n\n\n\n\n\n\n\n\n\n\nassign use_saved_current_instruction =  instruction_execute &&\n                          ( control_state == MEM_WAIT1     ||\n                            control_state == MEM_WAIT2     ||\n                            control_state == MTRANS_EXEC1  ||\n                            control_state == MTRANS_EXEC2  ||\n                            control_state == MTRANS_EXEC3  ||\n                            control_state == MTRANS_EXEC3B ||\n                            control_state == MTRANS_EXEC4  ||\n                            control_state == MTRANS5_ABORT ||\n                            control_state == MULT_PROC1    ||\n                            control_state == MULT_PROC2    ||\n                            control_state == MULT_ACCUMU   ||\n                            control_state == MULT_STORE    ||\n                            control_state == INT_WAIT1     ||\n                            control_state == INT_WAIT2     ||\n                            control_state == SWAP_WRITE    ||\n                            control_state == SWAP_WAIT1    ||\n                            control_state == SWAP_WAIT2    ||\n                            control_state == COPRO_WAIT     );\n\nassign use_pre_fetch_instruction = control_state == PRE_FETCH_EXEC;\n\n\nassign instruction_sel  =         use_saved_current_instruction  ? 2'd1 :  \n                                  use_pre_fetch_instruction      ? 2'd2 :  \n                                                                   2'd0 ;  \n\nassign instruction      =         instruction_sel == 2'd0 ? o_read_data               :\n                                  instruction_sel == 2'd1 ? saved_current_instruction :\n                                                            pre_fetch_instruction     ;\n\n\nassign instruction_iabt =         instruction_sel == 2'd0 ? iabt_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt :\n                                                            pre_fetch_instruction_iabt     ;\n\nassign instruction_address =      instruction_sel == 2'd0 ? abt_address_reg                   :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_address :\n                                                            pre_fetch_instruction_address     ;\n\nassign instruction_iabt_status =  instruction_sel == 2'd0 ? abt_status_reg                        :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt_status :\n                                                            pre_fetch_instruction_iabt_status     ;\n\n\nassign instruction_adex =         instruction_sel == 2'd0 ? adex_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_adex :\n                                                            pre_fetch_instruction_adex     ;\n\n\nalways @*\n    casez ({instruction[27:20], instruction[7:4]})\n        12'b00010?001001 : itype = SWAP;\n        12'b000000??1001 : itype = MULT;\n        12'b00?????????? : itype = REGOP;\n        12'b01?????????? : itype = TRANS;\n        12'b100????????? : itype = MTRANS;\n        12'b101????????? : itype = BRANCH;\n        12'b110????????? : itype = CODTRANS;\n        12'b1110???????0 : itype = COREGOP;\n        12'b1110???????1 : itype = CORTRANS;\n        default:           itype = SWI;\n    endcase\n\n\n\n\n\n\nassign opcode        = instruction[24:21];\nassign condition_nxt = instruction[31:28];\n\nassign o_rm_sel_nxt    = instruction[3:0];\n\nassign o_rn_sel_nxt    = branch  ? 4'd15              : \n                                   instruction[19:16] ;\n\nassign o_rds_sel_nxt   = control_state == SWAP_WRITE  ? instruction[3:0]   : \n                         itype == MTRANS              ? mtrans_reg         :\n                         branch                       ? 4'd15              : \n                         rds_use_rs                   ? instruction[11:8]  :\n                                                        instruction[15:12] ;\n\n\nassign shift_imm     = instruction[11:7];\n\n\nassign shift_extend  = !instruction[25] && !instruction[4] && !(|instruction[11:7]) && instruction[6:5] == 2'b11;\n\nassign offset12      = { 20'h0, instruction[11:0]};\nassign offset24      = {{6{instruction[23]}}, instruction[23:0], 2'd0 }; \nassign imm8          = instruction[7:0];\n\nassign immediate_shifter_operand = instruction[25];\nassign rds_use_rs                = (itype == REGOP && !instruction[25] && instruction[4]) ||\n                                   (itype == MULT &&\n                                    (control_state == MULT_PROC1  ||\n                                     control_state == MULT_PROC2  ||\n                                     instruction_valid && !interrupt )) ;\nassign branch                    = itype == BRANCH;\nassign opcode_compare =\n            opcode == CMP ||\n            opcode == CMN ||\n            opcode == TEQ ||\n            opcode == TST ;\n\n\nassign mem_op               = itype == TRANS;\nassign load_op              = mem_op && instruction[20];\nassign store_op             = mem_op && !instruction[20];\nassign write_pc             = pc_wen_nxt && pc_sel_nxt != 2'd0;\nassign regop_set_flags      = itype == REGOP && instruction[20];\n\nassign mem_op_pre_indexed   =  instruction[24] && instruction[21];\nassign mem_op_post_indexed  = !instruction[24];\n\nassign imm32_nxt            =  \n                               itype == MULT               ? {  32'd0                      } :\n\n                               \n                               itype == MTRANS             ? {  mtrans_base_reg_change     } :\n                               itype == BRANCH             ? {  offset24                   } :\n                               itype == TRANS              ? {  offset12                   } :\n                               instruction[11:8] == 4'h0  ? {            24'h0, imm8[7:0] } :\n                               instruction[11:8] == 4'h1  ? { imm8[1:0], 24'h0, imm8[7:2] } :\n                               instruction[11:8] == 4'h2  ? { imm8[3:0], 24'h0, imm8[7:4] } :\n                               instruction[11:8] == 4'h3  ? { imm8[5:0], 24'h0, imm8[7:6] } :\n                               instruction[11:8] == 4'h4  ? { imm8[7:0], 24'h0            } :\n                               instruction[11:8] == 4'h5  ? { 2'h0,  imm8[7:0], 22'h0     } :\n                               instruction[11:8] == 4'h6  ? { 4'h0,  imm8[7:0], 20'h0     } :\n                               instruction[11:8] == 4'h7  ? { 6'h0,  imm8[7:0], 18'h0     } :\n                               instruction[11:8] == 4'h8  ? { 8'h0,  imm8[7:0], 16'h0     } :\n                               instruction[11:8] == 4'h9  ? { 10'h0, imm8[7:0], 14'h0     } :\n                               instruction[11:8] == 4'ha  ? { 12'h0, imm8[7:0], 12'h0     } :\n                               instruction[11:8] == 4'hb  ? { 14'h0, imm8[7:0], 10'h0     } :\n                               instruction[11:8] == 4'hc  ? { 16'h0, imm8[7:0], 8'h0      } :\n                               instruction[11:8] == 4'hd  ? { 18'h0, imm8[7:0], 6'h0      } :\n                               instruction[11:8] == 4'he  ? { 20'h0, imm8[7:0], 4'h0      } :\n                                                            { 22'h0, imm8[7:0], 2'h0      } ;\n\n\nassign imm_shift_amount_nxt = shift_imm ;\n\n       \n       \nassign shift_imm_zero_nxt   = imm_shift_amount_nxt == 5'd0 &&       \n                              barrel_shift_amount_sel_nxt == 2'd2;  \n\nassign alu_function_nxt     = { alu_swap_sel_nxt,\n                                alu_not_sel_nxt,\n                                alu_cin_sel_nxt,\n                                alu_cout_sel_nxt,\n                                alu_out_sel_nxt  };\n\n\n\n\n\n\n   \n   \n   \nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_reg = 4'h0 ;\n    16'b??????????????10 : mtrans_reg = 4'h1 ;\n    16'b?????????????100 : mtrans_reg = 4'h2 ;\n    16'b????????????1000 : mtrans_reg = 4'h3 ;\n    16'b???????????10000 : mtrans_reg = 4'h4 ;\n    16'b??????????100000 : mtrans_reg = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg = 4'h6 ;\n    16'b????????10000000 : mtrans_reg = 4'h7 ;\n    16'b???????100000000 : mtrans_reg = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg = 4'ha ;\n    16'b????100000000000 : mtrans_reg = 4'hb ;\n    16'b???1000000000000 : mtrans_reg = 4'hc ;\n    16'b??10000000000000 : mtrans_reg = 4'hd ;\n    16'b?100000000000000 : mtrans_reg = 4'he ;\n    default              : mtrans_reg = 4'hf ;\n    endcase\n\n\nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase\n\n\n\nassign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;\n\n\nassign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};\n\n\n\n\n\nassign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = itype == SWI;\nassign dabt_request = dabt_reg;\n\n\n\n\nassign und_request  =   itype == CODTRANS ||\n                        itype == COREGOP  ||\n                      ( itype == CORTRANS && instruction[11:8] != 4'd15 );\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \nassign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  \n\n        \n        \n        \nassign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 ;   \n\n\nassign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;\n\n\n\n\n\n\n\nalways @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    exclusive_exec_nxt              = 1'd0;\n    data_access_exec_nxt            = 1'd0;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    mtrans_r15_nxt                  = mtrans_r15;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    address_sel_nxt                 = 'd0;\n    pc_sel_nxt                      = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    user_mode_regs_load_nxt         = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wsel_nxt               = 'hF;  \n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt )\n        begin\n        if ( itype == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt      = 2'd1; \n                    address_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wsel_nxt = instruction[15:12];\n                end\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_function_nxt  = instruction[6:5];\n\n            if ( !immediate_shifter_operand )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shifter_operand && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shifter_operand && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt  = 4'd6; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n            end\n\n        \n        if ( mem_op )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( itype == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( o_rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 2'd1;\n                else\n                    reg_bank_wsel_nxt = o_rn_sel_nxt;\n                end\n\n                \n            if ( mem_op_post_indexed )\n               address_sel_nxt = 4'd4; \n            else\n               address_sel_nxt = 4'd1; \n\n            if ( instruction[25] && itype ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( itype == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n        if ( itype == BRANCH )\n            begin\n            pc_sel_nxt      = 2'd1; \n            address_sel_nxt = 4'd1; \n            alu_out_sel_nxt = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wsel_nxt  = 4'd14;  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n        if ( itype == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            alu_out_sel_nxt                 = 4'd1; \n            mtrans_r15_nxt                  = instruction[15];  \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] ) \n                begin\n                if ( instruction[24] )    \n                    address_sel_nxt = 4'd7; \n                else\n                    address_sel_nxt = 4'd4; \n                end\n            else \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    address_sel_nxt  = 4'd6; \n                else\n                    address_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            \n            \n            if ( {instruction[22:20],instruction[15]} == 4'b1010 )\n                user_mode_regs_load_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20]} == 3'b100 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wsel_nxt  = o_rn_sel_nxt;\n            end\n\n\n        if ( itype == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( itype == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            data_access_exec_nxt            = 1'd1; \n                                                    \n            barrel_shift_data_sel_nxt       = 2'd2; \n            address_sel_nxt                 = 4'd4; \n            exclusive_exec_nxt              = 1'd1; \n            end\n\n\n        \n        if ( itype == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            address_sel_nxt                 = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( itype == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wsel_nxt               = 4'd14;  \n\n            address_sel_nxt                 = 4'd2;            \n            pc_sel_nxt                      = 2'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end\n\n    \n    \n    \n    \n    \n    \n    if ( instruction_valid && interrupt &&  next_interrupt != 3'd6 )\n        begin\n        \n        \n        \n        saved_current_instruction_wen   = 1'd1;\n\n        \n        \n        if ( next_interrupt == 3'd4 )\n            reg_write_sel_nxt               = 3'd7;            \n        else\n            reg_write_sel_nxt               = 3'd1;            \n\n        reg_bank_wsel_nxt               = 4'd14;           \n\n        address_sel_nxt                 = 4'd2;            \n        pc_sel_nxt                      = 2'd2;            \n\n        status_bits_mode_nxt            = interrupt_mode;  \n        status_bits_mode_wen_nxt        = 1'd1;\n\n        \n        status_bits_irq_mask_nxt        = 1'd1;\n        status_bits_irq_mask_wen_nxt    = 1'd1;\n\n        \n        if ( next_interrupt == 3'd2 ) \n            begin\n            status_bits_firq_mask_nxt        = 1'd1;\n            status_bits_firq_mask_wen_nxt    = 1'd1;\n            end\n        end\n\n\n    \n    \n    if ( control_state == MEM_WAIT1 )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n        end\n\n\n    \n    if ( control_state == MEM_WAIT2 && load_op )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n        barrel_shift_amount_sel_nxt = 2'd3;  \n\n        \n        if ( i_execute_address[1:0] != 2'd0 )\n            barrel_shift_function_nxt = ROR;\n\n        \n        if ( itype == TRANS && instruction[22] )\n            alu_out_sel_nxt             = 4'd3;  \n\n        if ( !dabt )  \n            begin\n            \n            if (instruction[15:12]  == 4'd15)\n                begin\n                pc_sel_nxt      = 2'd1; \n                address_sel_nxt = 4'd1; \n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd5;  \n            pc_wen_nxt                  = 1'd0;  \n            data_access_exec_nxt        = 1'd1;  \n                                                 \n\n            if ( !instruction[20] ) \n                write_data_wen_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20],mtrans_r15} == 4'b1010 )\n                user_mode_regs_load_nxt = 1'd1;\n\n            \n            \n            if ( {instruction[22:20]} == 3'b100 )\n                o_user_mode_regs_store_nxt = 1'd1;\n            end\n        end\n\n\n        \n    if ( control_state == MTRANS_EXEC2 )\n        begin\n        address_sel_nxt             = 4'd5;  \n        pc_wen_nxt                  = 1'd0;  \n        data_access_exec_nxt        = 1'd1;  \n                                             \n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        \n        if ( instruction[20] ) \n            begin\n            \n            \n            if ( !dabt )\n                reg_bank_wsel_nxt = mtrans_reg_d2;\n            end\n        else \n            write_data_wen_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n\n        \n    if ( control_state == MTRANS_EXEC3 && instruction_execute )\n        begin\n        address_sel_nxt             = 4'd3; \n        pc_wen_nxt                  = 1'd0;  \n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        \n        \n        if ( instruction[20] && !dabt ) \n            reg_bank_wsel_nxt = mtrans_reg_d2;\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n       end\n\n    \n    if ( control_state == MTRANS_EXEC3B && instruction_execute )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        address_sel_nxt             = 4'd3;  \n        pc_wen_nxt                  = 1'd0;  \n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n    if ( control_state == MTRANS_EXEC4 )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n\n        if ( instruction[20] ) \n            begin\n            if (!dabt) \n                begin\n                if ( mtrans_reg_d2 == 4'd15 ) \n                    begin\n                    address_sel_nxt = 4'd1; \n                    pc_sel_nxt      = 2'd1; \n                    pc_wen_nxt      = 1'd1; \n\n                    \n                    \n                    \n                    \n                    if ( instruction[22] )\n                         begin\n                         status_bits_sel_nxt           = 3'd1; \n                         status_bits_flags_wen_nxt     = 1'd1;\n\n                         \n                         if ( i_execute_status_bits[1:0] != USR )\n                            begin\n                            status_bits_mode_wen_nxt      = 1'd1;\n                            status_bits_irq_mask_wen_nxt  = 1'd1;\n                            status_bits_firq_mask_wen_nxt = 1'd1;\n                            end\n                         end\n                    end\n                else\n                    begin\n                    reg_bank_wsel_nxt = mtrans_reg_d2;\n                    end\n                end\n            end\n\n           \n        if ( dabt )\n            begin\n            pc_wen_nxt = 1'd0;  \n            end\n\n        \n        if ( {instruction[22],instruction[20],mtrans_r15} == 3'b110 )\n            user_mode_regs_load_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n        end\n\n\n    \n    if ( control_state == MTRANS5_ABORT )\n        begin\n        \n        \n        if (restore_base_address) \n            begin\n            reg_write_sel_nxt = 3'd6;                        \n            reg_bank_wsel_nxt  = instruction[19:16];         \n            end\n        end\n\n\n        \n    if ( control_state == MULT_PROC1 && instruction_execute )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n        pc_wen_nxt                  = 1'd0;  \n        multiply_function_nxt       = o_multiply_function;\n        end\n\n\n        \n        \n        \n    if ( control_state == MULT_PROC2 )\n        begin\n        \n        \n        pc_wen_nxt              = 1'd0;  \n        address_sel_nxt         = 4'd3;  \n        multiply_function_nxt   = o_multiply_function;\n        end\n\n\n    \n    \n    if ( control_state == MULT_STORE )\n        begin\n        reg_write_sel_nxt     = 3'd2; \n        multiply_function_nxt = o_multiply_function;\n\n        if ( itype == MULT ) \n            reg_bank_wsel_nxt      = instruction[19:16]; \n        else  \n            reg_bank_wsel_nxt      = instruction[15:12]; \n\n        if ( instruction[20] )  \n            begin\n            status_bits_sel_nxt       = 3'd4; \n            status_bits_flags_wen_nxt = 1'd1;\n            end\n        end\n\n        \n    if ( control_state == MULT_ACCUMU )\n        begin\n        multiply_function_nxt = o_multiply_function;\n        pc_wen_nxt            = 1'd0;  \n        address_sel_nxt       = 4'd3;  \n        end\n\n    \n    if ( control_state == SWAP_WRITE && instruction_execute )\n        begin\n        barrel_shift_data_sel_nxt       = 2'd2; \n        address_sel_nxt                 = 4'd4; \n        write_data_wen_nxt              = 1'd1;\n        data_access_exec_nxt            = 1'd1; \n                                                \n\n        if ( instruction[22] )\n            byte_enable_sel_nxt = 2'd1;         \n\n        if ( instruction_execute )                         \n            pc_wen_nxt                  = 1'd0; \n\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        end\n\n\n    \n    if ( control_state == SWAP_WAIT1 )\n        begin\n        barrel_shift_data_sel_nxt   = 2'd1;  \n        barrel_shift_amount_sel_nxt = 2'd3;  \n\n        \n        if ( i_execute_address[1:0] != 2'd0 )\n            barrel_shift_function_nxt = ROR;\n\n        if ( instruction_execute ) \n            begin\n            address_sel_nxt             = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n\n        \n        if ( instruction[22] )\n            alu_out_sel_nxt = 4'd3;  \n\n        if ( !dabt )\n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                pc_sel_nxt      = 2'd1; \n                address_sel_nxt = 4'd1; \n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n            end\n        end\n\n    \n    if ( control_state == COPRO_WAIT && instruction_execute )\n        begin\n        pre_fetch_instruction_wen = 1'd1;\n\n        if ( instruction[20] ) \n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                \n                \n                status_bits_sel_nxt           = 3'd3;  \n                status_bits_flags_wen_nxt     = 1'd1;\n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                   begin\n                   status_bits_mode_wen_nxt      = 1'd1;\n                   status_bits_irq_mask_wen_nxt  = 1'd1;\n                   status_bits_firq_mask_wen_nxt = 1'd1;\n                   end\n                end\n            else\n                reg_bank_wsel_nxt = instruction[15:12];\n\n            reg_write_sel_nxt = 3'd5;     \n            end\n        else \n            begin\n            copro_operation_nxt      = 2'd2;  \n            end\n        end\n\n\n    \n    \n    \n    \n    \n    if ( control_state == INT_WAIT1 )\n        status_bits_mode_nxt            = status_bits_mode_r;   \n\n    end\n\n\n\n\nassign firq_not_user_mode_nxt = !user_mode_regs_load_nxt && status_bits_mode_nxt == FIRQ;\n\n\n\n\n\n\n\nassign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );\n\nassign instruction_valid = (control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                     \n                     \n                    (!instruction_execute && (control_state == PC_STALL1    ||\n                                              control_state == MEM_WAIT1    ||\n                                              control_state == COPRO_WAIT   ||\n                                              control_state == SWAP_WRITE   ||\n                                              control_state == MULT_PROC1   ||\n                                              control_state == MTRANS_EXEC1 ||\n                                              control_state == MTRANS_EXEC3 ||\n                                              control_state == MTRANS_EXEC3B  ) );\n\n\n always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS5_ABORT ) control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if (mtrans_instruction_nxt[15:0] != 16'd0)\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            control_state_nxt = MTRANS_EXEC3;\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        control_state_nxt = MTRANS_EXEC3;\n\n    if ( control_state == MTRANS_EXEC3 )     control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC3B )    control_state_nxt = MTRANS_EXEC4;\n\n    if ( control_state == MTRANS_EXEC4  )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS5_ABORT;\n        else if (write_pc) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( mem_op )  \n             control_state_nxt = MEM_WAIT1;\n        if ( write_pc )\n             control_state_nxt = PC_STALL1;\n        if ( itype == MTRANS )\n            begin\n            if ( mtrans_num_registers != 5'd0 )\n                begin\n                \n                if ( mtrans_num_registers == 5'd1 )\n                    control_state_nxt = MTRANS_EXEC3B;\n                else\n                    control_state_nxt = MTRANS_EXEC1;\n                end\n            else\n                control_state_nxt = MTRANS_EXEC3;\n            end\n\n        if ( itype == MULT )\n                control_state_nxt = MULT_PROC1;\n\n        if ( itype == SWAP )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( itype == CORTRANS && !und_request )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt )\n                control_state_nxt = INT_WAIT1;\n        end\n    end\n\n\n\n\n\nalways @ ( posedge i_clk )\n    if (!i_fetch_stall)\n        begin\n        o_read_data                 <= i_read_data;\n        o_read_data_alignment       <= {i_execute_address[1:0], 3'd0};\n        abt_address_reg             <= i_execute_address;\n        iabt_reg                    <= i_iabt;\n        adex_reg                    <= i_adex;\n        abt_status_reg              <= i_abt_status;\n        status_bits_mode_r          <= status_bits_mode_nxt;\n        status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n        status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n        o_imm32                     <= imm32_nxt;\n        o_imm_shift_amount          <= imm_shift_amount_nxt;\n        o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n                                        \n                                        \n                                        \n                                        \n                                        \n        condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n        o_exclusive_exec            <= exclusive_exec_nxt;\n        o_data_access_exec          <= data_access_exec_nxt;\n\n        o_rm_sel                    <= o_rm_sel_nxt;\n        o_rds_sel                   <= o_rds_sel_nxt;\n        o_rn_sel                    <= o_rn_sel_nxt;\n        o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n        o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n        o_barrel_shift_function     <= barrel_shift_function_nxt;\n        o_alu_function              <= alu_function_nxt;\n        o_use_carry_in              <= use_carry_in_nxt;\n        o_multiply_function         <= multiply_function_nxt;\n        o_interrupt_vector_sel      <= next_interrupt;\n        address_sel_r               <= address_sel_nxt;\n        pc_sel_r                    <= pc_sel_nxt;\n        o_byte_enable_sel           <= byte_enable_sel_nxt;\n        o_status_bits_sel           <= status_bits_sel_nxt;\n        o_reg_write_sel             <= reg_write_sel_nxt;\n        o_user_mode_regs_load       <= user_mode_regs_load_nxt;\n        o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n        o_write_data_wen            <= write_data_wen_nxt;\n        o_base_address_wen          <= base_address_wen_nxt;\n        pc_wen_r                    <= pc_wen_nxt;\n        o_reg_bank_wsel             <= reg_bank_wsel_nxt;\n        o_reg_bank_wen              <= decode ( reg_bank_wsel_nxt );\n        o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n        o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n        o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n        o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n        o_copro_opcode1             <= instruction[23:21];\n        o_copro_opcode2             <= instruction[7:5];\n        o_copro_crn                 <= instruction[19:16];\n        o_copro_crm                 <= instruction[3:0];\n        o_copro_num                 <= instruction[11:8];\n        o_copro_operation           <= copro_operation_nxt;\n        o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n        mtrans_r15                  <= mtrans_r15_nxt;\n        restore_base_address        <= restore_base_address_nxt;\n        control_state               <= control_state_nxt;\n        mtrans_reg_d1               <= mtrans_reg;\n        mtrans_reg_d2               <= mtrans_reg_d1;\n        end\n\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        \n        \n        \n        \n        \n        if      (itype == MTRANS)\n            begin\n            saved_current_instruction              <= mtrans_instruction_nxt;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n        else if (saved_current_instruction_wen)\n            begin\n            saved_current_instruction              <= instruction;\n            saved_current_instruction_iabt         <= instruction_iabt;\n            saved_current_instruction_adex         <= instruction_adex;\n            saved_current_instruction_address      <= instruction_address;\n            saved_current_instruction_iabt_status  <= instruction_iabt_status;\n            end\n\n        if      (pre_fetch_instruction_wen)\n            begin\n            pre_fetch_instruction                  <= o_read_data;\n            pre_fetch_instruction_iabt             <= iabt_reg;\n            pre_fetch_instruction_adex             <= adex_reg;\n            pre_fetch_instruction_address          <= abt_address_reg;\n            pre_fetch_instruction_iabt_status      <= abt_status_reg;\n            end\n        end\n\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        irq   <= i_irq;\n        firq  <= i_firq;\n\n        if ( control_state == INT_WAIT1 && status_bits_mode_r == SVC )\n            begin\n            dabt_reg  <= 1'd0;\n            end\n        else\n            begin\n            dabt_reg  <= dabt_reg || i_dabt;\n            end\n\n        dabt_reg_d1  <= dabt_reg;\n        end\n\nassign dabt = dabt_reg || i_dabt;\n\n\n\n\n\n\n\n`include \"debug_functions.vh\"\n\na23_decompile  u_decompile (\n    .i_clk                      ( i_clk                            ),\n    .i_fetch_stall              ( i_fetch_stall                    ),\n    .i_instruction              ( instruction                      ),\n    .i_instruction_valid        ( instruction_valid                ),\n    .i_instruction_execute      ( instruction_execute              ),\n    .i_instruction_address      ( instruction_address              ),\n    .i_interrupt                ( {3{interrupt}} & next_interrupt  ),\n    .i_interrupt_state          ( control_state == INT_WAIT2       ),\n    .i_instruction_undefined    ( und_request                      ),\n    .i_pc_sel                   ( pc_sel_r                         ),\n    .i_pc_wen                   ( pc_wen_r                         ));\n\n\n\nwire    [(15*8)-1:0]    xCONTROL_STATE;\nwire    [(15*8)-1:0]    xMODE;\n\nassign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_EXEC3   ? \"MTRANS_EXEC3\"   :\n                               control_state == MTRANS_EXEC3B  ? \"MTRANS_EXEC3B\"  :\n                               control_state == MTRANS_EXEC4   ? \"MTRANS_EXEC4\"   :\n                               control_state == MTRANS5_ABORT  ? \"MTRANS5_ABORT\"  :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;\n\nassign xMODE  = mode_name ( status_bits_mode_r );\n\nalways @( posedge i_clk )\n    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n        begin\n        `TB_ERROR_MESSAGE\n        $display(\"Instruction with x's =%08h\", instruction);\n        end\n\n\nendmodule\n\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: a23_decode. Module specification: The a23_decode module is responsible for decoding ARM instructions in an ARM processor. It takes inputs such as clock (i_clk), read data (i_read_data), fetch stall signals (i_fetch_stall), interrupt requests (i_irq, i_firq), abort signals (i_dabt, i_iabt, i_adex), execute address (i_execute_address), abort status (i_abt_status), execute status bits (i_execute_status_bits), and multiply done signal (i_multiply_done). The module generates numerous output signals including decoded instruction information, register selection signals, ALU and barrel shifter control signals, memory access control signals, status bits and mode control signals, coprocessor operation signals, and abort handling signals. Internally, it uses various signals to manage instruction decoding, execution control, and state"
                }
            ]
        }
    ]
}