{
    "spec": "Module name: a25_decode. Module specification: This module is responsible for decoding ARM instructions in an ARM25 processor implementation. It takes inputs such as clock, reset, fetched instruction, core status, and interrupt signals, and generates control signals for other parts of the processor. The module handles different instruction types, manages the processor's control state, and handles interrupts and exceptions. Key input ports include clk, reset, i_fetch_instruction, i_core_stall, i_irq, i_firq, and i_execute_status_bits. Output ports include o_imm32, o_condition, o_decode_daccess, o_rm_sel, o_alu_function, o_reg_bank_wen, and o_copro_operation. Internal signals are used for instruction decoding, control state management, register selection, ALU control, and interrupt handling. The module is structured into",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: a25_decode\n\nExplanation: This module is responsible for decoding ARM instructions in an ARM25 processor implementation. It takes various inputs such as the fetched instruction, core status, and interrupt signals, and generates control signals for other parts of the processor. The module handles different instruction types, manages the processor's control state, and handles interrupts and exceptions. It also generates outputs for register selection, ALU operations, memory access, and coprocessor interactions. The module implements the complex instruction decoding logic required for executing ARM instructions, including handling of different addressing modes, conditional execution, and various instruction formats."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, reset, scan_enable, test_mode, i_fetch_instruction, i_core_stall, i_irq, i_firq, i_dabt, i_iabt, i_adex, i_execute_iaddress, i_execute_daddress, i_abt_status, i_execute_status_bits, i_multiply_done.\n\nExplanation:\nThese inputs include clock and reset signals, test-related signals, fetched instruction, core stall signal, interrupt requests, abort signals, execution addresses, abort status, execution status bits, and a signal indicating multiplication completion.\n\nOutput ports:\no_imm32, o_imm_shift_amount, o_shift_imm_zero, o_condition, o_decode_exclusive, o_decode_iaccess, o_decode_daccess, o_status_bits_mode, o_status_bits_irq_mask, o_status_bits_firq_mask, o_rm_sel, o_rs_sel, o_load_rd, o_rn_sel, o_barrel_shift_amount_sel, o_barrel_shift_data_sel, o_barrel_shift_function, o_alu_function, o_multiply_function, o_interrupt_vector_sel, o_iaddress_sel, o_daddress_sel, o_pc_sel, o_byte_enable_sel, o_status_bits_sel, o_reg_write_sel, o_user_mode_regs_store_nxt, o_firq_not_user_mode, o_use_carry_in, o_write_data_wen, o_base_address_wen, o_pc_wen, o_reg_bank_wen, o_status_bits_flags_wen, o_status_bits_mode_wen, o_status_bits_irq_mask_wen, o_status_bits_firq_mask_wen, o_copro_opcode1, o_copro_opcode2, o_copro_crn, o_copro_crm, o_copro_num, o_copro_operation, o_copro_write_data_wen, o_iabt_trigger, o_iabt_address, o_iabt_status, o_dabt_trigger, o_dabt_address, o_dabt_status, o_conflict, o_rn_use_read, o_rm_use_read, o_rs_use_read, o_rd_use_read.\n\nExplanation:\nThese outputs provide control signals for various parts of the processor, including immediate values, shift amounts, condition flags, register selection, ALU and barrel shifter control, memory access control, status bits control, coprocessor operation control, and abort handling signals. They are used to guide the execution of instructions and manage the processor's state."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\ninstruction, type, instruction_iabt, instruction_adex, instruction_address, instruction_iabt_status, instruction_sel, opcode, imm8, offset12, offset24, shift_imm, opcode_compare, mem_op, load_op, store_op, write_pc, current_write_pc, load_pc_nxt, load_pc_r, immediate_shift_op, rds_use_rs, branch, mem_op_pre_indexed, mem_op_post_indexed, imm32_nxt, imm_shift_amount_nxt, shift_imm_zero_nxt, condition_nxt, decode_exclusive_nxt, decode_iaccess_nxt, decode_daccess_nxt, shift_extend, barrel_shift_function_nxt, alu_function_nxt, multiply_function_nxt, status_bits_mode_nxt, status_bits_irq_mask_nxt, status_bits_firq_mask_nxt, rm_sel_nxt, rs_sel_nxt, rn_sel_nxt, barrel_shift_amount_sel_nxt, barrel_shift_data_sel_nxt, iaddress_sel_nxt, daddress_sel_nxt, pc_sel_nxt, byte_enable_sel_nxt, status_bits_sel_nxt, reg_write_sel_nxt, firq_not_user_mode_nxt, use_carry_in_nxt, alu_swap_sel_nxt, alu_not_sel_nxt, alu_cin_sel_nxt, alu_cout_sel_nxt, alu_out_sel_nxt, write_data_wen_nxt, copro_write_data_wen_nxt, base_address_wen_nxt, pc_wen_nxt, reg_bank_wen_nxt, status_bits_flags_wen_nxt, status_bits_mode_wen_nxt, status_bits_irq_mask_wen_nxt, status_bits_firq_mask_wen_nxt, control_state, control_state_nxt, dabt, dabt_reg, dabt_reg_d1, iabt_reg, adex_reg, fetch_address_r, abt_status_reg, fetch_instruction_r, fetch_instruction_type_r, saved_current_instruction, saved_current_instruction_type, saved_current_instruction_iabt, saved_current_instruction_adex, saved_current_instruction_address, saved_current_instruction_iabt_status, pre_fetch_instruction, pre_fetch_instruction_type, pre_fetch_instruction_iabt, pre_fetch_instruction_adex, pre_fetch_instruction_address, pre_fetch_instruction_iabt_status, hold_instruction, hold_instruction_type, hold_instruction_iabt, hold_instruction_adex, hold_instruction_address, hold_instruction_iabt_status, instruction_valid, instruction_execute, instruction_execute_r, mtrans_reg1, mtrans_reg2, mtrans_instruction_nxt, mtrans_reg2_mask, mtrans_base_reg_change, mtrans_num_registers, use_saved_current_instruction, use_hold_instruction, use_pre_fetch_instruction, interrupt, interrupt_or_conflict, interrupt_mode, next_interrupt, irq, firq, firq_request, irq_request, swi_request, und_request, dabt_request, copro_operation_nxt, restore_base_address, restore_base_address_nxt, regop_set_flags, load_rd_nxt, load_rd_byte, ldm_user_mode, ldm_status_bits, ldm_flags, load_rd_d1_nxt, load_rd_d1, rn_valid, rm_valid, rs_valid, rd_valid, stm_valid, rn_conflict1, rn_conflict2, rm_conflict1, rm_conflict2, rs_conflict1, rs_conflict2, rd_conflict1, rd_conflict2, stm_conflict1a, stm_conflict1b, stm_conflict2a, stm_conflict2b, conflict1, conflict2, conflict, conflict_r, rn_conflict1_r, rm_conflict1_r, rs_conflict1_r, rd_conflict1_r.\n\nExplanation:\nThese internal signals serve various purposes in the module, including:\n1. Instruction decoding (e.g., instruction, type, opcode)\n2. Control state management (e.g., control_state, control_state_nxt)\n3. Memory operation handling (e.g., mem_op, load_op, store_op)\n4. Register selection and conflict detection (e.g., rm_sel_nxt, rs_sel_nxt, rn_conflict1)\n5. ALU and barrel shifter control (e.g., alu_function_nxt, barrel_shift_function_nxt)\n6. Interrupt and exception handling (e.g., interrupt, next_interrupt, dabt_reg)\n7. Instruction pipeline management (e.g., saved_current_instruction, pre_fetch_instruction)\n8. Status bits and mode control (e.g., status_bits_mode_nxt, firq_not_user_mode_nxt)\n9. Memory access control (e.g., decode_daccess_nxt, byte_enable_sel_nxt)\n10. Coprocessor operation control (e.g., copro_operation_nxt)\n\nThese signals work together to implement the complex instruction decoding and execution control logic required for the ARM25 processor."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"../include/global_defines.vh\"\n\nmodule a25_decode\n(\ninput                       clk,\ninput                       reset,\ninput                       scan_enable,\ninput                       test_mode,\n\ninput       [31:0]          i_fetch_instruction,\ninput                       i_core_stall,                   \ninput                       i_irq,                          \ninput                       i_firq,                         \ninput                       i_dabt,                         \ninput                       i_iabt,                         \ninput                       i_adex,                         \ninput       [31:0]          i_execute_iaddress,             \ninput       [31:0]          i_execute_daddress,             \ninput       [7:0]           i_abt_status,                   \ninput       [31:0]          i_execute_status_bits,          \ninput                       i_multiply_done,                \n\n\n\n\n\noutput reg  [31:0]          o_imm32,\noutput reg  [4:0]           o_imm_shift_amount,\noutput reg                  o_shift_imm_zero,\noutput wire [3:0]           o_condition,\noutput reg                  o_decode_exclusive,       \noutput wire                 o_decode_iaccess,               \noutput reg                  o_decode_daccess,         \noutput wire [1:0]           o_status_bits_mode,\noutput wire                 o_status_bits_irq_mask,\noutput wire                 o_status_bits_firq_mask,\n\noutput reg  [3:0]           o_rm_sel,\noutput reg  [3:0]           o_rs_sel,\noutput reg  [7:0]           o_load_rd,                      \n                                                            \n                                                            \n                                                            \n                                                            \noutput reg  [3:0]           o_rn_sel,\noutput reg  [1:0]           o_barrel_shift_amount_sel,\noutput reg  [1:0]           o_barrel_shift_data_sel,\noutput reg  [1:0]           o_barrel_shift_function,\noutput reg  [8:0]           o_alu_function,\noutput reg  [1:0]           o_multiply_function,\noutput reg  [2:0]           o_interrupt_vector_sel,\noutput wire [3:0]           o_iaddress_sel,\noutput wire [3:0]           o_daddress_sel,\noutput wire [2:0]           o_pc_sel,\noutput reg  [1:0]           o_byte_enable_sel,        \noutput reg  [2:0]           o_status_bits_sel,\noutput reg  [2:0]           o_reg_write_sel,\noutput reg                  o_user_mode_regs_store_nxt,\noutput reg                  o_firq_not_user_mode,\noutput reg                  o_use_carry_in,\n\noutput reg                  o_write_data_wen,\noutput reg                  o_base_address_wen,       \n                                                            \noutput wire                 o_pc_wen,\noutput reg  [14:0]          o_reg_bank_wen,\noutput reg                  o_status_bits_flags_wen,\noutput reg                  o_status_bits_mode_wen,\noutput reg                  o_status_bits_irq_mask_wen,\noutput reg                  o_status_bits_firq_mask_wen,\n\n\n\n\noutput reg  [2:0]           o_copro_opcode1,\noutput reg  [2:0]           o_copro_opcode2,\noutput reg  [3:0]           o_copro_crn,\noutput reg  [3:0]           o_copro_crm,\noutput reg  [3:0]           o_copro_num,\noutput reg  [1:0]           o_copro_operation, \n                                                     \n                                                     \noutput reg                  o_copro_write_data_wen,\noutput                      o_iabt_trigger,\noutput      [31:0]          o_iabt_address,\noutput      [7:0]           o_iabt_status,\noutput                      o_dabt_trigger,\noutput      [31:0]          o_dabt_address,\noutput      [7:0]           o_dabt_status,\noutput                      o_conflict,\noutput reg                  o_rn_use_read,\noutput reg                  o_rm_use_read,\noutput reg                  o_rs_use_read,\noutput reg                  o_rd_use_read\n\n);\n\n`include \"../include/a25_localparams.vh\"\n`include \"../include/a25_functions.vh\"\n\nlocalparam [4:0] RST_WAIT1      = 5'd0,\n                 RST_WAIT2      = 5'd1,\n                 INT_WAIT1      = 5'd2,\n                 INT_WAIT2      = 5'd3,\n                 EXECUTE        = 5'd4,\n                 PRE_FETCH_EXEC = 5'd5,  \n                 MEM_WAIT1      = 5'd6,  \n                                         \n                 MEM_WAIT2      = 5'd7,\n                 PC_STALL1      = 5'd8,  \n                                         \n                                         \n                 PC_STALL2      = 5'd9,\n                 MTRANS_EXEC1   = 5'd10,\n                 MTRANS_EXEC2   = 5'd11,\n                 MTRANS_ABORT   = 5'd12,\n                 MULT_PROC1     = 5'd13,  \n                 MULT_PROC2     = 5'd14,  \n                 MULT_STORE     = 5'd15,  \n                 MULT_ACCUMU    = 5'd16,  \n                 SWAP_WRITE     = 5'd17,\n                 SWAP_WAIT1     = 5'd18,\n                 SWAP_WAIT2     = 5'd19,\n                 COPRO_WAIT     = 5'd20;\n\n\n\n\n\n\nwire    [31:0]         instruction;\nwire    [3:0]          type;                    \nwire                   instruction_iabt;        \nwire                   instruction_adex;        \nwire    [31:0]         instruction_address;     \n                                                \nwire    [7:0]          instruction_iabt_status; \nwire    [1:0]          instruction_sel;\nwire    [3:0]          opcode;\nwire    [7:0]          imm8;\nwire    [31:0]         offset12;\nwire    [31:0]         offset24;\nwire    [4:0]          shift_imm;\n\nwire                   opcode_compare;\nwire                   mem_op;\nwire                   load_op;\nwire                   store_op;\nwire                   write_pc;\nwire                   current_write_pc;\nreg                    load_pc_nxt;\nreg                    load_pc_r;\nwire                   immediate_shift_op;\nwire                   rds_use_rs;\nwire                   branch;\nwire                   mem_op_pre_indexed;\nwire                   mem_op_post_indexed;\n\n\nwire    [31:0]         imm32_nxt;\nwire    [4:0]          imm_shift_amount_nxt;\nwire                   shift_imm_zero_nxt;\nwire    [3:0]          condition_nxt;\nreg                    decode_exclusive_nxt;\nreg                    decode_iaccess_nxt;\nreg                    decode_daccess_nxt;\nwire                   shift_extend;\n\nreg     [1:0]          barrel_shift_function_nxt;\nwire    [8:0]          alu_function_nxt;\nreg     [1:0]          multiply_function_nxt;\nreg     [1:0]          status_bits_mode_nxt;\nreg                    status_bits_irq_mask_nxt;\nreg                    status_bits_firq_mask_nxt;\n\nwire    [3:0]          rm_sel_nxt;\nwire    [3:0]          rs_sel_nxt;\n\nwire    [3:0]          rn_sel_nxt;\nreg     [1:0]          barrel_shift_amount_sel_nxt;\nreg     [1:0]          barrel_shift_data_sel_nxt;\nreg     [3:0]          iaddress_sel_nxt;\nreg     [3:0]          daddress_sel_nxt;\nreg     [2:0]          pc_sel_nxt;\nreg     [1:0]          byte_enable_sel_nxt;\nreg     [2:0]          status_bits_sel_nxt;\nreg     [2:0]          reg_write_sel_nxt;\nwire                   firq_not_user_mode_nxt;\nreg                    use_carry_in_nxt;\n\n\nreg                    alu_swap_sel_nxt;\nreg                    alu_not_sel_nxt;\nreg     [1:0]          alu_cin_sel_nxt;\nreg                    alu_cout_sel_nxt;\nreg     [3:0]          alu_out_sel_nxt;\n\nreg                    write_data_wen_nxt;\nreg                    copro_write_data_wen_nxt;\nreg                    base_address_wen_nxt;\nreg                    pc_wen_nxt;\nreg     [14:0]         reg_bank_wen_nxt;\nreg                    status_bits_flags_wen_nxt;\nreg                    status_bits_mode_wen_nxt;\nreg                    status_bits_irq_mask_wen_nxt;\nreg                    status_bits_firq_mask_wen_nxt;\n\nreg                    saved_current_instruction_wen;   \nreg                    pre_fetch_instruction_wen;       \n\nreg     [4:0]          control_state;\nreg     [4:0]          control_state_nxt;\n\n\nwire                   dabt;\nreg                    dabt_reg;\nreg                    dabt_reg_d1;\nreg                    iabt_reg;\nreg                    adex_reg;\nreg     [31:0]         fetch_address_r;\nreg     [7:0]          abt_status_reg;\nreg     [31:0]         fetch_instruction_r;\nreg     [3:0]          fetch_instruction_type_r;\nreg     [31:0]         saved_current_instruction;\nreg     [3:0]          saved_current_instruction_type;\nreg                    saved_current_instruction_iabt;          \nreg                    saved_current_instruction_adex;          \nreg     [31:0]         saved_current_instruction_address;       \nreg     [7:0]          saved_current_instruction_iabt_status;   \nreg     [31:0]         pre_fetch_instruction;\nreg     [3:0]          pre_fetch_instruction_type;\nreg                    pre_fetch_instruction_iabt;              \nreg                    pre_fetch_instruction_adex;              \nreg     [31:0]         pre_fetch_instruction_address;           \nreg     [7:0]          pre_fetch_instruction_iabt_status;       \nreg     [31:0]         hold_instruction;\nreg     [3:0]          hold_instruction_type;\nreg                    hold_instruction_iabt;                   \nreg                    hold_instruction_adex;                   \nreg     [31:0]         hold_instruction_address;                \nreg     [7:0]          hold_instruction_iabt_status;            \n\nwire                   instruction_valid;\nwire                   instruction_execute;\nreg                    instruction_execute_r;\n\nreg     [3:0]          mtrans_reg1;             \nreg     [3:0]          mtrans_reg2;             \nreg     [31:0]         mtrans_instruction_nxt;\nwire    [15:0]         mtrans_reg2_mask;\n\nwire   [31:0]          mtrans_base_reg_change;\nwire   [4:0]           mtrans_num_registers;\nwire                   use_saved_current_instruction;\nwire                   use_hold_instruction;\nwire                   use_pre_fetch_instruction;\nwire                   interrupt;\nwire                   interrupt_or_conflict;\nwire   [1:0]           interrupt_mode;\nwire   [2:0]           next_interrupt;\nreg                    irq;\nreg                    firq;\nwire                   firq_request;\nwire                   irq_request;\nwire                   swi_request;\nwire                   und_request;\nwire                   dabt_request;\nreg    [1:0]           copro_operation_nxt;\nreg                    restore_base_address;\nreg                    restore_base_address_nxt;\n\nwire                   regop_set_flags;\n\nwire    [7:0]          load_rd_nxt;\nwire                   load_rd_byte;\nwire                   ldm_user_mode;\nwire                   ldm_status_bits;\nwire                   ldm_flags;\nwire    [6:0]          load_rd_d1_nxt;\nreg     [6:0]          load_rd_d1;  \n\nwire                   rn_valid;\nwire                   rm_valid;\nwire                   rs_valid;\nwire                   rd_valid;\nwire                   stm_valid;\nwire                   rn_conflict1;\nwire                   rn_conflict2;\nwire                   rm_conflict1;\nwire                   rm_conflict2;\nwire                   rs_conflict1;\nwire                   rs_conflict2;\nwire                   rd_conflict1;\nwire                   rd_conflict2;\nwire                   stm_conflict1a;\nwire                   stm_conflict1b;\nwire                   stm_conflict2a;\nwire                   stm_conflict2b;\nwire                   conflict1;          \nwire                   conflict2;          \nwire                   conflict;           \nreg                    conflict_r;\nreg                    rn_conflict1_r;\nreg                    rm_conflict1_r;\nreg                    rs_conflict1_r;\nreg                    rd_conflict1_r;\n\n\n\n\nreg  [3:0]           condition_r;             \nreg                  decode_iaccess_r;        \nreg  [1:0]           status_bits_mode_r;     \nreg                  status_bits_irq_mask_r;\nreg                  status_bits_firq_mask_r;\nreg [3:0]            iaddress_sel_r;\nreg [3:0]            daddress_sel_r;\nreg [2:0]            pc_sel_r;\nreg                  pc_wen_r;\n\n\nassign o_condition                 = condition_r;\nassign o_decode_iaccess            = decode_iaccess_r;\nassign o_status_bits_mode          = status_bits_mode_r;\nassign o_status_bits_irq_mask      = status_bits_irq_mask_r;\nassign o_status_bits_firq_mask     = status_bits_firq_mask_r;\nassign o_iaddress_sel              = iaddress_sel_r;\nassign o_daddress_sel              = daddress_sel_r;\nassign o_pc_sel                    = pc_sel_r;\nassign o_pc_wen                    = pc_wen_r;\n\n\n\n\n\n\n\nassign o_iabt_trigger     = instruction_iabt && status_bits_mode_r == SVC && control_state == INT_WAIT1;\nassign o_iabt_address     = instruction_address;\nassign o_iabt_status      = instruction_iabt_status;\n\nassign o_dabt_trigger     = dabt_reg && !dabt_reg_d1;\nassign o_dabt_address     = fetch_address_r;\nassign o_dabt_status      = abt_status_reg;\n\n\n\n\n\n\n\n\n\n\n\n\n\nassign use_saved_current_instruction = instruction_execute &&\n                          ( control_state == MEM_WAIT1     ||\n                            control_state == MEM_WAIT2     ||\n                            control_state == MTRANS_EXEC1  ||\n                            control_state == MTRANS_EXEC2  ||\n                            control_state == MTRANS_ABORT  ||\n                            control_state == MULT_PROC1    ||\n                            control_state == MULT_PROC2    ||\n                            control_state == MULT_ACCUMU   ||\n                            control_state == MULT_STORE    ||\n                            control_state == INT_WAIT1     ||\n                            control_state == INT_WAIT2     ||\n                            control_state == SWAP_WRITE    ||\n                            control_state == SWAP_WAIT1    ||\n                            control_state == SWAP_WAIT2    ||\n                            control_state == COPRO_WAIT     );\n\nassign use_hold_instruction = conflict_r;\n\nassign use_pre_fetch_instruction = control_state == PRE_FETCH_EXEC;\n\n\nassign instruction_sel  =         use_hold_instruction           ? 2'd3 :  \n                                  use_saved_current_instruction  ? 2'd1 :  \n                                  use_pre_fetch_instruction      ? 2'd2 :  \n                                                                   2'd0 ;  \n\nassign instruction      =         instruction_sel == 2'd0 ? fetch_instruction_r       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction :\n                                  instruction_sel == 2'd3 ? hold_instruction          :\n                                                            pre_fetch_instruction     ;\n\nassign type             =         instruction_sel == 2'd0 ? fetch_instruction_type_r       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_type :\n                                  instruction_sel == 2'd3 ? hold_instruction_type          :\n                                                            pre_fetch_instruction_type     ;\n\n\nassign instruction_iabt =         instruction_sel == 2'd0 ? iabt_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt :\n                                  instruction_sel == 2'd3 ? hold_instruction_iabt          :\n                                                            pre_fetch_instruction_iabt     ;\n\nassign instruction_address =      instruction_sel == 2'd0 ? fetch_address_r                   :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_address :\n                                  instruction_sel == 2'd3 ? hold_instruction_address          :\n                                                            pre_fetch_instruction_address     ;\n\nassign instruction_iabt_status =  instruction_sel == 2'd0 ? abt_status_reg                        :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt_status :\n                                  instruction_sel == 2'd3 ? hold_instruction_iabt_status          :\n                                                            pre_fetch_instruction_iabt_status     ;\n\n\nassign instruction_adex =         instruction_sel == 2'd0 ? adex_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_adex :\n                                  instruction_sel == 2'd3 ? hold_instruction_adex          :\n                                                            pre_fetch_instruction_adex     ;\n\n\n\n\n\n\nassign opcode               = instruction[24:21];\nassign condition_nxt        = instruction[31:28];\n\nassign rm_sel_nxt           = instruction[3:0];\nassign rn_sel_nxt           = branch ? 4'd15 : instruction[19:16]; \nassign rs_sel_nxt           = control_state == SWAP_WRITE  ? instruction[3:0]   : \n                              type == MTRANS               ? mtrans_reg1         :\n                              branch                       ? 4'd15              : \n                              rds_use_rs                   ? instruction[11:8]  :\n                                                             instruction[15:12] ;\n\n\nassign ldm_user_mode        = type == MTRANS && {instruction[22],instruction[20],instruction[15]} == 3'b110;\nassign ldm_flags            = type == MTRANS && rs_sel_nxt == 4'd15 && instruction[20] && instruction[22];\nassign ldm_status_bits      = type == MTRANS && rs_sel_nxt == 4'd15 && instruction[20] && instruction[22] && i_execute_status_bits[1:0] != USR;\nassign load_rd_byte         = (type == TRANS || type == SWAP) && instruction[22];\nassign load_rd_nxt          = {ldm_flags, ldm_status_bits, ldm_user_mode, load_rd_byte, rs_sel_nxt};\n\n\nassign shift_extend         = !instruction[25] && !instruction[4] && !(|instruction[11:7]) && instruction[6:5] == 2'b11;\n\n                            \nassign load_rd_d1_nxt       = {o_decode_daccess && !o_write_data_wen, o_load_rd[3:0]};\nassign shift_imm            = instruction[11:7];\nassign offset12             = { 20'h0, instruction[11:0]};\nassign offset24             = {{6{instruction[23]}}, instruction[23:0], 2'd0 }; \nassign imm8                 = instruction[7:0];\n\nassign immediate_shift_op   = instruction[25];\nassign rds_use_rs           = (type == REGOP && !instruction[25] && instruction[4]) ||\n                              (type == MULT &&\n                               (control_state == MULT_PROC1  ||\n                                control_state == MULT_PROC2  ||\n\n\n\n                                (instruction_valid && !interrupt_or_conflict))) ;\n\n\nassign branch               = type == BRANCH;\nassign opcode_compare       = opcode == CMP || opcode == CMN || opcode == TEQ || opcode == TST ;\nassign mem_op               = type == TRANS;\nassign load_op              = mem_op && instruction[20];\nassign store_op             = mem_op && !instruction[20];\nassign write_pc             = (pc_wen_nxt && pc_sel_nxt != 3'd0) || load_pc_r || load_pc_nxt;\nassign current_write_pc     = (pc_wen_nxt && pc_sel_nxt != 3'd0) || load_pc_nxt;\nassign regop_set_flags      = type == REGOP && instruction[20];\n\nassign mem_op_pre_indexed   =  instruction[24] && instruction[21];\nassign mem_op_post_indexed  = !instruction[24];\n\nassign imm32_nxt            =  \n                               type == MULT               ? {  32'd0                      } :\n\n                               \n                               type == MTRANS             ? {  mtrans_base_reg_change     } :\n                               type == BRANCH             ? {  offset24                   } :\n                               type == TRANS              ? {  offset12                   } :\n                               instruction[11:8] == 4'h0  ? {            24'h0, imm8[7:0] } :\n                               instruction[11:8] == 4'h1  ? { imm8[1:0], 24'h0, imm8[7:2] } :\n                               instruction[11:8] == 4'h2  ? { imm8[3:0], 24'h0, imm8[7:4] } :\n                               instruction[11:8] == 4'h3  ? { imm8[5:0], 24'h0, imm8[7:6] } :\n                               instruction[11:8] == 4'h4  ? { imm8[7:0], 24'h0            } :\n                               instruction[11:8] == 4'h5  ? { 2'h0,  imm8[7:0], 22'h0     } :\n                               instruction[11:8] == 4'h6  ? { 4'h0,  imm8[7:0], 20'h0     } :\n                               instruction[11:8] == 4'h7  ? { 6'h0,  imm8[7:0], 18'h0     } :\n                               instruction[11:8] == 4'h8  ? { 8'h0,  imm8[7:0], 16'h0     } :\n                               instruction[11:8] == 4'h9  ? { 10'h0, imm8[7:0], 14'h0     } :\n                               instruction[11:8] == 4'ha  ? { 12'h0, imm8[7:0], 12'h0     } :\n                               instruction[11:8] == 4'hb  ? { 14'h0, imm8[7:0], 10'h0     } :\n                               instruction[11:8] == 4'hc  ? { 16'h0, imm8[7:0], 8'h0      } :\n                               instruction[11:8] == 4'hd  ? { 18'h0, imm8[7:0], 6'h0      } :\n                               instruction[11:8] == 4'he  ? { 20'h0, imm8[7:0], 4'h0      } :\n                                                            { 22'h0, imm8[7:0], 2'h0      } ;\n\n\nassign imm_shift_amount_nxt = shift_imm ;\n\n       \n       \nassign shift_imm_zero_nxt   = imm_shift_amount_nxt == 5'd0 &&       \n                              barrel_shift_amount_sel_nxt == 2'd2;  \n\nassign alu_function_nxt     = { alu_swap_sel_nxt,\n                                alu_not_sel_nxt,\n                                alu_cin_sel_nxt,\n                                alu_cout_sel_nxt,\n                                alu_out_sel_nxt  };\n\n\n\n\nassign rn_valid       = type == REGOP || type == MULT || type == SWAP || type == TRANS || type == MTRANS || type == CODTRANS;\nassign rm_valid       = type == REGOP || type == MULT || type == SWAP || (type == TRANS && immediate_shift_op);\nassign rs_valid       = rds_use_rs;\nassign rd_valid       = (type == TRANS  && store_op) || (type == REGOP || type == SWAP);\nassign stm_valid      = type == MTRANS && !instruction[20];   \n\n\nassign rn_conflict1   = instruction_execute   && rn_valid  && ( load_rd_d1_nxt[4] && rn_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rn_conflict2   = instruction_execute_r && rn_valid  && ( load_rd_d1    [4] && rn_sel_nxt         == load_rd_d1    [3:0] );\nassign rm_conflict1   = instruction_execute   && rm_valid  && ( load_rd_d1_nxt[4] && rm_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rm_conflict2   = instruction_execute_r && rm_valid  && ( load_rd_d1    [4] && rm_sel_nxt         == load_rd_d1    [3:0] );\nassign rs_conflict1   = instruction_execute   && rs_valid  && ( load_rd_d1_nxt[4] && rs_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rs_conflict2   = instruction_execute_r && rs_valid  && ( load_rd_d1    [4] && rs_sel_nxt         == load_rd_d1    [3:0] );\nassign rd_conflict1   = instruction_execute   && rd_valid  && ( load_rd_d1_nxt[4] && instruction[15:12] == load_rd_d1_nxt[3:0] );\nassign rd_conflict2   = instruction_execute_r && rd_valid  && ( load_rd_d1    [4] && instruction[15:12] == load_rd_d1    [3:0] );\n\nassign stm_conflict1a = instruction_execute   && stm_valid && ( load_rd_d1_nxt[4] && mtrans_reg1        == load_rd_d1_nxt[3:0] );\nassign stm_conflict1b = instruction_execute   && stm_valid && ( load_rd_d1_nxt[4] && mtrans_reg2        == load_rd_d1_nxt[3:0] );\nassign stm_conflict2a = instruction_execute_r && stm_valid && ( load_rd_d1    [4] && mtrans_reg1        == load_rd_d1    [3:0] );\nassign stm_conflict2b = instruction_execute_r && stm_valid && ( load_rd_d1    [4] && mtrans_reg2        == load_rd_d1    [3:0] );\n\nassign conflict1      = instruction_valid &&\n                        (rn_conflict1 || rm_conflict1 || rs_conflict1 || rd_conflict1 ||\n                         stm_conflict1a || stm_conflict1b);\n\nassign conflict2      = instruction_valid && (stm_conflict2a || stm_conflict2b);\n\nassign conflict       = conflict1 || conflict2;\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tconflict_r              <= 'd0;\n\t\tinstruction_execute_r   <= 'd0;\n\t\trn_conflict1_r          <= 'd0;\n\t\trm_conflict1_r          <= 'd0;\n\t\trs_conflict1_r          <= 'd0;\n\t\trd_conflict1_r          <= 'd0;\n\t\to_rn_use_read           <= 'd0;\n\t\to_rm_use_read           <= 'd0;\n\t\to_rs_use_read           <= 'd0;\n\t\to_rd_use_read           <= 'd0;\n\tend else if ( !i_core_stall ) begin\n\t\tconflict_r              <= conflict;\n\t\tinstruction_execute_r   <= instruction_execute;\n\t\trn_conflict1_r          <= rn_conflict1 && instruction_execute;\n\t\trm_conflict1_r          <= rm_conflict1 && instruction_execute;\n\t\trs_conflict1_r          <= rs_conflict1 && instruction_execute;\n\t\trd_conflict1_r          <= rd_conflict1 && instruction_execute;\n\t\to_rn_use_read           <= instruction_valid && ( rn_conflict1_r || rn_conflict2 );\n\t\to_rm_use_read           <= instruction_valid && ( rm_conflict1_r || rm_conflict2 );\n\t\to_rs_use_read           <= instruction_valid && ( rs_conflict1_r || rs_conflict2 );\n\t\to_rd_use_read           <= instruction_valid && ( rd_conflict1_r || rd_conflict2 );\n\tend\nend\n\nassign o_conflict = conflict;\n\n\n\n\n\n\n   \n   \n   \nalways @*\n    casez ( instruction[15:0] )\n    16'b???????????????1 : mtrans_reg1 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg1 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg1 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg1 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg1 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg1 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg1 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg1 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg1 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg1 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg1 = 4'ha ;\n    16'b????100000000000 : mtrans_reg1 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg1 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg1 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg1 = 4'he ;\n    default              : mtrans_reg1 = 4'hf ;\n    endcase\n\n\nassign mtrans_reg2_mask = 1'd1<<mtrans_reg1;\n\nalways @*\n    casez ( instruction[15:0] & ~mtrans_reg2_mask )\n    16'b???????????????1 : mtrans_reg2 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg2 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg2 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg2 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg2 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg2 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg2 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg2 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg2 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg2 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg2 = 4'ha ;\n    16'b????100000000000 : mtrans_reg2 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg2 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg2 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg2 = 4'he ;\n    default              : mtrans_reg2 = 4'hf ;\n    endcase\n\nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase\n\n\n\nassign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;\n\n\nassign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};\n\n\n\n\n\nassign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = type == SWI;\nassign dabt_request = dabt_reg;\n\n\n\n\nassign und_request  =   type == CODTRANS ||\n                        type == COREGOP  ||\n                      ( type == CORTRANS && instruction[11:8] != 4'd15 );\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \nassign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  \n\n\n\n\n\nassign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 &&  \n                        !conflict               ;  \n                                                   \n\n\n\n\nassign interrupt_or_conflict\n                     =  next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6  ;  \n\nassign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;\n\n\n\n\n\nalways @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    decode_exclusive_nxt            = 1'd0;\n    decode_daccess_nxt              = 1'd0;\n    decode_iaccess_nxt              = 1'd1;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    iaddress_sel_nxt                = 'd0;\n    daddress_sel_nxt                = 'd0;\n    pc_sel_nxt                      = 'd0;\n    load_pc_nxt                     = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wen_nxt                = 'd0;  \n\n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt && !conflict )\n        begin\n        if ( type == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt       = 3'd1; \n                    iaddress_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wen_nxt = decode (instruction[15:12]);\n                end\n\n            if ( !immediate_shift_op )\n                begin\n                barrel_shift_function_nxt  = instruction[6:5];\n                end\n\n            if ( !immediate_shift_op )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shift_op && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shift_op && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt = 4'd6;  \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n            end\n\n        \n        if ( mem_op )\n            begin\n            if ( load_op && instruction[15:12]  == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n\n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( type == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 3'd1;\n                else\n                    reg_bank_wen_nxt = decode ( rn_sel_nxt );\n                end\n\n                \n            if ( mem_op_post_indexed )\n               daddress_sel_nxt = 4'd4; \n            else\n               daddress_sel_nxt = 4'd1; \n\n            if ( instruction[25] && type ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( type == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n\n        if ( type == BRANCH )\n            begin\n            pc_sel_nxt            = 3'd1; \n            iaddress_sel_nxt      = 4'd1; \n            alu_out_sel_nxt       = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wen_nxt  = decode (4'd14);  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n\n        if ( type == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            if ( mtrans_num_registers > 4'd1 )\n                begin\n                iaddress_sel_nxt        = 4'd3; \n                pc_wen_nxt              = 1'd0; \n                end\n\n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] )\n                begin\n                if ( instruction[24] )    \n                    daddress_sel_nxt = 4'd7; \n                else\n                    daddress_sel_nxt = 4'd4; \n                end\n            else\n            \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    daddress_sel_nxt  = 4'd6; \n                else\n                    daddress_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            if ( {instruction[22],instruction[20]} == 2'b10 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wen_nxt  = decode (rn_sel_nxt);\n\n            \n            if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n            end\n\n\n        if ( type == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( type == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            decode_iaccess_nxt              = 1'd0; \n            decode_daccess_nxt              = 1'd1; \n            barrel_shift_data_sel_nxt       = 2'd2; \n            daddress_sel_nxt                = 4'd4; \n            decode_exclusive_nxt            = 1'd1; \n            end\n\n\n        \n        if ( type == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            iaddress_sel_nxt                = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( type == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wen_nxt                = decode (4'd14);  \n\n            iaddress_sel_nxt                = 4'd2;            \n            pc_sel_nxt                      = 3'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end\n\n    \n    \n    \n    \n    \n    \n    if ( instruction_valid && interrupt &&  next_interrupt != 3'd6 )\n        begin\n        \n        \n        \n        saved_current_instruction_wen   = 1'd1;\n\n        \n        \n        if ( next_interrupt == 3'd4 )\n            reg_write_sel_nxt               = 3'd7;            \n        else\n            reg_write_sel_nxt               = 3'd1;            \n\n        reg_bank_wen_nxt                = decode (4'd14);  \n\n        iaddress_sel_nxt                = 4'd2;            \n        pc_sel_nxt                      = 3'd2;            \n\n        status_bits_mode_nxt            = interrupt_mode;  \n        status_bits_mode_wen_nxt        = 1'd1;\n\n        \n        status_bits_irq_mask_nxt        = 1'd1;\n        status_bits_irq_mask_wen_nxt    = 1'd1;\n\n        \n        if ( next_interrupt == 3'd2 ) \n            begin\n            status_bits_firq_mask_nxt        = 1'd1;\n            status_bits_firq_mask_wen_nxt    = 1'd1;\n            end\n        end\n\n\n    \n    \n    if ( control_state == MEM_WAIT1 && !conflict )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            iaddress_sel_nxt            = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            load_pc_nxt                 = load_pc_r;\n            end\n        end\n\n\n    \n    if ( control_state == MEM_WAIT2 )\n        begin\n        if ( !dabt )  \n            begin\n            pc_wen_nxt                  = 1'd0; \n\n            \n            if (( type == TRANS && instruction[15:12]  == 4'd15 ) ||\n                ( type == MTRANS && instruction[20] && mtrans_reg1 == 4'd15 ))\n                begin\n                pc_sel_nxt       = 3'd3; \n                iaddress_sel_nxt = 4'd3; \n                load_pc_nxt      = load_pc_r;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC1 && !conflict )\n        begin\n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            daddress_sel_nxt            = 4'd5;  \n            decode_daccess_nxt          = 1'd1;  \n\n            if ( mtrans_num_registers > 4'd2 )\n                decode_iaccess_nxt      = 1'd0;  \n\n\n            if ( mtrans_num_registers != 4'd1 )\n                begin\n                pc_wen_nxt              = 1'd0;  \n                iaddress_sel_nxt        = 4'd3;  \n                end\n\n\n            if ( !instruction[20] ) \n                write_data_wen_nxt = 1'd1;\n\n            \n            if ( {instruction[22],instruction[20]} == 2'b10 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC2 )\n        begin\n        daddress_sel_nxt            = 4'd5;  \n        decode_daccess_nxt          = 1'd1;  \n\n        if ( mtrans_num_registers > 4'd2 )\n            begin\n            decode_iaccess_nxt      = 1'd0;  \n            end\n\n        if ( mtrans_num_registers > 4'd1 )\n            begin\n            pc_wen_nxt              = 1'd0; \n            iaddress_sel_nxt        = 4'd3;  \n            end\n\n        \n        if ( !instruction[20] )\n            write_data_wen_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n\n        \n        if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            load_pc_nxt                     = 1'd1;\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_ABORT )\n        begin\n        \n        \n        if (restore_base_address) \n            begin\n            reg_write_sel_nxt = 3'd6;                        \n            reg_bank_wen_nxt  = decode ( instruction[19:16] ); \n            end\n        end\n\n\n        \n    if ( control_state == MULT_PROC1 && instruction_execute && !conflict )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n        pc_wen_nxt                  = 1'd0;  \n        multiply_function_nxt       = o_multiply_function;\n        end\n\n\n        \n        \n        \n    if ( control_state == MULT_PROC2 )\n        begin\n        \n        \n        pc_wen_nxt              = 1'd0;  \n        iaddress_sel_nxt        = 4'd3;  \n        multiply_function_nxt   = o_multiply_function;\n        end\n\n\n    \n    \n    if ( control_state == MULT_STORE )\n        begin\n        reg_write_sel_nxt     = 3'd2; \n        multiply_function_nxt = o_multiply_function;\n\n        if ( type == MULT ) \n            reg_bank_wen_nxt      = decode (instruction[19:16]); \n        else  \n            reg_bank_wen_nxt      = decode (instruction[15:12]); \n\n        if ( instruction[20] )  \n            begin\n            status_bits_sel_nxt       = 3'd4; \n            status_bits_flags_wen_nxt = 1'd1;\n            end\n        end\n\n\n    \n    if ( control_state == MULT_ACCUMU )\n        begin\n        multiply_function_nxt = o_multiply_function;\n        pc_wen_nxt            = 1'd0;  \n        iaddress_sel_nxt      = 4'd3;  \n        end\n\n\n    \n    if ( control_state == SWAP_WRITE && instruction_execute && !conflict )\n        begin\n        barrel_shift_data_sel_nxt       = 2'd2; \n        daddress_sel_nxt                = 4'd4; \n        write_data_wen_nxt              = 1'd1;\n        decode_iaccess_nxt              = 1'd0; \n        decode_daccess_nxt              = 1'd1; \n\n        if ( instruction[22] )\n            byte_enable_sel_nxt = 2'd1;         \n\n        if ( instruction_execute )              \n            pc_wen_nxt                  = 1'd0; \n\n        \n        \n        pre_fetch_instruction_wen       = 1'd1;\n\n        load_pc_nxt                     = load_pc_r;\n        end\n\n\n    \n    if ( control_state == SWAP_WAIT1 )\n        begin\n\n        if ( instruction_execute ) \n            begin\n            iaddress_sel_nxt            = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n\n        if ( !dabt )\n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                pc_sel_nxt       = 3'd3; \n                iaddress_sel_nxt = 4'd3; \n                load_pc_nxt      = load_pc_r;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == COPRO_WAIT && instruction_execute && !conflict )\n        begin\n        pre_fetch_instruction_wen = 1'd1;\n\n        if ( instruction[20] ) \n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                \n                \n                status_bits_sel_nxt           = 3'd3;  \n                status_bits_flags_wen_nxt     = 1'd1;\n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                   begin\n                   status_bits_mode_wen_nxt      = 1'd1;\n                   status_bits_irq_mask_wen_nxt  = 1'd1;\n                   status_bits_firq_mask_wen_nxt = 1'd1;\n                   end\n                end\n            else\n                reg_bank_wen_nxt = decode (instruction[15:12]);\n\n            reg_write_sel_nxt = 3'd5;     \n            end\n        else \n            begin\n            copro_operation_nxt      = 2'd2;  \n            end\n        end\n\n\n    \n    \n    \n    \n    \n    if ( control_state == INT_WAIT1 )\n        status_bits_mode_nxt            = status_bits_mode_r;   \n\n    end\n\n\n\n\nassign firq_not_user_mode_nxt = status_bits_mode_nxt == FIRQ;\n\n\n\n\n\n\n\nassign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );\n\n\n\n\nassign instruction_valid = ((control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                              \n                              \n                             (!instruction_execute && (control_state == PC_STALL1    ||\n                                                       control_state == MEM_WAIT1    ||\n                                                       control_state == COPRO_WAIT   ||\n                                                       control_state == SWAP_WRITE   ||\n                                                       control_state == MULT_PROC1   ||\n                                                       control_state == MTRANS_EXEC1  ) ));\n\n\n always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS_ABORT )  control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if ( mtrans_instruction_nxt[15:0] != 16'd0 )\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            begin\n            if ( dabt ) \n                control_state_nxt = MTRANS_ABORT;\n            else if ( write_pc ) \n                control_state_nxt = MEM_WAIT1;\n            else\n                control_state_nxt = PRE_FETCH_EXEC;\n            end\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS_ABORT;\n        else if ( write_pc ) \n            control_state_nxt = MEM_WAIT1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( current_write_pc )\n             control_state_nxt = PC_STALL1;\n\n        if ( load_op && instruction[15:12]  == 4'd15 )  \n             control_state_nxt = MEM_WAIT1;\n\n        \n        if ( type == MTRANS && instruction[20] && mtrans_reg1 == 4'd15 ) \n             control_state_nxt = MEM_WAIT1;\n\n        if ( type == MTRANS && !conflict && mtrans_num_registers != 5'd0 && mtrans_num_registers != 5'd1 )\n            control_state_nxt = MTRANS_EXEC1;\n\n        if ( type == MULT && !conflict )\n                control_state_nxt = MULT_PROC1;\n\n        if ( type == SWAP && !conflict )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( type == CORTRANS && !und_request && !conflict )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt && !conflict )\n                control_state_nxt = INT_WAIT1;\n        end\n\n    end\n\n\n\n\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tfetch_instruction_r         <= 'd0;\n\t\tfetch_instruction_type_r    <= 'd0;\n\t\tfetch_address_r             <= 'd0;\n\t\tiabt_reg                    <= 'd0;\n\t\tadex_reg                    <= 'd0;\n\t\tabt_status_reg              <= 'd0;\n\t\tstatus_bits_mode_r          <= 2'b11;\n\t\tstatus_bits_irq_mask_r      <= 1'd1;\n\t\tstatus_bits_firq_mask_r     <= 1'd1;\n\t\to_imm32                     <= 'd0;\n\t\to_imm_shift_amount          <= 'd0;\n\t\to_shift_imm_zero            <= 'd0;\n\t\tcondition_r                 <= 4'hE;\n\t\to_decode_exclusive          <= 'd0;\n\t\tdecode_iaccess_r            <= 1'd1;\n\t\to_decode_daccess            <= 'd0;\n\t\to_rm_sel                    <= 'd0;\n\t\to_rs_sel                    <= 'd0;\n\t\to_load_rd                   <= 'd0;\n\t\tload_rd_d1                  <= 'd0;\n\t\tload_pc_r                   <= 'd0;\n\t\to_rn_sel                    <= 'd0;\n\t\to_barrel_shift_amount_sel   <= 'd0;\n\t\to_barrel_shift_data_sel     <= 'd0;\n\t\to_barrel_shift_function     <= 'd0;\n\t\to_alu_function              <= 'd0;\n\t\to_use_carry_in              <= 'd0;\n\t\to_multiply_function         <= 'd0;\n\t\to_interrupt_vector_sel      <= 'd0;\n\t\tiaddress_sel_r              <= 4'd2;\n\t\tdaddress_sel_r              <= 4'd2;\n\t\tpc_sel_r                    <= 3'd2;\n\t\to_byte_enable_sel           <= 'd0;\n\t\to_status_bits_sel           <= 'd0;\n\t\to_reg_write_sel             <= 'd0;\n\t\to_firq_not_user_mode        <= 'd0;\n\t\to_write_data_wen            <= 'd0;\n\t\to_base_address_wen          <= 'd0;\n\t\tpc_wen_r                    <= 1'd1;\n\t\to_reg_bank_wen              <= 'd0;\n\t\to_status_bits_flags_wen     <= 'd0;\n\t\to_status_bits_mode_wen      <= 'd0;\n\t\to_status_bits_irq_mask_wen  <= 'd0;\n\t\to_status_bits_firq_mask_wen <= 'd0;\n\t\to_copro_opcode1             <= 'd0;\n\t\to_copro_opcode2             <= 'd0;\n\t\to_copro_crn                 <= 'd0;\n\t\to_copro_crm                 <= 'd0;\n\t\to_copro_num                 <= 'd0;\n\t\to_copro_operation           <= 'd0;\n\t\to_copro_write_data_wen      <= 'd0;\n\t\trestore_base_address        <= 'd0;\n\t\tcontrol_state               <= RST_WAIT1;\n\tend else begin\n\t    if ( !i_core_stall ) begin\n\t\t  if (!conflict) begin\n\t\t      fetch_instruction_r         <= i_fetch_instruction;\n\t\t      fetch_instruction_type_r    <= instruction_type(i_fetch_instruction);\n\t\t      fetch_address_r             <= i_execute_iaddress;\n\t\t      iabt_reg                    <= i_iabt;\n\t\t      adex_reg                    <= i_adex;\n\t\t      abt_status_reg              <= i_abt_status;\n\t\t      end\n\n\t\t  status_bits_mode_r          <= status_bits_mode_nxt;\n\t\t  status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n\t\t  status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n\t\t  o_imm32                     <= imm32_nxt;\n\t\t  o_imm_shift_amount          <= imm_shift_amount_nxt;\n\t\t  o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t  condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n\t\t  o_decode_exclusive          <= decode_exclusive_nxt;\n\t\t  decode_iaccess_r            <= decode_iaccess_nxt;\n\t\t  o_decode_daccess            <= decode_daccess_nxt;\n\n\t\t  o_rm_sel                    <= rm_sel_nxt;\n\t\t  o_rs_sel                    <= rs_sel_nxt;\n\t\t  o_load_rd                   <= load_rd_nxt;\n\t\t  load_rd_d1                  <= load_rd_d1_nxt;\n\t\t  load_pc_r                   <= load_pc_nxt;\n\t\t  o_rn_sel                    <= rn_sel_nxt;\n\t\t  o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n\t\t  o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n\t\t  o_barrel_shift_function     <= barrel_shift_function_nxt;\n\t\t  o_alu_function              <= alu_function_nxt;\n\t\t  o_use_carry_in              <= use_carry_in_nxt;\n\t\t  o_multiply_function         <= multiply_function_nxt;\n\t\t  o_interrupt_vector_sel      <= next_interrupt;\n\t\t  iaddress_sel_r              <= iaddress_sel_nxt;\n\t\t  daddress_sel_r              <= daddress_sel_nxt;\n\t\t  pc_sel_r                    <= pc_sel_nxt;\n\t\t  o_byte_enable_sel           <= byte_enable_sel_nxt;\n\t\t  o_status_bits_sel           <= status_bits_sel_nxt;\n\t\t  o_reg_write_sel             <= reg_write_sel_nxt;\n\t\t  o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n\t\t  o_write_data_wen            <= write_data_wen_nxt;\n\t\t  o_base_address_wen          <= base_address_wen_nxt;\n\t\t  pc_wen_r                    <= pc_wen_nxt;\n\t\t  o_reg_bank_wen              <= reg_bank_wen_nxt;\n\t\t  o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n\t\t  o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n\t\t  o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n\t\t  o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n\t\t  o_copro_opcode1             <= instruction[23:21];\n\t\t  o_copro_opcode2             <= instruction[7:5];\n\t\t  o_copro_crn                 <= instruction[19:16];\n\t\t  o_copro_crm                 <= instruction[3:0];\n\t\t  o_copro_num                 <= instruction[11:8];\n\t\t  o_copro_operation           <= copro_operation_nxt;\n\t\t  o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n\t\t  restore_base_address        <= restore_base_address_nxt;\n\t\t  control_state               <= control_state_nxt;\n\t\tend\n\tend\nend\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tsaved_current_instruction              <= 'd0;\n\t\tsaved_current_instruction_type         <= 'd0;\n\t\tsaved_current_instruction_iabt         <= 'd0;\n\t\tsaved_current_instruction_adex         <= 'd0;\n\t\tsaved_current_instruction_address      <= 'd0;\n\t\tsaved_current_instruction_iabt_status  <= 'd0;\n\t\tpre_fetch_instruction                  <= 'd0;\n\t\tpre_fetch_instruction_type             <= 'd0;\n\t\tpre_fetch_instruction_iabt             <= 'd0;\n\t\tpre_fetch_instruction_adex             <= 'd0;\n\t\tpre_fetch_instruction_address          <= 'd0;\n\t\tpre_fetch_instruction_iabt_status      <= 'd0;\n\t\thold_instruction              <= 'd0;\n\t\thold_instruction_type         <= 'd0;\n\t\thold_instruction_iabt         <= 'd0;\n\t\thold_instruction_adex         <= 'd0;\n\t\thold_instruction_address      <= 'd0;\n\t\thold_instruction_iabt_status  <= 'd0;\n\tend else begin\n\t    if ( !i_core_stall )\n\t\t  begin\n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  if      ( type == MTRANS )\n\t\t      begin\n\t\t      saved_current_instruction              <= mtrans_instruction_nxt;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\t\t  else if ( saved_current_instruction_wen )\n\t\t      begin\n\t\t      saved_current_instruction              <= instruction;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\n\t\t  if      ( pre_fetch_instruction_wen )\n\t\t      begin\n\t\t      pre_fetch_instruction                  <= fetch_instruction_r;\n\t\t      pre_fetch_instruction_type             <= fetch_instruction_type_r;\n\t\t      pre_fetch_instruction_iabt             <= iabt_reg;\n\t\t      pre_fetch_instruction_adex             <= adex_reg;\n\t\t      pre_fetch_instruction_address          <= fetch_address_r;\n\t\t      pre_fetch_instruction_iabt_status      <= abt_status_reg;\n\t\t      end\n\n\n\t\t  \n\t\t  hold_instruction              <= instruction;\n\t\t  hold_instruction_type         <= type;\n\t\t  hold_instruction_iabt         <= instruction_iabt;\n\t\t  hold_instruction_adex         <= instruction_adex;\n\t\t  hold_instruction_address      <= instruction_address;\n\t\t  hold_instruction_iabt_status  <= instruction_iabt_status;\n\t\t  end\n\tend\nend\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tirq   <= 'd0;\n\t\tfirq  <= 'd0;\n\t\tdabt_reg  <= 'd0;\n\t\tdabt_reg_d1  <= 'd0;\n\tend else begin\n\t\tif ( !i_core_stall ) begin\n\t\t\tirq   <= i_irq;\n\t\t\tfirq  <= i_firq;\n\t\t\tif ( control_state == INT_WAIT1 && status_bits_mode_r == SVC ) begin\n\t\t\t\tdabt_reg  <= 1'd0;\n\t\t\tend else begin\n\t\t\t\tdabt_reg  <= dabt_reg || i_dabt;\n\t\t\tend\n\t\t\tdabt_reg_d1  <= dabt_reg;\n\t\tend\n\tend\nend\n\nassign dabt = dabt_reg || i_dabt;\n\n\n\n\n\n\n\n`include \"../include/debug_functions.vh\"\n\na25_decompile  u_decompile (\n    .clk                      ( clk                            ),\n    .reset                    ( reset                          ),\n    .scan_enable              ( scan_enable                    ),\n    .test_mode                ( test_mode                      ),\n\n    .i_core_stall               ( i_core_stall                     ),\n    .i_instruction              ( instruction                      ),\n    .i_instruction_valid        ( instruction_valid &&!conflict    ),\n    .i_instruction_execute      ( instruction_execute              ),\n    .i_instruction_address      ( instruction_address              ),\n    .i_interrupt                ( {3{interrupt}} & next_interrupt  ),\n    .i_interrupt_state          ( control_state == INT_WAIT2       ),\n    .i_instruction_undefined    ( und_request                      ),\n    .i_pc_sel                   ( pc_sel_r                         ),\n    .i_pc_wen                   ( pc_wen_r                         ));\n\n\nwire    [(15*8)-1:0]    xCONTROL_STATE;\nwire    [(15*8)-1:0]    xMODE;\nwire    [( 8*8)-1:0]    xTYPE;\n\nassign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_ABORT   ? \"MTRANS_ABORT\"   :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;\n\nassign xMODE  = mode_name ( status_bits_mode_r );\n\nassign xTYPE  =\n                               type == REGOP    ? \"REGOP\"    :\n                               type == MULT     ? \"MULT\"     :\n                               type == SWAP     ? \"SWAP\"     :\n                               type == TRANS    ? \"TRANS\"    :\n                               type == MTRANS   ? \"MTRANS\"   :\n                               type == BRANCH   ? \"BRANCH\"   :\n                               type == CODTRANS ? \"CODTRANS\" :\n                               type == COREGOP  ? \"COREGOP\"  :\n                               type == CORTRANS ? \"CORTRANS\" :\n                               type == SWI      ? \"SWI\"      :\n                                                  \"UNKNOWN\"  ;\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\n\tend else begin\n\t    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n\t\t  begin\n\t\t  `TB_ERROR_MESSAGE\n\t\t  $display(\"Instruction with x's =%08h\", instruction);\n\t\t  end\n\tend\nend\n\n\nendmodule\n\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: a25_decode. Module specification: This module is responsible for decoding ARM instructions in an ARM25 processor implementation. It takes inputs such as clock, reset, fetched instruction, core status, and interrupt signals, and generates control signals for other parts of the processor. The module handles different instruction types, manages the processor's control state, and handles interrupts and exceptions. Key input ports include clk, reset, i_fetch_instruction, i_core_stall, i_irq, i_firq, and i_execute_status_bits. Output ports include o_imm32, o_condition, o_decode_daccess, o_rm_sel, o_alu_function, o_reg_bank_wen, and o_copro_operation. Internal signals are used for instruction decoding, control state management, register selection, ALU control, and interrupt handling. The module is structured into"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: a25_decode\n\nExplanation: This module is responsible for decoding ARM instructions in an ARM25 processor implementation. It takes various inputs such as the fetched instruction, core status, and interrupt signals, and generates control signals for other parts of the processor. The module handles different instruction types, manages the processor's control state, and handles interrupts and exceptions. It also generates outputs for register selection, ALU operations, memory access, and coprocessor interactions. The module implements the complex instruction decoding logic required for executing ARM instructions, including handling of different addressing modes, conditional execution, and various instruction formats."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nclk, reset, scan_enable, test_mode, i_fetch_instruction, i_core_stall, i_irq, i_firq, i_dabt, i_iabt, i_adex, i_execute_iaddress, i_execute_daddress, i_abt_status, i_execute_status_bits, i_multiply_done.\n\nExplanation:\nThese inputs include clock and reset signals, test-related signals, fetched instruction, core stall signal, interrupt requests, abort signals, execution addresses, abort status, execution status bits, and a signal indicating multiplication completion.\n\nOutput ports:\no_imm32, o_imm_shift_amount, o_shift_imm_zero, o_condition, o_decode_exclusive, o_decode_iaccess, o_decode_daccess, o_status_bits_mode, o_status_bits_irq_mask, o_status_bits_firq_mask, o_rm_sel, o_rs_sel, o_load_rd, o_rn_sel, o_barrel_shift_amount_sel, o_barrel_shift_data_sel, o_barrel_shift_function, o_alu_function, o_multiply_function, o_interrupt_vector_sel, o_iaddress_sel, o_daddress_sel, o_pc_sel, o_byte_enable_sel, o_status_bits_sel, o_reg_write_sel, o_user_mode_regs_store_nxt, o_firq_not_user_mode, o_use_carry_in, o_write_data_wen, o_base_address_wen, o_pc_wen, o_reg_bank_wen, o_status_bits_flags_wen, o_status_bits_mode_wen, o_status_bits_irq_mask_wen, o_status_bits_firq_mask_wen, o_copro_opcode1, o_copro_opcode2, o_copro_crn, o_copro_crm, o_copro_num, o_copro_operation, o_copro_write_data_wen, o_iabt_trigger, o_iabt_address, o_iabt_status, o_dabt_trigger, o_dabt_address, o_dabt_status, o_conflict, o_rn_use_read, o_rm_use_read, o_rs_use_read, o_rd_use_read.\n\nExplanation:\nThese outputs provide control signals for various parts of the processor, including immediate values, shift amounts, condition flags, register selection, ALU and barrel shifter control, memory access control, status bits control, coprocessor operation control, and abort handling signals. They are used to guide the execution of instructions and manage the processor's state."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\ninstruction, type, instruction_iabt, instruction_adex, instruction_address, instruction_iabt_status, instruction_sel, opcode, imm8, offset12, offset24, shift_imm, opcode_compare, mem_op, load_op, store_op, write_pc, current_write_pc, load_pc_nxt, load_pc_r, immediate_shift_op, rds_use_rs, branch, mem_op_pre_indexed, mem_op_post_indexed, imm32_nxt, imm_shift_amount_nxt, shift_imm_zero_nxt, condition_nxt, decode_exclusive_nxt, decode_iaccess_nxt, decode_daccess_nxt, shift_extend, barrel_shift_function_nxt, alu_function_nxt, multiply_function_nxt, status_bits_mode_nxt, status_bits_irq_mask_nxt, status_bits_firq_mask_nxt, rm_sel_nxt, rs_sel_nxt, rn_sel_nxt, barrel_shift_amount_sel_nxt, barrel_shift_data_sel_nxt, iaddress_sel_nxt, daddress_sel_nxt, pc_sel_nxt, byte_enable_sel_nxt, status_bits_sel_nxt, reg_write_sel_nxt, firq_not_user_mode_nxt, use_carry_in_nxt, alu_swap_sel_nxt, alu_not_sel_nxt, alu_cin_sel_nxt, alu_cout_sel_nxt, alu_out_sel_nxt, write_data_wen_nxt, copro_write_data_wen_nxt, base_address_wen_nxt, pc_wen_nxt, reg_bank_wen_nxt, status_bits_flags_wen_nxt, status_bits_mode_wen_nxt, status_bits_irq_mask_wen_nxt, status_bits_firq_mask_wen_nxt, control_state, control_state_nxt, dabt, dabt_reg, dabt_reg_d1, iabt_reg, adex_reg, fetch_address_r, abt_status_reg, fetch_instruction_r, fetch_instruction_type_r, saved_current_instruction, saved_current_instruction_type, saved_current_instruction_iabt, saved_current_instruction_adex, saved_current_instruction_address, saved_current_instruction_iabt_status, pre_fetch_instruction, pre_fetch_instruction_type, pre_fetch_instruction_iabt, pre_fetch_instruction_adex, pre_fetch_instruction_address, pre_fetch_instruction_iabt_status, hold_instruction, hold_instruction_type, hold_instruction_iabt, hold_instruction_adex, hold_instruction_address, hold_instruction_iabt_status, instruction_valid, instruction_execute, instruction_execute_r, mtrans_reg1, mtrans_reg2, mtrans_instruction_nxt, mtrans_reg2_mask, mtrans_base_reg_change, mtrans_num_registers, use_saved_current_instruction, use_hold_instruction, use_pre_fetch_instruction, interrupt, interrupt_or_conflict, interrupt_mode, next_interrupt, irq, firq, firq_request, irq_request, swi_request, und_request, dabt_request, copro_operation_nxt, restore_base_address, restore_base_address_nxt, regop_set_flags, load_rd_nxt, load_rd_byte, ldm_user_mode, ldm_status_bits, ldm_flags, load_rd_d1_nxt, load_rd_d1, rn_valid, rm_valid, rs_valid, rd_valid, stm_valid, rn_conflict1, rn_conflict2, rm_conflict1, rm_conflict2, rs_conflict1, rs_conflict2, rd_conflict1, rd_conflict2, stm_conflict1a, stm_conflict1b, stm_conflict2a, stm_conflict2b, conflict1, conflict2, conflict, conflict_r, rn_conflict1_r, rm_conflict1_r, rs_conflict1_r, rd_conflict1_r.\n\nExplanation:\nThese internal signals serve various purposes in the module, including:\n1. Instruction decoding (e.g., instruction, type, opcode)\n2. Control state management (e.g., control_state, control_state_nxt)\n3. Memory operation handling (e.g., mem_op, load_op, store_op)\n4. Register selection and conflict detection (e.g., rm_sel_nxt, rs_sel_nxt, rn_conflict1)\n5. ALU and barrel shifter control (e.g., alu_function_nxt, barrel_shift_function_nxt)\n6. Interrupt and exception handling (e.g., interrupt, next_interrupt, dabt_reg)\n7. Instruction pipeline management (e.g., saved_current_instruction, pre_fetch_instruction)\n8. Status bits and mode control (e.g., status_bits_mode_nxt, firq_not_user_mode_nxt)\n9. Memory access control (e.g., decode_daccess_nxt, byte_enable_sel_nxt)\n10. Coprocessor operation control (e.g., copro_operation_nxt)\n\nThese signals work together to implement the complex instruction decoding and execution control logic required for the ARM25 processor."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"../include/global_defines.vh\"\n\nmodule a25_decode\n(\ninput                       clk,\ninput                       reset,\ninput                       scan_enable,\ninput                       test_mode,\n\ninput       [31:0]          i_fetch_instruction,\ninput                       i_core_stall,                   \ninput                       i_irq,                          \ninput                       i_firq,                         \ninput                       i_dabt,                         \ninput                       i_iabt,                         \ninput                       i_adex,                         \ninput       [31:0]          i_execute_iaddress,             \ninput       [31:0]          i_execute_daddress,             \ninput       [7:0]           i_abt_status,                   \ninput       [31:0]          i_execute_status_bits,          \ninput                       i_multiply_done,                \n\n\n\n\n\noutput reg  [31:0]          o_imm32,\noutput reg  [4:0]           o_imm_shift_amount,\noutput reg                  o_shift_imm_zero,\noutput wire [3:0]           o_condition,\noutput reg                  o_decode_exclusive,       \noutput wire                 o_decode_iaccess,               \noutput reg                  o_decode_daccess,         \noutput wire [1:0]           o_status_bits_mode,\noutput wire                 o_status_bits_irq_mask,\noutput wire                 o_status_bits_firq_mask,\n\noutput reg  [3:0]           o_rm_sel,\noutput reg  [3:0]           o_rs_sel,\noutput reg  [7:0]           o_load_rd,                      \n                                                            \n                                                            \n                                                            \n                                                            \noutput reg  [3:0]           o_rn_sel,\noutput reg  [1:0]           o_barrel_shift_amount_sel,\noutput reg  [1:0]           o_barrel_shift_data_sel,\noutput reg  [1:0]           o_barrel_shift_function,\noutput reg  [8:0]           o_alu_function,\noutput reg  [1:0]           o_multiply_function,\noutput reg  [2:0]           o_interrupt_vector_sel,\noutput wire [3:0]           o_iaddress_sel,\noutput wire [3:0]           o_daddress_sel,\noutput wire [2:0]           o_pc_sel,\noutput reg  [1:0]           o_byte_enable_sel,        \noutput reg  [2:0]           o_status_bits_sel,\noutput reg  [2:0]           o_reg_write_sel,\noutput reg                  o_user_mode_regs_store_nxt,\noutput reg                  o_firq_not_user_mode,\noutput reg                  o_use_carry_in,\n\noutput reg                  o_write_data_wen,\noutput reg                  o_base_address_wen,       \n                                                            \noutput wire                 o_pc_wen,\noutput reg  [14:0]          o_reg_bank_wen,\noutput reg                  o_status_bits_flags_wen,\noutput reg                  o_status_bits_mode_wen,\noutput reg                  o_status_bits_irq_mask_wen,\noutput reg                  o_status_bits_firq_mask_wen,\n\n\n\n\noutput reg  [2:0]           o_copro_opcode1,\noutput reg  [2:0]           o_copro_opcode2,\noutput reg  [3:0]           o_copro_crn,\noutput reg  [3:0]           o_copro_crm,\noutput reg  [3:0]           o_copro_num,\noutput reg  [1:0]           o_copro_operation, \n                                                     \n                                                     \noutput reg                  o_copro_write_data_wen,\noutput                      o_iabt_trigger,\noutput      [31:0]          o_iabt_address,\noutput      [7:0]           o_iabt_status,\noutput                      o_dabt_trigger,\noutput      [31:0]          o_dabt_address,\noutput      [7:0]           o_dabt_status,\noutput                      o_conflict,\noutput reg                  o_rn_use_read,\noutput reg                  o_rm_use_read,\noutput reg                  o_rs_use_read,\noutput reg                  o_rd_use_read\n\n);\n\n`include \"../include/a25_localparams.vh\"\n`include \"../include/a25_functions.vh\"\n\nlocalparam [4:0] RST_WAIT1      = 5'd0,\n                 RST_WAIT2      = 5'd1,\n                 INT_WAIT1      = 5'd2,\n                 INT_WAIT2      = 5'd3,\n                 EXECUTE        = 5'd4,\n                 PRE_FETCH_EXEC = 5'd5,  \n                 MEM_WAIT1      = 5'd6,  \n                                         \n                 MEM_WAIT2      = 5'd7,\n                 PC_STALL1      = 5'd8,  \n                                         \n                                         \n                 PC_STALL2      = 5'd9,\n                 MTRANS_EXEC1   = 5'd10,\n                 MTRANS_EXEC2   = 5'd11,\n                 MTRANS_ABORT   = 5'd12,\n                 MULT_PROC1     = 5'd13,  \n                 MULT_PROC2     = 5'd14,  \n                 MULT_STORE     = 5'd15,  \n                 MULT_ACCUMU    = 5'd16,  \n                 SWAP_WRITE     = 5'd17,\n                 SWAP_WAIT1     = 5'd18,\n                 SWAP_WAIT2     = 5'd19,\n                 COPRO_WAIT     = 5'd20;\n\n\n\n\n\n\nwire    [31:0]         instruction;\nwire    [3:0]          type;                    \nwire                   instruction_iabt;        \nwire                   instruction_adex;        \nwire    [31:0]         instruction_address;     \n                                                \nwire    [7:0]          instruction_iabt_status; \nwire    [1:0]          instruction_sel;\nwire    [3:0]          opcode;\nwire    [7:0]          imm8;\nwire    [31:0]         offset12;\nwire    [31:0]         offset24;\nwire    [4:0]          shift_imm;\n\nwire                   opcode_compare;\nwire                   mem_op;\nwire                   load_op;\nwire                   store_op;\nwire                   write_pc;\nwire                   current_write_pc;\nreg                    load_pc_nxt;\nreg                    load_pc_r;\nwire                   immediate_shift_op;\nwire                   rds_use_rs;\nwire                   branch;\nwire                   mem_op_pre_indexed;\nwire                   mem_op_post_indexed;\n\n\nwire    [31:0]         imm32_nxt;\nwire    [4:0]          imm_shift_amount_nxt;\nwire                   shift_imm_zero_nxt;\nwire    [3:0]          condition_nxt;\nreg                    decode_exclusive_nxt;\nreg                    decode_iaccess_nxt;\nreg                    decode_daccess_nxt;\nwire                   shift_extend;\n\nreg     [1:0]          barrel_shift_function_nxt;\nwire    [8:0]          alu_function_nxt;\nreg     [1:0]          multiply_function_nxt;\nreg     [1:0]          status_bits_mode_nxt;\nreg                    status_bits_irq_mask_nxt;\nreg                    status_bits_firq_mask_nxt;\n\nwire    [3:0]          rm_sel_nxt;\nwire    [3:0]          rs_sel_nxt;\n\nwire    [3:0]          rn_sel_nxt;\nreg     [1:0]          barrel_shift_amount_sel_nxt;\nreg     [1:0]          barrel_shift_data_sel_nxt;\nreg     [3:0]          iaddress_sel_nxt;\nreg     [3:0]          daddress_sel_nxt;\nreg     [2:0]          pc_sel_nxt;\nreg     [1:0]          byte_enable_sel_nxt;\nreg     [2:0]          status_bits_sel_nxt;\nreg     [2:0]          reg_write_sel_nxt;\nwire                   firq_not_user_mode_nxt;\nreg                    use_carry_in_nxt;\n\n\nreg                    alu_swap_sel_nxt;\nreg                    alu_not_sel_nxt;\nreg     [1:0]          alu_cin_sel_nxt;\nreg                    alu_cout_sel_nxt;\nreg     [3:0]          alu_out_sel_nxt;\n\nreg                    write_data_wen_nxt;\nreg                    copro_write_data_wen_nxt;\nreg                    base_address_wen_nxt;\nreg                    pc_wen_nxt;\nreg     [14:0]         reg_bank_wen_nxt;\nreg                    status_bits_flags_wen_nxt;\nreg                    status_bits_mode_wen_nxt;\nreg                    status_bits_irq_mask_wen_nxt;\nreg                    status_bits_firq_mask_wen_nxt;\n\nreg                    saved_current_instruction_wen;   \nreg                    pre_fetch_instruction_wen;       \n\nreg     [4:0]          control_state;\nreg     [4:0]          control_state_nxt;\n\n\nwire                   dabt;\nreg                    dabt_reg;\nreg                    dabt_reg_d1;\nreg                    iabt_reg;\nreg                    adex_reg;\nreg     [31:0]         fetch_address_r;\nreg     [7:0]          abt_status_reg;\nreg     [31:0]         fetch_instruction_r;\nreg     [3:0]          fetch_instruction_type_r;\nreg     [31:0]         saved_current_instruction;\nreg     [3:0]          saved_current_instruction_type;\nreg                    saved_current_instruction_iabt;          \nreg                    saved_current_instruction_adex;          \nreg     [31:0]         saved_current_instruction_address;       \nreg     [7:0]          saved_current_instruction_iabt_status;   \nreg     [31:0]         pre_fetch_instruction;\nreg     [3:0]          pre_fetch_instruction_type;\nreg                    pre_fetch_instruction_iabt;              \nreg                    pre_fetch_instruction_adex;              \nreg     [31:0]         pre_fetch_instruction_address;           \nreg     [7:0]          pre_fetch_instruction_iabt_status;       \nreg     [31:0]         hold_instruction;\nreg     [3:0]          hold_instruction_type;\nreg                    hold_instruction_iabt;                   \nreg                    hold_instruction_adex;                   \nreg     [31:0]         hold_instruction_address;                \nreg     [7:0]          hold_instruction_iabt_status;            \n\nwire                   instruction_valid;\nwire                   instruction_execute;\nreg                    instruction_execute_r;\n\nreg     [3:0]          mtrans_reg1;             \nreg     [3:0]          mtrans_reg2;             \nreg     [31:0]         mtrans_instruction_nxt;\nwire    [15:0]         mtrans_reg2_mask;\n\nwire   [31:0]          mtrans_base_reg_change;\nwire   [4:0]           mtrans_num_registers;\nwire                   use_saved_current_instruction;\nwire                   use_hold_instruction;\nwire                   use_pre_fetch_instruction;\nwire                   interrupt;\nwire                   interrupt_or_conflict;\nwire   [1:0]           interrupt_mode;\nwire   [2:0]           next_interrupt;\nreg                    irq;\nreg                    firq;\nwire                   firq_request;\nwire                   irq_request;\nwire                   swi_request;\nwire                   und_request;\nwire                   dabt_request;\nreg    [1:0]           copro_operation_nxt;\nreg                    restore_base_address;\nreg                    restore_base_address_nxt;\n\nwire                   regop_set_flags;\n\nwire    [7:0]          load_rd_nxt;\nwire                   load_rd_byte;\nwire                   ldm_user_mode;\nwire                   ldm_status_bits;\nwire                   ldm_flags;\nwire    [6:0]          load_rd_d1_nxt;\nreg     [6:0]          load_rd_d1;  \n\nwire                   rn_valid;\nwire                   rm_valid;\nwire                   rs_valid;\nwire                   rd_valid;\nwire                   stm_valid;\nwire                   rn_conflict1;\nwire                   rn_conflict2;\nwire                   rm_conflict1;\nwire                   rm_conflict2;\nwire                   rs_conflict1;\nwire                   rs_conflict2;\nwire                   rd_conflict1;\nwire                   rd_conflict2;\nwire                   stm_conflict1a;\nwire                   stm_conflict1b;\nwire                   stm_conflict2a;\nwire                   stm_conflict2b;\nwire                   conflict1;          \nwire                   conflict2;          \nwire                   conflict;           \nreg                    conflict_r;\nreg                    rn_conflict1_r;\nreg                    rm_conflict1_r;\nreg                    rs_conflict1_r;\nreg                    rd_conflict1_r;\n\n\n\n\nreg  [3:0]           condition_r;             \nreg                  decode_iaccess_r;        \nreg  [1:0]           status_bits_mode_r;     \nreg                  status_bits_irq_mask_r;\nreg                  status_bits_firq_mask_r;\nreg [3:0]            iaddress_sel_r;\nreg [3:0]            daddress_sel_r;\nreg [2:0]            pc_sel_r;\nreg                  pc_wen_r;\n\n\nassign o_condition                 = condition_r;\nassign o_decode_iaccess            = decode_iaccess_r;\nassign o_status_bits_mode          = status_bits_mode_r;\nassign o_status_bits_irq_mask      = status_bits_irq_mask_r;\nassign o_status_bits_firq_mask     = status_bits_firq_mask_r;\nassign o_iaddress_sel              = iaddress_sel_r;\nassign o_daddress_sel              = daddress_sel_r;\nassign o_pc_sel                    = pc_sel_r;\nassign o_pc_wen                    = pc_wen_r;\n\n\n\n\n\n\n\nassign o_iabt_trigger     = instruction_iabt && status_bits_mode_r == SVC && control_state == INT_WAIT1;\nassign o_iabt_address     = instruction_address;\nassign o_iabt_status      = instruction_iabt_status;\n\nassign o_dabt_trigger     = dabt_reg && !dabt_reg_d1;\nassign o_dabt_address     = fetch_address_r;\nassign o_dabt_status      = abt_status_reg;\n\n\n\n\n\n\n\n\n\n\n\n\n\nassign use_saved_current_instruction = instruction_execute &&\n                          ( control_state == MEM_WAIT1     ||\n                            control_state == MEM_WAIT2     ||\n                            control_state == MTRANS_EXEC1  ||\n                            control_state == MTRANS_EXEC2  ||\n                            control_state == MTRANS_ABORT  ||\n                            control_state == MULT_PROC1    ||\n                            control_state == MULT_PROC2    ||\n                            control_state == MULT_ACCUMU   ||\n                            control_state == MULT_STORE    ||\n                            control_state == INT_WAIT1     ||\n                            control_state == INT_WAIT2     ||\n                            control_state == SWAP_WRITE    ||\n                            control_state == SWAP_WAIT1    ||\n                            control_state == SWAP_WAIT2    ||\n                            control_state == COPRO_WAIT     );\n\nassign use_hold_instruction = conflict_r;\n\nassign use_pre_fetch_instruction = control_state == PRE_FETCH_EXEC;\n\n\nassign instruction_sel  =         use_hold_instruction           ? 2'd3 :  \n                                  use_saved_current_instruction  ? 2'd1 :  \n                                  use_pre_fetch_instruction      ? 2'd2 :  \n                                                                   2'd0 ;  \n\nassign instruction      =         instruction_sel == 2'd0 ? fetch_instruction_r       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction :\n                                  instruction_sel == 2'd3 ? hold_instruction          :\n                                                            pre_fetch_instruction     ;\n\nassign type             =         instruction_sel == 2'd0 ? fetch_instruction_type_r       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_type :\n                                  instruction_sel == 2'd3 ? hold_instruction_type          :\n                                                            pre_fetch_instruction_type     ;\n\n\nassign instruction_iabt =         instruction_sel == 2'd0 ? iabt_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt :\n                                  instruction_sel == 2'd3 ? hold_instruction_iabt          :\n                                                            pre_fetch_instruction_iabt     ;\n\nassign instruction_address =      instruction_sel == 2'd0 ? fetch_address_r                   :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_address :\n                                  instruction_sel == 2'd3 ? hold_instruction_address          :\n                                                            pre_fetch_instruction_address     ;\n\nassign instruction_iabt_status =  instruction_sel == 2'd0 ? abt_status_reg                        :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_iabt_status :\n                                  instruction_sel == 2'd3 ? hold_instruction_iabt_status          :\n                                                            pre_fetch_instruction_iabt_status     ;\n\n\nassign instruction_adex =         instruction_sel == 2'd0 ? adex_reg                       :\n                                  instruction_sel == 2'd1 ? saved_current_instruction_adex :\n                                  instruction_sel == 2'd3 ? hold_instruction_adex          :\n                                                            pre_fetch_instruction_adex     ;\n\n\n\n\n\n\nassign opcode               = instruction[24:21];\nassign condition_nxt        = instruction[31:28];\n\nassign rm_sel_nxt           = instruction[3:0];\nassign rn_sel_nxt           = branch ? 4'd15 : instruction[19:16]; \nassign rs_sel_nxt           = control_state == SWAP_WRITE  ? instruction[3:0]   : \n                              type == MTRANS               ? mtrans_reg1         :\n                              branch                       ? 4'd15              : \n                              rds_use_rs                   ? instruction[11:8]  :\n                                                             instruction[15:12] ;\n\n\nassign ldm_user_mode        = type == MTRANS && {instruction[22],instruction[20],instruction[15]} == 3'b110;\nassign ldm_flags            = type == MTRANS && rs_sel_nxt == 4'd15 && instruction[20] && instruction[22];\nassign ldm_status_bits      = type == MTRANS && rs_sel_nxt == 4'd15 && instruction[20] && instruction[22] && i_execute_status_bits[1:0] != USR;\nassign load_rd_byte         = (type == TRANS || type == SWAP) && instruction[22];\nassign load_rd_nxt          = {ldm_flags, ldm_status_bits, ldm_user_mode, load_rd_byte, rs_sel_nxt};\n\n\nassign shift_extend         = !instruction[25] && !instruction[4] && !(|instruction[11:7]) && instruction[6:5] == 2'b11;\n\n                            \nassign load_rd_d1_nxt       = {o_decode_daccess && !o_write_data_wen, o_load_rd[3:0]};\nassign shift_imm            = instruction[11:7];\nassign offset12             = { 20'h0, instruction[11:0]};\nassign offset24             = {{6{instruction[23]}}, instruction[23:0], 2'd0 }; \nassign imm8                 = instruction[7:0];\n\nassign immediate_shift_op   = instruction[25];\nassign rds_use_rs           = (type == REGOP && !instruction[25] && instruction[4]) ||\n                              (type == MULT &&\n                               (control_state == MULT_PROC1  ||\n                                control_state == MULT_PROC2  ||\n\n\n\n                                (instruction_valid && !interrupt_or_conflict))) ;\n\n\nassign branch               = type == BRANCH;\nassign opcode_compare       = opcode == CMP || opcode == CMN || opcode == TEQ || opcode == TST ;\nassign mem_op               = type == TRANS;\nassign load_op              = mem_op && instruction[20];\nassign store_op             = mem_op && !instruction[20];\nassign write_pc             = (pc_wen_nxt && pc_sel_nxt != 3'd0) || load_pc_r || load_pc_nxt;\nassign current_write_pc     = (pc_wen_nxt && pc_sel_nxt != 3'd0) || load_pc_nxt;\nassign regop_set_flags      = type == REGOP && instruction[20];\n\nassign mem_op_pre_indexed   =  instruction[24] && instruction[21];\nassign mem_op_post_indexed  = !instruction[24];\n\nassign imm32_nxt            =  \n                               type == MULT               ? {  32'd0                      } :\n\n                               \n                               type == MTRANS             ? {  mtrans_base_reg_change     } :\n                               type == BRANCH             ? {  offset24                   } :\n                               type == TRANS              ? {  offset12                   } :\n                               instruction[11:8] == 4'h0  ? {            24'h0, imm8[7:0] } :\n                               instruction[11:8] == 4'h1  ? { imm8[1:0], 24'h0, imm8[7:2] } :\n                               instruction[11:8] == 4'h2  ? { imm8[3:0], 24'h0, imm8[7:4] } :\n                               instruction[11:8] == 4'h3  ? { imm8[5:0], 24'h0, imm8[7:6] } :\n                               instruction[11:8] == 4'h4  ? { imm8[7:0], 24'h0            } :\n                               instruction[11:8] == 4'h5  ? { 2'h0,  imm8[7:0], 22'h0     } :\n                               instruction[11:8] == 4'h6  ? { 4'h0,  imm8[7:0], 20'h0     } :\n                               instruction[11:8] == 4'h7  ? { 6'h0,  imm8[7:0], 18'h0     } :\n                               instruction[11:8] == 4'h8  ? { 8'h0,  imm8[7:0], 16'h0     } :\n                               instruction[11:8] == 4'h9  ? { 10'h0, imm8[7:0], 14'h0     } :\n                               instruction[11:8] == 4'ha  ? { 12'h0, imm8[7:0], 12'h0     } :\n                               instruction[11:8] == 4'hb  ? { 14'h0, imm8[7:0], 10'h0     } :\n                               instruction[11:8] == 4'hc  ? { 16'h0, imm8[7:0], 8'h0      } :\n                               instruction[11:8] == 4'hd  ? { 18'h0, imm8[7:0], 6'h0      } :\n                               instruction[11:8] == 4'he  ? { 20'h0, imm8[7:0], 4'h0      } :\n                                                            { 22'h0, imm8[7:0], 2'h0      } ;\n\n\nassign imm_shift_amount_nxt = shift_imm ;\n\n       \n       \nassign shift_imm_zero_nxt   = imm_shift_amount_nxt == 5'd0 &&       \n                              barrel_shift_amount_sel_nxt == 2'd2;  \n\nassign alu_function_nxt     = { alu_swap_sel_nxt,\n                                alu_not_sel_nxt,\n                                alu_cin_sel_nxt,\n                                alu_cout_sel_nxt,\n                                alu_out_sel_nxt  };\n\n\n\n\nassign rn_valid       = type == REGOP || type == MULT || type == SWAP || type == TRANS || type == MTRANS || type == CODTRANS;\nassign rm_valid       = type == REGOP || type == MULT || type == SWAP || (type == TRANS && immediate_shift_op);\nassign rs_valid       = rds_use_rs;\nassign rd_valid       = (type == TRANS  && store_op) || (type == REGOP || type == SWAP);\nassign stm_valid      = type == MTRANS && !instruction[20];   \n\n\nassign rn_conflict1   = instruction_execute   && rn_valid  && ( load_rd_d1_nxt[4] && rn_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rn_conflict2   = instruction_execute_r && rn_valid  && ( load_rd_d1    [4] && rn_sel_nxt         == load_rd_d1    [3:0] );\nassign rm_conflict1   = instruction_execute   && rm_valid  && ( load_rd_d1_nxt[4] && rm_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rm_conflict2   = instruction_execute_r && rm_valid  && ( load_rd_d1    [4] && rm_sel_nxt         == load_rd_d1    [3:0] );\nassign rs_conflict1   = instruction_execute   && rs_valid  && ( load_rd_d1_nxt[4] && rs_sel_nxt         == load_rd_d1_nxt[3:0] );\nassign rs_conflict2   = instruction_execute_r && rs_valid  && ( load_rd_d1    [4] && rs_sel_nxt         == load_rd_d1    [3:0] );\nassign rd_conflict1   = instruction_execute   && rd_valid  && ( load_rd_d1_nxt[4] && instruction[15:12] == load_rd_d1_nxt[3:0] );\nassign rd_conflict2   = instruction_execute_r && rd_valid  && ( load_rd_d1    [4] && instruction[15:12] == load_rd_d1    [3:0] );\n\nassign stm_conflict1a = instruction_execute   && stm_valid && ( load_rd_d1_nxt[4] && mtrans_reg1        == load_rd_d1_nxt[3:0] );\nassign stm_conflict1b = instruction_execute   && stm_valid && ( load_rd_d1_nxt[4] && mtrans_reg2        == load_rd_d1_nxt[3:0] );\nassign stm_conflict2a = instruction_execute_r && stm_valid && ( load_rd_d1    [4] && mtrans_reg1        == load_rd_d1    [3:0] );\nassign stm_conflict2b = instruction_execute_r && stm_valid && ( load_rd_d1    [4] && mtrans_reg2        == load_rd_d1    [3:0] );\n\nassign conflict1      = instruction_valid &&\n                        (rn_conflict1 || rm_conflict1 || rs_conflict1 || rd_conflict1 ||\n                         stm_conflict1a || stm_conflict1b);\n\nassign conflict2      = instruction_valid && (stm_conflict2a || stm_conflict2b);\n\nassign conflict       = conflict1 || conflict2;\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tconflict_r              <= 'd0;\n\t\tinstruction_execute_r   <= 'd0;\n\t\trn_conflict1_r          <= 'd0;\n\t\trm_conflict1_r          <= 'd0;\n\t\trs_conflict1_r          <= 'd0;\n\t\trd_conflict1_r          <= 'd0;\n\t\to_rn_use_read           <= 'd0;\n\t\to_rm_use_read           <= 'd0;\n\t\to_rs_use_read           <= 'd0;\n\t\to_rd_use_read           <= 'd0;\n\tend else if ( !i_core_stall ) begin\n\t\tconflict_r              <= conflict;\n\t\tinstruction_execute_r   <= instruction_execute;\n\t\trn_conflict1_r          <= rn_conflict1 && instruction_execute;\n\t\trm_conflict1_r          <= rm_conflict1 && instruction_execute;\n\t\trs_conflict1_r          <= rs_conflict1 && instruction_execute;\n\t\trd_conflict1_r          <= rd_conflict1 && instruction_execute;\n\t\to_rn_use_read           <= instruction_valid && ( rn_conflict1_r || rn_conflict2 );\n\t\to_rm_use_read           <= instruction_valid && ( rm_conflict1_r || rm_conflict2 );\n\t\to_rs_use_read           <= instruction_valid && ( rs_conflict1_r || rs_conflict2 );\n\t\to_rd_use_read           <= instruction_valid && ( rd_conflict1_r || rd_conflict2 );\n\tend\nend\n\nassign o_conflict = conflict;\n\n\n\n\n\n\n   \n   \n   \nalways @*\n    casez ( instruction[15:0] )\n    16'b???????????????1 : mtrans_reg1 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg1 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg1 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg1 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg1 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg1 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg1 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg1 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg1 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg1 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg1 = 4'ha ;\n    16'b????100000000000 : mtrans_reg1 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg1 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg1 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg1 = 4'he ;\n    default              : mtrans_reg1 = 4'hf ;\n    endcase\n\n\nassign mtrans_reg2_mask = 1'd1<<mtrans_reg1;\n\nalways @*\n    casez ( instruction[15:0] & ~mtrans_reg2_mask )\n    16'b???????????????1 : mtrans_reg2 = 4'h0 ;\n    16'b??????????????10 : mtrans_reg2 = 4'h1 ;\n    16'b?????????????100 : mtrans_reg2 = 4'h2 ;\n    16'b????????????1000 : mtrans_reg2 = 4'h3 ;\n    16'b???????????10000 : mtrans_reg2 = 4'h4 ;\n    16'b??????????100000 : mtrans_reg2 = 4'h5 ;\n    16'b?????????1000000 : mtrans_reg2 = 4'h6 ;\n    16'b????????10000000 : mtrans_reg2 = 4'h7 ;\n    16'b???????100000000 : mtrans_reg2 = 4'h8 ;\n    16'b??????1000000000 : mtrans_reg2 = 4'h9 ;\n    16'b?????10000000000 : mtrans_reg2 = 4'ha ;\n    16'b????100000000000 : mtrans_reg2 = 4'hb ;\n    16'b???1000000000000 : mtrans_reg2 = 4'hc ;\n    16'b??10000000000000 : mtrans_reg2 = 4'hd ;\n    16'b?100000000000000 : mtrans_reg2 = 4'he ;\n    default              : mtrans_reg2 = 4'hf ;\n    endcase\n\nalways @*\n    casez (instruction[15:0])\n    16'b???????????????1 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 1],  1'd0};\n    16'b??????????????10 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 2],  2'd0};\n    16'b?????????????100 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 3],  3'd0};\n    16'b????????????1000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 4],  4'd0};\n    16'b???????????10000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 5],  5'd0};\n    16'b??????????100000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 6],  6'd0};\n    16'b?????????1000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 7],  7'd0};\n    16'b????????10000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 8],  8'd0};\n    16'b???????100000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15: 9],  9'd0};\n    16'b??????1000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:10], 10'd0};\n    16'b?????10000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:11], 11'd0};\n    16'b????100000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:12], 12'd0};\n    16'b???1000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:13], 13'd0};\n    16'b??10000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15:14], 14'd0};\n    16'b?100000000000000 : mtrans_instruction_nxt = {instruction[31:16], instruction[15   ], 15'd0};\n    default              : mtrans_instruction_nxt = {instruction[31:16],                     16'd0};\n    endcase\n\n\n\nassign mtrans_num_registers =   {4'd0, instruction[15]} +\n                                {4'd0, instruction[14]} +\n                                {4'd0, instruction[13]} +\n                                {4'd0, instruction[12]} +\n                                {4'd0, instruction[11]} +\n                                {4'd0, instruction[10]} +\n                                {4'd0, instruction[ 9]} +\n                                {4'd0, instruction[ 8]} +\n                                {4'd0, instruction[ 7]} +\n                                {4'd0, instruction[ 6]} +\n                                {4'd0, instruction[ 5]} +\n                                {4'd0, instruction[ 4]} +\n                                {4'd0, instruction[ 3]} +\n                                {4'd0, instruction[ 2]} +\n                                {4'd0, instruction[ 1]} +\n                                {4'd0, instruction[ 0]} ;\n\n\nassign mtrans_base_reg_change = {25'd0, mtrans_num_registers, 2'd0};\n\n\n\n\n\nassign firq_request = firq && !i_execute_status_bits[26];\nassign irq_request  = irq  && !i_execute_status_bits[27];\nassign swi_request  = type == SWI;\nassign dabt_request = dabt_reg;\n\n\n\n\nassign und_request  =   type == CODTRANS ||\n                        type == COREGOP  ||\n                      ( type == CORTRANS && instruction[11:8] != 4'd15 );\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \nassign next_interrupt = dabt_request     ? 3'd1 :  \n                        firq_request     ? 3'd2 :  \n                        irq_request      ? 3'd3 :  \n                        instruction_adex ? 3'd4 :  \n                        instruction_iabt ? 3'd5 :  \n                                                   \n                        und_request      ? 3'd6 :  \n                        swi_request      ? 3'd7 :  \n                                           3'd0 ;  \n\n\n\n\n\nassign interrupt      = next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6 &&  \n                        !conflict               ;  \n                                                   \n\n\n\n\nassign interrupt_or_conflict\n                     =  next_interrupt != 3'd0 &&\n                        next_interrupt != 3'd7 &&  \n                        next_interrupt != 3'd6  ;  \n\nassign interrupt_mode = next_interrupt == 3'd2 ? FIRQ :\n                        next_interrupt == 3'd3 ? IRQ  :\n                        next_interrupt == 3'd4 ? SVC  :\n                        next_interrupt == 3'd5 ? SVC  :\n                        next_interrupt == 3'd6 ? SVC  :\n                        next_interrupt == 3'd7 ? SVC  :\n                        next_interrupt == 3'd1 ? SVC  :\n                                                 USR  ;\n\n\n\n\n\nalways @*\n    begin\n    \n    status_bits_mode_nxt            = i_execute_status_bits[1:0];   \n                                                                    \n    status_bits_irq_mask_nxt        = status_bits_irq_mask_r;\n    status_bits_firq_mask_nxt       = status_bits_firq_mask_r;\n    decode_exclusive_nxt            = 1'd0;\n    decode_daccess_nxt              = 1'd0;\n    decode_iaccess_nxt              = 1'd1;\n    copro_operation_nxt             = 'd0;\n\n    \n    saved_current_instruction_wen   = 1'd0;\n    pre_fetch_instruction_wen       = 1'd0;\n    restore_base_address_nxt        = restore_base_address;\n\n    \n    barrel_shift_amount_sel_nxt     = 'd0;  \n    barrel_shift_data_sel_nxt       = 'd0;  \n    barrel_shift_function_nxt       = 'd0;\n    use_carry_in_nxt                = 'd0;\n    multiply_function_nxt           = 'd0;\n    iaddress_sel_nxt                = 'd0;\n    daddress_sel_nxt                = 'd0;\n    pc_sel_nxt                      = 'd0;\n    load_pc_nxt                     = 'd0;\n    byte_enable_sel_nxt             = 'd0;\n    status_bits_sel_nxt             = 'd0;\n    reg_write_sel_nxt               = 'd0;\n    o_user_mode_regs_store_nxt      = 'd0;\n\n    \n    alu_swap_sel_nxt                = 'd0;\n    alu_not_sel_nxt                 = 'd0;\n    alu_cin_sel_nxt                 = 'd0;\n    alu_cout_sel_nxt                = 'd0;\n    alu_out_sel_nxt                 = 'd0;\n\n    \n    write_data_wen_nxt              = 'd0;\n    copro_write_data_wen_nxt        = 'd0;\n    base_address_wen_nxt            = 'd0;\n    pc_wen_nxt                      = 'd1;\n    reg_bank_wen_nxt                = 'd0;  \n\n    status_bits_flags_wen_nxt       = 'd0;\n    status_bits_mode_wen_nxt        = 'd0;\n    status_bits_irq_mask_wen_nxt    = 'd0;\n    status_bits_firq_mask_wen_nxt   = 'd0;\n\n    if ( instruction_valid && !interrupt && !conflict )\n        begin\n        if ( type == REGOP )\n            begin\n            if ( !opcode_compare )\n                begin\n                \n                if (instruction[15:12]  == 4'd15)\n                    begin\n                    pc_sel_nxt       = 3'd1; \n                    iaddress_sel_nxt = 4'd1; \n                    end\n                else\n                    reg_bank_wen_nxt = decode (instruction[15:12]);\n                end\n\n            if ( !immediate_shift_op )\n                begin\n                barrel_shift_function_nxt  = instruction[6:5];\n                end\n\n            if ( !immediate_shift_op )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( !immediate_shift_op && instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd1; \n\n            if ( !immediate_shift_op && !instruction[4] )\n                barrel_shift_amount_sel_nxt = 2'd2; \n\n            \n            if ( opcode == AND || opcode == EOR || opcode == TST || opcode == TEQ ||\n                 opcode == ORR || opcode == MOV || opcode == BIC || opcode == MVN )\n                status_bits_sel_nxt = 3'd5;\n\n            if ( opcode == ADD || opcode == CMN )   \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == ADC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                use_carry_in_nxt = shift_extend;\n                end\n\n            if ( opcode == SUB || opcode == CMP ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            \n            \n            \n            \n            if ( opcode == SBC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSB ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == RSC ) \n                begin\n                alu_out_sel_nxt  = 4'd1; \n                alu_cin_sel_nxt  = 2'd2; \n                alu_not_sel_nxt  = 1'd1; \n                alu_swap_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == AND || opcode == TST ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_cout_sel_nxt = 1'd1;  \n                end\n\n            if ( opcode == EOR || opcode == TEQ ) \n                begin\n                alu_out_sel_nxt = 4'd6;  \n                alu_cout_sel_nxt = 1'd1; \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == ORR )\n                begin\n                alu_out_sel_nxt  = 4'd7; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == BIC ) \n                begin\n                alu_out_sel_nxt  = 4'd8;  \n                alu_not_sel_nxt  = 1'd1;  \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n\n            if ( opcode == MOV ) \n                begin\n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n                end\n\n            if ( opcode == MVN ) \n                begin\n                alu_not_sel_nxt  = 1'd1; \n                alu_cout_sel_nxt = 1'd1;  \n                use_carry_in_nxt = 1'd1;\n               end\n            end\n\n        \n        if ( mem_op )\n            begin\n            if ( load_op && instruction[15:12]  == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n\n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n\n            if ( !instruction[23] )  \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                end\n\n            if ( store_op )\n                begin\n                write_data_wen_nxt = 1'd1;\n                if ( type == TRANS && instruction[22] )\n                    byte_enable_sel_nxt = 2'd1;         \n                end\n\n                \n                \n            if ( mem_op_pre_indexed || mem_op_post_indexed )\n                begin\n                \n                if ( rn_sel_nxt  == 4'd15 )\n                    pc_sel_nxt = 3'd1;\n                else\n                    reg_bank_wen_nxt = decode ( rn_sel_nxt );\n                end\n\n                \n            if ( mem_op_post_indexed )\n               daddress_sel_nxt = 4'd4; \n            else\n               daddress_sel_nxt = 4'd1; \n\n            if ( instruction[25] && type ==  TRANS )\n                barrel_shift_data_sel_nxt = 2'd2; \n\n            if ( type == TRANS && instruction[25] && shift_imm != 5'd0 )\n                begin\n                barrel_shift_function_nxt   = instruction[6:5];\n                barrel_shift_amount_sel_nxt = 2'd2; \n                end\n            end\n\n\n        if ( type == BRANCH )\n            begin\n            pc_sel_nxt            = 3'd1; \n            iaddress_sel_nxt      = 4'd1; \n            alu_out_sel_nxt       = 4'd1; \n\n            if ( instruction[24] ) \n                begin\n                reg_bank_wen_nxt  = decode (4'd14);  \n                reg_write_sel_nxt = 3'd1;            \n                end\n            end\n\n\n        if ( type == MTRANS )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            decode_daccess_nxt              = 1'd1; \n            alu_out_sel_nxt                 = 4'd1; \n            base_address_wen_nxt            = 1'd1; \n                                                    \n\n            if ( mtrans_num_registers > 4'd1 )\n                begin\n                iaddress_sel_nxt        = 4'd3; \n                pc_wen_nxt              = 1'd0; \n                end\n\n\n            \n            \n            \n            \n            restore_base_address_nxt        = instruction[20] &&\n                                                (instruction[15:0] & (1'd1 << instruction[19:16]));\n\n            \n            if ( instruction[23] )\n                begin\n                if ( instruction[24] )    \n                    daddress_sel_nxt = 4'd7; \n                else\n                    daddress_sel_nxt = 4'd4; \n                end\n            else\n            \n                begin\n                alu_cin_sel_nxt  = 2'd1; \n                alu_not_sel_nxt  = 1'd1; \n                if ( !instruction[24] )    \n                    daddress_sel_nxt  = 4'd6; \n                else\n                    daddress_sel_nxt  = 4'd1; \n                end\n\n            \n            if ( !instruction[20] )  \n                write_data_wen_nxt = 1'd1;\n\n            \n            if ( {instruction[22],instruction[20]} == 2'b10 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[21] )  \n                reg_bank_wen_nxt  = decode (rn_sel_nxt);\n\n            \n            if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n            end\n\n\n        if ( type == MULT )\n            begin\n            multiply_function_nxt[0]        = 1'd1; \n                                                    \n            saved_current_instruction_wen   = 1'd1; \n                                                    \n            pc_wen_nxt                      = 1'd0; \n\n            if ( instruction[21] )\n                multiply_function_nxt[1]    = 1'd1; \n            end\n\n\n        \n        if ( type == SWAP )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            decode_iaccess_nxt              = 1'd0; \n            decode_daccess_nxt              = 1'd1; \n            barrel_shift_data_sel_nxt       = 2'd2; \n            daddress_sel_nxt                = 4'd4; \n            decode_exclusive_nxt            = 1'd1; \n            end\n\n\n        \n        if ( type == CORTRANS && !und_request )\n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            iaddress_sel_nxt                = 4'd3; \n\n            if ( instruction[20] ) \n                copro_operation_nxt         = 2'd1;  \n            else \n                begin\n                 \n                 \n                copro_operation_nxt      = 2'd0;\n                copro_write_data_wen_nxt = 1'd1;  \n                end\n            end\n\n\n        if ( type == SWI || und_request )\n            begin\n            \n            reg_write_sel_nxt               = 3'd1;            \n            reg_bank_wen_nxt                = decode (4'd14);  \n\n            iaddress_sel_nxt                = 4'd2;            \n            pc_sel_nxt                      = 3'd2;            \n\n            status_bits_mode_nxt            = interrupt_mode;  \n            status_bits_mode_wen_nxt        = 1'd1;\n\n            \n            status_bits_irq_mask_nxt        = 1'd1;\n            status_bits_irq_mask_wen_nxt    = 1'd1;\n            end\n\n\n        if ( regop_set_flags )\n            begin\n            status_bits_flags_wen_nxt = 1'd1;\n\n            \n            \n            if ( instruction[15:12] == 4'd15 )\n                begin\n                status_bits_sel_nxt       = 3'd1; \n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                    begin\n                    status_bits_mode_wen_nxt      = 1'd1;\n                    status_bits_irq_mask_wen_nxt  = 1'd1;\n                    status_bits_firq_mask_wen_nxt = 1'd1;\n                    end\n                end\n            end\n\n        end\n\n    \n    \n    \n    \n    \n    \n    if ( instruction_valid && interrupt &&  next_interrupt != 3'd6 )\n        begin\n        \n        \n        \n        saved_current_instruction_wen   = 1'd1;\n\n        \n        \n        if ( next_interrupt == 3'd4 )\n            reg_write_sel_nxt               = 3'd7;            \n        else\n            reg_write_sel_nxt               = 3'd1;            \n\n        reg_bank_wen_nxt                = decode (4'd14);  \n\n        iaddress_sel_nxt                = 4'd2;            \n        pc_sel_nxt                      = 3'd2;            \n\n        status_bits_mode_nxt            = interrupt_mode;  \n        status_bits_mode_wen_nxt        = 1'd1;\n\n        \n        status_bits_irq_mask_nxt        = 1'd1;\n        status_bits_irq_mask_wen_nxt    = 1'd1;\n\n        \n        if ( next_interrupt == 3'd2 ) \n            begin\n            status_bits_firq_mask_nxt        = 1'd1;\n            status_bits_firq_mask_wen_nxt    = 1'd1;\n            end\n        end\n\n\n    \n    \n    if ( control_state == MEM_WAIT1 && !conflict )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            iaddress_sel_nxt            = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            load_pc_nxt                 = load_pc_r;\n            end\n        end\n\n\n    \n    if ( control_state == MEM_WAIT2 )\n        begin\n        if ( !dabt )  \n            begin\n            pc_wen_nxt                  = 1'd0; \n\n            \n            if (( type == TRANS && instruction[15:12]  == 4'd15 ) ||\n                ( type == MTRANS && instruction[20] && mtrans_reg1 == 4'd15 ))\n                begin\n                pc_sel_nxt       = 3'd3; \n                iaddress_sel_nxt = 4'd3; \n                load_pc_nxt      = load_pc_r;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC1 && !conflict )\n        begin\n        \n        pre_fetch_instruction_wen   = 1'd1;\n\n        if ( instruction_execute ) \n            begin\n            daddress_sel_nxt            = 4'd5;  \n            decode_daccess_nxt          = 1'd1;  \n\n            if ( mtrans_num_registers > 4'd2 )\n                decode_iaccess_nxt      = 1'd0;  \n\n\n            if ( mtrans_num_registers != 4'd1 )\n                begin\n                pc_wen_nxt              = 1'd0;  \n                iaddress_sel_nxt        = 4'd3;  \n                end\n\n\n            if ( !instruction[20] ) \n                write_data_wen_nxt = 1'd1;\n\n            \n            if ( {instruction[22],instruction[20]} == 2'b10 )\n                o_user_mode_regs_store_nxt = 1'd1;\n\n            \n            if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n                begin\n                saved_current_instruction_wen   = 1'd1; \n                pc_wen_nxt                      = 1'd0; \n                load_pc_nxt                     = 1'd1;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_EXEC2 )\n        begin\n        daddress_sel_nxt            = 4'd5;  \n        decode_daccess_nxt          = 1'd1;  \n\n        if ( mtrans_num_registers > 4'd2 )\n            begin\n            decode_iaccess_nxt      = 1'd0;  \n            end\n\n        if ( mtrans_num_registers > 4'd1 )\n            begin\n            pc_wen_nxt              = 1'd0; \n            iaddress_sel_nxt        = 4'd3;  \n            end\n\n        \n        if ( !instruction[20] )\n            write_data_wen_nxt = 1'd1;\n\n        \n        if ( {instruction[22],instruction[20]} == 2'b10 )\n            o_user_mode_regs_store_nxt = 1'd1;\n\n        \n        if ( instruction[20] && mtrans_reg1 == 4'd15 ) \n            begin\n            saved_current_instruction_wen   = 1'd1; \n            pc_wen_nxt                      = 1'd0; \n            load_pc_nxt                     = 1'd1;\n            end\n        end\n\n\n    \n    if ( control_state == MTRANS_ABORT )\n        begin\n        \n        \n        if (restore_base_address) \n            begin\n            reg_write_sel_nxt = 3'd6;                        \n            reg_bank_wen_nxt  = decode ( instruction[19:16] ); \n            end\n        end\n\n\n        \n    if ( control_state == MULT_PROC1 && instruction_execute && !conflict )\n        begin\n        \n        \n        pre_fetch_instruction_wen   = 1'd1;\n        pc_wen_nxt                  = 1'd0;  \n        multiply_function_nxt       = o_multiply_function;\n        end\n\n\n        \n        \n        \n    if ( control_state == MULT_PROC2 )\n        begin\n        \n        \n        pc_wen_nxt              = 1'd0;  \n        iaddress_sel_nxt        = 4'd3;  \n        multiply_function_nxt   = o_multiply_function;\n        end\n\n\n    \n    \n    if ( control_state == MULT_STORE )\n        begin\n        reg_write_sel_nxt     = 3'd2; \n        multiply_function_nxt = o_multiply_function;\n\n        if ( type == MULT ) \n            reg_bank_wen_nxt      = decode (instruction[19:16]); \n        else  \n            reg_bank_wen_nxt      = decode (instruction[15:12]); \n\n        if ( instruction[20] )  \n            begin\n            status_bits_sel_nxt       = 3'd4; \n            status_bits_flags_wen_nxt = 1'd1;\n            end\n        end\n\n\n    \n    if ( control_state == MULT_ACCUMU )\n        begin\n        multiply_function_nxt = o_multiply_function;\n        pc_wen_nxt            = 1'd0;  \n        iaddress_sel_nxt      = 4'd3;  \n        end\n\n\n    \n    if ( control_state == SWAP_WRITE && instruction_execute && !conflict )\n        begin\n        barrel_shift_data_sel_nxt       = 2'd2; \n        daddress_sel_nxt                = 4'd4; \n        write_data_wen_nxt              = 1'd1;\n        decode_iaccess_nxt              = 1'd0; \n        decode_daccess_nxt              = 1'd1; \n\n        if ( instruction[22] )\n            byte_enable_sel_nxt = 2'd1;         \n\n        if ( instruction_execute )              \n            pc_wen_nxt                  = 1'd0; \n\n        \n        \n        pre_fetch_instruction_wen       = 1'd1;\n\n        load_pc_nxt                     = load_pc_r;\n        end\n\n\n    \n    if ( control_state == SWAP_WAIT1 )\n        begin\n\n        if ( instruction_execute ) \n            begin\n            iaddress_sel_nxt            = 4'd3; \n            pc_wen_nxt                  = 1'd0; \n            end\n\n        if ( !dabt )\n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                pc_sel_nxt       = 3'd3; \n                iaddress_sel_nxt = 4'd3; \n                load_pc_nxt      = load_pc_r;\n                end\n            end\n        end\n\n\n    \n    if ( control_state == COPRO_WAIT && instruction_execute && !conflict )\n        begin\n        pre_fetch_instruction_wen = 1'd1;\n\n        if ( instruction[20] ) \n            begin\n            \n            if ( instruction[15:12]  == 4'd15 )\n                begin\n                \n                \n                status_bits_sel_nxt           = 3'd3;  \n                status_bits_flags_wen_nxt     = 1'd1;\n\n                \n                if ( i_execute_status_bits[1:0] != USR )\n                   begin\n                   status_bits_mode_wen_nxt      = 1'd1;\n                   status_bits_irq_mask_wen_nxt  = 1'd1;\n                   status_bits_firq_mask_wen_nxt = 1'd1;\n                   end\n                end\n            else\n                reg_bank_wen_nxt = decode (instruction[15:12]);\n\n            reg_write_sel_nxt = 3'd5;     \n            end\n        else \n            begin\n            copro_operation_nxt      = 2'd2;  \n            end\n        end\n\n\n    \n    \n    \n    \n    \n    if ( control_state == INT_WAIT1 )\n        status_bits_mode_nxt            = status_bits_mode_r;   \n\n    end\n\n\n\n\nassign firq_not_user_mode_nxt = status_bits_mode_nxt == FIRQ;\n\n\n\n\n\n\n\nassign instruction_execute = conditional_execute ( condition_r, i_execute_status_bits[31:28] );\n\n\n\n\nassign instruction_valid = ((control_state == EXECUTE || control_state == PRE_FETCH_EXEC) ||\n                              \n                              \n                             (!instruction_execute && (control_state == PC_STALL1    ||\n                                                       control_state == MEM_WAIT1    ||\n                                                       control_state == COPRO_WAIT   ||\n                                                       control_state == SWAP_WRITE   ||\n                                                       control_state == MULT_PROC1   ||\n                                                       control_state == MTRANS_EXEC1  ) ));\n\n\n always @*\n    begin\n    \n    control_state_nxt = control_state;\n\n    \n    if ( control_state == RST_WAIT1 )     control_state_nxt = RST_WAIT2;\n    if ( control_state == RST_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == INT_WAIT1 )     control_state_nxt = INT_WAIT2;\n    if ( control_state == INT_WAIT2 )     control_state_nxt = EXECUTE;\n    if ( control_state == COPRO_WAIT )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == PC_STALL1 )     control_state_nxt = PC_STALL2;\n    if ( control_state == PC_STALL2 )     control_state_nxt = EXECUTE;\n    if ( control_state == SWAP_WRITE )    control_state_nxt = SWAP_WAIT1;\n    if ( control_state == SWAP_WAIT1 )    control_state_nxt = SWAP_WAIT2;\n    if ( control_state == MULT_STORE )    control_state_nxt = PRE_FETCH_EXEC;\n    if ( control_state == MTRANS_ABORT )  control_state_nxt = PRE_FETCH_EXEC;\n\n    if ( control_state == MEM_WAIT1 )\n        control_state_nxt = MEM_WAIT2;\n\n    if ( control_state == MEM_WAIT2   ||\n        control_state == SWAP_WAIT2    )\n        begin\n        if ( write_pc ) \n            control_state_nxt = PC_STALL1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n    if ( control_state == MTRANS_EXEC1 )\n        begin\n        if ( mtrans_instruction_nxt[15:0] != 16'd0 )\n            control_state_nxt = MTRANS_EXEC2;\n        else   \n            begin\n            if ( dabt ) \n                control_state_nxt = MTRANS_ABORT;\n            else if ( write_pc ) \n                control_state_nxt = MEM_WAIT1;\n            else\n                control_state_nxt = PRE_FETCH_EXEC;\n            end\n        end\n\n        \n        \n    if ( control_state == MTRANS_EXEC2 && mtrans_num_registers == 5'd1 )\n        begin\n        if ( dabt ) \n            control_state_nxt = MTRANS_ABORT;\n        else if ( write_pc ) \n            control_state_nxt = MEM_WAIT1;\n        else\n            control_state_nxt = PRE_FETCH_EXEC;\n        end\n\n\n    if ( control_state == MULT_PROC1 )\n        begin\n        if (!instruction_execute)\n            control_state_nxt = PRE_FETCH_EXEC;\n        else\n            control_state_nxt = MULT_PROC2;\n        end\n\n    if ( control_state == MULT_PROC2 )\n        begin\n        if ( i_multiply_done )\n            if      ( o_multiply_function[1] )  \n                control_state_nxt = MULT_ACCUMU;\n            else\n                control_state_nxt = MULT_STORE;\n        end\n\n\n    if ( control_state == MULT_ACCUMU )\n        begin\n        control_state_nxt = MULT_STORE;\n        end\n\n\n    \n    \n    if ( instruction_valid )\n        begin\n        \n        \n        control_state_nxt = EXECUTE;\n\n        if ( current_write_pc )\n             control_state_nxt = PC_STALL1;\n\n        if ( load_op && instruction[15:12]  == 4'd15 )  \n             control_state_nxt = MEM_WAIT1;\n\n        \n        if ( type == MTRANS && instruction[20] && mtrans_reg1 == 4'd15 ) \n             control_state_nxt = MEM_WAIT1;\n\n        if ( type == MTRANS && !conflict && mtrans_num_registers != 5'd0 && mtrans_num_registers != 5'd1 )\n            control_state_nxt = MTRANS_EXEC1;\n\n        if ( type == MULT && !conflict )\n                control_state_nxt = MULT_PROC1;\n\n        if ( type == SWAP && !conflict )\n                control_state_nxt = SWAP_WRITE;\n\n        if ( type == CORTRANS && !und_request && !conflict )\n                control_state_nxt = COPRO_WAIT;\n\n         \n        if ( interrupt && !conflict )\n                control_state_nxt = INT_WAIT1;\n        end\n\n    end\n\n\n\n\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tfetch_instruction_r         <= 'd0;\n\t\tfetch_instruction_type_r    <= 'd0;\n\t\tfetch_address_r             <= 'd0;\n\t\tiabt_reg                    <= 'd0;\n\t\tadex_reg                    <= 'd0;\n\t\tabt_status_reg              <= 'd0;\n\t\tstatus_bits_mode_r          <= 2'b11;\n\t\tstatus_bits_irq_mask_r      <= 1'd1;\n\t\tstatus_bits_firq_mask_r     <= 1'd1;\n\t\to_imm32                     <= 'd0;\n\t\to_imm_shift_amount          <= 'd0;\n\t\to_shift_imm_zero            <= 'd0;\n\t\tcondition_r                 <= 4'hE;\n\t\to_decode_exclusive          <= 'd0;\n\t\tdecode_iaccess_r            <= 1'd1;\n\t\to_decode_daccess            <= 'd0;\n\t\to_rm_sel                    <= 'd0;\n\t\to_rs_sel                    <= 'd0;\n\t\to_load_rd                   <= 'd0;\n\t\tload_rd_d1                  <= 'd0;\n\t\tload_pc_r                   <= 'd0;\n\t\to_rn_sel                    <= 'd0;\n\t\to_barrel_shift_amount_sel   <= 'd0;\n\t\to_barrel_shift_data_sel     <= 'd0;\n\t\to_barrel_shift_function     <= 'd0;\n\t\to_alu_function              <= 'd0;\n\t\to_use_carry_in              <= 'd0;\n\t\to_multiply_function         <= 'd0;\n\t\to_interrupt_vector_sel      <= 'd0;\n\t\tiaddress_sel_r              <= 4'd2;\n\t\tdaddress_sel_r              <= 4'd2;\n\t\tpc_sel_r                    <= 3'd2;\n\t\to_byte_enable_sel           <= 'd0;\n\t\to_status_bits_sel           <= 'd0;\n\t\to_reg_write_sel             <= 'd0;\n\t\to_firq_not_user_mode        <= 'd0;\n\t\to_write_data_wen            <= 'd0;\n\t\to_base_address_wen          <= 'd0;\n\t\tpc_wen_r                    <= 1'd1;\n\t\to_reg_bank_wen              <= 'd0;\n\t\to_status_bits_flags_wen     <= 'd0;\n\t\to_status_bits_mode_wen      <= 'd0;\n\t\to_status_bits_irq_mask_wen  <= 'd0;\n\t\to_status_bits_firq_mask_wen <= 'd0;\n\t\to_copro_opcode1             <= 'd0;\n\t\to_copro_opcode2             <= 'd0;\n\t\to_copro_crn                 <= 'd0;\n\t\to_copro_crm                 <= 'd0;\n\t\to_copro_num                 <= 'd0;\n\t\to_copro_operation           <= 'd0;\n\t\to_copro_write_data_wen      <= 'd0;\n\t\trestore_base_address        <= 'd0;\n\t\tcontrol_state               <= RST_WAIT1;\n\tend else begin\n\t    if ( !i_core_stall ) begin\n\t\t  if (!conflict) begin\n\t\t      fetch_instruction_r         <= i_fetch_instruction;\n\t\t      fetch_instruction_type_r    <= instruction_type(i_fetch_instruction);\n\t\t      fetch_address_r             <= i_execute_iaddress;\n\t\t      iabt_reg                    <= i_iabt;\n\t\t      adex_reg                    <= i_adex;\n\t\t      abt_status_reg              <= i_abt_status;\n\t\t      end\n\n\t\t  status_bits_mode_r          <= status_bits_mode_nxt;\n\t\t  status_bits_irq_mask_r      <= status_bits_irq_mask_nxt;\n\t\t  status_bits_firq_mask_r     <= status_bits_firq_mask_nxt;\n\t\t  o_imm32                     <= imm32_nxt;\n\t\t  o_imm_shift_amount          <= imm_shift_amount_nxt;\n\t\t  o_shift_imm_zero            <= shift_imm_zero_nxt;\n\n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t                                  \n\t\t  condition_r                 <= instruction_valid && !interrupt ? condition_nxt : AL;\n\t\t  o_decode_exclusive          <= decode_exclusive_nxt;\n\t\t  decode_iaccess_r            <= decode_iaccess_nxt;\n\t\t  o_decode_daccess            <= decode_daccess_nxt;\n\n\t\t  o_rm_sel                    <= rm_sel_nxt;\n\t\t  o_rs_sel                    <= rs_sel_nxt;\n\t\t  o_load_rd                   <= load_rd_nxt;\n\t\t  load_rd_d1                  <= load_rd_d1_nxt;\n\t\t  load_pc_r                   <= load_pc_nxt;\n\t\t  o_rn_sel                    <= rn_sel_nxt;\n\t\t  o_barrel_shift_amount_sel   <= barrel_shift_amount_sel_nxt;\n\t\t  o_barrel_shift_data_sel     <= barrel_shift_data_sel_nxt;\n\t\t  o_barrel_shift_function     <= barrel_shift_function_nxt;\n\t\t  o_alu_function              <= alu_function_nxt;\n\t\t  o_use_carry_in              <= use_carry_in_nxt;\n\t\t  o_multiply_function         <= multiply_function_nxt;\n\t\t  o_interrupt_vector_sel      <= next_interrupt;\n\t\t  iaddress_sel_r              <= iaddress_sel_nxt;\n\t\t  daddress_sel_r              <= daddress_sel_nxt;\n\t\t  pc_sel_r                    <= pc_sel_nxt;\n\t\t  o_byte_enable_sel           <= byte_enable_sel_nxt;\n\t\t  o_status_bits_sel           <= status_bits_sel_nxt;\n\t\t  o_reg_write_sel             <= reg_write_sel_nxt;\n\t\t  o_firq_not_user_mode        <= firq_not_user_mode_nxt;\n\t\t  o_write_data_wen            <= write_data_wen_nxt;\n\t\t  o_base_address_wen          <= base_address_wen_nxt;\n\t\t  pc_wen_r                    <= pc_wen_nxt;\n\t\t  o_reg_bank_wen              <= reg_bank_wen_nxt;\n\t\t  o_status_bits_flags_wen     <= status_bits_flags_wen_nxt;\n\t\t  o_status_bits_mode_wen      <= status_bits_mode_wen_nxt;\n\t\t  o_status_bits_irq_mask_wen  <= status_bits_irq_mask_wen_nxt;\n\t\t  o_status_bits_firq_mask_wen <= status_bits_firq_mask_wen_nxt;\n\n\t\t  o_copro_opcode1             <= instruction[23:21];\n\t\t  o_copro_opcode2             <= instruction[7:5];\n\t\t  o_copro_crn                 <= instruction[19:16];\n\t\t  o_copro_crm                 <= instruction[3:0];\n\t\t  o_copro_num                 <= instruction[11:8];\n\t\t  o_copro_operation           <= copro_operation_nxt;\n\t\t  o_copro_write_data_wen      <= copro_write_data_wen_nxt;\n\t\t  restore_base_address        <= restore_base_address_nxt;\n\t\t  control_state               <= control_state_nxt;\n\t\tend\n\tend\nend\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tsaved_current_instruction              <= 'd0;\n\t\tsaved_current_instruction_type         <= 'd0;\n\t\tsaved_current_instruction_iabt         <= 'd0;\n\t\tsaved_current_instruction_adex         <= 'd0;\n\t\tsaved_current_instruction_address      <= 'd0;\n\t\tsaved_current_instruction_iabt_status  <= 'd0;\n\t\tpre_fetch_instruction                  <= 'd0;\n\t\tpre_fetch_instruction_type             <= 'd0;\n\t\tpre_fetch_instruction_iabt             <= 'd0;\n\t\tpre_fetch_instruction_adex             <= 'd0;\n\t\tpre_fetch_instruction_address          <= 'd0;\n\t\tpre_fetch_instruction_iabt_status      <= 'd0;\n\t\thold_instruction              <= 'd0;\n\t\thold_instruction_type         <= 'd0;\n\t\thold_instruction_iabt         <= 'd0;\n\t\thold_instruction_adex         <= 'd0;\n\t\thold_instruction_address      <= 'd0;\n\t\thold_instruction_iabt_status  <= 'd0;\n\tend else begin\n\t    if ( !i_core_stall )\n\t\t  begin\n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  \n\t\t  if      ( type == MTRANS )\n\t\t      begin\n\t\t      saved_current_instruction              <= mtrans_instruction_nxt;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\t\t  else if ( saved_current_instruction_wen )\n\t\t      begin\n\t\t      saved_current_instruction              <= instruction;\n\t\t      saved_current_instruction_type         <= type;\n\t\t      saved_current_instruction_iabt         <= instruction_iabt;\n\t\t      saved_current_instruction_adex         <= instruction_adex;\n\t\t      saved_current_instruction_address      <= instruction_address;\n\t\t      saved_current_instruction_iabt_status  <= instruction_iabt_status;\n\t\t      end\n\n\t\t  if      ( pre_fetch_instruction_wen )\n\t\t      begin\n\t\t      pre_fetch_instruction                  <= fetch_instruction_r;\n\t\t      pre_fetch_instruction_type             <= fetch_instruction_type_r;\n\t\t      pre_fetch_instruction_iabt             <= iabt_reg;\n\t\t      pre_fetch_instruction_adex             <= adex_reg;\n\t\t      pre_fetch_instruction_address          <= fetch_address_r;\n\t\t      pre_fetch_instruction_iabt_status      <= abt_status_reg;\n\t\t      end\n\n\n\t\t  \n\t\t  hold_instruction              <= instruction;\n\t\t  hold_instruction_type         <= type;\n\t\t  hold_instruction_iabt         <= instruction_iabt;\n\t\t  hold_instruction_adex         <= instruction_adex;\n\t\t  hold_instruction_address      <= instruction_address;\n\t\t  hold_instruction_iabt_status  <= instruction_iabt_status;\n\t\t  end\n\tend\nend\n\nalways @ ( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\tirq   <= 'd0;\n\t\tfirq  <= 'd0;\n\t\tdabt_reg  <= 'd0;\n\t\tdabt_reg_d1  <= 'd0;\n\tend else begin\n\t\tif ( !i_core_stall ) begin\n\t\t\tirq   <= i_irq;\n\t\t\tfirq  <= i_firq;\n\t\t\tif ( control_state == INT_WAIT1 && status_bits_mode_r == SVC ) begin\n\t\t\t\tdabt_reg  <= 1'd0;\n\t\t\tend else begin\n\t\t\t\tdabt_reg  <= dabt_reg || i_dabt;\n\t\t\tend\n\t\t\tdabt_reg_d1  <= dabt_reg;\n\t\tend\n\tend\nend\n\nassign dabt = dabt_reg || i_dabt;\n\n\n\n\n\n\n\n`include \"../include/debug_functions.vh\"\n\na25_decompile  u_decompile (\n    .clk                      ( clk                            ),\n    .reset                    ( reset                          ),\n    .scan_enable              ( scan_enable                    ),\n    .test_mode                ( test_mode                      ),\n\n    .i_core_stall               ( i_core_stall                     ),\n    .i_instruction              ( instruction                      ),\n    .i_instruction_valid        ( instruction_valid &&!conflict    ),\n    .i_instruction_execute      ( instruction_execute              ),\n    .i_instruction_address      ( instruction_address              ),\n    .i_interrupt                ( {3{interrupt}} & next_interrupt  ),\n    .i_interrupt_state          ( control_state == INT_WAIT2       ),\n    .i_instruction_undefined    ( und_request                      ),\n    .i_pc_sel                   ( pc_sel_r                         ),\n    .i_pc_wen                   ( pc_wen_r                         ));\n\n\nwire    [(15*8)-1:0]    xCONTROL_STATE;\nwire    [(15*8)-1:0]    xMODE;\nwire    [( 8*8)-1:0]    xTYPE;\n\nassign xCONTROL_STATE        =\n                               control_state == RST_WAIT1      ? \"RST_WAIT1\"      :\n                               control_state == RST_WAIT2      ? \"RST_WAIT2\"      :\n\n\n                               control_state == INT_WAIT1      ? \"INT_WAIT1\"      :\n                               control_state == INT_WAIT2      ? \"INT_WAIT2\"      :\n                               control_state == EXECUTE        ? \"EXECUTE\"        :\n                               control_state == PRE_FETCH_EXEC ? \"PRE_FETCH_EXEC\" :\n                               control_state == MEM_WAIT1      ? \"MEM_WAIT1\"      :\n                               control_state == MEM_WAIT2      ? \"MEM_WAIT2\"      :\n                               control_state == PC_STALL1      ? \"PC_STALL1\"      :\n                               control_state == PC_STALL2      ? \"PC_STALL2\"      :\n                               control_state == MTRANS_EXEC1   ? \"MTRANS_EXEC1\"   :\n                               control_state == MTRANS_EXEC2   ? \"MTRANS_EXEC2\"   :\n                               control_state == MTRANS_ABORT   ? \"MTRANS_ABORT\"   :\n                               control_state == MULT_PROC1     ? \"MULT_PROC1\"     :\n                               control_state == MULT_PROC2     ? \"MULT_PROC2\"     :\n                               control_state == MULT_STORE     ? \"MULT_STORE\"     :\n                               control_state == MULT_ACCUMU    ? \"MULT_ACCUMU\"    :\n                               control_state == SWAP_WRITE     ? \"SWAP_WRITE\"     :\n                               control_state == SWAP_WAIT1     ? \"SWAP_WAIT1\"     :\n                               control_state == SWAP_WAIT2     ? \"SWAP_WAIT2\"     :\n                               control_state == COPRO_WAIT     ? \"COPRO_WAIT\"     :\n                                                                 \"UNKNOWN \"       ;\n\nassign xMODE  = mode_name ( status_bits_mode_r );\n\nassign xTYPE  =\n                               type == REGOP    ? \"REGOP\"    :\n                               type == MULT     ? \"MULT\"     :\n                               type == SWAP     ? \"SWAP\"     :\n                               type == TRANS    ? \"TRANS\"    :\n                               type == MTRANS   ? \"MTRANS\"   :\n                               type == BRANCH   ? \"BRANCH\"   :\n                               type == CODTRANS ? \"CODTRANS\" :\n                               type == COREGOP  ? \"COREGOP\"  :\n                               type == CORTRANS ? \"CORTRANS\" :\n                               type == SWI      ? \"SWI\"      :\n                                                  \"UNKNOWN\"  ;\n\n\nalways @( posedge reset, posedge clk ) begin\n\tif (reset) begin\n\t\n\tend else begin\n\t    if (control_state == EXECUTE && ((instruction[0] === 1'bx) || (instruction[31] === 1'bx)))\n\t\t  begin\n\t\t  `TB_ERROR_MESSAGE\n\t\t  $display(\"Instruction with x's =%08h\", instruction);\n\t\t  end\n\tend\nend\n\n\nendmodule\n\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: a25_decode. Module specification: This module is responsible for decoding ARM instructions in an ARM25 processor implementation. It takes inputs such as clock, reset, fetched instruction, core status, and interrupt signals, and generates control signals for other parts of the processor. The module handles different instruction types, manages the processor's control state, and handles interrupts and exceptions. Key input ports include clk, reset, i_fetch_instruction, i_core_stall, i_irq, i_firq, and i_execute_status_bits. Output ports include o_imm32, o_condition, o_decode_daccess, o_rm_sel, o_alu_function, o_reg_bank_wen, and o_copro_operation. Internal signals are used for instruction decoding, control state management, register selection, ALU control, and interrupt handling. The module is structured into"
                }
            ]
        }
    ]
}