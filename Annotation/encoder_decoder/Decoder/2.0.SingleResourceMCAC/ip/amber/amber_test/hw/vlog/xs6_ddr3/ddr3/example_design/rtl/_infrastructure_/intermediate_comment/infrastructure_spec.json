{
    "spec": "Module name: infrastructure. Module specification: The `infrastructure` module is a versatile clock management component primarily used in FPGA designs for generating and managing multiple clock signals and reset conditions. It supports configurable input clock types, either differential (via `sys_clk_p` and `sys_clk_n`) for reduced noise and crosstalk, or single-ended (via `sys_clk`) for simpler, cost-effective applications. The module processes these clocks through a Phase-Locked Loop (PLL) to output various stabilized clock signals: `clk0` (primary system clock), `sysclk_2x` and `sysclk_2x_180` (frequency-doubled clocks with the latter being phase-shifted), and `mcb_drp_clk` (for Memory Controller Blocks and Dynamic Reconfiguration Port operations). Control signals `pll_ce_0` and `pll_ce_90` are aligned respectively with the double-speed clocks for serial deserialization tasks. It also outputs `pll_lock`, indicating the lock status of the PLL. Internal signals such as `clk_2x_0`, `clk_2x_180` for doubly fast clocks, and buffering signals `clk0_bufg_in` for primary clock stability play crucial roles. There are various configuration parameters, such as input frequency, clock divides, and multipliers that can be tailored based on system requirements. Key components of the code include differential and single-ended clock input handling, PLL configuration for various output clocks, buffer assignment for maintaining clock signal integrity, and complex reset synchronization mechanisms\u2014all ensuring robust and reliable operation of FPGA-based systems. This module is integral in managing different clock domains and ensuring that resets are consistently and safely asserted throughout the system.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\nExplanation: The `infrastructure` module is designed primarily for clock management, specifically for generating various clock signals and managing reset conditions in FPGA designs. It allows configuration of input clock types (differential or single-ended) and leverages a PLL (Phase-Locked Loop) advanced block to generate multiple output clocks with specified divides, phases, and duty cycles. It also includes buffers and conditional elements, ensuring clocks are stable and synchronized across the system. Additionally, the module includes features to handle asynchronous and synchronous resets based on the PLL lock status to ensure robust operation in FPGA applications. This setup is crucial in bigger systems where multiple clock domains and reliable reset de-assertion mechanisms are necessary for stable operation."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: sys_clk_p, sys_clk_n, sys_clk, sys_rst_i.\nExplanation:\n- `sys_clk_p` and `sys_clk_n`: These are the positive and negative differential clock inputs used when C_INPUT_CLK_TYPE is set to \"DIFFERENTIAL\". They support high-speed clock input applications with reduced noise and crosstalk.\n- `sys_clk`: This is the single-ended clock input used when C_INPUT_CLK_TYPE is set to \"SINGLE_ENDED\". It's an alternative to differential inputs, typically used when system simplicity and cost are more critical than performance.\n- `sys_rst_i`: This is the system reset input, which can be either active-high or active-low based on the C_RST_ACT_LOW parameter. It is used to reset the internal states and outputs of the module.\n\nOutput ports: clk0, rst0, async_rst, sysclk_2x, sysclk_2x_180, mcb_drp_clk, pll_ce_0, pll_ce_90, pll_lock.\nExplanation:\n- `clk0`: This is a primary clock output derived from the PLL, used for general system operations that require synchronized clock signals.\n- `rst0`: This is the synchronized reset output, providing a stable reset signal that changes only within the specified domain of clk0.\n- `async_rst`: This asynchronous reset output combines system reset input and the negation of the PLL's power-up lock status, ensuring robust reset behavior independent of clock stability during power-up or configuration phases.\n- `sysclk_2x`, `sysclk_2x_180`: These outputs provide doubled frequency clocks, with `sysclk_2x_180` being phase shifted by 180 degrees. They are typically used for high-speed operations or interfaces requiring a phase-shifted clock.\n- `mcb_drp_clk`: This output is a specially conditioned clock used for Memory Controller Blocks (MCB) and Dynamic Reconfiguration Port (DRP) operations, facilitated by the corresponding clock enable (CE) from the PLL lock status.\n- `pll_ce_0`, `pll_ce_90`: These outputs are control signals specifically useful for managing Clock Enable (CE) operations in serial deserialization; `pll_ce_0` is aligned with `sysclk_2x` and `pll_ce_90` is aligned with `sysclk_2x_180`.\n- `pll_lock`: This output indicates the lock status of the PLL, effectively signaling whether the PLL has successfully synchronized the provided input clock to the output clocks. This signal is critical for conditional resets and other logic operations that depend on stable clock outputs."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: clk_2x_0, clk_2x_180, clk0_bufg, clk0_bufg_in, mcb_drp_clk_bufg_in, clkfbout_clkfbin, locked, rst0_sync_r, rst_tmp, powerup_pll_locked, syn_clk0_powerup_pll_locked, sys_rst, bufpll_mcb_locked, sys_clk_ibufg.\nExplanation:\n- `clk_2x_0`, `clk_2x_180`: These signals are intermediate frequency-doubled clock outputs from the PLL, which are further processed to generate system clocks `sysclk_2x` and `sysclk_2x_180`.\n- `clk0_bufg`: This is a buffered version of the clock signal `clk0_bufg_in`, used as the primary system clock output `clk0`.\n- `clk0_bufg_in`: This input to the buffer represents one of the PLL's divided output clocks, designated specifically to function as `clk0` after buffering.\n- `mcb_drp_clk_bufg_in`: This signal is driven by one of the PLL outputs and is buffered to create the `mcb_drp_clk`, specifically used for Memory Controller and DRP operations.\n- `clkfbout_clkfbin`: This is part of the feedback path used inside the PLL to stabilize and lock the output frequencies based on the input clock.\n- `locked`: An internal signal from the PLL indicating whether it is locked (i.e., stable and within operational parameters).\n- `rst0_sync_r`: This register is used for synchronizing the reset signal `rst0` to the clock `clk0_bufg`, ensuring it is stable and glitch-free in the clock domain.\n- `rst_tmp`: This is a temporary signal combining the system reset and the negation of `syn_clk0_powerup_pll_locked`, used to control the synchronization of `rst0`.\n- `powerup_pll_locked`: This register holds the state of the system immediately after the PLL achieves lock, used to control the `async_rst`.\n- `syn_clk0_powerup_pll_locked`: Similar to `powerup_pll_locked`, but specifically synchronized to the `clk0_bufg` domain, influencing the synchronous reset output.\n- `sys_rst`: This is an adjusted system reset signal, accounting for whether the reset is active high or low based on the configuration parameter `C_RST_ACT_LOW`.\n- `bufpll_mcb_locked`: This locked status from the BUFPLL_MCB block indicates synchronization for buffers like `sysclk_2x` output, crucial for phase-aligned operations.\n- `sys_clk_ibufg`: This is an internally buffered clock signal derived from either differential input clocks or a single-ended clock, serving as the PLL's primary input clock."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: infrastructure. Module specification: The `infrastructure` module is a versatile clock management component primarily used in FPGA designs for generating and managing multiple clock signals and reset conditions. It supports configurable input clock types, either differential (via `sys_clk_p` and `sys_clk_n`) for reduced noise and crosstalk, or single-ended (via `sys_clk`) for simpler, cost-effective applications. The module processes these clocks through a Phase-Locked Loop (PLL) to output various stabilized clock signals: `clk0` (primary system clock), `sysclk_2x` and `sysclk_2x_180` (frequency-doubled clocks with the latter being phase-shifted), and `mcb_drp_clk` (for Memory Controller Blocks and Dynamic Reconfiguration Port operations). Control signals `pll_ce_0` and `pll_ce_90` are aligned respectively with the double-speed clocks for serial deserialization tasks. It also outputs `pll_lock`, indicating the lock status of the PLL. Internal signals such as `clk_2x_0`, `clk_2x_180` for doubly fast clocks, and buffering signals `clk0_bufg_in` for primary clock stability play crucial roles. There are various configuration parameters, such as input frequency, clock divides, and multipliers that can be tailored based on system requirements. Key components of the code include differential and single-ended clock input handling, PLL configuration for various output clocks, buffer assignment for maintaining clock signal integrity, and complex reset synchronization mechanisms\u2014all ensuring robust and reliable operation of FPGA-based systems. This module is integral in managing different clock domains and ensuring that resets are consistently and safely asserted throughout the system."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\nExplanation: The `infrastructure` module is designed primarily for clock management, specifically for generating various clock signals and managing reset conditions in FPGA designs. It allows configuration of input clock types (differential or single-ended) and leverages a PLL (Phase-Locked Loop) advanced block to generate multiple output clocks with specified divides, phases, and duty cycles. It also includes buffers and conditional elements, ensuring clocks are stable and synchronized across the system. Additionally, the module includes features to handle asynchronous and synchronous resets based on the PLL lock status to ensure robust operation in FPGA applications. This setup is crucial in bigger systems where multiple clock domains and reliable reset de-assertion mechanisms are necessary for stable operation."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: sys_clk_p, sys_clk_n, sys_clk, sys_rst_i.\nExplanation:\n- `sys_clk_p` and `sys_clk_n`: These are the positive and negative differential clock inputs used when C_INPUT_CLK_TYPE is set to \"DIFFERENTIAL\". They support high-speed clock input applications with reduced noise and crosstalk.\n- `sys_clk`: This is the single-ended clock input used when C_INPUT_CLK_TYPE is set to \"SINGLE_ENDED\". It's an alternative to differential inputs, typically used when system simplicity and cost are more critical than performance.\n- `sys_rst_i`: This is the system reset input, which can be either active-high or active-low based on the C_RST_ACT_LOW parameter. It is used to reset the internal states and outputs of the module.\n\nOutput ports: clk0, rst0, async_rst, sysclk_2x, sysclk_2x_180, mcb_drp_clk, pll_ce_0, pll_ce_90, pll_lock.\nExplanation:\n- `clk0`: This is a primary clock output derived from the PLL, used for general system operations that require synchronized clock signals.\n- `rst0`: This is the synchronized reset output, providing a stable reset signal that changes only within the specified domain of clk0.\n- `async_rst`: This asynchronous reset output combines system reset input and the negation of the PLL's power-up lock status, ensuring robust reset behavior independent of clock stability during power-up or configuration phases.\n- `sysclk_2x`, `sysclk_2x_180`: These outputs provide doubled frequency clocks, with `sysclk_2x_180` being phase shifted by 180 degrees. They are typically used for high-speed operations or interfaces requiring a phase-shifted clock.\n- `mcb_drp_clk`: This output is a specially conditioned clock used for Memory Controller Blocks (MCB) and Dynamic Reconfiguration Port (DRP) operations, facilitated by the corresponding clock enable (CE) from the PLL lock status.\n- `pll_ce_0`, `pll_ce_90`: These outputs are control signals specifically useful for managing Clock Enable (CE) operations in serial deserialization; `pll_ce_0` is aligned with `sysclk_2x` and `pll_ce_90` is aligned with `sysclk_2x_180`.\n- `pll_lock`: This output indicates the lock status of the PLL, effectively signaling whether the PLL has successfully synchronized the provided input clock to the output clocks. This signal is critical for conditional resets and other logic operations that depend on stable clock outputs."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: clk_2x_0, clk_2x_180, clk0_bufg, clk0_bufg_in, mcb_drp_clk_bufg_in, clkfbout_clkfbin, locked, rst0_sync_r, rst_tmp, powerup_pll_locked, syn_clk0_powerup_pll_locked, sys_rst, bufpll_mcb_locked, sys_clk_ibufg.\nExplanation:\n- `clk_2x_0`, `clk_2x_180`: These signals are intermediate frequency-doubled clock outputs from the PLL, which are further processed to generate system clocks `sysclk_2x` and `sysclk_2x_180`.\n- `clk0_bufg`: This is a buffered version of the clock signal `clk0_bufg_in`, used as the primary system clock output `clk0`.\n- `clk0_bufg_in`: This input to the buffer represents one of the PLL's divided output clocks, designated specifically to function as `clk0` after buffering.\n- `mcb_drp_clk_bufg_in`: This signal is driven by one of the PLL outputs and is buffered to create the `mcb_drp_clk`, specifically used for Memory Controller and DRP operations.\n- `clkfbout_clkfbin`: This is part of the feedback path used inside the PLL to stabilize and lock the output frequencies based on the input clock.\n- `locked`: An internal signal from the PLL indicating whether it is locked (i.e., stable and within operational parameters).\n- `rst0_sync_r`: This register is used for synchronizing the reset signal `rst0` to the clock `clk0_bufg`, ensuring it is stable and glitch-free in the clock domain.\n- `rst_tmp`: This is a temporary signal combining the system reset and the negation of `syn_clk0_powerup_pll_locked`, used to control the synchronization of `rst0`.\n- `powerup_pll_locked`: This register holds the state of the system immediately after the PLL achieves lock, used to control the `async_rst`.\n- `syn_clk0_powerup_pll_locked`: Similar to `powerup_pll_locked`, but specifically synchronized to the `clk0_bufg` domain, influencing the synchronous reset output.\n- `sys_rst`: This is an adjusted system reset signal, accounting for whether the reset is active high or low based on the configuration parameter `C_RST_ACT_LOW`.\n- `bufpll_mcb_locked`: This locked status from the BUFPLL_MCB block indicates synchronization for buffers like `sysclk_2x` output, crucial for phase-aligned operations.\n- `sys_clk_ibufg`: This is an internally buffered clock signal derived from either differential input clocks or a single-ended clock, serving as the PLL's primary input clock."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: infrastructure. Module specification: The `infrastructure` module is a versatile clock management component primarily used in FPGA designs for generating and managing multiple clock signals and reset conditions. It supports configurable input clock types, either differential (via `sys_clk_p` and `sys_clk_n`) for reduced noise and crosstalk, or single-ended (via `sys_clk`) for simpler, cost-effective applications. The module processes these clocks through a Phase-Locked Loop (PLL) to output various stabilized clock signals: `clk0` (primary system clock), `sysclk_2x` and `sysclk_2x_180` (frequency-doubled clocks with the latter being phase-shifted), and `mcb_drp_clk` (for Memory Controller Blocks and Dynamic Reconfiguration Port operations). Control signals `pll_ce_0` and `pll_ce_90` are aligned respectively with the double-speed clocks for serial deserialization tasks. It also outputs `pll_lock`, indicating the lock status of the PLL. Internal signals such as `clk_2x_0`, `clk_2x_180` for doubly fast clocks, and buffering signals `clk0_bufg_in` for primary clock stability play crucial roles. There are various configuration parameters, such as input frequency, clock divides, and multipliers that can be tailored based on system requirements. Key components of the code include differential and single-ended clock input handling, PLL configuration for various output clocks, buffer assignment for maintaining clock signal integrity, and complex reset synchronization mechanisms\u2014all ensuring robust and reliable operation of FPGA-based systems. This module is integral in managing different clock domains and ensuring that resets are consistently and safely asserted throughout the system."
                }
            ]
        }
    ]
}