Module name: interrupt_controller.

Module specification: The `interrupt_controller` module is tasked with managing and handling different types of interrupts (IRQs and FIRQs) from various sources such as UARTs, Ethernet MAC, and timers in a system utilizing a Wishbone compliant bus interface. The module operates with inputs including a system clock (`i_clk`), Wishbone transaction signals (`i_wb_adr`, `i_wb_sel`, `i_wb_we`, `i_wb_dat`, `i_wb_cyc`, `i_wb_stb`), and interrupt signals from peripherals (`i_uart0_int`, `i_uart1_int`, `i_ethmac_int`, `i_test_reg_irq`, `i_test_reg_firq`, `i_tm_timer_int`). Output ports facilitate the communication back to the Wishbone bus and include read acknowledgment (`o_wb_ack`), data output (`o_wb_dat`), error signaling (`o_wb_err`), and combined interrupt requests (`o_irq`, `o_firq`).

Internally, the module contains registers (`irq0_enable_reg`, `firq0_enable_reg`, etc.) to enable/disable interrupts, soft interrupts, and to hold and manage data for read and write transactions via Wishbone (`wb_rdata32`, `wb_wdata32`). Control signals like `wb_start_write` and `wb_start_read` help sequence the Wishbone transactions.

The module is divided into blocks handling the initial setup of conditions and flags, processing of incoming interrupts where interrupts are decoded, filtered through enabled masks (`irq0_interrupts`, `firq0_interrupts`), and aggregated to generate the output interrupt requests. There are also blocks dedicated to handling Wishbone write and read operations based on address mapping, with conditions to organize and execute different register and data management operations based on incoming commands. Debugging support is included conditionally to aid in development and testing with detailed log messages for transactions.