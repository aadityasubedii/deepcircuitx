{
    "spec": "Module name: eth_wishbone. Module specification: This module implements an Ethernet Wishbone interface controller, managing communication between the Ethernet MAC and the Wishbone bus for transmit and receive operations. It handles buffer management, status handling, and interrupt generation. Key inputs include clock signals, Wishbone bus inputs, Ethernet MAC signals, and configuration inputs. Outputs consist of Wishbone bus outputs, Ethernet MAC control signals, and interrupt signals. Internal signals manage buffer states, pointers, and various control flags. The module is divided into several functional blocks: Wishbone interface logic, transmit path logic, receive path logic, FIFO management, and interrupt generation. It coordinates data transfers between the Wishbone bus and Ethernet frames, manages buffer descriptors, and handles various control signals and status flags related to Ethernet packet transmission and reception. The design incorporates synchronization mechanisms between different clock domains and implements error handling for conditions such as under",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: eth_wishbone\n\nExplanation: This module appears to be an Ethernet Wishbone interface controller. It handles the communication between the Ethernet MAC (Media Access Control) and the Wishbone bus, managing transmit and receive operations. The module includes logic for buffer management, status handling, and interrupt generation for both transmit and receive paths. It coordinates data transfers between the Wishbone bus and Ethernet frames, handles buffer descriptors, and manages various control signals and status flags related to Ethernet packet transmission and reception."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nWB_CLK_I, WB_DAT_I, WB_ADR_I, WB_WE_I, BDCs, Reset, m_wb_dat_i, m_wb_ack_i, m_wb_err_i, MTxClk, TxUsedData, TxRetry, TxAbort, TxDone, MRxClk, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, r_TxEn, r_RxEn, r_TxBDNum, r_RxFlow, r_PassAll, InvalidSymbol, LatchedCrcError, RxLateCollision, ShortFrame, DribbleNibble, ReceivedPacketTooBig, RxLength, LoadRxStatus, ReceivedPacketGood, AddressMiss, ReceivedPauseFrm, RetryCntLatched, RetryLimit, LateCollLatched, DeferLatched, CarrierSenseLost.\n\nExplanation: These inputs include clock signals, data and address inputs from the Wishbone bus, control signals for transmit and receive operations, status signals from the Ethernet MAC, and configuration inputs.\n\nOutput ports:\nWB_DAT_O, WB_ACK_O, m_wb_adr_o, m_wb_sel_o, m_wb_we_o, m_wb_dat_o, m_wb_cyc_o, m_wb_stb_o, TxStartFrm, TxEndFrm, TxData, TxUnderRun, PerPacketCrcEn, PerPacketPad, RxStatusWriteLatched_sync2, RstDeferLatched, TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ.\n\nExplanation: These outputs include data and control signals for the Wishbone bus, signals for controlling the Ethernet MAC's transmit and receive operations, status signals, and interrupt request signals for various events in the Ethernet communication process."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nTxBDReady, TxBDRead, TxPointerRead, TxStatusWrite, BlockingTxStatusWrite, BlockingTxBDRead, TxStatus, ReadTxDataFromMemory, WriteRxDataToMemory, MasterWbTX, MasterWbRX, TxLength, LatchedTxLength, TxLengthEq0, TxLengthLt4, BlockingIncrementTxPointer, TxPointerMSB, TxPointerLSB, TxPointerLSB_rst, RxPointerMSB, RxPointerLSB_rst, RxByteSel, TxBufferAlmostFull, TxBufferFull, TxBufferEmpty, TxBufferAlmostEmpty, WriteRxDataToFifo, RxByteCnt, RxValidBytes, RxDataLatched1, RxDataLatched2, ShiftEnded, RxOverrun, TxError, RxError, RxStatusWriteLatched.\n\nExplanation:\n- TxBDReady, TxBDRead, TxPointerRead: Control signals for transmit buffer descriptor operations.\n- TxStatusWrite, BlockingTxStatusWrite: Manage the writing of transmit status.\n- BlockingTxBDRead: Controls the blocking of transmit buffer descriptor reads.\n- TxStatus: Holds the current transmit status.\n- ReadTxDataFromMemory, WriteRxDataToMemory: Control signals for memory access operations.\n- MasterWbTX, MasterWbRX: Indicate active Wishbone master operations for transmit and receive.\n- TxLength, LatchedTxLength: Store the length of the current transmit frame.\n- TxLengthEq0, TxLengthLt4: Flags for specific transmit length conditions.\n- BlockingIncrementTxPointer: Controls the increment of the transmit pointer.\n- TxPointerMSB, TxPointerLSB, TxPointerLSB_rst: Store different parts of the transmit pointer.\n- RxPointerMSB, RxPointerLSB_rst: Store different parts of the receive pointer.\n- RxByteSel: Selects which bytes are valid in receive operations.\n- TxBufferAlmostFull, TxBufferFull, TxBufferEmpty, TxBufferAlmostEmpty: Indicate the status of the transmit buffer.\n- WriteRxDataToFifo: Controls writing received data to the FIFO.\n- RxByteCnt, RxValidBytes: Count and track valid bytes in receive operations.\n- RxDataLatched1, RxDataLatched2: Store received data temporarily.\n- ShiftEnded: Indicates the end of a shift operation in receive process.\n- RxOverrun: Flags a receive buffer overrun condition.\n- TxError, RxError: Indicate transmit and receive errors.\n- RxStatusWriteLatched: Latches the write status for receive operations.\n\nThese signals are used throughout the module to control data flow, manage buffer states, handle timing and synchronization, and track various conditions in the Ethernet frame transmission and reception processes."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_wishbone\n   (\n\n    \n    WB_CLK_I, WB_DAT_I, WB_DAT_O, \n\n    \n \t\tWB_ADR_I, WB_WE_I, WB_ACK_O, \n    BDCs, \n\n    Reset, \n\n    \n    m_wb_adr_o, m_wb_sel_o, m_wb_we_o, \n    m_wb_dat_o, m_wb_dat_i, m_wb_cyc_o, \n    m_wb_stb_o, m_wb_ack_i, m_wb_err_i, \n\n`ifdef ETH_WISHBONE_B3\n    m_wb_cti_o, m_wb_bte_o, \n`endif\n\n    \n    MTxClk, TxStartFrm, TxEndFrm, TxUsedData, TxData, \n    TxRetry, TxAbort, TxUnderRun, TxDone, PerPacketCrcEn, \n    PerPacketPad, \n\n    \n    MRxClk, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, RxStatusWriteLatched_sync2, \n    \n    \n    r_TxEn, r_RxEn, r_TxBDNum, r_RxFlow, r_PassAll, \n\n    \n    TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, \n    \n    \n    InvalidSymbol, LatchedCrcError, RxLateCollision, ShortFrame, DribbleNibble,\n    ReceivedPacketTooBig, RxLength, LoadRxStatus, ReceivedPacketGood, AddressMiss, \n    ReceivedPauseFrm, \n    \n    \n    RetryCntLatched, RetryLimit, LateCollLatched, DeferLatched, RstDeferLatched, CarrierSenseLost\n\n    \n`ifdef ETH_BIST\n    ,\n    \n    mbist_si_i,       \n    mbist_so_o,       \n    mbist_ctrl_i        \n`endif\n    \n\n\n\t\t);\n\n\nparameter Tp = 1;\n\n\n\ninput           WB_CLK_I;       \ninput  [31:0]   WB_DAT_I;       \noutput [31:0]   WB_DAT_O;       \n\n\ninput   [9:2]   WB_ADR_I;       \ninput           WB_WE_I;        \ninput   [3:0]   BDCs;           \noutput          WB_ACK_O;       \n\n\noutput  [29:0]  m_wb_adr_o;     \noutput   [3:0]  m_wb_sel_o;     \noutput          m_wb_we_o;      \noutput  [31:0]  m_wb_dat_o;     \noutput          m_wb_cyc_o;     \noutput          m_wb_stb_o;     \ninput   [31:0]  m_wb_dat_i;     \ninput           m_wb_ack_i;     \ninput           m_wb_err_i;     \n\n`ifdef ETH_WISHBONE_B3\noutput   [2:0]  m_wb_cti_o;     \noutput   [1:0]  m_wb_bte_o;     \nreg      [2:0]  m_wb_cti_o;     \n`endif\n\ninput           Reset;       \n\n\ninput           InvalidSymbol;    \ninput           LatchedCrcError;  \ninput           RxLateCollision;  \ninput           ShortFrame;       \ninput           DribbleNibble;    \ninput           ReceivedPacketTooBig;\ninput    [15:0] RxLength;         \ninput           LoadRxStatus;     \ninput           ReceivedPacketGood;\ninput           AddressMiss;      \ninput           r_RxFlow;\ninput           r_PassAll;\ninput           ReceivedPauseFrm;\n\n\ninput     [3:0] RetryCntLatched;  \ninput           RetryLimit;       \ninput           LateCollLatched;  \ninput           DeferLatched;     \noutput          RstDeferLatched;\ninput           CarrierSenseLost; \n\n\ninput           MTxClk;         \ninput           TxUsedData;     \ninput           TxRetry;        \ninput           TxAbort;        \ninput           TxDone;         \noutput          TxStartFrm;     \noutput          TxEndFrm;       \noutput  [7:0]   TxData;         \noutput          TxUnderRun;     \noutput          PerPacketCrcEn; \noutput          PerPacketPad;   \n\n\ninput           MRxClk;         \ninput   [7:0]   RxData;         \ninput           RxValid;        \ninput           RxStartFrm;     \ninput           RxEndFrm;       \ninput           RxAbort;        \noutput          RxStatusWriteLatched_sync2;\n\n\ninput           r_TxEn;         \ninput           r_RxEn;         \ninput   [7:0]   r_TxBDNum;      \n\n\noutput TxB_IRQ;\noutput TxE_IRQ;\noutput RxB_IRQ;\noutput RxE_IRQ;\noutput Busy_IRQ;\n\n\n\n`ifdef ETH_BIST\ninput   mbist_si_i;       \noutput  mbist_so_o;       \ninput [`ETH_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i;       \n`endif\n\nreg TxB_IRQ;\nreg TxE_IRQ;\nreg RxB_IRQ;\nreg RxE_IRQ;\n\nreg             TxStartFrm;\nreg             TxEndFrm;\nreg     [7:0]   TxData;\n\nreg             TxUnderRun;\nreg             TxUnderRun_wb;\n\nreg             TxBDRead;\nwire            TxStatusWrite;\n\nreg     [1:0]   TxValidBytesLatched;\n\nreg    [15:0]   TxLength;\nreg    [15:0]   LatchedTxLength;\nreg   [14:11]   TxStatus;\n\nreg   [14:13]   RxStatus;\nwire  [14:13]   RxStatus_s;\n\nreg             TxStartFrm_wb;\nreg             TxRetry_wb;\nreg             TxAbort_wb;\nreg             TxDone_wb;\n\nreg             TxDone_wb_q;\nreg             TxAbort_wb_q;\nreg             TxRetry_wb_q;\nreg             TxRetryPacket;\nreg             TxRetryPacket_NotCleared;\nreg             TxDonePacket;\nreg             TxDonePacket_NotCleared;\nreg             TxAbortPacket;\nreg             TxAbortPacket_NotCleared;\nreg             RxBDReady;\nreg             RxReady;\nreg             TxBDReady;\n\nreg             RxBDRead;\n\nreg    [31:0]   TxDataLatched;\nreg     [1:0]   TxByteCnt;\nreg             LastWord;\nreg             ReadTxDataFromFifo_tck;\n\nreg             BlockingTxStatusWrite;\nreg             BlockingTxBDRead;\n\nreg             Flop;\n\nreg     [7:1]   TxBDAddress;\nreg     [7:1]   RxBDAddress;\n\nreg             TxRetrySync1;\nreg             TxAbortSync1;\nreg             TxDoneSync1;\n\nreg             TxAbort_q;\nreg             TxRetry_q;\nreg             TxUsedData_q;\n\nreg    [31:0]   RxDataLatched2;\n\nreg    [31:8]   RxDataLatched1;     \n\nreg     [1:0]   RxValidBytes;\nreg     [1:0]   RxByteCnt;\nreg             LastByteIn;\nreg             ShiftWillEnd;\n\nreg             WriteRxDataToFifo;\nreg    [15:0]   LatchedRxLength;\nreg             RxAbortLatched;\n\nreg             ShiftEnded;\nreg             RxOverrun;\n\nreg     [3:0]   BDWrite;                    \nreg             BDRead;                     \nwire   [31:0]   RxBDDataIn;                 \nwire   [31:0]   TxBDDataIn;                 \n\nreg             TxEndFrm_wb;\n\nwire            TxRetryPulse;\nwire            TxDonePulse;\nwire            TxAbortPulse;\n\nwire            StartRxBDRead;\n\nwire            StartTxBDRead;\n\nwire            TxIRQEn;\nwire            WrapTxStatusBit;\n\nwire            RxIRQEn;\nwire            WrapRxStatusBit;\n\nwire    [1:0]   TxValidBytes;\n\nwire    [7:1]   TempTxBDAddress;\nwire    [7:1]   TempRxBDAddress;\n\nwire            RxStatusWrite;\nwire            RxBufferFull;\nwire            RxBufferAlmostEmpty;\nwire            RxBufferEmpty;\n\nreg             WB_ACK_O;\n\nwire    [8:0]   RxStatusIn;\nreg     [8:0]   RxStatusInLatched;\n\nreg WbEn, WbEn_q;\nreg RxEn, RxEn_q;\nreg TxEn, TxEn_q;\nreg r_TxEn_q;\nreg r_RxEn_q;\n\nwire ram_ce;\nwire [3:0]  ram_we;\nwire ram_oe;\nreg [7:0]   ram_addr;\nreg [31:0]  ram_di;\nwire [31:0] ram_do;\n\nwire StartTxPointerRead;\nreg  TxPointerRead;\nreg TxEn_needed;\nreg RxEn_needed;\n\nwire StartRxPointerRead;\nreg RxPointerRead; \n\n`ifdef ETH_WISHBONE_B3\nassign m_wb_bte_o = 2'b00;    \n`endif\n\nassign m_wb_stb_o = m_wb_cyc_o;\n\nalways @ (posedge WB_CLK_I)\nbegin\n  WB_ACK_O <=#Tp (|BDWrite) & WbEn & WbEn_q | BDRead & WbEn & ~WbEn_q;\nend\n\nassign WB_DAT_O = ram_do;\n\n\neth_spram_256x32 bd_ram (\n\t.clk(WB_CLK_I), .rst(Reset), .ce(ram_ce), .we(ram_we), .oe(ram_oe), .addr(ram_addr), .di(ram_di), .do(ram_do)\n`ifdef ETH_BIST\n  ,\n  .mbist_si_i       (mbist_si_i),\n  .mbist_so_o       (mbist_so_o),\n  .mbist_ctrl_i       (mbist_ctrl_i)\n`endif\n);\n\nassign ram_ce = 1'b1;\nassign ram_we = (BDWrite & {4{(WbEn & WbEn_q)}}) | {4{(TxStatusWrite | RxStatusWrite)}};\nassign ram_oe = BDRead & WbEn & WbEn_q | TxEn & TxEn_q & (TxBDRead | TxPointerRead) | RxEn & RxEn_q & (RxBDRead | RxPointerRead);\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxEn_needed <=#Tp 1'b0;\n  else\n  if(~TxBDReady & r_TxEn & WbEn & ~WbEn_q)\n    TxEn_needed <=#Tp 1'b1;\n  else\n  if(TxPointerRead & TxEn & TxEn_q)\n    TxEn_needed <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      WbEn <=#Tp 1'b1;\n      RxEn <=#Tp 1'b0;\n      TxEn <=#Tp 1'b0;\n      ram_addr <=#Tp 8'h0;\n      ram_di <=#Tp 32'h0;\n      BDRead <=#Tp 1'b0;\n      BDWrite <=#Tp 1'b0;\n    end\n  else\n    begin\n      \n      case ({WbEn_q, RxEn_q, TxEn_q, RxEn_needed, TxEn_needed})  \n        5'b100_10, 5'b100_11 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b1;  \n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp {RxBDAddress, RxPointerRead};\n            ram_di <=#Tp RxBDDataIn;\n          end\n        5'b100_01 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b1;  \n            ram_addr <=#Tp {TxBDAddress, TxPointerRead};\n            ram_di <=#Tp TxBDDataIn;\n          end\n        5'b010_00, 5'b010_10 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n        5'b010_01, 5'b010_11 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b1;  \n            ram_addr <=#Tp {TxBDAddress, TxPointerRead};\n            ram_di <=#Tp TxBDDataIn;\n          end\n        5'b001_00, 5'b001_01, 5'b001_10, 5'b001_11 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n        5'b100_00 :\n          begin\n            WbEn <=#Tp 1'b0;  \n          end\n        5'b000_00 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n      endcase\n    end\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      WbEn_q <=#Tp 1'b0;\n      RxEn_q <=#Tp 1'b0;\n      TxEn_q <=#Tp 1'b0;\n      r_TxEn_q <=#Tp 1'b0;\n      r_RxEn_q <=#Tp 1'b0;\n    end\n  else\n    begin\n      WbEn_q <=#Tp WbEn;\n      RxEn_q <=#Tp RxEn;\n      TxEn_q <=#Tp TxEn;\n      r_TxEn_q <=#Tp r_TxEn;\n      r_RxEn_q <=#Tp r_RxEn;\n    end\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    Flop <=#Tp 1'b0;\n  else\n  if(TxDone | TxAbort | TxRetry_q)\n    Flop <=#Tp 1'b0;\n  else\n  if(TxUsedData)\n    Flop <=#Tp ~Flop;\nend\n\nwire ResetTxBDReady;\nassign ResetTxBDReady = TxDonePulse | TxAbortPulse | TxRetryPulse;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDReady <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxBDReady <=#Tp ram_do[15] & (ram_do[31:16] > 4); \n  else                                                \n  if(ResetTxBDReady)\n    TxBDReady <=#Tp 1'b0;\nend\n\n\n\nassign StartTxBDRead = (TxRetryPacket_NotCleared | TxStatusWrite) & ~BlockingTxBDRead & ~TxBDReady;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDRead <=#Tp 1'b1;\n  else\n  if(StartTxBDRead)\n    TxBDRead <=#Tp 1'b1;\n  else\n  if(TxBDReady)\n    TxBDRead <=#Tp 1'b0;\nend\n\n\n\nassign StartTxPointerRead = TxBDRead & TxBDReady;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerRead <=#Tp 1'b0;\n  else\n  if(StartTxPointerRead)\n    TxPointerRead <=#Tp 1'b1;\n  else\n  if(TxEn_q)\n    TxPointerRead <=#Tp 1'b0;\nend\n\n\n\nassign TxStatusWrite = (TxDonePacket_NotCleared | TxAbortPacket_NotCleared) & TxEn & TxEn_q & ~BlockingTxStatusWrite;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite <=#Tp 1'b0;\n  else\n  if(~TxDone_wb & ~TxAbort_wb)\n    BlockingTxStatusWrite <=#Tp 1'b0;\n  else\n  if(TxStatusWrite)\n    BlockingTxStatusWrite <=#Tp 1'b1;\nend\n\n\nreg BlockingTxStatusWrite_sync1;\nreg BlockingTxStatusWrite_sync2;\nreg BlockingTxStatusWrite_sync3;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync1 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync1 <=#Tp BlockingTxStatusWrite;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync2 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync2 <=#Tp BlockingTxStatusWrite_sync1;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync3 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync3 <=#Tp BlockingTxStatusWrite_sync2;\nend\n\nassign RstDeferLatched = BlockingTxStatusWrite_sync2 & ~BlockingTxStatusWrite_sync3;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxBDRead <=#Tp 1'b0;\n  else\n  if(StartTxBDRead)\n    BlockingTxBDRead <=#Tp 1'b1;\n  else\n  if(~StartTxBDRead & ~TxBDReady)\n    BlockingTxBDRead <=#Tp 1'b0;\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStatus <=#Tp 4'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxStatus <=#Tp ram_do[14:11];\nend\n\nreg ReadTxDataFromMemory;\nwire WriteRxDataToMemory;\n\nreg MasterWbTX;\nreg MasterWbRX;\n\nreg [29:0] m_wb_adr_o;\nreg        m_wb_cyc_o;\nreg  [3:0] m_wb_sel_o;\nreg        m_wb_we_o;\n\nwire TxLengthEq0;\nwire TxLengthLt4;\n\nreg BlockingIncrementTxPointer;\nreg [31:2] TxPointerMSB;\nreg [1:0]  TxPointerLSB;\nreg [1:0]  TxPointerLSB_rst;\nreg [31:2] RxPointerMSB;\nreg [1:0]  RxPointerLSB_rst;\n\nwire RxBurstAcc;\nwire RxWordAcc;\nwire RxHalfAcc;\nwire RxByteAcc;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxLength <=#Tp 16'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxLength <=#Tp ram_do[31:16];\n  else\n  if(MasterWbTX & m_wb_ack_i)\n    begin\n      if(TxLengthLt4)\n        TxLength <=#Tp 16'h0;\n      else\n      if(TxPointerLSB_rst==2'h0)\n        TxLength <=#Tp TxLength - 3'h4;    \n      else\n      if(TxPointerLSB_rst==2'h1)\n        TxLength <=#Tp TxLength - 3'h3;    \n      else\n      if(TxPointerLSB_rst==2'h2)\n        TxLength <=#Tp TxLength - 3'h2;    \n      else\n      if(TxPointerLSB_rst==2'h3)\n        TxLength <=#Tp TxLength - 3'h1;    \n    end\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchedTxLength <=#Tp 16'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    LatchedTxLength <=#Tp ram_do[31:16];\nend\n\nassign TxLengthEq0 = TxLength == 0;\nassign TxLengthLt4 = TxLength < 4;\n\nreg cyc_cleared;\nreg IncrTxPointer;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerMSB <=#Tp 30'h0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerMSB <=#Tp ram_do[31:2];\n  else\n  if(IncrTxPointer & ~BlockingIncrementTxPointer)\n    TxPointerMSB <=#Tp TxPointerMSB + 1'b1;     \nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerLSB[1:0] <=#Tp 0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerLSB[1:0] <=#Tp ram_do[1:0];\nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerLSB_rst[1:0] <=#Tp ram_do[1:0];\n  else\n  if(MasterWbTX & m_wb_ack_i)                 \n    TxPointerLSB_rst[1:0] <=#Tp 0;\nend\n\n\nreg  [3:0] RxByteSel;\nwire MasterAccessFinished;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingIncrementTxPointer <=#Tp 0;\n  else\n  if(MasterAccessFinished)\n    BlockingIncrementTxPointer <=#Tp 0;\n  else\n  if(IncrTxPointer)\n    BlockingIncrementTxPointer <=#Tp 1'b1;\nend\n\n\nwire TxBufferAlmostFull;\nwire TxBufferFull;\nwire TxBufferEmpty;\nwire TxBufferAlmostEmpty;\nwire SetReadTxDataFromMemory;\n\nreg BlockReadTxDataFromMemory;\n\nassign SetReadTxDataFromMemory = TxEn & TxEn_q & TxPointerRead;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if(TxLengthEq0 | TxAbortPulse | TxRetryPulse)\n    ReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if(SetReadTxDataFromMemory)\n    ReadTxDataFromMemory <=#Tp 1'b1;\nend\n\nreg tx_burst_en;\nreg rx_burst_en;\n\nwire ReadTxDataFromMemory_2 = ReadTxDataFromMemory & ~BlockReadTxDataFromMemory;\nwire tx_burst = ReadTxDataFromMemory_2 & tx_burst_en;\n\nwire [31:0] TxData_wb;\nwire ReadTxDataFromFifo_wb;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if((TxBufferAlmostFull | TxLength <= 4)& MasterWbTX & (~cyc_cleared) & (!(TxAbortPacket_NotCleared | TxRetryPacket_NotCleared)))\n    BlockReadTxDataFromMemory <=#Tp 1'b1;\n  else\n  if(ReadTxDataFromFifo_wb | TxDonePacket | TxAbortPacket | TxRetryPacket)\n    BlockReadTxDataFromMemory <=#Tp 1'b0;\nend\n\n\nassign MasterAccessFinished = m_wb_ack_i | m_wb_err_i;\nwire [`ETH_TX_FIFO_CNT_WIDTH-1:0] txfifo_cnt;\nwire [`ETH_RX_FIFO_CNT_WIDTH-1:0] rxfifo_cnt;\nreg  [`ETH_BURST_CNT_WIDTH-1:0] tx_burst_cnt;\nreg  [`ETH_BURST_CNT_WIDTH-1:0] rx_burst_cnt;\n\nwire rx_burst;\nwire enough_data_in_rxfifo_for_burst;\nwire enough_data_in_rxfifo_for_burst_plus1;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      MasterWbTX <=#Tp 1'b0;\n      MasterWbRX <=#Tp 1'b0;\n      m_wb_adr_o <=#Tp 30'h0;\n      m_wb_cyc_o <=#Tp 1'b0;\n      m_wb_we_o  <=#Tp 1'b0;\n      m_wb_sel_o <=#Tp 4'h0;\n      cyc_cleared<=#Tp 1'b0;\n      tx_burst_cnt<=#Tp 0;\n      rx_burst_cnt<=#Tp 0;\n      IncrTxPointer<=#Tp 1'b0;\n      tx_burst_en<=#Tp 1'b1;\n      rx_burst_en<=#Tp 1'b0;\n      `ifdef ETH_WISHBONE_B3\n        m_wb_cti_o <=#Tp 3'b0;\n      `endif\n    end\n  else\n    begin\n      \n      casex ({MasterWbTX, MasterWbRX, ReadTxDataFromMemory_2, WriteRxDataToMemory, MasterAccessFinished, cyc_cleared, tx_burst, rx_burst})  \n        8'b00_10_00_10,             \n        8'b10_1x_10_1x,             \n        8'b10_10_01_10,             \n        8'b01_1x_01_1x :            \n          begin\n            MasterWbTX <=#Tp 1'b1;  \n            MasterWbRX <=#Tp 1'b0;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b1;\n            tx_burst_cnt <=#Tp tx_burst_cnt+3'h1;\n            if(tx_burst_cnt==0)\n              m_wb_adr_o <=#Tp TxPointerMSB;\n            else\n              m_wb_adr_o <=#Tp m_wb_adr_o+1'b1;\n\n            if(tx_burst_cnt==(`ETH_BURST_LENGTH-1))\n              begin\n                tx_burst_en<=#Tp 1'b0;\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b111;\n              `endif\n              end\n            else\n              begin\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b010;\n              `endif\n              end\n          end\n        8'b00_x1_00_x1,             \n        8'b01_x1_10_x1,             \n        8'b01_01_01_01,             \n        8'b10_x1_01_x1 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;  \n            MasterWbRX <=#Tp 1'b1;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            IncrTxPointer<=#Tp 1'b0;\n            cyc_cleared<=#Tp 1'b0;\n            rx_burst_cnt <=#Tp rx_burst_cnt+3'h1;\n\n            if(rx_burst_cnt==0)\n              m_wb_adr_o <=#Tp RxPointerMSB;\n            else\n              m_wb_adr_o <=#Tp m_wb_adr_o+1'b1;\n\n            if(rx_burst_cnt==(`ETH_BURST_LENGTH-1))\n              begin\n                rx_burst_en<=#Tp 1'b0;\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b111;\n              `endif\n              end\n            else\n              begin\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b010;\n              `endif\n              end\n          end\n        8'b00_x1_00_x0 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b1;\n            m_wb_adr_o <=#Tp RxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            IncrTxPointer<=#Tp 1'b0;\n          end\n        8'b00_10_00_00 :            \n          begin\n            MasterWbTX <=#Tp 1'b1;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_adr_o <=#Tp TxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            IncrTxPointer<=#Tp 1'b1;\n          end\n        8'b10_10_01_00,             \n        8'b01_1x_01_0x  :           \n          begin\n            MasterWbTX <=#Tp 1'b1;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_adr_o <=#Tp TxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b1;\n          end\n        8'b01_01_01_00,             \n        8'b10_x1_01_x0  :           \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b1;\n            m_wb_adr_o <=#Tp RxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b0;\n          end\n        8'b01_01_10_00,             \n        8'b01_1x_10_x0,             \n        8'b10_10_10_00,             \n        8'b10_x1_10_0x :            \n          begin\n            m_wb_cyc_o <=#Tp 1'b0;  \n            cyc_cleared<=#Tp 1'b1;\n            IncrTxPointer<=#Tp 1'b0;\n            tx_burst_cnt<=#Tp 0;\n            tx_burst_en<=#Tp txfifo_cnt<(`ETH_TX_FIFO_DEPTH-`ETH_BURST_LENGTH) & (TxLength>(`ETH_BURST_LENGTH*4+4));\n            rx_burst_cnt<=#Tp 0;\n            rx_burst_en<=#Tp MasterWbRX ? enough_data_in_rxfifo_for_burst_plus1 : enough_data_in_rxfifo_for_burst;  \n            `ifdef ETH_WISHBONE_B3\n              m_wb_cti_o <=#Tp 3'b0;\n            `endif\n          end\n        8'bxx_00_10_00,             \n        8'bxx_00_01_00 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_cyc_o <=#Tp 1'b0;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b0;\n            rx_burst_cnt<=#Tp 0;\n            rx_burst_en<=#Tp MasterWbRX ? enough_data_in_rxfifo_for_burst_plus1 : enough_data_in_rxfifo_for_burst;  \n            `ifdef ETH_WISHBONE_B3\n              m_wb_cti_o <=#Tp 3'b0;\n            `endif\n          end\n        8'b00_00_00_00:             \n          begin\n            tx_burst_cnt<=#Tp 0;\n            tx_burst_en<=#Tp txfifo_cnt<(`ETH_TX_FIFO_DEPTH-`ETH_BURST_LENGTH) & (TxLength>(`ETH_BURST_LENGTH*4+4));\n          end\n        default:                    \n          begin\n            MasterWbTX <=#Tp MasterWbTX;\n            MasterWbRX <=#Tp MasterWbRX;\n            m_wb_cyc_o <=#Tp m_wb_cyc_o;\n            m_wb_sel_o <=#Tp m_wb_sel_o;\n            IncrTxPointer<=#Tp IncrTxPointer;\n          end\n      endcase\n    end\nend\n\n\nwire TxFifoClear;\n\nassign TxFifoClear = (TxAbortPacket | TxRetryPacket);\n\neth_fifo #(`ETH_TX_FIFO_DATA_WIDTH, `ETH_TX_FIFO_DEPTH, `ETH_TX_FIFO_CNT_WIDTH)\ntx_fifo ( .data_in(m_wb_dat_i),                             .data_out(TxData_wb), \n          .clk(WB_CLK_I),                                   .reset(Reset), \n          .write(MasterWbTX & m_wb_ack_i),                  .read(ReadTxDataFromFifo_wb & ~TxBufferEmpty),\n          .clear(TxFifoClear),                              .full(TxBufferFull), \n          .almost_full(TxBufferAlmostFull),                 .almost_empty(TxBufferAlmostEmpty), \n          .empty(TxBufferEmpty),                            .cnt(txfifo_cnt)\n        );\n\n\nreg StartOccured;\nreg TxStartFrm_sync1;\nreg TxStartFrm_sync2;\nreg TxStartFrm_syncb1;\nreg TxStartFrm_syncb2;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_wb <=#Tp 1'b0;\n  else\n  if(TxBDReady & ~StartOccured & (TxBufferFull | TxLengthEq0))\n    TxStartFrm_wb <=#Tp 1'b1;\n  else\n  if(TxStartFrm_syncb2)\n    TxStartFrm_wb <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    StartOccured <=#Tp 1'b0;\n  else\n  if(TxStartFrm_wb)\n    StartOccured <=#Tp 1'b1;\n  else\n  if(ResetTxBDReady)\n    StartOccured <=#Tp 1'b0;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_sync1 <=#Tp 1'b0;\n  else\n    TxStartFrm_sync1 <=#Tp TxStartFrm_wb;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_sync2 <=#Tp 1'b0;\n  else\n    TxStartFrm_sync2 <=#Tp TxStartFrm_sync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_syncb1 <=#Tp 1'b0;\n  else\n    TxStartFrm_syncb1 <=#Tp TxStartFrm_sync2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_syncb2 <=#Tp 1'b0;\n  else\n    TxStartFrm_syncb2 <=#Tp TxStartFrm_syncb1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm <=#Tp 1'b0;\n  else\n  if(TxStartFrm_sync2)\n    TxStartFrm <=#Tp 1'b1;\n  else\n  if(TxUsedData_q | ~TxStartFrm_sync2 & (TxRetry & (~TxRetry_q) | TxAbort & (~TxAbort_q)))\n    TxStartFrm <=#Tp 1'b0;\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxEndFrm_wb <=#Tp 1'b0;\n  else\n  if(TxLengthEq0 & TxBufferAlmostEmpty & TxUsedData)\n    TxEndFrm_wb <=#Tp 1'b1;\n  else\n  if(TxRetryPulse | TxDonePulse | TxAbortPulse)\n    TxEndFrm_wb <=#Tp 1'b0;\nend\n\n\n\nassign TxValidBytes = TxLengthLt4 ? TxLength[1:0] : 2'b0;\n\nreg LatchValidBytes;\nreg LatchValidBytes_q;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchValidBytes <=#Tp 1'b0;\n  else\n  if(TxLengthLt4 & TxBDReady)\n    LatchValidBytes <=#Tp 1'b1;\n  else\n    LatchValidBytes <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchValidBytes_q <=#Tp 1'b0;\n  else\n    LatchValidBytes_q <=#Tp LatchValidBytes;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxValidBytesLatched <=#Tp 2'h0;\n  else\n  if(LatchValidBytes & ~LatchValidBytes_q)\n    TxValidBytesLatched <=#Tp TxValidBytes;\n  else\n  if(TxRetryPulse | TxDonePulse | TxAbortPulse)\n    TxValidBytesLatched <=#Tp 2'h0;\nend\n\n\nassign TxIRQEn          = TxStatus[14];\nassign WrapTxStatusBit  = TxStatus[13];\nassign PerPacketPad     = TxStatus[12];\nassign PerPacketCrcEn   = TxStatus[11];\n\n\nassign RxIRQEn         = RxStatus_s[14];\nassign WrapRxStatusBit = RxStatus_s[13];\n\n\n\nassign TempTxBDAddress[7:1] = {7{ TxStatusWrite     & ~WrapTxStatusBit}}   & (TxBDAddress + 1'b1) ; \nassign TempRxBDAddress[7:1] = {7{ WrapRxStatusBit}} & (r_TxBDNum[6:0])     | \n                              {7{~WrapRxStatusBit}} & (RxBDAddress + 1'b1) ; \n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDAddress <=#Tp 7'h0;\n  else if (r_TxEn & (~r_TxEn_q))\n    TxBDAddress <=#Tp 7'h0;\n  else if (TxStatusWrite)\n    TxBDAddress <=#Tp TempTxBDAddress;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDAddress <=#Tp 7'h0;\n  else if(r_RxEn & (~r_RxEn_q))\n    RxBDAddress <=#Tp r_TxBDNum[6:0];\n  else if(RxStatusWrite)\n    RxBDAddress <=#Tp TempRxBDAddress;\nend\n\nwire [8:0] TxStatusInLatched = {TxUnderRun, RetryCntLatched[3:0], RetryLimit, LateCollLatched, DeferLatched, CarrierSenseLost};\n\nassign RxBDDataIn = {LatchedRxLength, 1'b0, RxStatus_s, 4'h0, RxStatusInLatched};\nassign TxBDDataIn = {LatchedTxLength, 1'b0, TxStatus, 2'h0, TxStatusInLatched};\n\n\n\nassign TxRetryPulse   = TxRetry_wb   & ~TxRetry_wb_q;\nassign TxDonePulse    = TxDone_wb    & ~TxDone_wb_q;\nassign TxAbortPulse   = TxAbort_wb   & ~TxAbort_wb_q;\n\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      TxAbort_q      <=#Tp 1'b0;\n      TxRetry_q      <=#Tp 1'b0;\n      TxUsedData_q   <=#Tp 1'b0;\n    end\n  else\n    begin\n      TxAbort_q      <=#Tp TxAbort;\n      TxRetry_q      <=#Tp TxRetry;\n      TxUsedData_q   <=#Tp TxUsedData;\n    end\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      TxDone_wb_q   <=#Tp 1'b0;\n      TxAbort_wb_q  <=#Tp 1'b0;\n      TxRetry_wb_q  <=#Tp 1'b0;\n    end\n  else\n    begin\n      TxDone_wb_q   <=#Tp TxDone_wb;\n      TxAbort_wb_q  <=#Tp TxAbort_wb;\n      TxRetry_wb_q  <=#Tp TxRetry_wb;\n    end\nend\n\n\nreg TxAbortPacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacket <=#Tp 1'b0;\n  else\n  if(TxAbort_wb & (~tx_burst_en) & MasterWbTX & MasterAccessFinished & (~TxAbortPacketBlocked) |\n     TxAbort_wb & (~MasterWbTX) & (~TxAbortPacketBlocked))\n    TxAbortPacket <=#Tp 1'b1;\n  else\n    TxAbortPacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxAbortPacket_NotCleared)\n    TxAbortPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxAbort_wb & (~tx_burst_en) & MasterWbTX & MasterAccessFinished & (~TxAbortPacketBlocked) |\n     TxAbort_wb & (~MasterWbTX) & (~TxAbortPacketBlocked))\n    TxAbortPacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxAbort_wb & TxAbort_wb_q)\n    TxAbortPacketBlocked <=#Tp 1'b0;\n  else\n  if(TxAbortPacket)\n    TxAbortPacketBlocked <=#Tp 1'b1;\nend\n\n\nreg TxRetryPacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacket <=#Tp 1'b0;\n  else\n  if(TxRetry_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxRetryPacketBlocked | \n     TxRetry_wb & !MasterWbTX & !TxRetryPacketBlocked)\n    TxRetryPacket <=#Tp 1'b1;\n  else\n    TxRetryPacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(StartTxBDRead)\n    TxRetryPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxRetry_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxRetryPacketBlocked | \n     TxRetry_wb & !MasterWbTX & !TxRetryPacketBlocked)\n    TxRetryPacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxRetry_wb & TxRetry_wb_q)\n    TxRetryPacketBlocked <=#Tp 1'b0;\n  else\n  if(TxRetryPacket)\n    TxRetryPacketBlocked <=#Tp 1'b1;\nend\n\n\nreg TxDonePacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacket <=#Tp 1'b0;\n  else\n  if(TxDone_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxDonePacketBlocked | \n     TxDone_wb & !MasterWbTX & !TxDonePacketBlocked)\n    TxDonePacket <=#Tp 1'b1;\n  else\n    TxDonePacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxDonePacket_NotCleared)\n    TxDonePacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxDone_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & (~TxDonePacketBlocked) | \n     TxDone_wb & !MasterWbTX & (~TxDonePacketBlocked))\n    TxDonePacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxDone_wb & TxDone_wb_q)\n    TxDonePacketBlocked <=#Tp 1'b0;\n  else\n  if(TxDonePacket)\n    TxDonePacketBlocked <=#Tp 1'b1;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    LastWord <=#Tp 1'b0;\n  else\n  if((TxEndFrm | TxAbort | TxRetry) & Flop)\n    LastWord <=#Tp 1'b0;\n  else\n  if(TxUsedData & Flop & TxByteCnt == 2'h3)\n    LastWord <=#Tp TxEndFrm_wb;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxEndFrm <=#Tp 1'b0;\n  else\n  if(Flop & TxEndFrm | TxAbort | TxRetry_q)\n    TxEndFrm <=#Tp 1'b0;        \n  else\n  if(Flop & LastWord)\n    begin\n      case (TxValidBytesLatched)  \n        1 : TxEndFrm <=#Tp TxByteCnt == 2'h0;\n        2 : TxEndFrm <=#Tp TxByteCnt == 2'h1;\n        3 : TxEndFrm <=#Tp TxByteCnt == 2'h2;\n        0 : TxEndFrm <=#Tp TxByteCnt == 2'h3;\n        default : TxEndFrm <=#Tp 1'b0;\n      endcase\n    end\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxData <=#Tp 0;\n  else\n  if(TxStartFrm_sync2 & ~TxStartFrm)\n    case(TxPointerLSB)  \n      2'h0 : TxData <=#Tp TxData_wb[31:24];                  \n      2'h1 : TxData <=#Tp TxData_wb[23:16];                  \n      2'h2 : TxData <=#Tp TxData_wb[15:08];                  \n      2'h3 : TxData <=#Tp TxData_wb[07:00];                  \n    endcase\n  else\n  if(TxStartFrm & TxUsedData & TxPointerLSB==2'h3)\n    TxData <=#Tp TxData_wb[31:24];                           \n  else\n  if(TxUsedData & Flop)\n    begin\n      case(TxByteCnt)  \n        0 : TxData <=#Tp TxDataLatched[31:24];               \n        1 : TxData <=#Tp TxDataLatched[23:16];\n        2 : TxData <=#Tp TxDataLatched[15:8];\n        3 : TxData <=#Tp TxDataLatched[7:0];\n      endcase\n    end\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxDataLatched[31:0] <=#Tp 32'h0;\n  else\n if(TxStartFrm_sync2 & ~TxStartFrm | TxUsedData & Flop & TxByteCnt == 2'h3 | TxStartFrm & TxUsedData & Flop & TxByteCnt == 2'h0)\n    TxDataLatched[31:0] <=#Tp TxData_wb[31:0];\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun_wb <=#Tp 1'b0;\n  else\n  if(TxAbortPulse)\n    TxUnderRun_wb <=#Tp 1'b0;\n  else\n  if(TxBufferEmpty & ReadTxDataFromFifo_wb)\n    TxUnderRun_wb <=#Tp 1'b1;\nend\n\n\nreg TxUnderRun_sync1;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun_sync1 <=#Tp 1'b0;\n  else\n  if(TxUnderRun_wb)\n    TxUnderRun_sync1 <=#Tp 1'b1;\n  else\n  if(BlockingTxStatusWrite_sync2)\n    TxUnderRun_sync1 <=#Tp 1'b0;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun <=#Tp 1'b0;\n  else\n  if(BlockingTxStatusWrite_sync2)\n    TxUnderRun <=#Tp 1'b0;\n  else\n  if(TxUnderRun_sync1)\n    TxUnderRun <=#Tp 1'b1;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxByteCnt <=#Tp 2'h0;\n  else\n  if(TxAbort_q | TxRetry_q)\n    TxByteCnt <=#Tp 2'h0;\n  else\n  if(TxStartFrm & ~TxUsedData)\n    case(TxPointerLSB)  \n      2'h0 : TxByteCnt <=#Tp 2'h1;\n      2'h1 : TxByteCnt <=#Tp 2'h2;\n      2'h2 : TxByteCnt <=#Tp 2'h3;\n      2'h3 : TxByteCnt <=#Tp 2'h0;\n    endcase\n  else\n  if(TxUsedData & Flop)\n    TxByteCnt <=#Tp TxByteCnt + 1'b1;\nend\n\n\n\nreg ReadTxDataFromFifo_sync1;\nreg ReadTxDataFromFifo_sync2;\nreg ReadTxDataFromFifo_sync3;\nreg ReadTxDataFromFifo_syncb1;\nreg ReadTxDataFromFifo_syncb2;\nreg ReadTxDataFromFifo_syncb3;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_tck <=#Tp 1'b0;\n  else\n  if(TxStartFrm_sync2 & ~TxStartFrm | TxUsedData & Flop & TxByteCnt == 2'h3 & ~LastWord | TxStartFrm & TxUsedData & Flop & TxByteCnt == 2'h0)\n     ReadTxDataFromFifo_tck <=#Tp 1'b1;\n  else\n  if(ReadTxDataFromFifo_syncb2 & ~ReadTxDataFromFifo_syncb3)\n    ReadTxDataFromFifo_tck <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync1 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync1 <=#Tp ReadTxDataFromFifo_tck;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync2 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync2 <=#Tp ReadTxDataFromFifo_sync1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb1 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb1 <=#Tp ReadTxDataFromFifo_sync2;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb2 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb2 <=#Tp ReadTxDataFromFifo_syncb1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb3 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb3 <=#Tp ReadTxDataFromFifo_syncb2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync3 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync3 <=#Tp ReadTxDataFromFifo_sync2;\nend\n\nassign ReadTxDataFromFifo_wb = ReadTxDataFromFifo_sync2 & ~ReadTxDataFromFifo_sync3;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetrySync1 <=#Tp 1'b0;\n  else\n    TxRetrySync1 <=#Tp TxRetry;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetry_wb <=#Tp 1'b0;\n  else\n    TxRetry_wb <=#Tp TxRetrySync1;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDoneSync1 <=#Tp 1'b0;\n  else\n    TxDoneSync1 <=#Tp TxDone;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDone_wb <=#Tp 1'b0;\n  else\n    TxDone_wb <=#Tp TxDoneSync1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortSync1 <=#Tp 1'b0;\n  else\n    TxAbortSync1 <=#Tp TxAbort;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbort_wb <=#Tp 1'b0;\n  else\n    TxAbort_wb <=#Tp TxAbortSync1;\nend\n\n\nreg RxAbortSync1;\nreg RxAbortSync2;\nreg RxAbortSync3;\nreg RxAbortSync4;\nreg RxAbortSyncb1;\nreg RxAbortSyncb2;\n\nassign StartRxBDRead = RxStatusWrite | RxAbortSync3 & ~RxAbortSync4 | r_RxEn & ~r_RxEn_q;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDRead <=#Tp 1'b0;\n  else\n  if(StartRxBDRead & ~RxReady)\n    RxBDRead <=#Tp 1'b1;\n  else\n  if(RxBDReady)\n    RxBDRead <=#Tp 1'b0;\nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDReady <=#Tp 1'b0;\n  else\n  if(RxPointerRead)\n    RxBDReady <=#Tp 1'b0;\n  else\n  if(RxEn & RxEn_q & RxBDRead)\n    RxBDReady <=#Tp ram_do[15]; \nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxStatus <=#Tp 2'h0;\n  else\n  if(RxEn & RxEn_q & RxBDRead)\n    RxStatus <=#Tp ram_do[14:13];\nend\n\n\nassign RxStatus_s = (RxEn & RxEn_q & RxBDRead) ? ram_do[14:13] : RxStatus;\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxReady <=#Tp 1'b0;\n  else\n  if(ShiftEnded | RxAbortSync2 & ~RxAbortSync3 | ~r_RxEn & r_RxEn_q)\n    RxReady <=#Tp 1'b0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxReady <=#Tp 1'b1;\nend\n\n\n\n\n\nassign StartRxPointerRead = RxBDRead & RxBDReady;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerRead <=#Tp 1'b0;\n  else\n  if(StartRxPointerRead)\n    RxPointerRead <=#Tp 1'b1;\n  else\n  if(RxEn & RxEn_q)\n    RxPointerRead <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerMSB <=#Tp 30'h0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxPointerMSB <=#Tp ram_do[31:2];\n  else\n  if(MasterWbRX & m_wb_ack_i)\n      RxPointerMSB <=#Tp RxPointerMSB + 1'b1; \nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(MasterWbRX & m_wb_ack_i)                 \n    RxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxPointerLSB_rst[1:0] <=#Tp ram_do[1:0];\nend\n\n\nalways @ (RxPointerLSB_rst)\nbegin\n  case(RxPointerLSB_rst[1:0])  \n    2'h0 : RxByteSel[3:0] = 4'hf;\n    2'h1 : RxByteSel[3:0] = 4'h7;\n    2'h2 : RxByteSel[3:0] = 4'h3;\n    2'h3 : RxByteSel[3:0] = 4'h1;\n  endcase\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxEn_needed <=#Tp 1'b0;\n  else\n  if(~RxReady & r_RxEn & WbEn & ~WbEn_q)\n    RxEn_needed <=#Tp 1'b1;\n  else\n  if(RxPointerRead & RxEn & RxEn_q)\n    RxEn_needed <=#Tp 1'b0;\nend\n\n\n\nassign RxStatusWrite = ShiftEnded & RxEn & RxEn_q;\n\nreg RxEnableWindow;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LastByteIn <=#Tp 1'b0;\n  else\n  if(ShiftWillEnd & (&RxByteCnt) | RxAbort)\n    LastByteIn <=#Tp 1'b0;\n  else\n  if(RxValid & RxReady & RxEndFrm & ~(&RxByteCnt) & RxEnableWindow)\n    LastByteIn <=#Tp 1'b1;\nend\n\nreg ShiftEnded_rck;\nreg ShiftEndedSync1;\nreg ShiftEndedSync2;\nreg ShiftEndedSync3;\nreg ShiftEndedSync_c1;\nreg ShiftEndedSync_c2;\n\nwire StartShiftWillEnd;\nassign StartShiftWillEnd = LastByteIn  | RxValid & RxEndFrm & (&RxByteCnt) & RxEnableWindow;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftWillEnd <=#Tp 1'b0;\n  else\n  if(ShiftEnded_rck | RxAbort)\n    ShiftWillEnd <=#Tp 1'b0;\n  else\n  if(StartShiftWillEnd)\n    ShiftWillEnd <=#Tp 1'b1;\nend\n\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxByteCnt <=#Tp 2'h0;\n  else\n  if(ShiftEnded_rck | RxAbort)\n    RxByteCnt <=#Tp 2'h0;\n  else\n  if(RxValid & RxStartFrm & RxReady)\n    case(RxPointerLSB_rst)  \n      2'h0 : RxByteCnt <=#Tp 2'h1;\n      2'h1 : RxByteCnt <=#Tp 2'h2;\n      2'h2 : RxByteCnt <=#Tp 2'h3;\n      2'h3 : RxByteCnt <=#Tp 2'h0;\n    endcase\n  else\n  if(RxValid & RxEnableWindow & RxReady | LastByteIn)\n    RxByteCnt <=#Tp RxByteCnt + 1'b1;\nend\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxValidBytes <=#Tp 2'h1;\n  else\n  if(RxValid & RxStartFrm)\n    case(RxPointerLSB_rst)  \n      2'h0 : RxValidBytes <=#Tp 2'h1;\n      2'h1 : RxValidBytes <=#Tp 2'h2;\n      2'h2 : RxValidBytes <=#Tp 2'h3;\n      2'h3 : RxValidBytes <=#Tp 2'h0;\n    endcase\n  else\n  if(RxValid & ~LastByteIn & ~RxStartFrm & RxEnableWindow)\n    RxValidBytes <=#Tp RxValidBytes + 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxDataLatched1       <=#Tp 24'h0;\n  else\n  if(RxValid & RxReady & ~LastByteIn)\n    if(RxStartFrm)\n    begin\n      case(RxPointerLSB_rst)     \n        2'h0:        RxDataLatched1[31:24] <=#Tp RxData;            \n        2'h1:        RxDataLatched1[23:16] <=#Tp RxData;\n        2'h2:        RxDataLatched1[15:8]  <=#Tp RxData;\n        2'h3:        RxDataLatched1        <=#Tp RxDataLatched1;\n      endcase\n    end\n    else if (RxEnableWindow)\n    begin\n      case(RxByteCnt)     \n        2'h0:        RxDataLatched1[31:24] <=#Tp RxData;            \n        2'h1:        RxDataLatched1[23:16] <=#Tp RxData;\n        2'h2:        RxDataLatched1[15:8]  <=#Tp RxData;\n        2'h3:        RxDataLatched1        <=#Tp RxDataLatched1;\n      endcase\n    end\nend\n\nwire SetWriteRxDataToFifo;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxDataLatched2 <=#Tp 32'h0;\n  else\n  if(SetWriteRxDataToFifo & ~ShiftWillEnd)\n    RxDataLatched2 <=#Tp {RxDataLatched1[31:8], RxData};              \n  else\n  if(SetWriteRxDataToFifo & ShiftWillEnd)\n    case(RxValidBytes)  \n      0 : RxDataLatched2 <=#Tp {RxDataLatched1[31:8],  RxData};       \n      1 : RxDataLatched2 <=#Tp {RxDataLatched1[31:24], 24'h0};\n      2 : RxDataLatched2 <=#Tp {RxDataLatched1[31:16], 16'h0};\n      3 : RxDataLatched2 <=#Tp {RxDataLatched1[31:8],   8'h0};\n    endcase\nend\n\n\nreg WriteRxDataToFifoSync1;\nreg WriteRxDataToFifoSync2;\nreg WriteRxDataToFifoSync3;\n\n\n\nassign SetWriteRxDataToFifo = (RxValid & RxReady & ~RxStartFrm & RxEnableWindow & (&RxByteCnt)) | \n                              (RxValid & RxReady &  RxStartFrm & (&RxPointerLSB_rst))           | \n                              (ShiftWillEnd & LastByteIn & (&RxByteCnt));\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifo <=#Tp 1'b0;\n  else\n  if(SetWriteRxDataToFifo & ~RxAbort)\n    WriteRxDataToFifo <=#Tp 1'b1;\n  else\n  if(WriteRxDataToFifoSync2 | RxAbort)\n    WriteRxDataToFifo <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync1 <=#Tp 1'b0;\n  else\n  if(WriteRxDataToFifo)\n    WriteRxDataToFifoSync1 <=#Tp 1'b1;\n  else\n    WriteRxDataToFifoSync1 <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync2 <=#Tp 1'b0;\n  else\n    WriteRxDataToFifoSync2 <=#Tp WriteRxDataToFifoSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync3 <=#Tp 1'b0;\n  else\n    WriteRxDataToFifoSync3 <=#Tp WriteRxDataToFifoSync2;\nend\n\nwire WriteRxDataToFifo_wb;\nassign WriteRxDataToFifo_wb = WriteRxDataToFifoSync2 & ~WriteRxDataToFifoSync3;\n\n\nreg LatchedRxStartFrm;\nreg SyncRxStartFrm;\nreg SyncRxStartFrm_q;\nreg SyncRxStartFrm_q2;\nwire RxFifoReset;\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LatchedRxStartFrm <=#Tp 0;\n  else\n  if(RxStartFrm & ~SyncRxStartFrm_q)\n    LatchedRxStartFrm <=#Tp 1;\n  else\n  if(SyncRxStartFrm_q)\n    LatchedRxStartFrm <=#Tp 0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm <=#Tp 0;\n  else\n  if(LatchedRxStartFrm)\n    SyncRxStartFrm <=#Tp 1;\n  else\n    SyncRxStartFrm <=#Tp 0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm_q <=#Tp 0;\n  else\n    SyncRxStartFrm_q <=#Tp SyncRxStartFrm;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm_q2 <=#Tp 0;\n  else\n    SyncRxStartFrm_q2 <=#Tp SyncRxStartFrm_q;\nend\n\n\nassign RxFifoReset = SyncRxStartFrm_q & ~SyncRxStartFrm_q2;\n\n\neth_fifo #(`ETH_RX_FIFO_DATA_WIDTH, `ETH_RX_FIFO_DEPTH, `ETH_RX_FIFO_CNT_WIDTH)\nrx_fifo (.data_in(RxDataLatched2),                      .data_out(m_wb_dat_o), \n         .clk(WB_CLK_I),                                .reset(Reset), \n         .write(WriteRxDataToFifo_wb & ~RxBufferFull),  .read(MasterWbRX & m_wb_ack_i), \n         .clear(RxFifoReset),                           .full(RxBufferFull), \n         .almost_full(),                                .almost_empty(RxBufferAlmostEmpty), \n         .empty(RxBufferEmpty),                         .cnt(rxfifo_cnt)\n        );\n\nassign enough_data_in_rxfifo_for_burst = rxfifo_cnt>=`ETH_BURST_LENGTH;\nassign enough_data_in_rxfifo_for_burst_plus1 = rxfifo_cnt>`ETH_BURST_LENGTH;\nassign WriteRxDataToMemory = ~RxBufferEmpty;\nassign rx_burst = rx_burst_en & WriteRxDataToMemory;\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEnded_rck <=#Tp 1'b0;\n  else\n  if(~RxAbort & SetWriteRxDataToFifo & StartShiftWillEnd)\n    ShiftEnded_rck <=#Tp 1'b1;\n  else\n  if(RxAbort | ShiftEndedSync_c1 & ShiftEndedSync_c2)\n    ShiftEnded_rck <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync1 <=#Tp 1'b0;\n  else\n    ShiftEndedSync1 <=#Tp ShiftEnded_rck;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync2 <=#Tp 1'b0;\n  else\n    ShiftEndedSync2 <=#Tp ShiftEndedSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync3 <=#Tp 1'b0;\n  else\n  if(ShiftEndedSync1 & ~ShiftEndedSync2)\n    ShiftEndedSync3 <=#Tp 1'b1;\n  else\n  if(ShiftEnded)\n    ShiftEndedSync3 <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEnded <=#Tp 1'b0;\n  else\n  if(ShiftEndedSync3 & MasterWbRX & m_wb_ack_i & RxBufferAlmostEmpty & ~ShiftEnded)\n    ShiftEnded <=#Tp 1'b1;\n  else\n  if(RxStatusWrite)\n    ShiftEnded <=#Tp 1'b0;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync_c1 <=#Tp 1'b0;\n  else\n    ShiftEndedSync_c1 <=#Tp ShiftEndedSync2;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync_c2 <=#Tp 1'b0;\n  else\n    ShiftEndedSync_c2 <=#Tp ShiftEndedSync_c1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxEnableWindow <=#Tp 1'b0;\n  else\n  if(RxStartFrm)\n    RxEnableWindow <=#Tp 1'b1;\n  else\n  if(RxEndFrm | RxAbort)\n    RxEnableWindow <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync1 <=#Tp 1'b0;\n  else\n    RxAbortSync1 <=#Tp RxAbortLatched;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync2 <=#Tp 1'b0;\n  else\n    RxAbortSync2 <=#Tp RxAbortSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync3 <=#Tp 1'b0;\n  else\n    RxAbortSync3 <=#Tp RxAbortSync2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync4 <=#Tp 1'b0;\n  else\n    RxAbortSync4 <=#Tp RxAbortSync3;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSyncb1 <=#Tp 1'b0;\n  else\n    RxAbortSyncb1 <=#Tp RxAbortSync2;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSyncb2 <=#Tp 1'b0;\n  else\n    RxAbortSyncb2 <=#Tp RxAbortSyncb1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortLatched <=#Tp 1'b0;\n  else\n  if(RxAbortSyncb2)\n    RxAbortLatched <=#Tp 1'b0;\n  else\n  if(RxAbort)\n    RxAbortLatched <=#Tp 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LatchedRxLength[15:0] <=#Tp 16'h0;\n  else\n  if(LoadRxStatus)\n    LatchedRxLength[15:0] <=#Tp RxLength[15:0];\nend\n\n\nassign RxStatusIn = {ReceivedPauseFrm, AddressMiss, RxOverrun, InvalidSymbol, DribbleNibble, ReceivedPacketTooBig, ShortFrame, LatchedCrcError, RxLateCollision};\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxStatusInLatched <=#Tp 'h0;\n  else\n  if(LoadRxStatus)\n    RxStatusInLatched <=#Tp RxStatusIn;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxOverrun <=#Tp 1'b0;\n  else\n  if(RxStatusWrite)\n    RxOverrun <=#Tp 1'b0;\n  else\n  if(RxBufferFull & WriteRxDataToFifo_wb)\n    RxOverrun <=#Tp 1'b1;\nend\n\n\n\nwire TxError;\nassign TxError = TxUnderRun | RetryLimit | LateCollLatched | CarrierSenseLost;\n\nwire RxError;\n\n\n\n\n\nassign RxError = (|RxStatusInLatched[6:3]) | (|RxStatusInLatched[1:0]);\n\n\n\nreg RxStatusWriteLatched;\nreg RxStatusWriteLatched_sync1;\nreg RxStatusWriteLatched_sync2;\nreg RxStatusWriteLatched_syncb1;\nreg RxStatusWriteLatched_syncb2;\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxStatusWriteLatched <=#Tp 1'b0;\n  else\n  if(RxStatusWriteLatched_syncb2)\n    RxStatusWriteLatched <=#Tp 1'b0;        \n  else\n  if(RxStatusWrite)\n    RxStatusWriteLatched <=#Tp 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      RxStatusWriteLatched_sync1 <=#Tp 1'b0;\n      RxStatusWriteLatched_sync2 <=#Tp 1'b0;\n    end\n  else\n    begin\n      RxStatusWriteLatched_sync1 <=#Tp RxStatusWriteLatched;\n      RxStatusWriteLatched_sync2 <=#Tp RxStatusWriteLatched_sync1;\n    end\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      RxStatusWriteLatched_syncb1 <=#Tp 1'b0;\n      RxStatusWriteLatched_syncb2 <=#Tp 1'b0;\n    end\n  else\n    begin\n      RxStatusWriteLatched_syncb1 <=#Tp RxStatusWriteLatched_sync2;\n      RxStatusWriteLatched_syncb2 <=#Tp RxStatusWriteLatched_syncb1;\n    end\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxB_IRQ <=#Tp 1'b0;\n  else\n  if(TxStatusWrite & TxIRQEn)\n    TxB_IRQ <=#Tp ~TxError;\n  else\n    TxB_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxE_IRQ <=#Tp 1'b0;\n  else\n  if(TxStatusWrite & TxIRQEn)\n    TxE_IRQ <=#Tp TxError;\n  else\n    TxE_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxB_IRQ <=#Tp 1'b0;\n  else\n  if(RxStatusWrite & RxIRQEn & ReceivedPacketGood & (~ReceivedPauseFrm | ReceivedPauseFrm & r_PassAll & (~r_RxFlow)))\n    RxB_IRQ <=#Tp (~RxError);\n  else\n    RxB_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxE_IRQ <=#Tp 1'b0;\n  else\n  if(RxStatusWrite & RxIRQEn & (~ReceivedPauseFrm | ReceivedPauseFrm & r_PassAll & (~r_RxFlow)))\n    RxE_IRQ <=#Tp RxError;\n  else\n    RxE_IRQ <=#Tp 1'b0;\nend\n\n\n\n\nreg Busy_IRQ_rck;\nreg Busy_IRQ_sync1;\nreg Busy_IRQ_sync2;\nreg Busy_IRQ_sync3;\nreg Busy_IRQ_syncb1;\nreg Busy_IRQ_syncb2;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    Busy_IRQ_rck <=#Tp 1'b0;\n  else\n  if(RxValid & RxStartFrm & ~RxReady)\n    Busy_IRQ_rck <=#Tp 1'b1;\n  else\n  if(Busy_IRQ_syncb2)\n    Busy_IRQ_rck <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I)\nbegin\n    Busy_IRQ_sync1 <=#Tp Busy_IRQ_rck;\n    Busy_IRQ_sync2 <=#Tp Busy_IRQ_sync1;\n    Busy_IRQ_sync3 <=#Tp Busy_IRQ_sync2;\nend\n\nalways @ (posedge MRxClk)\nbegin\n    Busy_IRQ_syncb1 <=#Tp Busy_IRQ_sync2;\n    Busy_IRQ_syncb2 <=#Tp Busy_IRQ_syncb1;\nend\n\nassign Busy_IRQ = Busy_IRQ_sync2 & ~Busy_IRQ_sync3;\n\n\n         \n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: eth_wishbone. Module specification: This module implements an Ethernet Wishbone interface controller, managing communication between the Ethernet MAC and the Wishbone bus for transmit and receive operations. It handles buffer management, status handling, and interrupt generation. Key inputs include clock signals, Wishbone bus inputs, Ethernet MAC signals, and configuration inputs. Outputs consist of Wishbone bus outputs, Ethernet MAC control signals, and interrupt signals. Internal signals manage buffer states, pointers, and various control flags. The module is divided into several functional blocks: Wishbone interface logic, transmit path logic, receive path logic, FIFO management, and interrupt generation. It coordinates data transfers between the Wishbone bus and Ethernet frames, manages buffer descriptors, and handles various control signals and status flags related to Ethernet packet transmission and reception. The design incorporates synchronization mechanisms between different clock domains and implements error handling for conditions such as under"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: eth_wishbone\n\nExplanation: This module appears to be an Ethernet Wishbone interface controller. It handles the communication between the Ethernet MAC (Media Access Control) and the Wishbone bus, managing transmit and receive operations. The module includes logic for buffer management, status handling, and interrupt generation for both transmit and receive paths. It coordinates data transfers between the Wishbone bus and Ethernet frames, handles buffer descriptors, and manages various control signals and status flags related to Ethernet packet transmission and reception."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nWB_CLK_I, WB_DAT_I, WB_ADR_I, WB_WE_I, BDCs, Reset, m_wb_dat_i, m_wb_ack_i, m_wb_err_i, MTxClk, TxUsedData, TxRetry, TxAbort, TxDone, MRxClk, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, r_TxEn, r_RxEn, r_TxBDNum, r_RxFlow, r_PassAll, InvalidSymbol, LatchedCrcError, RxLateCollision, ShortFrame, DribbleNibble, ReceivedPacketTooBig, RxLength, LoadRxStatus, ReceivedPacketGood, AddressMiss, ReceivedPauseFrm, RetryCntLatched, RetryLimit, LateCollLatched, DeferLatched, CarrierSenseLost.\n\nExplanation: These inputs include clock signals, data and address inputs from the Wishbone bus, control signals for transmit and receive operations, status signals from the Ethernet MAC, and configuration inputs.\n\nOutput ports:\nWB_DAT_O, WB_ACK_O, m_wb_adr_o, m_wb_sel_o, m_wb_we_o, m_wb_dat_o, m_wb_cyc_o, m_wb_stb_o, TxStartFrm, TxEndFrm, TxData, TxUnderRun, PerPacketCrcEn, PerPacketPad, RxStatusWriteLatched_sync2, RstDeferLatched, TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ.\n\nExplanation: These outputs include data and control signals for the Wishbone bus, signals for controlling the Ethernet MAC's transmit and receive operations, status signals, and interrupt request signals for various events in the Ethernet communication process."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nTxBDReady, TxBDRead, TxPointerRead, TxStatusWrite, BlockingTxStatusWrite, BlockingTxBDRead, TxStatus, ReadTxDataFromMemory, WriteRxDataToMemory, MasterWbTX, MasterWbRX, TxLength, LatchedTxLength, TxLengthEq0, TxLengthLt4, BlockingIncrementTxPointer, TxPointerMSB, TxPointerLSB, TxPointerLSB_rst, RxPointerMSB, RxPointerLSB_rst, RxByteSel, TxBufferAlmostFull, TxBufferFull, TxBufferEmpty, TxBufferAlmostEmpty, WriteRxDataToFifo, RxByteCnt, RxValidBytes, RxDataLatched1, RxDataLatched2, ShiftEnded, RxOverrun, TxError, RxError, RxStatusWriteLatched.\n\nExplanation:\n- TxBDReady, TxBDRead, TxPointerRead: Control signals for transmit buffer descriptor operations.\n- TxStatusWrite, BlockingTxStatusWrite: Manage the writing of transmit status.\n- BlockingTxBDRead: Controls the blocking of transmit buffer descriptor reads.\n- TxStatus: Holds the current transmit status.\n- ReadTxDataFromMemory, WriteRxDataToMemory: Control signals for memory access operations.\n- MasterWbTX, MasterWbRX: Indicate active Wishbone master operations for transmit and receive.\n- TxLength, LatchedTxLength: Store the length of the current transmit frame.\n- TxLengthEq0, TxLengthLt4: Flags for specific transmit length conditions.\n- BlockingIncrementTxPointer: Controls the increment of the transmit pointer.\n- TxPointerMSB, TxPointerLSB, TxPointerLSB_rst: Store different parts of the transmit pointer.\n- RxPointerMSB, RxPointerLSB_rst: Store different parts of the receive pointer.\n- RxByteSel: Selects which bytes are valid in receive operations.\n- TxBufferAlmostFull, TxBufferFull, TxBufferEmpty, TxBufferAlmostEmpty: Indicate the status of the transmit buffer.\n- WriteRxDataToFifo: Controls writing received data to the FIFO.\n- RxByteCnt, RxValidBytes: Count and track valid bytes in receive operations.\n- RxDataLatched1, RxDataLatched2: Store received data temporarily.\n- ShiftEnded: Indicates the end of a shift operation in receive process.\n- RxOverrun: Flags a receive buffer overrun condition.\n- TxError, RxError: Indicate transmit and receive errors.\n- RxStatusWriteLatched: Latches the write status for receive operations.\n\nThese signals are used throughout the module to control data flow, manage buffer states, handle timing and synchronization, and track various conditions in the Ethernet frame transmission and reception processes."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_wishbone\n   (\n\n    \n    WB_CLK_I, WB_DAT_I, WB_DAT_O, \n\n    \n \t\tWB_ADR_I, WB_WE_I, WB_ACK_O, \n    BDCs, \n\n    Reset, \n\n    \n    m_wb_adr_o, m_wb_sel_o, m_wb_we_o, \n    m_wb_dat_o, m_wb_dat_i, m_wb_cyc_o, \n    m_wb_stb_o, m_wb_ack_i, m_wb_err_i, \n\n`ifdef ETH_WISHBONE_B3\n    m_wb_cti_o, m_wb_bte_o, \n`endif\n\n    \n    MTxClk, TxStartFrm, TxEndFrm, TxUsedData, TxData, \n    TxRetry, TxAbort, TxUnderRun, TxDone, PerPacketCrcEn, \n    PerPacketPad, \n\n    \n    MRxClk, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, RxStatusWriteLatched_sync2, \n    \n    \n    r_TxEn, r_RxEn, r_TxBDNum, r_RxFlow, r_PassAll, \n\n    \n    TxB_IRQ, TxE_IRQ, RxB_IRQ, RxE_IRQ, Busy_IRQ, \n    \n    \n    InvalidSymbol, LatchedCrcError, RxLateCollision, ShortFrame, DribbleNibble,\n    ReceivedPacketTooBig, RxLength, LoadRxStatus, ReceivedPacketGood, AddressMiss, \n    ReceivedPauseFrm, \n    \n    \n    RetryCntLatched, RetryLimit, LateCollLatched, DeferLatched, RstDeferLatched, CarrierSenseLost\n\n    \n`ifdef ETH_BIST\n    ,\n    \n    mbist_si_i,       \n    mbist_so_o,       \n    mbist_ctrl_i        \n`endif\n    \n\n\n\t\t);\n\n\nparameter Tp = 1;\n\n\n\ninput           WB_CLK_I;       \ninput  [31:0]   WB_DAT_I;       \noutput [31:0]   WB_DAT_O;       \n\n\ninput   [9:2]   WB_ADR_I;       \ninput           WB_WE_I;        \ninput   [3:0]   BDCs;           \noutput          WB_ACK_O;       \n\n\noutput  [29:0]  m_wb_adr_o;     \noutput   [3:0]  m_wb_sel_o;     \noutput          m_wb_we_o;      \noutput  [31:0]  m_wb_dat_o;     \noutput          m_wb_cyc_o;     \noutput          m_wb_stb_o;     \ninput   [31:0]  m_wb_dat_i;     \ninput           m_wb_ack_i;     \ninput           m_wb_err_i;     \n\n`ifdef ETH_WISHBONE_B3\noutput   [2:0]  m_wb_cti_o;     \noutput   [1:0]  m_wb_bte_o;     \nreg      [2:0]  m_wb_cti_o;     \n`endif\n\ninput           Reset;       \n\n\ninput           InvalidSymbol;    \ninput           LatchedCrcError;  \ninput           RxLateCollision;  \ninput           ShortFrame;       \ninput           DribbleNibble;    \ninput           ReceivedPacketTooBig;\ninput    [15:0] RxLength;         \ninput           LoadRxStatus;     \ninput           ReceivedPacketGood;\ninput           AddressMiss;      \ninput           r_RxFlow;\ninput           r_PassAll;\ninput           ReceivedPauseFrm;\n\n\ninput     [3:0] RetryCntLatched;  \ninput           RetryLimit;       \ninput           LateCollLatched;  \ninput           DeferLatched;     \noutput          RstDeferLatched;\ninput           CarrierSenseLost; \n\n\ninput           MTxClk;         \ninput           TxUsedData;     \ninput           TxRetry;        \ninput           TxAbort;        \ninput           TxDone;         \noutput          TxStartFrm;     \noutput          TxEndFrm;       \noutput  [7:0]   TxData;         \noutput          TxUnderRun;     \noutput          PerPacketCrcEn; \noutput          PerPacketPad;   \n\n\ninput           MRxClk;         \ninput   [7:0]   RxData;         \ninput           RxValid;        \ninput           RxStartFrm;     \ninput           RxEndFrm;       \ninput           RxAbort;        \noutput          RxStatusWriteLatched_sync2;\n\n\ninput           r_TxEn;         \ninput           r_RxEn;         \ninput   [7:0]   r_TxBDNum;      \n\n\noutput TxB_IRQ;\noutput TxE_IRQ;\noutput RxB_IRQ;\noutput RxE_IRQ;\noutput Busy_IRQ;\n\n\n\n`ifdef ETH_BIST\ninput   mbist_si_i;       \noutput  mbist_so_o;       \ninput [`ETH_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i;       \n`endif\n\nreg TxB_IRQ;\nreg TxE_IRQ;\nreg RxB_IRQ;\nreg RxE_IRQ;\n\nreg             TxStartFrm;\nreg             TxEndFrm;\nreg     [7:0]   TxData;\n\nreg             TxUnderRun;\nreg             TxUnderRun_wb;\n\nreg             TxBDRead;\nwire            TxStatusWrite;\n\nreg     [1:0]   TxValidBytesLatched;\n\nreg    [15:0]   TxLength;\nreg    [15:0]   LatchedTxLength;\nreg   [14:11]   TxStatus;\n\nreg   [14:13]   RxStatus;\nwire  [14:13]   RxStatus_s;\n\nreg             TxStartFrm_wb;\nreg             TxRetry_wb;\nreg             TxAbort_wb;\nreg             TxDone_wb;\n\nreg             TxDone_wb_q;\nreg             TxAbort_wb_q;\nreg             TxRetry_wb_q;\nreg             TxRetryPacket;\nreg             TxRetryPacket_NotCleared;\nreg             TxDonePacket;\nreg             TxDonePacket_NotCleared;\nreg             TxAbortPacket;\nreg             TxAbortPacket_NotCleared;\nreg             RxBDReady;\nreg             RxReady;\nreg             TxBDReady;\n\nreg             RxBDRead;\n\nreg    [31:0]   TxDataLatched;\nreg     [1:0]   TxByteCnt;\nreg             LastWord;\nreg             ReadTxDataFromFifo_tck;\n\nreg             BlockingTxStatusWrite;\nreg             BlockingTxBDRead;\n\nreg             Flop;\n\nreg     [7:1]   TxBDAddress;\nreg     [7:1]   RxBDAddress;\n\nreg             TxRetrySync1;\nreg             TxAbortSync1;\nreg             TxDoneSync1;\n\nreg             TxAbort_q;\nreg             TxRetry_q;\nreg             TxUsedData_q;\n\nreg    [31:0]   RxDataLatched2;\n\nreg    [31:8]   RxDataLatched1;     \n\nreg     [1:0]   RxValidBytes;\nreg     [1:0]   RxByteCnt;\nreg             LastByteIn;\nreg             ShiftWillEnd;\n\nreg             WriteRxDataToFifo;\nreg    [15:0]   LatchedRxLength;\nreg             RxAbortLatched;\n\nreg             ShiftEnded;\nreg             RxOverrun;\n\nreg     [3:0]   BDWrite;                    \nreg             BDRead;                     \nwire   [31:0]   RxBDDataIn;                 \nwire   [31:0]   TxBDDataIn;                 \n\nreg             TxEndFrm_wb;\n\nwire            TxRetryPulse;\nwire            TxDonePulse;\nwire            TxAbortPulse;\n\nwire            StartRxBDRead;\n\nwire            StartTxBDRead;\n\nwire            TxIRQEn;\nwire            WrapTxStatusBit;\n\nwire            RxIRQEn;\nwire            WrapRxStatusBit;\n\nwire    [1:0]   TxValidBytes;\n\nwire    [7:1]   TempTxBDAddress;\nwire    [7:1]   TempRxBDAddress;\n\nwire            RxStatusWrite;\nwire            RxBufferFull;\nwire            RxBufferAlmostEmpty;\nwire            RxBufferEmpty;\n\nreg             WB_ACK_O;\n\nwire    [8:0]   RxStatusIn;\nreg     [8:0]   RxStatusInLatched;\n\nreg WbEn, WbEn_q;\nreg RxEn, RxEn_q;\nreg TxEn, TxEn_q;\nreg r_TxEn_q;\nreg r_RxEn_q;\n\nwire ram_ce;\nwire [3:0]  ram_we;\nwire ram_oe;\nreg [7:0]   ram_addr;\nreg [31:0]  ram_di;\nwire [31:0] ram_do;\n\nwire StartTxPointerRead;\nreg  TxPointerRead;\nreg TxEn_needed;\nreg RxEn_needed;\n\nwire StartRxPointerRead;\nreg RxPointerRead; \n\n`ifdef ETH_WISHBONE_B3\nassign m_wb_bte_o = 2'b00;    \n`endif\n\nassign m_wb_stb_o = m_wb_cyc_o;\n\nalways @ (posedge WB_CLK_I)\nbegin\n  WB_ACK_O <=#Tp (|BDWrite) & WbEn & WbEn_q | BDRead & WbEn & ~WbEn_q;\nend\n\nassign WB_DAT_O = ram_do;\n\n\neth_spram_256x32 bd_ram (\n\t.clk(WB_CLK_I), .rst(Reset), .ce(ram_ce), .we(ram_we), .oe(ram_oe), .addr(ram_addr), .di(ram_di), .do(ram_do)\n`ifdef ETH_BIST\n  ,\n  .mbist_si_i       (mbist_si_i),\n  .mbist_so_o       (mbist_so_o),\n  .mbist_ctrl_i       (mbist_ctrl_i)\n`endif\n);\n\nassign ram_ce = 1'b1;\nassign ram_we = (BDWrite & {4{(WbEn & WbEn_q)}}) | {4{(TxStatusWrite | RxStatusWrite)}};\nassign ram_oe = BDRead & WbEn & WbEn_q | TxEn & TxEn_q & (TxBDRead | TxPointerRead) | RxEn & RxEn_q & (RxBDRead | RxPointerRead);\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxEn_needed <=#Tp 1'b0;\n  else\n  if(~TxBDReady & r_TxEn & WbEn & ~WbEn_q)\n    TxEn_needed <=#Tp 1'b1;\n  else\n  if(TxPointerRead & TxEn & TxEn_q)\n    TxEn_needed <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      WbEn <=#Tp 1'b1;\n      RxEn <=#Tp 1'b0;\n      TxEn <=#Tp 1'b0;\n      ram_addr <=#Tp 8'h0;\n      ram_di <=#Tp 32'h0;\n      BDRead <=#Tp 1'b0;\n      BDWrite <=#Tp 1'b0;\n    end\n  else\n    begin\n      \n      case ({WbEn_q, RxEn_q, TxEn_q, RxEn_needed, TxEn_needed})  \n        5'b100_10, 5'b100_11 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b1;  \n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp {RxBDAddress, RxPointerRead};\n            ram_di <=#Tp RxBDDataIn;\n          end\n        5'b100_01 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b1;  \n            ram_addr <=#Tp {TxBDAddress, TxPointerRead};\n            ram_di <=#Tp TxBDDataIn;\n          end\n        5'b010_00, 5'b010_10 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n        5'b010_01, 5'b010_11 :\n          begin\n            WbEn <=#Tp 1'b0;\n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b1;  \n            ram_addr <=#Tp {TxBDAddress, TxPointerRead};\n            ram_di <=#Tp TxBDDataIn;\n          end\n        5'b001_00, 5'b001_01, 5'b001_10, 5'b001_11 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n        5'b100_00 :\n          begin\n            WbEn <=#Tp 1'b0;  \n          end\n        5'b000_00 :\n          begin\n            WbEn <=#Tp 1'b1;  \n            RxEn <=#Tp 1'b0;\n            TxEn <=#Tp 1'b0;\n            ram_addr <=#Tp WB_ADR_I[9:2];\n            ram_di <=#Tp WB_DAT_I;\n            BDWrite <=#Tp BDCs[3:0] & {4{WB_WE_I}};\n            BDRead <=#Tp (|BDCs) & ~WB_WE_I;\n          end\n      endcase\n    end\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      WbEn_q <=#Tp 1'b0;\n      RxEn_q <=#Tp 1'b0;\n      TxEn_q <=#Tp 1'b0;\n      r_TxEn_q <=#Tp 1'b0;\n      r_RxEn_q <=#Tp 1'b0;\n    end\n  else\n    begin\n      WbEn_q <=#Tp WbEn;\n      RxEn_q <=#Tp RxEn;\n      TxEn_q <=#Tp TxEn;\n      r_TxEn_q <=#Tp r_TxEn;\n      r_RxEn_q <=#Tp r_RxEn;\n    end\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    Flop <=#Tp 1'b0;\n  else\n  if(TxDone | TxAbort | TxRetry_q)\n    Flop <=#Tp 1'b0;\n  else\n  if(TxUsedData)\n    Flop <=#Tp ~Flop;\nend\n\nwire ResetTxBDReady;\nassign ResetTxBDReady = TxDonePulse | TxAbortPulse | TxRetryPulse;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDReady <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxBDReady <=#Tp ram_do[15] & (ram_do[31:16] > 4); \n  else                                                \n  if(ResetTxBDReady)\n    TxBDReady <=#Tp 1'b0;\nend\n\n\n\nassign StartTxBDRead = (TxRetryPacket_NotCleared | TxStatusWrite) & ~BlockingTxBDRead & ~TxBDReady;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDRead <=#Tp 1'b1;\n  else\n  if(StartTxBDRead)\n    TxBDRead <=#Tp 1'b1;\n  else\n  if(TxBDReady)\n    TxBDRead <=#Tp 1'b0;\nend\n\n\n\nassign StartTxPointerRead = TxBDRead & TxBDReady;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerRead <=#Tp 1'b0;\n  else\n  if(StartTxPointerRead)\n    TxPointerRead <=#Tp 1'b1;\n  else\n  if(TxEn_q)\n    TxPointerRead <=#Tp 1'b0;\nend\n\n\n\nassign TxStatusWrite = (TxDonePacket_NotCleared | TxAbortPacket_NotCleared) & TxEn & TxEn_q & ~BlockingTxStatusWrite;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite <=#Tp 1'b0;\n  else\n  if(~TxDone_wb & ~TxAbort_wb)\n    BlockingTxStatusWrite <=#Tp 1'b0;\n  else\n  if(TxStatusWrite)\n    BlockingTxStatusWrite <=#Tp 1'b1;\nend\n\n\nreg BlockingTxStatusWrite_sync1;\nreg BlockingTxStatusWrite_sync2;\nreg BlockingTxStatusWrite_sync3;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync1 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync1 <=#Tp BlockingTxStatusWrite;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync2 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync2 <=#Tp BlockingTxStatusWrite_sync1;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxStatusWrite_sync3 <=#Tp 1'b0;\n  else\n    BlockingTxStatusWrite_sync3 <=#Tp BlockingTxStatusWrite_sync2;\nend\n\nassign RstDeferLatched = BlockingTxStatusWrite_sync2 & ~BlockingTxStatusWrite_sync3;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingTxBDRead <=#Tp 1'b0;\n  else\n  if(StartTxBDRead)\n    BlockingTxBDRead <=#Tp 1'b1;\n  else\n  if(~StartTxBDRead & ~TxBDReady)\n    BlockingTxBDRead <=#Tp 1'b0;\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStatus <=#Tp 4'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxStatus <=#Tp ram_do[14:11];\nend\n\nreg ReadTxDataFromMemory;\nwire WriteRxDataToMemory;\n\nreg MasterWbTX;\nreg MasterWbRX;\n\nreg [29:0] m_wb_adr_o;\nreg        m_wb_cyc_o;\nreg  [3:0] m_wb_sel_o;\nreg        m_wb_we_o;\n\nwire TxLengthEq0;\nwire TxLengthLt4;\n\nreg BlockingIncrementTxPointer;\nreg [31:2] TxPointerMSB;\nreg [1:0]  TxPointerLSB;\nreg [1:0]  TxPointerLSB_rst;\nreg [31:2] RxPointerMSB;\nreg [1:0]  RxPointerLSB_rst;\n\nwire RxBurstAcc;\nwire RxWordAcc;\nwire RxHalfAcc;\nwire RxByteAcc;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxLength <=#Tp 16'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    TxLength <=#Tp ram_do[31:16];\n  else\n  if(MasterWbTX & m_wb_ack_i)\n    begin\n      if(TxLengthLt4)\n        TxLength <=#Tp 16'h0;\n      else\n      if(TxPointerLSB_rst==2'h0)\n        TxLength <=#Tp TxLength - 3'h4;    \n      else\n      if(TxPointerLSB_rst==2'h1)\n        TxLength <=#Tp TxLength - 3'h3;    \n      else\n      if(TxPointerLSB_rst==2'h2)\n        TxLength <=#Tp TxLength - 3'h2;    \n      else\n      if(TxPointerLSB_rst==2'h3)\n        TxLength <=#Tp TxLength - 3'h1;    \n    end\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchedTxLength <=#Tp 16'h0;\n  else\n  if(TxEn & TxEn_q & TxBDRead)\n    LatchedTxLength <=#Tp ram_do[31:16];\nend\n\nassign TxLengthEq0 = TxLength == 0;\nassign TxLengthLt4 = TxLength < 4;\n\nreg cyc_cleared;\nreg IncrTxPointer;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerMSB <=#Tp 30'h0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerMSB <=#Tp ram_do[31:2];\n  else\n  if(IncrTxPointer & ~BlockingIncrementTxPointer)\n    TxPointerMSB <=#Tp TxPointerMSB + 1'b1;     \nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerLSB[1:0] <=#Tp 0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerLSB[1:0] <=#Tp ram_do[1:0];\nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(TxEn & TxEn_q & TxPointerRead)\n    TxPointerLSB_rst[1:0] <=#Tp ram_do[1:0];\n  else\n  if(MasterWbTX & m_wb_ack_i)                 \n    TxPointerLSB_rst[1:0] <=#Tp 0;\nend\n\n\nreg  [3:0] RxByteSel;\nwire MasterAccessFinished;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockingIncrementTxPointer <=#Tp 0;\n  else\n  if(MasterAccessFinished)\n    BlockingIncrementTxPointer <=#Tp 0;\n  else\n  if(IncrTxPointer)\n    BlockingIncrementTxPointer <=#Tp 1'b1;\nend\n\n\nwire TxBufferAlmostFull;\nwire TxBufferFull;\nwire TxBufferEmpty;\nwire TxBufferAlmostEmpty;\nwire SetReadTxDataFromMemory;\n\nreg BlockReadTxDataFromMemory;\n\nassign SetReadTxDataFromMemory = TxEn & TxEn_q & TxPointerRead;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if(TxLengthEq0 | TxAbortPulse | TxRetryPulse)\n    ReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if(SetReadTxDataFromMemory)\n    ReadTxDataFromMemory <=#Tp 1'b1;\nend\n\nreg tx_burst_en;\nreg rx_burst_en;\n\nwire ReadTxDataFromMemory_2 = ReadTxDataFromMemory & ~BlockReadTxDataFromMemory;\nwire tx_burst = ReadTxDataFromMemory_2 & tx_burst_en;\n\nwire [31:0] TxData_wb;\nwire ReadTxDataFromFifo_wb;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    BlockReadTxDataFromMemory <=#Tp 1'b0;\n  else\n  if((TxBufferAlmostFull | TxLength <= 4)& MasterWbTX & (~cyc_cleared) & (!(TxAbortPacket_NotCleared | TxRetryPacket_NotCleared)))\n    BlockReadTxDataFromMemory <=#Tp 1'b1;\n  else\n  if(ReadTxDataFromFifo_wb | TxDonePacket | TxAbortPacket | TxRetryPacket)\n    BlockReadTxDataFromMemory <=#Tp 1'b0;\nend\n\n\nassign MasterAccessFinished = m_wb_ack_i | m_wb_err_i;\nwire [`ETH_TX_FIFO_CNT_WIDTH-1:0] txfifo_cnt;\nwire [`ETH_RX_FIFO_CNT_WIDTH-1:0] rxfifo_cnt;\nreg  [`ETH_BURST_CNT_WIDTH-1:0] tx_burst_cnt;\nreg  [`ETH_BURST_CNT_WIDTH-1:0] rx_burst_cnt;\n\nwire rx_burst;\nwire enough_data_in_rxfifo_for_burst;\nwire enough_data_in_rxfifo_for_burst_plus1;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      MasterWbTX <=#Tp 1'b0;\n      MasterWbRX <=#Tp 1'b0;\n      m_wb_adr_o <=#Tp 30'h0;\n      m_wb_cyc_o <=#Tp 1'b0;\n      m_wb_we_o  <=#Tp 1'b0;\n      m_wb_sel_o <=#Tp 4'h0;\n      cyc_cleared<=#Tp 1'b0;\n      tx_burst_cnt<=#Tp 0;\n      rx_burst_cnt<=#Tp 0;\n      IncrTxPointer<=#Tp 1'b0;\n      tx_burst_en<=#Tp 1'b1;\n      rx_burst_en<=#Tp 1'b0;\n      `ifdef ETH_WISHBONE_B3\n        m_wb_cti_o <=#Tp 3'b0;\n      `endif\n    end\n  else\n    begin\n      \n      casex ({MasterWbTX, MasterWbRX, ReadTxDataFromMemory_2, WriteRxDataToMemory, MasterAccessFinished, cyc_cleared, tx_burst, rx_burst})  \n        8'b00_10_00_10,             \n        8'b10_1x_10_1x,             \n        8'b10_10_01_10,             \n        8'b01_1x_01_1x :            \n          begin\n            MasterWbTX <=#Tp 1'b1;  \n            MasterWbRX <=#Tp 1'b0;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b1;\n            tx_burst_cnt <=#Tp tx_burst_cnt+3'h1;\n            if(tx_burst_cnt==0)\n              m_wb_adr_o <=#Tp TxPointerMSB;\n            else\n              m_wb_adr_o <=#Tp m_wb_adr_o+1'b1;\n\n            if(tx_burst_cnt==(`ETH_BURST_LENGTH-1))\n              begin\n                tx_burst_en<=#Tp 1'b0;\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b111;\n              `endif\n              end\n            else\n              begin\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b010;\n              `endif\n              end\n          end\n        8'b00_x1_00_x1,             \n        8'b01_x1_10_x1,             \n        8'b01_01_01_01,             \n        8'b10_x1_01_x1 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;  \n            MasterWbRX <=#Tp 1'b1;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            IncrTxPointer<=#Tp 1'b0;\n            cyc_cleared<=#Tp 1'b0;\n            rx_burst_cnt <=#Tp rx_burst_cnt+3'h1;\n\n            if(rx_burst_cnt==0)\n              m_wb_adr_o <=#Tp RxPointerMSB;\n            else\n              m_wb_adr_o <=#Tp m_wb_adr_o+1'b1;\n\n            if(rx_burst_cnt==(`ETH_BURST_LENGTH-1))\n              begin\n                rx_burst_en<=#Tp 1'b0;\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b111;\n              `endif\n              end\n            else\n              begin\n              `ifdef ETH_WISHBONE_B3\n                m_wb_cti_o <=#Tp 3'b010;\n              `endif\n              end\n          end\n        8'b00_x1_00_x0 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b1;\n            m_wb_adr_o <=#Tp RxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            IncrTxPointer<=#Tp 1'b0;\n          end\n        8'b00_10_00_00 :            \n          begin\n            MasterWbTX <=#Tp 1'b1;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_adr_o <=#Tp TxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            IncrTxPointer<=#Tp 1'b1;\n          end\n        8'b10_10_01_00,             \n        8'b01_1x_01_0x  :           \n          begin\n            MasterWbTX <=#Tp 1'b1;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_adr_o <=#Tp TxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b0;\n            m_wb_sel_o <=#Tp 4'hf;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b1;\n          end\n        8'b01_01_01_00,             \n        8'b10_x1_01_x0  :           \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b1;\n            m_wb_adr_o <=#Tp RxPointerMSB;\n            m_wb_cyc_o <=#Tp 1'b1;\n            m_wb_we_o  <=#Tp 1'b1;\n            m_wb_sel_o <=#Tp RxByteSel;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b0;\n          end\n        8'b01_01_10_00,             \n        8'b01_1x_10_x0,             \n        8'b10_10_10_00,             \n        8'b10_x1_10_0x :            \n          begin\n            m_wb_cyc_o <=#Tp 1'b0;  \n            cyc_cleared<=#Tp 1'b1;\n            IncrTxPointer<=#Tp 1'b0;\n            tx_burst_cnt<=#Tp 0;\n            tx_burst_en<=#Tp txfifo_cnt<(`ETH_TX_FIFO_DEPTH-`ETH_BURST_LENGTH) & (TxLength>(`ETH_BURST_LENGTH*4+4));\n            rx_burst_cnt<=#Tp 0;\n            rx_burst_en<=#Tp MasterWbRX ? enough_data_in_rxfifo_for_burst_plus1 : enough_data_in_rxfifo_for_burst;  \n            `ifdef ETH_WISHBONE_B3\n              m_wb_cti_o <=#Tp 3'b0;\n            `endif\n          end\n        8'bxx_00_10_00,             \n        8'bxx_00_01_00 :            \n          begin\n            MasterWbTX <=#Tp 1'b0;\n            MasterWbRX <=#Tp 1'b0;\n            m_wb_cyc_o <=#Tp 1'b0;\n            cyc_cleared<=#Tp 1'b0;\n            IncrTxPointer<=#Tp 1'b0;\n            rx_burst_cnt<=#Tp 0;\n            rx_burst_en<=#Tp MasterWbRX ? enough_data_in_rxfifo_for_burst_plus1 : enough_data_in_rxfifo_for_burst;  \n            `ifdef ETH_WISHBONE_B3\n              m_wb_cti_o <=#Tp 3'b0;\n            `endif\n          end\n        8'b00_00_00_00:             \n          begin\n            tx_burst_cnt<=#Tp 0;\n            tx_burst_en<=#Tp txfifo_cnt<(`ETH_TX_FIFO_DEPTH-`ETH_BURST_LENGTH) & (TxLength>(`ETH_BURST_LENGTH*4+4));\n          end\n        default:                    \n          begin\n            MasterWbTX <=#Tp MasterWbTX;\n            MasterWbRX <=#Tp MasterWbRX;\n            m_wb_cyc_o <=#Tp m_wb_cyc_o;\n            m_wb_sel_o <=#Tp m_wb_sel_o;\n            IncrTxPointer<=#Tp IncrTxPointer;\n          end\n      endcase\n    end\nend\n\n\nwire TxFifoClear;\n\nassign TxFifoClear = (TxAbortPacket | TxRetryPacket);\n\neth_fifo #(`ETH_TX_FIFO_DATA_WIDTH, `ETH_TX_FIFO_DEPTH, `ETH_TX_FIFO_CNT_WIDTH)\ntx_fifo ( .data_in(m_wb_dat_i),                             .data_out(TxData_wb), \n          .clk(WB_CLK_I),                                   .reset(Reset), \n          .write(MasterWbTX & m_wb_ack_i),                  .read(ReadTxDataFromFifo_wb & ~TxBufferEmpty),\n          .clear(TxFifoClear),                              .full(TxBufferFull), \n          .almost_full(TxBufferAlmostFull),                 .almost_empty(TxBufferAlmostEmpty), \n          .empty(TxBufferEmpty),                            .cnt(txfifo_cnt)\n        );\n\n\nreg StartOccured;\nreg TxStartFrm_sync1;\nreg TxStartFrm_sync2;\nreg TxStartFrm_syncb1;\nreg TxStartFrm_syncb2;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_wb <=#Tp 1'b0;\n  else\n  if(TxBDReady & ~StartOccured & (TxBufferFull | TxLengthEq0))\n    TxStartFrm_wb <=#Tp 1'b1;\n  else\n  if(TxStartFrm_syncb2)\n    TxStartFrm_wb <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    StartOccured <=#Tp 1'b0;\n  else\n  if(TxStartFrm_wb)\n    StartOccured <=#Tp 1'b1;\n  else\n  if(ResetTxBDReady)\n    StartOccured <=#Tp 1'b0;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_sync1 <=#Tp 1'b0;\n  else\n    TxStartFrm_sync1 <=#Tp TxStartFrm_wb;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_sync2 <=#Tp 1'b0;\n  else\n    TxStartFrm_sync2 <=#Tp TxStartFrm_sync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_syncb1 <=#Tp 1'b0;\n  else\n    TxStartFrm_syncb1 <=#Tp TxStartFrm_sync2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm_syncb2 <=#Tp 1'b0;\n  else\n    TxStartFrm_syncb2 <=#Tp TxStartFrm_syncb1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxStartFrm <=#Tp 1'b0;\n  else\n  if(TxStartFrm_sync2)\n    TxStartFrm <=#Tp 1'b1;\n  else\n  if(TxUsedData_q | ~TxStartFrm_sync2 & (TxRetry & (~TxRetry_q) | TxAbort & (~TxAbort_q)))\n    TxStartFrm <=#Tp 1'b0;\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxEndFrm_wb <=#Tp 1'b0;\n  else\n  if(TxLengthEq0 & TxBufferAlmostEmpty & TxUsedData)\n    TxEndFrm_wb <=#Tp 1'b1;\n  else\n  if(TxRetryPulse | TxDonePulse | TxAbortPulse)\n    TxEndFrm_wb <=#Tp 1'b0;\nend\n\n\n\nassign TxValidBytes = TxLengthLt4 ? TxLength[1:0] : 2'b0;\n\nreg LatchValidBytes;\nreg LatchValidBytes_q;\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchValidBytes <=#Tp 1'b0;\n  else\n  if(TxLengthLt4 & TxBDReady)\n    LatchValidBytes <=#Tp 1'b1;\n  else\n    LatchValidBytes <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    LatchValidBytes_q <=#Tp 1'b0;\n  else\n    LatchValidBytes_q <=#Tp LatchValidBytes;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxValidBytesLatched <=#Tp 2'h0;\n  else\n  if(LatchValidBytes & ~LatchValidBytes_q)\n    TxValidBytesLatched <=#Tp TxValidBytes;\n  else\n  if(TxRetryPulse | TxDonePulse | TxAbortPulse)\n    TxValidBytesLatched <=#Tp 2'h0;\nend\n\n\nassign TxIRQEn          = TxStatus[14];\nassign WrapTxStatusBit  = TxStatus[13];\nassign PerPacketPad     = TxStatus[12];\nassign PerPacketCrcEn   = TxStatus[11];\n\n\nassign RxIRQEn         = RxStatus_s[14];\nassign WrapRxStatusBit = RxStatus_s[13];\n\n\n\nassign TempTxBDAddress[7:1] = {7{ TxStatusWrite     & ~WrapTxStatusBit}}   & (TxBDAddress + 1'b1) ; \nassign TempRxBDAddress[7:1] = {7{ WrapRxStatusBit}} & (r_TxBDNum[6:0])     | \n                              {7{~WrapRxStatusBit}} & (RxBDAddress + 1'b1) ; \n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxBDAddress <=#Tp 7'h0;\n  else if (r_TxEn & (~r_TxEn_q))\n    TxBDAddress <=#Tp 7'h0;\n  else if (TxStatusWrite)\n    TxBDAddress <=#Tp TempTxBDAddress;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDAddress <=#Tp 7'h0;\n  else if(r_RxEn & (~r_RxEn_q))\n    RxBDAddress <=#Tp r_TxBDNum[6:0];\n  else if(RxStatusWrite)\n    RxBDAddress <=#Tp TempRxBDAddress;\nend\n\nwire [8:0] TxStatusInLatched = {TxUnderRun, RetryCntLatched[3:0], RetryLimit, LateCollLatched, DeferLatched, CarrierSenseLost};\n\nassign RxBDDataIn = {LatchedRxLength, 1'b0, RxStatus_s, 4'h0, RxStatusInLatched};\nassign TxBDDataIn = {LatchedTxLength, 1'b0, TxStatus, 2'h0, TxStatusInLatched};\n\n\n\nassign TxRetryPulse   = TxRetry_wb   & ~TxRetry_wb_q;\nassign TxDonePulse    = TxDone_wb    & ~TxDone_wb_q;\nassign TxAbortPulse   = TxAbort_wb   & ~TxAbort_wb_q;\n\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      TxAbort_q      <=#Tp 1'b0;\n      TxRetry_q      <=#Tp 1'b0;\n      TxUsedData_q   <=#Tp 1'b0;\n    end\n  else\n    begin\n      TxAbort_q      <=#Tp TxAbort;\n      TxRetry_q      <=#Tp TxRetry;\n      TxUsedData_q   <=#Tp TxUsedData;\n    end\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      TxDone_wb_q   <=#Tp 1'b0;\n      TxAbort_wb_q  <=#Tp 1'b0;\n      TxRetry_wb_q  <=#Tp 1'b0;\n    end\n  else\n    begin\n      TxDone_wb_q   <=#Tp TxDone_wb;\n      TxAbort_wb_q  <=#Tp TxAbort_wb;\n      TxRetry_wb_q  <=#Tp TxRetry_wb;\n    end\nend\n\n\nreg TxAbortPacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacket <=#Tp 1'b0;\n  else\n  if(TxAbort_wb & (~tx_burst_en) & MasterWbTX & MasterAccessFinished & (~TxAbortPacketBlocked) |\n     TxAbort_wb & (~MasterWbTX) & (~TxAbortPacketBlocked))\n    TxAbortPacket <=#Tp 1'b1;\n  else\n    TxAbortPacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxAbortPacket_NotCleared)\n    TxAbortPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxAbort_wb & (~tx_burst_en) & MasterWbTX & MasterAccessFinished & (~TxAbortPacketBlocked) |\n     TxAbort_wb & (~MasterWbTX) & (~TxAbortPacketBlocked))\n    TxAbortPacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortPacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxAbort_wb & TxAbort_wb_q)\n    TxAbortPacketBlocked <=#Tp 1'b0;\n  else\n  if(TxAbortPacket)\n    TxAbortPacketBlocked <=#Tp 1'b1;\nend\n\n\nreg TxRetryPacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacket <=#Tp 1'b0;\n  else\n  if(TxRetry_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxRetryPacketBlocked | \n     TxRetry_wb & !MasterWbTX & !TxRetryPacketBlocked)\n    TxRetryPacket <=#Tp 1'b1;\n  else\n    TxRetryPacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(StartTxBDRead)\n    TxRetryPacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxRetry_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxRetryPacketBlocked | \n     TxRetry_wb & !MasterWbTX & !TxRetryPacketBlocked)\n    TxRetryPacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetryPacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxRetry_wb & TxRetry_wb_q)\n    TxRetryPacketBlocked <=#Tp 1'b0;\n  else\n  if(TxRetryPacket)\n    TxRetryPacketBlocked <=#Tp 1'b1;\nend\n\n\nreg TxDonePacketBlocked;\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacket <=#Tp 1'b0;\n  else\n  if(TxDone_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & !TxDonePacketBlocked | \n     TxDone_wb & !MasterWbTX & !TxDonePacketBlocked)\n    TxDonePacket <=#Tp 1'b1;\n  else\n    TxDonePacket <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxEn & TxEn_q & TxDonePacket_NotCleared)\n    TxDonePacket_NotCleared <=#Tp 1'b0;\n  else\n  if(TxDone_wb & !tx_burst_en & MasterWbTX & MasterAccessFinished & (~TxDonePacketBlocked) | \n     TxDone_wb & !MasterWbTX & (~TxDonePacketBlocked))\n    TxDonePacket_NotCleared <=#Tp 1'b1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDonePacketBlocked <=#Tp 1'b0;\n  else\n  if(!TxDone_wb & TxDone_wb_q)\n    TxDonePacketBlocked <=#Tp 1'b0;\n  else\n  if(TxDonePacket)\n    TxDonePacketBlocked <=#Tp 1'b1;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    LastWord <=#Tp 1'b0;\n  else\n  if((TxEndFrm | TxAbort | TxRetry) & Flop)\n    LastWord <=#Tp 1'b0;\n  else\n  if(TxUsedData & Flop & TxByteCnt == 2'h3)\n    LastWord <=#Tp TxEndFrm_wb;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxEndFrm <=#Tp 1'b0;\n  else\n  if(Flop & TxEndFrm | TxAbort | TxRetry_q)\n    TxEndFrm <=#Tp 1'b0;        \n  else\n  if(Flop & LastWord)\n    begin\n      case (TxValidBytesLatched)  \n        1 : TxEndFrm <=#Tp TxByteCnt == 2'h0;\n        2 : TxEndFrm <=#Tp TxByteCnt == 2'h1;\n        3 : TxEndFrm <=#Tp TxByteCnt == 2'h2;\n        0 : TxEndFrm <=#Tp TxByteCnt == 2'h3;\n        default : TxEndFrm <=#Tp 1'b0;\n      endcase\n    end\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxData <=#Tp 0;\n  else\n  if(TxStartFrm_sync2 & ~TxStartFrm)\n    case(TxPointerLSB)  \n      2'h0 : TxData <=#Tp TxData_wb[31:24];                  \n      2'h1 : TxData <=#Tp TxData_wb[23:16];                  \n      2'h2 : TxData <=#Tp TxData_wb[15:08];                  \n      2'h3 : TxData <=#Tp TxData_wb[07:00];                  \n    endcase\n  else\n  if(TxStartFrm & TxUsedData & TxPointerLSB==2'h3)\n    TxData <=#Tp TxData_wb[31:24];                           \n  else\n  if(TxUsedData & Flop)\n    begin\n      case(TxByteCnt)  \n        0 : TxData <=#Tp TxDataLatched[31:24];               \n        1 : TxData <=#Tp TxDataLatched[23:16];\n        2 : TxData <=#Tp TxDataLatched[15:8];\n        3 : TxData <=#Tp TxDataLatched[7:0];\n      endcase\n    end\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxDataLatched[31:0] <=#Tp 32'h0;\n  else\n if(TxStartFrm_sync2 & ~TxStartFrm | TxUsedData & Flop & TxByteCnt == 2'h3 | TxStartFrm & TxUsedData & Flop & TxByteCnt == 2'h0)\n    TxDataLatched[31:0] <=#Tp TxData_wb[31:0];\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun_wb <=#Tp 1'b0;\n  else\n  if(TxAbortPulse)\n    TxUnderRun_wb <=#Tp 1'b0;\n  else\n  if(TxBufferEmpty & ReadTxDataFromFifo_wb)\n    TxUnderRun_wb <=#Tp 1'b1;\nend\n\n\nreg TxUnderRun_sync1;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun_sync1 <=#Tp 1'b0;\n  else\n  if(TxUnderRun_wb)\n    TxUnderRun_sync1 <=#Tp 1'b1;\n  else\n  if(BlockingTxStatusWrite_sync2)\n    TxUnderRun_sync1 <=#Tp 1'b0;\nend\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxUnderRun <=#Tp 1'b0;\n  else\n  if(BlockingTxStatusWrite_sync2)\n    TxUnderRun <=#Tp 1'b0;\n  else\n  if(TxUnderRun_sync1)\n    TxUnderRun <=#Tp 1'b1;\nend\n\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    TxByteCnt <=#Tp 2'h0;\n  else\n  if(TxAbort_q | TxRetry_q)\n    TxByteCnt <=#Tp 2'h0;\n  else\n  if(TxStartFrm & ~TxUsedData)\n    case(TxPointerLSB)  \n      2'h0 : TxByteCnt <=#Tp 2'h1;\n      2'h1 : TxByteCnt <=#Tp 2'h2;\n      2'h2 : TxByteCnt <=#Tp 2'h3;\n      2'h3 : TxByteCnt <=#Tp 2'h0;\n    endcase\n  else\n  if(TxUsedData & Flop)\n    TxByteCnt <=#Tp TxByteCnt + 1'b1;\nend\n\n\n\nreg ReadTxDataFromFifo_sync1;\nreg ReadTxDataFromFifo_sync2;\nreg ReadTxDataFromFifo_sync3;\nreg ReadTxDataFromFifo_syncb1;\nreg ReadTxDataFromFifo_syncb2;\nreg ReadTxDataFromFifo_syncb3;\n\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_tck <=#Tp 1'b0;\n  else\n  if(TxStartFrm_sync2 & ~TxStartFrm | TxUsedData & Flop & TxByteCnt == 2'h3 & ~LastWord | TxStartFrm & TxUsedData & Flop & TxByteCnt == 2'h0)\n     ReadTxDataFromFifo_tck <=#Tp 1'b1;\n  else\n  if(ReadTxDataFromFifo_syncb2 & ~ReadTxDataFromFifo_syncb3)\n    ReadTxDataFromFifo_tck <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync1 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync1 <=#Tp ReadTxDataFromFifo_tck;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync2 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync2 <=#Tp ReadTxDataFromFifo_sync1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb1 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb1 <=#Tp ReadTxDataFromFifo_sync2;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb2 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb2 <=#Tp ReadTxDataFromFifo_syncb1;\nend\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_syncb3 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_syncb3 <=#Tp ReadTxDataFromFifo_syncb2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ReadTxDataFromFifo_sync3 <=#Tp 1'b0;\n  else\n    ReadTxDataFromFifo_sync3 <=#Tp ReadTxDataFromFifo_sync2;\nend\n\nassign ReadTxDataFromFifo_wb = ReadTxDataFromFifo_sync2 & ~ReadTxDataFromFifo_sync3;\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetrySync1 <=#Tp 1'b0;\n  else\n    TxRetrySync1 <=#Tp TxRetry;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxRetry_wb <=#Tp 1'b0;\n  else\n    TxRetry_wb <=#Tp TxRetrySync1;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDoneSync1 <=#Tp 1'b0;\n  else\n    TxDoneSync1 <=#Tp TxDone;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxDone_wb <=#Tp 1'b0;\n  else\n    TxDone_wb <=#Tp TxDoneSync1;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbortSync1 <=#Tp 1'b0;\n  else\n    TxAbortSync1 <=#Tp TxAbort;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxAbort_wb <=#Tp 1'b0;\n  else\n    TxAbort_wb <=#Tp TxAbortSync1;\nend\n\n\nreg RxAbortSync1;\nreg RxAbortSync2;\nreg RxAbortSync3;\nreg RxAbortSync4;\nreg RxAbortSyncb1;\nreg RxAbortSyncb2;\n\nassign StartRxBDRead = RxStatusWrite | RxAbortSync3 & ~RxAbortSync4 | r_RxEn & ~r_RxEn_q;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDRead <=#Tp 1'b0;\n  else\n  if(StartRxBDRead & ~RxReady)\n    RxBDRead <=#Tp 1'b1;\n  else\n  if(RxBDReady)\n    RxBDRead <=#Tp 1'b0;\nend\n\n\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxBDReady <=#Tp 1'b0;\n  else\n  if(RxPointerRead)\n    RxBDReady <=#Tp 1'b0;\n  else\n  if(RxEn & RxEn_q & RxBDRead)\n    RxBDReady <=#Tp ram_do[15]; \nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxStatus <=#Tp 2'h0;\n  else\n  if(RxEn & RxEn_q & RxBDRead)\n    RxStatus <=#Tp ram_do[14:13];\nend\n\n\nassign RxStatus_s = (RxEn & RxEn_q & RxBDRead) ? ram_do[14:13] : RxStatus;\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxReady <=#Tp 1'b0;\n  else\n  if(ShiftEnded | RxAbortSync2 & ~RxAbortSync3 | ~r_RxEn & r_RxEn_q)\n    RxReady <=#Tp 1'b0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxReady <=#Tp 1'b1;\nend\n\n\n\n\n\nassign StartRxPointerRead = RxBDRead & RxBDReady;\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerRead <=#Tp 1'b0;\n  else\n  if(StartRxPointerRead)\n    RxPointerRead <=#Tp 1'b1;\n  else\n  if(RxEn & RxEn_q)\n    RxPointerRead <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerMSB <=#Tp 30'h0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxPointerMSB <=#Tp ram_do[31:2];\n  else\n  if(MasterWbRX & m_wb_ack_i)\n      RxPointerMSB <=#Tp RxPointerMSB + 1'b1; \nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(MasterWbRX & m_wb_ack_i)                 \n    RxPointerLSB_rst[1:0] <=#Tp 0;\n  else\n  if(RxEn & RxEn_q & RxPointerRead)\n    RxPointerLSB_rst[1:0] <=#Tp ram_do[1:0];\nend\n\n\nalways @ (RxPointerLSB_rst)\nbegin\n  case(RxPointerLSB_rst[1:0])  \n    2'h0 : RxByteSel[3:0] = 4'hf;\n    2'h1 : RxByteSel[3:0] = 4'h7;\n    2'h2 : RxByteSel[3:0] = 4'h3;\n    2'h3 : RxByteSel[3:0] = 4'h1;\n  endcase\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxEn_needed <=#Tp 1'b0;\n  else\n  if(~RxReady & r_RxEn & WbEn & ~WbEn_q)\n    RxEn_needed <=#Tp 1'b1;\n  else\n  if(RxPointerRead & RxEn & RxEn_q)\n    RxEn_needed <=#Tp 1'b0;\nend\n\n\n\nassign RxStatusWrite = ShiftEnded & RxEn & RxEn_q;\n\nreg RxEnableWindow;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LastByteIn <=#Tp 1'b0;\n  else\n  if(ShiftWillEnd & (&RxByteCnt) | RxAbort)\n    LastByteIn <=#Tp 1'b0;\n  else\n  if(RxValid & RxReady & RxEndFrm & ~(&RxByteCnt) & RxEnableWindow)\n    LastByteIn <=#Tp 1'b1;\nend\n\nreg ShiftEnded_rck;\nreg ShiftEndedSync1;\nreg ShiftEndedSync2;\nreg ShiftEndedSync3;\nreg ShiftEndedSync_c1;\nreg ShiftEndedSync_c2;\n\nwire StartShiftWillEnd;\nassign StartShiftWillEnd = LastByteIn  | RxValid & RxEndFrm & (&RxByteCnt) & RxEnableWindow;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftWillEnd <=#Tp 1'b0;\n  else\n  if(ShiftEnded_rck | RxAbort)\n    ShiftWillEnd <=#Tp 1'b0;\n  else\n  if(StartShiftWillEnd)\n    ShiftWillEnd <=#Tp 1'b1;\nend\n\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxByteCnt <=#Tp 2'h0;\n  else\n  if(ShiftEnded_rck | RxAbort)\n    RxByteCnt <=#Tp 2'h0;\n  else\n  if(RxValid & RxStartFrm & RxReady)\n    case(RxPointerLSB_rst)  \n      2'h0 : RxByteCnt <=#Tp 2'h1;\n      2'h1 : RxByteCnt <=#Tp 2'h2;\n      2'h2 : RxByteCnt <=#Tp 2'h3;\n      2'h3 : RxByteCnt <=#Tp 2'h0;\n    endcase\n  else\n  if(RxValid & RxEnableWindow & RxReady | LastByteIn)\n    RxByteCnt <=#Tp RxByteCnt + 1'b1;\nend\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxValidBytes <=#Tp 2'h1;\n  else\n  if(RxValid & RxStartFrm)\n    case(RxPointerLSB_rst)  \n      2'h0 : RxValidBytes <=#Tp 2'h1;\n      2'h1 : RxValidBytes <=#Tp 2'h2;\n      2'h2 : RxValidBytes <=#Tp 2'h3;\n      2'h3 : RxValidBytes <=#Tp 2'h0;\n    endcase\n  else\n  if(RxValid & ~LastByteIn & ~RxStartFrm & RxEnableWindow)\n    RxValidBytes <=#Tp RxValidBytes + 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxDataLatched1       <=#Tp 24'h0;\n  else\n  if(RxValid & RxReady & ~LastByteIn)\n    if(RxStartFrm)\n    begin\n      case(RxPointerLSB_rst)     \n        2'h0:        RxDataLatched1[31:24] <=#Tp RxData;            \n        2'h1:        RxDataLatched1[23:16] <=#Tp RxData;\n        2'h2:        RxDataLatched1[15:8]  <=#Tp RxData;\n        2'h3:        RxDataLatched1        <=#Tp RxDataLatched1;\n      endcase\n    end\n    else if (RxEnableWindow)\n    begin\n      case(RxByteCnt)     \n        2'h0:        RxDataLatched1[31:24] <=#Tp RxData;            \n        2'h1:        RxDataLatched1[23:16] <=#Tp RxData;\n        2'h2:        RxDataLatched1[15:8]  <=#Tp RxData;\n        2'h3:        RxDataLatched1        <=#Tp RxDataLatched1;\n      endcase\n    end\nend\n\nwire SetWriteRxDataToFifo;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxDataLatched2 <=#Tp 32'h0;\n  else\n  if(SetWriteRxDataToFifo & ~ShiftWillEnd)\n    RxDataLatched2 <=#Tp {RxDataLatched1[31:8], RxData};              \n  else\n  if(SetWriteRxDataToFifo & ShiftWillEnd)\n    case(RxValidBytes)  \n      0 : RxDataLatched2 <=#Tp {RxDataLatched1[31:8],  RxData};       \n      1 : RxDataLatched2 <=#Tp {RxDataLatched1[31:24], 24'h0};\n      2 : RxDataLatched2 <=#Tp {RxDataLatched1[31:16], 16'h0};\n      3 : RxDataLatched2 <=#Tp {RxDataLatched1[31:8],   8'h0};\n    endcase\nend\n\n\nreg WriteRxDataToFifoSync1;\nreg WriteRxDataToFifoSync2;\nreg WriteRxDataToFifoSync3;\n\n\n\nassign SetWriteRxDataToFifo = (RxValid & RxReady & ~RxStartFrm & RxEnableWindow & (&RxByteCnt)) | \n                              (RxValid & RxReady &  RxStartFrm & (&RxPointerLSB_rst))           | \n                              (ShiftWillEnd & LastByteIn & (&RxByteCnt));\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifo <=#Tp 1'b0;\n  else\n  if(SetWriteRxDataToFifo & ~RxAbort)\n    WriteRxDataToFifo <=#Tp 1'b1;\n  else\n  if(WriteRxDataToFifoSync2 | RxAbort)\n    WriteRxDataToFifo <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync1 <=#Tp 1'b0;\n  else\n  if(WriteRxDataToFifo)\n    WriteRxDataToFifoSync1 <=#Tp 1'b1;\n  else\n    WriteRxDataToFifoSync1 <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync2 <=#Tp 1'b0;\n  else\n    WriteRxDataToFifoSync2 <=#Tp WriteRxDataToFifoSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    WriteRxDataToFifoSync3 <=#Tp 1'b0;\n  else\n    WriteRxDataToFifoSync3 <=#Tp WriteRxDataToFifoSync2;\nend\n\nwire WriteRxDataToFifo_wb;\nassign WriteRxDataToFifo_wb = WriteRxDataToFifoSync2 & ~WriteRxDataToFifoSync3;\n\n\nreg LatchedRxStartFrm;\nreg SyncRxStartFrm;\nreg SyncRxStartFrm_q;\nreg SyncRxStartFrm_q2;\nwire RxFifoReset;\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LatchedRxStartFrm <=#Tp 0;\n  else\n  if(RxStartFrm & ~SyncRxStartFrm_q)\n    LatchedRxStartFrm <=#Tp 1;\n  else\n  if(SyncRxStartFrm_q)\n    LatchedRxStartFrm <=#Tp 0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm <=#Tp 0;\n  else\n  if(LatchedRxStartFrm)\n    SyncRxStartFrm <=#Tp 1;\n  else\n    SyncRxStartFrm <=#Tp 0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm_q <=#Tp 0;\n  else\n    SyncRxStartFrm_q <=#Tp SyncRxStartFrm;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    SyncRxStartFrm_q2 <=#Tp 0;\n  else\n    SyncRxStartFrm_q2 <=#Tp SyncRxStartFrm_q;\nend\n\n\nassign RxFifoReset = SyncRxStartFrm_q & ~SyncRxStartFrm_q2;\n\n\neth_fifo #(`ETH_RX_FIFO_DATA_WIDTH, `ETH_RX_FIFO_DEPTH, `ETH_RX_FIFO_CNT_WIDTH)\nrx_fifo (.data_in(RxDataLatched2),                      .data_out(m_wb_dat_o), \n         .clk(WB_CLK_I),                                .reset(Reset), \n         .write(WriteRxDataToFifo_wb & ~RxBufferFull),  .read(MasterWbRX & m_wb_ack_i), \n         .clear(RxFifoReset),                           .full(RxBufferFull), \n         .almost_full(),                                .almost_empty(RxBufferAlmostEmpty), \n         .empty(RxBufferEmpty),                         .cnt(rxfifo_cnt)\n        );\n\nassign enough_data_in_rxfifo_for_burst = rxfifo_cnt>=`ETH_BURST_LENGTH;\nassign enough_data_in_rxfifo_for_burst_plus1 = rxfifo_cnt>`ETH_BURST_LENGTH;\nassign WriteRxDataToMemory = ~RxBufferEmpty;\nassign rx_burst = rx_burst_en & WriteRxDataToMemory;\n\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEnded_rck <=#Tp 1'b0;\n  else\n  if(~RxAbort & SetWriteRxDataToFifo & StartShiftWillEnd)\n    ShiftEnded_rck <=#Tp 1'b1;\n  else\n  if(RxAbort | ShiftEndedSync_c1 & ShiftEndedSync_c2)\n    ShiftEnded_rck <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync1 <=#Tp 1'b0;\n  else\n    ShiftEndedSync1 <=#Tp ShiftEnded_rck;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync2 <=#Tp 1'b0;\n  else\n    ShiftEndedSync2 <=#Tp ShiftEndedSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync3 <=#Tp 1'b0;\n  else\n  if(ShiftEndedSync1 & ~ShiftEndedSync2)\n    ShiftEndedSync3 <=#Tp 1'b1;\n  else\n  if(ShiftEnded)\n    ShiftEndedSync3 <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEnded <=#Tp 1'b0;\n  else\n  if(ShiftEndedSync3 & MasterWbRX & m_wb_ack_i & RxBufferAlmostEmpty & ~ShiftEnded)\n    ShiftEnded <=#Tp 1'b1;\n  else\n  if(RxStatusWrite)\n    ShiftEnded <=#Tp 1'b0;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync_c1 <=#Tp 1'b0;\n  else\n    ShiftEndedSync_c1 <=#Tp ShiftEndedSync2;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    ShiftEndedSync_c2 <=#Tp 1'b0;\n  else\n    ShiftEndedSync_c2 <=#Tp ShiftEndedSync_c1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxEnableWindow <=#Tp 1'b0;\n  else\n  if(RxStartFrm)\n    RxEnableWindow <=#Tp 1'b1;\n  else\n  if(RxEndFrm | RxAbort)\n    RxEnableWindow <=#Tp 1'b0;\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync1 <=#Tp 1'b0;\n  else\n    RxAbortSync1 <=#Tp RxAbortLatched;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync2 <=#Tp 1'b0;\n  else\n    RxAbortSync2 <=#Tp RxAbortSync1;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync3 <=#Tp 1'b0;\n  else\n    RxAbortSync3 <=#Tp RxAbortSync2;\nend\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSync4 <=#Tp 1'b0;\n  else\n    RxAbortSync4 <=#Tp RxAbortSync3;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSyncb1 <=#Tp 1'b0;\n  else\n    RxAbortSyncb1 <=#Tp RxAbortSync2;\nend\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortSyncb2 <=#Tp 1'b0;\n  else\n    RxAbortSyncb2 <=#Tp RxAbortSyncb1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxAbortLatched <=#Tp 1'b0;\n  else\n  if(RxAbortSyncb2)\n    RxAbortLatched <=#Tp 1'b0;\n  else\n  if(RxAbort)\n    RxAbortLatched <=#Tp 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    LatchedRxLength[15:0] <=#Tp 16'h0;\n  else\n  if(LoadRxStatus)\n    LatchedRxLength[15:0] <=#Tp RxLength[15:0];\nend\n\n\nassign RxStatusIn = {ReceivedPauseFrm, AddressMiss, RxOverrun, InvalidSymbol, DribbleNibble, ReceivedPacketTooBig, ShortFrame, LatchedCrcError, RxLateCollision};\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    RxStatusInLatched <=#Tp 'h0;\n  else\n  if(LoadRxStatus)\n    RxStatusInLatched <=#Tp RxStatusIn;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxOverrun <=#Tp 1'b0;\n  else\n  if(RxStatusWrite)\n    RxOverrun <=#Tp 1'b0;\n  else\n  if(RxBufferFull & WriteRxDataToFifo_wb)\n    RxOverrun <=#Tp 1'b1;\nend\n\n\n\nwire TxError;\nassign TxError = TxUnderRun | RetryLimit | LateCollLatched | CarrierSenseLost;\n\nwire RxError;\n\n\n\n\n\nassign RxError = (|RxStatusInLatched[6:3]) | (|RxStatusInLatched[1:0]);\n\n\n\nreg RxStatusWriteLatched;\nreg RxStatusWriteLatched_sync1;\nreg RxStatusWriteLatched_sync2;\nreg RxStatusWriteLatched_syncb1;\nreg RxStatusWriteLatched_syncb2;\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxStatusWriteLatched <=#Tp 1'b0;\n  else\n  if(RxStatusWriteLatched_syncb2)\n    RxStatusWriteLatched <=#Tp 1'b0;        \n  else\n  if(RxStatusWrite)\n    RxStatusWriteLatched <=#Tp 1'b1;\nend\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      RxStatusWriteLatched_sync1 <=#Tp 1'b0;\n      RxStatusWriteLatched_sync2 <=#Tp 1'b0;\n    end\n  else\n    begin\n      RxStatusWriteLatched_sync1 <=#Tp RxStatusWriteLatched;\n      RxStatusWriteLatched_sync2 <=#Tp RxStatusWriteLatched_sync1;\n    end\nend\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      RxStatusWriteLatched_syncb1 <=#Tp 1'b0;\n      RxStatusWriteLatched_syncb2 <=#Tp 1'b0;\n    end\n  else\n    begin\n      RxStatusWriteLatched_syncb1 <=#Tp RxStatusWriteLatched_sync2;\n      RxStatusWriteLatched_syncb2 <=#Tp RxStatusWriteLatched_syncb1;\n    end\nend\n\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxB_IRQ <=#Tp 1'b0;\n  else\n  if(TxStatusWrite & TxIRQEn)\n    TxB_IRQ <=#Tp ~TxError;\n  else\n    TxB_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    TxE_IRQ <=#Tp 1'b0;\n  else\n  if(TxStatusWrite & TxIRQEn)\n    TxE_IRQ <=#Tp TxError;\n  else\n    TxE_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxB_IRQ <=#Tp 1'b0;\n  else\n  if(RxStatusWrite & RxIRQEn & ReceivedPacketGood & (~ReceivedPauseFrm | ReceivedPauseFrm & r_PassAll & (~r_RxFlow)))\n    RxB_IRQ <=#Tp (~RxError);\n  else\n    RxB_IRQ <=#Tp 1'b0;\nend\n\n\n\nalways @ (posedge WB_CLK_I or posedge Reset)\nbegin\n  if(Reset)\n    RxE_IRQ <=#Tp 1'b0;\n  else\n  if(RxStatusWrite & RxIRQEn & (~ReceivedPauseFrm | ReceivedPauseFrm & r_PassAll & (~r_RxFlow)))\n    RxE_IRQ <=#Tp RxError;\n  else\n    RxE_IRQ <=#Tp 1'b0;\nend\n\n\n\n\nreg Busy_IRQ_rck;\nreg Busy_IRQ_sync1;\nreg Busy_IRQ_sync2;\nreg Busy_IRQ_sync3;\nreg Busy_IRQ_syncb1;\nreg Busy_IRQ_syncb2;\n\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    Busy_IRQ_rck <=#Tp 1'b0;\n  else\n  if(RxValid & RxStartFrm & ~RxReady)\n    Busy_IRQ_rck <=#Tp 1'b1;\n  else\n  if(Busy_IRQ_syncb2)\n    Busy_IRQ_rck <=#Tp 1'b0;\nend\n\nalways @ (posedge WB_CLK_I)\nbegin\n    Busy_IRQ_sync1 <=#Tp Busy_IRQ_rck;\n    Busy_IRQ_sync2 <=#Tp Busy_IRQ_sync1;\n    Busy_IRQ_sync3 <=#Tp Busy_IRQ_sync2;\nend\n\nalways @ (posedge MRxClk)\nbegin\n    Busy_IRQ_syncb1 <=#Tp Busy_IRQ_sync2;\n    Busy_IRQ_syncb2 <=#Tp Busy_IRQ_syncb1;\nend\n\nassign Busy_IRQ = Busy_IRQ_sync2 & ~Busy_IRQ_sync3;\n\n\n         \n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: eth_wishbone. Module specification: This module implements an Ethernet Wishbone interface controller, managing communication between the Ethernet MAC and the Wishbone bus for transmit and receive operations. It handles buffer management, status handling, and interrupt generation. Key inputs include clock signals, Wishbone bus inputs, Ethernet MAC signals, and configuration inputs. Outputs consist of Wishbone bus outputs, Ethernet MAC control signals, and interrupt signals. Internal signals manage buffer states, pointers, and various control flags. The module is divided into several functional blocks: Wishbone interface logic, transmit path logic, receive path logic, FIFO management, and interrupt generation. It coordinates data transfers between the Wishbone bus and Ethernet frames, manages buffer descriptors, and handles various control signals and status flags related to Ethernet packet transmission and reception. The design incorporates synchronization mechanisms between different clock domains and implements error handling for conditions such as under"
                }
            ]
        }
    ]
}