{
    "spec": "Module name: eth_top. Module specification: The eth_top module is the top-level module for an Ethernet MAC (Media Access Control) implementation. It integrates various sub-modules to handle Ethernet frame transmission and reception, MAC control operations, MIIM (Management Interface) functionality, and Wishbone bus interfacing. The module has input ports for clocks, resets, Wishbone bus inputs, MAC transmit and receive signals, and MIIM data; output ports for Wishbone bus outputs, MAC transmit signals, and interrupt. Internal signals include control registers, status flags, and data flow signals. The module is composed of several key blocks: eth_registers for configuration and status registers, eth_rxethmac and eth_txethmac for receive and transmit operations, eth_maccontrol for flow control and pause frame handling, eth_miim for PHY management, eth_wishbone for DMA an",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: eth_top\n\nExplanation: This module appears to be the top-level module for an Ethernet MAC (Media Access Control) implementation. It integrates various sub-modules to handle Ethernet frame transmission and reception, MAC control operations, MIIM (Management Interface) functionality, and Wishbone bus interfacing. The module includes components for managing transmit and receive operations, handling flow control, performing address filtering, and managing buffer descriptors. It also incorporates features like collision detection, CRC checking, and various configuration options for Ethernet communication parameters. The module is designed to interface with external PHY devices and a host system through Wishbone bus, providing a complete Ethernet MAC solution."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nwb_clk_i, wb_rst_i, wb_dat_i, wb_adr_i, wb_sel_i, wb_we_i, wb_cyc_i, wb_stb_i, m_wb_dat_i, m_wb_ack_i, m_wb_err_i, mtx_clk_pad_i, mrx_clk_pad_i, mrxd_pad_i, mrxdv_pad_i, mrxerr_pad_i, mcoll_pad_i, mcrs_pad_i, md_pad_i.\n\nExplanation:\nThese ports include clock and reset signals, Wishbone bus inputs for host interface, master Wishbone bus inputs, MAC transmit and receive clocks, receive data and control signals, collision and carrier sense inputs, and MIIM data input.\n\nOutput ports:\nwb_dat_o, wb_ack_o, wb_err_o, m_wb_adr_o, m_wb_sel_o, m_wb_we_o, m_wb_dat_o, m_wb_cyc_o, m_wb_stb_o, mtxd_pad_o, mtxen_pad_o, mtxerr_pad_o, mdc_pad_o, md_pad_o, md_padoe_o, int_o.\n\nExplanation:\nThese ports include Wishbone bus outputs for host interface, master Wishbone bus outputs, MAC transmit data and control signals, MIIM clock and data outputs, and an interrupt output. They are used for communicating with the host system, external PHY, and other parts of the system."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nr_ClkDiv, r_MiiNoPre, r_CtrlData, r_FIAD, r_RGAD, r_WCtrlData, r_RStat, r_ScanStat, NValid_stat, Busy_stat, LinkFail, Prsd, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg, TxStartFrm, TxEndFrm, TxUsedData, TxData, TxRetry, TxAbort, TxUnderRun, TxDone, WillSendControlFrame_sync1, WillSendControlFrame_sync2, WillSendControlFrame_sync3, RstTxPauseRq, TxPauseRq_sync1, TxPauseRq_sync2, TxPauseRq_sync3, TPauseRq, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, WillTransmit, ResetCollision, TxDataOut, WillSendControlFrame, ReceiveEnd, ReceivedPacketGood, ReceivedLengthOK, InvalidSymbol, LatchedCrcError, RxLateCollision, RetryCntLatched, RetryCnt, StartTxAbort, MaxCollisionOccured, RetryLimit, StatePreamble, StateData.\n\nExplanation:\nThese internal signals serve various purposes within the module:\n- MIIM control signals (e.g., r_ClkDiv, r_MiiNoPre, r_CtrlData) for managing the management interface.\n- Transmit and receive control signals (e.g., TxStartFrm, TxEndFrm, RxValid, RxStartFrm) for handling Ethernet frame transmission and reception.\n- Status signals (e.g., Busy_stat, LinkFail, ReceivedPacketGood) for indicating various conditions and events.\n- Synchronization signals (e.g., WillSendControlFrame_sync1, TxPauseRq_sync1) for managing clock domain crossings.\n- Flow control signals (e.g., TPauseRq, RstTxPauseRq) for implementing Ethernet flow control mechanisms.\n- Collision and retry signals (e.g., ResetCollision, RetryCnt, MaxCollisionOccured) for managing CSMA/CD operations.\n- State signals (e.g., StatePreamble, StateData) for tracking the current state of transmit and receive operations.\n\nThese signals facilitate communication between different sub-modules, manage control flow, and maintain the overall state of the Ethernet MAC operations."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_top\n(\n  \n  wb_clk_i, wb_rst_i, wb_dat_i, wb_dat_o, \n\n  \n  wb_adr_i, wb_sel_i, wb_we_i, wb_cyc_i, wb_stb_i, wb_ack_o, wb_err_o, \n\n  \n  m_wb_adr_o, m_wb_sel_o, m_wb_we_o, \n  m_wb_dat_o, m_wb_dat_i, m_wb_cyc_o, \n  m_wb_stb_o, m_wb_ack_i, m_wb_err_i, \n\n`ifdef ETH_WISHBONE_B3\n  m_wb_cti_o, m_wb_bte_o, \n`endif\n\n  \n  mtx_clk_pad_i, mtxd_pad_o, mtxen_pad_o, mtxerr_pad_o,\n\n  \n  mrx_clk_pad_i, mrxd_pad_i, mrxdv_pad_i, mrxerr_pad_i, mcoll_pad_i, mcrs_pad_i, \n  \n  \n  mdc_pad_o, md_pad_i, md_pad_o, md_padoe_o,\n\n  int_o\n\n  \n`ifdef ETH_BIST\n  ,\n  \n  mbist_si_i,       \n  mbist_so_o,       \n  mbist_ctrl_i        \n`endif\n\n);\n\n\nparameter Tp = 1;\n\n\n\ninput           wb_clk_i;     \ninput           wb_rst_i;     \ninput   [31:0]  wb_dat_i;     \noutput  [31:0]  wb_dat_o;     \noutput          wb_err_o;     \n\n\ninput   [11:2]  wb_adr_i;     \ninput    [3:0]  wb_sel_i;     \ninput           wb_we_i;      \ninput           wb_cyc_i;     \ninput           wb_stb_i;     \noutput          wb_ack_o;     \n\n\noutput  [31:0]  m_wb_adr_o;\noutput   [3:0]  m_wb_sel_o;\noutput          m_wb_we_o;\ninput   [31:0]  m_wb_dat_i;\noutput  [31:0]  m_wb_dat_o;\noutput          m_wb_cyc_o;\noutput          m_wb_stb_o;\ninput           m_wb_ack_i;\ninput           m_wb_err_i;\n\nwire    [29:0]  m_wb_adr_tmp;\n\n`ifdef ETH_WISHBONE_B3\noutput   [2:0]  m_wb_cti_o;   \noutput   [1:0]  m_wb_bte_o;   \n`endif\n\n\ninput           mtx_clk_pad_i; \noutput   [3:0]  mtxd_pad_o;    \noutput          mtxen_pad_o;   \noutput          mtxerr_pad_o;  \n\n\ninput           mrx_clk_pad_i; \ninput    [3:0]  mrxd_pad_i;    \ninput           mrxdv_pad_i;   \ninput           mrxerr_pad_i;  \n\n\ninput           mcoll_pad_i;   \ninput           mcrs_pad_i;    \n\n\ninput           md_pad_i;      \noutput          mdc_pad_o;     \noutput          md_pad_o;      \noutput          md_padoe_o;    \n\noutput          int_o;         \n\n\n`ifdef ETH_BIST\ninput   mbist_si_i;       \noutput  mbist_so_o;       \ninput [`ETH_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i;       \n`endif\n\nwire     [7:0]  r_ClkDiv;\nwire            r_MiiNoPre;\nwire    [15:0]  r_CtrlData;\nwire     [4:0]  r_FIAD;\nwire     [4:0]  r_RGAD;\nwire            r_WCtrlData;\nwire            r_RStat;\nwire            r_ScanStat;\nwire            NValid_stat;\nwire            Busy_stat;\nwire            LinkFail;\nwire    [15:0]  Prsd;             \nwire            WCtrlDataStart;\nwire            RStatStart;\nwire            UpdateMIIRX_DATAReg;\n\nwire            TxStartFrm;\nwire            TxEndFrm;\nwire            TxUsedData;\nwire     [7:0]  TxData;\nwire            TxRetry;\nwire            TxAbort;\nwire            TxUnderRun;\nwire            TxDone;\n\n\nreg             WillSendControlFrame_sync1;\nreg             WillSendControlFrame_sync2;\nreg             WillSendControlFrame_sync3;\nreg             RstTxPauseRq;\n\nreg             TxPauseRq_sync1;\nreg             TxPauseRq_sync2;\nreg             TxPauseRq_sync3;\nreg             TPauseRq;\n\n\n\neth_miim miim1\n(\n  .Clk(wb_clk_i),                         .Reset(wb_rst_i),                   .Divider(r_ClkDiv), \n  .NoPre(r_MiiNoPre),                     .CtrlData(r_CtrlData),              .Rgad(r_RGAD), \n  .Fiad(r_FIAD),                          .WCtrlData(r_WCtrlData),            .RStat(r_RStat), \n  .ScanStat(r_ScanStat),                  .Mdi(md_pad_i),                     .Mdo(md_pad_o), \n  .MdoEn(md_padoe_o),                     .Mdc(mdc_pad_o),                    .Busy(Busy_stat), \n  .Prsd(Prsd),                            .LinkFail(LinkFail),                .Nvalid(NValid_stat), \n  .WCtrlDataStart(WCtrlDataStart),        .RStatStart(RStatStart),            .UpdateMIIRX_DATAReg(UpdateMIIRX_DATAReg)\n);\n\n\n\n\nwire  [3:0] RegCs;          \nwire [31:0] RegDataOut;     \nwire        r_RecSmall;     \nwire        r_LoopBck;      \nwire        r_TxEn;         \nwire        r_RxEn;         \n\nwire        MRxDV_Lb;       \nwire        MRxErr_Lb;      \nwire  [3:0] MRxD_Lb;        \nwire        Transmitting;   \nwire        r_HugEn;        \nwire        r_DlyCrcEn;     \nwire [15:0] r_MaxFL;        \n\nwire [15:0] r_MinFL;        \nwire        ShortFrame;\nwire        DribbleNibble;  \nwire        ReceivedPacketTooBig; \nwire [47:0] r_MAC;          \nwire        LoadRxStatus;   \nwire [31:0] r_HASH0;        \nwire [31:0] r_HASH1;        \nwire  [7:0] r_TxBDNum;      \nwire  [6:0] r_IPGT;         \nwire  [6:0] r_IPGR1;        \nwire  [6:0] r_IPGR2;        \nwire  [5:0] r_CollValid;    \nwire [15:0] r_TxPauseTV;    \nwire        r_TxPauseRq;    \n\nwire  [3:0] r_MaxRet;       \nwire        r_NoBckof;      \nwire        r_ExDfrEn;      \nwire        r_TxFlow;       \nwire        r_IFG;          \n\nwire        TxB_IRQ;        \nwire        TxE_IRQ;        \nwire        RxB_IRQ;        \nwire        RxE_IRQ;        \nwire        Busy_IRQ;       \n\n\nwire        ByteSelected;\nwire        BDAck;\nwire [31:0] BD_WB_DAT_O;    \nwire  [3:0] BDCs;           \nwire        CsMiss;         \n                            \nwire        r_Pad;\nwire        r_CrcEn;\nwire        r_FullD;\nwire        r_Pro;\nwire        r_Bro;\nwire        r_NoPre;\nwire        r_RxFlow;\nwire        r_PassAll;\nwire        TxCtrlEndFrm;\nwire        StartTxDone;\nwire        SetPauseTimer;\nwire        TxUsedDataIn;\nwire        TxDoneIn;\nwire        TxAbortIn;\nwire        PerPacketPad;\nwire        PadOut;\nwire        PerPacketCrcEn;\nwire        CrcEnOut;\nwire        TxStartFrmOut;\nwire        TxEndFrmOut;\nwire        ReceivedPauseFrm;\nwire        ControlFrmAddressOK;\nwire        RxStatusWriteLatched_sync2;\nwire        LateCollision;\nwire        DeferIndication;\nwire        LateCollLatched;\nwire        DeferLatched;\nwire        RstDeferLatched;\nwire        CarrierSenseLost;\n\nwire        temp_wb_ack_o;\nwire [31:0] temp_wb_dat_o;\nwire        temp_wb_err_o;\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  reg         temp_wb_ack_o_reg;\n  reg [31:0]  temp_wb_dat_o_reg;\n  reg         temp_wb_err_o_reg;\n`endif\n\n\nassign ByteSelected = |wb_sel_i;\nassign RegCs[3] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[3];   \nassign RegCs[2] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[2];   \nassign RegCs[1] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[1];   \nassign RegCs[0] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[0];   \nassign BDCs[3]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[3];   \nassign BDCs[2]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[2];   \nassign BDCs[1]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[1];   \nassign BDCs[0]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[0];   \nassign CsMiss = wb_stb_i & wb_cyc_i & ByteSelected & wb_adr_i[11];                   \nassign temp_wb_dat_o = ((|RegCs) & ~wb_we_i)? RegDataOut : BD_WB_DAT_O;\nassign temp_wb_err_o = wb_stb_i & wb_cyc_i & (~ByteSelected | CsMiss);\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  assign wb_ack_o = temp_wb_ack_o_reg;\n  assign wb_dat_o[31:0] = temp_wb_dat_o_reg;\n  assign wb_err_o = temp_wb_err_o_reg;\n`else\n  assign wb_ack_o = temp_wb_ack_o;\n  assign wb_dat_o[31:0] = temp_wb_dat_o;\n  assign wb_err_o = temp_wb_err_o;\n`endif\n\n`ifdef ETH_AVALON_BUS\n  \n  \n  \n  \n  \n  assign temp_wb_ack_o = (|RegCs) | BDAck | CsMiss;\n`else \n  assign temp_wb_ack_o = (|RegCs) | BDAck;\n`endif\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  always @ (posedge wb_clk_i or posedge wb_rst_i)\n  begin\n    if(wb_rst_i)\n      begin\n        temp_wb_ack_o_reg <=#Tp 1'b0;\n        temp_wb_dat_o_reg <=#Tp 32'h0;\n        temp_wb_err_o_reg <=#Tp 1'b0;\n      end\n    else\n      begin\n        temp_wb_ack_o_reg <=#Tp temp_wb_ack_o & ~temp_wb_ack_o_reg;\n        temp_wb_dat_o_reg <=#Tp temp_wb_dat_o;\n        temp_wb_err_o_reg <=#Tp temp_wb_err_o & ~temp_wb_err_o_reg;\n      end\n  end\n`endif\n\n\n\neth_registers ethreg1\n(\n  .DataIn(wb_dat_i),                      .Address(wb_adr_i[9:2]),                    .Rw(wb_we_i), \n  .Cs(RegCs),                             .Clk(wb_clk_i),                             .Reset(wb_rst_i), \n  .DataOut(RegDataOut),                   .r_RecSmall(r_RecSmall), \n  .r_Pad(r_Pad),                          .r_HugEn(r_HugEn),                          .r_CrcEn(r_CrcEn), \n  .r_DlyCrcEn(r_DlyCrcEn),                .r_FullD(r_FullD), \n  .r_ExDfrEn(r_ExDfrEn),                  .r_NoBckof(r_NoBckof),                      .r_LoopBck(r_LoopBck), \n  .r_IFG(r_IFG),                          .r_Pro(r_Pro),                              .r_Iam(), \n  .r_Bro(r_Bro),                          .r_NoPre(r_NoPre),                          .r_TxEn(r_TxEn), \n  .r_RxEn(r_RxEn),                        .Busy_IRQ(Busy_IRQ),                        .RxE_IRQ(RxE_IRQ), \n  .RxB_IRQ(RxB_IRQ),                      .TxE_IRQ(TxE_IRQ),                          .TxB_IRQ(TxB_IRQ), \n  .r_IPGT(r_IPGT), \n  .r_IPGR1(r_IPGR1),                      .r_IPGR2(r_IPGR2),                          .r_MinFL(r_MinFL), \n  .r_MaxFL(r_MaxFL),                      .r_MaxRet(r_MaxRet),                        .r_CollValid(r_CollValid), \n  .r_TxFlow(r_TxFlow),                    .r_RxFlow(r_RxFlow),                        .r_PassAll(r_PassAll), \n  .r_MiiNoPre(r_MiiNoPre),                .r_ClkDiv(r_ClkDiv), \n  .r_WCtrlData(r_WCtrlData),              .r_RStat(r_RStat),                          .r_ScanStat(r_ScanStat), \n  .r_RGAD(r_RGAD),                        .r_FIAD(r_FIAD),                            .r_CtrlData(r_CtrlData), \n  .NValid_stat(NValid_stat),              .Busy_stat(Busy_stat),                   \n  .LinkFail(LinkFail),                    .r_MAC(r_MAC),                              .WCtrlDataStart(WCtrlDataStart),\n  .RStatStart(RStatStart),                .UpdateMIIRX_DATAReg(UpdateMIIRX_DATAReg),  .Prsd(Prsd), \n  .r_TxBDNum(r_TxBDNum),                  .int_o(int_o),\n  .r_HASH0(r_HASH0),                      .r_HASH1(r_HASH1),                          .r_TxPauseRq(r_TxPauseRq), \n  .r_TxPauseTV(r_TxPauseTV),              .RstTxPauseRq(RstTxPauseRq),                .TxCtrlEndFrm(TxCtrlEndFrm), \n  .StartTxDone(StartTxDone),              .TxClk(mtx_clk_pad_i),                      .RxClk(mrx_clk_pad_i), \n  .SetPauseTimer(SetPauseTimer)\n  \n);\n\n\n\nwire  [7:0] RxData;\nwire        RxValid;\nwire        RxStartFrm;\nwire        RxEndFrm;\nwire        RxAbort;\n\nwire        WillTransmit;            \nwire        ResetCollision;          \nwire  [7:0] TxDataOut;               \nwire        WillSendControlFrame;\nwire        ReceiveEnd;\nwire        ReceivedPacketGood;\nwire        ReceivedLengthOK;\nwire        InvalidSymbol;\nwire        LatchedCrcError;\nwire        RxLateCollision;\nwire  [3:0] RetryCntLatched;   \nwire  [3:0] RetryCnt;   \nwire        StartTxAbort;   \nwire        MaxCollisionOccured;   \nwire        RetryLimit;   \nwire        StatePreamble;   \nwire  [1:0] StateData; \n\n\neth_maccontrol maccontrol1\n(\n  .MTxClk(mtx_clk_pad_i),                       .TPauseRq(TPauseRq), \n  .TxPauseTV(r_TxPauseTV),                      .TxDataIn(TxData), \n  .TxStartFrmIn(TxStartFrm),                    .TxEndFrmIn(TxEndFrm), \n  .TxUsedDataIn(TxUsedDataIn),                  .TxDoneIn(TxDoneIn), \n  .TxAbortIn(TxAbortIn),                        .MRxClk(mrx_clk_pad_i), \n  .RxData(RxData),                              .RxValid(RxValid), \n  .RxStartFrm(RxStartFrm),                      .RxEndFrm(RxEndFrm),\n  .ReceiveEnd(ReceiveEnd),                      .ReceivedPacketGood(ReceivedPacketGood),\n  .TxFlow(r_TxFlow), \n  .RxFlow(r_RxFlow),                            .DlyCrcEn(r_DlyCrcEn),\n  .MAC(r_MAC),                                  .PadIn(r_Pad | PerPacketPad), \n  .PadOut(PadOut),                              .CrcEnIn(r_CrcEn | PerPacketCrcEn), \n  .CrcEnOut(CrcEnOut),                          .TxReset(wb_rst_i), \n  .RxReset(wb_rst_i),                           .ReceivedLengthOK(ReceivedLengthOK),\n  .TxDataOut(TxDataOut),                        .TxStartFrmOut(TxStartFrmOut), \n  .TxEndFrmOut(TxEndFrmOut),                    .TxUsedDataOut(TxUsedData), \n  .TxDoneOut(TxDone),                           .TxAbortOut(TxAbort), \n  .WillSendControlFrame(WillSendControlFrame),  .TxCtrlEndFrm(TxCtrlEndFrm), \n  .ReceivedPauseFrm(ReceivedPauseFrm),          .ControlFrmAddressOK(ControlFrmAddressOK),\n  .SetPauseTimer(SetPauseTimer),\n  .RxStatusWriteLatched_sync2(RxStatusWriteLatched_sync2),                .r_PassAll(r_PassAll)\n);\n\n\n\nwire TxCarrierSense;          \nwire Collision;               \n\nreg CarrierSense_Tx1;\nreg CarrierSense_Tx2;\nreg Collision_Tx1;\nreg Collision_Tx2;\n\nreg RxEnSync;                 \nreg WillTransmit_q;\nreg WillTransmit_q2;\n\n\n\n\nassign MRxDV_Lb = r_LoopBck? mtxen_pad_o : mrxdv_pad_i & RxEnSync;\n\n\nassign MRxErr_Lb = r_LoopBck? mtxerr_pad_o : mrxerr_pad_i & RxEnSync;\n\n\nassign MRxD_Lb[3:0] = r_LoopBck? mtxd_pad_o[3:0] : mrxd_pad_i[3:0];\n\n\n\n\neth_txethmac txethmac1\n(\n  .MTxClk(mtx_clk_pad_i),             .Reset(wb_rst_i),                   .CarrierSense(TxCarrierSense), \n  .Collision(Collision),              .TxData(TxDataOut),                 .TxStartFrm(TxStartFrmOut), \n  .TxUnderRun(TxUnderRun),            .TxEndFrm(TxEndFrmOut),             .Pad(PadOut),  \n  .MinFL(r_MinFL),                    .CrcEn(CrcEnOut),                   .FullD(r_FullD), \n  .HugEn(r_HugEn),                    .DlyCrcEn(r_DlyCrcEn),              .IPGT(r_IPGT), \n  .IPGR1(r_IPGR1),                    .IPGR2(r_IPGR2),                    .CollValid(r_CollValid), \n  .MaxRet(r_MaxRet),                  .NoBckof(r_NoBckof),                .ExDfrEn(r_ExDfrEn), \n  .MaxFL(r_MaxFL),                    .MTxEn(mtxen_pad_o),                .MTxD(mtxd_pad_o), \n  .MTxErr(mtxerr_pad_o),              .TxUsedData(TxUsedDataIn),          .TxDone(TxDoneIn), \n  .TxRetry(TxRetry),                  .TxAbort(TxAbortIn),                .WillTransmit(WillTransmit), \n  .ResetCollision(ResetCollision),    .RetryCnt(RetryCnt),                .StartTxDone(StartTxDone), \n  .StartTxAbort(StartTxAbort),        .MaxCollisionOccured(MaxCollisionOccured), .LateCollision(LateCollision),   \n  .DeferIndication(DeferIndication),  .StatePreamble(StatePreamble),      .StateData(StateData)   \n);\n\n\n\n\nwire  [15:0]  RxByteCnt;\nwire          RxByteCntEq0;\nwire          RxByteCntGreat2;\nwire          RxByteCntMaxFrame;\nwire          RxCrcError;\nwire          RxStateIdle;\nwire          RxStatePreamble;\nwire          RxStateSFD;\nwire   [1:0]  RxStateData;\nwire          AddressMiss;\n\n\n\n\neth_rxethmac rxethmac1\n(\n  .MRxClk(mrx_clk_pad_i),               .MRxDV(MRxDV_Lb),                     .MRxD(MRxD_Lb),\n  .Transmitting(Transmitting),          .HugEn(r_HugEn),                      .DlyCrcEn(r_DlyCrcEn), \n  .MaxFL(r_MaxFL),                      .r_IFG(r_IFG),                        .Reset(wb_rst_i),\n  .RxData(RxData),                      .RxValid(RxValid),                    .RxStartFrm(RxStartFrm), \n  .RxEndFrm(RxEndFrm),                  .ByteCnt(RxByteCnt), \n  .ByteCntEq0(RxByteCntEq0),            .ByteCntGreat2(RxByteCntGreat2),      .ByteCntMaxFrame(RxByteCntMaxFrame), \n  .CrcError(RxCrcError),                .StateIdle(RxStateIdle),              .StatePreamble(RxStatePreamble), \n  .StateSFD(RxStateSFD),                .StateData(RxStateData),\n  .MAC(r_MAC),                          .r_Pro(r_Pro),                        .r_Bro(r_Bro),\n  .r_HASH0(r_HASH0),                    .r_HASH1(r_HASH1),                    .RxAbort(RxAbort), \n  .AddressMiss(AddressMiss),            .PassAll(r_PassAll),                  .ControlFrmAddressOK(ControlFrmAddressOK)\n);\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      CarrierSense_Tx1 <= #Tp 1'b0;\n      CarrierSense_Tx2 <= #Tp 1'b0;\n    end\n  else\n    begin\n      CarrierSense_Tx1 <= #Tp mcrs_pad_i;\n      CarrierSense_Tx2 <= #Tp CarrierSense_Tx1;\n    end\nend\n\nassign TxCarrierSense = ~r_FullD & CarrierSense_Tx2;\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      Collision_Tx1 <= #Tp 1'b0;\n      Collision_Tx2 <= #Tp 1'b0;\n    end\n  else\n    begin\n      Collision_Tx1 <= #Tp mcoll_pad_i;\n      if(ResetCollision)\n        Collision_Tx2 <= #Tp 1'b0;\n      else\n      if(Collision_Tx1)\n        Collision_Tx2 <= #Tp 1'b1;\n    end\nend\n\n\n\nassign Collision = ~r_FullD & Collision_Tx2;\n\n\n\n\nalways @ (posedge mrx_clk_pad_i)\nbegin\n  WillTransmit_q <= #Tp WillTransmit;\n  WillTransmit_q2 <= #Tp WillTransmit_q;\nend \n\n\nassign Transmitting = ~r_FullD & WillTransmit_q2;\n\n\n\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RxEnSync <= #Tp 1'b0;\n  else\n  if(~mrxdv_pad_i)\n    RxEnSync <= #Tp r_RxEn;\nend \n\n\n\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync1 <= 1'b0;\n  else\n    WillSendControlFrame_sync1 <=#Tp WillSendControlFrame;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync2 <= 1'b0;\n  else\n    WillSendControlFrame_sync2 <=#Tp WillSendControlFrame_sync1;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync3 <= 1'b0;\n  else\n    WillSendControlFrame_sync3 <=#Tp WillSendControlFrame_sync2;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RstTxPauseRq <= 1'b0;\n  else\n    RstTxPauseRq <=#Tp WillSendControlFrame_sync2 & ~WillSendControlFrame_sync3;\nend\n\n\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      TxPauseRq_sync1 <= #Tp 1'b0;\n      TxPauseRq_sync2 <= #Tp 1'b0;\n      TxPauseRq_sync3 <= #Tp 1'b0;\n    end\n  else\n    begin\n      TxPauseRq_sync1 <= #Tp (r_TxPauseRq & r_TxFlow);\n      TxPauseRq_sync2 <= #Tp TxPauseRq_sync1;\n      TxPauseRq_sync3 <= #Tp TxPauseRq_sync2;\n    end\nend\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    TPauseRq <= #Tp 1'b0;\n  else\n    TPauseRq <= #Tp TxPauseRq_sync2 & (~TxPauseRq_sync3);\nend\n\n\nwire LatchedMRxErr;\nreg RxAbort_latch;\nreg RxAbort_sync1;\nreg RxAbort_wb;\nreg RxAbortRst_sync1;\nreg RxAbortRst;\n\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RxAbort_latch <= #Tp 1'b0;\n  else if(RxAbort | (ShortFrame & ~r_RecSmall) | LatchedMRxErr & ~InvalidSymbol | (ReceivedPauseFrm & (~r_PassAll)))\n    RxAbort_latch <= #Tp 1'b1;\n  else if(RxAbortRst)\n    RxAbort_latch <= #Tp 1'b0;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      RxAbort_sync1 <= #Tp 1'b0;\n      RxAbort_wb    <= #Tp 1'b0;\n      RxAbort_wb    <= #Tp 1'b0;\n    end\n  else\n    begin\n      RxAbort_sync1 <= #Tp RxAbort_latch;\n      RxAbort_wb    <= #Tp RxAbort_sync1;\n    end\nend\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      RxAbortRst_sync1 <= #Tp 1'b0;\n      RxAbortRst       <= #Tp 1'b0;\n    end\n  else\n    begin\n      RxAbortRst_sync1 <= #Tp RxAbort_wb;\n      RxAbortRst       <= #Tp RxAbortRst_sync1;\n    end\nend\n\n\n\n\neth_wishbone wishbone\n(\n  .WB_CLK_I(wb_clk_i),                .WB_DAT_I(wb_dat_i), \n  .WB_DAT_O(BD_WB_DAT_O), \n\n  \n  .WB_ADR_I(wb_adr_i[9:2]),           .WB_WE_I(wb_we_i), \n  .BDCs(BDCs),                        .WB_ACK_O(BDAck), \n\n  .Reset(wb_rst_i), \n\n  \n  .m_wb_adr_o(m_wb_adr_tmp),          .m_wb_sel_o(m_wb_sel_o),                  .m_wb_we_o(m_wb_we_o), \n  .m_wb_dat_i(m_wb_dat_i),            .m_wb_dat_o(m_wb_dat_o),                  .m_wb_cyc_o(m_wb_cyc_o), \n  .m_wb_stb_o(m_wb_stb_o),            .m_wb_ack_i(m_wb_ack_i),                  .m_wb_err_i(m_wb_err_i), \n  \n`ifdef ETH_WISHBONE_B3\n  .m_wb_cti_o(m_wb_cti_o),            .m_wb_bte_o(m_wb_bte_o), \n`endif\n  \n\n    \n  .MTxClk(mtx_clk_pad_i),             .TxStartFrm(TxStartFrm),                  .TxEndFrm(TxEndFrm), \n  .TxUsedData(TxUsedData),            .TxData(TxData), \n  .TxRetry(TxRetry),                  .TxAbort(TxAbort),                        .TxUnderRun(TxUnderRun), \n  .TxDone(TxDone), \n  .PerPacketCrcEn(PerPacketCrcEn),    .PerPacketPad(PerPacketPad), \n\n  \n  .r_TxEn(r_TxEn),                    .r_RxEn(r_RxEn),                          .r_TxBDNum(r_TxBDNum), \n  .r_RxFlow(r_RxFlow),                      .r_PassAll(r_PassAll), \n\n  \n  .MRxClk(mrx_clk_pad_i),             .RxData(RxData),                          .RxValid(RxValid), \n  .RxStartFrm(RxStartFrm),            .RxEndFrm(RxEndFrm),                      \n  .Busy_IRQ(Busy_IRQ),                .RxE_IRQ(RxE_IRQ),                        .RxB_IRQ(RxB_IRQ), \n  .TxE_IRQ(TxE_IRQ),                  .TxB_IRQ(TxB_IRQ), \n\n  .RxAbort(RxAbort_wb),               .RxStatusWriteLatched_sync2(RxStatusWriteLatched_sync2), \n\n  .InvalidSymbol(InvalidSymbol),      .LatchedCrcError(LatchedCrcError),        .RxLength(RxByteCnt),\n  .RxLateCollision(RxLateCollision),  .ShortFrame(ShortFrame),                  .DribbleNibble(DribbleNibble),\n  .ReceivedPacketTooBig(ReceivedPacketTooBig), .LoadRxStatus(LoadRxStatus),     .RetryCntLatched(RetryCntLatched),\n  .RetryLimit(RetryLimit),            .LateCollLatched(LateCollLatched),        .DeferLatched(DeferLatched),   \n  .RstDeferLatched(RstDeferLatched), \n  .CarrierSenseLost(CarrierSenseLost),.ReceivedPacketGood(ReceivedPacketGood),  .AddressMiss(AddressMiss),\n  .ReceivedPauseFrm(ReceivedPauseFrm)\n  \n`ifdef ETH_BIST\n  ,\n  .mbist_si_i       (mbist_si_i),\n  .mbist_so_o       (mbist_so_o),\n  .mbist_ctrl_i       (mbist_ctrl_i)\n`endif\n);\n\nassign m_wb_adr_o = {m_wb_adr_tmp, 2'h0};\n\n\neth_macstatus macstatus1 \n(\n  .MRxClk(mrx_clk_pad_i),             .Reset(wb_rst_i),\n  .ReceiveEnd(ReceiveEnd),            .ReceivedPacketGood(ReceivedPacketGood),     .ReceivedLengthOK(ReceivedLengthOK), \n  .RxCrcError(RxCrcError),            .MRxErr(MRxErr_Lb),                          .MRxDV(MRxDV_Lb), \n  .RxStateSFD(RxStateSFD),            .RxStateData(RxStateData),                   .RxStatePreamble(RxStatePreamble), \n  .RxStateIdle(RxStateIdle),          .Transmitting(Transmitting),                 .RxByteCnt(RxByteCnt), \n  .RxByteCntEq0(RxByteCntEq0),        .RxByteCntGreat2(RxByteCntGreat2),           .RxByteCntMaxFrame(RxByteCntMaxFrame), \n  .InvalidSymbol(InvalidSymbol),\n  .MRxD(MRxD_Lb),                     .LatchedCrcError(LatchedCrcError),           .Collision(mcoll_pad_i),\n  .CollValid(r_CollValid),            .RxLateCollision(RxLateCollision),           .r_RecSmall(r_RecSmall),\n  .r_MinFL(r_MinFL),                  .r_MaxFL(r_MaxFL),                           .ShortFrame(ShortFrame),\n  .DribbleNibble(DribbleNibble),      .ReceivedPacketTooBig(ReceivedPacketTooBig), .r_HugEn(r_HugEn),\n  .LoadRxStatus(LoadRxStatus),        .RetryCnt(RetryCnt),                         .StartTxDone(StartTxDone),\n  .StartTxAbort(StartTxAbort),        .RetryCntLatched(RetryCntLatched),           .MTxClk(mtx_clk_pad_i),\n  .MaxCollisionOccured(MaxCollisionOccured), .RetryLimit(RetryLimit),              .LateCollision(LateCollision),\n  .LateCollLatched(LateCollLatched),  .DeferIndication(DeferIndication),           .DeferLatched(DeferLatched),\n  .RstDeferLatched(RstDeferLatched), \n  .TxStartFrm(TxStartFrmOut),         .StatePreamble(StatePreamble),               .StateData(StateData),\n  .CarrierSense(CarrierSense_Tx2),    .CarrierSenseLost(CarrierSenseLost),         .TxUsedData(TxUsedDataIn),\n  .LatchedMRxErr(LatchedMRxErr),      .Loopback(r_LoopBck),                        .r_FullD(r_FullD)\n);\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: eth_top. Module specification: The eth_top module is the top-level module for an Ethernet MAC (Media Access Control) implementation. It integrates various sub-modules to handle Ethernet frame transmission and reception, MAC control operations, MIIM (Management Interface) functionality, and Wishbone bus interfacing. The module has input ports for clocks, resets, Wishbone bus inputs, MAC transmit and receive signals, and MIIM data; output ports for Wishbone bus outputs, MAC transmit signals, and interrupt. Internal signals include control registers, status flags, and data flow signals. The module is composed of several key blocks: eth_registers for configuration and status registers, eth_rxethmac and eth_txethmac for receive and transmit operations, eth_maccontrol for flow control and pause frame handling, eth_miim for PHY management, eth_wishbone for DMA an"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: eth_top\n\nExplanation: This module appears to be the top-level module for an Ethernet MAC (Media Access Control) implementation. It integrates various sub-modules to handle Ethernet frame transmission and reception, MAC control operations, MIIM (Management Interface) functionality, and Wishbone bus interfacing. The module includes components for managing transmit and receive operations, handling flow control, performing address filtering, and managing buffer descriptors. It also incorporates features like collision detection, CRC checking, and various configuration options for Ethernet communication parameters. The module is designed to interface with external PHY devices and a host system through Wishbone bus, providing a complete Ethernet MAC solution."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nwb_clk_i, wb_rst_i, wb_dat_i, wb_adr_i, wb_sel_i, wb_we_i, wb_cyc_i, wb_stb_i, m_wb_dat_i, m_wb_ack_i, m_wb_err_i, mtx_clk_pad_i, mrx_clk_pad_i, mrxd_pad_i, mrxdv_pad_i, mrxerr_pad_i, mcoll_pad_i, mcrs_pad_i, md_pad_i.\n\nExplanation:\nThese ports include clock and reset signals, Wishbone bus inputs for host interface, master Wishbone bus inputs, MAC transmit and receive clocks, receive data and control signals, collision and carrier sense inputs, and MIIM data input.\n\nOutput ports:\nwb_dat_o, wb_ack_o, wb_err_o, m_wb_adr_o, m_wb_sel_o, m_wb_we_o, m_wb_dat_o, m_wb_cyc_o, m_wb_stb_o, mtxd_pad_o, mtxen_pad_o, mtxerr_pad_o, mdc_pad_o, md_pad_o, md_padoe_o, int_o.\n\nExplanation:\nThese ports include Wishbone bus outputs for host interface, master Wishbone bus outputs, MAC transmit data and control signals, MIIM clock and data outputs, and an interrupt output. They are used for communicating with the host system, external PHY, and other parts of the system."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nr_ClkDiv, r_MiiNoPre, r_CtrlData, r_FIAD, r_RGAD, r_WCtrlData, r_RStat, r_ScanStat, NValid_stat, Busy_stat, LinkFail, Prsd, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg, TxStartFrm, TxEndFrm, TxUsedData, TxData, TxRetry, TxAbort, TxUnderRun, TxDone, WillSendControlFrame_sync1, WillSendControlFrame_sync2, WillSendControlFrame_sync3, RstTxPauseRq, TxPauseRq_sync1, TxPauseRq_sync2, TxPauseRq_sync3, TPauseRq, RxData, RxValid, RxStartFrm, RxEndFrm, RxAbort, WillTransmit, ResetCollision, TxDataOut, WillSendControlFrame, ReceiveEnd, ReceivedPacketGood, ReceivedLengthOK, InvalidSymbol, LatchedCrcError, RxLateCollision, RetryCntLatched, RetryCnt, StartTxAbort, MaxCollisionOccured, RetryLimit, StatePreamble, StateData.\n\nExplanation:\nThese internal signals serve various purposes within the module:\n- MIIM control signals (e.g., r_ClkDiv, r_MiiNoPre, r_CtrlData) for managing the management interface.\n- Transmit and receive control signals (e.g., TxStartFrm, TxEndFrm, RxValid, RxStartFrm) for handling Ethernet frame transmission and reception.\n- Status signals (e.g., Busy_stat, LinkFail, ReceivedPacketGood) for indicating various conditions and events.\n- Synchronization signals (e.g., WillSendControlFrame_sync1, TxPauseRq_sync1) for managing clock domain crossings.\n- Flow control signals (e.g., TPauseRq, RstTxPauseRq) for implementing Ethernet flow control mechanisms.\n- Collision and retry signals (e.g., ResetCollision, RetryCnt, MaxCollisionOccured) for managing CSMA/CD operations.\n- State signals (e.g., StatePreamble, StateData) for tracking the current state of transmit and receive operations.\n\nThese signals facilitate communication between different sub-modules, manage control flow, and maintain the overall state of the Ethernet MAC operations."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"eth_defines.v\"\n`include \"timescale.v\"\n\n\nmodule eth_top\n(\n  \n  wb_clk_i, wb_rst_i, wb_dat_i, wb_dat_o, \n\n  \n  wb_adr_i, wb_sel_i, wb_we_i, wb_cyc_i, wb_stb_i, wb_ack_o, wb_err_o, \n\n  \n  m_wb_adr_o, m_wb_sel_o, m_wb_we_o, \n  m_wb_dat_o, m_wb_dat_i, m_wb_cyc_o, \n  m_wb_stb_o, m_wb_ack_i, m_wb_err_i, \n\n`ifdef ETH_WISHBONE_B3\n  m_wb_cti_o, m_wb_bte_o, \n`endif\n\n  \n  mtx_clk_pad_i, mtxd_pad_o, mtxen_pad_o, mtxerr_pad_o,\n\n  \n  mrx_clk_pad_i, mrxd_pad_i, mrxdv_pad_i, mrxerr_pad_i, mcoll_pad_i, mcrs_pad_i, \n  \n  \n  mdc_pad_o, md_pad_i, md_pad_o, md_padoe_o,\n\n  int_o\n\n  \n`ifdef ETH_BIST\n  ,\n  \n  mbist_si_i,       \n  mbist_so_o,       \n  mbist_ctrl_i        \n`endif\n\n);\n\n\nparameter Tp = 1;\n\n\n\ninput           wb_clk_i;     \ninput           wb_rst_i;     \ninput   [31:0]  wb_dat_i;     \noutput  [31:0]  wb_dat_o;     \noutput          wb_err_o;     \n\n\ninput   [11:2]  wb_adr_i;     \ninput    [3:0]  wb_sel_i;     \ninput           wb_we_i;      \ninput           wb_cyc_i;     \ninput           wb_stb_i;     \noutput          wb_ack_o;     \n\n\noutput  [31:0]  m_wb_adr_o;\noutput   [3:0]  m_wb_sel_o;\noutput          m_wb_we_o;\ninput   [31:0]  m_wb_dat_i;\noutput  [31:0]  m_wb_dat_o;\noutput          m_wb_cyc_o;\noutput          m_wb_stb_o;\ninput           m_wb_ack_i;\ninput           m_wb_err_i;\n\nwire    [29:0]  m_wb_adr_tmp;\n\n`ifdef ETH_WISHBONE_B3\noutput   [2:0]  m_wb_cti_o;   \noutput   [1:0]  m_wb_bte_o;   \n`endif\n\n\ninput           mtx_clk_pad_i; \noutput   [3:0]  mtxd_pad_o;    \noutput          mtxen_pad_o;   \noutput          mtxerr_pad_o;  \n\n\ninput           mrx_clk_pad_i; \ninput    [3:0]  mrxd_pad_i;    \ninput           mrxdv_pad_i;   \ninput           mrxerr_pad_i;  \n\n\ninput           mcoll_pad_i;   \ninput           mcrs_pad_i;    \n\n\ninput           md_pad_i;      \noutput          mdc_pad_o;     \noutput          md_pad_o;      \noutput          md_padoe_o;    \n\noutput          int_o;         \n\n\n`ifdef ETH_BIST\ninput   mbist_si_i;       \noutput  mbist_so_o;       \ninput [`ETH_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i;       \n`endif\n\nwire     [7:0]  r_ClkDiv;\nwire            r_MiiNoPre;\nwire    [15:0]  r_CtrlData;\nwire     [4:0]  r_FIAD;\nwire     [4:0]  r_RGAD;\nwire            r_WCtrlData;\nwire            r_RStat;\nwire            r_ScanStat;\nwire            NValid_stat;\nwire            Busy_stat;\nwire            LinkFail;\nwire    [15:0]  Prsd;             \nwire            WCtrlDataStart;\nwire            RStatStart;\nwire            UpdateMIIRX_DATAReg;\n\nwire            TxStartFrm;\nwire            TxEndFrm;\nwire            TxUsedData;\nwire     [7:0]  TxData;\nwire            TxRetry;\nwire            TxAbort;\nwire            TxUnderRun;\nwire            TxDone;\n\n\nreg             WillSendControlFrame_sync1;\nreg             WillSendControlFrame_sync2;\nreg             WillSendControlFrame_sync3;\nreg             RstTxPauseRq;\n\nreg             TxPauseRq_sync1;\nreg             TxPauseRq_sync2;\nreg             TxPauseRq_sync3;\nreg             TPauseRq;\n\n\n\neth_miim miim1\n(\n  .Clk(wb_clk_i),                         .Reset(wb_rst_i),                   .Divider(r_ClkDiv), \n  .NoPre(r_MiiNoPre),                     .CtrlData(r_CtrlData),              .Rgad(r_RGAD), \n  .Fiad(r_FIAD),                          .WCtrlData(r_WCtrlData),            .RStat(r_RStat), \n  .ScanStat(r_ScanStat),                  .Mdi(md_pad_i),                     .Mdo(md_pad_o), \n  .MdoEn(md_padoe_o),                     .Mdc(mdc_pad_o),                    .Busy(Busy_stat), \n  .Prsd(Prsd),                            .LinkFail(LinkFail),                .Nvalid(NValid_stat), \n  .WCtrlDataStart(WCtrlDataStart),        .RStatStart(RStatStart),            .UpdateMIIRX_DATAReg(UpdateMIIRX_DATAReg)\n);\n\n\n\n\nwire  [3:0] RegCs;          \nwire [31:0] RegDataOut;     \nwire        r_RecSmall;     \nwire        r_LoopBck;      \nwire        r_TxEn;         \nwire        r_RxEn;         \n\nwire        MRxDV_Lb;       \nwire        MRxErr_Lb;      \nwire  [3:0] MRxD_Lb;        \nwire        Transmitting;   \nwire        r_HugEn;        \nwire        r_DlyCrcEn;     \nwire [15:0] r_MaxFL;        \n\nwire [15:0] r_MinFL;        \nwire        ShortFrame;\nwire        DribbleNibble;  \nwire        ReceivedPacketTooBig; \nwire [47:0] r_MAC;          \nwire        LoadRxStatus;   \nwire [31:0] r_HASH0;        \nwire [31:0] r_HASH1;        \nwire  [7:0] r_TxBDNum;      \nwire  [6:0] r_IPGT;         \nwire  [6:0] r_IPGR1;        \nwire  [6:0] r_IPGR2;        \nwire  [5:0] r_CollValid;    \nwire [15:0] r_TxPauseTV;    \nwire        r_TxPauseRq;    \n\nwire  [3:0] r_MaxRet;       \nwire        r_NoBckof;      \nwire        r_ExDfrEn;      \nwire        r_TxFlow;       \nwire        r_IFG;          \n\nwire        TxB_IRQ;        \nwire        TxE_IRQ;        \nwire        RxB_IRQ;        \nwire        RxE_IRQ;        \nwire        Busy_IRQ;       \n\n\nwire        ByteSelected;\nwire        BDAck;\nwire [31:0] BD_WB_DAT_O;    \nwire  [3:0] BDCs;           \nwire        CsMiss;         \n                            \nwire        r_Pad;\nwire        r_CrcEn;\nwire        r_FullD;\nwire        r_Pro;\nwire        r_Bro;\nwire        r_NoPre;\nwire        r_RxFlow;\nwire        r_PassAll;\nwire        TxCtrlEndFrm;\nwire        StartTxDone;\nwire        SetPauseTimer;\nwire        TxUsedDataIn;\nwire        TxDoneIn;\nwire        TxAbortIn;\nwire        PerPacketPad;\nwire        PadOut;\nwire        PerPacketCrcEn;\nwire        CrcEnOut;\nwire        TxStartFrmOut;\nwire        TxEndFrmOut;\nwire        ReceivedPauseFrm;\nwire        ControlFrmAddressOK;\nwire        RxStatusWriteLatched_sync2;\nwire        LateCollision;\nwire        DeferIndication;\nwire        LateCollLatched;\nwire        DeferLatched;\nwire        RstDeferLatched;\nwire        CarrierSenseLost;\n\nwire        temp_wb_ack_o;\nwire [31:0] temp_wb_dat_o;\nwire        temp_wb_err_o;\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  reg         temp_wb_ack_o_reg;\n  reg [31:0]  temp_wb_dat_o_reg;\n  reg         temp_wb_err_o_reg;\n`endif\n\n\nassign ByteSelected = |wb_sel_i;\nassign RegCs[3] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[3];   \nassign RegCs[2] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[2];   \nassign RegCs[1] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[1];   \nassign RegCs[0] = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] & ~wb_adr_i[10] & wb_sel_i[0];   \nassign BDCs[3]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[3];   \nassign BDCs[2]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[2];   \nassign BDCs[1]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[1];   \nassign BDCs[0]  = wb_stb_i & wb_cyc_i & ByteSelected & ~wb_adr_i[11] &  wb_adr_i[10] & wb_sel_i[0];   \nassign CsMiss = wb_stb_i & wb_cyc_i & ByteSelected & wb_adr_i[11];                   \nassign temp_wb_dat_o = ((|RegCs) & ~wb_we_i)? RegDataOut : BD_WB_DAT_O;\nassign temp_wb_err_o = wb_stb_i & wb_cyc_i & (~ByteSelected | CsMiss);\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  assign wb_ack_o = temp_wb_ack_o_reg;\n  assign wb_dat_o[31:0] = temp_wb_dat_o_reg;\n  assign wb_err_o = temp_wb_err_o_reg;\n`else\n  assign wb_ack_o = temp_wb_ack_o;\n  assign wb_dat_o[31:0] = temp_wb_dat_o;\n  assign wb_err_o = temp_wb_err_o;\n`endif\n\n`ifdef ETH_AVALON_BUS\n  \n  \n  \n  \n  \n  assign temp_wb_ack_o = (|RegCs) | BDAck | CsMiss;\n`else \n  assign temp_wb_ack_o = (|RegCs) | BDAck;\n`endif\n\n`ifdef ETH_REGISTERED_OUTPUTS\n  always @ (posedge wb_clk_i or posedge wb_rst_i)\n  begin\n    if(wb_rst_i)\n      begin\n        temp_wb_ack_o_reg <=#Tp 1'b0;\n        temp_wb_dat_o_reg <=#Tp 32'h0;\n        temp_wb_err_o_reg <=#Tp 1'b0;\n      end\n    else\n      begin\n        temp_wb_ack_o_reg <=#Tp temp_wb_ack_o & ~temp_wb_ack_o_reg;\n        temp_wb_dat_o_reg <=#Tp temp_wb_dat_o;\n        temp_wb_err_o_reg <=#Tp temp_wb_err_o & ~temp_wb_err_o_reg;\n      end\n  end\n`endif\n\n\n\neth_registers ethreg1\n(\n  .DataIn(wb_dat_i),                      .Address(wb_adr_i[9:2]),                    .Rw(wb_we_i), \n  .Cs(RegCs),                             .Clk(wb_clk_i),                             .Reset(wb_rst_i), \n  .DataOut(RegDataOut),                   .r_RecSmall(r_RecSmall), \n  .r_Pad(r_Pad),                          .r_HugEn(r_HugEn),                          .r_CrcEn(r_CrcEn), \n  .r_DlyCrcEn(r_DlyCrcEn),                .r_FullD(r_FullD), \n  .r_ExDfrEn(r_ExDfrEn),                  .r_NoBckof(r_NoBckof),                      .r_LoopBck(r_LoopBck), \n  .r_IFG(r_IFG),                          .r_Pro(r_Pro),                              .r_Iam(), \n  .r_Bro(r_Bro),                          .r_NoPre(r_NoPre),                          .r_TxEn(r_TxEn), \n  .r_RxEn(r_RxEn),                        .Busy_IRQ(Busy_IRQ),                        .RxE_IRQ(RxE_IRQ), \n  .RxB_IRQ(RxB_IRQ),                      .TxE_IRQ(TxE_IRQ),                          .TxB_IRQ(TxB_IRQ), \n  .r_IPGT(r_IPGT), \n  .r_IPGR1(r_IPGR1),                      .r_IPGR2(r_IPGR2),                          .r_MinFL(r_MinFL), \n  .r_MaxFL(r_MaxFL),                      .r_MaxRet(r_MaxRet),                        .r_CollValid(r_CollValid), \n  .r_TxFlow(r_TxFlow),                    .r_RxFlow(r_RxFlow),                        .r_PassAll(r_PassAll), \n  .r_MiiNoPre(r_MiiNoPre),                .r_ClkDiv(r_ClkDiv), \n  .r_WCtrlData(r_WCtrlData),              .r_RStat(r_RStat),                          .r_ScanStat(r_ScanStat), \n  .r_RGAD(r_RGAD),                        .r_FIAD(r_FIAD),                            .r_CtrlData(r_CtrlData), \n  .NValid_stat(NValid_stat),              .Busy_stat(Busy_stat),                   \n  .LinkFail(LinkFail),                    .r_MAC(r_MAC),                              .WCtrlDataStart(WCtrlDataStart),\n  .RStatStart(RStatStart),                .UpdateMIIRX_DATAReg(UpdateMIIRX_DATAReg),  .Prsd(Prsd), \n  .r_TxBDNum(r_TxBDNum),                  .int_o(int_o),\n  .r_HASH0(r_HASH0),                      .r_HASH1(r_HASH1),                          .r_TxPauseRq(r_TxPauseRq), \n  .r_TxPauseTV(r_TxPauseTV),              .RstTxPauseRq(RstTxPauseRq),                .TxCtrlEndFrm(TxCtrlEndFrm), \n  .StartTxDone(StartTxDone),              .TxClk(mtx_clk_pad_i),                      .RxClk(mrx_clk_pad_i), \n  .SetPauseTimer(SetPauseTimer)\n  \n);\n\n\n\nwire  [7:0] RxData;\nwire        RxValid;\nwire        RxStartFrm;\nwire        RxEndFrm;\nwire        RxAbort;\n\nwire        WillTransmit;            \nwire        ResetCollision;          \nwire  [7:0] TxDataOut;               \nwire        WillSendControlFrame;\nwire        ReceiveEnd;\nwire        ReceivedPacketGood;\nwire        ReceivedLengthOK;\nwire        InvalidSymbol;\nwire        LatchedCrcError;\nwire        RxLateCollision;\nwire  [3:0] RetryCntLatched;   \nwire  [3:0] RetryCnt;   \nwire        StartTxAbort;   \nwire        MaxCollisionOccured;   \nwire        RetryLimit;   \nwire        StatePreamble;   \nwire  [1:0] StateData; \n\n\neth_maccontrol maccontrol1\n(\n  .MTxClk(mtx_clk_pad_i),                       .TPauseRq(TPauseRq), \n  .TxPauseTV(r_TxPauseTV),                      .TxDataIn(TxData), \n  .TxStartFrmIn(TxStartFrm),                    .TxEndFrmIn(TxEndFrm), \n  .TxUsedDataIn(TxUsedDataIn),                  .TxDoneIn(TxDoneIn), \n  .TxAbortIn(TxAbortIn),                        .MRxClk(mrx_clk_pad_i), \n  .RxData(RxData),                              .RxValid(RxValid), \n  .RxStartFrm(RxStartFrm),                      .RxEndFrm(RxEndFrm),\n  .ReceiveEnd(ReceiveEnd),                      .ReceivedPacketGood(ReceivedPacketGood),\n  .TxFlow(r_TxFlow), \n  .RxFlow(r_RxFlow),                            .DlyCrcEn(r_DlyCrcEn),\n  .MAC(r_MAC),                                  .PadIn(r_Pad | PerPacketPad), \n  .PadOut(PadOut),                              .CrcEnIn(r_CrcEn | PerPacketCrcEn), \n  .CrcEnOut(CrcEnOut),                          .TxReset(wb_rst_i), \n  .RxReset(wb_rst_i),                           .ReceivedLengthOK(ReceivedLengthOK),\n  .TxDataOut(TxDataOut),                        .TxStartFrmOut(TxStartFrmOut), \n  .TxEndFrmOut(TxEndFrmOut),                    .TxUsedDataOut(TxUsedData), \n  .TxDoneOut(TxDone),                           .TxAbortOut(TxAbort), \n  .WillSendControlFrame(WillSendControlFrame),  .TxCtrlEndFrm(TxCtrlEndFrm), \n  .ReceivedPauseFrm(ReceivedPauseFrm),          .ControlFrmAddressOK(ControlFrmAddressOK),\n  .SetPauseTimer(SetPauseTimer),\n  .RxStatusWriteLatched_sync2(RxStatusWriteLatched_sync2),                .r_PassAll(r_PassAll)\n);\n\n\n\nwire TxCarrierSense;          \nwire Collision;               \n\nreg CarrierSense_Tx1;\nreg CarrierSense_Tx2;\nreg Collision_Tx1;\nreg Collision_Tx2;\n\nreg RxEnSync;                 \nreg WillTransmit_q;\nreg WillTransmit_q2;\n\n\n\n\nassign MRxDV_Lb = r_LoopBck? mtxen_pad_o : mrxdv_pad_i & RxEnSync;\n\n\nassign MRxErr_Lb = r_LoopBck? mtxerr_pad_o : mrxerr_pad_i & RxEnSync;\n\n\nassign MRxD_Lb[3:0] = r_LoopBck? mtxd_pad_o[3:0] : mrxd_pad_i[3:0];\n\n\n\n\neth_txethmac txethmac1\n(\n  .MTxClk(mtx_clk_pad_i),             .Reset(wb_rst_i),                   .CarrierSense(TxCarrierSense), \n  .Collision(Collision),              .TxData(TxDataOut),                 .TxStartFrm(TxStartFrmOut), \n  .TxUnderRun(TxUnderRun),            .TxEndFrm(TxEndFrmOut),             .Pad(PadOut),  \n  .MinFL(r_MinFL),                    .CrcEn(CrcEnOut),                   .FullD(r_FullD), \n  .HugEn(r_HugEn),                    .DlyCrcEn(r_DlyCrcEn),              .IPGT(r_IPGT), \n  .IPGR1(r_IPGR1),                    .IPGR2(r_IPGR2),                    .CollValid(r_CollValid), \n  .MaxRet(r_MaxRet),                  .NoBckof(r_NoBckof),                .ExDfrEn(r_ExDfrEn), \n  .MaxFL(r_MaxFL),                    .MTxEn(mtxen_pad_o),                .MTxD(mtxd_pad_o), \n  .MTxErr(mtxerr_pad_o),              .TxUsedData(TxUsedDataIn),          .TxDone(TxDoneIn), \n  .TxRetry(TxRetry),                  .TxAbort(TxAbortIn),                .WillTransmit(WillTransmit), \n  .ResetCollision(ResetCollision),    .RetryCnt(RetryCnt),                .StartTxDone(StartTxDone), \n  .StartTxAbort(StartTxAbort),        .MaxCollisionOccured(MaxCollisionOccured), .LateCollision(LateCollision),   \n  .DeferIndication(DeferIndication),  .StatePreamble(StatePreamble),      .StateData(StateData)   \n);\n\n\n\n\nwire  [15:0]  RxByteCnt;\nwire          RxByteCntEq0;\nwire          RxByteCntGreat2;\nwire          RxByteCntMaxFrame;\nwire          RxCrcError;\nwire          RxStateIdle;\nwire          RxStatePreamble;\nwire          RxStateSFD;\nwire   [1:0]  RxStateData;\nwire          AddressMiss;\n\n\n\n\neth_rxethmac rxethmac1\n(\n  .MRxClk(mrx_clk_pad_i),               .MRxDV(MRxDV_Lb),                     .MRxD(MRxD_Lb),\n  .Transmitting(Transmitting),          .HugEn(r_HugEn),                      .DlyCrcEn(r_DlyCrcEn), \n  .MaxFL(r_MaxFL),                      .r_IFG(r_IFG),                        .Reset(wb_rst_i),\n  .RxData(RxData),                      .RxValid(RxValid),                    .RxStartFrm(RxStartFrm), \n  .RxEndFrm(RxEndFrm),                  .ByteCnt(RxByteCnt), \n  .ByteCntEq0(RxByteCntEq0),            .ByteCntGreat2(RxByteCntGreat2),      .ByteCntMaxFrame(RxByteCntMaxFrame), \n  .CrcError(RxCrcError),                .StateIdle(RxStateIdle),              .StatePreamble(RxStatePreamble), \n  .StateSFD(RxStateSFD),                .StateData(RxStateData),\n  .MAC(r_MAC),                          .r_Pro(r_Pro),                        .r_Bro(r_Bro),\n  .r_HASH0(r_HASH0),                    .r_HASH1(r_HASH1),                    .RxAbort(RxAbort), \n  .AddressMiss(AddressMiss),            .PassAll(r_PassAll),                  .ControlFrmAddressOK(ControlFrmAddressOK)\n);\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      CarrierSense_Tx1 <= #Tp 1'b0;\n      CarrierSense_Tx2 <= #Tp 1'b0;\n    end\n  else\n    begin\n      CarrierSense_Tx1 <= #Tp mcrs_pad_i;\n      CarrierSense_Tx2 <= #Tp CarrierSense_Tx1;\n    end\nend\n\nassign TxCarrierSense = ~r_FullD & CarrierSense_Tx2;\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      Collision_Tx1 <= #Tp 1'b0;\n      Collision_Tx2 <= #Tp 1'b0;\n    end\n  else\n    begin\n      Collision_Tx1 <= #Tp mcoll_pad_i;\n      if(ResetCollision)\n        Collision_Tx2 <= #Tp 1'b0;\n      else\n      if(Collision_Tx1)\n        Collision_Tx2 <= #Tp 1'b1;\n    end\nend\n\n\n\nassign Collision = ~r_FullD & Collision_Tx2;\n\n\n\n\nalways @ (posedge mrx_clk_pad_i)\nbegin\n  WillTransmit_q <= #Tp WillTransmit;\n  WillTransmit_q2 <= #Tp WillTransmit_q;\nend \n\n\nassign Transmitting = ~r_FullD & WillTransmit_q2;\n\n\n\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RxEnSync <= #Tp 1'b0;\n  else\n  if(~mrxdv_pad_i)\n    RxEnSync <= #Tp r_RxEn;\nend \n\n\n\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync1 <= 1'b0;\n  else\n    WillSendControlFrame_sync1 <=#Tp WillSendControlFrame;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync2 <= 1'b0;\n  else\n    WillSendControlFrame_sync2 <=#Tp WillSendControlFrame_sync1;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    WillSendControlFrame_sync3 <= 1'b0;\n  else\n    WillSendControlFrame_sync3 <=#Tp WillSendControlFrame_sync2;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RstTxPauseRq <= 1'b0;\n  else\n    RstTxPauseRq <=#Tp WillSendControlFrame_sync2 & ~WillSendControlFrame_sync3;\nend\n\n\n\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      TxPauseRq_sync1 <= #Tp 1'b0;\n      TxPauseRq_sync2 <= #Tp 1'b0;\n      TxPauseRq_sync3 <= #Tp 1'b0;\n    end\n  else\n    begin\n      TxPauseRq_sync1 <= #Tp (r_TxPauseRq & r_TxFlow);\n      TxPauseRq_sync2 <= #Tp TxPauseRq_sync1;\n      TxPauseRq_sync3 <= #Tp TxPauseRq_sync2;\n    end\nend\n\n\nalways @ (posedge mtx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    TPauseRq <= #Tp 1'b0;\n  else\n    TPauseRq <= #Tp TxPauseRq_sync2 & (~TxPauseRq_sync3);\nend\n\n\nwire LatchedMRxErr;\nreg RxAbort_latch;\nreg RxAbort_sync1;\nreg RxAbort_wb;\nreg RxAbortRst_sync1;\nreg RxAbortRst;\n\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    RxAbort_latch <= #Tp 1'b0;\n  else if(RxAbort | (ShortFrame & ~r_RecSmall) | LatchedMRxErr & ~InvalidSymbol | (ReceivedPauseFrm & (~r_PassAll)))\n    RxAbort_latch <= #Tp 1'b1;\n  else if(RxAbortRst)\n    RxAbort_latch <= #Tp 1'b0;\nend\n\nalways @ (posedge wb_clk_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      RxAbort_sync1 <= #Tp 1'b0;\n      RxAbort_wb    <= #Tp 1'b0;\n      RxAbort_wb    <= #Tp 1'b0;\n    end\n  else\n    begin\n      RxAbort_sync1 <= #Tp RxAbort_latch;\n      RxAbort_wb    <= #Tp RxAbort_sync1;\n    end\nend\n\nalways @ (posedge mrx_clk_pad_i or posedge wb_rst_i)\nbegin\n  if(wb_rst_i)\n    begin\n      RxAbortRst_sync1 <= #Tp 1'b0;\n      RxAbortRst       <= #Tp 1'b0;\n    end\n  else\n    begin\n      RxAbortRst_sync1 <= #Tp RxAbort_wb;\n      RxAbortRst       <= #Tp RxAbortRst_sync1;\n    end\nend\n\n\n\n\neth_wishbone wishbone\n(\n  .WB_CLK_I(wb_clk_i),                .WB_DAT_I(wb_dat_i), \n  .WB_DAT_O(BD_WB_DAT_O), \n\n  \n  .WB_ADR_I(wb_adr_i[9:2]),           .WB_WE_I(wb_we_i), \n  .BDCs(BDCs),                        .WB_ACK_O(BDAck), \n\n  .Reset(wb_rst_i), \n\n  \n  .m_wb_adr_o(m_wb_adr_tmp),          .m_wb_sel_o(m_wb_sel_o),                  .m_wb_we_o(m_wb_we_o), \n  .m_wb_dat_i(m_wb_dat_i),            .m_wb_dat_o(m_wb_dat_o),                  .m_wb_cyc_o(m_wb_cyc_o), \n  .m_wb_stb_o(m_wb_stb_o),            .m_wb_ack_i(m_wb_ack_i),                  .m_wb_err_i(m_wb_err_i), \n  \n`ifdef ETH_WISHBONE_B3\n  .m_wb_cti_o(m_wb_cti_o),            .m_wb_bte_o(m_wb_bte_o), \n`endif\n  \n\n    \n  .MTxClk(mtx_clk_pad_i),             .TxStartFrm(TxStartFrm),                  .TxEndFrm(TxEndFrm), \n  .TxUsedData(TxUsedData),            .TxData(TxData), \n  .TxRetry(TxRetry),                  .TxAbort(TxAbort),                        .TxUnderRun(TxUnderRun), \n  .TxDone(TxDone), \n  .PerPacketCrcEn(PerPacketCrcEn),    .PerPacketPad(PerPacketPad), \n\n  \n  .r_TxEn(r_TxEn),                    .r_RxEn(r_RxEn),                          .r_TxBDNum(r_TxBDNum), \n  .r_RxFlow(r_RxFlow),                      .r_PassAll(r_PassAll), \n\n  \n  .MRxClk(mrx_clk_pad_i),             .RxData(RxData),                          .RxValid(RxValid), \n  .RxStartFrm(RxStartFrm),            .RxEndFrm(RxEndFrm),                      \n  .Busy_IRQ(Busy_IRQ),                .RxE_IRQ(RxE_IRQ),                        .RxB_IRQ(RxB_IRQ), \n  .TxE_IRQ(TxE_IRQ),                  .TxB_IRQ(TxB_IRQ), \n\n  .RxAbort(RxAbort_wb),               .RxStatusWriteLatched_sync2(RxStatusWriteLatched_sync2), \n\n  .InvalidSymbol(InvalidSymbol),      .LatchedCrcError(LatchedCrcError),        .RxLength(RxByteCnt),\n  .RxLateCollision(RxLateCollision),  .ShortFrame(ShortFrame),                  .DribbleNibble(DribbleNibble),\n  .ReceivedPacketTooBig(ReceivedPacketTooBig), .LoadRxStatus(LoadRxStatus),     .RetryCntLatched(RetryCntLatched),\n  .RetryLimit(RetryLimit),            .LateCollLatched(LateCollLatched),        .DeferLatched(DeferLatched),   \n  .RstDeferLatched(RstDeferLatched), \n  .CarrierSenseLost(CarrierSenseLost),.ReceivedPacketGood(ReceivedPacketGood),  .AddressMiss(AddressMiss),\n  .ReceivedPauseFrm(ReceivedPauseFrm)\n  \n`ifdef ETH_BIST\n  ,\n  .mbist_si_i       (mbist_si_i),\n  .mbist_so_o       (mbist_so_o),\n  .mbist_ctrl_i       (mbist_ctrl_i)\n`endif\n);\n\nassign m_wb_adr_o = {m_wb_adr_tmp, 2'h0};\n\n\neth_macstatus macstatus1 \n(\n  .MRxClk(mrx_clk_pad_i),             .Reset(wb_rst_i),\n  .ReceiveEnd(ReceiveEnd),            .ReceivedPacketGood(ReceivedPacketGood),     .ReceivedLengthOK(ReceivedLengthOK), \n  .RxCrcError(RxCrcError),            .MRxErr(MRxErr_Lb),                          .MRxDV(MRxDV_Lb), \n  .RxStateSFD(RxStateSFD),            .RxStateData(RxStateData),                   .RxStatePreamble(RxStatePreamble), \n  .RxStateIdle(RxStateIdle),          .Transmitting(Transmitting),                 .RxByteCnt(RxByteCnt), \n  .RxByteCntEq0(RxByteCntEq0),        .RxByteCntGreat2(RxByteCntGreat2),           .RxByteCntMaxFrame(RxByteCntMaxFrame), \n  .InvalidSymbol(InvalidSymbol),\n  .MRxD(MRxD_Lb),                     .LatchedCrcError(LatchedCrcError),           .Collision(mcoll_pad_i),\n  .CollValid(r_CollValid),            .RxLateCollision(RxLateCollision),           .r_RecSmall(r_RecSmall),\n  .r_MinFL(r_MinFL),                  .r_MaxFL(r_MaxFL),                           .ShortFrame(ShortFrame),\n  .DribbleNibble(DribbleNibble),      .ReceivedPacketTooBig(ReceivedPacketTooBig), .r_HugEn(r_HugEn),\n  .LoadRxStatus(LoadRxStatus),        .RetryCnt(RetryCnt),                         .StartTxDone(StartTxDone),\n  .StartTxAbort(StartTxAbort),        .RetryCntLatched(RetryCntLatched),           .MTxClk(mtx_clk_pad_i),\n  .MaxCollisionOccured(MaxCollisionOccured), .RetryLimit(RetryLimit),              .LateCollision(LateCollision),\n  .LateCollLatched(LateCollLatched),  .DeferIndication(DeferIndication),           .DeferLatched(DeferLatched),\n  .RstDeferLatched(RstDeferLatched), \n  .TxStartFrm(TxStartFrmOut),         .StatePreamble(StatePreamble),               .StateData(StateData),\n  .CarrierSense(CarrierSense_Tx2),    .CarrierSenseLost(CarrierSenseLost),         .TxUsedData(TxUsedDataIn),\n  .LatchedMRxErr(LatchedMRxErr),      .Loopback(r_LoopBck),                        .r_FullD(r_FullD)\n);\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: eth_top. Module specification: The eth_top module is the top-level module for an Ethernet MAC (Media Access Control) implementation. It integrates various sub-modules to handle Ethernet frame transmission and reception, MAC control operations, MIIM (Management Interface) functionality, and Wishbone bus interfacing. The module has input ports for clocks, resets, Wishbone bus inputs, MAC transmit and receive signals, and MIIM data; output ports for Wishbone bus outputs, MAC transmit signals, and interrupt. Internal signals include control registers, status flags, and data flow signals. The module is composed of several key blocks: eth_registers for configuration and status registers, eth_rxethmac and eth_txethmac for receive and transmit operations, eth_maccontrol for flow control and pause frame handling, eth_miim for PHY management, eth_wishbone for DMA an"
                }
            ]
        }
    ]
}