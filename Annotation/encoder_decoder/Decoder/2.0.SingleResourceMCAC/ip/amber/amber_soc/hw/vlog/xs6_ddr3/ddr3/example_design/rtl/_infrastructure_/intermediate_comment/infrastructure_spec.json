{
    "spec": "Module name: infrastructure. Module specification: The \"infrastructure\" module is designed to manage and configure clock signals within a digital system, particularly using a PLL (Phase Locked Loop) to generate multiple output clocks with specific frequencies, phases, and duty cycles. It handles both differential (sys_clk_p, sys_clk_n) and single-ended (sys_clk) input clocks, providing better noise immunity or simpler infrastructure respectively. The module outputs include clk0 (buffered output clock), rst0 (synchronized reset signal), async_rst (combines system reset input and PLL lock status), several high-speed clock signals like sysclk_2x and sysclk_2x_180, mcb_drp_clk (for precise clocking needs), pll_ce_0 and pll_ce_90 (clock enables with phase shifts), and pll_lock (indicates PLL lock status). Internal signals such as clk_2x_0, clk_2x_180, clk0_bufg, and others facilitate the manipulation and buffering of the clock signals and synchronization logic. The Verilog code comprises multiple blocks including clock buffers, PLL configuration (PLL_ADV), clock generation decisions based on input type (differential or single-ended), and reset signal management, all aimed at ensuring stable and reliable clock outputs under various configurations and conditions.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\nExplanation: The module \"infrastructure\" configures and manages clock signals for a digital system. It utilizes various configurable parameters to handle different types of input clocks (differential or single-ended) and generates multiple output clocks with specified frequencies, phases, and duty cycles by leveraging a PLL (Phase Locked Loop). The module also includes synchronization logic to handle reset conditions and ensures that the output clocks are stable and available only when the PLL is locked, thereby improving the reliability of the system's operation under various reset and power-up conditions."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: sys_clk_p, sys_clk_n, sys_clk, sys_rst_i.\nExplanation:\n- sys_clk_p, sys_clk_n: These are the positive and negative differential clock inputs used by the module when the input clock type is configured as \"DIFFERENTIAL\". The differential clock provides better noise immunity compared to single-ended clocks.\n- sys_clk: This is the single-ended clock input used by the module when the input clock type is configured as \"SINGLE_ENDED\". This configuration simplifies the clocking infrastructure but might be more susceptible to noise.\n- sys_rst_i: This is the system reset input, which is used to reset the internal logic and synchronize the PLL when asserted. The reset input can be configured as active high or active low based on the parameter C_RST_ACT_LOW.\n\nOutput ports: clk0, rst0, async_rst, sysclk_2x, sysclk_2x_180, mcb_drp_clk, pll_ce_0, pll_ce_90, pll_lock.\nExplanation:\n- clk0: A buffered output clock derived from the PLL, which can be utilized by other modules or components in the system.\n- rst0: Final reset output which is synchronized to the clk0 signal. This reset ensures that all associated logic is properly reset relative to the stable clk0.\n- async_rst: Asynchronous reset signal that combines the direct system reset input and the pll lock status to provide a quick reset mechanism when the PLL is not locked.\n- sysclk_2x, sysclk_2x_180: Double frequency clocks derived from the PLL with 0 and 180-degree phase shifts, respectively. Useful for high-speed operations or DDR interfacing needs.\n- mcb_drp_clk: A clock used potentially for memory controller block (MCB) or other clocking needs requiring precise control and locking mechanism, enabled only when PLL is locked.\n- pll_ce_0, pll_ce_90: Clock enable outputs with 0 and 90-degree phases respectively, which can be used to drive clock networks or as a strobe signal.\n- pll_lock: Indicates the lock status of the PLL. When high, it signifies that the PLL output clocks are stable and can be utilized reliably."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: clk_2x_0, clk_2x_180, clk0_bufg, clk0_bufg_in, mcb_drp_clk_bufg_in, clkfbout_clkfbin, locked, rst0_sync_r, rst_tmp, powerup_pll_locked, syn_clk0_powerup_pll_locked, sys_rst, bufpll_mcb_locked, sys_clk_ibufg.\nExplanation:\n- clk_2x_0, clk_2x_180: These are intermediate signals that represent the zero-degree and 180-degree phase-shifted clocks, respectively, directly coming out from the PLL. They are used as inputs to further clock generation and control blocks.\n- clk0_bufg, mcb_drp_clk_bufg_in: These are buffers inside the module, which are driven by the PLL outputs. clk0_bufg is used to provide the clk0 output, whereas mcb_drp_clk_bufg_in is used for generating the mcb_drp_clk output.\n- clk0_bufg_in: This is an intermediate input to the clock buffer which drives the clk0 output, sourced from one of the PLL's output clocks.\n- clkfbout_clkfbin: This signal connects the feedback output of the PLL to its feedback input, forming a crucial part of the feedback loop required for the PLL's operation.\n- locked: This is a status signal indicating whether the PLL has successfully locked onto the input clock signal, ensuring that the output clocks are stable.\n- rst0_sync_r: This register is used in the generation of the rst0 signal. It is a shift register that handles the synchronization and propagation of the reset signal with respect to clk0.\n- rst_tmp: This signal combines the asynchronous reset input with the synchronization status of the PLL, driving the reset synchronization logic.\n- powerup_pll_locked, syn_clk0_powerup_pll_locked: These registers hold the status of the PLL's lock condition post-power-up or reset, providing a stable lock indication used to form the async_rst signal.\n- sys_rst: This is the conditioned system reset signal, which can be active high or low depending on the configuration. It provides a unified reset signal for internal logic use.\n- bufpll_mcb_locked: This captures the lock condition of the complementary PLL used for generating further clock-related signals like sysclk_2x and sysclk_2x_180.\n- sys_clk_ibufg: This is the buffer output for the input clock, which can be either differential or single-ended depending on the selected configuration. This provides a stable clock source to the PLL and other components in the module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: infrastructure. Module specification: The \"infrastructure\" module is designed to manage and configure clock signals within a digital system, particularly using a PLL (Phase Locked Loop) to generate multiple output clocks with specific frequencies, phases, and duty cycles. It handles both differential (sys_clk_p, sys_clk_n) and single-ended (sys_clk) input clocks, providing better noise immunity or simpler infrastructure respectively. The module outputs include clk0 (buffered output clock), rst0 (synchronized reset signal), async_rst (combines system reset input and PLL lock status), several high-speed clock signals like sysclk_2x and sysclk_2x_180, mcb_drp_clk (for precise clocking needs), pll_ce_0 and pll_ce_90 (clock enables with phase shifts), and pll_lock (indicates PLL lock status). Internal signals such as clk_2x_0, clk_2x_180, clk0_bufg, and others facilitate the manipulation and buffering of the clock signals and synchronization logic. The Verilog code comprises multiple blocks including clock buffers, PLL configuration (PLL_ADV), clock generation decisions based on input type (differential or single-ended), and reset signal management, all aimed at ensuring stable and reliable clock outputs under various configurations and conditions."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: infrastructure.\nExplanation: The module \"infrastructure\" configures and manages clock signals for a digital system. It utilizes various configurable parameters to handle different types of input clocks (differential or single-ended) and generates multiple output clocks with specified frequencies, phases, and duty cycles by leveraging a PLL (Phase Locked Loop). The module also includes synchronization logic to handle reset conditions and ensures that the output clocks are stable and available only when the PLL is locked, thereby improving the reliability of the system's operation under various reset and power-up conditions."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: sys_clk_p, sys_clk_n, sys_clk, sys_rst_i.\nExplanation:\n- sys_clk_p, sys_clk_n: These are the positive and negative differential clock inputs used by the module when the input clock type is configured as \"DIFFERENTIAL\". The differential clock provides better noise immunity compared to single-ended clocks.\n- sys_clk: This is the single-ended clock input used by the module when the input clock type is configured as \"SINGLE_ENDED\". This configuration simplifies the clocking infrastructure but might be more susceptible to noise.\n- sys_rst_i: This is the system reset input, which is used to reset the internal logic and synchronize the PLL when asserted. The reset input can be configured as active high or active low based on the parameter C_RST_ACT_LOW.\n\nOutput ports: clk0, rst0, async_rst, sysclk_2x, sysclk_2x_180, mcb_drp_clk, pll_ce_0, pll_ce_90, pll_lock.\nExplanation:\n- clk0: A buffered output clock derived from the PLL, which can be utilized by other modules or components in the system.\n- rst0: Final reset output which is synchronized to the clk0 signal. This reset ensures that all associated logic is properly reset relative to the stable clk0.\n- async_rst: Asynchronous reset signal that combines the direct system reset input and the pll lock status to provide a quick reset mechanism when the PLL is not locked.\n- sysclk_2x, sysclk_2x_180: Double frequency clocks derived from the PLL with 0 and 180-degree phase shifts, respectively. Useful for high-speed operations or DDR interfacing needs.\n- mcb_drp_clk: A clock used potentially for memory controller block (MCB) or other clocking needs requiring precise control and locking mechanism, enabled only when PLL is locked.\n- pll_ce_0, pll_ce_90: Clock enable outputs with 0 and 90-degree phases respectively, which can be used to drive clock networks or as a strobe signal.\n- pll_lock: Indicates the lock status of the PLL. When high, it signifies that the PLL output clocks are stable and can be utilized reliably."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: clk_2x_0, clk_2x_180, clk0_bufg, clk0_bufg_in, mcb_drp_clk_bufg_in, clkfbout_clkfbin, locked, rst0_sync_r, rst_tmp, powerup_pll_locked, syn_clk0_powerup_pll_locked, sys_rst, bufpll_mcb_locked, sys_clk_ibufg.\nExplanation:\n- clk_2x_0, clk_2x_180: These are intermediate signals that represent the zero-degree and 180-degree phase-shifted clocks, respectively, directly coming out from the PLL. They are used as inputs to further clock generation and control blocks.\n- clk0_bufg, mcb_drp_clk_bufg_in: These are buffers inside the module, which are driven by the PLL outputs. clk0_bufg is used to provide the clk0 output, whereas mcb_drp_clk_bufg_in is used for generating the mcb_drp_clk output.\n- clk0_bufg_in: This is an intermediate input to the clock buffer which drives the clk0 output, sourced from one of the PLL's output clocks.\n- clkfbout_clkfbin: This signal connects the feedback output of the PLL to its feedback input, forming a crucial part of the feedback loop required for the PLL's operation.\n- locked: This is a status signal indicating whether the PLL has successfully locked onto the input clock signal, ensuring that the output clocks are stable.\n- rst0_sync_r: This register is used in the generation of the rst0 signal. It is a shift register that handles the synchronization and propagation of the reset signal with respect to clk0.\n- rst_tmp: This signal combines the asynchronous reset input with the synchronization status of the PLL, driving the reset synchronization logic.\n- powerup_pll_locked, syn_clk0_powerup_pll_locked: These registers hold the status of the PLL's lock condition post-power-up or reset, providing a stable lock indication used to form the async_rst signal.\n- sys_rst: This is the conditioned system reset signal, which can be active high or low depending on the configuration. It provides a unified reset signal for internal logic use.\n- bufpll_mcb_locked: This captures the lock condition of the complementary PLL used for generating further clock-related signals like sysclk_2x and sysclk_2x_180.\n- sys_clk_ibufg: This is the buffer output for the input clock, which can be either differential or single-ended depending on the selected configuration. This provides a stable clock source to the PLL and other components in the module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns/1ps\n\nmodule infrastructure #\n  (\n   parameter C_INCLK_PERIOD    = 2500,\n   parameter C_RST_ACT_LOW      = 1,\n   parameter C_INPUT_CLK_TYPE   = \"DIFFERENTIAL\",\n   parameter C_CLKOUT0_DIVIDE   = 1,\n   parameter C_CLKOUT1_DIVIDE   = 1,\n   parameter C_CLKOUT2_DIVIDE   = 16,\n   parameter C_CLKOUT3_DIVIDE   = 8,\n   parameter C_CLKFBOUT_MULT    = 2,\n   parameter C_DIVCLK_DIVIDE    = 1\n   \n   )\n  (\n   input  sys_clk_p,\n   input  sys_clk_n,\n   input  sys_clk,\n   input  sys_rst_i,\n   output clk0,\n   output rst0,\n   output async_rst,\n   output sysclk_2x,\n   output sysclk_2x_180,\n   output mcb_drp_clk,\n   output pll_ce_0,\n   output pll_ce_90,\n   output pll_lock\n\n   );\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    ;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n  reg \t\t\t     syn_clk0_powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  (* KEEP = \"TRUE\" *) wire sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_i: sys_rst_i;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n      \n      \n      \n\n      IBUFGDS #\n        (\n         .DIFF_TERM    (\"TRUE\")\n         )\n        u_ibufg_sys_clk\n          (\n           .I  (sys_clk_p),\n           .IB (sys_clk_n),\n           .O  (sys_clk_ibufg)\n           );\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n\n      \n      \n      \n\n      IBUFG  u_ibufg_sys_clk\n          (\n           .I  (sys_clk),\n           .O  (sys_clk_ibufg)\n           );\n   end\n  endgenerate\n\n  \n  \n  \n\n    PLL_ADV #\n        (\n         .BANDWIDTH          (\"OPTIMIZED\"),\n         .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n         .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n         .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n         .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n         .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n         .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n         .CLKOUT4_DIVIDE     (1),\n         .CLKOUT5_DIVIDE     (1),\n         .CLKOUT0_PHASE      (0.000),\n         .CLKOUT1_PHASE      (180.000),\n         .CLKOUT2_PHASE      (0.000),\n         .CLKOUT3_PHASE      (0.000),\n         .CLKOUT4_PHASE      (0.000),\n         .CLKOUT5_PHASE      (0.000),\n         .CLKOUT0_DUTY_CYCLE (0.500),\n         .CLKOUT1_DUTY_CYCLE (0.500),\n         .CLKOUT2_DUTY_CYCLE (0.500),\n         .CLKOUT3_DUTY_CYCLE (0.500),\n         .CLKOUT4_DUTY_CYCLE (0.500),\n         .CLKOUT5_DUTY_CYCLE (0.500),\n         .SIM_DEVICE         (\"SPARTAN6\"),\n         .COMPENSATION       (\"INTERNAL\"),\n         .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n         .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n         .CLKFBOUT_PHASE     (0.0),\n         .REF_JITTER         (0.005000)\n         )\n        u_pll_adv\n          (\n           .CLKFBIN     (clkfbout_clkfbin),\n           .CLKINSEL    (1'b1),\n           .CLKIN1      (sys_clk_ibufg),\n           .CLKIN2      (1'b0),\n           .DADDR       (5'b0),\n           .DCLK        (1'b0),\n           .DEN         (1'b0),\n           .DI          (16'b0),\n           .DWE         (1'b0),\n           .REL         (1'b0),\n           .RST         (sys_rst),\n           .CLKFBDCM    (),\n           .CLKFBOUT    (clkfbout_clkfbin),\n           .CLKOUTDCM0  (),\n           .CLKOUTDCM1  (),\n           .CLKOUTDCM2  (),\n           .CLKOUTDCM3  (),\n           .CLKOUTDCM4  (),\n           .CLKOUTDCM5  (),\n           .CLKOUT0     (clk_2x_0),\n           .CLKOUT1     (clk_2x_180),\n           .CLKOUT2     (clk0_bufg_in),\n           .CLKOUT3     (mcb_drp_clk_bufg_in),\n           .CLKOUT4     (),\n           .CLKOUT5     (),\n           .DO          (),\n           .DRDY        (),\n           .LOCKED      (locked)\n           );\n\n \n\n   BUFG U_BUFG_CLK0\n    (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n     );\n\n   BUFGCE U_BUFG_CLK1\n    (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in),\n     .CE (locked)\n     );\n\n  always @(posedge mcb_drp_clk , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n         \n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         syn_clk0_powerup_pll_locked <= 1'b0;\n       \n      else if (bufpll_mcb_locked)\n         syn_clk0_powerup_pll_locked <= 1'b1;\n         \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n\n  assign async_rst = sys_rst | ~powerup_pll_locked;\n  \n  assign rst_tmp = sys_rst | ~syn_clk0_powerup_pll_locked;\n\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      \n      rst0_sync_r <= rst0_sync_r << 1;\n\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n\nBUFPLL_MCB BUFPLL_MCB1 \n( .IOCLK0         (sysclk_2x),  \n  .IOCLK1         (sysclk_2x_180),       \n  .LOCKED         (locked),\n  .GCLK           (mcb_drp_clk),\n  .SERDESSTROBE0  (pll_ce_0), \n  .SERDESSTROBE1  (pll_ce_90), \n  .PLLIN0         (clk_2x_0),  \n  .PLLIN1         (clk_2x_180),\n  .LOCK           (bufpll_mcb_locked) \n  );\n\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: infrastructure. Module specification: The \"infrastructure\" module is designed to manage and configure clock signals within a digital system, particularly using a PLL (Phase Locked Loop) to generate multiple output clocks with specific frequencies, phases, and duty cycles. It handles both differential (sys_clk_p, sys_clk_n) and single-ended (sys_clk) input clocks, providing better noise immunity or simpler infrastructure respectively. The module outputs include clk0 (buffered output clock), rst0 (synchronized reset signal), async_rst (combines system reset input and PLL lock status), several high-speed clock signals like sysclk_2x and sysclk_2x_180, mcb_drp_clk (for precise clocking needs), pll_ce_0 and pll_ce_90 (clock enables with phase shifts), and pll_lock (indicates PLL lock status). Internal signals such as clk_2x_0, clk_2x_180, clk0_bufg, and others facilitate the manipulation and buffering of the clock signals and synchronization logic. The Verilog code comprises multiple blocks including clock buffers, PLL configuration (PLL_ADV), clock generation decisions based on input type (differential or single-ended), and reset signal management, all aimed at ensuring stable and reliable clock outputs under various configurations and conditions."
                }
            ]
        }
    ]
}