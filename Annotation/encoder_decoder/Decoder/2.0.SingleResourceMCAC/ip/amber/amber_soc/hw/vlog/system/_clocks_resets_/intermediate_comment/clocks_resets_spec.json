{
    "spec": "Module name: clocks_resets.\n\nModule specification: The \"clocks_resets\" module is designed for handling clock and reset signals within a digital system. It processes differential clock signals and a board reset input to generate a system clock and a system reset signal, leveraging FPGA-specific resources like PLLs (Phase-Locked Loops) or MMCMs (Mixed-Mode Clock Managers) for clock signal conditioning and management. The module accepts four input ports: `i_brd_rst` (board reset signal), `i_brd_clk_n` and `i_brd_clk_p` (negative and positive differential clock inputs), and `i_ddr_calib_done` (DDR calibration completion signal). Three output ports are provided: `o_sys_rst` (system reset signal), `o_sys_clk` (system clock), and `o_clk_200` (an additional 200 MHz clock output). Internally, the module employs signals like `rst0` for reset generation, `pll_locked` for clock stability confirmation, and various synchronization registers to ensure correct timing and functionality across different clock domains. The Verilog code includes conditional compilation blocks (`ifdef XILINX_FPGA`) configuring the module for different FPGA families (Spartan6 and Virtex6) by defining FPGA-specific clock conditioning and reset logic. In non-Xilinx FPGA scenarios, it includes behavioral models for PLL and system clock functionalities, ensuring broad compatibility and ease of simulation. This comprehensive setup ensures the system's reliability and stability by providing the necessary clock and reset signals across various operating conditions and FPGA platforms.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: clocks_resets.\nExplanation: The module named \"clocks_resets\" is designed for handling clock and reset signals in a digital system. It takes inputs such as board reset, differential clock signals, and DDR calibration completion signal, and outputs system clock, reset, and optionally a 200 MHz clock. The module involves clock signal conditioning using IBUFGDS for differential signaling and PLL or MMCM for clock management, depending on the type of FPGA (Spartan6 or Virtex6). The reset logic includes synchronization and generation of a system reset signal based on the PLL's lock status and the DDR calibration state. This module is critical in ensuring stable and synchronized operation across various components of the system by providing the necessary clock and reset signals."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: i_brd_rst, i_brd_clk_n, i_brd_clk_p, i_ddr_calib_done.\nExplanation:\n- i_brd_rst: This is the board reset input signal. It is used to reset the entire system and all synchronized registers within the module to ensure a known state upon system initialization or when a reset is required.\n- i_brd_clk_n, i_brd_clk_p: These are the negative and positive differential clock input signals, respectively. They are used as the primary clock input for the system and are typically passed through a differential buffer (IBUFGDS) to generate a single-ended clock signal inside the FPGA.\n- i_ddr_calib_done: This input indicates whether DDR calibration has been completed. It is used to ensure that the system does not start operating with the DDR memory until it is properly calibrated and ready.\n\nOutput ports: o_sys_rst, o_sys_clk, o_clk_200.\nExplanation:\n- o_sys_rst: This is the system reset output signal. It is generated based on the board reset and DDR calibration status. The signal ensures that the system reset is applied across the entire digital system post-initialization or in the event of a necessary reset.\n- o_sys_clk: This is the system clock output signal, derived from a phase-locked loop (PLL) or mixed-mode clock manager (MMCM) depending on FPGA type. This clock is used to drive the synchronous elements in the digital system, providing a stable and reliable clock.\n- o_clk_200: This is an additional clock output running at 200 MHz, provided from the input differential clock buffer directly and used for specific system requirements needing this frequency."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: calib_done_33mhz, rst0, pll_locked, clkfbout_clkfbin, rst0_sync_r, ddr_calib_done_sync_r, rst_tmp, pll_clk, brd_clk_ibufg, pll_div_count, sys_clk_beh, pll_clk_beh, brd_clk_period, pll_clk_period, brd_temp.\n\nExplanation:\n- calib_done_33mhz: A signal indicating the completion of the DDR calibration at a 33 MHz effective rate, derived from the synchronization of the i_ddr_calib_done input after a reset or initialization.\n- rst0: This signal is used to generate the o_sys_rst output. It becomes high during reset conditions such as the assertion of the i_brd_rst signal or if the DDR calibration is not done.\n- pll_locked: This status signal from the PLL/MMCM indicates whether the PLL has successfully locked to the desired frequency, critical for stable clock generation.\n- clkfbout_clkfbin: Loopback connection between the output and input of the feedback clock in the PLL. This is critical in maintaining the stability and regulation of the PLL\u2019s output frequency.\n- rst0_sync_r: A register array used to synchronize the rst0 signal across the clock domains to avoid metastability issues.\n- ddr_calib_done_sync_r: A register array used to synchronize the DDR calibration completion signal across the clock domains to align it with the system clock domain.\n- rst_tmp: An intermediate reset signal that is asserted either by the board reset or when the PLL is not locked, ensuring a safe reset condition for synchronization registers.\n- pll_clk: The output clock from the PLL or MMCM used as the system clock (o_sys_clk) and further clock domains inside the FPGA.\n- brd_clk_ibufg: The buffered version of the input differential clock, used directly as the 200 MHz output clock (o_clk_200) and as an input to the PLL or MMCM.\n- pll_div_count: A counter used in the non-Xilinx FPGA implementation to generate a divided clock based on brd_clk_period, simulating PLL behavior in a behavioral model.\n- sys_clk_beh: A behaviorally modeled system clock signal derived from the pll_clk_beh, used to imitate hardware PLL functionality in simulation for platforms other than Xilinx FPGAs.\n- pll_clk_beh: A behaviorally modeled PLL clock signal based on the period calculated from the input clock; this is toggled to simulate the PLL clock output in non-Xilinx FPGAs.\n- brd_clk_period: A real value capturing the period of the input differential clock, used to calculate timings for simulation models.\n- pll_clk_period: A real value calculated based on brd_clk_period indicating the period of the pll_clk_beh, used in simulations to model hardware behavior in non-Xilinx FPGAs.\n- brd_temp: A real value temporarily storing time measurements to assist in calculation of brd_clk_period during simulation initialization."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"system_config_defines.vh\"\n`include \"global_timescale.vh\"\n\n\n\n\n\n\nmodule clocks_resets  (\ninput                       i_brd_rst,\ninput                       i_brd_clk_n,  \ninput                       i_brd_clk_p,  \ninput                       i_ddr_calib_done,\noutput                      o_sys_rst,\noutput                      o_sys_clk,\noutput                      o_clk_200\n\n);\n\n\nwire                        calib_done_33mhz;\nwire                        rst0;\n\nassign o_sys_rst = rst0 || !calib_done_33mhz;\n\n\n\n`ifdef XILINX_FPGA\n\n    localparam                  RST_SYNC_NUM = 25;\n    wire                        pll_locked;\n    wire                        clkfbout_clkfbin;\n    reg [RST_SYNC_NUM-1:0]      rst0_sync_r    ;\n    reg [RST_SYNC_NUM-1:0]      ddr_calib_done_sync_r    ;\n    wire                        rst_tmp;\n    wire                        pll_clk;\n\n    (* KEEP = \"TRUE\" *)  wire brd_clk_ibufg;\n\n\n    IBUFGDS # (  \n         .DIFF_TERM  ( \"TRUE\"     ), \n         .IOSTANDARD ( \"LVDS_25\"  ))  \n         u_ibufgds_brd\n        (\n         .I  ( i_brd_clk_p    ),\n         .IB ( i_brd_clk_n    ),\n         .O  ( brd_clk_ibufg  )\n         );\n         \n         \n    assign rst0             = rst0_sync_r[RST_SYNC_NUM-1];\n    assign calib_done_33mhz = ddr_calib_done_sync_r[RST_SYNC_NUM-1];\n    assign o_clk_200        = brd_clk_ibufg;\n\n\n    `ifdef XILINX_SPARTAN6_FPGA\n    \n    \n    \n        PLL_ADV #\n            (\n             .BANDWIDTH          ( \"OPTIMIZED\"        ),\n             .CLKIN1_PERIOD      ( 5                  ),\n             .CLKIN2_PERIOD      ( 1                  ),\n             .CLKOUT0_DIVIDE     ( 1                  ), \n             .CLKOUT1_DIVIDE     (                    ),\n             .CLKOUT2_DIVIDE     ( `AMBER_CLK_DIVIDER ),   \n             .CLKOUT3_DIVIDE     ( 1                  ),\n             .CLKOUT4_DIVIDE     ( 1                  ),\n             .CLKOUT5_DIVIDE     ( 1                  ),\n             .CLKOUT0_PHASE      ( 0.000              ),\n             .CLKOUT1_PHASE      ( 0.000              ),\n             .CLKOUT2_PHASE      ( 0.000              ),\n             .CLKOUT3_PHASE      ( 0.000              ),\n             .CLKOUT4_PHASE      ( 0.000              ),\n             .CLKOUT5_PHASE      ( 0.000              ),\n             .CLKOUT0_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT1_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT2_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT3_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT4_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT5_DUTY_CYCLE ( 0.500              ),\n             .COMPENSATION       ( \"INTERNAL\"         ),\n             .DIVCLK_DIVIDE      ( 1                  ),\n             .CLKFBOUT_MULT      ( 4                  ),   \n             .CLKFBOUT_PHASE     ( 0.0                ),\n             .REF_JITTER         ( 0.005000           )\n             )\n            u_pll_adv\n              (\n               .CLKFBIN     ( clkfbout_clkfbin  ),\n               .CLKINSEL    ( 1'b1              ),\n               .CLKIN1      ( brd_clk_ibufg     ),\n               .CLKIN2      ( 1'b0              ),\n               .DADDR       ( 5'b0              ),\n               .DCLK        ( 1'b0              ),\n               .DEN         ( 1'b0              ),\n               .DI          ( 16'b0             ),           \n               .DWE         ( 1'b0              ),\n               .REL         ( 1'b0              ),\n               .RST         ( i_brd_rst          ),\n               .CLKFBDCM    (                   ),\n               .CLKFBOUT    ( clkfbout_clkfbin  ),\n               .CLKOUTDCM0  (                   ),\n               .CLKOUTDCM1  (                   ),\n               .CLKOUTDCM2  (                   ),\n               .CLKOUTDCM3  (                   ),\n               .CLKOUTDCM4  (                   ),\n               .CLKOUTDCM5  (                   ),\n               .CLKOUT0     (                   ),\n               .CLKOUT1     (                   ),\n               .CLKOUT2     ( pll_clk           ),\n               .CLKOUT3     (                   ),\n               .CLKOUT4     (                   ),\n               .CLKOUT5     (                   ),\n               .DO          (                   ),\n               .DRDY        (                   ),\n               .LOCKED      ( pll_locked        )\n               );\n    `endif\n\n\n    `ifdef XILINX_VIRTEX6_FPGA\n    \n    \n    \n        MMCM_ADV #\n        (\n         .CLKIN1_PERIOD      ( 5                    ),   \n         .CLKOUT2_DIVIDE     ( `AMBER_CLK_DIVIDER   ),\n         .CLKFBOUT_MULT_F    ( 6                    )    \n         )\n        u_pll_adv\n          (\n           .CLKFBOUT     ( clkfbout_clkfbin ),\n           .CLKFBOUTB    (                  ),\n           .CLKFBSTOPPED (                  ),\n           .CLKINSTOPPED (                  ),\n           .CLKOUT0      (                  ),\n           .CLKOUT0B     (                  ),\n           .CLKOUT1      (                  ),\n           .CLKOUT1B     (                  ),\n           .CLKOUT2      ( pll_clk          ),\n           .CLKOUT2B     (                  ),\n           .CLKOUT3      (                  ),\n           .CLKOUT3B     (                  ),\n           .CLKOUT4      (                  ),\n           .CLKOUT5      (                  ),\n           .CLKOUT6      (                  ),\n           .DRDY         (                  ),\n           .LOCKED       ( pll_locked       ),\n           .PSDONE       (                  ),\n           .DO           (                  ),\n           .CLKFBIN      ( clkfbout_clkfbin ),\n           .CLKIN1       ( brd_clk_ibufg    ),\n           .CLKIN2       ( 1'b0             ),\n           .CLKINSEL     ( 1'b1             ),\n           .DCLK         ( 1'b0             ),\n           .DEN          ( 1'b0             ),\n           .DWE          ( 1'b0             ),\n           .PSCLK        ( 1'd0             ),\n           .PSEN         ( 1'd0             ),\n           .PSINCDEC     ( 1'd0             ),\n           .PWRDWN       ( 1'd0             ),\n           .RST          ( i_brd_rst         ),\n           .DI           ( 16'b0            ),\n           .DADDR        ( 7'b0             ) \n           );\n    `endif\n\n\n    BUFG u_bufg_sys_clk (\n         .O ( o_sys_clk  ),\n         .I ( pll_clk    )\n         );\n\n\n    \n    \n    \n    assign rst_tmp = i_brd_rst | ~pll_locked;\n\n      \n    always @(posedge o_sys_clk or posedge rst_tmp)\n        if (rst_tmp)\n          rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n        else\n          \n          rst0_sync_r <= rst0_sync_r << 1;\n\n    always @(posedge o_sys_clk or posedge rst_tmp)\n        if (rst_tmp)\n            ddr_calib_done_sync_r <= {RST_SYNC_NUM{1'b0}};\n        else\n            ddr_calib_done_sync_r <= {ddr_calib_done_sync_r[RST_SYNC_NUM-2:0], i_ddr_calib_done};\n\n    `endif\n\n\n\n`ifndef XILINX_FPGA\n\nreal      brd_clk_period = 6000;  \nreal      pll_clk_period = 1000;  \nreal      brd_temp;\nreg       pll_clk_beh;\nreg       sys_clk_beh;\ninteger   pll_div_count = 0;\n\n\ninitial\n    begin\n    @ (posedge i_brd_clk_p)\n    brd_temp = $time;\n    @ (posedge i_brd_clk_p)\n    brd_clk_period = $time - brd_temp;\n    pll_clk_period = brd_clk_period / 4;\n    end\n    \n\nalways @( posedge i_brd_clk_p )\n    begin\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n\n    end\n\n\nalways @( pll_clk_beh )\n    begin\n    if ( pll_div_count == (\n        `AMBER_CLK_DIVIDER \n        * 2 ) - 1 )\n        pll_div_count <= 'd0;\n    else    \n        pll_div_count <= pll_div_count + 1'd1;\n        \n    if ( pll_div_count == 0 )\n        sys_clk_beh = 1'd1;\n    else if ( pll_div_count == \n        `AMBER_CLK_DIVIDER \n        )\n        sys_clk_beh = 1'd0;\n    end\n\nassign o_sys_clk        = sys_clk_beh;\nassign rst0             = i_brd_rst;\nassign calib_done_33mhz = 1'd1;\nassign o_clk_200        = i_brd_clk_p;\n\n`endif\n\n\nendmodule\n\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: clocks_resets.\n\nModule specification: The \"clocks_resets\" module is designed for handling clock and reset signals within a digital system. It processes differential clock signals and a board reset input to generate a system clock and a system reset signal, leveraging FPGA-specific resources like PLLs (Phase-Locked Loops) or MMCMs (Mixed-Mode Clock Managers) for clock signal conditioning and management. The module accepts four input ports: `i_brd_rst` (board reset signal), `i_brd_clk_n` and `i_brd_clk_p` (negative and positive differential clock inputs), and `i_ddr_calib_done` (DDR calibration completion signal). Three output ports are provided: `o_sys_rst` (system reset signal), `o_sys_clk` (system clock), and `o_clk_200` (an additional 200 MHz clock output). Internally, the module employs signals like `rst0` for reset generation, `pll_locked` for clock stability confirmation, and various synchronization registers to ensure correct timing and functionality across different clock domains. The Verilog code includes conditional compilation blocks (`ifdef XILINX_FPGA`) configuring the module for different FPGA families (Spartan6 and Virtex6) by defining FPGA-specific clock conditioning and reset logic. In non-Xilinx FPGA scenarios, it includes behavioral models for PLL and system clock functionalities, ensuring broad compatibility and ease of simulation. This comprehensive setup ensures the system's reliability and stability by providing the necessary clock and reset signals across various operating conditions and FPGA platforms."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: clocks_resets.\nExplanation: The module named \"clocks_resets\" is designed for handling clock and reset signals in a digital system. It takes inputs such as board reset, differential clock signals, and DDR calibration completion signal, and outputs system clock, reset, and optionally a 200 MHz clock. The module involves clock signal conditioning using IBUFGDS for differential signaling and PLL or MMCM for clock management, depending on the type of FPGA (Spartan6 or Virtex6). The reset logic includes synchronization and generation of a system reset signal based on the PLL's lock status and the DDR calibration state. This module is critical in ensuring stable and synchronized operation across various components of the system by providing the necessary clock and reset signals."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: i_brd_rst, i_brd_clk_n, i_brd_clk_p, i_ddr_calib_done.\nExplanation:\n- i_brd_rst: This is the board reset input signal. It is used to reset the entire system and all synchronized registers within the module to ensure a known state upon system initialization or when a reset is required.\n- i_brd_clk_n, i_brd_clk_p: These are the negative and positive differential clock input signals, respectively. They are used as the primary clock input for the system and are typically passed through a differential buffer (IBUFGDS) to generate a single-ended clock signal inside the FPGA.\n- i_ddr_calib_done: This input indicates whether DDR calibration has been completed. It is used to ensure that the system does not start operating with the DDR memory until it is properly calibrated and ready.\n\nOutput ports: o_sys_rst, o_sys_clk, o_clk_200.\nExplanation:\n- o_sys_rst: This is the system reset output signal. It is generated based on the board reset and DDR calibration status. The signal ensures that the system reset is applied across the entire digital system post-initialization or in the event of a necessary reset.\n- o_sys_clk: This is the system clock output signal, derived from a phase-locked loop (PLL) or mixed-mode clock manager (MMCM) depending on FPGA type. This clock is used to drive the synchronous elements in the digital system, providing a stable and reliable clock.\n- o_clk_200: This is an additional clock output running at 200 MHz, provided from the input differential clock buffer directly and used for specific system requirements needing this frequency."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: calib_done_33mhz, rst0, pll_locked, clkfbout_clkfbin, rst0_sync_r, ddr_calib_done_sync_r, rst_tmp, pll_clk, brd_clk_ibufg, pll_div_count, sys_clk_beh, pll_clk_beh, brd_clk_period, pll_clk_period, brd_temp.\n\nExplanation:\n- calib_done_33mhz: A signal indicating the completion of the DDR calibration at a 33 MHz effective rate, derived from the synchronization of the i_ddr_calib_done input after a reset or initialization.\n- rst0: This signal is used to generate the o_sys_rst output. It becomes high during reset conditions such as the assertion of the i_brd_rst signal or if the DDR calibration is not done.\n- pll_locked: This status signal from the PLL/MMCM indicates whether the PLL has successfully locked to the desired frequency, critical for stable clock generation.\n- clkfbout_clkfbin: Loopback connection between the output and input of the feedback clock in the PLL. This is critical in maintaining the stability and regulation of the PLL\u2019s output frequency.\n- rst0_sync_r: A register array used to synchronize the rst0 signal across the clock domains to avoid metastability issues.\n- ddr_calib_done_sync_r: A register array used to synchronize the DDR calibration completion signal across the clock domains to align it with the system clock domain.\n- rst_tmp: An intermediate reset signal that is asserted either by the board reset or when the PLL is not locked, ensuring a safe reset condition for synchronization registers.\n- pll_clk: The output clock from the PLL or MMCM used as the system clock (o_sys_clk) and further clock domains inside the FPGA.\n- brd_clk_ibufg: The buffered version of the input differential clock, used directly as the 200 MHz output clock (o_clk_200) and as an input to the PLL or MMCM.\n- pll_div_count: A counter used in the non-Xilinx FPGA implementation to generate a divided clock based on brd_clk_period, simulating PLL behavior in a behavioral model.\n- sys_clk_beh: A behaviorally modeled system clock signal derived from the pll_clk_beh, used to imitate hardware PLL functionality in simulation for platforms other than Xilinx FPGAs.\n- pll_clk_beh: A behaviorally modeled PLL clock signal based on the period calculated from the input clock; this is toggled to simulate the PLL clock output in non-Xilinx FPGAs.\n- brd_clk_period: A real value capturing the period of the input differential clock, used to calculate timings for simulation models.\n- pll_clk_period: A real value calculated based on brd_clk_period indicating the period of the pll_clk_beh, used in simulations to model hardware behavior in non-Xilinx FPGAs.\n- brd_temp: A real value temporarily storing time measurements to assist in calculation of brd_clk_period during simulation initialization."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`include \"system_config_defines.vh\"\n`include \"global_timescale.vh\"\n\n\n\n\n\n\nmodule clocks_resets  (\ninput                       i_brd_rst,\ninput                       i_brd_clk_n,  \ninput                       i_brd_clk_p,  \ninput                       i_ddr_calib_done,\noutput                      o_sys_rst,\noutput                      o_sys_clk,\noutput                      o_clk_200\n\n);\n\n\nwire                        calib_done_33mhz;\nwire                        rst0;\n\nassign o_sys_rst = rst0 || !calib_done_33mhz;\n\n\n\n`ifdef XILINX_FPGA\n\n    localparam                  RST_SYNC_NUM = 25;\n    wire                        pll_locked;\n    wire                        clkfbout_clkfbin;\n    reg [RST_SYNC_NUM-1:0]      rst0_sync_r    ;\n    reg [RST_SYNC_NUM-1:0]      ddr_calib_done_sync_r    ;\n    wire                        rst_tmp;\n    wire                        pll_clk;\n\n    (* KEEP = \"TRUE\" *)  wire brd_clk_ibufg;\n\n\n    IBUFGDS # (  \n         .DIFF_TERM  ( \"TRUE\"     ), \n         .IOSTANDARD ( \"LVDS_25\"  ))  \n         u_ibufgds_brd\n        (\n         .I  ( i_brd_clk_p    ),\n         .IB ( i_brd_clk_n    ),\n         .O  ( brd_clk_ibufg  )\n         );\n         \n         \n    assign rst0             = rst0_sync_r[RST_SYNC_NUM-1];\n    assign calib_done_33mhz = ddr_calib_done_sync_r[RST_SYNC_NUM-1];\n    assign o_clk_200        = brd_clk_ibufg;\n\n\n    `ifdef XILINX_SPARTAN6_FPGA\n    \n    \n    \n        PLL_ADV #\n            (\n             .BANDWIDTH          ( \"OPTIMIZED\"        ),\n             .CLKIN1_PERIOD      ( 5                  ),\n             .CLKIN2_PERIOD      ( 1                  ),\n             .CLKOUT0_DIVIDE     ( 1                  ), \n             .CLKOUT1_DIVIDE     (                    ),\n             .CLKOUT2_DIVIDE     ( `AMBER_CLK_DIVIDER ),   \n             .CLKOUT3_DIVIDE     ( 1                  ),\n             .CLKOUT4_DIVIDE     ( 1                  ),\n             .CLKOUT5_DIVIDE     ( 1                  ),\n             .CLKOUT0_PHASE      ( 0.000              ),\n             .CLKOUT1_PHASE      ( 0.000              ),\n             .CLKOUT2_PHASE      ( 0.000              ),\n             .CLKOUT3_PHASE      ( 0.000              ),\n             .CLKOUT4_PHASE      ( 0.000              ),\n             .CLKOUT5_PHASE      ( 0.000              ),\n             .CLKOUT0_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT1_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT2_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT3_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT4_DUTY_CYCLE ( 0.500              ),\n             .CLKOUT5_DUTY_CYCLE ( 0.500              ),\n             .COMPENSATION       ( \"INTERNAL\"         ),\n             .DIVCLK_DIVIDE      ( 1                  ),\n             .CLKFBOUT_MULT      ( 4                  ),   \n             .CLKFBOUT_PHASE     ( 0.0                ),\n             .REF_JITTER         ( 0.005000           )\n             )\n            u_pll_adv\n              (\n               .CLKFBIN     ( clkfbout_clkfbin  ),\n               .CLKINSEL    ( 1'b1              ),\n               .CLKIN1      ( brd_clk_ibufg     ),\n               .CLKIN2      ( 1'b0              ),\n               .DADDR       ( 5'b0              ),\n               .DCLK        ( 1'b0              ),\n               .DEN         ( 1'b0              ),\n               .DI          ( 16'b0             ),           \n               .DWE         ( 1'b0              ),\n               .REL         ( 1'b0              ),\n               .RST         ( i_brd_rst          ),\n               .CLKFBDCM    (                   ),\n               .CLKFBOUT    ( clkfbout_clkfbin  ),\n               .CLKOUTDCM0  (                   ),\n               .CLKOUTDCM1  (                   ),\n               .CLKOUTDCM2  (                   ),\n               .CLKOUTDCM3  (                   ),\n               .CLKOUTDCM4  (                   ),\n               .CLKOUTDCM5  (                   ),\n               .CLKOUT0     (                   ),\n               .CLKOUT1     (                   ),\n               .CLKOUT2     ( pll_clk           ),\n               .CLKOUT3     (                   ),\n               .CLKOUT4     (                   ),\n               .CLKOUT5     (                   ),\n               .DO          (                   ),\n               .DRDY        (                   ),\n               .LOCKED      ( pll_locked        )\n               );\n    `endif\n\n\n    `ifdef XILINX_VIRTEX6_FPGA\n    \n    \n    \n        MMCM_ADV #\n        (\n         .CLKIN1_PERIOD      ( 5                    ),   \n         .CLKOUT2_DIVIDE     ( `AMBER_CLK_DIVIDER   ),\n         .CLKFBOUT_MULT_F    ( 6                    )    \n         )\n        u_pll_adv\n          (\n           .CLKFBOUT     ( clkfbout_clkfbin ),\n           .CLKFBOUTB    (                  ),\n           .CLKFBSTOPPED (                  ),\n           .CLKINSTOPPED (                  ),\n           .CLKOUT0      (                  ),\n           .CLKOUT0B     (                  ),\n           .CLKOUT1      (                  ),\n           .CLKOUT1B     (                  ),\n           .CLKOUT2      ( pll_clk          ),\n           .CLKOUT2B     (                  ),\n           .CLKOUT3      (                  ),\n           .CLKOUT3B     (                  ),\n           .CLKOUT4      (                  ),\n           .CLKOUT5      (                  ),\n           .CLKOUT6      (                  ),\n           .DRDY         (                  ),\n           .LOCKED       ( pll_locked       ),\n           .PSDONE       (                  ),\n           .DO           (                  ),\n           .CLKFBIN      ( clkfbout_clkfbin ),\n           .CLKIN1       ( brd_clk_ibufg    ),\n           .CLKIN2       ( 1'b0             ),\n           .CLKINSEL     ( 1'b1             ),\n           .DCLK         ( 1'b0             ),\n           .DEN          ( 1'b0             ),\n           .DWE          ( 1'b0             ),\n           .PSCLK        ( 1'd0             ),\n           .PSEN         ( 1'd0             ),\n           .PSINCDEC     ( 1'd0             ),\n           .PWRDWN       ( 1'd0             ),\n           .RST          ( i_brd_rst         ),\n           .DI           ( 16'b0            ),\n           .DADDR        ( 7'b0             ) \n           );\n    `endif\n\n\n    BUFG u_bufg_sys_clk (\n         .O ( o_sys_clk  ),\n         .I ( pll_clk    )\n         );\n\n\n    \n    \n    \n    assign rst_tmp = i_brd_rst | ~pll_locked;\n\n      \n    always @(posedge o_sys_clk or posedge rst_tmp)\n        if (rst_tmp)\n          rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n        else\n          \n          rst0_sync_r <= rst0_sync_r << 1;\n\n    always @(posedge o_sys_clk or posedge rst_tmp)\n        if (rst_tmp)\n            ddr_calib_done_sync_r <= {RST_SYNC_NUM{1'b0}};\n        else\n            ddr_calib_done_sync_r <= {ddr_calib_done_sync_r[RST_SYNC_NUM-2:0], i_ddr_calib_done};\n\n    `endif\n\n\n\n`ifndef XILINX_FPGA\n\nreal      brd_clk_period = 6000;  \nreal      pll_clk_period = 1000;  \nreal      brd_temp;\nreg       pll_clk_beh;\nreg       sys_clk_beh;\ninteger   pll_div_count = 0;\n\n\ninitial\n    begin\n    @ (posedge i_brd_clk_p)\n    brd_temp = $time;\n    @ (posedge i_brd_clk_p)\n    brd_clk_period = $time - brd_temp;\n    pll_clk_period = brd_clk_period / 4;\n    end\n    \n\nalways @( posedge i_brd_clk_p )\n    begin\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n    # ( pll_clk_period / 2 )\n\n    pll_clk_beh = 1'd1;\n    # ( pll_clk_period / 2 )\n    pll_clk_beh = 1'd0;\n\n    end\n\n\nalways @( pll_clk_beh )\n    begin\n    if ( pll_div_count == (\n        `AMBER_CLK_DIVIDER \n        * 2 ) - 1 )\n        pll_div_count <= 'd0;\n    else    \n        pll_div_count <= pll_div_count + 1'd1;\n        \n    if ( pll_div_count == 0 )\n        sys_clk_beh = 1'd1;\n    else if ( pll_div_count == \n        `AMBER_CLK_DIVIDER \n        )\n        sys_clk_beh = 1'd0;\n    end\n\nassign o_sys_clk        = sys_clk_beh;\nassign rst0             = i_brd_rst;\nassign calib_done_33mhz = 1'd1;\nassign o_clk_200        = i_brd_clk_p;\n\n`endif\n\n\nendmodule\n\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: clocks_resets.\n\nModule specification: The \"clocks_resets\" module is designed for handling clock and reset signals within a digital system. It processes differential clock signals and a board reset input to generate a system clock and a system reset signal, leveraging FPGA-specific resources like PLLs (Phase-Locked Loops) or MMCMs (Mixed-Mode Clock Managers) for clock signal conditioning and management. The module accepts four input ports: `i_brd_rst` (board reset signal), `i_brd_clk_n` and `i_brd_clk_p` (negative and positive differential clock inputs), and `i_ddr_calib_done` (DDR calibration completion signal). Three output ports are provided: `o_sys_rst` (system reset signal), `o_sys_clk` (system clock), and `o_clk_200` (an additional 200 MHz clock output). Internally, the module employs signals like `rst0` for reset generation, `pll_locked` for clock stability confirmation, and various synchronization registers to ensure correct timing and functionality across different clock domains. The Verilog code includes conditional compilation blocks (`ifdef XILINX_FPGA`) configuring the module for different FPGA families (Spartan6 and Virtex6) by defining FPGA-specific clock conditioning and reset logic. In non-Xilinx FPGA scenarios, it includes behavioral models for PLL and system clock functionalities, ensuring broad compatibility and ease of simulation. This comprehensive setup ensures the system's reliability and stability by providing the necessary clock and reset signals across various operating conditions and FPGA platforms."
                }
            ]
        }
    ]
}