{
    "spec": "Module name: ethmac_wb\n\nModule specification: The `ethmac_wb` module functions as an interface component in an Ethernet MAC subsystem, linking the master and slave sections of a Wishbone bus. It supports configurable data widths of 32 or 128 bits. The module handles various input and output ports - `i_m_wb_*` inputs connect to the master side and include signals like address (`adr`), data (`wdat`), control (`cyc`, `stb`, `we`), and feedback (`ack`, `err`). Correspondingly, `o_m_wb_*` outputs interface back to the master side. Likewise, `i_s_wb_*` inputs and `o_s_wb_*` outputs connect to and from the slave side, respectively, transferring similar kinds of data and control signals. The module doesn\u2019t utilize explicit internal signals for internal storage or data manipulation; instead, it directly manipulates and routes these inputs to outputs through conditional checks and assignments. The Verilog code includes two main generate blocks: `wbm128` and `wbm32` for the master, and `wbs128` and `wbs32` for the slave interfaces, handling data width adaptation, endianness conversion, and signal alignment based on the `WB_DWIDTH` parameter. These generate blocks conditionally format outputs primarily concerning data width and endian corrections using helper functions from an included file `system_functions.vh`, illustrating a dynamic and reconfigurable design approach suitable for variable bus configurations in network applications.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: ethmac_wb\n\nExplanation: This module seems to be designed as part of an Ethernet MAC (Media Access Control) subsystem, interfacing with a Wishbone bus. It features parameterized data widths and manages read and write data transactions between a master and slave interface of the bus. The module handles data alignment and endianess adjustments depending on the parameterized data width (either 32 or 128 bits), facilitating compatible and flexible data communication across different subsystems through conditional instantiation, as seen in the `generate` blocks within the Verilog code. It additionally implements the direct passing of control signals such as acknowledge (`ack`), error (`err`), write enable (`we`), and others between its interfaces, ensuring reliable data transactions over the Wishbone bus."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- `i_m_wb_adr`, `i_m_wb_sel`, `i_m_wb_we`, `i_m_wb_wdat`, `i_m_wb_cyc`, `i_m_wb_stb`, `i_m_wb_rdat`, `i_m_wb_ack`, `i_m_wb_err`\n- `i_s_wb_adr`, `i_s_wb_sel`, `i_s_wb_we`, `i_s_wb_wdat`, `i_s_wb_cyc`, `i_s_wb_stb`, `i_s_wb_rdat`, `i_s_wb_ack`, `i_s_wb_err`\n\n**Explanation:**\n- `i_m_wb_*` ports correspond to the master interface of the Wishbone bus. They include address (`adr`), select (`sel`), write enable (`we`), write data (`wdat`), cycle valid signal (`cyc`), strobe signal (`stb`), read data (`rdat`), acknowledge signal (`ack`), and error signal (`err`). These inputs manage data transfers and control signaling from the master side of the Wishbone bus.\n- `i_s_wb_*` ports correspond to the slave interface of the Wishbone bus with a similar set of signals that manage data transfers and control signaling from the slave side.\n\n**Output ports:**\n- `o_m_wb_rdat`, `o_m_wb_ack`, `o_m_wb_err`, `o_m_wb_adr`, `o_m_wb_sel`, `o_m_wb_we`, `o_m_wb_wdat`, `o_m_wb_cyc`, `o_m_wb_stb`\n- `o_s_wb_rdat`, `o_s_wb_ack`, `o_s_wb_err`, `o_s_wb_adr`, `o_s_wb_sel`, `o_s_wb_we`, `o_s_wb_wdat`, `o_s_wb_cyc`, `o_s_wb_stb`\n\n**Explanation:**\n- `o_m_wb_*` ports are the outputs directed towards the master interface of the Wishbone bus. They include read data (`rdat`), acknowledge signal (`ack`), error signal (`err`), address (`adr`), select (`sel`), write enable (`we`), write data (`wdat`), cycle valid signal (`cyc`), and strobe signal (`stb`). These outputs connect the internal operation of the module with the master side, facilitating output control and data response.\n- `o_s_wb_*` ports are the outputs directed towards the slave interface. These carry resolved control signals and data processed to suit the slave communication requirements on the bus."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: None explicitly defined within the provided code.\n\nExplanation: The module `ethmac_wb` relies entirely on direct connections and signal manipulations between its ports and does not explicitly declare or use additional internal signals within the given context. All data transformations and routing between input and output ports are handled directly through assignments and conditional checks without the storage or intermediate manipulation using internal signals as per the visible code. This straightforward approach is typical in interface-focused Verilog modules where simplicity and direct traceability of signal paths are crucial."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule ethmac_wb #(\nparameter WB_DWIDTH  = 32,\nparameter WB_SWIDTH  = 4\n)(\n\n\ninput       [31:0]          i_m_wb_adr,\ninput       [3:0]           i_m_wb_sel,\ninput                       i_m_wb_we,\noutput      [31:0]          o_m_wb_rdat,\ninput       [31:0]          i_m_wb_wdat,\ninput                       i_m_wb_cyc,\ninput                       i_m_wb_stb,\noutput                      o_m_wb_ack,\noutput                      o_m_wb_err,\n\n\noutput      [31:0]          o_m_wb_adr,\noutput      [WB_SWIDTH-1:0] o_m_wb_sel,\noutput                      o_m_wb_we,\ninput       [WB_DWIDTH-1:0] i_m_wb_rdat,\noutput      [WB_DWIDTH-1:0] o_m_wb_wdat,\noutput                      o_m_wb_cyc,\noutput                      o_m_wb_stb,\ninput                       i_m_wb_ack,\ninput                       i_m_wb_err,\n\n\ninput       [31:0]          i_s_wb_adr,\ninput       [WB_SWIDTH-1:0] i_s_wb_sel,\ninput                       i_s_wb_we,\noutput      [WB_DWIDTH-1:0] o_s_wb_rdat,\ninput       [WB_DWIDTH-1:0] i_s_wb_wdat,\ninput                       i_s_wb_cyc,\ninput                       i_s_wb_stb,\noutput                      o_s_wb_ack,\noutput                      o_s_wb_err,\n\n\noutput      [31:0]          o_s_wb_adr,\noutput      [3:0]           o_s_wb_sel,\noutput                      o_s_wb_we,\ninput       [31:0]          i_s_wb_rdat,\noutput      [31:0]          o_s_wb_wdat,\noutput                      o_s_wb_cyc,\noutput                      o_s_wb_stb,\ninput                       i_s_wb_ack,\ninput                       i_s_wb_err\n\n);\n\n`include \"system_functions.vh\"\n\n\n\n\n\ngenerate\nif (WB_DWIDTH == 128) \n    begin : wbm128\n    assign o_m_wb_rdat = i_m_wb_adr[3:2] == 2'd3 ? endian_x32(i_m_wb_rdat[127:96]) :\n                         i_m_wb_adr[3:2] == 2'd2 ? endian_x32(i_m_wb_rdat[ 95:64]) :\n                         i_m_wb_adr[3:2] == 2'd1 ? endian_x32(i_m_wb_rdat[ 63:32]) :\n                                                   endian_x32(i_m_wb_rdat[ 31: 0]) ;\n                                                  \n    assign o_m_wb_sel  = i_m_wb_adr[3:2] == 2'd3 ? {       endian_x4(i_m_wb_sel), 12'd0} :\n                         i_m_wb_adr[3:2] == 2'd2 ? { 4'd0, endian_x4(i_m_wb_sel),  8'd0} :\n                         i_m_wb_adr[3:2] == 2'd1 ? { 8'd0, endian_x4(i_m_wb_sel),  4'd0} :\n                                                   {12'd0, endian_x4(i_m_wb_sel)       } ;\n                                                  \n    assign o_m_wb_wdat = i_m_wb_adr[3:2] == 2'd3 ? {       endian_x32(i_m_wb_wdat), 96'd0} :\n                         i_m_wb_adr[3:2] == 2'd2 ? {32'd0, endian_x32(i_m_wb_wdat), 64'd0} :\n                         i_m_wb_adr[3:2] == 2'd1 ? {64'd0, endian_x32(i_m_wb_wdat), 32'd0} :\n                                                   {96'd0, endian_x32(i_m_wb_wdat)       } ;\n    end \nelse\n    begin : wbm32\n    assign o_m_wb_rdat = endian_x32(i_m_wb_rdat);\n    assign o_m_wb_sel  = endian_x4 (i_m_wb_sel);\n    assign o_m_wb_wdat = endian_x32(i_m_wb_wdat);\n    end\nendgenerate\n\nassign o_m_wb_ack = i_m_wb_ack;\nassign o_m_wb_err = i_m_wb_err;\nassign o_m_wb_adr = i_m_wb_adr;\nassign o_m_wb_we  = i_m_wb_we ;\nassign o_m_wb_cyc = i_m_wb_cyc;\nassign o_m_wb_stb = i_m_wb_stb;\n\n\n\n\n\ngenerate\nif (WB_DWIDTH == 128) \n    begin : wbs128\n    assign o_s_wb_wdat = i_s_wb_adr[3:2] == 2'd3 ? i_s_wb_wdat[127:96] :\n                         i_s_wb_adr[3:2] == 2'd2 ? i_s_wb_wdat[ 95:64] :\n                         i_s_wb_adr[3:2] == 2'd1 ? i_s_wb_wdat[ 63:32] :\n                                                   i_s_wb_wdat[ 31: 0] ;\n                                                  \n    assign o_s_wb_sel  = i_s_wb_adr[3:2] == 2'd3 ? i_s_wb_sel[15:12] :\n                         i_s_wb_adr[3:2] == 2'd2 ? i_s_wb_sel[11: 8] :\n                         i_s_wb_adr[3:2] == 2'd1 ? i_s_wb_sel[ 7: 4] :\n                                                   i_s_wb_sel[ 3: 0] ;\n                                                  \n    assign o_s_wb_rdat = i_s_wb_adr[3:2] == 2'd3 ? {       i_s_wb_rdat, 96'd0} :\n                         i_s_wb_adr[3:2] == 2'd2 ? {32'd0, i_s_wb_rdat, 64'd0} :\n                         i_s_wb_adr[3:2] == 2'd1 ? {64'd0, i_s_wb_rdat, 32'd0} :\n                                                   {96'd0, i_s_wb_rdat       } ;\n    end\nelse\n    begin : wbs32\n    assign o_s_wb_wdat = i_s_wb_wdat;\n    assign o_s_wb_sel  = i_s_wb_sel;\n    assign o_s_wb_rdat = i_s_wb_rdat;\n    end\nendgenerate\n\nassign o_s_wb_ack = i_s_wb_ack;\nassign o_s_wb_err = i_s_wb_err;\nassign o_s_wb_adr = i_s_wb_adr;\nassign o_s_wb_we  = i_s_wb_we ;\nassign o_s_wb_cyc = i_s_wb_cyc;\nassign o_s_wb_stb = i_s_wb_stb;\n\nendmodule\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: ethmac_wb\n\nModule specification: The `ethmac_wb` module functions as an interface component in an Ethernet MAC subsystem, linking the master and slave sections of a Wishbone bus. It supports configurable data widths of 32 or 128 bits. The module handles various input and output ports - `i_m_wb_*` inputs connect to the master side and include signals like address (`adr`), data (`wdat`), control (`cyc`, `stb`, `we`), and feedback (`ack`, `err`). Correspondingly, `o_m_wb_*` outputs interface back to the master side. Likewise, `i_s_wb_*` inputs and `o_s_wb_*` outputs connect to and from the slave side, respectively, transferring similar kinds of data and control signals. The module doesn\u2019t utilize explicit internal signals for internal storage or data manipulation; instead, it directly manipulates and routes these inputs to outputs through conditional checks and assignments. The Verilog code includes two main generate blocks: `wbm128` and `wbm32` for the master, and `wbs128` and `wbs32` for the slave interfaces, handling data width adaptation, endianness conversion, and signal alignment based on the `WB_DWIDTH` parameter. These generate blocks conditionally format outputs primarily concerning data width and endian corrections using helper functions from an included file `system_functions.vh`, illustrating a dynamic and reconfigurable design approach suitable for variable bus configurations in network applications."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: ethmac_wb\n\nExplanation: This module seems to be designed as part of an Ethernet MAC (Media Access Control) subsystem, interfacing with a Wishbone bus. It features parameterized data widths and manages read and write data transactions between a master and slave interface of the bus. The module handles data alignment and endianess adjustments depending on the parameterized data width (either 32 or 128 bits), facilitating compatible and flexible data communication across different subsystems through conditional instantiation, as seen in the `generate` blocks within the Verilog code. It additionally implements the direct passing of control signals such as acknowledge (`ack`), error (`err`), write enable (`we`), and others between its interfaces, ensuring reliable data transactions over the Wishbone bus."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \n**Input ports:**\n- `i_m_wb_adr`, `i_m_wb_sel`, `i_m_wb_we`, `i_m_wb_wdat`, `i_m_wb_cyc`, `i_m_wb_stb`, `i_m_wb_rdat`, `i_m_wb_ack`, `i_m_wb_err`\n- `i_s_wb_adr`, `i_s_wb_sel`, `i_s_wb_we`, `i_s_wb_wdat`, `i_s_wb_cyc`, `i_s_wb_stb`, `i_s_wb_rdat`, `i_s_wb_ack`, `i_s_wb_err`\n\n**Explanation:**\n- `i_m_wb_*` ports correspond to the master interface of the Wishbone bus. They include address (`adr`), select (`sel`), write enable (`we`), write data (`wdat`), cycle valid signal (`cyc`), strobe signal (`stb`), read data (`rdat`), acknowledge signal (`ack`), and error signal (`err`). These inputs manage data transfers and control signaling from the master side of the Wishbone bus.\n- `i_s_wb_*` ports correspond to the slave interface of the Wishbone bus with a similar set of signals that manage data transfers and control signaling from the slave side.\n\n**Output ports:**\n- `o_m_wb_rdat`, `o_m_wb_ack`, `o_m_wb_err`, `o_m_wb_adr`, `o_m_wb_sel`, `o_m_wb_we`, `o_m_wb_wdat`, `o_m_wb_cyc`, `o_m_wb_stb`\n- `o_s_wb_rdat`, `o_s_wb_ack`, `o_s_wb_err`, `o_s_wb_adr`, `o_s_wb_sel`, `o_s_wb_we`, `o_s_wb_wdat`, `o_s_wb_cyc`, `o_s_wb_stb`\n\n**Explanation:**\n- `o_m_wb_*` ports are the outputs directed towards the master interface of the Wishbone bus. They include read data (`rdat`), acknowledge signal (`ack`), error signal (`err`), address (`adr`), select (`sel`), write enable (`we`), write data (`wdat`), cycle valid signal (`cyc`), and strobe signal (`stb`). These outputs connect the internal operation of the module with the master side, facilitating output control and data response.\n- `o_s_wb_*` ports are the outputs directed towards the slave interface. These carry resolved control signals and data processed to suit the slave communication requirements on the bus."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: None explicitly defined within the provided code.\n\nExplanation: The module `ethmac_wb` relies entirely on direct connections and signal manipulations between its ports and does not explicitly declare or use additional internal signals within the given context. All data transformations and routing between input and output ports are handled directly through assignments and conditional checks without the storage or intermediate manipulation using internal signals as per the visible code. This straightforward approach is typical in interface-focused Verilog modules where simplicity and direct traceability of signal paths are crucial."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule ethmac_wb #(\nparameter WB_DWIDTH  = 32,\nparameter WB_SWIDTH  = 4\n)(\n\n\ninput       [31:0]          i_m_wb_adr,\ninput       [3:0]           i_m_wb_sel,\ninput                       i_m_wb_we,\noutput      [31:0]          o_m_wb_rdat,\ninput       [31:0]          i_m_wb_wdat,\ninput                       i_m_wb_cyc,\ninput                       i_m_wb_stb,\noutput                      o_m_wb_ack,\noutput                      o_m_wb_err,\n\n\noutput      [31:0]          o_m_wb_adr,\noutput      [WB_SWIDTH-1:0] o_m_wb_sel,\noutput                      o_m_wb_we,\ninput       [WB_DWIDTH-1:0] i_m_wb_rdat,\noutput      [WB_DWIDTH-1:0] o_m_wb_wdat,\noutput                      o_m_wb_cyc,\noutput                      o_m_wb_stb,\ninput                       i_m_wb_ack,\ninput                       i_m_wb_err,\n\n\ninput       [31:0]          i_s_wb_adr,\ninput       [WB_SWIDTH-1:0] i_s_wb_sel,\ninput                       i_s_wb_we,\noutput      [WB_DWIDTH-1:0] o_s_wb_rdat,\ninput       [WB_DWIDTH-1:0] i_s_wb_wdat,\ninput                       i_s_wb_cyc,\ninput                       i_s_wb_stb,\noutput                      o_s_wb_ack,\noutput                      o_s_wb_err,\n\n\noutput      [31:0]          o_s_wb_adr,\noutput      [3:0]           o_s_wb_sel,\noutput                      o_s_wb_we,\ninput       [31:0]          i_s_wb_rdat,\noutput      [31:0]          o_s_wb_wdat,\noutput                      o_s_wb_cyc,\noutput                      o_s_wb_stb,\ninput                       i_s_wb_ack,\ninput                       i_s_wb_err\n\n);\n\n`include \"system_functions.vh\"\n\n\n\n\n\ngenerate\nif (WB_DWIDTH == 128) \n    begin : wbm128\n    assign o_m_wb_rdat = i_m_wb_adr[3:2] == 2'd3 ? endian_x32(i_m_wb_rdat[127:96]) :\n                         i_m_wb_adr[3:2] == 2'd2 ? endian_x32(i_m_wb_rdat[ 95:64]) :\n                         i_m_wb_adr[3:2] == 2'd1 ? endian_x32(i_m_wb_rdat[ 63:32]) :\n                                                   endian_x32(i_m_wb_rdat[ 31: 0]) ;\n                                                  \n    assign o_m_wb_sel  = i_m_wb_adr[3:2] == 2'd3 ? {       endian_x4(i_m_wb_sel), 12'd0} :\n                         i_m_wb_adr[3:2] == 2'd2 ? { 4'd0, endian_x4(i_m_wb_sel),  8'd0} :\n                         i_m_wb_adr[3:2] == 2'd1 ? { 8'd0, endian_x4(i_m_wb_sel),  4'd0} :\n                                                   {12'd0, endian_x4(i_m_wb_sel)       } ;\n                                                  \n    assign o_m_wb_wdat = i_m_wb_adr[3:2] == 2'd3 ? {       endian_x32(i_m_wb_wdat), 96'd0} :\n                         i_m_wb_adr[3:2] == 2'd2 ? {32'd0, endian_x32(i_m_wb_wdat), 64'd0} :\n                         i_m_wb_adr[3:2] == 2'd1 ? {64'd0, endian_x32(i_m_wb_wdat), 32'd0} :\n                                                   {96'd0, endian_x32(i_m_wb_wdat)       } ;\n    end \nelse\n    begin : wbm32\n    assign o_m_wb_rdat = endian_x32(i_m_wb_rdat);\n    assign o_m_wb_sel  = endian_x4 (i_m_wb_sel);\n    assign o_m_wb_wdat = endian_x32(i_m_wb_wdat);\n    end\nendgenerate\n\nassign o_m_wb_ack = i_m_wb_ack;\nassign o_m_wb_err = i_m_wb_err;\nassign o_m_wb_adr = i_m_wb_adr;\nassign o_m_wb_we  = i_m_wb_we ;\nassign o_m_wb_cyc = i_m_wb_cyc;\nassign o_m_wb_stb = i_m_wb_stb;\n\n\n\n\n\ngenerate\nif (WB_DWIDTH == 128) \n    begin : wbs128\n    assign o_s_wb_wdat = i_s_wb_adr[3:2] == 2'd3 ? i_s_wb_wdat[127:96] :\n                         i_s_wb_adr[3:2] == 2'd2 ? i_s_wb_wdat[ 95:64] :\n                         i_s_wb_adr[3:2] == 2'd1 ? i_s_wb_wdat[ 63:32] :\n                                                   i_s_wb_wdat[ 31: 0] ;\n                                                  \n    assign o_s_wb_sel  = i_s_wb_adr[3:2] == 2'd3 ? i_s_wb_sel[15:12] :\n                         i_s_wb_adr[3:2] == 2'd2 ? i_s_wb_sel[11: 8] :\n                         i_s_wb_adr[3:2] == 2'd1 ? i_s_wb_sel[ 7: 4] :\n                                                   i_s_wb_sel[ 3: 0] ;\n                                                  \n    assign o_s_wb_rdat = i_s_wb_adr[3:2] == 2'd3 ? {       i_s_wb_rdat, 96'd0} :\n                         i_s_wb_adr[3:2] == 2'd2 ? {32'd0, i_s_wb_rdat, 64'd0} :\n                         i_s_wb_adr[3:2] == 2'd1 ? {64'd0, i_s_wb_rdat, 32'd0} :\n                                                   {96'd0, i_s_wb_rdat       } ;\n    end\nelse\n    begin : wbs32\n    assign o_s_wb_wdat = i_s_wb_wdat;\n    assign o_s_wb_sel  = i_s_wb_sel;\n    assign o_s_wb_rdat = i_s_wb_rdat;\n    end\nendgenerate\n\nassign o_s_wb_ack = i_s_wb_ack;\nassign o_s_wb_err = i_s_wb_err;\nassign o_s_wb_adr = i_s_wb_adr;\nassign o_s_wb_we  = i_s_wb_we ;\nassign o_s_wb_cyc = i_s_wb_cyc;\nassign o_s_wb_stb = i_s_wb_stb;\n\nendmodule\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: ethmac_wb\n\nModule specification: The `ethmac_wb` module functions as an interface component in an Ethernet MAC subsystem, linking the master and slave sections of a Wishbone bus. It supports configurable data widths of 32 or 128 bits. The module handles various input and output ports - `i_m_wb_*` inputs connect to the master side and include signals like address (`adr`), data (`wdat`), control (`cyc`, `stb`, `we`), and feedback (`ack`, `err`). Correspondingly, `o_m_wb_*` outputs interface back to the master side. Likewise, `i_s_wb_*` inputs and `o_s_wb_*` outputs connect to and from the slave side, respectively, transferring similar kinds of data and control signals. The module doesn\u2019t utilize explicit internal signals for internal storage or data manipulation; instead, it directly manipulates and routes these inputs to outputs through conditional checks and assignments. The Verilog code includes two main generate blocks: `wbm128` and `wbm32` for the master, and `wbs128` and `wbs32` for the slave interfaces, handling data width adaptation, endianness conversion, and signal alignment based on the `WB_DWIDTH` parameter. These generate blocks conditionally format outputs primarily concerning data width and endian corrections using helper functions from an included file `system_functions.vh`, illustrating a dynamic and reconfigurable design approach suitable for variable bus configurations in network applications."
                }
            ]
        }
    ]
}