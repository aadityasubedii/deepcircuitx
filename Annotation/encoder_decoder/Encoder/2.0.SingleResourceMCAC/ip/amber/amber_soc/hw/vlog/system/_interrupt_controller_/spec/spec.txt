Module name: interrupt_controller.   
Module specification: The `interrupt_controller` module is designed to manage both normal and fast interrupt requests (IRQ and FIRQ) for a system, handling inputs from devices such as UARTs, an Ethernet MAC, and timers. Operating with a Wishbone bus interface, it uses a 32-bit wide data path (`WB_DWIDTH`) and supports various selection widths (`WB_SWIDTH`). Key input ports include a clock signal (`i_clk`), Wishbone signals such as address (`i_wb_adr`), select (`i_wb_sel`), write enable (`i_wb_we`), data input (`i_wb_dat`), cycle (`i_wb_cyc`), and strobe (`i_wb_stb`), in addition to specific device interrupt signals (`i_uart0_int`, `i_uart1_int`, etc.). Output ports consist of Wishbone data output (`o_wb_dat`), acknowledge (`o_wb_ack`), error signal (`o_wb_err`), and the IRQ/FIRQ outputs (`o_irq`, `o_firq`). Internal registers like `irq0_enable_reg` and `firq0_enable_reg` hold enable states for interrupts, and signals such as `wb_start_write` manage the timing of data operations on the Wishbone bus. The code structure includes initial settings, combinatorial logic for managing read/write operations, and generate blocks for data width accommodation. It also integrates sections for processing interrupt vector masks and enabling conditions, alongside debugging provisions enclosed in conditional compilation blocks for tracing and diagnostic outputs. This module underpins the robust handling and configurability of interrupt-driven tasks within digital systems.