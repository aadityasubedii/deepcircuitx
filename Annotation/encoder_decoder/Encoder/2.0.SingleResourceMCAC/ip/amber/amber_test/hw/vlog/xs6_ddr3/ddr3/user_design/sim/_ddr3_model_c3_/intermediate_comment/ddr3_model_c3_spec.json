{
    "spec": "Module name: ddr3_model_c3. Module specification: This module simulates a DDR3 SDRAM memory device, implementing features such as initialization sequence, mode register settings, refresh operations, power-down modes, and various timing checks. It has input ports for control signals (rst_n, ck, ck_n, cke, cs_n, ras_n, cas_n, we_n), address and bank selection (ba, addr), data mask/termination (dm_tdqs), and data I/O (dq, dqs, dqs_n), with an output port for termination (tdqs_n). The module uses internal signals to track timing parameters, manage operation modes, and control data transfer. Key internal components include clock timing management, command decoding and execution, data read/write operations, and extensive timing checks to ensure compliance with DDR3 SDRAM specifications.",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: ddr3_model_c3.\n\nExplanation: This module represents a DDR3 SDRAM memory model. It simulates the behavior and timing of a DDR3 memory device, including command processing, data read/write operations, and various timing checks. The module implements features such as initialization sequence, mode register settings, refresh operations, and power-down modes. It also performs extensive timing checks to ensure compliance with DDR3 SDRAM specifications, including setup and hold times, clock jitter, and various other timing parameters. The model supports multiple banks, burst operations, and ODT (On-Die Termination) functionality."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nrst_n, ck, ck_n, cke, cs_n, ras_n, cas_n, we_n, ba, addr, odt, dm_tdqs (inout), dq (inout), dqs (inout), dqs_n (inout).\n\nExplanation:\n- rst_n: Active-low reset signal\n- ck, ck_n: Differential clock inputs\n- cke: Clock enable\n- cs_n, ras_n, cas_n, we_n: Command inputs (chip select, row address strobe, column address strobe, write enable)\n- ba: Bank address input\n- addr: Address input\n- odt: On-die termination control\n- dm_tdqs: Data mask (input) / termination data strobe (inout)\n- dq: Data bus (inout)\n- dqs, dqs_n: Data strobe (inout)\n\nOutput ports:\ntdqs_n (output)\n\nExplanation:\n- tdqs_n: Termination data strobe (negative)\n\nThe module uses these ports to simulate DDR3 SDRAM behavior, including command decoding, data transfer, and timing checks. Inout ports (dm_tdqs, dq, dqs, dqs_n) allow bidirectional data transfer, while the single output port (tdqs_n) is used for termination purposes."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\n1. tck_avg\n2. tck_sample\n3. tch_sample\n4. tcl_sample\n5. tck_i\n6. tch_i\n7. tcl_i\n8. tch_avg\n9. tcl_avg\n10. tm_ck_pos\n11. tm_ck_neg\n12. tjit_per_rtime\n13. tjit_cc_time\n14. terr_nper_rtime\n15. tjit_ch_rtime\n16. duty_cycle\n17. out_delay\n18. dqsck\n19. dqsck_min\n20. dqsck_max\n21. dqsq_min\n22. dqsq_max\n23. seed\n24. mode_reg\n25. burst_order\n26. burst_length\n27. blotf\n28. truebl4\n29. cas_latency\n30. dll_reset\n31. dll_locked\n32. write_recovery\n33. low_power\n34. dll_en\n35. odt_rtt_nom\n36. odt_rtt_wr\n37. odt_en\n38. dyn_odt_en\n39. al\n40. additive_latency\n41. write_levelization\n42. duty_cycle_corrector\n43. tdqs_en\n44. out_en\n45. pasr\n46. cas_write_latency\n47. asr\n48. srt\n49. mpr_select\n50. mpr_en\n51. odts_readout\n52. read_latency\n53. write_latency\n\nExplanation:\n1. tck_avg: Average clock period\n2-4. tck_sample, tch_sample, tcl_sample: Arrays to store clock timing samples\n5-7. tck_i, tch_i, tcl_i: Instantaneous clock timing values\n8-9. tch_avg, tcl_avg: Average high and low clock times\n10-11. tm_ck_pos, tm_ck_neg: Timestamps for positive and negative clock edges\n12-15. tjit_per_rtime, tjit_cc_time, terr_nper_rtime, tjit_ch_rtime: Jitter and error timing values\n16. duty_cycle: Clock duty cycle\n17. out_delay: Output delay value\n18-22. dqsck, dqsck_min, dqsck_max, dqsq_min, dqsq_max: DQS to CK timing parameters\n23. seed: Random seed for timing variations\n24. mode_reg: Mode register settings\n25-27. burst_order, burst_length, blotf: Burst-related parameters\n28. truebl4: True BL4 mode flag\n29-32. cas_latency, dll_reset, dll_locked, write_recovery: Timing and control parameters\n33-34. low_power, dll_en: Power and DLL control flags\n35-37. odt_rtt_nom, odt_rtt_wr, odt_en: On-Die Termination parameters\n38. dyn_odt_en: Dynamic ODT enable flag\n39-40. al, additive_latency: Additive latency parameters\n41-42. write_levelization, duty_cycle_corrector: Write leveling and duty cycle correction flags\n43-44. tdqs_en, out_en: Output enable flags\n45. pasr: Partial Array Self-Refresh parameter\n46. cas_write_latency: CAS Write Latency\n47-48. asr, srt: Auto Self-Refresh and Self-Refresh Temperature flags\n49-51. mpr_select, mpr_en, odts_readout: Multi-Purpose Register parameters\n52-53. read_latency, write_latency: Read and write latency values\n\nThese internal signals are used to control various aspects of the DDR3 SDRAM operation, including timing, mode settings, and performance parameters."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps / 1ps\n\n\n\n\nmodule ddr3_model_c3(\n    rst_n,\n    ck,\n    ck_n,\n    cke,\n    cs_n,\n    ras_n,\n    cas_n,\n    we_n,\n    dm_tdqs,\n    ba,\n    addr,\n    dq,\n    dqs,\n    dqs_n,\n    tdqs_n,\n    odt\n);\n\n    `include \"ddr3_model_parameters_c3.vh\"\n\n    parameter check_strict_mrbits = 1;\n    parameter check_strict_timing = 1;\n    parameter feature_pasr = 1;\n    parameter feature_truebl4 = 0;\n   \n    \n    `define DQ_PER_DQS DQ_BITS/DQS_BITS\n    `define BANKS      (1<<BA_BITS)\n    `define MAX_BITS   (BA_BITS+ROW_BITS+COL_BITS-BL_BITS)\n    `define MAX_SIZE   (1<<(BA_BITS+ROW_BITS+COL_BITS-BL_BITS))\n    `define MEM_SIZE   (1<<MEM_BITS)\n    `define MAX_PIPE   4*CL_MAX\n\n    \n    input   rst_n;\n    input   ck;\n    input   ck_n;\n    input   cke;\n    input   cs_n;\n    input   ras_n;\n    input   cas_n;\n    input   we_n;\n    inout   [DM_BITS-1:0]   dm_tdqs;\n    input   [BA_BITS-1:0]   ba;\n    input   [ADDR_BITS-1:0] addr;\n    inout   [DQ_BITS-1:0]   dq;\n    inout   [DQS_BITS-1:0]  dqs;\n    inout   [DQS_BITS-1:0]  dqs_n;\n    output  [DQS_BITS-1:0]  tdqs_n;\n    input   odt;\n\n    \n    real    tck_avg;\n    time    tck_sample [TDLLK-1:0];\n    time    tch_sample [TDLLK-1:0];\n    time    tcl_sample [TDLLK-1:0];\n    time    tck_i;\n    time    tch_i;\n    time    tcl_i;\n    real    tch_avg;\n    real    tcl_avg;\n    time    tm_ck_pos;\n    time    tm_ck_neg;\n    real    tjit_per_rtime;\n    integer tjit_cc_time;\n    real    terr_nper_rtime;\n    \n    real    tjit_ch_rtime;\n    real    duty_cycle;\n\n    \n    real    out_delay;\n    integer dqsck [DQS_BITS-1:0];\n    integer dqsck_min;\n    integer dqsck_max;\n    integer dqsq_min;\n    integer dqsq_max;\n    integer seed;\n\n    \n    reg     [ADDR_BITS-1:0] mode_reg [`BANKS-1:0];\n    reg     burst_order;\n    reg     [BL_BITS:0] burst_length;\n    reg     blotf;\n    reg     truebl4;\n    integer cas_latency;\n    reg     dll_reset;\n    reg     dll_locked;\n    integer write_recovery;\n    reg     low_power;\n    reg     dll_en;\n    reg     [2:0] odt_rtt_nom;\n    reg     [1:0] odt_rtt_wr;\n    reg     odt_en;\n    reg     dyn_odt_en;\n    reg     [1:0] al;\n    integer additive_latency;\n    reg     write_levelization;\n    reg     duty_cycle_corrector;\n    reg     tdqs_en;\n    reg     out_en;\n    reg     [2:0] pasr;\n    integer cas_write_latency;\n    reg     asr; \n    reg     srt; \n    reg     [1:0] mpr_select;\n    reg     mpr_en;\n    reg     odts_readout;\n    integer read_latency;\n    integer write_latency;\n\n    \n    parameter     \n        LOAD_MODE = 4'b0000,\n        REFRESH   = 4'b0001,\n        PRECHARGE = 4'b0010,\n        ACTIVATE  = 4'b0011,\n        WRITE     = 4'b0100,\n        READ      = 4'b0101,\n        ZQ        = 4'b0110,\n        NOP       = 4'b0111,\n        \n        PWR_DOWN  = 4'b1000,\n        SELF_REF  = 4'b1001\n    ;\n\n    reg [8*9-1:0] cmd_string [9:0];\n    initial begin\n        cmd_string[LOAD_MODE] = \"Load Mode\";\n        cmd_string[REFRESH  ] = \"Refresh  \";\n        cmd_string[PRECHARGE] = \"Precharge\";\n        cmd_string[ACTIVATE ] = \"Activate \";\n        cmd_string[WRITE    ] = \"Write    \";\n        cmd_string[READ     ] = \"Read     \";\n        cmd_string[ZQ       ] = \"ZQ       \";\n        cmd_string[NOP      ] = \"No Op    \";\n        cmd_string[PWR_DOWN ] = \"Pwr Down \";\n        cmd_string[SELF_REF ] = \"Self Ref \";\n    end\n\n    \n    reg     [`BANKS-1:0] active_bank;\n    reg     [`BANKS-1:0] auto_precharge_bank;\n    reg     [`BANKS-1:0] write_precharge_bank;\n    reg     [`BANKS-1:0] read_precharge_bank;\n    reg     [ROW_BITS-1:0] active_row [`BANKS-1:0];\n    reg     in_power_down;\n    reg     in_self_refresh;\n    reg     [3:0] init_mode_reg;\n    reg     init_dll_reset;\n    reg     init_done;\n    integer init_step;\n    reg     zq_set;\n    reg     er_trfc_max;\n    reg     odt_state;\n    reg     odt_state_dly;\n    reg     dyn_odt_state;\n    reg     dyn_odt_state_dly;\n    reg     prev_odt;\n    wire    [7:0] calibration_pattern = 8'b10101010; \n    wire    [7:0] temp_sensor = 8'h01; \n    reg     [1:0] mr_chk;\n    reg     rd_bc;\n    integer banki;\n\n\n\n    \n    integer ref_cntr;\n    integer odt_cntr;\n    integer ck_cntr;\n    integer ck_txpr;\n    integer ck_load_mode;\n    integer ck_refresh;\n    integer ck_precharge;\n    integer ck_activate;\n    integer ck_write;\n    integer ck_read;\n    integer ck_zqinit;\n    integer ck_zqoper;\n    integer ck_zqcs;\n    integer ck_power_down;\n    integer ck_slow_exit_pd;\n    integer ck_self_refresh;\n    integer ck_freq_change;\n    integer ck_odt;\n    integer ck_odth8;\n    integer ck_dll_reset;\n    integer ck_cke_cmd;\n    integer ck_bank_write     [`BANKS-1:0];\n    integer ck_bank_read      [`BANKS-1:0];\n    integer ck_group_activate [1:0];\n    integer ck_group_write    [1:0];\n    integer ck_group_read     [1:0];\n    time    tm_txpr;\n    time    tm_load_mode;\n    time    tm_refresh;\n    time    tm_precharge;\n    time    tm_activate;\n    time    tm_write_end;\n    time    tm_power_down;\n    time    tm_slow_exit_pd;\n    time    tm_self_refresh;\n    time    tm_freq_change;\n    time    tm_cke_cmd;\n    time    tm_ttsinit;\n    time    tm_bank_precharge [`BANKS-1:0];\n    time    tm_bank_activate  [`BANKS-1:0];\n    time    tm_bank_write_end [`BANKS-1:0];\n    time    tm_bank_read_end  [`BANKS-1:0];\n    time    tm_group_activate  [1:0];\n    time    tm_group_write_end [1:0];\n\n    \n    reg     [`MAX_PIPE:0]  al_pipeline;\n    reg     [`MAX_PIPE:0]  wr_pipeline;\n    reg     [`MAX_PIPE:0]  rd_pipeline;\n    reg     [`MAX_PIPE:0]  odt_pipeline;\n    reg     [`MAX_PIPE:0]  dyn_odt_pipeline;\n    reg     [BL_BITS:0]    bl_pipeline  [`MAX_PIPE:0];\n    reg     [BA_BITS-1:0]  ba_pipeline  [`MAX_PIPE:0];\n    reg     [ROW_BITS-1:0] row_pipeline [`MAX_PIPE:0];\n    reg     [COL_BITS-1:0] col_pipeline [`MAX_PIPE:0];\n    reg     prev_cke;\n\n    \n    reg     [BL_MAX*DQ_BITS-1:0] memory_data;\n    reg     [BL_MAX*DQ_BITS-1:0] bit_mask;\n    reg     [BL_BITS-1:0]        burst_position;\n    reg     [BL_BITS:0]          burst_cntr;\n    reg     [DQ_BITS-1:0]        dq_temp;\n    reg     [31:0] check_write_postamble;\n    reg     [31:0] check_write_preamble;\n    reg     [31:0] check_write_dqs_high;\n    reg     [31:0] check_write_dqs_low;\n    reg     [15:0] check_dm_tdipw;\n    reg     [63:0] check_dq_tdipw;\n\n    \n    time    tm_rst_n;\n    time    tm_cke;\n    time    tm_odt;\n    time    tm_tdqss;\n    time    tm_dm       [15:0];\n    time    tm_dqs      [15:0];\n    time    tm_dqs_pos  [31:0];\n    time    tm_dqss_pos [31:0];\n    time    tm_dqs_neg  [31:0];\n    time    tm_dq       [63:0];\n    time    tm_cmd_addr [22:0];\n    reg [8*7-1:0] cmd_addr_string [22:0];\n    initial begin\n        cmd_addr_string[ 0] = \"CS_N   \";\n        cmd_addr_string[ 1] = \"RAS_N  \";\n        cmd_addr_string[ 2] = \"CAS_N  \";\n        cmd_addr_string[ 3] = \"WE_N   \";\n        cmd_addr_string[ 4] = \"BA 0   \";\n        cmd_addr_string[ 5] = \"BA 1   \";\n        cmd_addr_string[ 6] = \"BA 2   \";\n        cmd_addr_string[ 7] = \"ADDR  0\";\n        cmd_addr_string[ 8] = \"ADDR  1\";\n        cmd_addr_string[ 9] = \"ADDR  2\";\n        cmd_addr_string[10] = \"ADDR  3\";\n        cmd_addr_string[11] = \"ADDR  4\";\n        cmd_addr_string[12] = \"ADDR  5\";\n        cmd_addr_string[13] = \"ADDR  6\";\n        cmd_addr_string[14] = \"ADDR  7\";\n        cmd_addr_string[15] = \"ADDR  8\";\n        cmd_addr_string[16] = \"ADDR  9\";\n        cmd_addr_string[17] = \"ADDR 10\";\n        cmd_addr_string[18] = \"ADDR 11\";\n        cmd_addr_string[19] = \"ADDR 12\";\n        cmd_addr_string[20] = \"ADDR 13\";\n        cmd_addr_string[21] = \"ADDR 14\";\n        cmd_addr_string[22] = \"ADDR 15\";\n    end\n\n    reg [8*5-1:0] dqs_string [1:0];\n    initial begin\n        dqs_string[0] = \"DQS  \";\n        dqs_string[1] = \"DQS_N\";\n    end\n\n    \n`ifdef MAX_MEM\n    parameter RFF_BITS = DQ_BITS*BL_MAX;\n     \n    parameter RFF_CHUNK = 8 * (RFF_BITS/32 + (RFF_BITS%32 ? 1 : 0));\n    reg [1024:1] tmp_model_dir;\n    integer memfd[`BANKS-1:0];\n\n    initial\n    begin : file_io_open\n        integer bank;\n\n        if (!$value$plusargs(\"model_data+%s\", tmp_model_dir))\n        begin\n            tmp_model_dir = \"/tmp\";\n            $display(\n                \"%m: at time %t WARNING: no +model_data option specified, using /tmp.\",\n                $time\n            );\n        end\n\n        for (bank = 0; bank < `BANKS; bank = bank + 1)\n            memfd[bank] = open_bank_file(bank);\n    end\n`else\n    reg     [BL_MAX*DQ_BITS-1:0] memory  [0:`MEM_SIZE-1];\n    reg     [`MAX_BITS-1:0]      address [0:`MEM_SIZE-1];\n    reg     [MEM_BITS:0]         memory_index;\n    reg     [MEM_BITS:0]         memory_used = 0;\n`endif\n\n    \n    reg            rst_n_in;\n    reg            ck_in;\n    reg            ck_n_in;\n    reg            cke_in;\n    reg            cs_n_in;\n    reg            ras_n_in;\n    reg            cas_n_in;\n    reg            we_n_in;\n    reg     [15:0] dm_in;\n    reg     [2:0]  ba_in;\n    reg     [15:0] addr_in;\n    reg     [63:0] dq_in;\n    reg     [31:0] dqs_in;\n    reg            odt_in;\n\n    reg     [15:0] dm_in_pos;\n    reg     [15:0] dm_in_neg;\n    reg     [63:0] dq_in_pos;\n    reg     [63:0] dq_in_neg;\n    reg            dq_in_valid;\n    reg            dqs_in_valid;\n    integer        wdqs_cntr;\n    integer        wdq_cntr;\n    integer        wdqs_pos_cntr [31:0];\n    reg            b2b_write;\n    reg [BL_BITS:0] wr_burst_length;\n    reg     [31:0] prev_dqs_in;\n    reg            diff_ck;\n\n    always @(rst_n  ) rst_n_in   <= #BUS_DELAY rst_n;\n    always @(ck     ) ck_in      <= #BUS_DELAY ck;\n    always @(ck_n   ) ck_n_in    <= #BUS_DELAY ck_n;\n    always @(cke    ) cke_in     <= #BUS_DELAY cke;\n    always @(cs_n   ) cs_n_in    <= #BUS_DELAY cs_n;\n    always @(ras_n  ) ras_n_in   <= #BUS_DELAY ras_n;\n    always @(cas_n  ) cas_n_in   <= #BUS_DELAY cas_n;\n    always @(we_n   ) we_n_in    <= #BUS_DELAY we_n;\n    always @(dm_tdqs) dm_in      <= #BUS_DELAY dm_tdqs;\n    always @(ba     ) ba_in      <= #BUS_DELAY ba;\n    always @(addr   ) addr_in    <= #BUS_DELAY addr;\n    always @(dq     ) dq_in      <= #BUS_DELAY dq;\n    always @(dqs or dqs_n) dqs_in <= #BUS_DELAY (dqs_n<<16) | dqs;\n    always @(odt    ) odt_in     <= #BUS_DELAY odt;\n    \n    always @(posedge ck_in) diff_ck <= ck_in;\n    always @(posedge ck_n_in) diff_ck <= ~ck_n_in;\n    \n    wire    [15:0] dqs_even = dqs_in[15:0];\n    wire    [15:0] dqs_odd  = dqs_in[31:16];\n    wire    [3:0]  cmd_n_in = !cs_n_in ? {ras_n_in, cas_n_in, we_n_in} : NOP;  \n\n    \n    reg                    dqs_out_en;\n    reg     [DQS_BITS-1:0] dqs_out_en_dly;\n    reg                    dqs_out;\n    reg     [DQS_BITS-1:0] dqs_out_dly;\n    reg                    dq_out_en;\n    reg     [DQ_BITS-1:0]  dq_out_en_dly;\n    reg     [DQ_BITS-1:0]  dq_out;\n    reg     [DQ_BITS-1:0]  dq_out_dly;\n    integer                rdqsen_cntr;\n    integer                rdqs_cntr;\n    integer                rdqen_cntr;\n    integer                rdq_cntr;\n\n    bufif1 buf_dqs    [DQS_BITS-1:0] (dqs,     dqs_out_dly,  dqs_out_en_dly & {DQS_BITS{out_en}});\n    bufif1 buf_dqs_n  [DQS_BITS-1:0] (dqs_n,   ~dqs_out_dly, dqs_out_en_dly & {DQS_BITS{out_en}});\n    bufif1 buf_dq     [DQ_BITS-1:0]  (dq,      dq_out_dly,   dq_out_en_dly  & {DQ_BITS {out_en}});\n    assign tdqs_n = {DQS_BITS{1'bz}};\n\n    initial begin\n        if (BL_MAX < 2) \n            $display(\"%m ERROR: BL_MAX parameter must be >= 2.  \\nBL_MAX = %d\", BL_MAX);\n        if ((1<<BO_BITS) > BL_MAX) \n            $display(\"%m ERROR: 2^BO_BITS cannot be greater than BL_MAX parameter.\");\n\n        $timeformat (-12, 1, \" ps\", 1);\n        seed = RANDOM_SEED;\n\n        ck_cntr = 0;\n    end\n\n    function integer get_rtt_wr;\n    input [1:0] rtt;\n    begin\n        get_rtt_wr = RZQ/{rtt[0], rtt[1], 1'b0};\n    end\n    endfunction\n\n    function integer get_rtt_nom;\n    input [2:0] rtt;\n    begin\n        case (rtt)\n            1: get_rtt_nom = RZQ/4;\n            2: get_rtt_nom = RZQ/2;\n            3: get_rtt_nom = RZQ/6;\n            4: get_rtt_nom = RZQ/12;\n            5: get_rtt_nom = RZQ/8;\n            default : get_rtt_nom = 0;\n        endcase\n    end\n    endfunction\n\n    \n    function real abs_value;\n    input arg;\n    real arg;\n    begin\n        if (arg < 0.0)\n            abs_value = -1.0 * arg;\n        else\n            abs_value = arg;\n    end\n    endfunction\n\n    function integer ceil;\n        input number;\n        real number;\n\n        \n        \n        \n        if (number > $rtoi(number))\n            ceil = $rtoi(number) + 1;\n        else\n            ceil = number;\n    endfunction\n\n    function integer floor;\n        input number;\n        real number;\n\n        \n        \n        \n        if (number < $rtoi(number))\n            floor = $rtoi(number) - 1;\n        else\n            floor = number;\n    endfunction\n\n`ifdef MAX_MEM\n\n    function integer open_bank_file( input integer bank );\n        integer fd;\n        reg [2048:1] filename;\n        begin \n            $sformat( filename, \"%0s/%m.%0d\", tmp_model_dir, bank );\n\n            fd = $fopen(filename, \"w+\");\n            if (fd == 0)\n            begin\n                $display(\"%m: at time %0t ERROR: failed to open %0s.\", $time, filename);\n                $finish;\n            end\n            else\n            begin\n                if (DEBUG) $display(\"%m: at time %0t INFO: opening %0s.\", $time, filename);\n                open_bank_file = fd;\n            end\n\n        end\n    endfunction\n\n    function [RFF_BITS:1] read_from_file( \n        input integer fd, \n        input integer index \n    );\n        integer code;\n        integer offset;\n        reg [1024:1] msg;\n        reg [RFF_BITS:1] read_value;\n    \n        begin\n            offset = index * RFF_CHUNK;\n            code = $fseek( fd, offset, 0 );\n            \n            if (code != 0)\n            begin\n                $display(\"%m: at time %t ERROR: fseek to %d failed\", $time, offset);\n                $finish;\n            end\n        \n            code = $fscanf(fd, \"%z\", read_value);\n            \n            if (code != 1)\n            begin\n                if ($ferror(fd,msg) != 0)\n                begin\n                    $display(\"%m: at time %t ERROR: fscanf failed at %d\", $time, index);\n                    $display(msg);\n                    $finish;\n                end\n                else\n                    read_value = 'hx;\n            end\n    \n            \n\n\n\n            if (read_value[1] === 1'bz)\n                \n                read_value[1] = 1'b0;\n            else if (read_value[1] === 1'b0)\n                \n                read_value = 'hx;\n\n            read_from_file = read_value;\n        end\n    endfunction\n    \n    task write_to_file( \n        input integer fd, \n        input integer index, \n        input [RFF_BITS:1] data \n    );\n        integer code;\n        integer offset;\n    \n        begin\n            offset = index * RFF_CHUNK;\n            code = $fseek( fd, offset, 0 );\n            if (code != 0)\n            begin\n                $display(\"%m: at time %t ERROR: fseek to %d failed\", $time, offset);\n                $finish;\n            end\n        \n            \n            if (data[1] === 1'bz)\n                data[1] = 1'bx;\n            else if (data[1] === 1'b0)\n                data[1] = 1'bz;\n\n            $fwrite( fd, \"%z\", data );\n        end\n    endtask\n`else\n    function get_index;\n        input [`MAX_BITS-1:0] addr;\n        begin : index\n            get_index = 0;\n            for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                if (address[memory_index] == addr) begin\n                    get_index = 1;\n                    disable index;\n                end\n            end\n        end\n    endfunction\n`endif\n\n    task memory_write;\n        input  [BA_BITS-1:0]  bank;\n        input  [ROW_BITS-1:0] row;\n        input  [COL_BITS-1:0] col;\n        input  [BL_MAX*DQ_BITS-1:0] data;\n        reg    [`MAX_BITS-1:0] addr;\n        begin\n`ifdef MAX_MEM\n            addr = {row, col}/BL_MAX;\n            write_to_file( memfd[bank], addr, data );\n`else\n            \n            addr = {bank, row, col}/BL_MAX;\n            if (get_index(addr)) begin\n                address[memory_index] = addr;\n                memory[memory_index] = data;\n            end else if (memory_used == `MEM_SIZE) begin\n                $display (\"%m: at time %t ERROR: Memory overflow.  Write to Address %h with Data %h will be lost.\\nYou must increase the MEM_BITS parameter or define MAX_MEM.\", $time, addr, data);\n                if (STOP_ON_ERROR) $stop(0);\n            end else begin\n                address[memory_used] = addr;\n                memory[memory_used] = data;\n                memory_used = memory_used + 1;\n            end\n`endif\n        end\n    endtask\n\n    task memory_read;\n        input  [BA_BITS-1:0]  bank;\n        input  [ROW_BITS-1:0] row;\n        input  [COL_BITS-1:0] col;\n        output [BL_MAX*DQ_BITS-1:0] data;\n        reg    [`MAX_BITS-1:0] addr;\n        begin\n`ifdef MAX_MEM\n            addr = {row, col}/BL_MAX;\n            data = read_from_file( memfd[bank], addr );\n`else\n            \n            addr = {bank, row, col}/BL_MAX;\n            if (get_index(addr)) begin\n                data = memory[memory_index];\n            end else begin\n                data = {BL_MAX*DQ_BITS{1'bx}};\n            end\n`endif\n        end\n    endtask\n\n    task set_latency;\n        begin\n            if (al == 0) begin\n                additive_latency = 0;\n            end else begin\n                additive_latency = cas_latency - al;\n            end\n            read_latency = cas_latency + additive_latency;\n            write_latency = cas_write_latency + additive_latency;\n        end\n    endtask\n\n    \n    task erase_banks;\n        input  [`BANKS-1:0] banks; \n        reg [BA_BITS-1:0] ba;\n        reg [`MAX_BITS-1:0] i;\n        integer bank;\n\n        begin\n\n`ifdef MAX_MEM\n        for (bank = 0; bank < `BANKS; bank = bank + 1)\n            if (banks[bank] === 1'b1) begin\n\t        $fclose(memfd[bank]);\n                memfd[bank] = open_bank_file(bank);\n\t    end\n`else\n        memory_index = 0;\n        i = 0;\n        \n        for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n            ba = (address[memory_index]>>(ROW_BITS+COL_BITS-BL_BITS));\n            if (!banks[ba]) begin \n                address[i] = address[memory_index];\n                memory[i] = memory[memory_index];\n                i = i + 1;\n            end\n        end\n        \n        for (memory_index=i; memory_index<memory_used; memory_index=memory_index+1) begin\n            address[memory_index] = 'bx;\n            memory[memory_index] = {8*DQ_BITS{1'bx}};\n        end\n        memory_used = i;\n`endif\n        end\n    endtask\n\n    \n    \n    task initialize;\n        input [ADDR_BITS-1:0] mode_reg0;\n        input [ADDR_BITS-1:0] mode_reg1;\n        input [ADDR_BITS-1:0] mode_reg2;\n        input [ADDR_BITS-1:0] mode_reg3;\n        begin\n            if (DEBUG) $display (\"%m: at time %t INFO: Performing Initialization Sequence\", $time);\n            cmd_task(1,       NOP, 'bx, 'bx);\n            cmd_task(1,        ZQ, 'bx, 'h400); \n            cmd_task(1, LOAD_MODE, 3, mode_reg3);\n            cmd_task(1, LOAD_MODE, 2, mode_reg2);\n            cmd_task(1, LOAD_MODE, 1, mode_reg1);\n            cmd_task(1, LOAD_MODE, 0, mode_reg0 | 'h100); \n            cmd_task(0,       NOP, 'bx, 'bx);\n        end\n    endtask\n    \n    task reset_task;\n        integer i;\n        begin\n            \n            dq_in_valid         = 0;\n            dqs_in_valid       <= 0;\n            wdqs_cntr           = 0;\n            wdq_cntr            = 0;\n            for (i=0; i<31; i=i+1) begin\n                wdqs_pos_cntr[i]    <= 0;\n            end\n            b2b_write           <= 0;\n            \n            out_en              = 0;\n            dq_out_en           = 0;\n            rdq_cntr            = 0;\n            dqs_out_en          = 0;\n            rdqs_cntr           = 0;\n            \n            odt_en              = 0;\n            dyn_odt_en          = 0;\n            odt_state           = 0;\n            dyn_odt_state       = 0;\n            \n            active_bank         = 0;\n            auto_precharge_bank = 0;\n            read_precharge_bank  = 0;\n\t        write_precharge_bank = 0;\n            \n\n            init_done            = 0;\n\t\t    mpr_en              = 0;\n            init_step           = 0;\n            init_mode_reg       = 0;\n            init_dll_reset      = 0;\n            zq_set              = 0;\n            \n            dll_en              = 0;\n            dll_reset           = 0;\n            dll_locked          = 0;\n            \n            prev_cke            = 1'bx;\n            in_power_down       = 0;\n            in_self_refresh     = 0;\n            \n            al_pipeline         = 0;\n            wr_pipeline         = 0;\n            rd_pipeline         = 0;\n            odt_pipeline        = 0;\n            dyn_odt_pipeline    = 0;\n        end\n    endtask\n\n    parameter SAME_BANK  = 2'd0; \n    parameter DIFF_BANK  = 2'd1; \n    parameter DIFF_GROUP = 2'd2; \n\n    task chk_err;\n        input [1:0] relationship;\n        input [BA_BITS-1:0] bank;\n        input [3:0] fromcmd;\n        input [3:0] cmd;\n        reg err;\n    begin\n\n        casex ({truebl4, relationship, fromcmd, cmd})\n            \n            {1'bx, DIFF_BANK , LOAD_MODE, LOAD_MODE} : begin if (ck_cntr - ck_load_mode < TMRD)                                                                                $display (\"%m: at time %t ERROR:  tMRD violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , LOAD_MODE, READ     } : begin if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))                                         $display (\"%m: at time %t ERROR:  tMOD violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , LOAD_MODE, REFRESH  } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, PRECHARGE} ,\n            {1'bx, DIFF_BANK , LOAD_MODE, ACTIVATE } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, ZQ       } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, PWR_DOWN } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, SELF_REF } : begin if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))                                         $display (\"%m: at time %t ERROR:  tMOD violation during %s\", $time, cmd_string[cmd]);                         end\n\n            \n            {1'bx, DIFF_BANK , REFRESH  , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , REFRESH  , REFRESH  } ,\n            {1'bx, DIFF_BANK , REFRESH  , PRECHARGE} ,\n            {1'bx, DIFF_BANK , REFRESH  , ACTIVATE } ,\n            {1'bx, DIFF_BANK , REFRESH  , ZQ       } ,\n            {1'bx, DIFF_BANK , REFRESH  , SELF_REF } : begin if ($time - tm_refresh < TRFC_MIN)                                                                                $display (\"%m: at time %t ERROR:  tRFC violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , REFRESH  , PWR_DOWN } : begin if (ck_cntr - ck_refresh < TREFPDEN)                                                                              $display (\"%m: at time %t ERROR:  tREFPDEN violation during %s\", $time, cmd_string[cmd]);                     end\n\n            \n            {1'bx, SAME_BANK , PRECHARGE, ACTIVATE } : begin if ($time - tm_bank_precharge[bank] < TRP)                                                                        $display (\"%m: at time %t ERROR:   tRP violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end \n            {1'bx, DIFF_BANK , PRECHARGE, LOAD_MODE} ,\n            {1'bx, DIFF_BANK , PRECHARGE, REFRESH  } ,\n            {1'bx, DIFF_BANK , PRECHARGE, ZQ       } ,\n            {1'bx, DIFF_BANK , PRECHARGE, SELF_REF } : begin if ($time - tm_precharge < TRP)                                                                                   $display (\"%m: at time %t ERROR:   tRP violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , PRECHARGE, PWR_DOWN } : ; \n\n            \n            {1'bx, SAME_BANK , ACTIVATE , PRECHARGE} : begin if ($time - tm_bank_activate[bank] > TRAS_MAX)                                                                    $display (\"%m: at time %t ERROR:  tRAS maximum violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                                                             if ($time - tm_bank_activate[bank] < TRAS_MIN)                                                                    $display (\"%m: at time %t ERROR:  tRAS minimum violation during %s to bank %d\", $time, cmd_string[cmd], bank);end\n            {1'bx, SAME_BANK , ACTIVATE , ACTIVATE } : begin if ($time - tm_bank_activate[bank] < TRC)                                                                         $display (\"%m: at time %t ERROR:   tRC violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'bx, SAME_BANK , ACTIVATE , WRITE    } ,\n            {1'bx, SAME_BANK , ACTIVATE , READ     } : ; \n            {1'b0, DIFF_BANK , ACTIVATE , ACTIVATE } : begin if (($time - tm_activate < TRRD) || (ck_cntr - ck_activate < TRRD_TCK))                                           $display (\"%m: at time %t ERROR:  tRRD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , ACTIVATE , ACTIVATE } : begin if (($time - tm_group_activate[bank[1]] < TRRD) || (ck_cntr - ck_group_activate[bank[1]] < TRRD_TCK))             $display (\"%m: at time %t ERROR:  tRRD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, ACTIVATE , ACTIVATE } : begin if (($time - tm_activate < TRRD_DG) || (ck_cntr - ck_activate < TRRD_DG_TCK))                                     $display (\"%m: at time %t ERROR:  tRRD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , ACTIVATE , REFRESH  } : begin if ($time - tm_activate < TRC)                                                                                    $display (\"%m: at time %t ERROR:   tRC violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , ACTIVATE , PWR_DOWN } : begin if (ck_cntr - ck_activate < TACTPDEN)                                                                             $display (\"%m: at time %t ERROR:  tACTPDEN violation during %s\", $time, cmd_string[cmd]);                     end\n\n            \n            {1'bx, SAME_BANK , WRITE    , PRECHARGE} : begin if (($time - tm_bank_write_end[bank] < TWR) || (ck_cntr - ck_bank_write[bank] <= write_latency + burst_length/2)) $display (\"%m: at time %t ERROR:   tWR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , WRITE    , WRITE    } : begin if (ck_cntr - ck_write < TCCD)                                                                                    $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , WRITE    , WRITE    } : begin if (ck_cntr - ck_group_write[bank[1]] < TCCD)                                                                     $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , WRITE    , READ     } : begin if (ck_cntr - ck_write < write_latency + burst_length/2 + TWTR_TCK - additive_latency)                            $display (\"%m: at time %t ERROR:  tWTR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , WRITE    , READ     } : begin if (ck_cntr - ck_group_write[bank[1]] < write_latency + burst_length/2 + TWTR_TCK - additive_latency)             $display (\"%m: at time %t ERROR:  tWTR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, WRITE    , WRITE    } : begin if (ck_cntr - ck_write < TCCD_DG)                                                                                 $display (\"%m: at time %t ERROR:  tCCD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'b1, DIFF_GROUP, WRITE    , READ     } : begin if (ck_cntr - ck_write < write_latency + burst_length/2 + TWTR_DG_TCK - additive_latency)                         $display (\"%m: at time %t ERROR:  tWTR_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , WRITE    , PWR_DOWN } : begin if (($time - tm_write_end < TWR) || (ck_cntr - ck_write < write_latency + burst_length/2))                        $display (\"%m: at time %t ERROR:  tWRPDEN violation during %s\", $time, cmd_string[cmd]);                      end\n\n            \n            {1'bx, SAME_BANK , READ     , PRECHARGE} : begin if (($time - tm_bank_read_end[bank] < TRTP) || (ck_cntr - ck_bank_read[bank] < additive_latency + TRTP_TCK))      $display (\"%m: at time %t ERROR:  tRTP violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , READ     , WRITE    } : ; \n            {1'b1, DIFF_BANK , READ     , WRITE    } : ; \n            {1'b0, DIFF_BANK , READ     , READ     } : begin if (ck_cntr - ck_read < TCCD)                                                                                     $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , READ     , READ     } : begin if (ck_cntr - ck_group_read[bank[1]] < TCCD)                                                                      $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, READ     , WRITE    } : ; \n            {1'b1, DIFF_GROUP, READ     , READ     } : begin if (ck_cntr - ck_read < TCCD_DG)                                                                                  $display (\"%m: at time %t ERROR:  tCCD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , READ     , PWR_DOWN } : begin if (ck_cntr - ck_read < read_latency + 5)                                                                         $display (\"%m: at time %t ERROR:  tRDPDEN violation during %s\", $time, cmd_string[cmd]);                      end\n\n            \n            {1'bx, DIFF_BANK , ZQ       , LOAD_MODE} : ; \n            {1'bx, DIFF_BANK , ZQ       , REFRESH  } ,\n            {1'bx, DIFF_BANK , ZQ       , PRECHARGE} ,\n            {1'bx, DIFF_BANK , ZQ       , ACTIVATE } ,\n            {1'bx, DIFF_BANK , ZQ       , ZQ       } ,\n            {1'bx, DIFF_BANK , ZQ       , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , ZQ       , SELF_REF } : begin if (ck_cntr - ck_zqinit < TZQINIT)                                                                                $display (\"%m: at time %t ERROR:  tZQinit violation during %s\", $time, cmd_string[cmd]);\n                                                             if (ck_cntr - ck_zqoper < TZQOPER)                                                                                $display (\"%m: at time %t ERROR:  tZQoper violation during %s\", $time, cmd_string[cmd]);\n                                                             if (ck_cntr - ck_zqcs < TZQCS)                                                                                    $display (\"%m: at time %t ERROR:  tZQCS violation during %s\", $time, cmd_string[cmd]);                        end\n\n            \n            {1'bx, DIFF_BANK , PWR_DOWN , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , PWR_DOWN , REFRESH  } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , PRECHARGE} ,\n            {1'bx, DIFF_BANK , PWR_DOWN , ACTIVATE } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , WRITE    } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , ZQ       } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , PWR_DOWN , READ     } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);                            \n                                                        else if (($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK))                               $display (\"%m: at time %t ERROR:  tXPDLL violation during %s\", $time, cmd_string[cmd]);                       end\n            {1'bx, DIFF_BANK , PWR_DOWN , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , SELF_REF } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);\n                                                             if ((tm_power_down > tm_refresh) && ($time - tm_refresh < TRFC_MIN))                                              $display (\"%m: at time %t ERROR:  tRFC violation during %s\", $time, cmd_string[cmd]);\n                                                             if ((tm_refresh > tm_power_down) && (($time - tm_power_down < TXPDLL) || (ck_cntr - ck_power_down < TXPDLL_TCK))) $display (\"%m: at time %t ERROR:  tXPDLL violation during %s\", $time, cmd_string[cmd]);\n                                                             if (($time - tm_cke_cmd < TCKE) || (ck_cntr - ck_cke_cmd < TCKE_TCK))                                             $display (\"%m: at time %t ERROR:  tCKE violation on CKE\", $time);                                             end\n\n            \n            {1'bx, DIFF_BANK , SELF_REF , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , SELF_REF , REFRESH  } ,\n            {1'bx, DIFF_BANK , SELF_REF , PRECHARGE} ,\n            {1'bx, DIFF_BANK , SELF_REF , ACTIVATE } ,\n            {1'bx, DIFF_BANK , SELF_REF , WRITE    } ,\n            {1'bx, DIFF_BANK , SELF_REF , ZQ       } : begin if (($time - tm_self_refresh < TXS) || (ck_cntr - ck_self_refresh < TXS_TCK))                                     $display (\"%m: at time %t ERROR:   tXS violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , SELF_REF , READ     } : begin if (ck_cntr - ck_self_refresh < TXSDLL)                                                                           $display (\"%m: at time %t ERROR:  tXSDLL violation during %s\", $time, cmd_string[cmd]);                       end\n            {1'bx, DIFF_BANK , SELF_REF , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , SELF_REF , SELF_REF } : begin if (($time - tm_self_refresh < TXS) || (ck_cntr - ck_self_refresh < TXS_TCK))                                     $display (\"%m: at time %t ERROR:   tXS violation during %s\", $time, cmd_string[cmd]);\n                                                             if (($time - tm_cke_cmd < TCKE) || (ck_cntr - ck_cke_cmd < TCKE_TCK))                                             $display (\"%m: at time %t ERROR:  tCKE violation on CKE\", $time);                                             end\n        endcase\n    end\n    endtask\n\n    task cmd_task;\n        input cke;\n        input [2:0] cmd;\n        input [BA_BITS-1:0] bank;\n        input [ADDR_BITS-1:0] addr;\n        reg [`BANKS:0] i;\n        integer j;\n        reg [`BANKS:0] tfaw_cntr;\n        reg [COL_BITS-1:0] col;\n        reg group;\n        begin\n            \n            if (!er_trfc_max && !in_self_refresh) begin\n                if ($time - tm_refresh > TRFC_MAX && check_strict_timing) begin\n                    $display (\"%m: at time %t ERROR:  tRFC maximum violation during %s\", $time, cmd_string[cmd]);\n                    er_trfc_max = 1;\n                end\n            end\n            if (cke) begin\n                if ((cmd < NOP) && (cmd != PRECHARGE)) begin\n                    if (($time - tm_txpr < TXPR) || (ck_cntr - ck_txpr < TXPR_TCK))\n                        $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[cmd]);\n                    for (j=0; j<=SELF_REF; j=j+1) begin\n                        chk_err(SAME_BANK , bank, j, cmd);\n                        chk_err(DIFF_BANK , bank, j, cmd);\n                        chk_err(DIFF_GROUP, bank, j, cmd);\n                    end\n                end\n                case (cmd)\n                    LOAD_MODE : begin\n                        if (|odt_pipeline)\n                            $display (\"%m: at time %t ERROR: ODTL violation during %s\", $time, cmd_string[cmd]);\n                        if (odt_state)\n                            $display (\"%m: at time %t ERROR: ODT must be off prior to %s\", $time, cmd_string[cmd]);\n\n                        if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s %d\", $time, cmd_string[cmd], bank);\n                            if (bank>>2) begin\n                                $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved bank bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                            end\n                            case (bank)\n                                0 : begin\n                                    \n                                    if (addr[1:0] == 2'b00) begin\n                                        burst_length = 8;\n                                        blotf = 0;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = %d\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else if (addr[1:0] == 2'b01) begin\n                                        burst_length = 8;\n                                        blotf = 1;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = Select via A12\", $time, cmd_string[cmd], bank);\n                                    end else if (addr[1:0] == 2'b10) begin\n                                        burst_length = 4;\n                                        blotf = 0;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = Fixed %d (chop)\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else if (feature_truebl4 && (addr[1:0] == 2'b11)) begin\n                                        burst_length = 4;\n                                        blotf = 0;\n                                        truebl4 = 1;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = True %d\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Burst Length = %d\", $time, cmd_string[cmd], bank, addr[1:0]);\n                                    end\n                                    \n                                    burst_order = addr[3];\n                                    if (!burst_order) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Order = Sequential\", $time, cmd_string[cmd], bank);\n                                    end else if (burst_order) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Order = Interleaved\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Burst Order = %d\", $time, cmd_string[cmd], bank, burst_order);\n                                    end\n                                    \n                                    cas_latency = {addr[2],addr[6:4]} + 4;\n                                    set_latency;\n                                    if ((cas_latency >= CL_MIN) && (cas_latency <= CL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d CAS Latency = %d\", $time, cmd_string[cmd], bank, cas_latency);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal CAS Latency = %d\", $time, cmd_string[cmd], bank, cas_latency);\n                                    end\n                                    \n                                    if (addr[7] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    dll_reset = addr[8];\n                                    if (!dll_reset) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Reset = Normal\", $time, cmd_string[cmd], bank);\n                                    end else if (dll_reset) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Reset = Reset DLL\", $time, cmd_string[cmd], bank);\n                                        dll_locked = 0;\n                                        init_dll_reset = 1;\n                                        ck_dll_reset <= ck_cntr;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal DLL Reset = %d\", $time, cmd_string[cmd], bank, dll_reset);\n                                    end\n\n\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t   if (addr[11:9] == 0) begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = 16;\n\t\t\t\t\t\t\t\t   end else if (addr[11:9] < 4) begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = addr[11:9] + 4;\n\t\t\t\t\t\t\t\t   end else begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = 2*addr[11:9];\n\t\t\t\t\t\t\t\t   end\n\n                                    if ((write_recovery >= WR_MIN) && (write_recovery <= WR_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Recovery = %d\", $time, cmd_string[cmd], bank, write_recovery);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Write Recovery = %d\", $time, cmd_string[cmd], bank, write_recovery);\n                                    end\n                                    \n                                    low_power = !addr[12];\n                                    if (!low_power) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Power Down Mode = DLL on\", $time, cmd_string[cmd], bank);\n                                    end else if (low_power) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Power Down Mode = DLL off\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Power Down Mode = %d\", $time, cmd_string[cmd], bank, low_power);\n                                    end\n                                    \n                                    if (ADDR_BITS>13 && addr[13] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                1 : begin\n                                    \n                                    dll_en = !addr[0];\n                                    if (!dll_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d DLL off mode is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else if (dll_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal DLL Enable = %d\", $time, cmd_string[cmd], bank, dll_en);\n                                    end\n                                    \n                                    if ({addr[5], addr[1]} == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/6);\n                                    end else if ({addr[5], addr[1]} == 2'b01) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/7);\n                                    end else if ({addr[5], addr[1]} == 2'b11) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/5);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Output Drive Strength = %d\", $time, cmd_string[cmd], bank, {addr[5], addr[1]});\n                                    end\n                                    \n                                    odt_rtt_nom = {addr[9], addr[6], addr[2]};\n                                    if (odt_rtt_nom == 3'b000) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d ODT Rtt = Disabled\", $time, cmd_string[cmd], bank);\n                                        odt_en = 0;\n                                    end else if ((odt_rtt_nom < 4) || ((!addr[7] || (addr[7] && addr[12])) && (odt_rtt_nom < 6))) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d ODT Rtt = %d Ohm\", $time, cmd_string[cmd], bank, get_rtt_nom(odt_rtt_nom));\n                                        odt_en = 1;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal ODT Rtt = %d\", $time, cmd_string[cmd], bank, odt_rtt_nom);\n                                        odt_en = 0;\n                                    end\n                                    \n                                    al = addr[4:3];\n                                    set_latency;\n                                    if (al == 0) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Additive Latency = %d\", $time, cmd_string[cmd], bank, al);\n                                    end else if ((al >= AL_MIN) && (al <= AL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Additive Latency = CL - %d\", $time, cmd_string[cmd], bank, al);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Additive Latency = %d\", $time, cmd_string[cmd], bank, al);\n                                    end\n                                    \n                                    write_levelization = addr[7];\n                                    if (!write_levelization) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Levelization = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (write_levelization) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Levelization = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Write Levelization = %d\", $time, cmd_string[cmd], bank, write_levelization);\n                                    end\n                                    \n                                    if (addr[8] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    if (addr[10] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    tdqs_en = addr[11];\n                                    if (!tdqs_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d TDQS Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (tdqs_en) begin\n                                        if (8 == DQ_BITS) begin\n\t\t\t\t\t\t\t\t\t\t    if (DEBUG) $display (\"%m: at time %t INFO: %s %d TDQS Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                        end\n\t\t\t\t\t\t\t\t\t    else begin\n                                            $display (\"%m: at time %t WARNING: %s %d Illegal TDQS Enable.  TDQS only exists on a x8 part\", $time, cmd_string[cmd], bank);\n                                            tdqs_en = 0;\n\t\t\t\t\t\t\t\t\t\tend   \n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal TDQS Enable = %d\", $time, cmd_string[cmd], bank, tdqs_en);\n                                    end \n                                    \n                                    out_en = !addr[12];\n                                    if (!out_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Qoff = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (out_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Qoff = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Qoff = %d\", $time, cmd_string[cmd], bank, out_en);\n                                    end \n                                    \n                                    if (ADDR_BITS>13 && addr[13] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                2 : begin\n\t\t\t\t\t\t\t\t    if (feature_pasr) begin\n                                        \n                                        pasr = addr[2:0];\n                                        case (pasr)\n                                            3'b000 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-7\", $time, cmd_string[cmd], bank);\n                                            3'b001 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-3\", $time, cmd_string[cmd], bank);\n                                            3'b010 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-1\", $time, cmd_string[cmd], bank);\n                                            3'b011 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0\", $time, cmd_string[cmd], bank);\n                                            3'b100 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 2-7\", $time, cmd_string[cmd], bank);\n                                            3'b101 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 4-7\", $time, cmd_string[cmd], bank);\n                                            3'b110 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 6-7\", $time, cmd_string[cmd], bank);\n                                            3'b111 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 7\", $time, cmd_string[cmd], bank);\n                                            default : $display (\"%m: at time %t ERROR: %s %d Illegal Partial Array Self Refresh = %d\", $time, cmd_string[cmd], bank, pasr);\n                                        endcase \n\t\t\t\t\t\t\t\t\tend \n\t\t\t\t\t\t\t\t    else\n                                    if (addr[2:0] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    cas_write_latency = addr[5:3]+5;\n                                    set_latency;\n                                    if ((cas_write_latency >= CWL_MIN) && (cas_write_latency <= CWL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d CAS Write Latency = %d\", $time, cmd_string[cmd], bank, cas_write_latency);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal CAS Write Latency = %d\", $time, cmd_string[cmd], bank, cas_write_latency);\n                                    end\n                                    \n                                    asr = addr[6];\n                                    if (!asr) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Auto Self Refresh = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (asr) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Auto Self Refresh = Enabled\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d Auto Self Refresh is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Auto Self Refresh = %d\", $time, cmd_string[cmd], bank, asr);\n                                    end \n                                    \n                                    srt = addr[7];\n                                    if (!srt) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Self Refresh Temperature = Normal\", $time, cmd_string[cmd], bank);\n                                    end else if (srt) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Self Refresh Temperature = Extended\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d Self Refresh Temperature is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Self Refresh Temperature = %d\", $time, cmd_string[cmd], bank, srt);\n                                    end \n                                    if (asr && srt)\n                                        $display (\"%m: at time %t ERROR: %s %d SRT must be set to 0 when ASR is enabled.\", $time, cmd_string[cmd], bank);\n                                    \n                                    if (addr[8] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    odt_rtt_wr = addr[10:9];\n                                    if (odt_rtt_wr == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Dynamic ODT = Disabled\", $time, cmd_string[cmd], bank);\n                                        dyn_odt_en = 0;\n                                    end else if ((odt_rtt_wr > 0) && (odt_rtt_wr < 3)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Dynamic ODT Rtt = %d Ohm\", $time, cmd_string[cmd], bank, get_rtt_wr(odt_rtt_wr));\n                                        dyn_odt_en = 1;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Dynamic ODT = %d\", $time, cmd_string[cmd], bank, odt_rtt_wr);\n                                        dyn_odt_en = 0;\n                                    end\n                                    \n                                    if (ADDR_BITS>13 && addr[13:11] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                3 : begin\n                                    mpr_select = addr[1:0];\n                                    \n                                    if (mpr_select == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Select = Pre-defined pattern\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        if (check_strict_mrbits) $display (\"%m: at time %t ERROR: %s %d Illegal MultiPurpose Register Select = %d\", $time, cmd_string[cmd], bank, mpr_select);\n                                    end\n                                    \n                                    mpr_en = addr[2];\n                                    if (!mpr_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (mpr_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal MultiPurpose Register Enable = %d\", $time, cmd_string[cmd], bank, mpr_en);\n                                    end \n                                    \n                                    if (ADDR_BITS>13 && addr[13:3] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                            endcase\n                            if (dyn_odt_en && write_levelization)\n                                $display (\"%m: at time %t ERROR: Dynamic ODT is not available during Write Leveling mode.\", $time);\n                            init_mode_reg[bank] = 1;\n                            mode_reg[bank] = addr;\n                            tm_load_mode <= $time;\n                            ck_load_mode <= ck_cntr;\n                        end\n                    end\n                    REFRESH : begin\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s\", $time, cmd_string[cmd]);\n                            er_trfc_max = 0;\n                            ref_cntr = ref_cntr + 1;\n                            tm_refresh <= $time;\n                            ck_refresh <= ck_cntr;\n                        end\n                    end\n                    PRECHARGE : begin\n                        if (addr[AP]) begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s All\", $time, cmd_string[cmd]);\n                        end\n                        \n                        \n                        if (|active_bank) begin\n                            if (($time - tm_txpr < TXPR) || (ck_cntr - ck_txpr < TXPR_TCK))\n                                $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[cmd]);\n                            if (mpr_en) begin\n                                $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                                if (STOP_ON_ERROR) $stop(0);\n                            end else begin\n                                for (i=0; i<`BANKS; i=i+1) begin\n                                    if (active_bank[i]) begin\n                                        if (addr[AP] || (i == bank)) begin\n\n                                            for (j=0; j<=SELF_REF; j=j+1) begin\n                                                chk_err(SAME_BANK, i, j, cmd);\n                                                chk_err(DIFF_BANK, i, j, cmd);\n                                            end\n\n                                            if (auto_precharge_bank[i]) begin\n                                                $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], i);\n                                                if (STOP_ON_ERROR) $stop(0);\n                                            end else begin\n                                                if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d\", $time, cmd_string[cmd], i);\n                                                active_bank[i] = 1'b0;\n                                                tm_bank_precharge[i] <= $time;\n                                                tm_precharge <= $time;\n                                                ck_precharge <= ck_cntr;\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                    ACTIVATE : begin\n                        tfaw_cntr = 0;\n                        for (i=0; i<`BANKS; i=i+1) begin\n                            if ($time - tm_bank_activate[i] < TFAW) begin\n                                tfaw_cntr = tfaw_cntr + 1;\n                            end\n                        end\n                        if (tfaw_cntr > 3) begin\n                            $display (\"%m: at time %t ERROR:  tFAW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (active_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Precharged.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr >= 1<<ROW_BITS) begin\n                                $display (\"%m: at time %t WARNING: row = %h does not exist.  Maximum row = %h\", $time, addr, (1<<ROW_BITS)-1);\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d row %h\", $time, cmd_string[cmd], bank, addr);\n                            active_bank[bank] = 1'b1;\n                            active_row[bank] = addr;\n                            tm_group_activate[bank[1]] <= $time;\n                            tm_activate <= $time;\n                            tm_bank_activate[bank] <= $time;\n                            ck_group_activate[bank[1]] <= ck_cntr;\n                            ck_activate <= ck_cntr;\n                        end\n                    end\n                    WRITE : begin\n                        if ((!rd_bc && blotf) || (burst_length == 4)) begin \n                            if (truebl4) begin\n                                if (ck_cntr - ck_group_read[bank[1]] < read_latency + TCCD/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                                if (ck_cntr - ck_read < read_latency + TCCD_DG/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                            end else begin\n                                if (ck_cntr - ck_read < read_latency + TCCD/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                            end\n                        end else begin \n                            if (ck_cntr - ck_read < read_latency + TCCD + 2 - write_latency)\n                                $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!active_bank[bank])  begin\n                            if (check_strict_timing) $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Activated.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (auto_precharge_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (ck_cntr - ck_write < burst_length/2) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Illegal burst interruption.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr[AP]) begin\n                                auto_precharge_bank[bank] = 1'b1;\n                                write_precharge_bank[bank] = 1'b1;\n                            end\n                            col = {addr[BC-1:AP+1], addr[AP-1:0]}; \n                            if (col >= 1<<COL_BITS) begin\n                                $display (\"%m: at time %t WARNING: col = %h does not exist.  Maximum col = %h\", $time, col, (1<<COL_BITS)-1);\n                            end\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                col = col & -4;\n                            end else begin \n                                col = col & -8;\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d col %h, auto precharge %d\", $time, cmd_string[cmd], bank, col, addr[AP]);\n                            wr_pipeline[2*write_latency + 1]  = 1;\n                            ba_pipeline[2*write_latency + 1]  = bank;\n                            row_pipeline[2*write_latency + 1] = active_row[bank];\n                            col_pipeline[2*write_latency + 1] = col;\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                bl_pipeline[2*write_latency + 1] = 4;\n                                if (mpr_en && col%4) begin\n                                    $display (\"%m: at time %t WARNING: col[1:0] must be set to 2'b00 during a BL4 Multipurpose Register read\", $time);\n                                end\n                            end else begin \n                                bl_pipeline[2*write_latency + 1] = 8;\n                                if (odt_in) begin\n                                    ck_odth8 <= ck_cntr;\n                                end\n                            end\n                            for (j=0; j<(burst_length + 4); j=j+1) begin\n                                dyn_odt_pipeline[2*(write_latency - 2) + j] = 1'b1; \n                            end\n                            ck_bank_write[bank] <= ck_cntr;\n                            ck_group_write[bank[1]] <= ck_cntr;\n                            ck_write <= ck_cntr;\n                        end\n                    end\n                    READ : begin\n                        if (!dll_locked)\n                            $display (\"%m: at time %t WARNING: tDLLK violation during %s.\", $time, cmd_string[cmd]);\n                        if (mpr_en && (addr[1:0] != 2'b00)) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  addr[1:0] must be zero during Multipurpose Register Read.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!active_bank[bank] && !mpr_en) begin\n                            if (check_strict_timing) $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Activated.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (auto_precharge_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (ck_cntr - ck_read < burst_length/2) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Illegal burst interruption.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr[AP] && !mpr_en) begin\n                                auto_precharge_bank[bank] = 1'b1;\n                                read_precharge_bank[bank] = 1'b1;\n                            end\n                            col = {addr[BC-1:AP+1], addr[AP-1:0]}; \n                            if (col >= 1<<COL_BITS) begin\n                                $display (\"%m: at time %t WARNING: col = %h does not exist.  Maximum col = %h\", $time, col, (1<<COL_BITS)-1);\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d col %h, auto precharge %d\", $time, cmd_string[cmd], bank, col, addr[AP]);\n                            rd_pipeline[2*read_latency - 1]  = 1;\n                            ba_pipeline[2*read_latency - 1]  = bank;\n                            row_pipeline[2*read_latency - 1] = active_row[bank];\n                            col_pipeline[2*read_latency - 1] = col;\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                bl_pipeline[2*read_latency - 1] = 4;\n                                if (mpr_en && col%4) begin\n                                    $display (\"%m: at time %t WARNING: col[1:0] must be set to 2'b00 during a BL4 Multipurpose Register read\", $time);\n                                end\n                            end else begin \n                                bl_pipeline[2*read_latency - 1] = 8;\n                                if (mpr_en && col%8) begin\n                                    $display (\"%m: at time %t WARNING: col[2:0] must be set to 3'b000 during a BL8 Multipurpose Register read\", $time);\n                                end\n                            end\n                            rd_bc = addr[BC];\n                            ck_bank_read[bank] <= ck_cntr;\n                            ck_group_read[bank[1]] <= ck_cntr;\n                            ck_read <= ck_cntr;\n                        end\n                    end\n                    ZQ : begin\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s long = %d\", $time, cmd_string[cmd], addr[AP]);\n                            if (addr[AP]) begin\n                                zq_set = 1;\n                                if (init_done) begin\n                                    ck_zqoper <= ck_cntr;\n                                end else begin\n                                    ck_zqinit <= ck_cntr;\n                                end\n                            end else begin\n                                ck_zqcs <= ck_cntr;\n                            end\n                        end\n                    end\n                    NOP: begin\n                        if (in_power_down) begin\n                            if (($time - tm_freq_change < TCKSRX) || (ck_cntr - ck_freq_change < TCKSRX_TCK))\n                                $display (\"%m: at time %t ERROR: tCKSRX violation during Power Down Exit\", $time);\n                            if ($time - tm_cke_cmd > TPD_MAX)\n                                $display (\"%m: at time %t ERROR: tPD maximum violation during Power Down Exit\", $time);\n                            if (DEBUG) $display (\"%m: at time %t INFO: Power Down Exit\", $time);\n                            in_power_down = 0;\n                            if ((active_bank == 0) && low_power) begin \n                                if (ck_cntr - ck_odt < write_latency - 1)\n                                    $display (\"%m: at time %t WARNING: tANPD violation during Power Down Exit.  Synchronous or asynchronous change in termination resistance is possible.\", $time);\n                                tm_slow_exit_pd <= $time;\n                                ck_slow_exit_pd <= ck_cntr;\n                            end\n                            tm_power_down <= $time;\n                            ck_power_down <= ck_cntr;\n                        end\n                        if (in_self_refresh) begin\n                            if (($time - tm_freq_change < TCKSRX) || (ck_cntr - ck_freq_change < TCKSRX_TCK))\n                                $display (\"%m: at time %t ERROR: tCKSRX violation during Self Refresh Exit\", $time);\n                            if (ck_cntr - ck_cke_cmd < TCKESR_TCK)\n                                $display (\"%m: at time %t ERROR: tCKESR violation during Self Refresh Exit\", $time);\n                            if ($time - tm_cke < TISXR)\n                                $display (\"%m: at time %t ERROR: tISXR violation during Self Refresh Exit\", $time);\n                            if (DEBUG) $display (\"%m: at time %t INFO: Self Refresh Exit\", $time);\n                            in_self_refresh = 0;\n                            ck_dll_reset <= ck_cntr;\n                            ck_self_refresh <= ck_cntr;\n                            tm_self_refresh <= $time;\n                            tm_refresh <= $time;\n                        end\n                    end\n                endcase\n                if ((prev_cke !== 1) && (cmd !== NOP)) begin\n                    $display (\"%m: at time %t ERROR: NOP or Deselect is required when CKE goes active.\", $time);\n                end\n\n                if (!init_done) begin\n                    case (init_step)\n                        0 : begin\n                            if ($time - tm_rst_n < 500000000 && check_strict_timing) \n                                $display (\"%m at time %t WARNING: 500 us is required after RST_N goes inactive before CKE goes active.\", $time);\n                            tm_txpr <= $time;\n                            ck_txpr <= ck_cntr;\n                            init_step = init_step + 1;\n                        end\n                        1 : if (dll_en) init_step = init_step + 1;\n                        2 : begin\n                            if (&init_mode_reg && init_dll_reset && zq_set) begin\n                                if (DEBUG) $display (\"%m: at time %t INFO: Initialization Sequence is complete\", $time);\n                                init_done = 1;\n                            end\n                        end\n                    endcase\n                end\n            end else if (prev_cke) begin\n                if ((!init_done) && (init_step > 1)) begin\n                    $display (\"%m: at time %t ERROR: CKE must remain active until the initialization sequence is complete.\", $time);\n                    if (STOP_ON_ERROR) $stop(0);\n                end\n                case (cmd)\n                    REFRESH : begin\n                        if ($time - tm_txpr < TXPR)\n                            $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[SELF_REF]);\n                        for (j=0; j<=SELF_REF; j=j+1) begin\n                            chk_err(DIFF_BANK, bank, j, SELF_REF);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  Multipurpose Register must be disabled.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  All banks must be Precharged.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (odt_state) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  ODT must be off prior to entering Self Refresh\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  Initialization sequence is not complete.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: Self Refresh Enter\", $time);\n\t\t\t\t\t\t    if (feature_pasr)\n                                \n                                case (pasr)\n                                    3'b000 : ;\n                                    3'b001 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 4-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hF0); end\n                                    3'b010 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 2-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hFC); end\n                                    3'b011 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 1-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hFE); end\n                                    3'b100 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-1 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h03); end\n                                    3'b101 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-3 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h0F); end\n                                    3'b110 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-5 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h3F); end\n                                    3'b111 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-6 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h7F); end\n\t\t\t\t\t\t\t    endcase\n                            in_self_refresh = 1;\n                            dll_locked = 0;\n                        end\n                    end\n                    NOP : begin\n                        \n                        if (low_power && (active_bank == 0) && |odt_pipeline)\n                            $display (\"%m: at time %t WARNING: tANPD violation during %s.   Synchronous or asynchronous change in termination resistance is possible.\", $time, cmd_string[PWR_DOWN]);\n                        if ($time - tm_txpr < TXPR)\n                            $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[PWR_DOWN]);\n                        for (j=0; j<=SELF_REF; j=j+1) begin\n                            chk_err(DIFF_BANK, bank, j, PWR_DOWN);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: Power Down Failure.  Multipurpose Register must be disabled.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: Power Down Failure.  Initialization sequence is not complete.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) begin\n                                if (|active_bank) begin\n                                    $display (\"%m: at time %t INFO: Active Power Down Enter\", $time);\n                                end else begin\n                                    $display (\"%m: at time %t INFO: Precharge Power Down Enter\", $time);\n                                end\n                            end\n                            in_power_down = 1;\n                        end\n                    end\n                    default : begin\n                        $display (\"%m: at time %t ERROR: NOP, Deselect, or Refresh is required when CKE goes inactive.\", $time);\n                    end\n                endcase\n            end else if (in_self_refresh || in_power_down) begin\n                if ((ck_cntr - ck_cke_cmd <= TCPDED) && (cmd !== NOP))\n                    $display (\"%m: at time %t ERROR: tCPDED violation during Power Down or Self Refresh Entry.  NOP or Deselect is required.\", $time);\n            end\n            prev_cke  = cke;\n\n        end\n    endtask    \n\n    task data_task;\n        reg [BA_BITS-1:0] bank;\n        reg [ROW_BITS-1:0] row;\n        reg [COL_BITS-1:0] col;\n        integer i;\n        integer j;\n        begin\n\n            if (diff_ck) begin\n                for (i=0; i<32; i=i+1) begin\n                    if (dq_in_valid && dll_locked && ($time - tm_dqs_neg[i] < $rtoi(TDSS*tck_avg)))\n                        $display (\"%m: at time %t ERROR: tDSS violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    if (check_write_dqs_high[i])\n                        $display (\"%m: at time %t ERROR: %s bit %d latching edge required during the preceding clock period.\", $time, dqs_string[i/16], i%16);\n                end\n                check_write_dqs_high <= 0;\n            end else begin\n                for (i=0; i<32; i=i+1) begin\n                    if (dll_locked && dq_in_valid) begin\n                        tm_tdqss = abs_value(1.0*tm_ck_pos - tm_dqss_pos[i]);\n                        if ((tm_tdqss < tck_avg/2.0) && (tm_tdqss > TDQSS*tck_avg))\n                            $display (\"%m: at time %t ERROR: tDQSS violation on %s bit %d\", $time, dqs_string[i/16], i%16); \n                    end\n                    if (check_write_dqs_low[i])\n                        $display (\"%m: at time %t ERROR: %s bit %d latching edge required during the preceding clock period\", $time, dqs_string[i/16], i%16);\n                end\n                check_write_preamble <= 0;\n                check_write_postamble <= 0;\n                check_write_dqs_low <= 0;\n            end\n\n            if (wr_pipeline[0] || rd_pipeline[0]) begin\n                bank = ba_pipeline[0];\n                row = row_pipeline[0];\n                col = col_pipeline[0];\n                burst_cntr = 0;\n                memory_read(bank, row, col, memory_data);\n            end\n\n            \n            if (burst_cntr < burst_length) begin\n                burst_position = col ^ burst_cntr;\n                if (!burst_order) begin\n                    burst_position[BO_BITS-1:0] = col + burst_cntr;\n                end\n                burst_cntr = burst_cntr + 1;\n            end\n\n            \n            if (wr_pipeline[WDQS_PRE + 1]) begin\n                wdqs_cntr = WDQS_PRE + bl_pipeline[WDQS_PRE + 1] + WDQS_PST - 1;\n            end\n            \n            if ((wr_pipeline[2]) && (wdq_cntr == 0)) begin \n                check_write_preamble <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n            end\n            if (wdqs_cntr > 1) begin  \n                if ((wdqs_cntr - WDQS_PST)%2) begin\n                    check_write_dqs_high <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n                end else begin\n                    check_write_dqs_low <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n                end\n            end\n            if (wdqs_cntr == WDQS_PST) begin \n                check_write_postamble <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n            end \n            if (wdqs_cntr > 0) begin\n                wdqs_cntr = wdqs_cntr - 1;\n            end\n\n            \n            if (dq_in_valid) begin \n                bit_mask = 0;\n                if (diff_ck) begin\n                    for (i=0; i<DM_BITS; i=i+1) begin\n                        bit_mask = bit_mask | ({`DQ_PER_DQS{~dm_in_neg[i]}}<<(burst_position*DQ_BITS + i*`DQ_PER_DQS));\n                    end\n                    memory_data = (dq_in_neg<<(burst_position*DQ_BITS) & bit_mask) | (memory_data & ~bit_mask);\n                end else begin\n                    for (i=0; i<DM_BITS; i=i+1) begin\n                        bit_mask = bit_mask | ({`DQ_PER_DQS{~dm_in_pos[i]}}<<(burst_position*DQ_BITS + i*`DQ_PER_DQS));\n                    end\n                    memory_data = (dq_in_pos<<(burst_position*DQ_BITS) & bit_mask) | (memory_data & ~bit_mask);\n                end\n                dq_temp = memory_data>>(burst_position*DQ_BITS);\n                if (DEBUG) $display (\"%m: at time %t INFO: WRITE @ DQS= bank = %h row = %h col = %h data = %h\",$time, bank, row, (-1*BL_MAX & col) + burst_position, dq_temp);\n                if (burst_cntr%BL_MIN == 0) begin\n                    memory_write(bank, row, col, memory_data);\n                end\n            end\n            if (wr_pipeline[1]) begin\n                wdq_cntr = bl_pipeline[1];\n            end\n            if (wdq_cntr > 0) begin\n                wdq_cntr = wdq_cntr - 1;\n                dq_in_valid = 1'b1;\n            end else begin\n                dq_in_valid = 1'b0;\n                dqs_in_valid <= 1'b0;\n                for (i=0; i<31; i=i+1) begin\n                    wdqs_pos_cntr[i]    <= 0;\n                end\n            end\n            if (wr_pipeline[0]) begin\n                b2b_write <= 1'b0;\n            end\n            if (wr_pipeline[2]) begin\n                if (dqs_in_valid) begin\n                    b2b_write <= 1'b1;\n                end\n                dqs_in_valid <= 1'b1;\n                wr_burst_length = bl_pipeline[2];\n            end\n\n            \n            if (rd_pipeline[RDQSEN_PRE]) begin\n                rdqsen_cntr = RDQSEN_PRE + bl_pipeline[RDQSEN_PRE] + RDQSEN_PST - 1;\n            end\n            if (rdqsen_cntr > 0) begin\n                rdqsen_cntr = rdqsen_cntr - 1;\n                dqs_out_en = 1'b1;\n            end else begin\n                dqs_out_en = 1'b0;\n            end\n            \n            \n            if (rd_pipeline[RDQS_PRE]) begin\n                rdqs_cntr = RDQS_PRE + bl_pipeline[RDQS_PRE] + RDQS_PST - 1;\n            end\n            \n            if (((rd_pipeline>>1 & {RDQS_PRE{1'b1}}) > 0) && (rdq_cntr == 0)) begin \n                dqs_out = 1'b0;\n            end else if (rdqs_cntr > RDQS_PST) begin \n                dqs_out = rdqs_cntr - RDQS_PST;\n            end else if (rdqs_cntr > 0) begin \n                dqs_out = 1'b0;\n            end else begin\n                dqs_out = 1'b1;\n            end\n            if (rdqs_cntr > 0) begin\n                rdqs_cntr = rdqs_cntr - 1;\n            end\n\n            \n            if (rd_pipeline[RDQEN_PRE]) begin\n                rdqen_cntr = RDQEN_PRE + bl_pipeline[RDQEN_PRE] + RDQEN_PST;\n            end\n            if (rdqen_cntr > 0) begin\n                rdqen_cntr = rdqen_cntr - 1;\n                dq_out_en = 1'b1;\n            end else begin\n                dq_out_en = 1'b0;\n            end\n            \n            if (rd_pipeline[0]) begin\n                rdq_cntr = bl_pipeline[0];\n            end\n            if (rdq_cntr > 0) begin \n                if (mpr_en) begin\n`ifdef MPR_DQ0 \n                    if (mpr_select == 2'b00) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, calibration_pattern[burst_position]}};\n                    end else if (odts_readout && (mpr_select == 2'b11)) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, temp_sensor[burst_position]}};\n                    end else begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, 1'bx}};\n                    end\n`else \n                    if (mpr_select == 2'b00) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{calibration_pattern[burst_position]}}}};\n                    end else if (odts_readout && (mpr_select == 2'b11)) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{temp_sensor[burst_position]}}}};\n                    end else begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{1'bx}}}};\n                    end\n`endif\t\t\t\t   \n                    if (DEBUG) $display (\"%m: at time %t READ @ DQS MultiPurpose Register %d, col = %d,  data = %b\", $time, mpr_select, burst_position, dq_temp[0]);\n                end else begin\n                    dq_temp = memory_data>>(burst_position*DQ_BITS);\n                    if (DEBUG) $display (\"%m: at time %t INFO: READ @ DQS= bank = %h row = %h col = %h data = %h\",$time, bank, row, (-1*BL_MAX & col) + burst_position, dq_temp);\n                end\n                dq_out = dq_temp;\n                rdq_cntr = rdq_cntr - 1;\n            end else begin\n                dq_out = {DQ_BITS{1'b1}};\n            end\n\n            \n            if (RANDOM_OUT_DELAY && (dqs_out_en || (|dqs_out_en_dly) || dq_out_en || (|dq_out_en_dly))) begin\n                for (i=0; i<DQS_BITS; i=i+1) begin\n                    \n                    \n                    \n                    \n                    dqsck_max = TDQSCK;\n                    if (dqsck_max > dqsck[i] + TQH*tck_avg + TDQSQ) begin\n                        dqsck_max = dqsck[i] + TQH*tck_avg + TDQSQ;\n                    end\n                    dqsck_min = -1*TDQSCK;\n                    if (dqsck_min < dqsck[i] - TQH*tck_avg - TDQSQ) begin\n                        dqsck_min = dqsck[i] - TQH*tck_avg - TDQSQ;\n                    end\n\n                    \n                    \n                    \n                    \n                    dqsq_min = 0;\n                    if (dqsq_min < dqsck[i] - TQH*tck_avg) begin\n                        dqsq_min = dqsck[i] - TQH*tck_avg;\n                    end\n                    if (dqsck_min == dqsck_max) begin\n                        dqsck[i] = dqsck_min;\n                    end else begin\n                        dqsck[i] = $dist_uniform(seed, dqsck_min, dqsck_max);\n                    end\n                    dqsq_max = TDQSQ + dqsck[i];\n\n                    dqs_out_en_dly[i] <= #(tck_avg/2) dqs_out_en;\n                    dqs_out_dly[i]    <= #(tck_avg/2 + dqsck[i]) dqs_out;\n                    if (!write_levelization) begin\n                        for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                            dq_out_en_dly[i*`DQ_PER_DQS + j] <= #(tck_avg/2) dq_out_en;\n                            if (dqsq_min == dqsq_max) begin\n                                dq_out_dly   [i*`DQ_PER_DQS + j] <= #(tck_avg/2 + dqsq_min) dq_out[i*`DQ_PER_DQS + j];\n                            end else begin\n                                dq_out_dly   [i*`DQ_PER_DQS + j] <= #(tck_avg/2 + $dist_uniform(seed, dqsq_min, dqsq_max)) dq_out[i*`DQ_PER_DQS + j];\n                            end\n                        end\n                    end\n                end\n            end else begin\n                out_delay = tck_avg/2;\n                dqs_out_en_dly <= #(out_delay) {DQS_BITS{dqs_out_en}};\n                dqs_out_dly    <= #(out_delay) {DQS_BITS{dqs_out   }};\n                if (write_levelization !== 1'b1) begin\n                    dq_out_en_dly  <= #(out_delay) {DQ_BITS {dq_out_en }};\n                    dq_out_dly     <= #(out_delay) {DQ_BITS {dq_out    }};\n                end\n            end\n        end\n    endtask\n\n    always @ (posedge rst_n_in) begin : reset\n        integer i;\n        if (rst_n_in) begin\n            if ($time < 200000000 && check_strict_timing) \n                $display (\"%m at time %t WARNING: 200 us is required before RST_N goes inactive.\", $time);\n            if (cke_in !== 1'b0)\n                $display (\"%m: at time %t ERROR: CKE must be inactive when RST_N goes inactive.\", $time);\n            if ($time - tm_cke < 10000)\n                $display (\"%m: at time %t ERROR: CKE must be maintained inactive for 10 ns before RST_N goes inactive.\", $time);\n\n            \n`ifdef MAX_MEM\n            \n    \n    \n    \n    \n`else\n            memory_used <= 0; \n`endif\n\n        end\n    end\n\n    always @(negedge rst_n_in or posedge diff_ck or negedge diff_ck) begin : main\n        integer i;\n        if (!rst_n_in) begin\n            reset_task;\n        end else begin\n            if (!in_self_refresh && (diff_ck !== 1'b0) && (diff_ck !== 1'b1))\n                $display (\"%m: at time %t ERROR: CK and CK_N are not allowed to go to an unknown state.\", $time);\n            data_task;\n\n            \n            \n            \n            if (in_self_refresh || (in_power_down && (active_bank == 0))) begin\n                if (diff_ck) begin\n                    tjit_per_rtime = $time - tm_ck_pos - tck_avg;\n                end else begin\n                    tjit_per_rtime = $time - tm_ck_neg - tck_avg;\n                end\n                if (dll_locked && (abs_value(tjit_per_rtime) > TJIT_PER)) begin\n                    if ((tm_ck_pos - tm_cke_cmd < TCKSRE) || (ck_cntr - ck_cke_cmd < TCKSRE_TCK))\n                        $display (\"%m: at time %t ERROR: tCKSRE violation during Self Refresh or Precharge Power Down Entry\", $time);\n                    if (odt_state) begin\n                        $display (\"%m: at time %t ERROR: Clock Frequency Change Failure.  ODT must be off prior to Clock Frequency Change.\", $time);\n                        if (STOP_ON_ERROR) $stop(0);\n                    end else begin\n                        if (DEBUG) $display (\"%m: at time %t INFO: Clock Frequency Change detected.  DLL Reset is Required.\", $time);\n                        tm_freq_change <= $time;\n                        ck_freq_change <= ck_cntr;\n                        dll_locked = 0;\n                    end\n                end\n            end\n\n            if (diff_ck) begin\n                \n                if ($time > TIS) begin\n                    if ($time - tm_cke < TIS) \n                        $display (\"%m: at time %t ERROR:   tIS violation on CKE by %t\", $time, tm_cke + TIS - $time);\n                    if (cke_in) begin\n                        for (i=0; i<22; i=i+1) begin\n                            if ($time - tm_cmd_addr[i] < TIS) \n                                $display (\"%m: at time %t ERROR:   tIS violation on %s by %t\", $time, cmd_addr_string[i], tm_cmd_addr[i] + TIS - $time);\n                        end\n                    end\n                end\n\n                \n                if (dll_locked) begin\n                    if (mr_chk == 0) begin\n                        mr_chk = 1;\n                    end else if (init_mode_reg[0] && (mr_chk == 1)) begin\n                        \n                        if (cas_latency*tck_avg < CL_TIME && check_strict_timing)\n                            $display (\"%m: at time %t ERROR: CAS Latency = %d is illegal @tCK(avg) = %f\", $time, cas_latency, tck_avg);\n                        \n                        if (ceil(write_recovery*tck_avg) < TWR)\n                            $display (\"%m: at time %t ERROR: Write Recovery = %d is illegal @tCK(avg) = %f\", $time, write_recovery, tck_avg);\n                        \n\t\t\t\t\t    if (check_strict_timing) begin \n                            case (cas_write_latency)\n                                5 : if (tck_avg < 2500.0)                          $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                6 : if ((tck_avg < 1875.0) || (tck_avg >= 2500.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                7 : if ((tck_avg < 1500.0) || (tck_avg >= 1875.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                8 : if ((tck_avg < 1250.0) || (tck_avg >= 1500.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                9 : if ((tck_avg < 15e3/14) || (tck_avg >= 1250.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                10: if ((tck_avg < 937.5) || (tck_avg >= 15e3/14)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                default :                                          $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                            endcase\n                            \n                            if (!valid_cl(cas_latency, cas_write_latency))\n                                $display (\"%m: at time %t ERROR: CAS Latency = %d is not valid when CAS Write Latency = %d\", $time, cas_latency, cas_write_latency);\n                        end\n                        mr_chk = 2;\n                    end\n                end else if (!in_self_refresh) begin\n                    mr_chk = 0;\n                    if (ck_cntr - ck_dll_reset == TDLLK) begin\n                        dll_locked = 1;\n                    end\n                end\n\n                if (|auto_precharge_bank) begin\n                    for (i=0; i<`BANKS; i=i+1) begin\n                        \n                        \n                        \n                        if (write_precharge_bank[i]) begin\n                            if ($time - tm_bank_activate[i] >= TRAS_MIN) begin\n                                if (ck_cntr - ck_bank_write[i] >= write_latency + burst_length/2 + write_recovery) begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", $time, i);\n                                    write_precharge_bank[i] = 0;\n                                    active_bank[i] = 0;\n                                    auto_precharge_bank[i] = 0;\n                                    tm_bank_precharge[i] = $time;\n                                    tm_precharge = $time;\n                                    ck_precharge = ck_cntr;\n                                end\n                            end\n                        end\n                        \n                        \n                        \n                        \n                        if (read_precharge_bank[i]) begin\n                            if (($time - tm_bank_activate[i] >= TRAS_MIN) && (ck_cntr - ck_bank_read[i] >= additive_latency + TRTP_TCK)) begin\n                                read_precharge_bank[i] = 0;\n                                \n                                \n                                if ($time - tm_bank_read_end[i] < TRTP) begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", tm_bank_read_end[i] + TRTP, i);\n                                    active_bank[i] <= #(tm_bank_read_end[i] + TRTP - $time) 0;\n                                    auto_precharge_bank[i] <= #(tm_bank_read_end[i] + TRTP - $time) 0;\n                                    tm_bank_precharge[i] <= #(tm_bank_read_end[i] + TRTP - $time) tm_bank_read_end[i] + TRTP;\n                                    tm_precharge <= #(tm_bank_read_end[i] + TRTP - $time) tm_bank_read_end[i] + TRTP;\n                                    ck_precharge = ck_cntr;\n                                end else begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", $time, i);\n                                    active_bank[i] = 0;\n                                    auto_precharge_bank[i] = 0;\n                                    tm_bank_precharge[i] = $time;\n                                    tm_precharge = $time;\n                                    ck_precharge = ck_cntr;\n                                end\n                            end\n                        end\n                    end\n                end\n\n                \n                if (cke_in ^ prev_cke) begin\n                    tm_cke_cmd <= $time;\n                    ck_cke_cmd <= ck_cntr;\n                end\n\n                cmd_task(cke_in, cmd_n_in, ba_in, addr_in);\n                if ((cmd_n_in == WRITE) || (cmd_n_in == READ)) begin\n                    al_pipeline[2*additive_latency] = 1'b1;\n                end\n                if (al_pipeline[0]) begin\n                    \n                    if ((rd_pipeline[2*cas_latency - 1]) && ($time - tm_bank_activate[ba_pipeline[2*cas_latency - 1]] < TRCD))\n                        $display (\"%m: at time %t ERROR:  tRCD violation during %s\", $time, cmd_string[READ]);\n                    if ((wr_pipeline[2*cas_write_latency + 1]) && ($time - tm_bank_activate[ba_pipeline[2*cas_write_latency + 1]] < TRCD))\n                        $display (\"%m: at time %t ERROR:  tRCD violation during %s\", $time, cmd_string[WRITE]);\n                    \n                    if (rd_pipeline[2*cas_latency - 1]) begin \n                        if (truebl4) begin \n                            i = ba_pipeline[2*cas_latency - 1];\n                            if ($time - tm_group_write_end[i[1]] < TWTR)\n                                $display (\"%m: at time %t ERROR:  tWTR violation during %s\", $time, cmd_string[READ]);\n                            if ($time - tm_write_end < TWTR_DG)\n                                $display (\"%m: at time %t ERROR:  tWTR_DG violation during %s\", $time, cmd_string[READ]);\n                        end else begin\n                            if ($time - tm_write_end < TWTR)\n                                $display (\"%m: at time %t ERROR:  tWTR violation during %s\", $time, cmd_string[READ]);\n                        end\n                    end\n                end\n               if (rd_pipeline) begin\n                  if (rd_pipeline[2*cas_latency - 1]) begin\n                     tm_bank_read_end[ba_pipeline[2*cas_latency - 1]] <= $time;\n                  end\n\t       end\n                for (i=0; i<`BANKS; i=i+1) begin\n\t\t    if ((ck_cntr - ck_bank_write[i] > write_latency) && (ck_cntr - ck_bank_write[i] <= write_latency + burst_length/2)) begin\n                        tm_bank_write_end[i] <= $time;\n                        tm_group_write_end[i[1]] <= $time;\n                        tm_write_end <= $time;\n                    end\n                end\n\n                \n                if (!in_self_refresh && tm_ck_pos ) begin\n                    tjit_cc_time = $time - tm_ck_pos - tck_i;\n                    tck_i   = $time - tm_ck_pos;\n                    tck_avg = tck_avg - tck_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tck_avg = tck_avg + tck_i/$itor(TDLLK);\n                    tck_sample[ck_cntr%TDLLK] = tck_i;\n                    tjit_per_rtime = tck_i - tck_avg;\n\n                    if (dll_locked && check_strict_timing) begin\n                        \n                        terr_nper_rtime = 0;\n                        for (i=0; i<12; i=i+1) begin\n                            terr_nper_rtime = terr_nper_rtime + tck_sample[i] - tck_avg;\n                            terr_nper_rtime = abs_value(terr_nper_rtime);\n                            case (i)\n                                      0 :;\n                                      1 : if (terr_nper_rtime - TERR_2PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(2per) violation by %f ps.\", $time, terr_nper_rtime - TERR_2PER);\n                                      2 : if (terr_nper_rtime - TERR_3PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(3per) violation by %f ps.\", $time, terr_nper_rtime - TERR_3PER);\n                                      3 : if (terr_nper_rtime - TERR_4PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(4per) violation by %f ps.\", $time, terr_nper_rtime - TERR_4PER);\n                                      4 : if (terr_nper_rtime - TERR_5PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(5per) violation by %f ps.\", $time, terr_nper_rtime - TERR_5PER);\n                                      5 : if (terr_nper_rtime - TERR_6PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(6per) violation by %f ps.\", $time, terr_nper_rtime - TERR_6PER);\n                                      6 : if (terr_nper_rtime - TERR_7PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(7per) violation by %f ps.\", $time, terr_nper_rtime - TERR_7PER);\n                                      7 : if (terr_nper_rtime - TERR_8PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(8per) violation by %f ps.\", $time, terr_nper_rtime - TERR_8PER);\n                                      8 : if (terr_nper_rtime - TERR_9PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(9per) violation by %f ps.\", $time, terr_nper_rtime - TERR_9PER);\n                                      9 : if (terr_nper_rtime - TERR_10PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(10per) violation by %f ps.\", $time, terr_nper_rtime - TERR_10PER);\n                                     10 : if (terr_nper_rtime - TERR_11PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(11per) violation by %f ps.\", $time, terr_nper_rtime - TERR_11PER);\n                                     11 : if (terr_nper_rtime - TERR_12PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(12per) violation by %f ps.\", $time, terr_nper_rtime - TERR_12PER);\n                            endcase\n                        end\n\t\t\t\t\t   \n                        \n                        if (abs_value(tjit_per_rtime) - TJIT_PER >= 1.0) \n                            $display (\"%m: at time %t ERROR: tJIT(per) violation by %f ps.\", $time, abs_value(tjit_per_rtime) - TJIT_PER);\n                        if (abs_value(tjit_cc_time) - TJIT_CC >= 1.0) \n                            $display (\"%m: at time %t ERROR: tJIT(cc) violation by %f ps.\", $time, abs_value(tjit_cc_time) - TJIT_CC);\n                        if (TCK_MIN - tck_avg >= 1.0)\n                            $display (\"%m: at time %t ERROR: tCK(avg) minimum violation by %f ps.\", $time, TCK_MIN - tck_avg);\n                        if (tck_avg - TCK_MAX >= 1.0) \n                            $display (\"%m: at time %t ERROR: tCK(avg) maximum violation by %f ps.\", $time, tck_avg - TCK_MAX);\n\n                        \n                        if (tm_ck_neg - $time < TCL_ABS_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(abs) minimum violation on CLK by %t\", $time, TCL_ABS_MIN*tck_avg - tm_ck_neg + $time);\n                        if (tcl_avg < TCL_AVG_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(avg) minimum violation on CLK by %t\", $time, TCL_AVG_MIN*tck_avg - tcl_avg);\n                        if (tcl_avg > TCL_AVG_MAX*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(avg) maximum violation on CLK by %t\", $time, tcl_avg - TCL_AVG_MAX*tck_avg);\n                    end\n\n                    \n                    tch_avg = tch_avg - tch_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tch_avg = tch_avg + tch_i/$itor(TDLLK);\n                    tch_sample[ck_cntr%TDLLK] = tch_i;\n                    tjit_ch_rtime = tch_i - tch_avg;\n                    duty_cycle = tch_avg/tck_avg;\n\n                    \n                    tcl_i <= $time - tm_ck_neg;\n                end\n\n                prev_odt <= odt_in;\n                \n                ck_cntr <= ck_cntr + 1;\n                tm_ck_pos = $time;\n            end else begin\n                \n                if (!in_self_refresh) begin\n                    if (dll_locked && check_strict_timing) begin\n                        if ($time - tm_ck_pos < TCH_ABS_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(abs) minimum violation on CLK by %t\", $time, TCH_ABS_MIN*tck_avg - $time + tm_ck_pos);\n                        if (tch_avg < TCH_AVG_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(avg) minimum violation on CLK by %t\", $time, TCH_AVG_MIN*tck_avg - tch_avg);\n                        if (tch_avg > TCH_AVG_MAX*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(avg) maximum violation on CLK by %t\", $time, tch_avg - TCH_AVG_MAX*tck_avg);\n                    end\n\t\t\t\t   \n                    \n                    tcl_avg = tcl_avg - tcl_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tcl_avg = tcl_avg + tcl_i/$itor(TDLLK);\n                    tcl_sample[ck_cntr%TDLLK] = tcl_i;\n\n                    \n                    tch_i <= $time - tm_ck_pos;\n                end\n                tm_ck_neg = $time;\n            end\n\n            \n            if (odt_en || dyn_odt_en) begin\n                \n                if (!in_self_refresh && diff_ck) begin\n                    if ($time - tm_odt < TIS)\n                        $display (\"%m: at time %t ERROR: tIS violation on ODT by %t\", $time, tm_odt + TIS - $time);\n                    if (prev_odt ^ odt_in) begin\n                        if (!dll_locked)\n                            $display (\"%m: at time %t WARNING: tDLLK violation during ODT transition.\", $time);\n                        if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))\n                            $display (\"%m: at time %t ERROR:  tMOD violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqinit < TZQINIT)\n                            $display (\"%m: at time %t ERROR: TZQinit violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqoper < TZQOPER)\n                            $display (\"%m: at time %t ERROR: TZQoper violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqcs < TZQCS)\n                            $display (\"%m: at time %t ERROR: tZQcs violation during ODT transition\", $time);\n                        \n                        \n                        if (ck_cntr - ck_self_refresh < TXSDLL)\n                            $display (\"%m: at time %t ERROR: tXSDLL violation during ODT transition\", $time);\n                        if (in_self_refresh)\n                            $display (\"%m: at time %t ERROR:  Illegal ODT transition during Self Refresh.\", $time);\n                        if (!odt_in && (ck_cntr - ck_odt < ODTH4))\n                            $display (\"%m: at time %t ERROR:  ODTH4 violation during ODT transition\", $time);\n                        if (!odt_in && (ck_cntr - ck_odth8 < ODTH8))\n                            $display (\"%m: at time %t ERROR:  ODTH8 violation during ODT transition\", $time);\n                        if (($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK))\n                            $display (\"%m: at time %t WARNING: tXPDLL during ODT transition.  Synchronous or asynchronous change in termination resistance is possible.\", $time);\n\n                        \n                        \n                        \n                        \n                        if ((in_power_down && low_power && (active_bank == 0)) || ($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK)) begin\n                            odt_state = odt_in;\n                            if (DEBUG && odt_en) $display (\"%m: at time %t INFO: Async On Die Termination Rtt_NOM = %d Ohm\", $time, {32{odt_state}} & get_rtt_nom(odt_rtt_nom));\n                            if (odt_state) begin\n                                odt_state_dly <= #(TAONPD) odt_state;\n                            end else begin\n                                odt_state_dly <= #(TAOFPD) odt_state;\n                            end\n                        \n                        \n                        \n                        \n                        end else begin\n                            odt_pipeline[2*(write_latency - 2)] = 1'b1; \n                        end\n                        ck_odt <= ck_cntr;\n                    end\n                end\n                if (odt_pipeline[0]) begin\n                    odt_state = ~odt_state;\n                    if (DEBUG && odt_en) $display (\"%m: at time %t INFO: Sync On Die Termination Rtt_NOM = %d Ohm\", $time, {32{odt_state}} & get_rtt_nom(odt_rtt_nom));\n                    if (odt_state) begin\n                        odt_state_dly <= #(TAON) odt_state;\n                    end else begin\n                        odt_state_dly <= #(TAOF*tck_avg) odt_state;\n                    end\n                end\n                if (rd_pipeline[RDQSEN_PRE]) begin\n                    odt_cntr = 1 + RDQSEN_PRE + bl_pipeline[RDQSEN_PRE] + RDQSEN_PST - 1;\n                end\n                if (odt_cntr > 0) begin\n                    if (odt_state) begin\n                        $display (\"%m: at time %t ERROR: On Die Termination must be OFF during Read data transfer.\", $time);\n                    end\n                    odt_cntr = odt_cntr - 1;\n                end\n                if (dyn_odt_en && odt_state) begin\n                    if (DEBUG && (dyn_odt_state ^ dyn_odt_pipeline[0]))\n                        $display (\"%m: at time %t INFO: Sync On Die Termination Rtt_WR = %d Ohm\", $time, {32{dyn_odt_pipeline[0]}} & get_rtt_wr(odt_rtt_wr));\n                    dyn_odt_state = dyn_odt_pipeline[0];\n                end \n                dyn_odt_state_dly <= #(TADC*tck_avg) dyn_odt_state; \n            end\n\n            if (cke_in && write_levelization) begin\n                for (i=0; i<DQS_BITS; i=i+1) begin\n                    if ($time - tm_dqs_pos[i] < TWLH)\n                        $display (\"%m: at time %t WARNING: tWLH violation on DQS bit %d positive edge.   Indeterminate CK capture is possible.\", $time, i);\n                end\n            end\n\n            \n            if (|wr_pipeline || |rd_pipeline || |al_pipeline) begin\n                al_pipeline = al_pipeline>>1;\n                wr_pipeline = wr_pipeline>>1;\n                rd_pipeline = rd_pipeline>>1;\n                for (i=0; i<`MAX_PIPE; i=i+1) begin\n                    bl_pipeline[i] = bl_pipeline[i+1];\n                    ba_pipeline[i] = ba_pipeline[i+1];\n                    row_pipeline[i] = row_pipeline[i+1];\n                    col_pipeline[i] = col_pipeline[i+1];\n                end\n            end\n            if (|odt_pipeline || |dyn_odt_pipeline) begin\n                odt_pipeline = odt_pipeline>>1;\n                dyn_odt_pipeline = dyn_odt_pipeline>>1;\n            end\n        end\n    end\n\n    \n    task dqs_even_receiver;\n        input [3:0] i;\n        reg [63:0] bit_mask;\n        begin\n            bit_mask = {`DQ_PER_DQS{1'b1}}<<(i*`DQ_PER_DQS);\n            if (dqs_even[i]) begin\n                if (tdqs_en) begin \n                    dm_in_pos[i] = 1'b0;\n                end else begin\n                    dm_in_pos[i] = dm_in[i];\n                end\n                dq_in_pos = (dq_in & bit_mask) | (dq_in_pos & ~bit_mask);\n            end\n        end\n    endtask\n\n    always @(posedge dqs_even[ 0]) dqs_even_receiver( 0);\n    always @(posedge dqs_even[ 1]) dqs_even_receiver( 1);\n    always @(posedge dqs_even[ 2]) dqs_even_receiver( 2);\n    always @(posedge dqs_even[ 3]) dqs_even_receiver( 3);\n    always @(posedge dqs_even[ 4]) dqs_even_receiver( 4);\n    always @(posedge dqs_even[ 5]) dqs_even_receiver( 5);\n    always @(posedge dqs_even[ 6]) dqs_even_receiver( 6);\n    always @(posedge dqs_even[ 7]) dqs_even_receiver( 7);\n    always @(posedge dqs_even[ 8]) dqs_even_receiver( 8);\n    always @(posedge dqs_even[ 9]) dqs_even_receiver( 9);\n    always @(posedge dqs_even[10]) dqs_even_receiver(10);\n    always @(posedge dqs_even[11]) dqs_even_receiver(11);\n    always @(posedge dqs_even[12]) dqs_even_receiver(12);\n    always @(posedge dqs_even[13]) dqs_even_receiver(13);\n    always @(posedge dqs_even[14]) dqs_even_receiver(14);\n    always @(posedge dqs_even[15]) dqs_even_receiver(15);\n\n    task dqs_odd_receiver;\n        input [3:0] i;\n        reg [63:0] bit_mask;\n        begin\n            bit_mask = {`DQ_PER_DQS{1'b1}}<<(i*`DQ_PER_DQS);\n            if (dqs_odd[i]) begin\n                if (tdqs_en) begin \n                    dm_in_neg[i] = 1'b0;\n                end else begin\n                    dm_in_neg[i] = dm_in[i];\n                end\n                dq_in_neg = (dq_in & bit_mask) | (dq_in_neg & ~bit_mask);\n            end\n        end\n    endtask\n\n    always @(posedge dqs_odd[ 0]) dqs_odd_receiver( 0);\n    always @(posedge dqs_odd[ 1]) dqs_odd_receiver( 1);\n    always @(posedge dqs_odd[ 2]) dqs_odd_receiver( 2);\n    always @(posedge dqs_odd[ 3]) dqs_odd_receiver( 3);\n    always @(posedge dqs_odd[ 4]) dqs_odd_receiver( 4);\n    always @(posedge dqs_odd[ 5]) dqs_odd_receiver( 5);\n    always @(posedge dqs_odd[ 6]) dqs_odd_receiver( 6);\n    always @(posedge dqs_odd[ 7]) dqs_odd_receiver( 7);\n    always @(posedge dqs_odd[ 8]) dqs_odd_receiver( 8);\n    always @(posedge dqs_odd[ 9]) dqs_odd_receiver( 9);\n    always @(posedge dqs_odd[10]) dqs_odd_receiver(10);\n    always @(posedge dqs_odd[11]) dqs_odd_receiver(11);\n    always @(posedge dqs_odd[12]) dqs_odd_receiver(12);\n    always @(posedge dqs_odd[13]) dqs_odd_receiver(13);\n    always @(posedge dqs_odd[14]) dqs_odd_receiver(14);\n    always @(posedge dqs_odd[15]) dqs_odd_receiver(15);\n\n    \n    always @(posedge rst_n_in) begin\n        if ($time > 100000) begin\n            if (tm_rst_n + 100000 > $time)\n                $display (\"%m: at time %t ERROR: RST_N pulse width violation by %t\", $time, tm_rst_n + 100000 - $time);\n        end\n        tm_rst_n = $time;\n    end\n    always @(cke_in) begin\n        if (rst_n_in) begin\n            if ($time > TIH) begin\n                if ($time - tm_ck_pos < TIH) \n                    $display (\"%m: at time %t ERROR:  tIH violation on CKE by %t\", $time, tm_ck_pos + TIH - $time);\n            end\n            if ($time - tm_cke < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on CKE by %t\", $time, tm_cke + TIPW - $time);\n        end\n        tm_cke = $time;\n    end\n    always @(odt_in) begin\n        if (rst_n_in && odt_en && !in_self_refresh) begin\n            if ($time - tm_ck_pos < TIH) \n                $display (\"%m: at time %t ERROR:  tIH violation on ODT by %t\", $time, tm_ck_pos + TIH - $time);\n            if ($time - tm_odt < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on ODT by %t\", $time, tm_odt + TIPW - $time);\n        end\n        tm_odt = $time;\n    end\n\n    task cmd_addr_timing_check;\n    input i;\n    reg [4:0] i;\n    begin\n        if (rst_n_in && prev_cke) begin\n            if ((i == 0) && ($time - tm_ck_pos < TIH))\t               \n                $display (\"%m: at time %t ERROR:  tIH violation on %s by %t\", $time, cmd_addr_string[i], tm_ck_pos + TIH - $time);\n            if ((i > 0) && (cs_n_in == 0) &&($time - tm_ck_pos < TIH)) \n                $display (\"%m: at time %t ERROR:  tIH violation on %s by %t\", $time, cmd_addr_string[i], tm_ck_pos + TIH - $time);\n            if ($time - tm_cmd_addr[i] < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on %s by %t\", $time, cmd_addr_string[i], tm_cmd_addr[i] + TIPW - $time);\n        end\n        tm_cmd_addr[i] = $time;\n    end\n    endtask\n\n    always @(cs_n_in    ) cmd_addr_timing_check( 0);\n    always @(ras_n_in   ) cmd_addr_timing_check( 1);\n    always @(cas_n_in   ) cmd_addr_timing_check( 2);\n    always @(we_n_in    ) cmd_addr_timing_check( 3);\n    always @(ba_in  [ 0]) cmd_addr_timing_check( 4);\n    always @(ba_in  [ 1]) cmd_addr_timing_check( 5);\n    always @(ba_in  [ 2]) cmd_addr_timing_check( 6);\n    always @(addr_in[ 0]) cmd_addr_timing_check( 7);\n    always @(addr_in[ 1]) cmd_addr_timing_check( 8);\n    always @(addr_in[ 2]) cmd_addr_timing_check( 9);\n    always @(addr_in[ 3]) cmd_addr_timing_check(10);\n    always @(addr_in[ 4]) cmd_addr_timing_check(11);\n    always @(addr_in[ 5]) cmd_addr_timing_check(12);\n    always @(addr_in[ 6]) cmd_addr_timing_check(13);\n    always @(addr_in[ 7]) cmd_addr_timing_check(14);\n    always @(addr_in[ 8]) cmd_addr_timing_check(15);\n    always @(addr_in[ 9]) cmd_addr_timing_check(16);\n    always @(addr_in[10]) cmd_addr_timing_check(17);\n    always @(addr_in[11]) cmd_addr_timing_check(18);\n    always @(addr_in[12]) cmd_addr_timing_check(19);\n    always @(addr_in[13]) cmd_addr_timing_check(20);\n    always @(addr_in[14]) cmd_addr_timing_check(21);\n    always @(addr_in[15]) cmd_addr_timing_check(22);\n\n    \n    task dm_timing_check;\n    input i;\n    reg [3:0] i;\n    begin\n        if (dqs_in_valid) begin\n            if ($time - tm_dqs[i] < TDH) \n                $display (\"%m: at time %t ERROR:   tDH violation on DM bit %d by %t\", $time, i, tm_dqs[i] + TDH - $time);\n            if (check_dm_tdipw[i]) begin\n                if ($time - tm_dm[i] < TDIPW)\n                    $display (\"%m: at time %t ERROR: tDIPW violation on DM bit %d by %t\", $time, i, tm_dm[i] + TDIPW - $time);\n            end\n        end\n        check_dm_tdipw[i] <= 1'b0;\n        tm_dm[i] = $time;\n    end\n    endtask\n\n    always @(dm_in[ 0]) dm_timing_check( 0);\n    always @(dm_in[ 1]) dm_timing_check( 1);\n    always @(dm_in[ 2]) dm_timing_check( 2);\n    always @(dm_in[ 3]) dm_timing_check( 3);\n    always @(dm_in[ 4]) dm_timing_check( 4);\n    always @(dm_in[ 5]) dm_timing_check( 5);\n    always @(dm_in[ 6]) dm_timing_check( 6);\n    always @(dm_in[ 7]) dm_timing_check( 7);\n    always @(dm_in[ 8]) dm_timing_check( 8);\n    always @(dm_in[ 9]) dm_timing_check( 9);\n    always @(dm_in[10]) dm_timing_check(10);\n    always @(dm_in[11]) dm_timing_check(11);\n    always @(dm_in[12]) dm_timing_check(12);\n    always @(dm_in[13]) dm_timing_check(13);\n    always @(dm_in[14]) dm_timing_check(14);\n    always @(dm_in[15]) dm_timing_check(15);\n\n    task dq_timing_check;\n    input i;\n    reg [5:0] i;\n    begin\n        if (dqs_in_valid) begin\n            if ($time - tm_dqs[i/`DQ_PER_DQS] < TDH) \n                $display (\"%m: at time %t ERROR:   tDH violation on DQ bit %d by %t\", $time, i, tm_dqs[i/`DQ_PER_DQS] + TDH - $time);\n            if (check_dq_tdipw[i]) begin\n                if ($time - tm_dq[i] < TDIPW)\n                    $display (\"%m: at time %t ERROR: tDIPW violation on DQ bit %d by %t\", $time, i, tm_dq[i] + TDIPW - $time);\n            end\n        end\n        check_dq_tdipw[i] <= 1'b0;\n        tm_dq[i] = $time;\n    end \n    endtask\n\n    always @(dq_in[ 0]) dq_timing_check( 0);\n    always @(dq_in[ 1]) dq_timing_check( 1);\n    always @(dq_in[ 2]) dq_timing_check( 2);\n    always @(dq_in[ 3]) dq_timing_check( 3);\n    always @(dq_in[ 4]) dq_timing_check( 4);\n    always @(dq_in[ 5]) dq_timing_check( 5);\n    always @(dq_in[ 6]) dq_timing_check( 6);\n    always @(dq_in[ 7]) dq_timing_check( 7);\n    always @(dq_in[ 8]) dq_timing_check( 8);\n    always @(dq_in[ 9]) dq_timing_check( 9);\n    always @(dq_in[10]) dq_timing_check(10);\n    always @(dq_in[11]) dq_timing_check(11);\n    always @(dq_in[12]) dq_timing_check(12);\n    always @(dq_in[13]) dq_timing_check(13);\n    always @(dq_in[14]) dq_timing_check(14);\n    always @(dq_in[15]) dq_timing_check(15);\n    always @(dq_in[16]) dq_timing_check(16);\n    always @(dq_in[17]) dq_timing_check(17);\n    always @(dq_in[18]) dq_timing_check(18);\n    always @(dq_in[19]) dq_timing_check(19);\n    always @(dq_in[20]) dq_timing_check(20);\n    always @(dq_in[21]) dq_timing_check(21);\n    always @(dq_in[22]) dq_timing_check(22);\n    always @(dq_in[23]) dq_timing_check(23);\n    always @(dq_in[24]) dq_timing_check(24);\n    always @(dq_in[25]) dq_timing_check(25);\n    always @(dq_in[26]) dq_timing_check(26);\n    always @(dq_in[27]) dq_timing_check(27);\n    always @(dq_in[28]) dq_timing_check(28);\n    always @(dq_in[29]) dq_timing_check(29);\n    always @(dq_in[30]) dq_timing_check(30);\n    always @(dq_in[31]) dq_timing_check(31);\n    always @(dq_in[32]) dq_timing_check(32);\n    always @(dq_in[33]) dq_timing_check(33);\n    always @(dq_in[34]) dq_timing_check(34);\n    always @(dq_in[35]) dq_timing_check(35);\n    always @(dq_in[36]) dq_timing_check(36);\n    always @(dq_in[37]) dq_timing_check(37);\n    always @(dq_in[38]) dq_timing_check(38);\n    always @(dq_in[39]) dq_timing_check(39);\n    always @(dq_in[40]) dq_timing_check(40);\n    always @(dq_in[41]) dq_timing_check(41);\n    always @(dq_in[42]) dq_timing_check(42);\n    always @(dq_in[43]) dq_timing_check(43);\n    always @(dq_in[44]) dq_timing_check(44);\n    always @(dq_in[45]) dq_timing_check(45);\n    always @(dq_in[46]) dq_timing_check(46);\n    always @(dq_in[47]) dq_timing_check(47);\n    always @(dq_in[48]) dq_timing_check(48);\n    always @(dq_in[49]) dq_timing_check(49);\n    always @(dq_in[50]) dq_timing_check(50);\n    always @(dq_in[51]) dq_timing_check(51);\n    always @(dq_in[52]) dq_timing_check(52);\n    always @(dq_in[53]) dq_timing_check(53);\n    always @(dq_in[54]) dq_timing_check(54);\n    always @(dq_in[55]) dq_timing_check(55);\n    always @(dq_in[56]) dq_timing_check(56);\n    always @(dq_in[57]) dq_timing_check(57);\n    always @(dq_in[58]) dq_timing_check(58);\n    always @(dq_in[59]) dq_timing_check(59);\n    always @(dq_in[60]) dq_timing_check(60);\n    always @(dq_in[61]) dq_timing_check(61);\n    always @(dq_in[62]) dq_timing_check(62);\n    always @(dq_in[63]) dq_timing_check(63);\n\n    task dqs_pos_timing_check;\n    input i;\n    reg [4:0] i;\n    reg [3:0] j;\n    begin\n        if (write_levelization && i<16) begin\n            if (ck_cntr - ck_load_mode < TWLMRD) \n                $display (\"%m: at time %t ERROR: tWLMRD violation on DQS bit %d positive edge.\", $time, i);\n            if (($time - tm_ck_pos < TWLS) || ($time - tm_ck_neg < TWLS))\n                $display (\"%m: at time %t WARNING: tWLS violation on DQS bit %d positive edge.  Indeterminate CK capture is possible.\", $time, i);\n            if (DEBUG) \n                $display (\"%m: at time %t Write Leveling @ DQS ck = %b\", $time, diff_ck);\n            dq_out_en_dly[i*`DQ_PER_DQS] <= #(TWLO) 1'b1;\n            dq_out_dly[i*`DQ_PER_DQS] <= #(TWLO) diff_ck;\n            for (j=1; j<`DQ_PER_DQS; j=j+1) begin\n                dq_out_en_dly[i*`DQ_PER_DQS+j] <= #(TWLO + TWLOE) 1'b1;\n                dq_out_dly[i*`DQ_PER_DQS+j] <= #(TWLO + TWLOE) 1'b0;\n            end\n        end\n        if (dqs_in_valid && ((wdqs_pos_cntr[i] < wr_burst_length/2) || b2b_write)) begin\n            if (dqs_in[i] ^ prev_dqs_in[i]) begin\n                if (dll_locked) begin\n                    if (check_write_preamble[i]) begin\n                        if ($time - tm_dqs_pos[i] < $rtoi(TWPRE*tck_avg))\n                            $display (\"%m: at time %t ERROR: tWPRE violation on &s bit %d\", $time, dqs_string[i/16], i%16);\n                    end else if (check_write_postamble[i]) begin\n                        if ($time - tm_dqs_neg[i] < $rtoi(TWPST*tck_avg))\n                            $display (\"%m: at time %t ERROR: tWPST violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    end else begin\n                        if ($time - tm_dqs_neg[i] < $rtoi(TDQSL*tck_avg))\n                            $display (\"%m: at time %t ERROR: tDQSL violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    end\n                end\n                if ($time - tm_dm[i%16] < TDS) \n                    $display (\"%m: at time %t ERROR: tDS violation on DM bit %d by %t\", $time, i,  tm_dm[i%16] + TDS - $time);\n                if (!dq_out_en) begin\n                    for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                        if ($time - tm_dq[(i%16)*`DQ_PER_DQS+j] < TDS) \n                            $display (\"%m: at time %t ERROR: tDS violation on DQ bit %d by %t\", $time, i*`DQ_PER_DQS+j, tm_dq[(i%16)*`DQ_PER_DQS+j] + TDS - $time);\n                        check_dq_tdipw[(i%16)*`DQ_PER_DQS+j] <= 1'b1;\n                    end\n                end\n                if ((wdqs_pos_cntr[i] < wr_burst_length/2) && !b2b_write) begin\n                    wdqs_pos_cntr[i] <= wdqs_pos_cntr[i] + 1;\n                end else begin\n                    wdqs_pos_cntr[i] <= 1;\n                end\n                check_dm_tdipw[i%16] <= 1'b1;\n                check_write_preamble[i] <= 1'b0;\n                check_write_postamble[i] <= 1'b0;\n                check_write_dqs_low[i] <= 1'b0;\n                tm_dqs[i%16] <= $time;\n            end else begin\n                $display (\"%m: at time %t ERROR: Invalid latching edge on %s bit %d\", $time, dqs_string[i/16], i%16);\n            end\n        end\n        tm_dqss_pos[i] <= $time;\n        tm_dqs_pos[i] = $time;\n        prev_dqs_in[i] <= dqs_in[i];\n    end\n    endtask\n\n    always @(posedge dqs_in[ 0]) dqs_pos_timing_check( 0);\n    always @(posedge dqs_in[ 1]) dqs_pos_timing_check( 1);\n    always @(posedge dqs_in[ 2]) dqs_pos_timing_check( 2);\n    always @(posedge dqs_in[ 3]) dqs_pos_timing_check( 3);\n    always @(posedge dqs_in[ 4]) dqs_pos_timing_check( 4);\n    always @(posedge dqs_in[ 5]) dqs_pos_timing_check( 5);\n    always @(posedge dqs_in[ 6]) dqs_pos_timing_check( 6);\n    always @(posedge dqs_in[ 7]) dqs_pos_timing_check( 7);\n    always @(posedge dqs_in[ 8]) dqs_pos_timing_check( 8);\n    always @(posedge dqs_in[ 9]) dqs_pos_timing_check( 9);\n    always @(posedge dqs_in[10]) dqs_pos_timing_check(10);\n    always @(posedge dqs_in[11]) dqs_pos_timing_check(11);\n    always @(posedge dqs_in[12]) dqs_pos_timing_check(12);\n    always @(posedge dqs_in[13]) dqs_pos_timing_check(13);\n    always @(posedge dqs_in[14]) dqs_pos_timing_check(14);\n    always @(posedge dqs_in[15]) dqs_pos_timing_check(15);\n    always @(negedge dqs_in[16]) dqs_pos_timing_check(16);\n    always @(negedge dqs_in[17]) dqs_pos_timing_check(17);\n    always @(negedge dqs_in[18]) dqs_pos_timing_check(18);\n    always @(negedge dqs_in[19]) dqs_pos_timing_check(19);\n    always @(negedge dqs_in[20]) dqs_pos_timing_check(20);\n    always @(negedge dqs_in[21]) dqs_pos_timing_check(21);\n    always @(negedge dqs_in[22]) dqs_pos_timing_check(22);\n    always @(negedge dqs_in[23]) dqs_pos_timing_check(23);\n    always @(negedge dqs_in[24]) dqs_pos_timing_check(24);\n    always @(negedge dqs_in[25]) dqs_pos_timing_check(25);\n    always @(negedge dqs_in[26]) dqs_pos_timing_check(26);\n    always @(negedge dqs_in[27]) dqs_pos_timing_check(27);\n    always @(negedge dqs_in[28]) dqs_pos_timing_check(28);\n    always @(negedge dqs_in[29]) dqs_pos_timing_check(29);\n    always @(negedge dqs_in[30]) dqs_pos_timing_check(30);\n    always @(negedge dqs_in[31]) dqs_pos_timing_check(31);\n\n    task dqs_neg_timing_check;\n    input i;\n    reg [4:0] i;\n    reg [3:0] j;\n    begin\n        if (write_levelization && i<16) begin\n            if (ck_cntr - ck_load_mode < TWLDQSEN)\n                $display (\"%m: at time %t ERROR: tWLDQSEN violation on DQS bit %d.\", $time, i);\n            if ($time - tm_dqs_pos[i] < $rtoi(TDQSH*tck_avg))\n                $display (\"%m: at time %t ERROR: tDQSH violation on DQS bit %d by %t\", $time, i, tm_dqs_pos[i] + TDQSH*tck_avg - $time);\n        end\n        if (dqs_in_valid && (wdqs_pos_cntr[i] > 0) && check_write_dqs_high[i]) begin\n            if (dqs_in[i] ^ prev_dqs_in[i]) begin\n                if (dll_locked) begin\n                    if ($time - tm_dqs_pos[i] < $rtoi(TDQSH*tck_avg))\n                        $display (\"%m: at time %t ERROR: tDQSH violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    if ($time - tm_ck_pos < $rtoi(TDSH*tck_avg))\n                        $display (\"%m: at time %t ERROR: tDSH violation on %s bit %d\", $time, dqs_string[i/16], i%16); \n                end\n                if ($time - tm_dm[i%16] < TDS) \n                    $display (\"%m: at time %t ERROR: tDS violation on DM bit %d by %t\", $time, i,  tm_dm[i%16] + TDS - $time);\n                if (!dq_out_en) begin\n                    for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                        if ($time - tm_dq[(i%16)*`DQ_PER_DQS+j] < TDS) \n                            $display (\"%m: at time %t ERROR: tDS violation on DQ bit %d by %t\", $time, i*`DQ_PER_DQS+j, tm_dq[(i%16)*`DQ_PER_DQS+j] + TDS - $time);\n                        check_dq_tdipw[(i%16)*`DQ_PER_DQS+j] <= 1'b1;\n                    end\n                end\n                check_dm_tdipw[i%16] <= 1'b1;\n                tm_dqs[i%16] <= $time;\n            end else begin\n                $display (\"%m: at time %t ERROR: Invalid latching edge on %s bit %d\", $time, dqs_string[i/16], i%16);\n            end\n        end\n        check_write_dqs_high[i] <= 1'b0;\n        tm_dqs_neg[i] = $time;\n        prev_dqs_in[i] <= dqs_in[i];\n    end\n    endtask\n\n    always @(negedge dqs_in[ 0]) dqs_neg_timing_check( 0);\n    always @(negedge dqs_in[ 1]) dqs_neg_timing_check( 1);\n    always @(negedge dqs_in[ 2]) dqs_neg_timing_check( 2);\n    always @(negedge dqs_in[ 3]) dqs_neg_timing_check( 3);\n    always @(negedge dqs_in[ 4]) dqs_neg_timing_check( 4);\n    always @(negedge dqs_in[ 5]) dqs_neg_timing_check( 5);\n    always @(negedge dqs_in[ 6]) dqs_neg_timing_check( 6);\n    always @(negedge dqs_in[ 7]) dqs_neg_timing_check( 7);\n    always @(negedge dqs_in[ 8]) dqs_neg_timing_check( 8);\n    always @(negedge dqs_in[ 9]) dqs_neg_timing_check( 9);\n    always @(negedge dqs_in[10]) dqs_neg_timing_check(10);\n    always @(negedge dqs_in[11]) dqs_neg_timing_check(11);\n    always @(negedge dqs_in[12]) dqs_neg_timing_check(12);\n    always @(negedge dqs_in[13]) dqs_neg_timing_check(13);\n    always @(negedge dqs_in[14]) dqs_neg_timing_check(14);\n    always @(negedge dqs_in[15]) dqs_neg_timing_check(15);\n    always @(posedge dqs_in[16]) dqs_neg_timing_check(16);\n    always @(posedge dqs_in[17]) dqs_neg_timing_check(17);\n    always @(posedge dqs_in[18]) dqs_neg_timing_check(18);\n    always @(posedge dqs_in[19]) dqs_neg_timing_check(19);\n    always @(posedge dqs_in[20]) dqs_neg_timing_check(20);\n    always @(posedge dqs_in[21]) dqs_neg_timing_check(21);\n    always @(posedge dqs_in[22]) dqs_neg_timing_check(22);\n    always @(posedge dqs_in[23]) dqs_neg_timing_check(23);\n    always @(posedge dqs_in[24]) dqs_neg_timing_check(24);\n    always @(posedge dqs_in[25]) dqs_neg_timing_check(25);\n    always @(posedge dqs_in[26]) dqs_neg_timing_check(26);\n    always @(posedge dqs_in[27]) dqs_neg_timing_check(27);\n    always @(posedge dqs_in[28]) dqs_neg_timing_check(28);\n    always @(posedge dqs_in[29]) dqs_neg_timing_check(29);\n    always @(posedge dqs_in[30]) dqs_neg_timing_check(30);\n    always @(posedge dqs_in[31]) dqs_neg_timing_check(31);\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: ddr3_model_c3. Module specification: This module simulates a DDR3 SDRAM memory device, implementing features such as initialization sequence, mode register settings, refresh operations, power-down modes, and various timing checks. It has input ports for control signals (rst_n, ck, ck_n, cke, cs_n, ras_n, cas_n, we_n), address and bank selection (ba, addr), data mask/termination (dm_tdqs), and data I/O (dq, dqs, dqs_n), with an output port for termination (tdqs_n). The module uses internal signals to track timing parameters, manage operation modes, and control data transfer. Key internal components include clock timing management, command decoding and execution, data read/write operations, and extensive timing checks to ensure compliance with DDR3 SDRAM specifications."
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: ddr3_model_c3.\n\nExplanation: This module represents a DDR3 SDRAM memory model. It simulates the behavior and timing of a DDR3 memory device, including command processing, data read/write operations, and various timing checks. The module implements features such as initialization sequence, mode register settings, refresh operations, and power-down modes. It also performs extensive timing checks to ensure compliance with DDR3 SDRAM specifications, including setup and hold times, clock jitter, and various other timing parameters. The model supports multiple banks, burst operations, and ODT (On-Die Termination) functionality."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nrst_n, ck, ck_n, cke, cs_n, ras_n, cas_n, we_n, ba, addr, odt, dm_tdqs (inout), dq (inout), dqs (inout), dqs_n (inout).\n\nExplanation:\n- rst_n: Active-low reset signal\n- ck, ck_n: Differential clock inputs\n- cke: Clock enable\n- cs_n, ras_n, cas_n, we_n: Command inputs (chip select, row address strobe, column address strobe, write enable)\n- ba: Bank address input\n- addr: Address input\n- odt: On-die termination control\n- dm_tdqs: Data mask (input) / termination data strobe (inout)\n- dq: Data bus (inout)\n- dqs, dqs_n: Data strobe (inout)\n\nOutput ports:\ntdqs_n (output)\n\nExplanation:\n- tdqs_n: Termination data strobe (negative)\n\nThe module uses these ports to simulate DDR3 SDRAM behavior, including command decoding, data transfer, and timing checks. Inout ports (dm_tdqs, dq, dqs, dqs_n) allow bidirectional data transfer, while the single output port (tdqs_n) is used for termination purposes."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\n1. tck_avg\n2. tck_sample\n3. tch_sample\n4. tcl_sample\n5. tck_i\n6. tch_i\n7. tcl_i\n8. tch_avg\n9. tcl_avg\n10. tm_ck_pos\n11. tm_ck_neg\n12. tjit_per_rtime\n13. tjit_cc_time\n14. terr_nper_rtime\n15. tjit_ch_rtime\n16. duty_cycle\n17. out_delay\n18. dqsck\n19. dqsck_min\n20. dqsck_max\n21. dqsq_min\n22. dqsq_max\n23. seed\n24. mode_reg\n25. burst_order\n26. burst_length\n27. blotf\n28. truebl4\n29. cas_latency\n30. dll_reset\n31. dll_locked\n32. write_recovery\n33. low_power\n34. dll_en\n35. odt_rtt_nom\n36. odt_rtt_wr\n37. odt_en\n38. dyn_odt_en\n39. al\n40. additive_latency\n41. write_levelization\n42. duty_cycle_corrector\n43. tdqs_en\n44. out_en\n45. pasr\n46. cas_write_latency\n47. asr\n48. srt\n49. mpr_select\n50. mpr_en\n51. odts_readout\n52. read_latency\n53. write_latency\n\nExplanation:\n1. tck_avg: Average clock period\n2-4. tck_sample, tch_sample, tcl_sample: Arrays to store clock timing samples\n5-7. tck_i, tch_i, tcl_i: Instantaneous clock timing values\n8-9. tch_avg, tcl_avg: Average high and low clock times\n10-11. tm_ck_pos, tm_ck_neg: Timestamps for positive and negative clock edges\n12-15. tjit_per_rtime, tjit_cc_time, terr_nper_rtime, tjit_ch_rtime: Jitter and error timing values\n16. duty_cycle: Clock duty cycle\n17. out_delay: Output delay value\n18-22. dqsck, dqsck_min, dqsck_max, dqsq_min, dqsq_max: DQS to CK timing parameters\n23. seed: Random seed for timing variations\n24. mode_reg: Mode register settings\n25-27. burst_order, burst_length, blotf: Burst-related parameters\n28. truebl4: True BL4 mode flag\n29-32. cas_latency, dll_reset, dll_locked, write_recovery: Timing and control parameters\n33-34. low_power, dll_en: Power and DLL control flags\n35-37. odt_rtt_nom, odt_rtt_wr, odt_en: On-Die Termination parameters\n38. dyn_odt_en: Dynamic ODT enable flag\n39-40. al, additive_latency: Additive latency parameters\n41-42. write_levelization, duty_cycle_corrector: Write leveling and duty cycle correction flags\n43-44. tdqs_en, out_en: Output enable flags\n45. pasr: Partial Array Self-Refresh parameter\n46. cas_write_latency: CAS Write Latency\n47-48. asr, srt: Auto Self-Refresh and Self-Refresh Temperature flags\n49-51. mpr_select, mpr_en, odts_readout: Multi-Purpose Register parameters\n52-53. read_latency, write_latency: Read and write latency values\n\nThese internal signals are used to control various aspects of the DDR3 SDRAM operation, including timing, mode settings, and performance parameters."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ps / 1ps\n\n\n\n\nmodule ddr3_model_c3(\n    rst_n,\n    ck,\n    ck_n,\n    cke,\n    cs_n,\n    ras_n,\n    cas_n,\n    we_n,\n    dm_tdqs,\n    ba,\n    addr,\n    dq,\n    dqs,\n    dqs_n,\n    tdqs_n,\n    odt\n);\n\n    `include \"ddr3_model_parameters_c3.vh\"\n\n    parameter check_strict_mrbits = 1;\n    parameter check_strict_timing = 1;\n    parameter feature_pasr = 1;\n    parameter feature_truebl4 = 0;\n   \n    \n    `define DQ_PER_DQS DQ_BITS/DQS_BITS\n    `define BANKS      (1<<BA_BITS)\n    `define MAX_BITS   (BA_BITS+ROW_BITS+COL_BITS-BL_BITS)\n    `define MAX_SIZE   (1<<(BA_BITS+ROW_BITS+COL_BITS-BL_BITS))\n    `define MEM_SIZE   (1<<MEM_BITS)\n    `define MAX_PIPE   4*CL_MAX\n\n    \n    input   rst_n;\n    input   ck;\n    input   ck_n;\n    input   cke;\n    input   cs_n;\n    input   ras_n;\n    input   cas_n;\n    input   we_n;\n    inout   [DM_BITS-1:0]   dm_tdqs;\n    input   [BA_BITS-1:0]   ba;\n    input   [ADDR_BITS-1:0] addr;\n    inout   [DQ_BITS-1:0]   dq;\n    inout   [DQS_BITS-1:0]  dqs;\n    inout   [DQS_BITS-1:0]  dqs_n;\n    output  [DQS_BITS-1:0]  tdqs_n;\n    input   odt;\n\n    \n    real    tck_avg;\n    time    tck_sample [TDLLK-1:0];\n    time    tch_sample [TDLLK-1:0];\n    time    tcl_sample [TDLLK-1:0];\n    time    tck_i;\n    time    tch_i;\n    time    tcl_i;\n    real    tch_avg;\n    real    tcl_avg;\n    time    tm_ck_pos;\n    time    tm_ck_neg;\n    real    tjit_per_rtime;\n    integer tjit_cc_time;\n    real    terr_nper_rtime;\n    \n    real    tjit_ch_rtime;\n    real    duty_cycle;\n\n    \n    real    out_delay;\n    integer dqsck [DQS_BITS-1:0];\n    integer dqsck_min;\n    integer dqsck_max;\n    integer dqsq_min;\n    integer dqsq_max;\n    integer seed;\n\n    \n    reg     [ADDR_BITS-1:0] mode_reg [`BANKS-1:0];\n    reg     burst_order;\n    reg     [BL_BITS:0] burst_length;\n    reg     blotf;\n    reg     truebl4;\n    integer cas_latency;\n    reg     dll_reset;\n    reg     dll_locked;\n    integer write_recovery;\n    reg     low_power;\n    reg     dll_en;\n    reg     [2:0] odt_rtt_nom;\n    reg     [1:0] odt_rtt_wr;\n    reg     odt_en;\n    reg     dyn_odt_en;\n    reg     [1:0] al;\n    integer additive_latency;\n    reg     write_levelization;\n    reg     duty_cycle_corrector;\n    reg     tdqs_en;\n    reg     out_en;\n    reg     [2:0] pasr;\n    integer cas_write_latency;\n    reg     asr; \n    reg     srt; \n    reg     [1:0] mpr_select;\n    reg     mpr_en;\n    reg     odts_readout;\n    integer read_latency;\n    integer write_latency;\n\n    \n    parameter     \n        LOAD_MODE = 4'b0000,\n        REFRESH   = 4'b0001,\n        PRECHARGE = 4'b0010,\n        ACTIVATE  = 4'b0011,\n        WRITE     = 4'b0100,\n        READ      = 4'b0101,\n        ZQ        = 4'b0110,\n        NOP       = 4'b0111,\n        \n        PWR_DOWN  = 4'b1000,\n        SELF_REF  = 4'b1001\n    ;\n\n    reg [8*9-1:0] cmd_string [9:0];\n    initial begin\n        cmd_string[LOAD_MODE] = \"Load Mode\";\n        cmd_string[REFRESH  ] = \"Refresh  \";\n        cmd_string[PRECHARGE] = \"Precharge\";\n        cmd_string[ACTIVATE ] = \"Activate \";\n        cmd_string[WRITE    ] = \"Write    \";\n        cmd_string[READ     ] = \"Read     \";\n        cmd_string[ZQ       ] = \"ZQ       \";\n        cmd_string[NOP      ] = \"No Op    \";\n        cmd_string[PWR_DOWN ] = \"Pwr Down \";\n        cmd_string[SELF_REF ] = \"Self Ref \";\n    end\n\n    \n    reg     [`BANKS-1:0] active_bank;\n    reg     [`BANKS-1:0] auto_precharge_bank;\n    reg     [`BANKS-1:0] write_precharge_bank;\n    reg     [`BANKS-1:0] read_precharge_bank;\n    reg     [ROW_BITS-1:0] active_row [`BANKS-1:0];\n    reg     in_power_down;\n    reg     in_self_refresh;\n    reg     [3:0] init_mode_reg;\n    reg     init_dll_reset;\n    reg     init_done;\n    integer init_step;\n    reg     zq_set;\n    reg     er_trfc_max;\n    reg     odt_state;\n    reg     odt_state_dly;\n    reg     dyn_odt_state;\n    reg     dyn_odt_state_dly;\n    reg     prev_odt;\n    wire    [7:0] calibration_pattern = 8'b10101010; \n    wire    [7:0] temp_sensor = 8'h01; \n    reg     [1:0] mr_chk;\n    reg     rd_bc;\n    integer banki;\n\n\n\n    \n    integer ref_cntr;\n    integer odt_cntr;\n    integer ck_cntr;\n    integer ck_txpr;\n    integer ck_load_mode;\n    integer ck_refresh;\n    integer ck_precharge;\n    integer ck_activate;\n    integer ck_write;\n    integer ck_read;\n    integer ck_zqinit;\n    integer ck_zqoper;\n    integer ck_zqcs;\n    integer ck_power_down;\n    integer ck_slow_exit_pd;\n    integer ck_self_refresh;\n    integer ck_freq_change;\n    integer ck_odt;\n    integer ck_odth8;\n    integer ck_dll_reset;\n    integer ck_cke_cmd;\n    integer ck_bank_write     [`BANKS-1:0];\n    integer ck_bank_read      [`BANKS-1:0];\n    integer ck_group_activate [1:0];\n    integer ck_group_write    [1:0];\n    integer ck_group_read     [1:0];\n    time    tm_txpr;\n    time    tm_load_mode;\n    time    tm_refresh;\n    time    tm_precharge;\n    time    tm_activate;\n    time    tm_write_end;\n    time    tm_power_down;\n    time    tm_slow_exit_pd;\n    time    tm_self_refresh;\n    time    tm_freq_change;\n    time    tm_cke_cmd;\n    time    tm_ttsinit;\n    time    tm_bank_precharge [`BANKS-1:0];\n    time    tm_bank_activate  [`BANKS-1:0];\n    time    tm_bank_write_end [`BANKS-1:0];\n    time    tm_bank_read_end  [`BANKS-1:0];\n    time    tm_group_activate  [1:0];\n    time    tm_group_write_end [1:0];\n\n    \n    reg     [`MAX_PIPE:0]  al_pipeline;\n    reg     [`MAX_PIPE:0]  wr_pipeline;\n    reg     [`MAX_PIPE:0]  rd_pipeline;\n    reg     [`MAX_PIPE:0]  odt_pipeline;\n    reg     [`MAX_PIPE:0]  dyn_odt_pipeline;\n    reg     [BL_BITS:0]    bl_pipeline  [`MAX_PIPE:0];\n    reg     [BA_BITS-1:0]  ba_pipeline  [`MAX_PIPE:0];\n    reg     [ROW_BITS-1:0] row_pipeline [`MAX_PIPE:0];\n    reg     [COL_BITS-1:0] col_pipeline [`MAX_PIPE:0];\n    reg     prev_cke;\n\n    \n    reg     [BL_MAX*DQ_BITS-1:0] memory_data;\n    reg     [BL_MAX*DQ_BITS-1:0] bit_mask;\n    reg     [BL_BITS-1:0]        burst_position;\n    reg     [BL_BITS:0]          burst_cntr;\n    reg     [DQ_BITS-1:0]        dq_temp;\n    reg     [31:0] check_write_postamble;\n    reg     [31:0] check_write_preamble;\n    reg     [31:0] check_write_dqs_high;\n    reg     [31:0] check_write_dqs_low;\n    reg     [15:0] check_dm_tdipw;\n    reg     [63:0] check_dq_tdipw;\n\n    \n    time    tm_rst_n;\n    time    tm_cke;\n    time    tm_odt;\n    time    tm_tdqss;\n    time    tm_dm       [15:0];\n    time    tm_dqs      [15:0];\n    time    tm_dqs_pos  [31:0];\n    time    tm_dqss_pos [31:0];\n    time    tm_dqs_neg  [31:0];\n    time    tm_dq       [63:0];\n    time    tm_cmd_addr [22:0];\n    reg [8*7-1:0] cmd_addr_string [22:0];\n    initial begin\n        cmd_addr_string[ 0] = \"CS_N   \";\n        cmd_addr_string[ 1] = \"RAS_N  \";\n        cmd_addr_string[ 2] = \"CAS_N  \";\n        cmd_addr_string[ 3] = \"WE_N   \";\n        cmd_addr_string[ 4] = \"BA 0   \";\n        cmd_addr_string[ 5] = \"BA 1   \";\n        cmd_addr_string[ 6] = \"BA 2   \";\n        cmd_addr_string[ 7] = \"ADDR  0\";\n        cmd_addr_string[ 8] = \"ADDR  1\";\n        cmd_addr_string[ 9] = \"ADDR  2\";\n        cmd_addr_string[10] = \"ADDR  3\";\n        cmd_addr_string[11] = \"ADDR  4\";\n        cmd_addr_string[12] = \"ADDR  5\";\n        cmd_addr_string[13] = \"ADDR  6\";\n        cmd_addr_string[14] = \"ADDR  7\";\n        cmd_addr_string[15] = \"ADDR  8\";\n        cmd_addr_string[16] = \"ADDR  9\";\n        cmd_addr_string[17] = \"ADDR 10\";\n        cmd_addr_string[18] = \"ADDR 11\";\n        cmd_addr_string[19] = \"ADDR 12\";\n        cmd_addr_string[20] = \"ADDR 13\";\n        cmd_addr_string[21] = \"ADDR 14\";\n        cmd_addr_string[22] = \"ADDR 15\";\n    end\n\n    reg [8*5-1:0] dqs_string [1:0];\n    initial begin\n        dqs_string[0] = \"DQS  \";\n        dqs_string[1] = \"DQS_N\";\n    end\n\n    \n`ifdef MAX_MEM\n    parameter RFF_BITS = DQ_BITS*BL_MAX;\n     \n    parameter RFF_CHUNK = 8 * (RFF_BITS/32 + (RFF_BITS%32 ? 1 : 0));\n    reg [1024:1] tmp_model_dir;\n    integer memfd[`BANKS-1:0];\n\n    initial\n    begin : file_io_open\n        integer bank;\n\n        if (!$value$plusargs(\"model_data+%s\", tmp_model_dir))\n        begin\n            tmp_model_dir = \"/tmp\";\n            $display(\n                \"%m: at time %t WARNING: no +model_data option specified, using /tmp.\",\n                $time\n            );\n        end\n\n        for (bank = 0; bank < `BANKS; bank = bank + 1)\n            memfd[bank] = open_bank_file(bank);\n    end\n`else\n    reg     [BL_MAX*DQ_BITS-1:0] memory  [0:`MEM_SIZE-1];\n    reg     [`MAX_BITS-1:0]      address [0:`MEM_SIZE-1];\n    reg     [MEM_BITS:0]         memory_index;\n    reg     [MEM_BITS:0]         memory_used = 0;\n`endif\n\n    \n    reg            rst_n_in;\n    reg            ck_in;\n    reg            ck_n_in;\n    reg            cke_in;\n    reg            cs_n_in;\n    reg            ras_n_in;\n    reg            cas_n_in;\n    reg            we_n_in;\n    reg     [15:0] dm_in;\n    reg     [2:0]  ba_in;\n    reg     [15:0] addr_in;\n    reg     [63:0] dq_in;\n    reg     [31:0] dqs_in;\n    reg            odt_in;\n\n    reg     [15:0] dm_in_pos;\n    reg     [15:0] dm_in_neg;\n    reg     [63:0] dq_in_pos;\n    reg     [63:0] dq_in_neg;\n    reg            dq_in_valid;\n    reg            dqs_in_valid;\n    integer        wdqs_cntr;\n    integer        wdq_cntr;\n    integer        wdqs_pos_cntr [31:0];\n    reg            b2b_write;\n    reg [BL_BITS:0] wr_burst_length;\n    reg     [31:0] prev_dqs_in;\n    reg            diff_ck;\n\n    always @(rst_n  ) rst_n_in   <= #BUS_DELAY rst_n;\n    always @(ck     ) ck_in      <= #BUS_DELAY ck;\n    always @(ck_n   ) ck_n_in    <= #BUS_DELAY ck_n;\n    always @(cke    ) cke_in     <= #BUS_DELAY cke;\n    always @(cs_n   ) cs_n_in    <= #BUS_DELAY cs_n;\n    always @(ras_n  ) ras_n_in   <= #BUS_DELAY ras_n;\n    always @(cas_n  ) cas_n_in   <= #BUS_DELAY cas_n;\n    always @(we_n   ) we_n_in    <= #BUS_DELAY we_n;\n    always @(dm_tdqs) dm_in      <= #BUS_DELAY dm_tdqs;\n    always @(ba     ) ba_in      <= #BUS_DELAY ba;\n    always @(addr   ) addr_in    <= #BUS_DELAY addr;\n    always @(dq     ) dq_in      <= #BUS_DELAY dq;\n    always @(dqs or dqs_n) dqs_in <= #BUS_DELAY (dqs_n<<16) | dqs;\n    always @(odt    ) odt_in     <= #BUS_DELAY odt;\n    \n    always @(posedge ck_in) diff_ck <= ck_in;\n    always @(posedge ck_n_in) diff_ck <= ~ck_n_in;\n    \n    wire    [15:0] dqs_even = dqs_in[15:0];\n    wire    [15:0] dqs_odd  = dqs_in[31:16];\n    wire    [3:0]  cmd_n_in = !cs_n_in ? {ras_n_in, cas_n_in, we_n_in} : NOP;  \n\n    \n    reg                    dqs_out_en;\n    reg     [DQS_BITS-1:0] dqs_out_en_dly;\n    reg                    dqs_out;\n    reg     [DQS_BITS-1:0] dqs_out_dly;\n    reg                    dq_out_en;\n    reg     [DQ_BITS-1:0]  dq_out_en_dly;\n    reg     [DQ_BITS-1:0]  dq_out;\n    reg     [DQ_BITS-1:0]  dq_out_dly;\n    integer                rdqsen_cntr;\n    integer                rdqs_cntr;\n    integer                rdqen_cntr;\n    integer                rdq_cntr;\n\n    bufif1 buf_dqs    [DQS_BITS-1:0] (dqs,     dqs_out_dly,  dqs_out_en_dly & {DQS_BITS{out_en}});\n    bufif1 buf_dqs_n  [DQS_BITS-1:0] (dqs_n,   ~dqs_out_dly, dqs_out_en_dly & {DQS_BITS{out_en}});\n    bufif1 buf_dq     [DQ_BITS-1:0]  (dq,      dq_out_dly,   dq_out_en_dly  & {DQ_BITS {out_en}});\n    assign tdqs_n = {DQS_BITS{1'bz}};\n\n    initial begin\n        if (BL_MAX < 2) \n            $display(\"%m ERROR: BL_MAX parameter must be >= 2.  \\nBL_MAX = %d\", BL_MAX);\n        if ((1<<BO_BITS) > BL_MAX) \n            $display(\"%m ERROR: 2^BO_BITS cannot be greater than BL_MAX parameter.\");\n\n        $timeformat (-12, 1, \" ps\", 1);\n        seed = RANDOM_SEED;\n\n        ck_cntr = 0;\n    end\n\n    function integer get_rtt_wr;\n    input [1:0] rtt;\n    begin\n        get_rtt_wr = RZQ/{rtt[0], rtt[1], 1'b0};\n    end\n    endfunction\n\n    function integer get_rtt_nom;\n    input [2:0] rtt;\n    begin\n        case (rtt)\n            1: get_rtt_nom = RZQ/4;\n            2: get_rtt_nom = RZQ/2;\n            3: get_rtt_nom = RZQ/6;\n            4: get_rtt_nom = RZQ/12;\n            5: get_rtt_nom = RZQ/8;\n            default : get_rtt_nom = 0;\n        endcase\n    end\n    endfunction\n\n    \n    function real abs_value;\n    input arg;\n    real arg;\n    begin\n        if (arg < 0.0)\n            abs_value = -1.0 * arg;\n        else\n            abs_value = arg;\n    end\n    endfunction\n\n    function integer ceil;\n        input number;\n        real number;\n\n        \n        \n        \n        if (number > $rtoi(number))\n            ceil = $rtoi(number) + 1;\n        else\n            ceil = number;\n    endfunction\n\n    function integer floor;\n        input number;\n        real number;\n\n        \n        \n        \n        if (number < $rtoi(number))\n            floor = $rtoi(number) - 1;\n        else\n            floor = number;\n    endfunction\n\n`ifdef MAX_MEM\n\n    function integer open_bank_file( input integer bank );\n        integer fd;\n        reg [2048:1] filename;\n        begin \n            $sformat( filename, \"%0s/%m.%0d\", tmp_model_dir, bank );\n\n            fd = $fopen(filename, \"w+\");\n            if (fd == 0)\n            begin\n                $display(\"%m: at time %0t ERROR: failed to open %0s.\", $time, filename);\n                $finish;\n            end\n            else\n            begin\n                if (DEBUG) $display(\"%m: at time %0t INFO: opening %0s.\", $time, filename);\n                open_bank_file = fd;\n            end\n\n        end\n    endfunction\n\n    function [RFF_BITS:1] read_from_file( \n        input integer fd, \n        input integer index \n    );\n        integer code;\n        integer offset;\n        reg [1024:1] msg;\n        reg [RFF_BITS:1] read_value;\n    \n        begin\n            offset = index * RFF_CHUNK;\n            code = $fseek( fd, offset, 0 );\n            \n            if (code != 0)\n            begin\n                $display(\"%m: at time %t ERROR: fseek to %d failed\", $time, offset);\n                $finish;\n            end\n        \n            code = $fscanf(fd, \"%z\", read_value);\n            \n            if (code != 1)\n            begin\n                if ($ferror(fd,msg) != 0)\n                begin\n                    $display(\"%m: at time %t ERROR: fscanf failed at %d\", $time, index);\n                    $display(msg);\n                    $finish;\n                end\n                else\n                    read_value = 'hx;\n            end\n    \n            \n\n\n\n            if (read_value[1] === 1'bz)\n                \n                read_value[1] = 1'b0;\n            else if (read_value[1] === 1'b0)\n                \n                read_value = 'hx;\n\n            read_from_file = read_value;\n        end\n    endfunction\n    \n    task write_to_file( \n        input integer fd, \n        input integer index, \n        input [RFF_BITS:1] data \n    );\n        integer code;\n        integer offset;\n    \n        begin\n            offset = index * RFF_CHUNK;\n            code = $fseek( fd, offset, 0 );\n            if (code != 0)\n            begin\n                $display(\"%m: at time %t ERROR: fseek to %d failed\", $time, offset);\n                $finish;\n            end\n        \n            \n            if (data[1] === 1'bz)\n                data[1] = 1'bx;\n            else if (data[1] === 1'b0)\n                data[1] = 1'bz;\n\n            $fwrite( fd, \"%z\", data );\n        end\n    endtask\n`else\n    function get_index;\n        input [`MAX_BITS-1:0] addr;\n        begin : index\n            get_index = 0;\n            for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n                if (address[memory_index] == addr) begin\n                    get_index = 1;\n                    disable index;\n                end\n            end\n        end\n    endfunction\n`endif\n\n    task memory_write;\n        input  [BA_BITS-1:0]  bank;\n        input  [ROW_BITS-1:0] row;\n        input  [COL_BITS-1:0] col;\n        input  [BL_MAX*DQ_BITS-1:0] data;\n        reg    [`MAX_BITS-1:0] addr;\n        begin\n`ifdef MAX_MEM\n            addr = {row, col}/BL_MAX;\n            write_to_file( memfd[bank], addr, data );\n`else\n            \n            addr = {bank, row, col}/BL_MAX;\n            if (get_index(addr)) begin\n                address[memory_index] = addr;\n                memory[memory_index] = data;\n            end else if (memory_used == `MEM_SIZE) begin\n                $display (\"%m: at time %t ERROR: Memory overflow.  Write to Address %h with Data %h will be lost.\\nYou must increase the MEM_BITS parameter or define MAX_MEM.\", $time, addr, data);\n                if (STOP_ON_ERROR) $stop(0);\n            end else begin\n                address[memory_used] = addr;\n                memory[memory_used] = data;\n                memory_used = memory_used + 1;\n            end\n`endif\n        end\n    endtask\n\n    task memory_read;\n        input  [BA_BITS-1:0]  bank;\n        input  [ROW_BITS-1:0] row;\n        input  [COL_BITS-1:0] col;\n        output [BL_MAX*DQ_BITS-1:0] data;\n        reg    [`MAX_BITS-1:0] addr;\n        begin\n`ifdef MAX_MEM\n            addr = {row, col}/BL_MAX;\n            data = read_from_file( memfd[bank], addr );\n`else\n            \n            addr = {bank, row, col}/BL_MAX;\n            if (get_index(addr)) begin\n                data = memory[memory_index];\n            end else begin\n                data = {BL_MAX*DQ_BITS{1'bx}};\n            end\n`endif\n        end\n    endtask\n\n    task set_latency;\n        begin\n            if (al == 0) begin\n                additive_latency = 0;\n            end else begin\n                additive_latency = cas_latency - al;\n            end\n            read_latency = cas_latency + additive_latency;\n            write_latency = cas_write_latency + additive_latency;\n        end\n    endtask\n\n    \n    task erase_banks;\n        input  [`BANKS-1:0] banks; \n        reg [BA_BITS-1:0] ba;\n        reg [`MAX_BITS-1:0] i;\n        integer bank;\n\n        begin\n\n`ifdef MAX_MEM\n        for (bank = 0; bank < `BANKS; bank = bank + 1)\n            if (banks[bank] === 1'b1) begin\n\t        $fclose(memfd[bank]);\n                memfd[bank] = open_bank_file(bank);\n\t    end\n`else\n        memory_index = 0;\n        i = 0;\n        \n        for (memory_index=0; memory_index<memory_used; memory_index=memory_index+1) begin\n            ba = (address[memory_index]>>(ROW_BITS+COL_BITS-BL_BITS));\n            if (!banks[ba]) begin \n                address[i] = address[memory_index];\n                memory[i] = memory[memory_index];\n                i = i + 1;\n            end\n        end\n        \n        for (memory_index=i; memory_index<memory_used; memory_index=memory_index+1) begin\n            address[memory_index] = 'bx;\n            memory[memory_index] = {8*DQ_BITS{1'bx}};\n        end\n        memory_used = i;\n`endif\n        end\n    endtask\n\n    \n    \n    task initialize;\n        input [ADDR_BITS-1:0] mode_reg0;\n        input [ADDR_BITS-1:0] mode_reg1;\n        input [ADDR_BITS-1:0] mode_reg2;\n        input [ADDR_BITS-1:0] mode_reg3;\n        begin\n            if (DEBUG) $display (\"%m: at time %t INFO: Performing Initialization Sequence\", $time);\n            cmd_task(1,       NOP, 'bx, 'bx);\n            cmd_task(1,        ZQ, 'bx, 'h400); \n            cmd_task(1, LOAD_MODE, 3, mode_reg3);\n            cmd_task(1, LOAD_MODE, 2, mode_reg2);\n            cmd_task(1, LOAD_MODE, 1, mode_reg1);\n            cmd_task(1, LOAD_MODE, 0, mode_reg0 | 'h100); \n            cmd_task(0,       NOP, 'bx, 'bx);\n        end\n    endtask\n    \n    task reset_task;\n        integer i;\n        begin\n            \n            dq_in_valid         = 0;\n            dqs_in_valid       <= 0;\n            wdqs_cntr           = 0;\n            wdq_cntr            = 0;\n            for (i=0; i<31; i=i+1) begin\n                wdqs_pos_cntr[i]    <= 0;\n            end\n            b2b_write           <= 0;\n            \n            out_en              = 0;\n            dq_out_en           = 0;\n            rdq_cntr            = 0;\n            dqs_out_en          = 0;\n            rdqs_cntr           = 0;\n            \n            odt_en              = 0;\n            dyn_odt_en          = 0;\n            odt_state           = 0;\n            dyn_odt_state       = 0;\n            \n            active_bank         = 0;\n            auto_precharge_bank = 0;\n            read_precharge_bank  = 0;\n\t        write_precharge_bank = 0;\n            \n\n            init_done            = 0;\n\t\t    mpr_en              = 0;\n            init_step           = 0;\n            init_mode_reg       = 0;\n            init_dll_reset      = 0;\n            zq_set              = 0;\n            \n            dll_en              = 0;\n            dll_reset           = 0;\n            dll_locked          = 0;\n            \n            prev_cke            = 1'bx;\n            in_power_down       = 0;\n            in_self_refresh     = 0;\n            \n            al_pipeline         = 0;\n            wr_pipeline         = 0;\n            rd_pipeline         = 0;\n            odt_pipeline        = 0;\n            dyn_odt_pipeline    = 0;\n        end\n    endtask\n\n    parameter SAME_BANK  = 2'd0; \n    parameter DIFF_BANK  = 2'd1; \n    parameter DIFF_GROUP = 2'd2; \n\n    task chk_err;\n        input [1:0] relationship;\n        input [BA_BITS-1:0] bank;\n        input [3:0] fromcmd;\n        input [3:0] cmd;\n        reg err;\n    begin\n\n        casex ({truebl4, relationship, fromcmd, cmd})\n            \n            {1'bx, DIFF_BANK , LOAD_MODE, LOAD_MODE} : begin if (ck_cntr - ck_load_mode < TMRD)                                                                                $display (\"%m: at time %t ERROR:  tMRD violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , LOAD_MODE, READ     } : begin if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))                                         $display (\"%m: at time %t ERROR:  tMOD violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , LOAD_MODE, REFRESH  } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, PRECHARGE} ,\n            {1'bx, DIFF_BANK , LOAD_MODE, ACTIVATE } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, ZQ       } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, PWR_DOWN } ,\n            {1'bx, DIFF_BANK , LOAD_MODE, SELF_REF } : begin if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))                                         $display (\"%m: at time %t ERROR:  tMOD violation during %s\", $time, cmd_string[cmd]);                         end\n\n            \n            {1'bx, DIFF_BANK , REFRESH  , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , REFRESH  , REFRESH  } ,\n            {1'bx, DIFF_BANK , REFRESH  , PRECHARGE} ,\n            {1'bx, DIFF_BANK , REFRESH  , ACTIVATE } ,\n            {1'bx, DIFF_BANK , REFRESH  , ZQ       } ,\n            {1'bx, DIFF_BANK , REFRESH  , SELF_REF } : begin if ($time - tm_refresh < TRFC_MIN)                                                                                $display (\"%m: at time %t ERROR:  tRFC violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , REFRESH  , PWR_DOWN } : begin if (ck_cntr - ck_refresh < TREFPDEN)                                                                              $display (\"%m: at time %t ERROR:  tREFPDEN violation during %s\", $time, cmd_string[cmd]);                     end\n\n            \n            {1'bx, SAME_BANK , PRECHARGE, ACTIVATE } : begin if ($time - tm_bank_precharge[bank] < TRP)                                                                        $display (\"%m: at time %t ERROR:   tRP violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end \n            {1'bx, DIFF_BANK , PRECHARGE, LOAD_MODE} ,\n            {1'bx, DIFF_BANK , PRECHARGE, REFRESH  } ,\n            {1'bx, DIFF_BANK , PRECHARGE, ZQ       } ,\n            {1'bx, DIFF_BANK , PRECHARGE, SELF_REF } : begin if ($time - tm_precharge < TRP)                                                                                   $display (\"%m: at time %t ERROR:   tRP violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , PRECHARGE, PWR_DOWN } : ; \n\n            \n            {1'bx, SAME_BANK , ACTIVATE , PRECHARGE} : begin if ($time - tm_bank_activate[bank] > TRAS_MAX)                                                                    $display (\"%m: at time %t ERROR:  tRAS maximum violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                                                             if ($time - tm_bank_activate[bank] < TRAS_MIN)                                                                    $display (\"%m: at time %t ERROR:  tRAS minimum violation during %s to bank %d\", $time, cmd_string[cmd], bank);end\n            {1'bx, SAME_BANK , ACTIVATE , ACTIVATE } : begin if ($time - tm_bank_activate[bank] < TRC)                                                                         $display (\"%m: at time %t ERROR:   tRC violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'bx, SAME_BANK , ACTIVATE , WRITE    } ,\n            {1'bx, SAME_BANK , ACTIVATE , READ     } : ; \n            {1'b0, DIFF_BANK , ACTIVATE , ACTIVATE } : begin if (($time - tm_activate < TRRD) || (ck_cntr - ck_activate < TRRD_TCK))                                           $display (\"%m: at time %t ERROR:  tRRD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , ACTIVATE , ACTIVATE } : begin if (($time - tm_group_activate[bank[1]] < TRRD) || (ck_cntr - ck_group_activate[bank[1]] < TRRD_TCK))             $display (\"%m: at time %t ERROR:  tRRD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, ACTIVATE , ACTIVATE } : begin if (($time - tm_activate < TRRD_DG) || (ck_cntr - ck_activate < TRRD_DG_TCK))                                     $display (\"%m: at time %t ERROR:  tRRD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , ACTIVATE , REFRESH  } : begin if ($time - tm_activate < TRC)                                                                                    $display (\"%m: at time %t ERROR:   tRC violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , ACTIVATE , PWR_DOWN } : begin if (ck_cntr - ck_activate < TACTPDEN)                                                                             $display (\"%m: at time %t ERROR:  tACTPDEN violation during %s\", $time, cmd_string[cmd]);                     end\n\n            \n            {1'bx, SAME_BANK , WRITE    , PRECHARGE} : begin if (($time - tm_bank_write_end[bank] < TWR) || (ck_cntr - ck_bank_write[bank] <= write_latency + burst_length/2)) $display (\"%m: at time %t ERROR:   tWR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , WRITE    , WRITE    } : begin if (ck_cntr - ck_write < TCCD)                                                                                    $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , WRITE    , WRITE    } : begin if (ck_cntr - ck_group_write[bank[1]] < TCCD)                                                                     $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , WRITE    , READ     } : begin if (ck_cntr - ck_write < write_latency + burst_length/2 + TWTR_TCK - additive_latency)                            $display (\"%m: at time %t ERROR:  tWTR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , WRITE    , READ     } : begin if (ck_cntr - ck_group_write[bank[1]] < write_latency + burst_length/2 + TWTR_TCK - additive_latency)             $display (\"%m: at time %t ERROR:  tWTR violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, WRITE    , WRITE    } : begin if (ck_cntr - ck_write < TCCD_DG)                                                                                 $display (\"%m: at time %t ERROR:  tCCD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'b1, DIFF_GROUP, WRITE    , READ     } : begin if (ck_cntr - ck_write < write_latency + burst_length/2 + TWTR_DG_TCK - additive_latency)                         $display (\"%m: at time %t ERROR:  tWTR_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , WRITE    , PWR_DOWN } : begin if (($time - tm_write_end < TWR) || (ck_cntr - ck_write < write_latency + burst_length/2))                        $display (\"%m: at time %t ERROR:  tWRPDEN violation during %s\", $time, cmd_string[cmd]);                      end\n\n            \n            {1'bx, SAME_BANK , READ     , PRECHARGE} : begin if (($time - tm_bank_read_end[bank] < TRTP) || (ck_cntr - ck_bank_read[bank] < additive_latency + TRTP_TCK))      $display (\"%m: at time %t ERROR:  tRTP violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b0, DIFF_BANK , READ     , WRITE    } : ; \n            {1'b1, DIFF_BANK , READ     , WRITE    } : ; \n            {1'b0, DIFF_BANK , READ     , READ     } : begin if (ck_cntr - ck_read < TCCD)                                                                                     $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_BANK , READ     , READ     } : begin if (ck_cntr - ck_group_read[bank[1]] < TCCD)                                                                      $display (\"%m: at time %t ERROR:  tCCD violation during %s to bank %d\", $time, cmd_string[cmd], bank);        end\n            {1'b1, DIFF_GROUP, READ     , WRITE    } : ; \n            {1'b1, DIFF_GROUP, READ     , READ     } : begin if (ck_cntr - ck_read < TCCD_DG)                                                                                  $display (\"%m: at time %t ERROR:  tCCD_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);     end\n            {1'bx, DIFF_BANK , READ     , PWR_DOWN } : begin if (ck_cntr - ck_read < read_latency + 5)                                                                         $display (\"%m: at time %t ERROR:  tRDPDEN violation during %s\", $time, cmd_string[cmd]);                      end\n\n            \n            {1'bx, DIFF_BANK , ZQ       , LOAD_MODE} : ; \n            {1'bx, DIFF_BANK , ZQ       , REFRESH  } ,\n            {1'bx, DIFF_BANK , ZQ       , PRECHARGE} ,\n            {1'bx, DIFF_BANK , ZQ       , ACTIVATE } ,\n            {1'bx, DIFF_BANK , ZQ       , ZQ       } ,\n            {1'bx, DIFF_BANK , ZQ       , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , ZQ       , SELF_REF } : begin if (ck_cntr - ck_zqinit < TZQINIT)                                                                                $display (\"%m: at time %t ERROR:  tZQinit violation during %s\", $time, cmd_string[cmd]);\n                                                             if (ck_cntr - ck_zqoper < TZQOPER)                                                                                $display (\"%m: at time %t ERROR:  tZQoper violation during %s\", $time, cmd_string[cmd]);\n                                                             if (ck_cntr - ck_zqcs < TZQCS)                                                                                    $display (\"%m: at time %t ERROR:  tZQCS violation during %s\", $time, cmd_string[cmd]);                        end\n\n            \n            {1'bx, DIFF_BANK , PWR_DOWN , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , PWR_DOWN , REFRESH  } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , PRECHARGE} ,\n            {1'bx, DIFF_BANK , PWR_DOWN , ACTIVATE } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , WRITE    } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , ZQ       } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , PWR_DOWN , READ     } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);                            \n                                                        else if (($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK))                               $display (\"%m: at time %t ERROR:  tXPDLL violation during %s\", $time, cmd_string[cmd]);                       end\n            {1'bx, DIFF_BANK , PWR_DOWN , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , PWR_DOWN , SELF_REF } : begin if (($time - tm_power_down < TXP) || (ck_cntr - ck_power_down < TXP_TCK))                                         $display (\"%m: at time %t ERROR:   tXP violation during %s\", $time, cmd_string[cmd]);\n                                                             if ((tm_power_down > tm_refresh) && ($time - tm_refresh < TRFC_MIN))                                              $display (\"%m: at time %t ERROR:  tRFC violation during %s\", $time, cmd_string[cmd]);\n                                                             if ((tm_refresh > tm_power_down) && (($time - tm_power_down < TXPDLL) || (ck_cntr - ck_power_down < TXPDLL_TCK))) $display (\"%m: at time %t ERROR:  tXPDLL violation during %s\", $time, cmd_string[cmd]);\n                                                             if (($time - tm_cke_cmd < TCKE) || (ck_cntr - ck_cke_cmd < TCKE_TCK))                                             $display (\"%m: at time %t ERROR:  tCKE violation on CKE\", $time);                                             end\n\n            \n            {1'bx, DIFF_BANK , SELF_REF , LOAD_MODE} ,\n            {1'bx, DIFF_BANK , SELF_REF , REFRESH  } ,\n            {1'bx, DIFF_BANK , SELF_REF , PRECHARGE} ,\n            {1'bx, DIFF_BANK , SELF_REF , ACTIVATE } ,\n            {1'bx, DIFF_BANK , SELF_REF , WRITE    } ,\n            {1'bx, DIFF_BANK , SELF_REF , ZQ       } : begin if (($time - tm_self_refresh < TXS) || (ck_cntr - ck_self_refresh < TXS_TCK))                                     $display (\"%m: at time %t ERROR:   tXS violation during %s\", $time, cmd_string[cmd]);                         end\n            {1'bx, DIFF_BANK , SELF_REF , READ     } : begin if (ck_cntr - ck_self_refresh < TXSDLL)                                                                           $display (\"%m: at time %t ERROR:  tXSDLL violation during %s\", $time, cmd_string[cmd]);                       end\n            {1'bx, DIFF_BANK , SELF_REF , PWR_DOWN } ,\n            {1'bx, DIFF_BANK , SELF_REF , SELF_REF } : begin if (($time - tm_self_refresh < TXS) || (ck_cntr - ck_self_refresh < TXS_TCK))                                     $display (\"%m: at time %t ERROR:   tXS violation during %s\", $time, cmd_string[cmd]);\n                                                             if (($time - tm_cke_cmd < TCKE) || (ck_cntr - ck_cke_cmd < TCKE_TCK))                                             $display (\"%m: at time %t ERROR:  tCKE violation on CKE\", $time);                                             end\n        endcase\n    end\n    endtask\n\n    task cmd_task;\n        input cke;\n        input [2:0] cmd;\n        input [BA_BITS-1:0] bank;\n        input [ADDR_BITS-1:0] addr;\n        reg [`BANKS:0] i;\n        integer j;\n        reg [`BANKS:0] tfaw_cntr;\n        reg [COL_BITS-1:0] col;\n        reg group;\n        begin\n            \n            if (!er_trfc_max && !in_self_refresh) begin\n                if ($time - tm_refresh > TRFC_MAX && check_strict_timing) begin\n                    $display (\"%m: at time %t ERROR:  tRFC maximum violation during %s\", $time, cmd_string[cmd]);\n                    er_trfc_max = 1;\n                end\n            end\n            if (cke) begin\n                if ((cmd < NOP) && (cmd != PRECHARGE)) begin\n                    if (($time - tm_txpr < TXPR) || (ck_cntr - ck_txpr < TXPR_TCK))\n                        $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[cmd]);\n                    for (j=0; j<=SELF_REF; j=j+1) begin\n                        chk_err(SAME_BANK , bank, j, cmd);\n                        chk_err(DIFF_BANK , bank, j, cmd);\n                        chk_err(DIFF_GROUP, bank, j, cmd);\n                    end\n                end\n                case (cmd)\n                    LOAD_MODE : begin\n                        if (|odt_pipeline)\n                            $display (\"%m: at time %t ERROR: ODTL violation during %s\", $time, cmd_string[cmd]);\n                        if (odt_state)\n                            $display (\"%m: at time %t ERROR: ODT must be off prior to %s\", $time, cmd_string[cmd]);\n\n                        if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s %d\", $time, cmd_string[cmd], bank);\n                            if (bank>>2) begin\n                                $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved bank bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                            end\n                            case (bank)\n                                0 : begin\n                                    \n                                    if (addr[1:0] == 2'b00) begin\n                                        burst_length = 8;\n                                        blotf = 0;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = %d\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else if (addr[1:0] == 2'b01) begin\n                                        burst_length = 8;\n                                        blotf = 1;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = Select via A12\", $time, cmd_string[cmd], bank);\n                                    end else if (addr[1:0] == 2'b10) begin\n                                        burst_length = 4;\n                                        blotf = 0;\n                                        truebl4 = 0;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = Fixed %d (chop)\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else if (feature_truebl4 && (addr[1:0] == 2'b11)) begin\n                                        burst_length = 4;\n                                        blotf = 0;\n                                        truebl4 = 1;\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Length = True %d\", $time, cmd_string[cmd], bank, burst_length);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Burst Length = %d\", $time, cmd_string[cmd], bank, addr[1:0]);\n                                    end\n                                    \n                                    burst_order = addr[3];\n                                    if (!burst_order) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Order = Sequential\", $time, cmd_string[cmd], bank);\n                                    end else if (burst_order) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Burst Order = Interleaved\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Burst Order = %d\", $time, cmd_string[cmd], bank, burst_order);\n                                    end\n                                    \n                                    cas_latency = {addr[2],addr[6:4]} + 4;\n                                    set_latency;\n                                    if ((cas_latency >= CL_MIN) && (cas_latency <= CL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d CAS Latency = %d\", $time, cmd_string[cmd], bank, cas_latency);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal CAS Latency = %d\", $time, cmd_string[cmd], bank, cas_latency);\n                                    end\n                                    \n                                    if (addr[7] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    dll_reset = addr[8];\n                                    if (!dll_reset) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Reset = Normal\", $time, cmd_string[cmd], bank);\n                                    end else if (dll_reset) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Reset = Reset DLL\", $time, cmd_string[cmd], bank);\n                                        dll_locked = 0;\n                                        init_dll_reset = 1;\n                                        ck_dll_reset <= ck_cntr;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal DLL Reset = %d\", $time, cmd_string[cmd], bank, dll_reset);\n                                    end\n\n\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t   if (addr[11:9] == 0) begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = 16;\n\t\t\t\t\t\t\t\t   end else if (addr[11:9] < 4) begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = addr[11:9] + 4;\n\t\t\t\t\t\t\t\t   end else begin\n\t\t\t\t\t\t\t\t\t  write_recovery  = 2*addr[11:9];\n\t\t\t\t\t\t\t\t   end\n\n                                    if ((write_recovery >= WR_MIN) && (write_recovery <= WR_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Recovery = %d\", $time, cmd_string[cmd], bank, write_recovery);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Write Recovery = %d\", $time, cmd_string[cmd], bank, write_recovery);\n                                    end\n                                    \n                                    low_power = !addr[12];\n                                    if (!low_power) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Power Down Mode = DLL on\", $time, cmd_string[cmd], bank);\n                                    end else if (low_power) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Power Down Mode = DLL off\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Power Down Mode = %d\", $time, cmd_string[cmd], bank, low_power);\n                                    end\n                                    \n                                    if (ADDR_BITS>13 && addr[13] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                1 : begin\n                                    \n                                    dll_en = !addr[0];\n                                    if (!dll_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d DLL off mode is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else if (dll_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d DLL Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal DLL Enable = %d\", $time, cmd_string[cmd], bank, dll_en);\n                                    end\n                                    \n                                    if ({addr[5], addr[1]} == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/6);\n                                    end else if ({addr[5], addr[1]} == 2'b01) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/7);\n                                    end else if ({addr[5], addr[1]} == 2'b11) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Output Drive Strength = %d Ohm\", $time, cmd_string[cmd], bank, RZQ/5);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Output Drive Strength = %d\", $time, cmd_string[cmd], bank, {addr[5], addr[1]});\n                                    end\n                                    \n                                    odt_rtt_nom = {addr[9], addr[6], addr[2]};\n                                    if (odt_rtt_nom == 3'b000) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d ODT Rtt = Disabled\", $time, cmd_string[cmd], bank);\n                                        odt_en = 0;\n                                    end else if ((odt_rtt_nom < 4) || ((!addr[7] || (addr[7] && addr[12])) && (odt_rtt_nom < 6))) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d ODT Rtt = %d Ohm\", $time, cmd_string[cmd], bank, get_rtt_nom(odt_rtt_nom));\n                                        odt_en = 1;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal ODT Rtt = %d\", $time, cmd_string[cmd], bank, odt_rtt_nom);\n                                        odt_en = 0;\n                                    end\n                                    \n                                    al = addr[4:3];\n                                    set_latency;\n                                    if (al == 0) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Additive Latency = %d\", $time, cmd_string[cmd], bank, al);\n                                    end else if ((al >= AL_MIN) && (al <= AL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Additive Latency = CL - %d\", $time, cmd_string[cmd], bank, al);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Additive Latency = %d\", $time, cmd_string[cmd], bank, al);\n                                    end\n                                    \n                                    write_levelization = addr[7];\n                                    if (!write_levelization) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Levelization = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (write_levelization) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Write Levelization = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Write Levelization = %d\", $time, cmd_string[cmd], bank, write_levelization);\n                                    end\n                                    \n                                    if (addr[8] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    if (addr[10] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    tdqs_en = addr[11];\n                                    if (!tdqs_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d TDQS Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (tdqs_en) begin\n                                        if (8 == DQ_BITS) begin\n\t\t\t\t\t\t\t\t\t\t    if (DEBUG) $display (\"%m: at time %t INFO: %s %d TDQS Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                        end\n\t\t\t\t\t\t\t\t\t    else begin\n                                            $display (\"%m: at time %t WARNING: %s %d Illegal TDQS Enable.  TDQS only exists on a x8 part\", $time, cmd_string[cmd], bank);\n                                            tdqs_en = 0;\n\t\t\t\t\t\t\t\t\t\tend   \n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal TDQS Enable = %d\", $time, cmd_string[cmd], bank, tdqs_en);\n                                    end \n                                    \n                                    out_en = !addr[12];\n                                    if (!out_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Qoff = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (out_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Qoff = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Qoff = %d\", $time, cmd_string[cmd], bank, out_en);\n                                    end \n                                    \n                                    if (ADDR_BITS>13 && addr[13] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                2 : begin\n\t\t\t\t\t\t\t\t    if (feature_pasr) begin\n                                        \n                                        pasr = addr[2:0];\n                                        case (pasr)\n                                            3'b000 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-7\", $time, cmd_string[cmd], bank);\n                                            3'b001 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-3\", $time, cmd_string[cmd], bank);\n                                            3'b010 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0-1\", $time, cmd_string[cmd], bank);\n                                            3'b011 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 0\", $time, cmd_string[cmd], bank);\n                                            3'b100 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 2-7\", $time, cmd_string[cmd], bank);\n                                            3'b101 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 4-7\", $time, cmd_string[cmd], bank);\n                                            3'b110 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 6-7\", $time, cmd_string[cmd], bank);\n                                            3'b111 : if (DEBUG) $display (\"%m: at time %t INFO: %s %d Partial Array Self Refresh = Bank 7\", $time, cmd_string[cmd], bank);\n                                            default : $display (\"%m: at time %t ERROR: %s %d Illegal Partial Array Self Refresh = %d\", $time, cmd_string[cmd], bank, pasr);\n                                        endcase \n\t\t\t\t\t\t\t\t\tend \n\t\t\t\t\t\t\t\t    else\n                                    if (addr[2:0] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    cas_write_latency = addr[5:3]+5;\n                                    set_latency;\n                                    if ((cas_write_latency >= CWL_MIN) && (cas_write_latency <= CWL_MAX)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d CAS Write Latency = %d\", $time, cmd_string[cmd], bank, cas_write_latency);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal CAS Write Latency = %d\", $time, cmd_string[cmd], bank, cas_write_latency);\n                                    end\n                                    \n                                    asr = addr[6];\n                                    if (!asr) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Auto Self Refresh = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (asr) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Auto Self Refresh = Enabled\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d Auto Self Refresh is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Auto Self Refresh = %d\", $time, cmd_string[cmd], bank, asr);\n                                    end \n                                    \n                                    srt = addr[7];\n                                    if (!srt) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Self Refresh Temperature = Normal\", $time, cmd_string[cmd], bank);\n                                    end else if (srt) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Self Refresh Temperature = Extended\", $time, cmd_string[cmd], bank);\n                                        if (check_strict_mrbits) $display (\"%m: at time %t WARNING: %s %d Self Refresh Temperature is not modeled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Self Refresh Temperature = %d\", $time, cmd_string[cmd], bank, srt);\n                                    end \n                                    if (asr && srt)\n                                        $display (\"%m: at time %t ERROR: %s %d SRT must be set to 0 when ASR is enabled.\", $time, cmd_string[cmd], bank);\n                                    \n                                    if (addr[8] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                    \n                                    odt_rtt_wr = addr[10:9];\n                                    if (odt_rtt_wr == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Dynamic ODT = Disabled\", $time, cmd_string[cmd], bank);\n                                        dyn_odt_en = 0;\n                                    end else if ((odt_rtt_wr > 0) && (odt_rtt_wr < 3)) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d Dynamic ODT Rtt = %d Ohm\", $time, cmd_string[cmd], bank, get_rtt_wr(odt_rtt_wr));\n                                        dyn_odt_en = 1;\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal Dynamic ODT = %d\", $time, cmd_string[cmd], bank, odt_rtt_wr);\n                                        dyn_odt_en = 0;\n                                    end\n                                    \n                                    if (ADDR_BITS>13 && addr[13:11] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                                3 : begin\n                                    mpr_select = addr[1:0];\n                                    \n                                    if (mpr_select == 2'b00) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Select = Pre-defined pattern\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        if (check_strict_mrbits) $display (\"%m: at time %t ERROR: %s %d Illegal MultiPurpose Register Select = %d\", $time, cmd_string[cmd], bank, mpr_select);\n                                    end\n                                    \n                                    mpr_en = addr[2];\n                                    if (!mpr_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Enable = Disabled\", $time, cmd_string[cmd], bank);\n                                    end else if (mpr_en) begin\n                                        if (DEBUG) $display (\"%m: at time %t INFO: %s %d MultiPurpose Register Enable = Enabled\", $time, cmd_string[cmd], bank);\n                                    end else begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal MultiPurpose Register Enable = %d\", $time, cmd_string[cmd], bank, mpr_en);\n                                    end \n                                    \n                                    if (ADDR_BITS>13 && addr[13:3] !== 0 && check_strict_mrbits) begin\n                                        $display (\"%m: at time %t ERROR: %s %d Illegal value.  Reserved address bits must be programmed to zero\", $time, cmd_string[cmd], bank);\n                                    end\n                                end\n                            endcase\n                            if (dyn_odt_en && write_levelization)\n                                $display (\"%m: at time %t ERROR: Dynamic ODT is not available during Write Leveling mode.\", $time);\n                            init_mode_reg[bank] = 1;\n                            mode_reg[bank] = addr;\n                            tm_load_mode <= $time;\n                            ck_load_mode <= ck_cntr;\n                        end\n                    end\n                    REFRESH : begin\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s\", $time, cmd_string[cmd]);\n                            er_trfc_max = 0;\n                            ref_cntr = ref_cntr + 1;\n                            tm_refresh <= $time;\n                            ck_refresh <= ck_cntr;\n                        end\n                    end\n                    PRECHARGE : begin\n                        if (addr[AP]) begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s All\", $time, cmd_string[cmd]);\n                        end\n                        \n                        \n                        if (|active_bank) begin\n                            if (($time - tm_txpr < TXPR) || (ck_cntr - ck_txpr < TXPR_TCK))\n                                $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[cmd]);\n                            if (mpr_en) begin\n                                $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                                if (STOP_ON_ERROR) $stop(0);\n                            end else begin\n                                for (i=0; i<`BANKS; i=i+1) begin\n                                    if (active_bank[i]) begin\n                                        if (addr[AP] || (i == bank)) begin\n\n                                            for (j=0; j<=SELF_REF; j=j+1) begin\n                                                chk_err(SAME_BANK, i, j, cmd);\n                                                chk_err(DIFF_BANK, i, j, cmd);\n                                            end\n\n                                            if (auto_precharge_bank[i]) begin\n                                                $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], i);\n                                                if (STOP_ON_ERROR) $stop(0);\n                                            end else begin\n                                                if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d\", $time, cmd_string[cmd], i);\n                                                active_bank[i] = 1'b0;\n                                                tm_bank_precharge[i] <= $time;\n                                                tm_precharge <= $time;\n                                                ck_precharge <= ck_cntr;\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                    ACTIVATE : begin\n                        tfaw_cntr = 0;\n                        for (i=0; i<`BANKS; i=i+1) begin\n                            if ($time - tm_bank_activate[i] < TFAW) begin\n                                tfaw_cntr = tfaw_cntr + 1;\n                            end\n                        end\n                        if (tfaw_cntr > 3) begin\n                            $display (\"%m: at time %t ERROR:  tFAW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (active_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Precharged.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr >= 1<<ROW_BITS) begin\n                                $display (\"%m: at time %t WARNING: row = %h does not exist.  Maximum row = %h\", $time, addr, (1<<ROW_BITS)-1);\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d row %h\", $time, cmd_string[cmd], bank, addr);\n                            active_bank[bank] = 1'b1;\n                            active_row[bank] = addr;\n                            tm_group_activate[bank[1]] <= $time;\n                            tm_activate <= $time;\n                            tm_bank_activate[bank] <= $time;\n                            ck_group_activate[bank[1]] <= ck_cntr;\n                            ck_activate <= ck_cntr;\n                        end\n                    end\n                    WRITE : begin\n                        if ((!rd_bc && blotf) || (burst_length == 4)) begin \n                            if (truebl4) begin\n                                if (ck_cntr - ck_group_read[bank[1]] < read_latency + TCCD/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                                if (ck_cntr - ck_read < read_latency + TCCD_DG/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW_DG violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                            end else begin\n                                if (ck_cntr - ck_read < read_latency + TCCD/2 + 2 - write_latency)\n                                    $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                            end\n                        end else begin \n                            if (ck_cntr - ck_read < read_latency + TCCD + 2 - write_latency)\n                                $display (\"%m: at time %t ERROR:  tRTW violation during %s to bank %d\", $time, cmd_string[cmd], bank);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!active_bank[bank])  begin\n                            if (check_strict_timing) $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Activated.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (auto_precharge_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (ck_cntr - ck_write < burst_length/2) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Illegal burst interruption.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr[AP]) begin\n                                auto_precharge_bank[bank] = 1'b1;\n                                write_precharge_bank[bank] = 1'b1;\n                            end\n                            col = {addr[BC-1:AP+1], addr[AP-1:0]}; \n                            if (col >= 1<<COL_BITS) begin\n                                $display (\"%m: at time %t WARNING: col = %h does not exist.  Maximum col = %h\", $time, col, (1<<COL_BITS)-1);\n                            end\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                col = col & -4;\n                            end else begin \n                                col = col & -8;\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d col %h, auto precharge %d\", $time, cmd_string[cmd], bank, col, addr[AP]);\n                            wr_pipeline[2*write_latency + 1]  = 1;\n                            ba_pipeline[2*write_latency + 1]  = bank;\n                            row_pipeline[2*write_latency + 1] = active_row[bank];\n                            col_pipeline[2*write_latency + 1] = col;\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                bl_pipeline[2*write_latency + 1] = 4;\n                                if (mpr_en && col%4) begin\n                                    $display (\"%m: at time %t WARNING: col[1:0] must be set to 2'b00 during a BL4 Multipurpose Register read\", $time);\n                                end\n                            end else begin \n                                bl_pipeline[2*write_latency + 1] = 8;\n                                if (odt_in) begin\n                                    ck_odth8 <= ck_cntr;\n                                end\n                            end\n                            for (j=0; j<(burst_length + 4); j=j+1) begin\n                                dyn_odt_pipeline[2*(write_latency - 2) + j] = 1'b1; \n                            end\n                            ck_bank_write[bank] <= ck_cntr;\n                            ck_group_write[bank[1]] <= ck_cntr;\n                            ck_write <= ck_cntr;\n                        end\n                    end\n                    READ : begin\n                        if (!dll_locked)\n                            $display (\"%m: at time %t WARNING: tDLLK violation during %s.\", $time, cmd_string[cmd]);\n                        if (mpr_en && (addr[1:0] != 2'b00)) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  addr[1:0] must be zero during Multipurpose Register Read.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Initialization sequence is not complete.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!active_bank[bank] && !mpr_en) begin\n                            if (check_strict_timing) $display (\"%m: at time %t ERROR: %s Failure.  Bank %d must be Activated.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (auto_precharge_bank[bank]) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Auto Precharge is scheduled to bank %d.\", $time, cmd_string[cmd], bank);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (ck_cntr - ck_read < burst_length/2) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Illegal burst interruption.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (addr[AP] && !mpr_en) begin\n                                auto_precharge_bank[bank] = 1'b1;\n                                read_precharge_bank[bank] = 1'b1;\n                            end\n                            col = {addr[BC-1:AP+1], addr[AP-1:0]}; \n                            if (col >= 1<<COL_BITS) begin\n                                $display (\"%m: at time %t WARNING: col = %h does not exist.  Maximum col = %h\", $time, col, (1<<COL_BITS)-1);\n                            end\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s bank %d col %h, auto precharge %d\", $time, cmd_string[cmd], bank, col, addr[AP]);\n                            rd_pipeline[2*read_latency - 1]  = 1;\n                            ba_pipeline[2*read_latency - 1]  = bank;\n                            row_pipeline[2*read_latency - 1] = active_row[bank];\n                            col_pipeline[2*read_latency - 1] = col;\n                            if ((!addr[BC] && blotf) || (burst_length == 4)) begin \n                                bl_pipeline[2*read_latency - 1] = 4;\n                                if (mpr_en && col%4) begin\n                                    $display (\"%m: at time %t WARNING: col[1:0] must be set to 2'b00 during a BL4 Multipurpose Register read\", $time);\n                                end\n                            end else begin \n                                bl_pipeline[2*read_latency - 1] = 8;\n                                if (mpr_en && col%8) begin\n                                    $display (\"%m: at time %t WARNING: col[2:0] must be set to 3'b000 during a BL8 Multipurpose Register read\", $time);\n                                end\n                            end\n                            rd_bc = addr[BC];\n                            ck_bank_read[bank] <= ck_cntr;\n                            ck_group_read[bank[1]] <= ck_cntr;\n                            ck_read <= ck_cntr;\n                        end\n                    end\n                    ZQ : begin\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  Multipurpose Register must be disabled.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: %s Failure.  All banks must be Precharged.\", $time, cmd_string[cmd]);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: %s long = %d\", $time, cmd_string[cmd], addr[AP]);\n                            if (addr[AP]) begin\n                                zq_set = 1;\n                                if (init_done) begin\n                                    ck_zqoper <= ck_cntr;\n                                end else begin\n                                    ck_zqinit <= ck_cntr;\n                                end\n                            end else begin\n                                ck_zqcs <= ck_cntr;\n                            end\n                        end\n                    end\n                    NOP: begin\n                        if (in_power_down) begin\n                            if (($time - tm_freq_change < TCKSRX) || (ck_cntr - ck_freq_change < TCKSRX_TCK))\n                                $display (\"%m: at time %t ERROR: tCKSRX violation during Power Down Exit\", $time);\n                            if ($time - tm_cke_cmd > TPD_MAX)\n                                $display (\"%m: at time %t ERROR: tPD maximum violation during Power Down Exit\", $time);\n                            if (DEBUG) $display (\"%m: at time %t INFO: Power Down Exit\", $time);\n                            in_power_down = 0;\n                            if ((active_bank == 0) && low_power) begin \n                                if (ck_cntr - ck_odt < write_latency - 1)\n                                    $display (\"%m: at time %t WARNING: tANPD violation during Power Down Exit.  Synchronous or asynchronous change in termination resistance is possible.\", $time);\n                                tm_slow_exit_pd <= $time;\n                                ck_slow_exit_pd <= ck_cntr;\n                            end\n                            tm_power_down <= $time;\n                            ck_power_down <= ck_cntr;\n                        end\n                        if (in_self_refresh) begin\n                            if (($time - tm_freq_change < TCKSRX) || (ck_cntr - ck_freq_change < TCKSRX_TCK))\n                                $display (\"%m: at time %t ERROR: tCKSRX violation during Self Refresh Exit\", $time);\n                            if (ck_cntr - ck_cke_cmd < TCKESR_TCK)\n                                $display (\"%m: at time %t ERROR: tCKESR violation during Self Refresh Exit\", $time);\n                            if ($time - tm_cke < TISXR)\n                                $display (\"%m: at time %t ERROR: tISXR violation during Self Refresh Exit\", $time);\n                            if (DEBUG) $display (\"%m: at time %t INFO: Self Refresh Exit\", $time);\n                            in_self_refresh = 0;\n                            ck_dll_reset <= ck_cntr;\n                            ck_self_refresh <= ck_cntr;\n                            tm_self_refresh <= $time;\n                            tm_refresh <= $time;\n                        end\n                    end\n                endcase\n                if ((prev_cke !== 1) && (cmd !== NOP)) begin\n                    $display (\"%m: at time %t ERROR: NOP or Deselect is required when CKE goes active.\", $time);\n                end\n\n                if (!init_done) begin\n                    case (init_step)\n                        0 : begin\n                            if ($time - tm_rst_n < 500000000 && check_strict_timing) \n                                $display (\"%m at time %t WARNING: 500 us is required after RST_N goes inactive before CKE goes active.\", $time);\n                            tm_txpr <= $time;\n                            ck_txpr <= ck_cntr;\n                            init_step = init_step + 1;\n                        end\n                        1 : if (dll_en) init_step = init_step + 1;\n                        2 : begin\n                            if (&init_mode_reg && init_dll_reset && zq_set) begin\n                                if (DEBUG) $display (\"%m: at time %t INFO: Initialization Sequence is complete\", $time);\n                                init_done = 1;\n                            end\n                        end\n                    endcase\n                end\n            end else if (prev_cke) begin\n                if ((!init_done) && (init_step > 1)) begin\n                    $display (\"%m: at time %t ERROR: CKE must remain active until the initialization sequence is complete.\", $time);\n                    if (STOP_ON_ERROR) $stop(0);\n                end\n                case (cmd)\n                    REFRESH : begin\n                        if ($time - tm_txpr < TXPR)\n                            $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[SELF_REF]);\n                        for (j=0; j<=SELF_REF; j=j+1) begin\n                            chk_err(DIFF_BANK, bank, j, SELF_REF);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  Multipurpose Register must be disabled.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (|active_bank) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  All banks must be Precharged.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (odt_state) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  ODT must be off prior to entering Self Refresh\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: Self Refresh Failure.  Initialization sequence is not complete.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) $display (\"%m: at time %t INFO: Self Refresh Enter\", $time);\n\t\t\t\t\t\t    if (feature_pasr)\n                                \n                                case (pasr)\n                                    3'b000 : ;\n                                    3'b001 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 4-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hF0); end\n                                    3'b010 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 2-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hFC); end\n                                    3'b011 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 1-7 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'hFE); end\n                                    3'b100 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-1 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h03); end\n                                    3'b101 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-3 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h0F); end\n                                    3'b110 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-5 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h3F); end\n                                    3'b111 : begin if (DEBUG) $display(\"%m: at time %t INFO: Banks 0-6 will be lost due to Partial Array Self Refresh\", $time); erase_banks(8'h7F); end\n\t\t\t\t\t\t\t    endcase\n                            in_self_refresh = 1;\n                            dll_locked = 0;\n                        end\n                    end\n                    NOP : begin\n                        \n                        if (low_power && (active_bank == 0) && |odt_pipeline)\n                            $display (\"%m: at time %t WARNING: tANPD violation during %s.   Synchronous or asynchronous change in termination resistance is possible.\", $time, cmd_string[PWR_DOWN]);\n                        if ($time - tm_txpr < TXPR)\n                            $display (\"%m: at time %t ERROR:  tXPR violation during %s\", $time, cmd_string[PWR_DOWN]);\n                        for (j=0; j<=SELF_REF; j=j+1) begin\n                            chk_err(DIFF_BANK, bank, j, PWR_DOWN);\n                        end\n\n                        if (mpr_en) begin\n                            $display (\"%m: at time %t ERROR: Power Down Failure.  Multipurpose Register must be disabled.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else if (!init_done) begin\n                            $display (\"%m: at time %t ERROR: Power Down Failure.  Initialization sequence is not complete.\", $time);\n                            if (STOP_ON_ERROR) $stop(0);\n                        end else begin\n                            if (DEBUG) begin\n                                if (|active_bank) begin\n                                    $display (\"%m: at time %t INFO: Active Power Down Enter\", $time);\n                                end else begin\n                                    $display (\"%m: at time %t INFO: Precharge Power Down Enter\", $time);\n                                end\n                            end\n                            in_power_down = 1;\n                        end\n                    end\n                    default : begin\n                        $display (\"%m: at time %t ERROR: NOP, Deselect, or Refresh is required when CKE goes inactive.\", $time);\n                    end\n                endcase\n            end else if (in_self_refresh || in_power_down) begin\n                if ((ck_cntr - ck_cke_cmd <= TCPDED) && (cmd !== NOP))\n                    $display (\"%m: at time %t ERROR: tCPDED violation during Power Down or Self Refresh Entry.  NOP or Deselect is required.\", $time);\n            end\n            prev_cke  = cke;\n\n        end\n    endtask    \n\n    task data_task;\n        reg [BA_BITS-1:0] bank;\n        reg [ROW_BITS-1:0] row;\n        reg [COL_BITS-1:0] col;\n        integer i;\n        integer j;\n        begin\n\n            if (diff_ck) begin\n                for (i=0; i<32; i=i+1) begin\n                    if (dq_in_valid && dll_locked && ($time - tm_dqs_neg[i] < $rtoi(TDSS*tck_avg)))\n                        $display (\"%m: at time %t ERROR: tDSS violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    if (check_write_dqs_high[i])\n                        $display (\"%m: at time %t ERROR: %s bit %d latching edge required during the preceding clock period.\", $time, dqs_string[i/16], i%16);\n                end\n                check_write_dqs_high <= 0;\n            end else begin\n                for (i=0; i<32; i=i+1) begin\n                    if (dll_locked && dq_in_valid) begin\n                        tm_tdqss = abs_value(1.0*tm_ck_pos - tm_dqss_pos[i]);\n                        if ((tm_tdqss < tck_avg/2.0) && (tm_tdqss > TDQSS*tck_avg))\n                            $display (\"%m: at time %t ERROR: tDQSS violation on %s bit %d\", $time, dqs_string[i/16], i%16); \n                    end\n                    if (check_write_dqs_low[i])\n                        $display (\"%m: at time %t ERROR: %s bit %d latching edge required during the preceding clock period\", $time, dqs_string[i/16], i%16);\n                end\n                check_write_preamble <= 0;\n                check_write_postamble <= 0;\n                check_write_dqs_low <= 0;\n            end\n\n            if (wr_pipeline[0] || rd_pipeline[0]) begin\n                bank = ba_pipeline[0];\n                row = row_pipeline[0];\n                col = col_pipeline[0];\n                burst_cntr = 0;\n                memory_read(bank, row, col, memory_data);\n            end\n\n            \n            if (burst_cntr < burst_length) begin\n                burst_position = col ^ burst_cntr;\n                if (!burst_order) begin\n                    burst_position[BO_BITS-1:0] = col + burst_cntr;\n                end\n                burst_cntr = burst_cntr + 1;\n            end\n\n            \n            if (wr_pipeline[WDQS_PRE + 1]) begin\n                wdqs_cntr = WDQS_PRE + bl_pipeline[WDQS_PRE + 1] + WDQS_PST - 1;\n            end\n            \n            if ((wr_pipeline[2]) && (wdq_cntr == 0)) begin \n                check_write_preamble <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n            end\n            if (wdqs_cntr > 1) begin  \n                if ((wdqs_cntr - WDQS_PST)%2) begin\n                    check_write_dqs_high <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n                end else begin\n                    check_write_dqs_low <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n                end\n            end\n            if (wdqs_cntr == WDQS_PST) begin \n                check_write_postamble <= ({DQS_BITS{1'b1}}<<16) | {DQS_BITS{1'b1}};\n            end \n            if (wdqs_cntr > 0) begin\n                wdqs_cntr = wdqs_cntr - 1;\n            end\n\n            \n            if (dq_in_valid) begin \n                bit_mask = 0;\n                if (diff_ck) begin\n                    for (i=0; i<DM_BITS; i=i+1) begin\n                        bit_mask = bit_mask | ({`DQ_PER_DQS{~dm_in_neg[i]}}<<(burst_position*DQ_BITS + i*`DQ_PER_DQS));\n                    end\n                    memory_data = (dq_in_neg<<(burst_position*DQ_BITS) & bit_mask) | (memory_data & ~bit_mask);\n                end else begin\n                    for (i=0; i<DM_BITS; i=i+1) begin\n                        bit_mask = bit_mask | ({`DQ_PER_DQS{~dm_in_pos[i]}}<<(burst_position*DQ_BITS + i*`DQ_PER_DQS));\n                    end\n                    memory_data = (dq_in_pos<<(burst_position*DQ_BITS) & bit_mask) | (memory_data & ~bit_mask);\n                end\n                dq_temp = memory_data>>(burst_position*DQ_BITS);\n                if (DEBUG) $display (\"%m: at time %t INFO: WRITE @ DQS= bank = %h row = %h col = %h data = %h\",$time, bank, row, (-1*BL_MAX & col) + burst_position, dq_temp);\n                if (burst_cntr%BL_MIN == 0) begin\n                    memory_write(bank, row, col, memory_data);\n                end\n            end\n            if (wr_pipeline[1]) begin\n                wdq_cntr = bl_pipeline[1];\n            end\n            if (wdq_cntr > 0) begin\n                wdq_cntr = wdq_cntr - 1;\n                dq_in_valid = 1'b1;\n            end else begin\n                dq_in_valid = 1'b0;\n                dqs_in_valid <= 1'b0;\n                for (i=0; i<31; i=i+1) begin\n                    wdqs_pos_cntr[i]    <= 0;\n                end\n            end\n            if (wr_pipeline[0]) begin\n                b2b_write <= 1'b0;\n            end\n            if (wr_pipeline[2]) begin\n                if (dqs_in_valid) begin\n                    b2b_write <= 1'b1;\n                end\n                dqs_in_valid <= 1'b1;\n                wr_burst_length = bl_pipeline[2];\n            end\n\n            \n            if (rd_pipeline[RDQSEN_PRE]) begin\n                rdqsen_cntr = RDQSEN_PRE + bl_pipeline[RDQSEN_PRE] + RDQSEN_PST - 1;\n            end\n            if (rdqsen_cntr > 0) begin\n                rdqsen_cntr = rdqsen_cntr - 1;\n                dqs_out_en = 1'b1;\n            end else begin\n                dqs_out_en = 1'b0;\n            end\n            \n            \n            if (rd_pipeline[RDQS_PRE]) begin\n                rdqs_cntr = RDQS_PRE + bl_pipeline[RDQS_PRE] + RDQS_PST - 1;\n            end\n            \n            if (((rd_pipeline>>1 & {RDQS_PRE{1'b1}}) > 0) && (rdq_cntr == 0)) begin \n                dqs_out = 1'b0;\n            end else if (rdqs_cntr > RDQS_PST) begin \n                dqs_out = rdqs_cntr - RDQS_PST;\n            end else if (rdqs_cntr > 0) begin \n                dqs_out = 1'b0;\n            end else begin\n                dqs_out = 1'b1;\n            end\n            if (rdqs_cntr > 0) begin\n                rdqs_cntr = rdqs_cntr - 1;\n            end\n\n            \n            if (rd_pipeline[RDQEN_PRE]) begin\n                rdqen_cntr = RDQEN_PRE + bl_pipeline[RDQEN_PRE] + RDQEN_PST;\n            end\n            if (rdqen_cntr > 0) begin\n                rdqen_cntr = rdqen_cntr - 1;\n                dq_out_en = 1'b1;\n            end else begin\n                dq_out_en = 1'b0;\n            end\n            \n            if (rd_pipeline[0]) begin\n                rdq_cntr = bl_pipeline[0];\n            end\n            if (rdq_cntr > 0) begin \n                if (mpr_en) begin\n`ifdef MPR_DQ0 \n                    if (mpr_select == 2'b00) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, calibration_pattern[burst_position]}};\n                    end else if (odts_readout && (mpr_select == 2'b11)) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, temp_sensor[burst_position]}};\n                    end else begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS-1{1'b0}}, 1'bx}};\n                    end\n`else \n                    if (mpr_select == 2'b00) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{calibration_pattern[burst_position]}}}};\n                    end else if (odts_readout && (mpr_select == 2'b11)) begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{temp_sensor[burst_position]}}}};\n                    end else begin \n                        dq_temp = {DQS_BITS{{`DQ_PER_DQS{1'bx}}}};\n                    end\n`endif\t\t\t\t   \n                    if (DEBUG) $display (\"%m: at time %t READ @ DQS MultiPurpose Register %d, col = %d,  data = %b\", $time, mpr_select, burst_position, dq_temp[0]);\n                end else begin\n                    dq_temp = memory_data>>(burst_position*DQ_BITS);\n                    if (DEBUG) $display (\"%m: at time %t INFO: READ @ DQS= bank = %h row = %h col = %h data = %h\",$time, bank, row, (-1*BL_MAX & col) + burst_position, dq_temp);\n                end\n                dq_out = dq_temp;\n                rdq_cntr = rdq_cntr - 1;\n            end else begin\n                dq_out = {DQ_BITS{1'b1}};\n            end\n\n            \n            if (RANDOM_OUT_DELAY && (dqs_out_en || (|dqs_out_en_dly) || dq_out_en || (|dq_out_en_dly))) begin\n                for (i=0; i<DQS_BITS; i=i+1) begin\n                    \n                    \n                    \n                    \n                    dqsck_max = TDQSCK;\n                    if (dqsck_max > dqsck[i] + TQH*tck_avg + TDQSQ) begin\n                        dqsck_max = dqsck[i] + TQH*tck_avg + TDQSQ;\n                    end\n                    dqsck_min = -1*TDQSCK;\n                    if (dqsck_min < dqsck[i] - TQH*tck_avg - TDQSQ) begin\n                        dqsck_min = dqsck[i] - TQH*tck_avg - TDQSQ;\n                    end\n\n                    \n                    \n                    \n                    \n                    dqsq_min = 0;\n                    if (dqsq_min < dqsck[i] - TQH*tck_avg) begin\n                        dqsq_min = dqsck[i] - TQH*tck_avg;\n                    end\n                    if (dqsck_min == dqsck_max) begin\n                        dqsck[i] = dqsck_min;\n                    end else begin\n                        dqsck[i] = $dist_uniform(seed, dqsck_min, dqsck_max);\n                    end\n                    dqsq_max = TDQSQ + dqsck[i];\n\n                    dqs_out_en_dly[i] <= #(tck_avg/2) dqs_out_en;\n                    dqs_out_dly[i]    <= #(tck_avg/2 + dqsck[i]) dqs_out;\n                    if (!write_levelization) begin\n                        for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                            dq_out_en_dly[i*`DQ_PER_DQS + j] <= #(tck_avg/2) dq_out_en;\n                            if (dqsq_min == dqsq_max) begin\n                                dq_out_dly   [i*`DQ_PER_DQS + j] <= #(tck_avg/2 + dqsq_min) dq_out[i*`DQ_PER_DQS + j];\n                            end else begin\n                                dq_out_dly   [i*`DQ_PER_DQS + j] <= #(tck_avg/2 + $dist_uniform(seed, dqsq_min, dqsq_max)) dq_out[i*`DQ_PER_DQS + j];\n                            end\n                        end\n                    end\n                end\n            end else begin\n                out_delay = tck_avg/2;\n                dqs_out_en_dly <= #(out_delay) {DQS_BITS{dqs_out_en}};\n                dqs_out_dly    <= #(out_delay) {DQS_BITS{dqs_out   }};\n                if (write_levelization !== 1'b1) begin\n                    dq_out_en_dly  <= #(out_delay) {DQ_BITS {dq_out_en }};\n                    dq_out_dly     <= #(out_delay) {DQ_BITS {dq_out    }};\n                end\n            end\n        end\n    endtask\n\n    always @ (posedge rst_n_in) begin : reset\n        integer i;\n        if (rst_n_in) begin\n            if ($time < 200000000 && check_strict_timing) \n                $display (\"%m at time %t WARNING: 200 us is required before RST_N goes inactive.\", $time);\n            if (cke_in !== 1'b0)\n                $display (\"%m: at time %t ERROR: CKE must be inactive when RST_N goes inactive.\", $time);\n            if ($time - tm_cke < 10000)\n                $display (\"%m: at time %t ERROR: CKE must be maintained inactive for 10 ns before RST_N goes inactive.\", $time);\n\n            \n`ifdef MAX_MEM\n            \n    \n    \n    \n    \n`else\n            memory_used <= 0; \n`endif\n\n        end\n    end\n\n    always @(negedge rst_n_in or posedge diff_ck or negedge diff_ck) begin : main\n        integer i;\n        if (!rst_n_in) begin\n            reset_task;\n        end else begin\n            if (!in_self_refresh && (diff_ck !== 1'b0) && (diff_ck !== 1'b1))\n                $display (\"%m: at time %t ERROR: CK and CK_N are not allowed to go to an unknown state.\", $time);\n            data_task;\n\n            \n            \n            \n            if (in_self_refresh || (in_power_down && (active_bank == 0))) begin\n                if (diff_ck) begin\n                    tjit_per_rtime = $time - tm_ck_pos - tck_avg;\n                end else begin\n                    tjit_per_rtime = $time - tm_ck_neg - tck_avg;\n                end\n                if (dll_locked && (abs_value(tjit_per_rtime) > TJIT_PER)) begin\n                    if ((tm_ck_pos - tm_cke_cmd < TCKSRE) || (ck_cntr - ck_cke_cmd < TCKSRE_TCK))\n                        $display (\"%m: at time %t ERROR: tCKSRE violation during Self Refresh or Precharge Power Down Entry\", $time);\n                    if (odt_state) begin\n                        $display (\"%m: at time %t ERROR: Clock Frequency Change Failure.  ODT must be off prior to Clock Frequency Change.\", $time);\n                        if (STOP_ON_ERROR) $stop(0);\n                    end else begin\n                        if (DEBUG) $display (\"%m: at time %t INFO: Clock Frequency Change detected.  DLL Reset is Required.\", $time);\n                        tm_freq_change <= $time;\n                        ck_freq_change <= ck_cntr;\n                        dll_locked = 0;\n                    end\n                end\n            end\n\n            if (diff_ck) begin\n                \n                if ($time > TIS) begin\n                    if ($time - tm_cke < TIS) \n                        $display (\"%m: at time %t ERROR:   tIS violation on CKE by %t\", $time, tm_cke + TIS - $time);\n                    if (cke_in) begin\n                        for (i=0; i<22; i=i+1) begin\n                            if ($time - tm_cmd_addr[i] < TIS) \n                                $display (\"%m: at time %t ERROR:   tIS violation on %s by %t\", $time, cmd_addr_string[i], tm_cmd_addr[i] + TIS - $time);\n                        end\n                    end\n                end\n\n                \n                if (dll_locked) begin\n                    if (mr_chk == 0) begin\n                        mr_chk = 1;\n                    end else if (init_mode_reg[0] && (mr_chk == 1)) begin\n                        \n                        if (cas_latency*tck_avg < CL_TIME && check_strict_timing)\n                            $display (\"%m: at time %t ERROR: CAS Latency = %d is illegal @tCK(avg) = %f\", $time, cas_latency, tck_avg);\n                        \n                        if (ceil(write_recovery*tck_avg) < TWR)\n                            $display (\"%m: at time %t ERROR: Write Recovery = %d is illegal @tCK(avg) = %f\", $time, write_recovery, tck_avg);\n                        \n\t\t\t\t\t    if (check_strict_timing) begin \n                            case (cas_write_latency)\n                                5 : if (tck_avg < 2500.0)                          $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                6 : if ((tck_avg < 1875.0) || (tck_avg >= 2500.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                7 : if ((tck_avg < 1500.0) || (tck_avg >= 1875.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                8 : if ((tck_avg < 1250.0) || (tck_avg >= 1500.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                9 : if ((tck_avg < 15e3/14) || (tck_avg >= 1250.0)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                10: if ((tck_avg < 937.5) || (tck_avg >= 15e3/14)) $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                                default :                                          $display (\"%m: at time %t ERROR: CWL = %d is illegal @tCK(avg) = %f\", $time, cas_write_latency, tck_avg);\n                            endcase\n                            \n                            if (!valid_cl(cas_latency, cas_write_latency))\n                                $display (\"%m: at time %t ERROR: CAS Latency = %d is not valid when CAS Write Latency = %d\", $time, cas_latency, cas_write_latency);\n                        end\n                        mr_chk = 2;\n                    end\n                end else if (!in_self_refresh) begin\n                    mr_chk = 0;\n                    if (ck_cntr - ck_dll_reset == TDLLK) begin\n                        dll_locked = 1;\n                    end\n                end\n\n                if (|auto_precharge_bank) begin\n                    for (i=0; i<`BANKS; i=i+1) begin\n                        \n                        \n                        \n                        if (write_precharge_bank[i]) begin\n                            if ($time - tm_bank_activate[i] >= TRAS_MIN) begin\n                                if (ck_cntr - ck_bank_write[i] >= write_latency + burst_length/2 + write_recovery) begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", $time, i);\n                                    write_precharge_bank[i] = 0;\n                                    active_bank[i] = 0;\n                                    auto_precharge_bank[i] = 0;\n                                    tm_bank_precharge[i] = $time;\n                                    tm_precharge = $time;\n                                    ck_precharge = ck_cntr;\n                                end\n                            end\n                        end\n                        \n                        \n                        \n                        \n                        if (read_precharge_bank[i]) begin\n                            if (($time - tm_bank_activate[i] >= TRAS_MIN) && (ck_cntr - ck_bank_read[i] >= additive_latency + TRTP_TCK)) begin\n                                read_precharge_bank[i] = 0;\n                                \n                                \n                                if ($time - tm_bank_read_end[i] < TRTP) begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", tm_bank_read_end[i] + TRTP, i);\n                                    active_bank[i] <= #(tm_bank_read_end[i] + TRTP - $time) 0;\n                                    auto_precharge_bank[i] <= #(tm_bank_read_end[i] + TRTP - $time) 0;\n                                    tm_bank_precharge[i] <= #(tm_bank_read_end[i] + TRTP - $time) tm_bank_read_end[i] + TRTP;\n                                    tm_precharge <= #(tm_bank_read_end[i] + TRTP - $time) tm_bank_read_end[i] + TRTP;\n                                    ck_precharge = ck_cntr;\n                                end else begin\n                                    if (DEBUG) $display (\"%m: at time %t INFO: Auto Precharge bank %d\", $time, i);\n                                    active_bank[i] = 0;\n                                    auto_precharge_bank[i] = 0;\n                                    tm_bank_precharge[i] = $time;\n                                    tm_precharge = $time;\n                                    ck_precharge = ck_cntr;\n                                end\n                            end\n                        end\n                    end\n                end\n\n                \n                if (cke_in ^ prev_cke) begin\n                    tm_cke_cmd <= $time;\n                    ck_cke_cmd <= ck_cntr;\n                end\n\n                cmd_task(cke_in, cmd_n_in, ba_in, addr_in);\n                if ((cmd_n_in == WRITE) || (cmd_n_in == READ)) begin\n                    al_pipeline[2*additive_latency] = 1'b1;\n                end\n                if (al_pipeline[0]) begin\n                    \n                    if ((rd_pipeline[2*cas_latency - 1]) && ($time - tm_bank_activate[ba_pipeline[2*cas_latency - 1]] < TRCD))\n                        $display (\"%m: at time %t ERROR:  tRCD violation during %s\", $time, cmd_string[READ]);\n                    if ((wr_pipeline[2*cas_write_latency + 1]) && ($time - tm_bank_activate[ba_pipeline[2*cas_write_latency + 1]] < TRCD))\n                        $display (\"%m: at time %t ERROR:  tRCD violation during %s\", $time, cmd_string[WRITE]);\n                    \n                    if (rd_pipeline[2*cas_latency - 1]) begin \n                        if (truebl4) begin \n                            i = ba_pipeline[2*cas_latency - 1];\n                            if ($time - tm_group_write_end[i[1]] < TWTR)\n                                $display (\"%m: at time %t ERROR:  tWTR violation during %s\", $time, cmd_string[READ]);\n                            if ($time - tm_write_end < TWTR_DG)\n                                $display (\"%m: at time %t ERROR:  tWTR_DG violation during %s\", $time, cmd_string[READ]);\n                        end else begin\n                            if ($time - tm_write_end < TWTR)\n                                $display (\"%m: at time %t ERROR:  tWTR violation during %s\", $time, cmd_string[READ]);\n                        end\n                    end\n                end\n               if (rd_pipeline) begin\n                  if (rd_pipeline[2*cas_latency - 1]) begin\n                     tm_bank_read_end[ba_pipeline[2*cas_latency - 1]] <= $time;\n                  end\n\t       end\n                for (i=0; i<`BANKS; i=i+1) begin\n\t\t    if ((ck_cntr - ck_bank_write[i] > write_latency) && (ck_cntr - ck_bank_write[i] <= write_latency + burst_length/2)) begin\n                        tm_bank_write_end[i] <= $time;\n                        tm_group_write_end[i[1]] <= $time;\n                        tm_write_end <= $time;\n                    end\n                end\n\n                \n                if (!in_self_refresh && tm_ck_pos ) begin\n                    tjit_cc_time = $time - tm_ck_pos - tck_i;\n                    tck_i   = $time - tm_ck_pos;\n                    tck_avg = tck_avg - tck_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tck_avg = tck_avg + tck_i/$itor(TDLLK);\n                    tck_sample[ck_cntr%TDLLK] = tck_i;\n                    tjit_per_rtime = tck_i - tck_avg;\n\n                    if (dll_locked && check_strict_timing) begin\n                        \n                        terr_nper_rtime = 0;\n                        for (i=0; i<12; i=i+1) begin\n                            terr_nper_rtime = terr_nper_rtime + tck_sample[i] - tck_avg;\n                            terr_nper_rtime = abs_value(terr_nper_rtime);\n                            case (i)\n                                      0 :;\n                                      1 : if (terr_nper_rtime - TERR_2PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(2per) violation by %f ps.\", $time, terr_nper_rtime - TERR_2PER);\n                                      2 : if (terr_nper_rtime - TERR_3PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(3per) violation by %f ps.\", $time, terr_nper_rtime - TERR_3PER);\n                                      3 : if (terr_nper_rtime - TERR_4PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(4per) violation by %f ps.\", $time, terr_nper_rtime - TERR_4PER);\n                                      4 : if (terr_nper_rtime - TERR_5PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(5per) violation by %f ps.\", $time, terr_nper_rtime - TERR_5PER);\n                                      5 : if (terr_nper_rtime - TERR_6PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(6per) violation by %f ps.\", $time, terr_nper_rtime - TERR_6PER);\n                                      6 : if (terr_nper_rtime - TERR_7PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(7per) violation by %f ps.\", $time, terr_nper_rtime - TERR_7PER);\n                                      7 : if (terr_nper_rtime - TERR_8PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(8per) violation by %f ps.\", $time, terr_nper_rtime - TERR_8PER);\n                                      8 : if (terr_nper_rtime - TERR_9PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(9per) violation by %f ps.\", $time, terr_nper_rtime - TERR_9PER);\n                                      9 : if (terr_nper_rtime - TERR_10PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(10per) violation by %f ps.\", $time, terr_nper_rtime - TERR_10PER);\n                                     10 : if (terr_nper_rtime - TERR_11PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(11per) violation by %f ps.\", $time, terr_nper_rtime - TERR_11PER);\n                                     11 : if (terr_nper_rtime - TERR_12PER >= 1.0) $display (\"%m: at time %t ERROR: tERR(12per) violation by %f ps.\", $time, terr_nper_rtime - TERR_12PER);\n                            endcase\n                        end\n\t\t\t\t\t   \n                        \n                        if (abs_value(tjit_per_rtime) - TJIT_PER >= 1.0) \n                            $display (\"%m: at time %t ERROR: tJIT(per) violation by %f ps.\", $time, abs_value(tjit_per_rtime) - TJIT_PER);\n                        if (abs_value(tjit_cc_time) - TJIT_CC >= 1.0) \n                            $display (\"%m: at time %t ERROR: tJIT(cc) violation by %f ps.\", $time, abs_value(tjit_cc_time) - TJIT_CC);\n                        if (TCK_MIN - tck_avg >= 1.0)\n                            $display (\"%m: at time %t ERROR: tCK(avg) minimum violation by %f ps.\", $time, TCK_MIN - tck_avg);\n                        if (tck_avg - TCK_MAX >= 1.0) \n                            $display (\"%m: at time %t ERROR: tCK(avg) maximum violation by %f ps.\", $time, tck_avg - TCK_MAX);\n\n                        \n                        if (tm_ck_neg - $time < TCL_ABS_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(abs) minimum violation on CLK by %t\", $time, TCL_ABS_MIN*tck_avg - tm_ck_neg + $time);\n                        if (tcl_avg < TCL_AVG_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(avg) minimum violation on CLK by %t\", $time, TCL_AVG_MIN*tck_avg - tcl_avg);\n                        if (tcl_avg > TCL_AVG_MAX*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCL(avg) maximum violation on CLK by %t\", $time, tcl_avg - TCL_AVG_MAX*tck_avg);\n                    end\n\n                    \n                    tch_avg = tch_avg - tch_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tch_avg = tch_avg + tch_i/$itor(TDLLK);\n                    tch_sample[ck_cntr%TDLLK] = tch_i;\n                    tjit_ch_rtime = tch_i - tch_avg;\n                    duty_cycle = tch_avg/tck_avg;\n\n                    \n                    tcl_i <= $time - tm_ck_neg;\n                end\n\n                prev_odt <= odt_in;\n                \n                ck_cntr <= ck_cntr + 1;\n                tm_ck_pos = $time;\n            end else begin\n                \n                if (!in_self_refresh) begin\n                    if (dll_locked && check_strict_timing) begin\n                        if ($time - tm_ck_pos < TCH_ABS_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(abs) minimum violation on CLK by %t\", $time, TCH_ABS_MIN*tck_avg - $time + tm_ck_pos);\n                        if (tch_avg < TCH_AVG_MIN*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(avg) minimum violation on CLK by %t\", $time, TCH_AVG_MIN*tck_avg - tch_avg);\n                        if (tch_avg > TCH_AVG_MAX*tck_avg) \n                            $display (\"%m: at time %t ERROR: tCH(avg) maximum violation on CLK by %t\", $time, tch_avg - TCH_AVG_MAX*tck_avg);\n                    end\n\t\t\t\t   \n                    \n                    tcl_avg = tcl_avg - tcl_sample[ck_cntr%TDLLK]/$itor(TDLLK);\n                    tcl_avg = tcl_avg + tcl_i/$itor(TDLLK);\n                    tcl_sample[ck_cntr%TDLLK] = tcl_i;\n\n                    \n                    tch_i <= $time - tm_ck_pos;\n                end\n                tm_ck_neg = $time;\n            end\n\n            \n            if (odt_en || dyn_odt_en) begin\n                \n                if (!in_self_refresh && diff_ck) begin\n                    if ($time - tm_odt < TIS)\n                        $display (\"%m: at time %t ERROR: tIS violation on ODT by %t\", $time, tm_odt + TIS - $time);\n                    if (prev_odt ^ odt_in) begin\n                        if (!dll_locked)\n                            $display (\"%m: at time %t WARNING: tDLLK violation during ODT transition.\", $time);\n                        if (($time - tm_load_mode < TMOD) || (ck_cntr - ck_load_mode < TMOD_TCK))\n                            $display (\"%m: at time %t ERROR:  tMOD violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqinit < TZQINIT)\n                            $display (\"%m: at time %t ERROR: TZQinit violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqoper < TZQOPER)\n                            $display (\"%m: at time %t ERROR: TZQoper violation during ODT transition\", $time);\n                        if (ck_cntr - ck_zqcs < TZQCS)\n                            $display (\"%m: at time %t ERROR: tZQcs violation during ODT transition\", $time);\n                        \n                        \n                        if (ck_cntr - ck_self_refresh < TXSDLL)\n                            $display (\"%m: at time %t ERROR: tXSDLL violation during ODT transition\", $time);\n                        if (in_self_refresh)\n                            $display (\"%m: at time %t ERROR:  Illegal ODT transition during Self Refresh.\", $time);\n                        if (!odt_in && (ck_cntr - ck_odt < ODTH4))\n                            $display (\"%m: at time %t ERROR:  ODTH4 violation during ODT transition\", $time);\n                        if (!odt_in && (ck_cntr - ck_odth8 < ODTH8))\n                            $display (\"%m: at time %t ERROR:  ODTH8 violation during ODT transition\", $time);\n                        if (($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK))\n                            $display (\"%m: at time %t WARNING: tXPDLL during ODT transition.  Synchronous or asynchronous change in termination resistance is possible.\", $time);\n\n                        \n                        \n                        \n                        \n                        if ((in_power_down && low_power && (active_bank == 0)) || ($time - tm_slow_exit_pd < TXPDLL) || (ck_cntr - ck_slow_exit_pd < TXPDLL_TCK)) begin\n                            odt_state = odt_in;\n                            if (DEBUG && odt_en) $display (\"%m: at time %t INFO: Async On Die Termination Rtt_NOM = %d Ohm\", $time, {32{odt_state}} & get_rtt_nom(odt_rtt_nom));\n                            if (odt_state) begin\n                                odt_state_dly <= #(TAONPD) odt_state;\n                            end else begin\n                                odt_state_dly <= #(TAOFPD) odt_state;\n                            end\n                        \n                        \n                        \n                        \n                        end else begin\n                            odt_pipeline[2*(write_latency - 2)] = 1'b1; \n                        end\n                        ck_odt <= ck_cntr;\n                    end\n                end\n                if (odt_pipeline[0]) begin\n                    odt_state = ~odt_state;\n                    if (DEBUG && odt_en) $display (\"%m: at time %t INFO: Sync On Die Termination Rtt_NOM = %d Ohm\", $time, {32{odt_state}} & get_rtt_nom(odt_rtt_nom));\n                    if (odt_state) begin\n                        odt_state_dly <= #(TAON) odt_state;\n                    end else begin\n                        odt_state_dly <= #(TAOF*tck_avg) odt_state;\n                    end\n                end\n                if (rd_pipeline[RDQSEN_PRE]) begin\n                    odt_cntr = 1 + RDQSEN_PRE + bl_pipeline[RDQSEN_PRE] + RDQSEN_PST - 1;\n                end\n                if (odt_cntr > 0) begin\n                    if (odt_state) begin\n                        $display (\"%m: at time %t ERROR: On Die Termination must be OFF during Read data transfer.\", $time);\n                    end\n                    odt_cntr = odt_cntr - 1;\n                end\n                if (dyn_odt_en && odt_state) begin\n                    if (DEBUG && (dyn_odt_state ^ dyn_odt_pipeline[0]))\n                        $display (\"%m: at time %t INFO: Sync On Die Termination Rtt_WR = %d Ohm\", $time, {32{dyn_odt_pipeline[0]}} & get_rtt_wr(odt_rtt_wr));\n                    dyn_odt_state = dyn_odt_pipeline[0];\n                end \n                dyn_odt_state_dly <= #(TADC*tck_avg) dyn_odt_state; \n            end\n\n            if (cke_in && write_levelization) begin\n                for (i=0; i<DQS_BITS; i=i+1) begin\n                    if ($time - tm_dqs_pos[i] < TWLH)\n                        $display (\"%m: at time %t WARNING: tWLH violation on DQS bit %d positive edge.   Indeterminate CK capture is possible.\", $time, i);\n                end\n            end\n\n            \n            if (|wr_pipeline || |rd_pipeline || |al_pipeline) begin\n                al_pipeline = al_pipeline>>1;\n                wr_pipeline = wr_pipeline>>1;\n                rd_pipeline = rd_pipeline>>1;\n                for (i=0; i<`MAX_PIPE; i=i+1) begin\n                    bl_pipeline[i] = bl_pipeline[i+1];\n                    ba_pipeline[i] = ba_pipeline[i+1];\n                    row_pipeline[i] = row_pipeline[i+1];\n                    col_pipeline[i] = col_pipeline[i+1];\n                end\n            end\n            if (|odt_pipeline || |dyn_odt_pipeline) begin\n                odt_pipeline = odt_pipeline>>1;\n                dyn_odt_pipeline = dyn_odt_pipeline>>1;\n            end\n        end\n    end\n\n    \n    task dqs_even_receiver;\n        input [3:0] i;\n        reg [63:0] bit_mask;\n        begin\n            bit_mask = {`DQ_PER_DQS{1'b1}}<<(i*`DQ_PER_DQS);\n            if (dqs_even[i]) begin\n                if (tdqs_en) begin \n                    dm_in_pos[i] = 1'b0;\n                end else begin\n                    dm_in_pos[i] = dm_in[i];\n                end\n                dq_in_pos = (dq_in & bit_mask) | (dq_in_pos & ~bit_mask);\n            end\n        end\n    endtask\n\n    always @(posedge dqs_even[ 0]) dqs_even_receiver( 0);\n    always @(posedge dqs_even[ 1]) dqs_even_receiver( 1);\n    always @(posedge dqs_even[ 2]) dqs_even_receiver( 2);\n    always @(posedge dqs_even[ 3]) dqs_even_receiver( 3);\n    always @(posedge dqs_even[ 4]) dqs_even_receiver( 4);\n    always @(posedge dqs_even[ 5]) dqs_even_receiver( 5);\n    always @(posedge dqs_even[ 6]) dqs_even_receiver( 6);\n    always @(posedge dqs_even[ 7]) dqs_even_receiver( 7);\n    always @(posedge dqs_even[ 8]) dqs_even_receiver( 8);\n    always @(posedge dqs_even[ 9]) dqs_even_receiver( 9);\n    always @(posedge dqs_even[10]) dqs_even_receiver(10);\n    always @(posedge dqs_even[11]) dqs_even_receiver(11);\n    always @(posedge dqs_even[12]) dqs_even_receiver(12);\n    always @(posedge dqs_even[13]) dqs_even_receiver(13);\n    always @(posedge dqs_even[14]) dqs_even_receiver(14);\n    always @(posedge dqs_even[15]) dqs_even_receiver(15);\n\n    task dqs_odd_receiver;\n        input [3:0] i;\n        reg [63:0] bit_mask;\n        begin\n            bit_mask = {`DQ_PER_DQS{1'b1}}<<(i*`DQ_PER_DQS);\n            if (dqs_odd[i]) begin\n                if (tdqs_en) begin \n                    dm_in_neg[i] = 1'b0;\n                end else begin\n                    dm_in_neg[i] = dm_in[i];\n                end\n                dq_in_neg = (dq_in & bit_mask) | (dq_in_neg & ~bit_mask);\n            end\n        end\n    endtask\n\n    always @(posedge dqs_odd[ 0]) dqs_odd_receiver( 0);\n    always @(posedge dqs_odd[ 1]) dqs_odd_receiver( 1);\n    always @(posedge dqs_odd[ 2]) dqs_odd_receiver( 2);\n    always @(posedge dqs_odd[ 3]) dqs_odd_receiver( 3);\n    always @(posedge dqs_odd[ 4]) dqs_odd_receiver( 4);\n    always @(posedge dqs_odd[ 5]) dqs_odd_receiver( 5);\n    always @(posedge dqs_odd[ 6]) dqs_odd_receiver( 6);\n    always @(posedge dqs_odd[ 7]) dqs_odd_receiver( 7);\n    always @(posedge dqs_odd[ 8]) dqs_odd_receiver( 8);\n    always @(posedge dqs_odd[ 9]) dqs_odd_receiver( 9);\n    always @(posedge dqs_odd[10]) dqs_odd_receiver(10);\n    always @(posedge dqs_odd[11]) dqs_odd_receiver(11);\n    always @(posedge dqs_odd[12]) dqs_odd_receiver(12);\n    always @(posedge dqs_odd[13]) dqs_odd_receiver(13);\n    always @(posedge dqs_odd[14]) dqs_odd_receiver(14);\n    always @(posedge dqs_odd[15]) dqs_odd_receiver(15);\n\n    \n    always @(posedge rst_n_in) begin\n        if ($time > 100000) begin\n            if (tm_rst_n + 100000 > $time)\n                $display (\"%m: at time %t ERROR: RST_N pulse width violation by %t\", $time, tm_rst_n + 100000 - $time);\n        end\n        tm_rst_n = $time;\n    end\n    always @(cke_in) begin\n        if (rst_n_in) begin\n            if ($time > TIH) begin\n                if ($time - tm_ck_pos < TIH) \n                    $display (\"%m: at time %t ERROR:  tIH violation on CKE by %t\", $time, tm_ck_pos + TIH - $time);\n            end\n            if ($time - tm_cke < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on CKE by %t\", $time, tm_cke + TIPW - $time);\n        end\n        tm_cke = $time;\n    end\n    always @(odt_in) begin\n        if (rst_n_in && odt_en && !in_self_refresh) begin\n            if ($time - tm_ck_pos < TIH) \n                $display (\"%m: at time %t ERROR:  tIH violation on ODT by %t\", $time, tm_ck_pos + TIH - $time);\n            if ($time - tm_odt < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on ODT by %t\", $time, tm_odt + TIPW - $time);\n        end\n        tm_odt = $time;\n    end\n\n    task cmd_addr_timing_check;\n    input i;\n    reg [4:0] i;\n    begin\n        if (rst_n_in && prev_cke) begin\n            if ((i == 0) && ($time - tm_ck_pos < TIH))\t               \n                $display (\"%m: at time %t ERROR:  tIH violation on %s by %t\", $time, cmd_addr_string[i], tm_ck_pos + TIH - $time);\n            if ((i > 0) && (cs_n_in == 0) &&($time - tm_ck_pos < TIH)) \n                $display (\"%m: at time %t ERROR:  tIH violation on %s by %t\", $time, cmd_addr_string[i], tm_ck_pos + TIH - $time);\n            if ($time - tm_cmd_addr[i] < TIPW)\n                $display (\"%m: at time %t ERROR: tIPW violation on %s by %t\", $time, cmd_addr_string[i], tm_cmd_addr[i] + TIPW - $time);\n        end\n        tm_cmd_addr[i] = $time;\n    end\n    endtask\n\n    always @(cs_n_in    ) cmd_addr_timing_check( 0);\n    always @(ras_n_in   ) cmd_addr_timing_check( 1);\n    always @(cas_n_in   ) cmd_addr_timing_check( 2);\n    always @(we_n_in    ) cmd_addr_timing_check( 3);\n    always @(ba_in  [ 0]) cmd_addr_timing_check( 4);\n    always @(ba_in  [ 1]) cmd_addr_timing_check( 5);\n    always @(ba_in  [ 2]) cmd_addr_timing_check( 6);\n    always @(addr_in[ 0]) cmd_addr_timing_check( 7);\n    always @(addr_in[ 1]) cmd_addr_timing_check( 8);\n    always @(addr_in[ 2]) cmd_addr_timing_check( 9);\n    always @(addr_in[ 3]) cmd_addr_timing_check(10);\n    always @(addr_in[ 4]) cmd_addr_timing_check(11);\n    always @(addr_in[ 5]) cmd_addr_timing_check(12);\n    always @(addr_in[ 6]) cmd_addr_timing_check(13);\n    always @(addr_in[ 7]) cmd_addr_timing_check(14);\n    always @(addr_in[ 8]) cmd_addr_timing_check(15);\n    always @(addr_in[ 9]) cmd_addr_timing_check(16);\n    always @(addr_in[10]) cmd_addr_timing_check(17);\n    always @(addr_in[11]) cmd_addr_timing_check(18);\n    always @(addr_in[12]) cmd_addr_timing_check(19);\n    always @(addr_in[13]) cmd_addr_timing_check(20);\n    always @(addr_in[14]) cmd_addr_timing_check(21);\n    always @(addr_in[15]) cmd_addr_timing_check(22);\n\n    \n    task dm_timing_check;\n    input i;\n    reg [3:0] i;\n    begin\n        if (dqs_in_valid) begin\n            if ($time - tm_dqs[i] < TDH) \n                $display (\"%m: at time %t ERROR:   tDH violation on DM bit %d by %t\", $time, i, tm_dqs[i] + TDH - $time);\n            if (check_dm_tdipw[i]) begin\n                if ($time - tm_dm[i] < TDIPW)\n                    $display (\"%m: at time %t ERROR: tDIPW violation on DM bit %d by %t\", $time, i, tm_dm[i] + TDIPW - $time);\n            end\n        end\n        check_dm_tdipw[i] <= 1'b0;\n        tm_dm[i] = $time;\n    end\n    endtask\n\n    always @(dm_in[ 0]) dm_timing_check( 0);\n    always @(dm_in[ 1]) dm_timing_check( 1);\n    always @(dm_in[ 2]) dm_timing_check( 2);\n    always @(dm_in[ 3]) dm_timing_check( 3);\n    always @(dm_in[ 4]) dm_timing_check( 4);\n    always @(dm_in[ 5]) dm_timing_check( 5);\n    always @(dm_in[ 6]) dm_timing_check( 6);\n    always @(dm_in[ 7]) dm_timing_check( 7);\n    always @(dm_in[ 8]) dm_timing_check( 8);\n    always @(dm_in[ 9]) dm_timing_check( 9);\n    always @(dm_in[10]) dm_timing_check(10);\n    always @(dm_in[11]) dm_timing_check(11);\n    always @(dm_in[12]) dm_timing_check(12);\n    always @(dm_in[13]) dm_timing_check(13);\n    always @(dm_in[14]) dm_timing_check(14);\n    always @(dm_in[15]) dm_timing_check(15);\n\n    task dq_timing_check;\n    input i;\n    reg [5:0] i;\n    begin\n        if (dqs_in_valid) begin\n            if ($time - tm_dqs[i/`DQ_PER_DQS] < TDH) \n                $display (\"%m: at time %t ERROR:   tDH violation on DQ bit %d by %t\", $time, i, tm_dqs[i/`DQ_PER_DQS] + TDH - $time);\n            if (check_dq_tdipw[i]) begin\n                if ($time - tm_dq[i] < TDIPW)\n                    $display (\"%m: at time %t ERROR: tDIPW violation on DQ bit %d by %t\", $time, i, tm_dq[i] + TDIPW - $time);\n            end\n        end\n        check_dq_tdipw[i] <= 1'b0;\n        tm_dq[i] = $time;\n    end \n    endtask\n\n    always @(dq_in[ 0]) dq_timing_check( 0);\n    always @(dq_in[ 1]) dq_timing_check( 1);\n    always @(dq_in[ 2]) dq_timing_check( 2);\n    always @(dq_in[ 3]) dq_timing_check( 3);\n    always @(dq_in[ 4]) dq_timing_check( 4);\n    always @(dq_in[ 5]) dq_timing_check( 5);\n    always @(dq_in[ 6]) dq_timing_check( 6);\n    always @(dq_in[ 7]) dq_timing_check( 7);\n    always @(dq_in[ 8]) dq_timing_check( 8);\n    always @(dq_in[ 9]) dq_timing_check( 9);\n    always @(dq_in[10]) dq_timing_check(10);\n    always @(dq_in[11]) dq_timing_check(11);\n    always @(dq_in[12]) dq_timing_check(12);\n    always @(dq_in[13]) dq_timing_check(13);\n    always @(dq_in[14]) dq_timing_check(14);\n    always @(dq_in[15]) dq_timing_check(15);\n    always @(dq_in[16]) dq_timing_check(16);\n    always @(dq_in[17]) dq_timing_check(17);\n    always @(dq_in[18]) dq_timing_check(18);\n    always @(dq_in[19]) dq_timing_check(19);\n    always @(dq_in[20]) dq_timing_check(20);\n    always @(dq_in[21]) dq_timing_check(21);\n    always @(dq_in[22]) dq_timing_check(22);\n    always @(dq_in[23]) dq_timing_check(23);\n    always @(dq_in[24]) dq_timing_check(24);\n    always @(dq_in[25]) dq_timing_check(25);\n    always @(dq_in[26]) dq_timing_check(26);\n    always @(dq_in[27]) dq_timing_check(27);\n    always @(dq_in[28]) dq_timing_check(28);\n    always @(dq_in[29]) dq_timing_check(29);\n    always @(dq_in[30]) dq_timing_check(30);\n    always @(dq_in[31]) dq_timing_check(31);\n    always @(dq_in[32]) dq_timing_check(32);\n    always @(dq_in[33]) dq_timing_check(33);\n    always @(dq_in[34]) dq_timing_check(34);\n    always @(dq_in[35]) dq_timing_check(35);\n    always @(dq_in[36]) dq_timing_check(36);\n    always @(dq_in[37]) dq_timing_check(37);\n    always @(dq_in[38]) dq_timing_check(38);\n    always @(dq_in[39]) dq_timing_check(39);\n    always @(dq_in[40]) dq_timing_check(40);\n    always @(dq_in[41]) dq_timing_check(41);\n    always @(dq_in[42]) dq_timing_check(42);\n    always @(dq_in[43]) dq_timing_check(43);\n    always @(dq_in[44]) dq_timing_check(44);\n    always @(dq_in[45]) dq_timing_check(45);\n    always @(dq_in[46]) dq_timing_check(46);\n    always @(dq_in[47]) dq_timing_check(47);\n    always @(dq_in[48]) dq_timing_check(48);\n    always @(dq_in[49]) dq_timing_check(49);\n    always @(dq_in[50]) dq_timing_check(50);\n    always @(dq_in[51]) dq_timing_check(51);\n    always @(dq_in[52]) dq_timing_check(52);\n    always @(dq_in[53]) dq_timing_check(53);\n    always @(dq_in[54]) dq_timing_check(54);\n    always @(dq_in[55]) dq_timing_check(55);\n    always @(dq_in[56]) dq_timing_check(56);\n    always @(dq_in[57]) dq_timing_check(57);\n    always @(dq_in[58]) dq_timing_check(58);\n    always @(dq_in[59]) dq_timing_check(59);\n    always @(dq_in[60]) dq_timing_check(60);\n    always @(dq_in[61]) dq_timing_check(61);\n    always @(dq_in[62]) dq_timing_check(62);\n    always @(dq_in[63]) dq_timing_check(63);\n\n    task dqs_pos_timing_check;\n    input i;\n    reg [4:0] i;\n    reg [3:0] j;\n    begin\n        if (write_levelization && i<16) begin\n            if (ck_cntr - ck_load_mode < TWLMRD) \n                $display (\"%m: at time %t ERROR: tWLMRD violation on DQS bit %d positive edge.\", $time, i);\n            if (($time - tm_ck_pos < TWLS) || ($time - tm_ck_neg < TWLS))\n                $display (\"%m: at time %t WARNING: tWLS violation on DQS bit %d positive edge.  Indeterminate CK capture is possible.\", $time, i);\n            if (DEBUG) \n                $display (\"%m: at time %t Write Leveling @ DQS ck = %b\", $time, diff_ck);\n            dq_out_en_dly[i*`DQ_PER_DQS] <= #(TWLO) 1'b1;\n            dq_out_dly[i*`DQ_PER_DQS] <= #(TWLO) diff_ck;\n            for (j=1; j<`DQ_PER_DQS; j=j+1) begin\n                dq_out_en_dly[i*`DQ_PER_DQS+j] <= #(TWLO + TWLOE) 1'b1;\n                dq_out_dly[i*`DQ_PER_DQS+j] <= #(TWLO + TWLOE) 1'b0;\n            end\n        end\n        if (dqs_in_valid && ((wdqs_pos_cntr[i] < wr_burst_length/2) || b2b_write)) begin\n            if (dqs_in[i] ^ prev_dqs_in[i]) begin\n                if (dll_locked) begin\n                    if (check_write_preamble[i]) begin\n                        if ($time - tm_dqs_pos[i] < $rtoi(TWPRE*tck_avg))\n                            $display (\"%m: at time %t ERROR: tWPRE violation on &s bit %d\", $time, dqs_string[i/16], i%16);\n                    end else if (check_write_postamble[i]) begin\n                        if ($time - tm_dqs_neg[i] < $rtoi(TWPST*tck_avg))\n                            $display (\"%m: at time %t ERROR: tWPST violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    end else begin\n                        if ($time - tm_dqs_neg[i] < $rtoi(TDQSL*tck_avg))\n                            $display (\"%m: at time %t ERROR: tDQSL violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    end\n                end\n                if ($time - tm_dm[i%16] < TDS) \n                    $display (\"%m: at time %t ERROR: tDS violation on DM bit %d by %t\", $time, i,  tm_dm[i%16] + TDS - $time);\n                if (!dq_out_en) begin\n                    for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                        if ($time - tm_dq[(i%16)*`DQ_PER_DQS+j] < TDS) \n                            $display (\"%m: at time %t ERROR: tDS violation on DQ bit %d by %t\", $time, i*`DQ_PER_DQS+j, tm_dq[(i%16)*`DQ_PER_DQS+j] + TDS - $time);\n                        check_dq_tdipw[(i%16)*`DQ_PER_DQS+j] <= 1'b1;\n                    end\n                end\n                if ((wdqs_pos_cntr[i] < wr_burst_length/2) && !b2b_write) begin\n                    wdqs_pos_cntr[i] <= wdqs_pos_cntr[i] + 1;\n                end else begin\n                    wdqs_pos_cntr[i] <= 1;\n                end\n                check_dm_tdipw[i%16] <= 1'b1;\n                check_write_preamble[i] <= 1'b0;\n                check_write_postamble[i] <= 1'b0;\n                check_write_dqs_low[i] <= 1'b0;\n                tm_dqs[i%16] <= $time;\n            end else begin\n                $display (\"%m: at time %t ERROR: Invalid latching edge on %s bit %d\", $time, dqs_string[i/16], i%16);\n            end\n        end\n        tm_dqss_pos[i] <= $time;\n        tm_dqs_pos[i] = $time;\n        prev_dqs_in[i] <= dqs_in[i];\n    end\n    endtask\n\n    always @(posedge dqs_in[ 0]) dqs_pos_timing_check( 0);\n    always @(posedge dqs_in[ 1]) dqs_pos_timing_check( 1);\n    always @(posedge dqs_in[ 2]) dqs_pos_timing_check( 2);\n    always @(posedge dqs_in[ 3]) dqs_pos_timing_check( 3);\n    always @(posedge dqs_in[ 4]) dqs_pos_timing_check( 4);\n    always @(posedge dqs_in[ 5]) dqs_pos_timing_check( 5);\n    always @(posedge dqs_in[ 6]) dqs_pos_timing_check( 6);\n    always @(posedge dqs_in[ 7]) dqs_pos_timing_check( 7);\n    always @(posedge dqs_in[ 8]) dqs_pos_timing_check( 8);\n    always @(posedge dqs_in[ 9]) dqs_pos_timing_check( 9);\n    always @(posedge dqs_in[10]) dqs_pos_timing_check(10);\n    always @(posedge dqs_in[11]) dqs_pos_timing_check(11);\n    always @(posedge dqs_in[12]) dqs_pos_timing_check(12);\n    always @(posedge dqs_in[13]) dqs_pos_timing_check(13);\n    always @(posedge dqs_in[14]) dqs_pos_timing_check(14);\n    always @(posedge dqs_in[15]) dqs_pos_timing_check(15);\n    always @(negedge dqs_in[16]) dqs_pos_timing_check(16);\n    always @(negedge dqs_in[17]) dqs_pos_timing_check(17);\n    always @(negedge dqs_in[18]) dqs_pos_timing_check(18);\n    always @(negedge dqs_in[19]) dqs_pos_timing_check(19);\n    always @(negedge dqs_in[20]) dqs_pos_timing_check(20);\n    always @(negedge dqs_in[21]) dqs_pos_timing_check(21);\n    always @(negedge dqs_in[22]) dqs_pos_timing_check(22);\n    always @(negedge dqs_in[23]) dqs_pos_timing_check(23);\n    always @(negedge dqs_in[24]) dqs_pos_timing_check(24);\n    always @(negedge dqs_in[25]) dqs_pos_timing_check(25);\n    always @(negedge dqs_in[26]) dqs_pos_timing_check(26);\n    always @(negedge dqs_in[27]) dqs_pos_timing_check(27);\n    always @(negedge dqs_in[28]) dqs_pos_timing_check(28);\n    always @(negedge dqs_in[29]) dqs_pos_timing_check(29);\n    always @(negedge dqs_in[30]) dqs_pos_timing_check(30);\n    always @(negedge dqs_in[31]) dqs_pos_timing_check(31);\n\n    task dqs_neg_timing_check;\n    input i;\n    reg [4:0] i;\n    reg [3:0] j;\n    begin\n        if (write_levelization && i<16) begin\n            if (ck_cntr - ck_load_mode < TWLDQSEN)\n                $display (\"%m: at time %t ERROR: tWLDQSEN violation on DQS bit %d.\", $time, i);\n            if ($time - tm_dqs_pos[i] < $rtoi(TDQSH*tck_avg))\n                $display (\"%m: at time %t ERROR: tDQSH violation on DQS bit %d by %t\", $time, i, tm_dqs_pos[i] + TDQSH*tck_avg - $time);\n        end\n        if (dqs_in_valid && (wdqs_pos_cntr[i] > 0) && check_write_dqs_high[i]) begin\n            if (dqs_in[i] ^ prev_dqs_in[i]) begin\n                if (dll_locked) begin\n                    if ($time - tm_dqs_pos[i] < $rtoi(TDQSH*tck_avg))\n                        $display (\"%m: at time %t ERROR: tDQSH violation on %s bit %d\", $time, dqs_string[i/16], i%16);\n                    if ($time - tm_ck_pos < $rtoi(TDSH*tck_avg))\n                        $display (\"%m: at time %t ERROR: tDSH violation on %s bit %d\", $time, dqs_string[i/16], i%16); \n                end\n                if ($time - tm_dm[i%16] < TDS) \n                    $display (\"%m: at time %t ERROR: tDS violation on DM bit %d by %t\", $time, i,  tm_dm[i%16] + TDS - $time);\n                if (!dq_out_en) begin\n                    for (j=0; j<`DQ_PER_DQS; j=j+1) begin\n                        if ($time - tm_dq[(i%16)*`DQ_PER_DQS+j] < TDS) \n                            $display (\"%m: at time %t ERROR: tDS violation on DQ bit %d by %t\", $time, i*`DQ_PER_DQS+j, tm_dq[(i%16)*`DQ_PER_DQS+j] + TDS - $time);\n                        check_dq_tdipw[(i%16)*`DQ_PER_DQS+j] <= 1'b1;\n                    end\n                end\n                check_dm_tdipw[i%16] <= 1'b1;\n                tm_dqs[i%16] <= $time;\n            end else begin\n                $display (\"%m: at time %t ERROR: Invalid latching edge on %s bit %d\", $time, dqs_string[i/16], i%16);\n            end\n        end\n        check_write_dqs_high[i] <= 1'b0;\n        tm_dqs_neg[i] = $time;\n        prev_dqs_in[i] <= dqs_in[i];\n    end\n    endtask\n\n    always @(negedge dqs_in[ 0]) dqs_neg_timing_check( 0);\n    always @(negedge dqs_in[ 1]) dqs_neg_timing_check( 1);\n    always @(negedge dqs_in[ 2]) dqs_neg_timing_check( 2);\n    always @(negedge dqs_in[ 3]) dqs_neg_timing_check( 3);\n    always @(negedge dqs_in[ 4]) dqs_neg_timing_check( 4);\n    always @(negedge dqs_in[ 5]) dqs_neg_timing_check( 5);\n    always @(negedge dqs_in[ 6]) dqs_neg_timing_check( 6);\n    always @(negedge dqs_in[ 7]) dqs_neg_timing_check( 7);\n    always @(negedge dqs_in[ 8]) dqs_neg_timing_check( 8);\n    always @(negedge dqs_in[ 9]) dqs_neg_timing_check( 9);\n    always @(negedge dqs_in[10]) dqs_neg_timing_check(10);\n    always @(negedge dqs_in[11]) dqs_neg_timing_check(11);\n    always @(negedge dqs_in[12]) dqs_neg_timing_check(12);\n    always @(negedge dqs_in[13]) dqs_neg_timing_check(13);\n    always @(negedge dqs_in[14]) dqs_neg_timing_check(14);\n    always @(negedge dqs_in[15]) dqs_neg_timing_check(15);\n    always @(posedge dqs_in[16]) dqs_neg_timing_check(16);\n    always @(posedge dqs_in[17]) dqs_neg_timing_check(17);\n    always @(posedge dqs_in[18]) dqs_neg_timing_check(18);\n    always @(posedge dqs_in[19]) dqs_neg_timing_check(19);\n    always @(posedge dqs_in[20]) dqs_neg_timing_check(20);\n    always @(posedge dqs_in[21]) dqs_neg_timing_check(21);\n    always @(posedge dqs_in[22]) dqs_neg_timing_check(22);\n    always @(posedge dqs_in[23]) dqs_neg_timing_check(23);\n    always @(posedge dqs_in[24]) dqs_neg_timing_check(24);\n    always @(posedge dqs_in[25]) dqs_neg_timing_check(25);\n    always @(posedge dqs_in[26]) dqs_neg_timing_check(26);\n    always @(posedge dqs_in[27]) dqs_neg_timing_check(27);\n    always @(posedge dqs_in[28]) dqs_neg_timing_check(28);\n    always @(posedge dqs_in[29]) dqs_neg_timing_check(29);\n    always @(posedge dqs_in[30]) dqs_neg_timing_check(30);\n    always @(posedge dqs_in[31]) dqs_neg_timing_check(31);\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: ddr3_model_c3. Module specification: This module simulates a DDR3 SDRAM memory device, implementing features such as initialization sequence, mode register settings, refresh operations, power-down modes, and various timing checks. It has input ports for control signals (rst_n, ck, ck_n, cke, cs_n, ras_n, cas_n, we_n), address and bank selection (ba, addr), data mask/termination (dm_tdqs), and data I/O (dq, dqs, dqs_n), with an output port for termination (tdqs_n). The module uses internal signals to track timing parameters, manage operation modes, and control data transfer. Key internal components include clock timing management, command decoding and execution, data read/write operations, and extensive timing checks to ensure compliance with DDR3 SDRAM specifications."
                }
            ]
        }
    ]
}