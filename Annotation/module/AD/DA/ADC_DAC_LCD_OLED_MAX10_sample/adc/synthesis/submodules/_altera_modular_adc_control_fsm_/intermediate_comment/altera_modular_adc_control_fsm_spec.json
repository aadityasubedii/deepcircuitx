{
    "spec": "Module name: altera_modular_adc_control_fsm. Module specification: This module is a finite state machine (FSM) controller for an Altera modular ADC, managing the ADC's operation including power-down, power-up, channel selection, conversion, and result handling. It has input ports for clock (clk), reset (rst_n), PLL lock status (clk_in_pll_locked), command signals (cmd_valid, cmd_channel, cmd_sop, cmd_eop), DFT clock (clk_dft), end of conversion (eoc), ADC data output (dout), and synchronization ready signal (sync_ready). Output ports include response signals (rsp_valid, rsp_channel, rsp_data, rsp_sop, rsp_eop), command ready (cmd_ready), channel select (chsel),",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: altera_modular_adc_control_fsm\n\nExplanation: This module is a finite state machine (FSM) controller for an Altera modular ADC. It manages the ADC's operation, including power-down, power-up, channel selection, conversion, and result handling. The FSM coordinates the ADC's sampling process, handles command inputs, generates control signals, and provides response outputs. It also supports features like averaging for temperature sensing and dual ADC mode synchronization. The module controls the ADC's behavior through various states, manages timing, and ensures proper sequencing of ADC operations."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports: clk, rst_n, clk_in_pll_locked, cmd_valid, cmd_channel, cmd_sop, cmd_eop, clk_dft, eoc, dout, sync_ready.\n\nExplanation:\n- clk: Main clock input\n- rst_n: Active-low reset signal\n- clk_in_pll_locked: PLL locked signal\n- cmd_valid: Command valid signal\n- cmd_channel: 5-bit command channel\n- cmd_sop: Start of packet signal for command\n- cmd_eop: End of packet signal for command\n- clk_dft: DFT clock input\n- eoc: End of conversion signal\n- dout: 12-bit ADC data output\n- sync_ready: Synchronization ready signal for dual ADC mode\n\nOutput ports: rsp_valid, rsp_channel, rsp_data, rsp_sop, rsp_eop, cmd_ready, chsel, soc, usr_pwd, tsen, sync_valid.\n\nExplanation:\n- rsp_valid: Response valid signal\n- rsp_channel: 5-bit response channel\n- rsp_data: 12-bit response data\n- rsp_sop: Start of packet signal for response\n- rsp_eop: End of packet signal for response\n- cmd_ready: Command ready signal\n- chsel: 5-bit channel select output\n- soc: Start of conversion signal\n- usr_pwd: User power-down control signal\n- tsen: Temperature sensor enable signal\n- sync_valid: Synchronization valid signal for dual ADC mode"
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals: ctrl_state, ctrl_state_nxt, clk_dft_synch_dly, eoc_synch_dly, chsel_nxt, soc_nxt, usr_pwd_nxt, tsen_nxt, prev_cmd_is_ts, cmd_fetched, pend, cmd_channel_dly, cmd_sop_dly, cmd_eop_dly, int_timer, avrg_sum, avrg_cnt_done, frst_64_ptr_done, conv_dly1_s_flp, dout_flp, prev_ctrl_state, sync_ctrl_state, sync_ctrl_state_nxt.\n\nExplanation:\n- ctrl_state, ctrl_state_nxt: Current and next state of the FSM, controlling the overall behavior of the ADC.\n- clk_dft_synch_dly, eoc_synch_dly: Delayed versions of synchronized clk_dft and eoc signals for edge detection.\n- chsel_nxt, soc_nxt, usr_pwd_nxt, tsen_nxt: Next state values for channel select, start of conversion, user power-down, and temperature sensor enable signals.\n- prev_cmd_is_ts: Flag to remember if the previous command was for temperature sensing.\n- cmd_fetched: Indicates if a command has been fetched and is being processed.\n- pend: Indicates a pending operation, used for managing conversions and responses.\n- cmd_channel_dly, cmd_sop_dly, cmd_eop_dly: Delayed versions of command signals for response generation.\n- int_timer: Internal timer for managing delays and counts in various states.\n- avrg_sum: Accumulator for averaging ADC readings, particularly for temperature sensing.\n- avrg_cnt_done: Flag indicating completion of the averaging process.\n- frst_64_ptr_done: Flag for managing the first 64 points in the averaging process.\n- conv_dly1_s_flp: Flop for conv_dly1 state, used in pend logic.\n- dout_flp: Flopped version of the ADC output data.\n- prev_ctrl_state, sync_ctrl_state, sync_ctrl_state_nxt: Used for managing synchronization in dual ADC mode."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\nmodule altera_modular_adc_control_fsm #(\n    parameter is_this_first_or_second_adc = 1,\n    parameter dual_adc_mode = 0\n) (\n    input               clk, \n    input               rst_n,\n    input               clk_in_pll_locked,\n    input               cmd_valid,\n    input [4:0]         cmd_channel,\n    input               cmd_sop,\n    input               cmd_eop,\n    input               clk_dft,\n    input               eoc,\n    input [11:0]        dout,\n    input               sync_ready,\n\n    output reg          rsp_valid,\n    output reg [4:0]    rsp_channel,\n    output reg [11:0]   rsp_data,\n    output reg          rsp_sop,\n    output reg          rsp_eop,\n    output reg          cmd_ready,\n    output reg [4:0]    chsel,\n    output reg          soc,\n    output reg          usr_pwd,\n    output reg          tsen,\n    output reg          sync_valid\n\n);\n\nreg [4:0]   ctrl_state;\nreg [4:0]   ctrl_state_nxt;\nreg         clk_dft_synch_dly;\nreg         eoc_synch_dly;\nreg [4:0]   chsel_nxt;\nreg         soc_nxt;\nreg         usr_pwd_nxt;\nreg         tsen_nxt;\nreg         prev_cmd_is_ts;\nreg         cmd_fetched;\nreg         pend;\nreg [4:0]   cmd_channel_dly;\nreg         cmd_sop_dly;\nreg         cmd_eop_dly;\nreg [7:0]   int_timer;\nreg [17:0]  avrg_sum;\nreg         avrg_cnt_done;\nreg         frst_64_ptr_done;\nreg         conv_dly1_s_flp;\nreg [11:0]  dout_flp;\nreg [4:0]   prev_ctrl_state;\nreg [4:0]   sync_ctrl_state;\nreg [4:0]   sync_ctrl_state_nxt;\n\nwire        clk_dft_synch;\nwire        eoc_synch;\nwire        clk_dft_lh;\nwire        clk_dft_hl;\nwire        eoc_hl;\nwire        cmd_is_rclb;\nwire        cmd_is_ts;\nwire        arc_conv_conv_dly1;\nwire        arc_sync1_conv_dly1;\nwire        arc_wait_pend_wait_pend_dly1;\nwire        arc_sync1_wait_pend_dly1;\nwire        arc_to_conv;\nwire        arc_to_avrg_cnt;\nwire        load_rsp;\nwire        load_cmd_ready;\nwire        arc_getcmd_w_pwrdwn;\nwire        arc_getcmd_pwrdwn;\nwire        load_cmd_fetched;\nwire        load_int_timer;\nwire        incr_int_timer;\nwire        arc_out_from_pwrup_soc;\nwire        clr_cmd_fetched;\nwire        adc_change_mode;\nwire        add_avrg_sum;\nwire        add_avrg_sum_run;\nwire        clear_avrg_sum;\nwire        clear_avrg_cnt_done;\nwire        set_frst_64_ptr_done;\nwire        clear_frst_64_ptr_done;\nwire [11:0] fifo_q;\nwire        fifo_sclr;\nwire        fifo_rdreq;\nwire        fifo_wrreq;\nwire        putresp_s;\nwire        putresp_pend_s;\nwire        pwrdwn_s;\nwire        pwrdwn_tsen_s;\nwire        avrg_cnt_s;\nwire        wait_pend_dly1_s;\nwire        conv_dly1_s;\nwire        conv_s;\nwire        putresp_dly3_s;\nwire        load_dout;\nwire        avrg_enable;\nwire [11:0] rsp_data_nxt;\n\nlocalparam [4:0]    IDLE                = 5'b00000;\nlocalparam [4:0]    PWRDWN              = 5'b00001;\nlocalparam [4:0]    PWRDWN_TSEN         = 5'b00010;\nlocalparam [4:0]    PWRDWN_DONE         = 5'b00011;\nlocalparam [4:0]    PWRUP_CH            = 5'b00100;\nlocalparam [4:0]    PWRUP_SOC           = 5'b00101;\nlocalparam [4:0]    WAIT                = 5'b00110;\nlocalparam [4:0]    GETCMD              = 5'b00111;\nlocalparam [4:0]    GETCMD_W            = 5'b01000;\nlocalparam [4:0]    PRE_CONV            = 5'b01001;\nlocalparam [4:0]    CONV                = 5'b01010; \n                                                    \n                                                    \nlocalparam [4:0]    CONV_DLY1           = 5'b01011; \nlocalparam [4:0]    PUTRESP             = 5'b01100; \nlocalparam [4:0]    PUTRESP_DLY1        = 5'b01101;\nlocalparam [4:0]    PUTRESP_DLY2        = 5'b01110;\nlocalparam [4:0]    PUTRESP_DLY3        = 5'b01111;\nlocalparam [4:0]    WAIT_PEND           = 5'b10000; \n                                                    \n                                                    \nlocalparam [4:0]    WAIT_PEND_DLY1      = 5'b10001; \nlocalparam [4:0]    PUTRESP_PEND        = 5'b10010; \nlocalparam [4:0]    AVRG_CNT            = 5'b10011;\nlocalparam [4:0]    SYNC1               = 5'b10100; \n\nlocalparam [7:0]    NUM_AVRG_POINTS     = 8'd64;\n\n\n\n\naltera_std_synchronizer #(\n    .depth    (2)\n) u_clk_dft_synchronizer (\n    .clk        (clk),\n    .reset_n    (rst_n),\n    .din        (clk_dft),\n    .dout       (clk_dft_synch)\n);\n\naltera_std_synchronizer #(\n    .depth    (2)\n) u_eoc_synchronizer (\n    .clk        (clk),\n    .reset_n    (rst_n),\n    .din        (eoc),\n    .dout       (eoc_synch)\n);\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_dft_synch_dly   <= 1'b0;\n        eoc_synch_dly       <= 1'b0;\n    end\n    else begin\n        clk_dft_synch_dly   <= clk_dft_synch;\n        eoc_synch_dly       <= eoc_synch;\n    end\nend\n\nassign clk_dft_lh   = clk_dft_synch & ~clk_dft_synch_dly;\nassign clk_dft_hl   = ~clk_dft_synch & clk_dft_synch_dly;\nassign eoc_hl       = ~eoc_synch & eoc_synch_dly;\n\n\n\n\n\n\ngenerate\nif (dual_adc_mode == 1) begin\n\n    \n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            prev_ctrl_state   <= IDLE;\n        else\n            prev_ctrl_state   <= ctrl_state;\n    end\n\n    \n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            sync_ctrl_state   <= IDLE;\n        else\n            sync_ctrl_state   <= sync_ctrl_state_nxt;\n    end\n\nend\nelse begin\n\n    always @* begin\n        prev_ctrl_state = 5'h0;\n        sync_ctrl_state = 5'h0;\n    end\n\nend\nendgenerate\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        ctrl_state   <= IDLE;\n    else\n        ctrl_state   <= ctrl_state_nxt;\nend\n\n\nalways @* begin\n\n    \n    sync_ctrl_state_nxt = sync_ctrl_state;\n    sync_valid          = 1'b0;\n\n    case (ctrl_state)\n        IDLE: begin\n            if (clk_in_pll_locked)\n                ctrl_state_nxt = PWRDWN;\n            else\n                ctrl_state_nxt = IDLE;\n        end\n\n        PWRDWN: begin\n            if (int_timer[6])\n                ctrl_state_nxt = PWRDWN_TSEN;\n            else\n                ctrl_state_nxt = PWRDWN;\n        end\n\n        PWRDWN_TSEN: begin\n            if (int_timer[7])\n                ctrl_state_nxt = PWRDWN_DONE;\n            else\n                ctrl_state_nxt = PWRDWN_TSEN;\n        end\n\n        PWRDWN_DONE: begin\n            if (dual_adc_mode == 1) begin\n                if (clk_dft_lh) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = PWRUP_CH;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PWRDWN_DONE;\n                end\n\n                if (clk_dft_lh) begin\n                    sync_ctrl_state_nxt = PWRUP_CH;\n                    sync_valid          = 1'b1;\n                end\n                \n            end\n            else begin\n                if (clk_dft_lh)\n                    ctrl_state_nxt = PWRUP_CH;\n                else\n                    ctrl_state_nxt = PWRDWN_DONE;\n            end\n        end\n\n        PWRUP_CH: begin\n            if (dual_adc_mode == 1) begin\n                if (clk_dft_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = PWRUP_SOC;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PWRUP_CH;\n                end\n\n                if (clk_dft_hl) begin\n                    sync_ctrl_state_nxt = PWRUP_SOC;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (clk_dft_hl)\n                    ctrl_state_nxt = PWRUP_SOC;\n                else\n                    ctrl_state_nxt = PWRUP_CH;\n            end\n        end\n\n        PWRUP_SOC: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready) begin\n                        if (cmd_fetched & ~cmd_is_rclb)\n                            ctrl_state_nxt = CONV;\n                        else if (cmd_fetched & cmd_is_rclb)\n                            ctrl_state_nxt = PUTRESP;\n                        else if (cmd_valid)\n                            ctrl_state_nxt = GETCMD;\n                        else\n                            ctrl_state_nxt = WAIT;\n                    end\n                    else begin\n                        ctrl_state_nxt = SYNC1;\n                    end\n                end\n                else begin\n                    ctrl_state_nxt = PWRUP_SOC;\n                end\n\n                if (eoc_hl) begin\n                    if (cmd_fetched & ~cmd_is_rclb)\n                        sync_ctrl_state_nxt = CONV;\n                    else if (cmd_fetched & cmd_is_rclb)\n                        sync_ctrl_state_nxt = PUTRESP;\n                    else if (cmd_valid)\n                        sync_ctrl_state_nxt = GETCMD;\n                    else\n                        sync_ctrl_state_nxt = WAIT;\n\n                    sync_valid  = 1'b1;\n                end\n\n            end\n            else begin\n                if (cmd_fetched & ~cmd_is_rclb & eoc_hl)\n                    ctrl_state_nxt = CONV;\n                else if (cmd_fetched & cmd_is_rclb & eoc_hl)\n                    ctrl_state_nxt = PUTRESP;\n                else if (cmd_valid & eoc_hl)\n                    ctrl_state_nxt = GETCMD;\n                else if (eoc_hl)\n                    ctrl_state_nxt = WAIT;\n                else\n                    ctrl_state_nxt = PWRUP_SOC;\n            end\n        end\n\n        SYNC1: begin\n            if (sync_ready)\n                ctrl_state_nxt = sync_ctrl_state;   \n            else\n                ctrl_state_nxt = prev_ctrl_state;   \n\n            sync_valid  = 1'b1;\n\n        end\n        \n        WAIT: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD_W;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        GETCMD_W: begin\n            if (cmd_is_rclb | adc_change_mode)\n                ctrl_state_nxt = PWRDWN;\n            else\n                ctrl_state_nxt = PRE_CONV;\n        end\n\n        PRE_CONV: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = CONV;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PRE_CONV;\n                end\n\n                if (eoc_hl) begin\n                    sync_ctrl_state_nxt = CONV;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl)\n                    ctrl_state_nxt = CONV;\n                else\n                    ctrl_state_nxt = PRE_CONV;\n            end\n        end\n\n        GETCMD: begin\n            if ((cmd_is_rclb | adc_change_mode) & ~pend)\n                ctrl_state_nxt = PWRDWN;\n            else if ((cmd_is_rclb | adc_change_mode) & pend)\n                ctrl_state_nxt = WAIT_PEND;\n            else\n                ctrl_state_nxt = CONV;\n        end\n\n        CONV: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready) begin\n                        if (avrg_enable & ~avrg_cnt_done)\n                            ctrl_state_nxt = AVRG_CNT;\n                        else\n                            ctrl_state_nxt = CONV_DLY1;\n                    end\n                    else begin\n                        ctrl_state_nxt = SYNC1;\n                    end\n                end\n                else begin\n                    ctrl_state_nxt = CONV;\n                end\n\n                if (eoc_hl) begin\n                    if (avrg_enable & ~avrg_cnt_done)\n                        sync_ctrl_state_nxt = AVRG_CNT;\n                    else \n                        sync_ctrl_state_nxt = CONV_DLY1;\n\n                    sync_valid  = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl & avrg_enable & ~avrg_cnt_done)\n                    ctrl_state_nxt = AVRG_CNT;\n                else if (eoc_hl)\n                    ctrl_state_nxt = CONV_DLY1;\n                else\n                    ctrl_state_nxt = CONV;\n            end\n        end\n        \n        AVRG_CNT: begin\n            ctrl_state_nxt = CONV;\n        end\n        \n        CONV_DLY1: begin\n            ctrl_state_nxt = PUTRESP;\n        end\n\n        PUTRESP: begin\n            ctrl_state_nxt = PUTRESP_DLY1;\n        end\n        \n        PUTRESP_DLY1: begin\n            ctrl_state_nxt = PUTRESP_DLY2;\n        end\n        \n        PUTRESP_DLY2: begin\n            ctrl_state_nxt = PUTRESP_DLY3;\n        end\n\n        PUTRESP_DLY3: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD;\n            else if (pend)\n                ctrl_state_nxt = WAIT_PEND;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        WAIT_PEND: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = WAIT_PEND_DLY1;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = WAIT_PEND;\n                end\n\n                if (eoc_hl) begin\n                    sync_ctrl_state_nxt = WAIT_PEND_DLY1;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl)\n                    ctrl_state_nxt = WAIT_PEND_DLY1;\n                else\n                    ctrl_state_nxt = WAIT_PEND;\n            end\n        end\n        \n        WAIT_PEND_DLY1: begin\n            ctrl_state_nxt = PUTRESP_PEND;\n        end\n        \n        PUTRESP_PEND: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        default: begin\n            ctrl_state_nxt = IDLE;\n        end\n\n    endcase\nend\n\n\n\n\n\n\nalways @* begin\n    chsel_nxt       = chsel;\n    soc_nxt         = soc;\n    usr_pwd_nxt     = usr_pwd;\n    tsen_nxt        = tsen;\n\n    case (ctrl_state_nxt)\n        IDLE: begin\n            chsel_nxt   = 5'b11110;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            tsen_nxt    = 1'b0;\n        end\n\n        PWRDWN: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            tsen_nxt    = tsen;\n        end\n\n        PWRDWN_TSEN: begin\n            \n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            if (cmd_fetched & cmd_is_ts)        \n                tsen_nxt    = 1'b1;\n            else if (cmd_fetched & cmd_is_rclb) \n                tsen_nxt    = tsen;\n            else\n                tsen_nxt    = 1'b0;             \n            \n            \n            \n            if (cmd_fetched & (cmd_is_ts | (cmd_is_rclb & tsen)))   \n                chsel_nxt   = 5'b10001;\n            else\n                chsel_nxt   = 5'b11110;                                \n        end\n\n        PWRDWN_DONE: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b0;\n            tsen_nxt    = tsen;\n        end\n\n        PWRUP_CH: begin\n            \n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = 1'b0;\n            tsen_nxt    = tsen;\n        end\n\n        PWRUP_SOC: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b1;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        SYNC1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        WAIT: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        GETCMD_W: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PRE_CONV: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        GETCMD: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        CONV: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        AVRG_CNT: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        CONV_DLY1: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        PUTRESP_DLY1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP_DLY2: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        PUTRESP_DLY3: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        WAIT_PEND: begin\n            \n            if (tsen)\n                chsel_nxt   = chsel;         \n            else                             \n                chsel_nxt   = 5'b11110;     \n                                            \n                                            \n                                            \n                                            \n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        WAIT_PEND_DLY1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP_PEND: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        default: begin\n            chsel_nxt   = 5'bx;\n            soc_nxt     = 1'bx;\n            usr_pwd_nxt = 1'bx;\n            tsen_nxt    = 1'bx;\n        end\n\n    endcase\nend\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        chsel       <= 5'b11110;\n        soc         <= 1'b0;\n        usr_pwd     <= 1'b1;\n        tsen        <= 1'b0;\n    end\n    else begin\n        chsel       <= chsel_nxt;\n        soc         <= soc_nxt;\n        usr_pwd     <= usr_pwd_nxt;\n        tsen        <= tsen_nxt;\n\n    end\nend\n\n\n\n\n\n\n\nassign arc_conv_conv_dly1               = (ctrl_state == CONV) & (ctrl_state_nxt == CONV_DLY1);\nassign arc_wait_pend_wait_pend_dly1     = (ctrl_state == WAIT_PEND) & (ctrl_state_nxt == WAIT_PEND_DLY1);\nassign arc_to_avrg_cnt                  = ((ctrl_state == CONV) & (ctrl_state_nxt == AVRG_CNT)) | ((ctrl_state == SYNC1) & (ctrl_state_nxt == AVRG_CNT));\n\n\n\nassign arc_sync1_conv_dly1              = (ctrl_state == SYNC1) & (ctrl_state_nxt == CONV_DLY1);        \nassign arc_sync1_wait_pend_dly1         = (ctrl_state == SYNC1) & (ctrl_state_nxt == WAIT_PEND_DLY1);   \n\n\n\n\n\nassign putresp_s        = (ctrl_state == PUTRESP);\nassign putresp_pend_s   = (ctrl_state == PUTRESP_PEND);\nassign pwrdwn_s         = (ctrl_state == PWRDWN);\nassign pwrdwn_tsen_s    = (ctrl_state == PWRDWN_TSEN);\nassign avrg_cnt_s       = (ctrl_state == AVRG_CNT);\nassign wait_pend_dly1_s = (ctrl_state == WAIT_PEND_DLY1);\nassign conv_dly1_s      = (ctrl_state == CONV_DLY1);\nassign conv_s           = (ctrl_state == CONV);\nassign putresp_dly3_s   = (ctrl_state == PUTRESP_DLY3);\n\n\n\n\n\n\nassign load_rsp                     = (putresp_s & ~cmd_is_rclb & pend) | putresp_pend_s;\nassign load_dout                    = ((arc_conv_conv_dly1 | arc_sync1_conv_dly1) & ~cmd_is_rclb & pend) | arc_wait_pend_wait_pend_dly1 | arc_sync1_wait_pend_dly1 | ((int_timer != 8'h0) & arc_to_avrg_cnt);\nassign load_cmd_ready               = putresp_s;\nassign arc_to_conv                  = (ctrl_state != CONV) & (ctrl_state != AVRG_CNT) & ~((ctrl_state == SYNC1) & (prev_ctrl_state == CONV)) & (ctrl_state_nxt == CONV);\n\nassign arc_getcmd_w_pwrdwn          = (ctrl_state == GETCMD_W) & (ctrl_state_nxt == PWRDWN);\nassign arc_getcmd_pwrdwn            = (ctrl_state == GETCMD) & (ctrl_state_nxt == PWRDWN);\nassign load_cmd_fetched             = arc_getcmd_w_pwrdwn | arc_getcmd_pwrdwn;\nassign load_int_timer               = arc_getcmd_w_pwrdwn | arc_getcmd_pwrdwn | arc_to_conv; \nassign incr_int_timer               = pwrdwn_s | pwrdwn_tsen_s | avrg_cnt_s; \n\nassign arc_out_from_pwrup_soc       = ((ctrl_state == PWRUP_SOC) & (ctrl_state_nxt != PWRUP_SOC) & (ctrl_state_nxt != SYNC1)) |\n                                        ((ctrl_state == SYNC1) & (prev_ctrl_state == PWRUP_SOC) & (ctrl_state_nxt != PWRUP_SOC));\nassign clr_cmd_fetched              = arc_out_from_pwrup_soc;\n\n\n\n\n\nassign cmd_is_rclb      = (cmd_channel == 5'b11111);\nassign cmd_is_ts        = (cmd_channel == 5'b10001);\nassign adc_change_mode  = (~prev_cmd_is_ts & cmd_is_ts) | (prev_cmd_is_ts & ~cmd_is_ts);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        prev_cmd_is_ts  <= 1'b0;\n    else if (load_cmd_ready & ~cmd_is_rclb)\n        prev_cmd_is_ts  <= cmd_is_ts;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cmd_fetched  <= 1'b0;\n    else if (load_cmd_fetched)\n        cmd_fetched  <= 1'b1;\n    else if (clr_cmd_fetched)\n        cmd_fetched  <= 1'b0;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        conv_dly1_s_flp <= 1'b0;\n    else\n        conv_dly1_s_flp <= conv_dly1_s;\nend\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pend <= 1'b0;\n    else if (conv_dly1_s_flp)\n        pend <= 1'b1;\n    else if (wait_pend_dly1_s)\n        pend <= 1'b0;\n\nend\n\n\n\n\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dout_flp <= 12'd0;\n    else if (load_dout) \n        dout_flp <= dout;\nend\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        int_timer <= 8'h0;\n    else if (load_int_timer)\n        int_timer <= 8'h0;\n    else if (incr_int_timer)\n        int_timer <= int_timer + 8'h1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        avrg_cnt_done <= 1'b0;\n    else if ((int_timer == (NUM_AVRG_POINTS - 8'd1)) & conv_s)\n        avrg_cnt_done <= 1'b1;\n    else if (clear_avrg_cnt_done)\n        avrg_cnt_done <= 1'b0;\nend\n\nassign clear_avrg_cnt_done = putresp_dly3_s & ~cmd_valid; \n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cmd_channel_dly <= 5'h0;\n        cmd_sop_dly     <= 1'b0;\n        cmd_eop_dly     <= 1'b0;\n    end\n    else if (load_cmd_ready) begin\n        cmd_channel_dly <= cmd_channel;\n        cmd_sop_dly     <= cmd_sop;\n        cmd_eop_dly     <= cmd_eop;\n    end\nend\n\n\n\n\n\n\n\n\nassign avrg_enable = cmd_is_ts;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        avrg_sum    <= 18'h0;\n    else if (clear_avrg_sum)\n        avrg_sum    <= 18'h0;\n    else if (add_avrg_sum_run)\n        avrg_sum  <= (avrg_sum - fifo_q) + {6'h0, dout_flp};\n    else if (add_avrg_sum)\n        avrg_sum  <= avrg_sum + {6'h0, dout_flp};\nend\n\nassign add_avrg_sum     = ((int_timer != 8'h0) & avrg_cnt_s) |  \n                            (conv_dly1_s & avrg_enable & pend) |    \n                            (conv_dly1_s & avrg_enable & ~pend & ~frst_64_ptr_done) | \n                            (wait_pend_dly1_s & prev_cmd_is_ts); \n\nassign add_avrg_sum_run = set_frst_64_ptr_done & frst_64_ptr_done;\n\nassign clear_avrg_sum           = ~avrg_cnt_done & putresp_pend_s;  \n                                                                    \n\nassign set_frst_64_ptr_done     = (wait_pend_dly1_s & prev_cmd_is_ts) | \n                                    (conv_dly1_s & avrg_enable & pend); \n                                                                        \n\nassign clear_frst_64_ptr_done   = clear_avrg_sum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        frst_64_ptr_done <= 1'b0;\n    else if (set_frst_64_ptr_done)\n        frst_64_ptr_done <= 1'b1;\n    else if (clear_frst_64_ptr_done)\n        frst_64_ptr_done <= 1'b0;\nend\n\nassign fifo_sclr    = clear_avrg_sum;\nassign fifo_rdreq   = (((arc_wait_pend_wait_pend_dly1 | arc_sync1_wait_pend_dly1) & prev_cmd_is_ts) | ((arc_conv_conv_dly1 | arc_sync1_conv_dly1) & avrg_enable & pend)) & frst_64_ptr_done;\nassign fifo_wrreq   = ((int_timer != 8'h0) & avrg_cnt_s) |\n                        (conv_dly1_s & avrg_enable & pend) |\n                        (conv_dly1_s & avrg_enable & ~pend & ~frst_64_ptr_done) |\n                        (wait_pend_dly1_s & prev_cmd_is_ts);\n\naltera_modular_adc_control_avrg_fifo ts_avrg_fifo (\n    .clock      (clk),\n    .data       (dout_flp),\n    .rdreq      (fifo_rdreq),\n    .wrreq      (fifo_wrreq),\n    .sclr       (fifo_sclr),\n    .empty      (),\n    .full       (),\n    .q          (fifo_q)\n);\n\n\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rsp_valid   <= 1'b0;\n        rsp_channel <= 5'h0;\n        rsp_data    <= 12'h0;\n        rsp_sop     <= 1'b0;\n        rsp_eop     <= 1'b0;\n    end\n    else if (load_rsp) begin\n        rsp_valid   <= 1'b1;\n        rsp_channel <= cmd_channel_dly;\n        rsp_data    <= rsp_data_nxt;\n        rsp_sop     <= cmd_sop_dly;\n        rsp_eop     <= cmd_eop_dly;\n    end \n    else begin\n        rsp_valid   <= 1'b0;\n        rsp_channel <= 5'h0;\n        rsp_data    <= 12'h0;\n        rsp_sop     <= 1'b0;\n        rsp_eop     <= 1'b0;\n    end\nend\n\ngenerate\nif (is_this_first_or_second_adc == 2) begin\n    assign rsp_data_nxt = prev_cmd_is_ts ? 12'h0 : dout_flp;    \nend\nelse begin\n    assign rsp_data_nxt = prev_cmd_is_ts ? avrg_sum[17:6] : dout_flp;\nend\nendgenerate\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cmd_ready   <= 1'b0;\n    else if (load_cmd_ready)\n        cmd_ready   <= 1'b1;\n    else\n        cmd_ready   <= 1'b0;\nend\n\nendmodule\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: altera_modular_adc_control_fsm. Module specification: This module is a finite state machine (FSM) controller for an Altera modular ADC, managing the ADC's operation including power-down, power-up, channel selection, conversion, and result handling. It has input ports for clock (clk), reset (rst_n), PLL lock status (clk_in_pll_locked), command signals (cmd_valid, cmd_channel, cmd_sop, cmd_eop), DFT clock (clk_dft), end of conversion (eoc), ADC data output (dout), and synchronization ready signal (sync_ready). Output ports include response signals (rsp_valid, rsp_channel, rsp_data, rsp_sop, rsp_eop), command ready (cmd_ready), channel select (chsel),"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: altera_modular_adc_control_fsm\n\nExplanation: This module is a finite state machine (FSM) controller for an Altera modular ADC. It manages the ADC's operation, including power-down, power-up, channel selection, conversion, and result handling. The FSM coordinates the ADC's sampling process, handles command inputs, generates control signals, and provides response outputs. It also supports features like averaging for temperature sensing and dual ADC mode synchronization. The module controls the ADC's behavior through various states, manages timing, and ensures proper sequencing of ADC operations."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports: clk, rst_n, clk_in_pll_locked, cmd_valid, cmd_channel, cmd_sop, cmd_eop, clk_dft, eoc, dout, sync_ready.\n\nExplanation:\n- clk: Main clock input\n- rst_n: Active-low reset signal\n- clk_in_pll_locked: PLL locked signal\n- cmd_valid: Command valid signal\n- cmd_channel: 5-bit command channel\n- cmd_sop: Start of packet signal for command\n- cmd_eop: End of packet signal for command\n- clk_dft: DFT clock input\n- eoc: End of conversion signal\n- dout: 12-bit ADC data output\n- sync_ready: Synchronization ready signal for dual ADC mode\n\nOutput ports: rsp_valid, rsp_channel, rsp_data, rsp_sop, rsp_eop, cmd_ready, chsel, soc, usr_pwd, tsen, sync_valid.\n\nExplanation:\n- rsp_valid: Response valid signal\n- rsp_channel: 5-bit response channel\n- rsp_data: 12-bit response data\n- rsp_sop: Start of packet signal for response\n- rsp_eop: End of packet signal for response\n- cmd_ready: Command ready signal\n- chsel: 5-bit channel select output\n- soc: Start of conversion signal\n- usr_pwd: User power-down control signal\n- tsen: Temperature sensor enable signal\n- sync_valid: Synchronization valid signal for dual ADC mode"
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals: ctrl_state, ctrl_state_nxt, clk_dft_synch_dly, eoc_synch_dly, chsel_nxt, soc_nxt, usr_pwd_nxt, tsen_nxt, prev_cmd_is_ts, cmd_fetched, pend, cmd_channel_dly, cmd_sop_dly, cmd_eop_dly, int_timer, avrg_sum, avrg_cnt_done, frst_64_ptr_done, conv_dly1_s_flp, dout_flp, prev_ctrl_state, sync_ctrl_state, sync_ctrl_state_nxt.\n\nExplanation:\n- ctrl_state, ctrl_state_nxt: Current and next state of the FSM, controlling the overall behavior of the ADC.\n- clk_dft_synch_dly, eoc_synch_dly: Delayed versions of synchronized clk_dft and eoc signals for edge detection.\n- chsel_nxt, soc_nxt, usr_pwd_nxt, tsen_nxt: Next state values for channel select, start of conversion, user power-down, and temperature sensor enable signals.\n- prev_cmd_is_ts: Flag to remember if the previous command was for temperature sensing.\n- cmd_fetched: Indicates if a command has been fetched and is being processed.\n- pend: Indicates a pending operation, used for managing conversions and responses.\n- cmd_channel_dly, cmd_sop_dly, cmd_eop_dly: Delayed versions of command signals for response generation.\n- int_timer: Internal timer for managing delays and counts in various states.\n- avrg_sum: Accumulator for averaging ADC readings, particularly for temperature sensing.\n- avrg_cnt_done: Flag indicating completion of the averaging process.\n- frst_64_ptr_done: Flag for managing the first 64 points in the averaging process.\n- conv_dly1_s_flp: Flop for conv_dly1 state, used in pend logic.\n- dout_flp: Flopped version of the ADC output data.\n- prev_ctrl_state, sync_ctrl_state, sync_ctrl_state_nxt: Used for managing synchronization in dual ADC mode."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 1ps\n\n\nmodule altera_modular_adc_control_fsm #(\n    parameter is_this_first_or_second_adc = 1,\n    parameter dual_adc_mode = 0\n) (\n    input               clk, \n    input               rst_n,\n    input               clk_in_pll_locked,\n    input               cmd_valid,\n    input [4:0]         cmd_channel,\n    input               cmd_sop,\n    input               cmd_eop,\n    input               clk_dft,\n    input               eoc,\n    input [11:0]        dout,\n    input               sync_ready,\n\n    output reg          rsp_valid,\n    output reg [4:0]    rsp_channel,\n    output reg [11:0]   rsp_data,\n    output reg          rsp_sop,\n    output reg          rsp_eop,\n    output reg          cmd_ready,\n    output reg [4:0]    chsel,\n    output reg          soc,\n    output reg          usr_pwd,\n    output reg          tsen,\n    output reg          sync_valid\n\n);\n\nreg [4:0]   ctrl_state;\nreg [4:0]   ctrl_state_nxt;\nreg         clk_dft_synch_dly;\nreg         eoc_synch_dly;\nreg [4:0]   chsel_nxt;\nreg         soc_nxt;\nreg         usr_pwd_nxt;\nreg         tsen_nxt;\nreg         prev_cmd_is_ts;\nreg         cmd_fetched;\nreg         pend;\nreg [4:0]   cmd_channel_dly;\nreg         cmd_sop_dly;\nreg         cmd_eop_dly;\nreg [7:0]   int_timer;\nreg [17:0]  avrg_sum;\nreg         avrg_cnt_done;\nreg         frst_64_ptr_done;\nreg         conv_dly1_s_flp;\nreg [11:0]  dout_flp;\nreg [4:0]   prev_ctrl_state;\nreg [4:0]   sync_ctrl_state;\nreg [4:0]   sync_ctrl_state_nxt;\n\nwire        clk_dft_synch;\nwire        eoc_synch;\nwire        clk_dft_lh;\nwire        clk_dft_hl;\nwire        eoc_hl;\nwire        cmd_is_rclb;\nwire        cmd_is_ts;\nwire        arc_conv_conv_dly1;\nwire        arc_sync1_conv_dly1;\nwire        arc_wait_pend_wait_pend_dly1;\nwire        arc_sync1_wait_pend_dly1;\nwire        arc_to_conv;\nwire        arc_to_avrg_cnt;\nwire        load_rsp;\nwire        load_cmd_ready;\nwire        arc_getcmd_w_pwrdwn;\nwire        arc_getcmd_pwrdwn;\nwire        load_cmd_fetched;\nwire        load_int_timer;\nwire        incr_int_timer;\nwire        arc_out_from_pwrup_soc;\nwire        clr_cmd_fetched;\nwire        adc_change_mode;\nwire        add_avrg_sum;\nwire        add_avrg_sum_run;\nwire        clear_avrg_sum;\nwire        clear_avrg_cnt_done;\nwire        set_frst_64_ptr_done;\nwire        clear_frst_64_ptr_done;\nwire [11:0] fifo_q;\nwire        fifo_sclr;\nwire        fifo_rdreq;\nwire        fifo_wrreq;\nwire        putresp_s;\nwire        putresp_pend_s;\nwire        pwrdwn_s;\nwire        pwrdwn_tsen_s;\nwire        avrg_cnt_s;\nwire        wait_pend_dly1_s;\nwire        conv_dly1_s;\nwire        conv_s;\nwire        putresp_dly3_s;\nwire        load_dout;\nwire        avrg_enable;\nwire [11:0] rsp_data_nxt;\n\nlocalparam [4:0]    IDLE                = 5'b00000;\nlocalparam [4:0]    PWRDWN              = 5'b00001;\nlocalparam [4:0]    PWRDWN_TSEN         = 5'b00010;\nlocalparam [4:0]    PWRDWN_DONE         = 5'b00011;\nlocalparam [4:0]    PWRUP_CH            = 5'b00100;\nlocalparam [4:0]    PWRUP_SOC           = 5'b00101;\nlocalparam [4:0]    WAIT                = 5'b00110;\nlocalparam [4:0]    GETCMD              = 5'b00111;\nlocalparam [4:0]    GETCMD_W            = 5'b01000;\nlocalparam [4:0]    PRE_CONV            = 5'b01001;\nlocalparam [4:0]    CONV                = 5'b01010; \n                                                    \n                                                    \nlocalparam [4:0]    CONV_DLY1           = 5'b01011; \nlocalparam [4:0]    PUTRESP             = 5'b01100; \nlocalparam [4:0]    PUTRESP_DLY1        = 5'b01101;\nlocalparam [4:0]    PUTRESP_DLY2        = 5'b01110;\nlocalparam [4:0]    PUTRESP_DLY3        = 5'b01111;\nlocalparam [4:0]    WAIT_PEND           = 5'b10000; \n                                                    \n                                                    \nlocalparam [4:0]    WAIT_PEND_DLY1      = 5'b10001; \nlocalparam [4:0]    PUTRESP_PEND        = 5'b10010; \nlocalparam [4:0]    AVRG_CNT            = 5'b10011;\nlocalparam [4:0]    SYNC1               = 5'b10100; \n\nlocalparam [7:0]    NUM_AVRG_POINTS     = 8'd64;\n\n\n\n\naltera_std_synchronizer #(\n    .depth    (2)\n) u_clk_dft_synchronizer (\n    .clk        (clk),\n    .reset_n    (rst_n),\n    .din        (clk_dft),\n    .dout       (clk_dft_synch)\n);\n\naltera_std_synchronizer #(\n    .depth    (2)\n) u_eoc_synchronizer (\n    .clk        (clk),\n    .reset_n    (rst_n),\n    .din        (eoc),\n    .dout       (eoc_synch)\n);\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_dft_synch_dly   <= 1'b0;\n        eoc_synch_dly       <= 1'b0;\n    end\n    else begin\n        clk_dft_synch_dly   <= clk_dft_synch;\n        eoc_synch_dly       <= eoc_synch;\n    end\nend\n\nassign clk_dft_lh   = clk_dft_synch & ~clk_dft_synch_dly;\nassign clk_dft_hl   = ~clk_dft_synch & clk_dft_synch_dly;\nassign eoc_hl       = ~eoc_synch & eoc_synch_dly;\n\n\n\n\n\n\ngenerate\nif (dual_adc_mode == 1) begin\n\n    \n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            prev_ctrl_state   <= IDLE;\n        else\n            prev_ctrl_state   <= ctrl_state;\n    end\n\n    \n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            sync_ctrl_state   <= IDLE;\n        else\n            sync_ctrl_state   <= sync_ctrl_state_nxt;\n    end\n\nend\nelse begin\n\n    always @* begin\n        prev_ctrl_state = 5'h0;\n        sync_ctrl_state = 5'h0;\n    end\n\nend\nendgenerate\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        ctrl_state   <= IDLE;\n    else\n        ctrl_state   <= ctrl_state_nxt;\nend\n\n\nalways @* begin\n\n    \n    sync_ctrl_state_nxt = sync_ctrl_state;\n    sync_valid          = 1'b0;\n\n    case (ctrl_state)\n        IDLE: begin\n            if (clk_in_pll_locked)\n                ctrl_state_nxt = PWRDWN;\n            else\n                ctrl_state_nxt = IDLE;\n        end\n\n        PWRDWN: begin\n            if (int_timer[6])\n                ctrl_state_nxt = PWRDWN_TSEN;\n            else\n                ctrl_state_nxt = PWRDWN;\n        end\n\n        PWRDWN_TSEN: begin\n            if (int_timer[7])\n                ctrl_state_nxt = PWRDWN_DONE;\n            else\n                ctrl_state_nxt = PWRDWN_TSEN;\n        end\n\n        PWRDWN_DONE: begin\n            if (dual_adc_mode == 1) begin\n                if (clk_dft_lh) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = PWRUP_CH;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PWRDWN_DONE;\n                end\n\n                if (clk_dft_lh) begin\n                    sync_ctrl_state_nxt = PWRUP_CH;\n                    sync_valid          = 1'b1;\n                end\n                \n            end\n            else begin\n                if (clk_dft_lh)\n                    ctrl_state_nxt = PWRUP_CH;\n                else\n                    ctrl_state_nxt = PWRDWN_DONE;\n            end\n        end\n\n        PWRUP_CH: begin\n            if (dual_adc_mode == 1) begin\n                if (clk_dft_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = PWRUP_SOC;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PWRUP_CH;\n                end\n\n                if (clk_dft_hl) begin\n                    sync_ctrl_state_nxt = PWRUP_SOC;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (clk_dft_hl)\n                    ctrl_state_nxt = PWRUP_SOC;\n                else\n                    ctrl_state_nxt = PWRUP_CH;\n            end\n        end\n\n        PWRUP_SOC: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready) begin\n                        if (cmd_fetched & ~cmd_is_rclb)\n                            ctrl_state_nxt = CONV;\n                        else if (cmd_fetched & cmd_is_rclb)\n                            ctrl_state_nxt = PUTRESP;\n                        else if (cmd_valid)\n                            ctrl_state_nxt = GETCMD;\n                        else\n                            ctrl_state_nxt = WAIT;\n                    end\n                    else begin\n                        ctrl_state_nxt = SYNC1;\n                    end\n                end\n                else begin\n                    ctrl_state_nxt = PWRUP_SOC;\n                end\n\n                if (eoc_hl) begin\n                    if (cmd_fetched & ~cmd_is_rclb)\n                        sync_ctrl_state_nxt = CONV;\n                    else if (cmd_fetched & cmd_is_rclb)\n                        sync_ctrl_state_nxt = PUTRESP;\n                    else if (cmd_valid)\n                        sync_ctrl_state_nxt = GETCMD;\n                    else\n                        sync_ctrl_state_nxt = WAIT;\n\n                    sync_valid  = 1'b1;\n                end\n\n            end\n            else begin\n                if (cmd_fetched & ~cmd_is_rclb & eoc_hl)\n                    ctrl_state_nxt = CONV;\n                else if (cmd_fetched & cmd_is_rclb & eoc_hl)\n                    ctrl_state_nxt = PUTRESP;\n                else if (cmd_valid & eoc_hl)\n                    ctrl_state_nxt = GETCMD;\n                else if (eoc_hl)\n                    ctrl_state_nxt = WAIT;\n                else\n                    ctrl_state_nxt = PWRUP_SOC;\n            end\n        end\n\n        SYNC1: begin\n            if (sync_ready)\n                ctrl_state_nxt = sync_ctrl_state;   \n            else\n                ctrl_state_nxt = prev_ctrl_state;   \n\n            sync_valid  = 1'b1;\n\n        end\n        \n        WAIT: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD_W;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        GETCMD_W: begin\n            if (cmd_is_rclb | adc_change_mode)\n                ctrl_state_nxt = PWRDWN;\n            else\n                ctrl_state_nxt = PRE_CONV;\n        end\n\n        PRE_CONV: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = CONV;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = PRE_CONV;\n                end\n\n                if (eoc_hl) begin\n                    sync_ctrl_state_nxt = CONV;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl)\n                    ctrl_state_nxt = CONV;\n                else\n                    ctrl_state_nxt = PRE_CONV;\n            end\n        end\n\n        GETCMD: begin\n            if ((cmd_is_rclb | adc_change_mode) & ~pend)\n                ctrl_state_nxt = PWRDWN;\n            else if ((cmd_is_rclb | adc_change_mode) & pend)\n                ctrl_state_nxt = WAIT_PEND;\n            else\n                ctrl_state_nxt = CONV;\n        end\n\n        CONV: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready) begin\n                        if (avrg_enable & ~avrg_cnt_done)\n                            ctrl_state_nxt = AVRG_CNT;\n                        else\n                            ctrl_state_nxt = CONV_DLY1;\n                    end\n                    else begin\n                        ctrl_state_nxt = SYNC1;\n                    end\n                end\n                else begin\n                    ctrl_state_nxt = CONV;\n                end\n\n                if (eoc_hl) begin\n                    if (avrg_enable & ~avrg_cnt_done)\n                        sync_ctrl_state_nxt = AVRG_CNT;\n                    else \n                        sync_ctrl_state_nxt = CONV_DLY1;\n\n                    sync_valid  = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl & avrg_enable & ~avrg_cnt_done)\n                    ctrl_state_nxt = AVRG_CNT;\n                else if (eoc_hl)\n                    ctrl_state_nxt = CONV_DLY1;\n                else\n                    ctrl_state_nxt = CONV;\n            end\n        end\n        \n        AVRG_CNT: begin\n            ctrl_state_nxt = CONV;\n        end\n        \n        CONV_DLY1: begin\n            ctrl_state_nxt = PUTRESP;\n        end\n\n        PUTRESP: begin\n            ctrl_state_nxt = PUTRESP_DLY1;\n        end\n        \n        PUTRESP_DLY1: begin\n            ctrl_state_nxt = PUTRESP_DLY2;\n        end\n        \n        PUTRESP_DLY2: begin\n            ctrl_state_nxt = PUTRESP_DLY3;\n        end\n\n        PUTRESP_DLY3: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD;\n            else if (pend)\n                ctrl_state_nxt = WAIT_PEND;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        WAIT_PEND: begin\n            if (dual_adc_mode == 1) begin\n                if (eoc_hl) begin\n                    if (sync_ready)\n                        ctrl_state_nxt = WAIT_PEND_DLY1;\n                    else\n                        ctrl_state_nxt = SYNC1;\n                end\n                else begin\n                    ctrl_state_nxt = WAIT_PEND;\n                end\n\n                if (eoc_hl) begin\n                    sync_ctrl_state_nxt = WAIT_PEND_DLY1;\n                    sync_valid          = 1'b1;\n                end\n\n            end\n            else begin\n                if (eoc_hl)\n                    ctrl_state_nxt = WAIT_PEND_DLY1;\n                else\n                    ctrl_state_nxt = WAIT_PEND;\n            end\n        end\n        \n        WAIT_PEND_DLY1: begin\n            ctrl_state_nxt = PUTRESP_PEND;\n        end\n        \n        PUTRESP_PEND: begin\n            if (cmd_valid)\n                ctrl_state_nxt = GETCMD;\n            else\n                ctrl_state_nxt = WAIT;\n        end\n\n        default: begin\n            ctrl_state_nxt = IDLE;\n        end\n\n    endcase\nend\n\n\n\n\n\n\nalways @* begin\n    chsel_nxt       = chsel;\n    soc_nxt         = soc;\n    usr_pwd_nxt     = usr_pwd;\n    tsen_nxt        = tsen;\n\n    case (ctrl_state_nxt)\n        IDLE: begin\n            chsel_nxt   = 5'b11110;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            tsen_nxt    = 1'b0;\n        end\n\n        PWRDWN: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            tsen_nxt    = tsen;\n        end\n\n        PWRDWN_TSEN: begin\n            \n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b1;\n            if (cmd_fetched & cmd_is_ts)        \n                tsen_nxt    = 1'b1;\n            else if (cmd_fetched & cmd_is_rclb) \n                tsen_nxt    = tsen;\n            else\n                tsen_nxt    = 1'b0;             \n            \n            \n            \n            if (cmd_fetched & (cmd_is_ts | (cmd_is_rclb & tsen)))   \n                chsel_nxt   = 5'b10001;\n            else\n                chsel_nxt   = 5'b11110;                                \n        end\n\n        PWRDWN_DONE: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b0;\n            usr_pwd_nxt = 1'b0;\n            tsen_nxt    = tsen;\n        end\n\n        PWRUP_CH: begin\n            \n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = 1'b0;\n            tsen_nxt    = tsen;\n        end\n\n        PWRUP_SOC: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = 1'b1;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        SYNC1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        WAIT: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        GETCMD_W: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PRE_CONV: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        GETCMD: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        CONV: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        AVRG_CNT: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        CONV_DLY1: begin\n            chsel_nxt   = cmd_channel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        PUTRESP_DLY1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP_DLY2: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        PUTRESP_DLY3: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        WAIT_PEND: begin\n            \n            if (tsen)\n                chsel_nxt   = chsel;         \n            else                             \n                chsel_nxt   = 5'b11110;     \n                                            \n                                            \n                                            \n                                            \n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        WAIT_PEND_DLY1: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n\n        PUTRESP_PEND: begin\n            chsel_nxt   = chsel;\n            soc_nxt     = soc;\n            usr_pwd_nxt = usr_pwd;\n            tsen_nxt    = tsen;\n        end\n        \n        default: begin\n            chsel_nxt   = 5'bx;\n            soc_nxt     = 1'bx;\n            usr_pwd_nxt = 1'bx;\n            tsen_nxt    = 1'bx;\n        end\n\n    endcase\nend\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        chsel       <= 5'b11110;\n        soc         <= 1'b0;\n        usr_pwd     <= 1'b1;\n        tsen        <= 1'b0;\n    end\n    else begin\n        chsel       <= chsel_nxt;\n        soc         <= soc_nxt;\n        usr_pwd     <= usr_pwd_nxt;\n        tsen        <= tsen_nxt;\n\n    end\nend\n\n\n\n\n\n\n\nassign arc_conv_conv_dly1               = (ctrl_state == CONV) & (ctrl_state_nxt == CONV_DLY1);\nassign arc_wait_pend_wait_pend_dly1     = (ctrl_state == WAIT_PEND) & (ctrl_state_nxt == WAIT_PEND_DLY1);\nassign arc_to_avrg_cnt                  = ((ctrl_state == CONV) & (ctrl_state_nxt == AVRG_CNT)) | ((ctrl_state == SYNC1) & (ctrl_state_nxt == AVRG_CNT));\n\n\n\nassign arc_sync1_conv_dly1              = (ctrl_state == SYNC1) & (ctrl_state_nxt == CONV_DLY1);        \nassign arc_sync1_wait_pend_dly1         = (ctrl_state == SYNC1) & (ctrl_state_nxt == WAIT_PEND_DLY1);   \n\n\n\n\n\nassign putresp_s        = (ctrl_state == PUTRESP);\nassign putresp_pend_s   = (ctrl_state == PUTRESP_PEND);\nassign pwrdwn_s         = (ctrl_state == PWRDWN);\nassign pwrdwn_tsen_s    = (ctrl_state == PWRDWN_TSEN);\nassign avrg_cnt_s       = (ctrl_state == AVRG_CNT);\nassign wait_pend_dly1_s = (ctrl_state == WAIT_PEND_DLY1);\nassign conv_dly1_s      = (ctrl_state == CONV_DLY1);\nassign conv_s           = (ctrl_state == CONV);\nassign putresp_dly3_s   = (ctrl_state == PUTRESP_DLY3);\n\n\n\n\n\n\nassign load_rsp                     = (putresp_s & ~cmd_is_rclb & pend) | putresp_pend_s;\nassign load_dout                    = ((arc_conv_conv_dly1 | arc_sync1_conv_dly1) & ~cmd_is_rclb & pend) | arc_wait_pend_wait_pend_dly1 | arc_sync1_wait_pend_dly1 | ((int_timer != 8'h0) & arc_to_avrg_cnt);\nassign load_cmd_ready               = putresp_s;\nassign arc_to_conv                  = (ctrl_state != CONV) & (ctrl_state != AVRG_CNT) & ~((ctrl_state == SYNC1) & (prev_ctrl_state == CONV)) & (ctrl_state_nxt == CONV);\n\nassign arc_getcmd_w_pwrdwn          = (ctrl_state == GETCMD_W) & (ctrl_state_nxt == PWRDWN);\nassign arc_getcmd_pwrdwn            = (ctrl_state == GETCMD) & (ctrl_state_nxt == PWRDWN);\nassign load_cmd_fetched             = arc_getcmd_w_pwrdwn | arc_getcmd_pwrdwn;\nassign load_int_timer               = arc_getcmd_w_pwrdwn | arc_getcmd_pwrdwn | arc_to_conv; \nassign incr_int_timer               = pwrdwn_s | pwrdwn_tsen_s | avrg_cnt_s; \n\nassign arc_out_from_pwrup_soc       = ((ctrl_state == PWRUP_SOC) & (ctrl_state_nxt != PWRUP_SOC) & (ctrl_state_nxt != SYNC1)) |\n                                        ((ctrl_state == SYNC1) & (prev_ctrl_state == PWRUP_SOC) & (ctrl_state_nxt != PWRUP_SOC));\nassign clr_cmd_fetched              = arc_out_from_pwrup_soc;\n\n\n\n\n\nassign cmd_is_rclb      = (cmd_channel == 5'b11111);\nassign cmd_is_ts        = (cmd_channel == 5'b10001);\nassign adc_change_mode  = (~prev_cmd_is_ts & cmd_is_ts) | (prev_cmd_is_ts & ~cmd_is_ts);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        prev_cmd_is_ts  <= 1'b0;\n    else if (load_cmd_ready & ~cmd_is_rclb)\n        prev_cmd_is_ts  <= cmd_is_ts;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cmd_fetched  <= 1'b0;\n    else if (load_cmd_fetched)\n        cmd_fetched  <= 1'b1;\n    else if (clr_cmd_fetched)\n        cmd_fetched  <= 1'b0;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        conv_dly1_s_flp <= 1'b0;\n    else\n        conv_dly1_s_flp <= conv_dly1_s;\nend\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pend <= 1'b0;\n    else if (conv_dly1_s_flp)\n        pend <= 1'b1;\n    else if (wait_pend_dly1_s)\n        pend <= 1'b0;\n\nend\n\n\n\n\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dout_flp <= 12'd0;\n    else if (load_dout) \n        dout_flp <= dout;\nend\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        int_timer <= 8'h0;\n    else if (load_int_timer)\n        int_timer <= 8'h0;\n    else if (incr_int_timer)\n        int_timer <= int_timer + 8'h1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        avrg_cnt_done <= 1'b0;\n    else if ((int_timer == (NUM_AVRG_POINTS - 8'd1)) & conv_s)\n        avrg_cnt_done <= 1'b1;\n    else if (clear_avrg_cnt_done)\n        avrg_cnt_done <= 1'b0;\nend\n\nassign clear_avrg_cnt_done = putresp_dly3_s & ~cmd_valid; \n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cmd_channel_dly <= 5'h0;\n        cmd_sop_dly     <= 1'b0;\n        cmd_eop_dly     <= 1'b0;\n    end\n    else if (load_cmd_ready) begin\n        cmd_channel_dly <= cmd_channel;\n        cmd_sop_dly     <= cmd_sop;\n        cmd_eop_dly     <= cmd_eop;\n    end\nend\n\n\n\n\n\n\n\n\nassign avrg_enable = cmd_is_ts;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        avrg_sum    <= 18'h0;\n    else if (clear_avrg_sum)\n        avrg_sum    <= 18'h0;\n    else if (add_avrg_sum_run)\n        avrg_sum  <= (avrg_sum - fifo_q) + {6'h0, dout_flp};\n    else if (add_avrg_sum)\n        avrg_sum  <= avrg_sum + {6'h0, dout_flp};\nend\n\nassign add_avrg_sum     = ((int_timer != 8'h0) & avrg_cnt_s) |  \n                            (conv_dly1_s & avrg_enable & pend) |    \n                            (conv_dly1_s & avrg_enable & ~pend & ~frst_64_ptr_done) | \n                            (wait_pend_dly1_s & prev_cmd_is_ts); \n\nassign add_avrg_sum_run = set_frst_64_ptr_done & frst_64_ptr_done;\n\nassign clear_avrg_sum           = ~avrg_cnt_done & putresp_pend_s;  \n                                                                    \n\nassign set_frst_64_ptr_done     = (wait_pend_dly1_s & prev_cmd_is_ts) | \n                                    (conv_dly1_s & avrg_enable & pend); \n                                                                        \n\nassign clear_frst_64_ptr_done   = clear_avrg_sum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        frst_64_ptr_done <= 1'b0;\n    else if (set_frst_64_ptr_done)\n        frst_64_ptr_done <= 1'b1;\n    else if (clear_frst_64_ptr_done)\n        frst_64_ptr_done <= 1'b0;\nend\n\nassign fifo_sclr    = clear_avrg_sum;\nassign fifo_rdreq   = (((arc_wait_pend_wait_pend_dly1 | arc_sync1_wait_pend_dly1) & prev_cmd_is_ts) | ((arc_conv_conv_dly1 | arc_sync1_conv_dly1) & avrg_enable & pend)) & frst_64_ptr_done;\nassign fifo_wrreq   = ((int_timer != 8'h0) & avrg_cnt_s) |\n                        (conv_dly1_s & avrg_enable & pend) |\n                        (conv_dly1_s & avrg_enable & ~pend & ~frst_64_ptr_done) |\n                        (wait_pend_dly1_s & prev_cmd_is_ts);\n\naltera_modular_adc_control_avrg_fifo ts_avrg_fifo (\n    .clock      (clk),\n    .data       (dout_flp),\n    .rdreq      (fifo_rdreq),\n    .wrreq      (fifo_wrreq),\n    .sclr       (fifo_sclr),\n    .empty      (),\n    .full       (),\n    .q          (fifo_q)\n);\n\n\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rsp_valid   <= 1'b0;\n        rsp_channel <= 5'h0;\n        rsp_data    <= 12'h0;\n        rsp_sop     <= 1'b0;\n        rsp_eop     <= 1'b0;\n    end\n    else if (load_rsp) begin\n        rsp_valid   <= 1'b1;\n        rsp_channel <= cmd_channel_dly;\n        rsp_data    <= rsp_data_nxt;\n        rsp_sop     <= cmd_sop_dly;\n        rsp_eop     <= cmd_eop_dly;\n    end \n    else begin\n        rsp_valid   <= 1'b0;\n        rsp_channel <= 5'h0;\n        rsp_data    <= 12'h0;\n        rsp_sop     <= 1'b0;\n        rsp_eop     <= 1'b0;\n    end\nend\n\ngenerate\nif (is_this_first_or_second_adc == 2) begin\n    assign rsp_data_nxt = prev_cmd_is_ts ? 12'h0 : dout_flp;    \nend\nelse begin\n    assign rsp_data_nxt = prev_cmd_is_ts ? avrg_sum[17:6] : dout_flp;\nend\nendgenerate\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cmd_ready   <= 1'b0;\n    else if (load_cmd_ready)\n        cmd_ready   <= 1'b1;\n    else\n        cmd_ready   <= 1'b0;\nend\n\nendmodule\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: altera_modular_adc_control_fsm. Module specification: This module is a finite state machine (FSM) controller for an Altera modular ADC, managing the ADC's operation including power-down, power-up, channel selection, conversion, and result handling. It has input ports for clock (clk), reset (rst_n), PLL lock status (clk_in_pll_locked), command signals (cmd_valid, cmd_channel, cmd_sop, cmd_eop), DFT clock (clk_dft), end of conversion (eoc), ADC data output (dout), and synchronization ready signal (sync_ready). Output ports include response signals (rsp_valid, rsp_channel, rsp_data, rsp_sop, rsp_eop), command ready (cmd_ready), channel select (chsel),"
                }
            ]
        }
    ]
}