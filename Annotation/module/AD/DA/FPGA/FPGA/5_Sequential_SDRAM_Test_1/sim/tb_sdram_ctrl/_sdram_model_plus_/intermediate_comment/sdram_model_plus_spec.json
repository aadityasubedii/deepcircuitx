{
    "spec": "Module name: sdram_model_plus. Module specification: This module simulates a Synchronous Dynamic Random Access Memory (SDRAM) device with four banks, supporting various burst lengths and CAS latencies. It handles read, write, activate, precharge, and refresh operations, implementing timing constraints and auto-precharge functionality. The module has input ports for data (Dq), address (Addr), bank select (Ba), clock (Clk), control signals (Cke, Cs_n, Ras_n, Cas_n, We_n), data mask (Dqm), and debug mode (Debug). The bidirectional Dq port serves for both data input and output. Internal signals include memory banks (Bank0-3), address registers, command storage, data masks, and various control flags. The module is structured with sections for command decoding, timing checks, burst operations, and auto-",
    "gpt-message": [
        {
            "role": "system",
            "content": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
        },
        {
            "role": "user",
            "content": "Name of the module and its functionality is as follows: \nModule name: sdram_model_plus\n\nExplanation: This module simulates a Synchronous Dynamic Random Access Memory (SDRAM) device. It implements the behavior of an SDRAM, including operations such as read, write, activate, precharge, and refresh. The module handles timing constraints, burst operations, and auto-precharge functionality. It also includes debug features and the ability to dump memory contents to files. The SDRAM model supports multiple banks, different burst lengths, and various CAS latencies, mimicking the behavior of a real SDRAM chip."
        },
        {
            "role": "user",
            "content": "Input and output ports and their explanation is as follows: \nInput ports:\nDq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm, Debug\n\nExplanation:\n- Dq: Bidirectional data bus for reading and writing data\n- Addr: Address input for row and column addresses\n- Ba: Bank address input\n- Clk: Clock input\n- Cke: Clock enable input\n- Cs_n: Chip select (active low)\n- Ras_n: Row address strobe (active low)\n- Cas_n: Column address strobe (active low)\n- We_n: Write enable (active low)\n- Dqm: Data mask input\n- Debug: Debug mode enable input\n\nOutput ports:\nDq (inout)\n\nExplanation:\n- Dq: Bidirectional data bus for reading and writing data. It serves as both an input (during write operations) and an output (during read operations)."
        },
        {
            "role": "user",
            "content": "Internal signals and their explanation is as follows: \nInternal signals:\nBank0, Bank1, Bank2, Bank3, Bank_addr, Col_addr, Command, Dqm_reg0, Dqm_reg1, B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr, Mode_reg, Dq_reg, Dq_dqm, Col_temp, Burst_counter, Act_b0, Act_b1, Act_b2, Act_b3, Pc_b0, Pc_b1, Pc_b2, Pc_b3, Bank_precharge, A10_precharge, Auto_precharge, Read_precharge, Write_precharge, Count_precharge, RW_interrupt_read, RW_interrupt_write, Data_in_enable, Data_out_enable, Bank, Previous_bank, Row, Col, Col_brst, CkeZ, Sys_clk.\n\nExplanation:\n- Bank0, Bank1, Bank2, Bank3: Arrays representing the four memory banks of the SDRAM\n- Bank_addr, Col_addr: Arrays storing bank and column addresses for multiple clock cycles\n- Command: Array storing commands for multiple clock cycles\n- Dqm_reg0, Dqm_reg1: Registers for data mask values\n- B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr: Row address registers for each bank\n- Mode_reg: Register storing the mode register settings\n- Dq_reg, Dq_dqm: Registers for data input/output and data masking\n- Col_temp, Burst_counter: Used for burst operations and column address calculations\n- Act_b0, Act_b1, Act_b2, Act_b3: Flags indicating if a bank is active\n- Pc_b0, Pc_b1, Pc_b2, Pc_b3: Flags indicating if a bank is precharged\n- Bank_precharge, A10_precharge, Auto_precharge, Read_precharge, Write_precharge: Signals for precharge operations\n- Count_precharge: Counter for precharge operations\n- RW_interrupt_read, RW_interrupt_write: Flags for interrupting read/write operations\n- Data_in_enable, Data_out_enable: Control signals for data input/output\n- Bank, Previous_bank, Row, Col, Col_brst: Current bank, row, and column addresses\n- CkeZ, Sys_clk: Internal clock signals\n\nThese internal signals are used to manage the SDRAM's state, store addresses and data, control operations, and handle timing constraints within the module."
        },
        {
            "role": "user",
            "content": "Original Verilog code is as follows: \n```verilog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 100ps\n\nmodule sdram_model_plus (Dq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm,Debug);\n\n    parameter addr_bits =\t11;\n    parameter data_bits = \t32;\n    parameter col_bits  =\t8;\n    parameter mem_sizes =\t1048576*2-1;\n\n    inout     [data_bits - 1 : 0] Dq;\n    input     [addr_bits - 1 : 0] Addr;\n    input                 [1 : 0] Ba;\n    input                         Clk;\n    input                         Cke;\n    input                         Cs_n;\n    input                         Ras_n;\n    input                         Cas_n;\n    input                         We_n;\n    input                 [3 : 0] Dqm;          \n    \n    input\t\t\t  Debug;\n\n    reg       [data_bits - 1 : 0] Bank0 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank1 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank2 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank3 [0 : mem_sizes];\n\n    reg                   [1 : 0] Bank_addr [0 : 3];                \n    reg        [col_bits - 1 : 0] Col_addr [0 : 3];                 \n    reg                   [3 : 0] Command [0 : 3];                  \n    reg                   [3 : 0] Dqm_reg0, Dqm_reg1;               \n    reg       [addr_bits - 1 : 0] B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr;\n\n    reg       [addr_bits - 1 : 0] Mode_reg;\n    reg       [data_bits - 1 : 0] Dq_reg, Dq_dqm;\n    reg       [col_bits - 1 : 0] Col_temp, Burst_counter;\n\n    reg                           Act_b0, Act_b1, Act_b2, Act_b3;   \n    reg                           Pc_b0, Pc_b1, Pc_b2, Pc_b3;       \n\n    reg                   [1 : 0] Bank_precharge     [0 : 3];       \n    reg                           A10_precharge      [0 : 3];       \n    reg                           Auto_precharge     [0 : 3];       \n    reg                           Read_precharge     [0 : 3];       \n    reg                           Write_precharge    [0 : 3];       \n    integer                       Count_precharge    [0 : 3];       \n    reg                           RW_interrupt_read  [0 : 3];       \n    reg                           RW_interrupt_write [0 : 3];       \n\n    reg                           Data_in_enable;\n    reg                           Data_out_enable;\n\n    reg                   [1 : 0] Bank, Previous_bank;\n    reg       [addr_bits - 1 : 0] Row;\n    reg        [col_bits - 1 : 0] Col, Col_brst;\n\n    \n    reg                           CkeZ, Sys_clk;\n\n    reg\t[21:0]\tdd;\n    \n    \n    wire      Active_enable    = ~Cs_n & ~Ras_n &  Cas_n &  We_n;\n    wire      Aref_enable      = ~Cs_n & ~Ras_n & ~Cas_n &  We_n;\n    wire      Burst_term       = ~Cs_n &  Ras_n &  Cas_n & ~We_n;\n    wire      Mode_reg_enable  = ~Cs_n & ~Ras_n & ~Cas_n & ~We_n;\n    wire      Prech_enable     = ~Cs_n & ~Ras_n &  Cas_n & ~We_n;\n    wire      Read_enable      = ~Cs_n &  Ras_n & ~Cas_n &  We_n;\n    wire      Write_enable     = ~Cs_n &  Ras_n & ~Cas_n & ~We_n;\n\n    \n    wire      Burst_length_1   = ~Mode_reg[2] & ~Mode_reg[1] & ~Mode_reg[0];\n    wire      Burst_length_2   = ~Mode_reg[2] & ~Mode_reg[1] &  Mode_reg[0];\n    wire      Burst_length_4   = ~Mode_reg[2] &  Mode_reg[1] & ~Mode_reg[0];\n    wire      Burst_length_8   = ~Mode_reg[2] &  Mode_reg[1] &  Mode_reg[0];\n\n    \n    wire      Cas_latency_2    = ~Mode_reg[6] &  Mode_reg[5] & ~Mode_reg[4];\n    wire      Cas_latency_3    = ~Mode_reg[6] &  Mode_reg[5] &  Mode_reg[4];\n\n    \n    wire      Write_burst_mode = Mode_reg[9];\n\n    wire      Debug;\t\t\n    wire      Dq_chk           = Sys_clk & Data_in_enable;      \n\n    reg\t\t[31:0]\tmem_d;\n    \n    event\tsdram_r,sdram_w,compare;\n    \n    \n   \n   \n    assign    Dq               = Dq_reg;                        \n\n    \n    `define   ACT       0\n    `define   NOP       1\n    `define   READ      2\n    `define   READ_A    3\n    `define   WRITE     4\n    `define   WRITE_A   5\n    `define   PRECH     6\n    `define   A_REF     7\n    `define   BST       8\n    `define   LMR       9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    parameter tAC  =   6.5;\t\n    parameter tHZ  =   5.5;\n    parameter tOH  =   2;\n    parameter tMRD =   2.0;     \n    parameter tRAS =  48.0;\n    parameter tRC  =  70.0;\n    parameter tRCD =  20.0;\n    parameter tRP  =  20.0;\n    parameter tRRD =  14.0;\n    parameter tWRa =   7.5;     \n    parameter tWRp =  0.0;     \n    \n    \n    integer   MRD_chk;\n    integer   WR_counter [0 : 3];\n    time      WR_chk [0 : 3];\n    time      RC_chk, RRD_chk;\n    time      RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3;\n    time      RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3;\n    time      RP_chk0, RP_chk1, RP_chk2, RP_chk3;\n\n    integer\ttest_file;\n    \n    \n    \n    parameter\tMode_Reg_Set\t=4'b0000;\n    parameter\tAuto_Refresh\t=4'b0001;\n    parameter\tRow_Active\t=4'b0011;\n    parameter\tPre_Charge\t=4'b0010;\n    parameter\tPreCharge_All\t=4'b0010;\n    parameter\tWrite\t\t=4'b0100;\n    parameter\tWrite_Pre\t=4'b0100;\n    parameter\tRead\t\t=4'b0101;\n    parameter\tRead_Pre\t=4'b0101;\n    parameter\tBurst_Stop\t=4'b0110;\n    parameter\tNop\t\t=4'b0111;\n    parameter\tDsel\t\t=4'b1111;\n\n    wire\t[3:0]\tsdram_control;\n    reg\t\t\tcke_temp;\n    reg\t\t[8*13:1]\tsdram_command;\n   \n    always@(posedge Clk)\n\tcke_temp<=Cke;\n\n    assign\tsdram_control={Cs_n,Ras_n,Cas_n,We_n};\n\n    always@(sdram_control or cke_temp)\n\tbegin\n\t\tcase(sdram_control)\n\t\t\tMode_Reg_Set:\tsdram_command<=\"Mode_Reg_Set\";\n\t\t\tAuto_Refresh:\tsdram_command<=\"Auto_Refresh\";\n\t\t\tRow_Active:\tsdram_command<=\"Row_Active\";\n\t\t\tPre_Charge:\tsdram_command<=\"Pre_Charge\";\n\t\t\tBurst_Stop:\tsdram_command<=\"Burst_Stop\";\n\t\t\tDsel:\t\tsdram_command<=\"Dsel\";\n\n\t\t\tWrite:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Write\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Write_suspend\";\n\t\t\t\t\t\t\n\t\t\tRead:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Read\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Read_suspend\";\n\t\t\t\t\t\t\n\t\t\tNop:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Nop\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Self_refresh\";\n\t\t\t\t\t\t\n\t\t\tdefault:\tsdram_command<=\"Power_down\";\n\t\tendcase\n\tend\n\n    \n    \n    initial \n    \tbegin\n\t\t\n\tend\n\n    initial \n    \tbegin\n        Dq_reg = {data_bits{1'bz}};\n        {Data_in_enable, Data_out_enable} = 0;\n        {Act_b0, Act_b1, Act_b2, Act_b3} = 4'b0000;\n        {Pc_b0, Pc_b1, Pc_b2, Pc_b3} = 4'b0000;\n        {WR_chk[0], WR_chk[1], WR_chk[2], WR_chk[3]} = 0;\n        {WR_counter[0], WR_counter[1], WR_counter[2], WR_counter[3]} = 0;\n        {RW_interrupt_read[0], RW_interrupt_read[1], RW_interrupt_read[2], RW_interrupt_read[3]} = 0;\n        {RW_interrupt_write[0], RW_interrupt_write[1], RW_interrupt_write[2], RW_interrupt_write[3]} = 0;\n        {MRD_chk, RC_chk, RRD_chk} = 0;\n        {RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3} = 0;\n        {RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3} = 0;\n        {RP_chk0, RP_chk1, RP_chk2, RP_chk3} = 0;\n        $timeformat (-9, 0, \" ns\", 12);\n        \n        \n        \n        \n\n\n\n\n\n\n\n\n        \t\n  \tinitial_sdram(0);\n  \tend\n \n        task\tinitial_sdram; \n \n \t\tinput\t\tdata_sign;\n \t\treg\t[3:0]\tdata_sign;\n \t     \n       \t\tfor(dd=0;dd<=mem_sizes;dd=dd+1)\n        \tbegin\n        \t\tmem_d = {data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign};\n        \t\tif(data_bits==16)\n        \t\t\tbegin\n        \t\t\t\tBank0[dd]=mem_d[15:0];\n        \t\t\t\tBank1[dd]=mem_d[15:0];\n        \t\t\t\tBank2[dd]=mem_d[15:0];\n        \t\t\t\tBank3[dd]=mem_d[15:0];\n        \t\t\tend\n        \t\telse if(data_bits==32)\n        \t\t\tbegin\n        \t\t\t\tBank0[dd]=mem_d[31:0];\n        \t\t\t\tBank1[dd]=mem_d[31:0];\n        \t\t\t\tBank2[dd]=mem_d[31:0];\n        \t\t\t\tBank3[dd]=mem_d[31:0];\n        \t\t\tend\n        \tend\t\n      \t\n       \t\tendtask\n\n    \n    always\n    \tbegin\n       \t\t@(posedge Clk)\n       \t\t\tbegin\n            \t\t\tSys_clk = CkeZ;\n            \t\t\tCkeZ = Cke;\n        \t\tend\n        \t@(negedge Clk) \n        \t\tbegin\n            \t\t\tSys_clk = 1'b0;\n        \t\tend\n    \tend\n\n    always @ (posedge Sys_clk) begin\n        \n        Command[0] = Command[1];\n        Command[1] = Command[2];\n        Command[2] = Command[3];\n        Command[3] = `NOP;\n\n        Col_addr[0] = Col_addr[1];\n        Col_addr[1] = Col_addr[2];\n        Col_addr[2] = Col_addr[3];\n        Col_addr[3] = {col_bits{1'b0}};\n\n        Bank_addr[0] = Bank_addr[1];\n        Bank_addr[1] = Bank_addr[2];\n        Bank_addr[2] = Bank_addr[3];\n        Bank_addr[3] = 2'b0;\n\n        Bank_precharge[0] = Bank_precharge[1];\n        Bank_precharge[1] = Bank_precharge[2];\n        Bank_precharge[2] = Bank_precharge[3];\n        Bank_precharge[3] = 2'b0;\n\n        A10_precharge[0] = A10_precharge[1];\n        A10_precharge[1] = A10_precharge[2];\n        A10_precharge[2] = A10_precharge[3];\n        A10_precharge[3] = 1'b0;\n\n        \n        Dqm_reg0 = Dqm_reg1;\n        Dqm_reg1 = Dqm;\n\n        \n        if (Auto_precharge[0] == 1'b1) begin\n            Count_precharge[0] = Count_precharge[0] + 1;\n        end\n        if (Auto_precharge[1] == 1'b1) begin\n            Count_precharge[1] = Count_precharge[1] + 1;\n        end\n        if (Auto_precharge[2] == 1'b1) begin\n            Count_precharge[2] = Count_precharge[2] + 1;\n        end\n        if (Auto_precharge[3] == 1'b1) begin\n            Count_precharge[3] = Count_precharge[3] + 1;\n        end\n\n        \n        MRD_chk = MRD_chk + 1;\n\n        \n        WR_counter[0] = WR_counter[0] + 1;\n        WR_counter[1] = WR_counter[1] + 1;\n        WR_counter[2] = WR_counter[2] + 1;\n        WR_counter[3] = WR_counter[3] + 1;\n\n        \n        if (Aref_enable == 1'b1) begin\n            if (Debug) $display (\"at time %t AREF : Auto Refresh\", $time);\n            \n            if (($time - RC_chk < tRC)&&Debug) begin\n                $display (\"at time %t ERROR: tRC violation during Auto Refresh\", $time);\n            end\n            \n            if (($time - RP_chk0 < tRP || $time - RP_chk1 < tRP || $time - RP_chk2 < tRP || $time - RP_chk3 < tRP)&&Debug) begin\n                $display (\"at time %t ERROR: tRP violation during Auto Refresh\", $time);\n            end\n            \n            if (Pc_b0 == 1'b0 || Pc_b1 == 1'b0 || Pc_b2 == 1'b0 || Pc_b3 == 1'b0) begin\n                $display (\"at time %t ERROR: All banks must be Precharge before Auto Refresh\", $time);\n            end\n            \n            RC_chk = $time;\n        end\n        \n        \n        if (Mode_reg_enable == 1'b1) begin\n            \n            if (Pc_b0 == 1'b1 && Pc_b1 == 1'b1 && Pc_b2 == 1'b1 && Pc_b3 == 1'b1) begin\n                Mode_reg = Addr;\n                if (Debug) begin\n                    $display (\"at time %t LMR  : Load Mode Register\", $time);\n                    \n                    if (Addr[6 : 4] == 3'b010)\n                        $display (\"                            CAS Latency      = 2\");\n                    else if (Addr[6 : 4] == 3'b011)\n                        $display (\"                            CAS Latency      = 3\");\n                    else\n                        $display (\"                            CAS Latency      = Reserved\");\n                    \n                    if (Addr[2 : 0] == 3'b000)\n                        $display (\"                            Burst Length     = 1\");\n                    else if (Addr[2 : 0] == 3'b001)\n                        $display (\"                            Burst Length     = 2\");\n                    else if (Addr[2 : 0] == 3'b010)\n                        $display (\"                            Burst Length     = 4\");\n                    else if (Addr[2 : 0] == 3'b011)\n                        $display (\"                            Burst Length     = 8\");\n                    else if (Addr[3 : 0] == 4'b0111)\n                        $display (\"                            Burst Length     = Full\");\n                    else\n                        $display (\"                            Burst Length     = Reserved\");\n                    \n                    if (Addr[3] == 1'b0)\n                        $display (\"                            Burst Type       = Sequential\");\n                    else if (Addr[3] == 1'b1)\n                        $display (\"                            Burst Type       = Interleaved\");\n                    else\n                        $display (\"                            Burst Type       = Reserved\");\n                    \n                    if (Addr[9] == 1'b0)\n                        $display (\"                            Write Burst Mode = Programmed Burst Length\");\n                    else if (Addr[9] == 1'b1)\n                        $display (\"                            Write Burst Mode = Single Location Access\");\n                    else\n                        $display (\"                            Write Burst Mode = Reserved\");\n                end\n            end else begin\n                $display (\"at time %t ERROR: all banks must be Precharge before Load Mode Register\", $time);\n            end\n            \n            if ($time - RC_chk < tRC) begin\n                $display (\"at time %t ERROR: tRC violation during Load Mode Register\", $time);\n            end\n            \n            if (MRD_chk < tMRD) begin\n                $display (\"at time %t ERROR: tMRD violation during Load Mode Register\", $time);\n            end\n            MRD_chk = 0;\n        end\n        \n        \n        if (Active_enable == 1'b1) begin\n            if (Ba == 2'b00 && Pc_b0 == 1'b1) begin\n                {Act_b0, Pc_b0} = 2'b10;\n                B0_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk0 = $time;\n                RAS_chk0 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 0 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk0 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 0\", $time);\n                end\n            end else if (Ba == 2'b01 && Pc_b1 == 1'b1) begin\n                {Act_b1, Pc_b1} = 2'b10;\n                B1_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk1 = $time;\n                RAS_chk1 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 1 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk1 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 1\", $time);\n                end\n            end else if (Ba == 2'b10 && Pc_b2 == 1'b1) begin\n                {Act_b2, Pc_b2} = 2'b10;\n                B2_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk2 = $time;\n                RAS_chk2 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 2 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk2 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 2\", $time);\n                end\n            end else if (Ba == 2'b11 && Pc_b3 == 1'b1) begin\n                {Act_b3, Pc_b3} = 2'b10;\n                B3_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk3 = $time;\n                RAS_chk3 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 3 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk3 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 3\", $time);\n                end\n            end else if (Ba == 2'b00 && Pc_b0 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 0 is not Precharged.\", $time);\n            end else if (Ba == 2'b01 && Pc_b1 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 1 is not Precharged.\", $time);\n            end else if (Ba == 2'b10 && Pc_b2 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 2 is not Precharged.\", $time);\n            end else if (Ba == 2'b11 && Pc_b3 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 3 is not Precharged.\", $time);\n            end\n            \n            if ((Previous_bank != Ba) && ($time - RRD_chk < tRRD)) begin\n                $display (\"at time %t ERROR: tRRD violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            if (MRD_chk < tMRD ) begin\n                $display (\"at time %t ERROR: tMRD violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            if (($time - RC_chk < tRC)&&Debug) begin\n                $display (\"at time %t ERROR: tRC violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            RRD_chk = $time;\n            Previous_bank = Ba;\n        end\n        \n        \n        if (Prech_enable == 1'b1) begin\n            if (Addr[10] == 1'b1) begin\n                {Pc_b0, Pc_b1, Pc_b2, Pc_b3} = 4'b1111;\n                {Act_b0, Act_b1, Act_b2, Act_b3} = 4'b0000;\n                RP_chk0 = $time;\n                RP_chk1 = $time;\n                RP_chk2 = $time;\n                RP_chk3 = $time;\n                if (Debug) $display (\"at time %t PRE  : Bank = ALL\",$time);\n                \n                if (($time - RAS_chk0 < tRAS) || ($time - RAS_chk1 < tRAS) ||\n                    ($time - RAS_chk2 < tRAS) || ($time - RAS_chk3 < tRAS)) begin\n                    $display (\"at time %t ERROR: tRAS violation during Precharge all bank\", $time);\n                end\n                \n                if (($time - WR_chk[0] < tWRp) || ($time - WR_chk[1] < tWRp) ||\n                    ($time - WR_chk[2] < tWRp) || ($time - WR_chk[3] < tWRp)) begin\n                    $display (\"at time %t ERROR: tWR violation during Precharge all bank\", $time);\n                end\n            end else if (Addr[10] == 1'b0) begin\n                if (Ba == 2'b00) begin\n                    {Pc_b0, Act_b0} = 2'b10;\n                    RP_chk0 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 0\",$time);\n                    \n                    if ($time - RAS_chk0 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 0\", $time);\n                    end\n                end else if (Ba == 2'b01) begin\n                    {Pc_b1, Act_b1} = 2'b10;\n                    RP_chk1 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 1\",$time);\n                    \n                    if ($time - RAS_chk1 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 1\", $time);\n                    end\n                end else if (Ba == 2'b10) begin\n                    {Pc_b2, Act_b2} = 2'b10;\n                    RP_chk2 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 2\",$time);\n                    \n                    if ($time - RAS_chk2 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 2\", $time);\n                    end\n                end else if (Ba == 2'b11) begin\n                    {Pc_b3, Act_b3} = 2'b10;\n                    RP_chk3 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 3\",$time);\n                    \n                    if ($time - RAS_chk3 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 3\", $time);\n                    end\n                end\n                \n                if ($time - WR_chk[Ba] < tWRp) begin\n                    $display (\"at time %t ERROR: tWR violation during Precharge bank %d\", $time, Ba);\n                end\n            end\n            \n            if (Data_in_enable == 1'b1 && (Bank == Ba || Addr[10] == 1'b1)) begin\n                Data_in_enable = 1'b0;\n            end\n            \n            if (Cas_latency_3 == 1'b1) begin\n                Command[2] = `PRECH;\n                Bank_precharge[2] = Ba;\n                A10_precharge[2] = Addr[10];\n            end else if (Cas_latency_2 == 1'b1) begin\n                Command[1] = `PRECH;\n                Bank_precharge[1] = Ba;\n                A10_precharge[1] = Addr[10];\n            end\n        end\n        \n        \n        if (Burst_term == 1'b1) begin\n            \n            if (Data_in_enable == 1'b1) begin\n                Data_in_enable = 1'b0;\n            end\n            \n            if (Cas_latency_3 == 1'b1) begin\n                Command[2] = `BST;\n            end else if (Cas_latency_2 == 1'b1) begin\n                Command[1] = `BST;\n            end\n            if (Debug) $display (\"at time %t BST  : Burst Terminate\",$time);\n        end\n        \n        \n        if (Read_enable == 1'b1 || Write_enable == 1'b1) begin\n            \n            if ((Ba == 2'b00 && Pc_b0 == 1'b1) || (Ba == 2'b01 && Pc_b1 == 1'b1) ||\n                (Ba == 2'b10 && Pc_b2 == 1'b1) || (Ba == 2'b11 && Pc_b3 == 1'b1)) begin\n                $display(\"at time %t ERROR: Cannot Read or Write - Bank %d is not Activated\", $time, Ba);\n            end\n            \n            if ((Ba == 2'b00) && ($time - RCD_chk0 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 0\", $time);\n            if ((Ba == 2'b01) && ($time - RCD_chk1 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 1\", $time);\n            if ((Ba == 2'b10) && ($time - RCD_chk2 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 2\", $time);\n            if ((Ba == 2'b11) && ($time - RCD_chk3 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 3\", $time);\n            \n            if (Read_enable == 1'b1) begin\n                \n                if (Cas_latency_3 == 1'b1) begin\n                    if (Addr[10] == 1'b1) begin\n                        Command[2] = `READ_A;\n                    end else begin\n                        Command[2] = `READ;\n                    end\n                    Col_addr[2] = Addr;\n                    Bank_addr[2] = Ba;\n                end else if (Cas_latency_2 == 1'b1) begin\n                    if (Addr[10] == 1'b1) begin\n                        Command[1] = `READ_A;\n                    end else begin\n                        Command[1] = `READ;\n                    end\n                    Col_addr[1] = Addr;\n                    Bank_addr[1] = Ba;\n                end\n\n                \n                if (Data_in_enable == 1'b1) begin\n                    Data_in_enable = 1'b0;\n                end\n\n            \n            end else if (Write_enable == 1'b1) begin\n                if (Addr[10] == 1'b1) begin\n                    Command[0] = `WRITE_A;\n                end else begin\n                    Command[0] = `WRITE;\n                end\n                Col_addr[0] = Addr;\n                Bank_addr[0] = Ba;\n\n                \n                if (Data_in_enable == 1'b1) begin\n                    Data_in_enable = 1'b0;\n                end\n\n                \n                if (Data_out_enable == 1'b1) begin\n                    Data_out_enable = 1'b0;\n                end\n            end\n\n            \n            if (Auto_precharge[Bank] == 1'b1 && Write_precharge[Bank] == 1'b1) begin\n                RW_interrupt_write[Bank] = 1'b1;\n                if (Debug) $display (\"at time %t NOTE : Read/Write Bank %d interrupt Write Bank %d with Autoprecharge\", $time, Ba, Bank);\n            end\n\n            \n            if (Auto_precharge[Bank] == 1'b1 && Read_precharge[Bank] == 1'b1) begin\n                RW_interrupt_read[Bank] = 1'b1;\n                if (Debug) $display (\"at time %t NOTE : Read/Write Bank %d interrupt Read Bank %d with Autoprecharge\", $time, Ba, Bank);\n            end\n\n            \n            if (Addr[10] == 1'b1) begin\n                Auto_precharge[Ba] = 1'b1;\n                Count_precharge[Ba] = 0;\n                if (Read_enable == 1'b1) begin\n                    Read_precharge[Ba] = 1'b1;\n                end else if (Write_enable == 1'b1) begin\n                    Write_precharge[Ba] = 1'b1;\n                end\n            end\n        end\n\n        \n        \n        \n        \n        \n        if ((Auto_precharge[0] == 1'b1) && (Read_precharge[0] == 1'b1)) begin\n            if ((($time - RAS_chk0 >= tRAS) &&                                                      \n                ((Burst_length_1 == 1'b1 && Count_precharge[0] >= 1) ||                             \n                 (Burst_length_2 == 1'b1 && Count_precharge[0] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[0] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[0] >= 8))) ||\n                 (RW_interrupt_read[0] == 1'b1)) begin                                              \n                    Pc_b0 = 1'b1;\n                    Act_b0 = 1'b0;\n                    RP_chk0 = $time;\n                    Auto_precharge[0] = 1'b0;\n                    Read_precharge[0] = 1'b0;\n                    RW_interrupt_read[0] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 0\", $time);\n            end\n        end\n        if ((Auto_precharge[1] == 1'b1) && (Read_precharge[1] == 1'b1)) begin\n            if ((($time - RAS_chk1 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[1] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[1] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[1] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[1] >= 8))) ||\n                 (RW_interrupt_read[1] == 1'b1)) begin\n                    Pc_b1 = 1'b1;\n                    Act_b1 = 1'b0;\n                    RP_chk1 = $time;\n                    Auto_precharge[1] = 1'b0;\n                    Read_precharge[1] = 1'b0;\n                    RW_interrupt_read[1] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 1\", $time);\n            end\n        end\n        if ((Auto_precharge[2] == 1'b1) && (Read_precharge[2] == 1'b1)) begin\n            if ((($time - RAS_chk2 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[2] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[2] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[2] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[2] >= 8))) ||\n                 (RW_interrupt_read[2] == 1'b1)) begin\n                    Pc_b2 = 1'b1;\n                    Act_b2 = 1'b0;\n                    RP_chk2 = $time;\n                    Auto_precharge[2] = 1'b0;\n                    Read_precharge[2] = 1'b0;\n                    RW_interrupt_read[2] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 2\", $time);\n            end\n        end\n        if ((Auto_precharge[3] == 1'b1) && (Read_precharge[3] == 1'b1)) begin\n            if ((($time - RAS_chk3 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[3] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[3] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[3] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[3] >= 8))) ||\n                 (RW_interrupt_read[3] == 1'b1)) begin\n                    Pc_b3 = 1'b1;\n                    Act_b3 = 1'b0;\n                    RP_chk3 = $time;\n                    Auto_precharge[3] = 1'b0;\n                    Read_precharge[3] = 1'b0;\n                    RW_interrupt_read[3] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 3\", $time);\n            end\n        end\n\n        \n        if (Command[0] == `PRECH) begin                         \n            if (Bank_precharge[0] == Bank || A10_precharge[0] == 1'b1) begin\n                if (Data_out_enable == 1'b1) begin\n                    Data_out_enable = 1'b0;\n                end\n            end\n        end else if (Command[0] == `BST) begin                  \n            if (Data_out_enable == 1'b1) begin\n                Data_out_enable = 1'b0;\n            end\n        end\n\n        if (Data_out_enable == 1'b0) begin\n            Dq_reg <= #tOH {data_bits{1'bz}};\n        end\n\n        \n        if (Command[0] == `READ || Command[0] == `READ_A) begin\n            Bank = Bank_addr[0];\n            Col = Col_addr[0];\n            Col_brst = Col_addr[0];\n            if (Bank_addr[0] == 2'b00) begin\n                Row = B0_row_addr;\n            end else if (Bank_addr[0] == 2'b01) begin\n                Row = B1_row_addr;\n            end else if (Bank_addr[0] == 2'b10) begin\n                Row = B2_row_addr;\n            end else if (Bank_addr[0] == 2'b11) begin\n                Row = B3_row_addr;\n            end\n            Burst_counter = 0;\n            Data_in_enable = 1'b0;\n            Data_out_enable = 1'b1;\n        end else if (Command[0] == `WRITE || Command[0] == `WRITE_A) begin\n            Bank = Bank_addr[0];\n            Col = Col_addr[0];\n            Col_brst = Col_addr[0];\n            if (Bank_addr[0] == 2'b00) begin\n                Row = B0_row_addr;\n            end else if (Bank_addr[0] == 2'b01) begin\n                Row = B1_row_addr;\n            end else if (Bank_addr[0] == 2'b10) begin\n                Row = B2_row_addr;\n            end else if (Bank_addr[0] == 2'b11) begin\n                Row = B3_row_addr;\n            end\n            Burst_counter = 0;\n            Data_in_enable = 1'b1;\n            Data_out_enable = 1'b0;\n        end\n\n        \n        if (Data_in_enable == 1'b1) begin                                   \n            \n            if (Bank == 2'b00) Dq_dqm [data_bits - 1  : 0] = Bank0 [{Row, Col}];\n            if (Bank == 2'b01) Dq_dqm [data_bits - 1  : 0] = Bank1 [{Row, Col}];\n            if (Bank == 2'b10) Dq_dqm [data_bits - 1  : 0] = Bank2 [{Row, Col}];\n            if (Bank == 2'b11) Dq_dqm [data_bits - 1  : 0] = Bank3 [{Row, Col}];\n            \n            if (Dqm[0] == 1'b0) Dq_dqm [ 7 : 0] = Dq [ 7 : 0];\n            if (Dqm[1] == 1'b0) Dq_dqm [15 : 8] = Dq [15 : 8];\n            \n           \n            \n            if (Bank == 2'b00) Bank0 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b01) Bank1 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b10) Bank2 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b11) Bank3 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b11 && Row==10'h3 && Col[7:4]==4'h4)\n            \t$display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            \n            \n            if (Dqm == 4'b1111) begin\n                if (Debug) $display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            end else begin\n                if (Debug) $display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b\", $time, Bank, Row, Col, Dq_dqm, Dqm);\n                \n                WR_chk [Bank] = $time;\n                WR_counter [Bank] = 0;\n            end\n            \n            #tHZ Burst;\n        end else if (Data_out_enable == 1'b1) begin                         \n        \t\n            \n            if (Bank == 2'b00) Dq_dqm [data_bits - 1  : 0] = Bank0 [{Row, Col}];\n            if (Bank == 2'b01) Dq_dqm [data_bits - 1  : 0] = Bank1 [{Row, Col}];\n            if (Bank == 2'b10) Dq_dqm [data_bits - 1  : 0] = Bank2 [{Row, Col}];\n            if (Bank == 2'b11) Dq_dqm [data_bits - 1  : 0] = Bank3 [{Row, Col}];\n            \t\n            \n            if (Dqm_reg0[0] == 1'b1) Dq_dqm [ 7 : 0] = 8'bz;\n            if (Dqm_reg0[1] == 1'b1) Dq_dqm [15 : 8] = 8'bz;\n            if (Dqm_reg0[2] == 1'b1) Dq_dqm [23 : 16] = 8'bz;\n            if (Dqm_reg0[3] == 1'b1) Dq_dqm [31 : 24] = 8'bz;\n            \n            Dq_reg [data_bits - 1  : 0] = #tAC Dq_dqm [data_bits - 1  : 0];\n            if (Dqm_reg0 == 4'b1111) begin\n                if (Debug) $display(\"at time %t READ : Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            end else begin\n                if (Debug) $display(\"at time %t READ : Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b\", $time, Bank, Row, Col, Dq_reg, Dqm_reg0);\n            end\n            \n            Burst;\n        end\n    end\n\n    \n    \n    \n    \n    \n    always @ (WR_counter[0]) begin\n        if ((Auto_precharge[0] == 1'b1) && (Write_precharge[0] == 1'b1)) begin\n            if ((($time - RAS_chk0 >= tRAS) &&                                                          \n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [0] >= 1) ||   \n                 (Burst_length_2 == 1'b1 && Count_precharge [0] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [0] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [0] >= 8))) ||\n                 (RW_interrupt_write[0] == 1'b1 && WR_counter[0] >= 2)) begin                           \n                    Auto_precharge[0] = 1'b0;\n                    Write_precharge[0] = 1'b0;\n                    RW_interrupt_write[0] = 1'b0;\n                    #tWRa;                          \n                    Pc_b0 = 1'b1;\n                    Act_b0 = 1'b0;\n                    RP_chk0 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 0\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[1]) begin\n        if ((Auto_precharge[1] == 1'b1) && (Write_precharge[1] == 1'b1)) begin\n            if ((($time - RAS_chk1 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [1] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [1] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [1] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [1] >= 8))) ||\n                 (RW_interrupt_write[1] == 1'b1 && WR_counter[1] >= 2)) begin\n                    Auto_precharge[1] = 1'b0;\n                    Write_precharge[1] = 1'b0;\n                    RW_interrupt_write[1] = 1'b0;\n                    #tWRa;                          \n                    Pc_b1 = 1'b1;\n                    Act_b1 = 1'b0;\n                    RP_chk1 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 1\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[2]) begin\n        if ((Auto_precharge[2] == 1'b1) && (Write_precharge[2] == 1'b1)) begin\n            if ((($time - RAS_chk2 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [2] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [2] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [2] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [2] >= 8))) ||\n                 (RW_interrupt_write[2] == 1'b1 && WR_counter[2] >= 2)) begin\n                    Auto_precharge[2] = 1'b0;\n                    Write_precharge[2] = 1'b0;\n                    RW_interrupt_write[2] = 1'b0;\n                    #tWRa;                          \n                    Pc_b2 = 1'b1;\n                    Act_b2 = 1'b0;\n                    RP_chk2 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 2\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[3]) begin\n        if ((Auto_precharge[3] == 1'b1) && (Write_precharge[3] == 1'b1)) begin\n            if ((($time - RAS_chk3 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [3] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [3] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [3] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [3] >= 8))) ||\n                 (RW_interrupt_write[3] == 1'b1 && WR_counter[3] >= 2)) begin\n                    Auto_precharge[3] = 1'b0;\n                    Write_precharge[3] = 1'b0;\n                    RW_interrupt_write[3] = 1'b0;\n                    #tWRa;                          \n                    Pc_b3 = 1'b1;\n                    Act_b3 = 1'b0;\n                    RP_chk3 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 3\", $time);\n            end\n        end\n    end\n\n    task Burst;\n        begin\n            \n            Burst_counter = Burst_counter + 1;\n\n            \n            if (Mode_reg[3] == 1'b0) begin                                  \n                Col_temp = Col + 1;\n            end else if (Mode_reg[3] == 1'b1) begin                         \n                Col_temp[2] =  Burst_counter[2] ^  Col_brst[2];\n                Col_temp[1] =  Burst_counter[1] ^  Col_brst[1];\n                Col_temp[0] =  Burst_counter[0] ^  Col_brst[0];\n            end\n\n            \n            if (Burst_length_2) begin                                       \n                Col [0] = Col_temp [0];\n            end else if (Burst_length_4) begin                              \n                Col [1 : 0] = Col_temp [1 : 0];\n            end else if (Burst_length_8) begin                              \n                Col [2 : 0] = Col_temp [2 : 0];\n            end else begin                                                  \n                Col = Col_temp;\n            end\n\n            \n            if (Write_burst_mode == 1'b1) begin\n                Data_in_enable = 1'b0;\n            end\n\n            \n            if (Burst_length_1 == 1'b1) begin\n                if (Burst_counter >= 1) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_2 == 1'b1) begin\n                if (Burst_counter >= 2) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_4 == 1'b1) begin\n                if (Burst_counter >= 4) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_8 == 1'b1) begin\n                if (Burst_counter >= 8) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end\n        end\n    endtask\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    integer\tsdram_data,sdram_mem;\n    reg\t[23:0]\taa,cc;\n    reg\t[18:0]\tbb,ee;\n    \n    always@(sdram_r)\n\tbegin\n\t\t   $display(\"Sdram dampout begin \",$realtime);\n\t\t   sdram_data=$fopen(\"sdram_data.txt\");\n\t\t   for(aa=0;aa<4*(mem_sizes+1);aa=aa+1)\n\t\t   \tbegin\n\t\t   \tbb=aa[18:0];\n\t\t\tif(aa<=mem_sizes)\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank0[bb]);\n\t\t\telse if(aa<=2*mem_sizes+1)\n\t\t            \t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank1[bb]);\n\t\t\telse if(aa<=3*mem_sizes+2)\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank2[bb]);\n\t\t\telse\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank3[bb]);\n\t\t  \tend\t    \t    \t    \n\t\t  $fclose(\"sdram_data.txt\"); \n\t\t  \n\t\t  sdram_mem=$fopen(\"sdram_mem.txt\");\n\t\t  for(cc=0;cc<4*(mem_sizes+1);cc=cc+1)\n\t\t  \tbegin\n\t\t   \tee=cc[18:0];\n\t\t\tif(cc<=mem_sizes)\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank0[ee]);\n\t\t\telse if(cc<=2*mem_sizes+1)\n\t\t            \t$fdisplay(sdram_mem,\"%0h\",Bank1[ee]);\n\t\t\telse if(cc<=3*mem_sizes+2)\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank2[ee]);\n\t\t\telse\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank3[ee]);\n\t\t  \tend\t    \t    \t    \n\t\t  $fclose(\"sdram_mem.txt\");        \n\t \n\t  end        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nendmodule\n\n```"
        },
        {
            "role": "user",
            "content": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
        },
        {
            "role": "assistant",
            "content": "Module name: sdram_model_plus. Module specification: This module simulates a Synchronous Dynamic Random Access Memory (SDRAM) device with four banks, supporting various burst lengths and CAS latencies. It handles read, write, activate, precharge, and refresh operations, implementing timing constraints and auto-precharge functionality. The module has input ports for data (Dq), address (Addr), bank select (Ba), clock (Clk), control signals (Cke, Cs_n, Ras_n, Cas_n, We_n), data mask (Dqm), and debug mode (Debug). The bidirectional Dq port serves for both data input and output. Internal signals include memory banks (Bank0-3), address registers, command storage, data masks, and various control flags. The module is structured with sections for command decoding, timing checks, burst operations, and auto-"
        }
    ],
    "claude-message": [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You are an expert in hardware design with a deep understanding of Verilog RTL codes. Now I want to train a large language model for code comment generation tasks specifically focused on Verilog RTL codes. And I want you to help me process the raw data, transforming it into suitable formats that can serve as inputs and outputs for the model."
                },
                {
                    "type": "text",
                    "text": "Name of the module and its functionality is as follows: \nModule name: sdram_model_plus\n\nExplanation: This module simulates a Synchronous Dynamic Random Access Memory (SDRAM) device. It implements the behavior of an SDRAM, including operations such as read, write, activate, precharge, and refresh. The module handles timing constraints, burst operations, and auto-precharge functionality. It also includes debug features and the ability to dump memory contents to files. The SDRAM model supports multiple banks, different burst lengths, and various CAS latencies, mimicking the behavior of a real SDRAM chip."
                },
                {
                    "type": "text",
                    "text": "Input and output ports and their explanation is as follows: \nInput ports:\nDq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm, Debug\n\nExplanation:\n- Dq: Bidirectional data bus for reading and writing data\n- Addr: Address input for row and column addresses\n- Ba: Bank address input\n- Clk: Clock input\n- Cke: Clock enable input\n- Cs_n: Chip select (active low)\n- Ras_n: Row address strobe (active low)\n- Cas_n: Column address strobe (active low)\n- We_n: Write enable (active low)\n- Dqm: Data mask input\n- Debug: Debug mode enable input\n\nOutput ports:\nDq (inout)\n\nExplanation:\n- Dq: Bidirectional data bus for reading and writing data. It serves as both an input (during write operations) and an output (during read operations)."
                },
                {
                    "type": "text",
                    "text": "Internal signals and their explanation is as follows: \nInternal signals:\nBank0, Bank1, Bank2, Bank3, Bank_addr, Col_addr, Command, Dqm_reg0, Dqm_reg1, B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr, Mode_reg, Dq_reg, Dq_dqm, Col_temp, Burst_counter, Act_b0, Act_b1, Act_b2, Act_b3, Pc_b0, Pc_b1, Pc_b2, Pc_b3, Bank_precharge, A10_precharge, Auto_precharge, Read_precharge, Write_precharge, Count_precharge, RW_interrupt_read, RW_interrupt_write, Data_in_enable, Data_out_enable, Bank, Previous_bank, Row, Col, Col_brst, CkeZ, Sys_clk.\n\nExplanation:\n- Bank0, Bank1, Bank2, Bank3: Arrays representing the four memory banks of the SDRAM\n- Bank_addr, Col_addr: Arrays storing bank and column addresses for multiple clock cycles\n- Command: Array storing commands for multiple clock cycles\n- Dqm_reg0, Dqm_reg1: Registers for data mask values\n- B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr: Row address registers for each bank\n- Mode_reg: Register storing the mode register settings\n- Dq_reg, Dq_dqm: Registers for data input/output and data masking\n- Col_temp, Burst_counter: Used for burst operations and column address calculations\n- Act_b0, Act_b1, Act_b2, Act_b3: Flags indicating if a bank is active\n- Pc_b0, Pc_b1, Pc_b2, Pc_b3: Flags indicating if a bank is precharged\n- Bank_precharge, A10_precharge, Auto_precharge, Read_precharge, Write_precharge: Signals for precharge operations\n- Count_precharge: Counter for precharge operations\n- RW_interrupt_read, RW_interrupt_write: Flags for interrupting read/write operations\n- Data_in_enable, Data_out_enable: Control signals for data input/output\n- Bank, Previous_bank, Row, Col, Col_brst: Current bank, row, and column addresses\n- CkeZ, Sys_clk: Internal clock signals\n\nThese internal signals are used to manage the SDRAM's state, store addresses and data, control operations, and handle timing constraints within the module."
                },
                {
                    "type": "text",
                    "text": "Original Verilog code is as follows: \n<code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`timescale 1ns / 100ps\n\nmodule sdram_model_plus (Dq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm,Debug);\n\n    parameter addr_bits =\t11;\n    parameter data_bits = \t32;\n    parameter col_bits  =\t8;\n    parameter mem_sizes =\t1048576*2-1;\n\n    inout     [data_bits - 1 : 0] Dq;\n    input     [addr_bits - 1 : 0] Addr;\n    input                 [1 : 0] Ba;\n    input                         Clk;\n    input                         Cke;\n    input                         Cs_n;\n    input                         Ras_n;\n    input                         Cas_n;\n    input                         We_n;\n    input                 [3 : 0] Dqm;          \n    \n    input\t\t\t  Debug;\n\n    reg       [data_bits - 1 : 0] Bank0 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank1 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank2 [0 : mem_sizes];\n    reg       [data_bits - 1 : 0] Bank3 [0 : mem_sizes];\n\n    reg                   [1 : 0] Bank_addr [0 : 3];                \n    reg        [col_bits - 1 : 0] Col_addr [0 : 3];                 \n    reg                   [3 : 0] Command [0 : 3];                  \n    reg                   [3 : 0] Dqm_reg0, Dqm_reg1;               \n    reg       [addr_bits - 1 : 0] B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr;\n\n    reg       [addr_bits - 1 : 0] Mode_reg;\n    reg       [data_bits - 1 : 0] Dq_reg, Dq_dqm;\n    reg       [col_bits - 1 : 0] Col_temp, Burst_counter;\n\n    reg                           Act_b0, Act_b1, Act_b2, Act_b3;   \n    reg                           Pc_b0, Pc_b1, Pc_b2, Pc_b3;       \n\n    reg                   [1 : 0] Bank_precharge     [0 : 3];       \n    reg                           A10_precharge      [0 : 3];       \n    reg                           Auto_precharge     [0 : 3];       \n    reg                           Read_precharge     [0 : 3];       \n    reg                           Write_precharge    [0 : 3];       \n    integer                       Count_precharge    [0 : 3];       \n    reg                           RW_interrupt_read  [0 : 3];       \n    reg                           RW_interrupt_write [0 : 3];       \n\n    reg                           Data_in_enable;\n    reg                           Data_out_enable;\n\n    reg                   [1 : 0] Bank, Previous_bank;\n    reg       [addr_bits - 1 : 0] Row;\n    reg        [col_bits - 1 : 0] Col, Col_brst;\n\n    \n    reg                           CkeZ, Sys_clk;\n\n    reg\t[21:0]\tdd;\n    \n    \n    wire      Active_enable    = ~Cs_n & ~Ras_n &  Cas_n &  We_n;\n    wire      Aref_enable      = ~Cs_n & ~Ras_n & ~Cas_n &  We_n;\n    wire      Burst_term       = ~Cs_n &  Ras_n &  Cas_n & ~We_n;\n    wire      Mode_reg_enable  = ~Cs_n & ~Ras_n & ~Cas_n & ~We_n;\n    wire      Prech_enable     = ~Cs_n & ~Ras_n &  Cas_n & ~We_n;\n    wire      Read_enable      = ~Cs_n &  Ras_n & ~Cas_n &  We_n;\n    wire      Write_enable     = ~Cs_n &  Ras_n & ~Cas_n & ~We_n;\n\n    \n    wire      Burst_length_1   = ~Mode_reg[2] & ~Mode_reg[1] & ~Mode_reg[0];\n    wire      Burst_length_2   = ~Mode_reg[2] & ~Mode_reg[1] &  Mode_reg[0];\n    wire      Burst_length_4   = ~Mode_reg[2] &  Mode_reg[1] & ~Mode_reg[0];\n    wire      Burst_length_8   = ~Mode_reg[2] &  Mode_reg[1] &  Mode_reg[0];\n\n    \n    wire      Cas_latency_2    = ~Mode_reg[6] &  Mode_reg[5] & ~Mode_reg[4];\n    wire      Cas_latency_3    = ~Mode_reg[6] &  Mode_reg[5] &  Mode_reg[4];\n\n    \n    wire      Write_burst_mode = Mode_reg[9];\n\n    wire      Debug;\t\t\n    wire      Dq_chk           = Sys_clk & Data_in_enable;      \n\n    reg\t\t[31:0]\tmem_d;\n    \n    event\tsdram_r,sdram_w,compare;\n    \n    \n   \n   \n    assign    Dq               = Dq_reg;                        \n\n    \n    `define   ACT       0\n    `define   NOP       1\n    `define   READ      2\n    `define   READ_A    3\n    `define   WRITE     4\n    `define   WRITE_A   5\n    `define   PRECH     6\n    `define   A_REF     7\n    `define   BST       8\n    `define   LMR       9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    parameter tAC  =   6.5;\t\n    parameter tHZ  =   5.5;\n    parameter tOH  =   2;\n    parameter tMRD =   2.0;     \n    parameter tRAS =  48.0;\n    parameter tRC  =  70.0;\n    parameter tRCD =  20.0;\n    parameter tRP  =  20.0;\n    parameter tRRD =  14.0;\n    parameter tWRa =   7.5;     \n    parameter tWRp =  0.0;     \n    \n    \n    integer   MRD_chk;\n    integer   WR_counter [0 : 3];\n    time      WR_chk [0 : 3];\n    time      RC_chk, RRD_chk;\n    time      RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3;\n    time      RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3;\n    time      RP_chk0, RP_chk1, RP_chk2, RP_chk3;\n\n    integer\ttest_file;\n    \n    \n    \n    parameter\tMode_Reg_Set\t=4'b0000;\n    parameter\tAuto_Refresh\t=4'b0001;\n    parameter\tRow_Active\t=4'b0011;\n    parameter\tPre_Charge\t=4'b0010;\n    parameter\tPreCharge_All\t=4'b0010;\n    parameter\tWrite\t\t=4'b0100;\n    parameter\tWrite_Pre\t=4'b0100;\n    parameter\tRead\t\t=4'b0101;\n    parameter\tRead_Pre\t=4'b0101;\n    parameter\tBurst_Stop\t=4'b0110;\n    parameter\tNop\t\t=4'b0111;\n    parameter\tDsel\t\t=4'b1111;\n\n    wire\t[3:0]\tsdram_control;\n    reg\t\t\tcke_temp;\n    reg\t\t[8*13:1]\tsdram_command;\n   \n    always@(posedge Clk)\n\tcke_temp<=Cke;\n\n    assign\tsdram_control={Cs_n,Ras_n,Cas_n,We_n};\n\n    always@(sdram_control or cke_temp)\n\tbegin\n\t\tcase(sdram_control)\n\t\t\tMode_Reg_Set:\tsdram_command<=\"Mode_Reg_Set\";\n\t\t\tAuto_Refresh:\tsdram_command<=\"Auto_Refresh\";\n\t\t\tRow_Active:\tsdram_command<=\"Row_Active\";\n\t\t\tPre_Charge:\tsdram_command<=\"Pre_Charge\";\n\t\t\tBurst_Stop:\tsdram_command<=\"Burst_Stop\";\n\t\t\tDsel:\t\tsdram_command<=\"Dsel\";\n\n\t\t\tWrite:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Write\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Write_suspend\";\n\t\t\t\t\t\t\n\t\t\tRead:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Read\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Read_suspend\";\n\t\t\t\t\t\t\n\t\t\tNop:\t\tif(cke_temp==1)\n\t\t\t\t\t\tsdram_command<=\"Nop\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsdram_command<=\"Self_refresh\";\n\t\t\t\t\t\t\n\t\t\tdefault:\tsdram_command<=\"Power_down\";\n\t\tendcase\n\tend\n\n    \n    \n    initial \n    \tbegin\n\t\t\n\tend\n\n    initial \n    \tbegin\n        Dq_reg = {data_bits{1'bz}};\n        {Data_in_enable, Data_out_enable} = 0;\n        {Act_b0, Act_b1, Act_b2, Act_b3} = 4'b0000;\n        {Pc_b0, Pc_b1, Pc_b2, Pc_b3} = 4'b0000;\n        {WR_chk[0], WR_chk[1], WR_chk[2], WR_chk[3]} = 0;\n        {WR_counter[0], WR_counter[1], WR_counter[2], WR_counter[3]} = 0;\n        {RW_interrupt_read[0], RW_interrupt_read[1], RW_interrupt_read[2], RW_interrupt_read[3]} = 0;\n        {RW_interrupt_write[0], RW_interrupt_write[1], RW_interrupt_write[2], RW_interrupt_write[3]} = 0;\n        {MRD_chk, RC_chk, RRD_chk} = 0;\n        {RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3} = 0;\n        {RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3} = 0;\n        {RP_chk0, RP_chk1, RP_chk2, RP_chk3} = 0;\n        $timeformat (-9, 0, \" ns\", 12);\n        \n        \n        \n        \n\n\n\n\n\n\n\n\n        \t\n  \tinitial_sdram(0);\n  \tend\n \n        task\tinitial_sdram; \n \n \t\tinput\t\tdata_sign;\n \t\treg\t[3:0]\tdata_sign;\n \t     \n       \t\tfor(dd=0;dd<=mem_sizes;dd=dd+1)\n        \tbegin\n        \t\tmem_d = {data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign};\n        \t\tif(data_bits==16)\n        \t\t\tbegin\n        \t\t\t\tBank0[dd]=mem_d[15:0];\n        \t\t\t\tBank1[dd]=mem_d[15:0];\n        \t\t\t\tBank2[dd]=mem_d[15:0];\n        \t\t\t\tBank3[dd]=mem_d[15:0];\n        \t\t\tend\n        \t\telse if(data_bits==32)\n        \t\t\tbegin\n        \t\t\t\tBank0[dd]=mem_d[31:0];\n        \t\t\t\tBank1[dd]=mem_d[31:0];\n        \t\t\t\tBank2[dd]=mem_d[31:0];\n        \t\t\t\tBank3[dd]=mem_d[31:0];\n        \t\t\tend\n        \tend\t\n      \t\n       \t\tendtask\n\n    \n    always\n    \tbegin\n       \t\t@(posedge Clk)\n       \t\t\tbegin\n            \t\t\tSys_clk = CkeZ;\n            \t\t\tCkeZ = Cke;\n        \t\tend\n        \t@(negedge Clk) \n        \t\tbegin\n            \t\t\tSys_clk = 1'b0;\n        \t\tend\n    \tend\n\n    always @ (posedge Sys_clk) begin\n        \n        Command[0] = Command[1];\n        Command[1] = Command[2];\n        Command[2] = Command[3];\n        Command[3] = `NOP;\n\n        Col_addr[0] = Col_addr[1];\n        Col_addr[1] = Col_addr[2];\n        Col_addr[2] = Col_addr[3];\n        Col_addr[3] = {col_bits{1'b0}};\n\n        Bank_addr[0] = Bank_addr[1];\n        Bank_addr[1] = Bank_addr[2];\n        Bank_addr[2] = Bank_addr[3];\n        Bank_addr[3] = 2'b0;\n\n        Bank_precharge[0] = Bank_precharge[1];\n        Bank_precharge[1] = Bank_precharge[2];\n        Bank_precharge[2] = Bank_precharge[3];\n        Bank_precharge[3] = 2'b0;\n\n        A10_precharge[0] = A10_precharge[1];\n        A10_precharge[1] = A10_precharge[2];\n        A10_precharge[2] = A10_precharge[3];\n        A10_precharge[3] = 1'b0;\n\n        \n        Dqm_reg0 = Dqm_reg1;\n        Dqm_reg1 = Dqm;\n\n        \n        if (Auto_precharge[0] == 1'b1) begin\n            Count_precharge[0] = Count_precharge[0] + 1;\n        end\n        if (Auto_precharge[1] == 1'b1) begin\n            Count_precharge[1] = Count_precharge[1] + 1;\n        end\n        if (Auto_precharge[2] == 1'b1) begin\n            Count_precharge[2] = Count_precharge[2] + 1;\n        end\n        if (Auto_precharge[3] == 1'b1) begin\n            Count_precharge[3] = Count_precharge[3] + 1;\n        end\n\n        \n        MRD_chk = MRD_chk + 1;\n\n        \n        WR_counter[0] = WR_counter[0] + 1;\n        WR_counter[1] = WR_counter[1] + 1;\n        WR_counter[2] = WR_counter[2] + 1;\n        WR_counter[3] = WR_counter[3] + 1;\n\n        \n        if (Aref_enable == 1'b1) begin\n            if (Debug) $display (\"at time %t AREF : Auto Refresh\", $time);\n            \n            if (($time - RC_chk < tRC)&&Debug) begin\n                $display (\"at time %t ERROR: tRC violation during Auto Refresh\", $time);\n            end\n            \n            if (($time - RP_chk0 < tRP || $time - RP_chk1 < tRP || $time - RP_chk2 < tRP || $time - RP_chk3 < tRP)&&Debug) begin\n                $display (\"at time %t ERROR: tRP violation during Auto Refresh\", $time);\n            end\n            \n            if (Pc_b0 == 1'b0 || Pc_b1 == 1'b0 || Pc_b2 == 1'b0 || Pc_b3 == 1'b0) begin\n                $display (\"at time %t ERROR: All banks must be Precharge before Auto Refresh\", $time);\n            end\n            \n            RC_chk = $time;\n        end\n        \n        \n        if (Mode_reg_enable == 1'b1) begin\n            \n            if (Pc_b0 == 1'b1 && Pc_b1 == 1'b1 && Pc_b2 == 1'b1 && Pc_b3 == 1'b1) begin\n                Mode_reg = Addr;\n                if (Debug) begin\n                    $display (\"at time %t LMR  : Load Mode Register\", $time);\n                    \n                    if (Addr[6 : 4] == 3'b010)\n                        $display (\"                            CAS Latency      = 2\");\n                    else if (Addr[6 : 4] == 3'b011)\n                        $display (\"                            CAS Latency      = 3\");\n                    else\n                        $display (\"                            CAS Latency      = Reserved\");\n                    \n                    if (Addr[2 : 0] == 3'b000)\n                        $display (\"                            Burst Length     = 1\");\n                    else if (Addr[2 : 0] == 3'b001)\n                        $display (\"                            Burst Length     = 2\");\n                    else if (Addr[2 : 0] == 3'b010)\n                        $display (\"                            Burst Length     = 4\");\n                    else if (Addr[2 : 0] == 3'b011)\n                        $display (\"                            Burst Length     = 8\");\n                    else if (Addr[3 : 0] == 4'b0111)\n                        $display (\"                            Burst Length     = Full\");\n                    else\n                        $display (\"                            Burst Length     = Reserved\");\n                    \n                    if (Addr[3] == 1'b0)\n                        $display (\"                            Burst Type       = Sequential\");\n                    else if (Addr[3] == 1'b1)\n                        $display (\"                            Burst Type       = Interleaved\");\n                    else\n                        $display (\"                            Burst Type       = Reserved\");\n                    \n                    if (Addr[9] == 1'b0)\n                        $display (\"                            Write Burst Mode = Programmed Burst Length\");\n                    else if (Addr[9] == 1'b1)\n                        $display (\"                            Write Burst Mode = Single Location Access\");\n                    else\n                        $display (\"                            Write Burst Mode = Reserved\");\n                end\n            end else begin\n                $display (\"at time %t ERROR: all banks must be Precharge before Load Mode Register\", $time);\n            end\n            \n            if ($time - RC_chk < tRC) begin\n                $display (\"at time %t ERROR: tRC violation during Load Mode Register\", $time);\n            end\n            \n            if (MRD_chk < tMRD) begin\n                $display (\"at time %t ERROR: tMRD violation during Load Mode Register\", $time);\n            end\n            MRD_chk = 0;\n        end\n        \n        \n        if (Active_enable == 1'b1) begin\n            if (Ba == 2'b00 && Pc_b0 == 1'b1) begin\n                {Act_b0, Pc_b0} = 2'b10;\n                B0_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk0 = $time;\n                RAS_chk0 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 0 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk0 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 0\", $time);\n                end\n            end else if (Ba == 2'b01 && Pc_b1 == 1'b1) begin\n                {Act_b1, Pc_b1} = 2'b10;\n                B1_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk1 = $time;\n                RAS_chk1 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 1 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk1 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 1\", $time);\n                end\n            end else if (Ba == 2'b10 && Pc_b2 == 1'b1) begin\n                {Act_b2, Pc_b2} = 2'b10;\n                B2_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk2 = $time;\n                RAS_chk2 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 2 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk2 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 2\", $time);\n                end\n            end else if (Ba == 2'b11 && Pc_b3 == 1'b1) begin\n                {Act_b3, Pc_b3} = 2'b10;\n                B3_row_addr = Addr [addr_bits - 1 : 0];\n                RCD_chk3 = $time;\n                RAS_chk3 = $time;\n                if (Debug) $display (\"at time %t ACT  : Bank = 3 Row = %d\", $time, Addr);\n                \n                if ($time - RP_chk3 < tRP) begin\n                    $display (\"at time %t ERROR: tRP violation during Activate bank 3\", $time);\n                end\n            end else if (Ba == 2'b00 && Pc_b0 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 0 is not Precharged.\", $time);\n            end else if (Ba == 2'b01 && Pc_b1 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 1 is not Precharged.\", $time);\n            end else if (Ba == 2'b10 && Pc_b2 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 2 is not Precharged.\", $time);\n            end else if (Ba == 2'b11 && Pc_b3 == 1'b0) begin\n                $display (\"at time %t ERROR: Bank 3 is not Precharged.\", $time);\n            end\n            \n            if ((Previous_bank != Ba) && ($time - RRD_chk < tRRD)) begin\n                $display (\"at time %t ERROR: tRRD violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            if (MRD_chk < tMRD ) begin\n                $display (\"at time %t ERROR: tMRD violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            if (($time - RC_chk < tRC)&&Debug) begin\n                $display (\"at time %t ERROR: tRC violation during Activate bank = %d\", $time, Ba);\n            end\n            \n            RRD_chk = $time;\n            Previous_bank = Ba;\n        end\n        \n        \n        if (Prech_enable == 1'b1) begin\n            if (Addr[10] == 1'b1) begin\n                {Pc_b0, Pc_b1, Pc_b2, Pc_b3} = 4'b1111;\n                {Act_b0, Act_b1, Act_b2, Act_b3} = 4'b0000;\n                RP_chk0 = $time;\n                RP_chk1 = $time;\n                RP_chk2 = $time;\n                RP_chk3 = $time;\n                if (Debug) $display (\"at time %t PRE  : Bank = ALL\",$time);\n                \n                if (($time - RAS_chk0 < tRAS) || ($time - RAS_chk1 < tRAS) ||\n                    ($time - RAS_chk2 < tRAS) || ($time - RAS_chk3 < tRAS)) begin\n                    $display (\"at time %t ERROR: tRAS violation during Precharge all bank\", $time);\n                end\n                \n                if (($time - WR_chk[0] < tWRp) || ($time - WR_chk[1] < tWRp) ||\n                    ($time - WR_chk[2] < tWRp) || ($time - WR_chk[3] < tWRp)) begin\n                    $display (\"at time %t ERROR: tWR violation during Precharge all bank\", $time);\n                end\n            end else if (Addr[10] == 1'b0) begin\n                if (Ba == 2'b00) begin\n                    {Pc_b0, Act_b0} = 2'b10;\n                    RP_chk0 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 0\",$time);\n                    \n                    if ($time - RAS_chk0 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 0\", $time);\n                    end\n                end else if (Ba == 2'b01) begin\n                    {Pc_b1, Act_b1} = 2'b10;\n                    RP_chk1 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 1\",$time);\n                    \n                    if ($time - RAS_chk1 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 1\", $time);\n                    end\n                end else if (Ba == 2'b10) begin\n                    {Pc_b2, Act_b2} = 2'b10;\n                    RP_chk2 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 2\",$time);\n                    \n                    if ($time - RAS_chk2 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 2\", $time);\n                    end\n                end else if (Ba == 2'b11) begin\n                    {Pc_b3, Act_b3} = 2'b10;\n                    RP_chk3 = $time;\n                    if (Debug) $display (\"at time %t PRE  : Bank = 3\",$time);\n                    \n                    if ($time - RAS_chk3 < tRAS) begin\n                        $display (\"at time %t ERROR: tRAS violation during Precharge bank 3\", $time);\n                    end\n                end\n                \n                if ($time - WR_chk[Ba] < tWRp) begin\n                    $display (\"at time %t ERROR: tWR violation during Precharge bank %d\", $time, Ba);\n                end\n            end\n            \n            if (Data_in_enable == 1'b1 && (Bank == Ba || Addr[10] == 1'b1)) begin\n                Data_in_enable = 1'b0;\n            end\n            \n            if (Cas_latency_3 == 1'b1) begin\n                Command[2] = `PRECH;\n                Bank_precharge[2] = Ba;\n                A10_precharge[2] = Addr[10];\n            end else if (Cas_latency_2 == 1'b1) begin\n                Command[1] = `PRECH;\n                Bank_precharge[1] = Ba;\n                A10_precharge[1] = Addr[10];\n            end\n        end\n        \n        \n        if (Burst_term == 1'b1) begin\n            \n            if (Data_in_enable == 1'b1) begin\n                Data_in_enable = 1'b0;\n            end\n            \n            if (Cas_latency_3 == 1'b1) begin\n                Command[2] = `BST;\n            end else if (Cas_latency_2 == 1'b1) begin\n                Command[1] = `BST;\n            end\n            if (Debug) $display (\"at time %t BST  : Burst Terminate\",$time);\n        end\n        \n        \n        if (Read_enable == 1'b1 || Write_enable == 1'b1) begin\n            \n            if ((Ba == 2'b00 && Pc_b0 == 1'b1) || (Ba == 2'b01 && Pc_b1 == 1'b1) ||\n                (Ba == 2'b10 && Pc_b2 == 1'b1) || (Ba == 2'b11 && Pc_b3 == 1'b1)) begin\n                $display(\"at time %t ERROR: Cannot Read or Write - Bank %d is not Activated\", $time, Ba);\n            end\n            \n            if ((Ba == 2'b00) && ($time - RCD_chk0 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 0\", $time);\n            if ((Ba == 2'b01) && ($time - RCD_chk1 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 1\", $time);\n            if ((Ba == 2'b10) && ($time - RCD_chk2 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 2\", $time);\n            if ((Ba == 2'b11) && ($time - RCD_chk3 < tRCD))\n                $display(\"at time %t ERROR: tRCD violation during Read or Write to Bank 3\", $time);\n            \n            if (Read_enable == 1'b1) begin\n                \n                if (Cas_latency_3 == 1'b1) begin\n                    if (Addr[10] == 1'b1) begin\n                        Command[2] = `READ_A;\n                    end else begin\n                        Command[2] = `READ;\n                    end\n                    Col_addr[2] = Addr;\n                    Bank_addr[2] = Ba;\n                end else if (Cas_latency_2 == 1'b1) begin\n                    if (Addr[10] == 1'b1) begin\n                        Command[1] = `READ_A;\n                    end else begin\n                        Command[1] = `READ;\n                    end\n                    Col_addr[1] = Addr;\n                    Bank_addr[1] = Ba;\n                end\n\n                \n                if (Data_in_enable == 1'b1) begin\n                    Data_in_enable = 1'b0;\n                end\n\n            \n            end else if (Write_enable == 1'b1) begin\n                if (Addr[10] == 1'b1) begin\n                    Command[0] = `WRITE_A;\n                end else begin\n                    Command[0] = `WRITE;\n                end\n                Col_addr[0] = Addr;\n                Bank_addr[0] = Ba;\n\n                \n                if (Data_in_enable == 1'b1) begin\n                    Data_in_enable = 1'b0;\n                end\n\n                \n                if (Data_out_enable == 1'b1) begin\n                    Data_out_enable = 1'b0;\n                end\n            end\n\n            \n            if (Auto_precharge[Bank] == 1'b1 && Write_precharge[Bank] == 1'b1) begin\n                RW_interrupt_write[Bank] = 1'b1;\n                if (Debug) $display (\"at time %t NOTE : Read/Write Bank %d interrupt Write Bank %d with Autoprecharge\", $time, Ba, Bank);\n            end\n\n            \n            if (Auto_precharge[Bank] == 1'b1 && Read_precharge[Bank] == 1'b1) begin\n                RW_interrupt_read[Bank] = 1'b1;\n                if (Debug) $display (\"at time %t NOTE : Read/Write Bank %d interrupt Read Bank %d with Autoprecharge\", $time, Ba, Bank);\n            end\n\n            \n            if (Addr[10] == 1'b1) begin\n                Auto_precharge[Ba] = 1'b1;\n                Count_precharge[Ba] = 0;\n                if (Read_enable == 1'b1) begin\n                    Read_precharge[Ba] = 1'b1;\n                end else if (Write_enable == 1'b1) begin\n                    Write_precharge[Ba] = 1'b1;\n                end\n            end\n        end\n\n        \n        \n        \n        \n        \n        if ((Auto_precharge[0] == 1'b1) && (Read_precharge[0] == 1'b1)) begin\n            if ((($time - RAS_chk0 >= tRAS) &&                                                      \n                ((Burst_length_1 == 1'b1 && Count_precharge[0] >= 1) ||                             \n                 (Burst_length_2 == 1'b1 && Count_precharge[0] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[0] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[0] >= 8))) ||\n                 (RW_interrupt_read[0] == 1'b1)) begin                                              \n                    Pc_b0 = 1'b1;\n                    Act_b0 = 1'b0;\n                    RP_chk0 = $time;\n                    Auto_precharge[0] = 1'b0;\n                    Read_precharge[0] = 1'b0;\n                    RW_interrupt_read[0] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 0\", $time);\n            end\n        end\n        if ((Auto_precharge[1] == 1'b1) && (Read_precharge[1] == 1'b1)) begin\n            if ((($time - RAS_chk1 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[1] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[1] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[1] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[1] >= 8))) ||\n                 (RW_interrupt_read[1] == 1'b1)) begin\n                    Pc_b1 = 1'b1;\n                    Act_b1 = 1'b0;\n                    RP_chk1 = $time;\n                    Auto_precharge[1] = 1'b0;\n                    Read_precharge[1] = 1'b0;\n                    RW_interrupt_read[1] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 1\", $time);\n            end\n        end\n        if ((Auto_precharge[2] == 1'b1) && (Read_precharge[2] == 1'b1)) begin\n            if ((($time - RAS_chk2 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[2] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[2] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[2] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[2] >= 8))) ||\n                 (RW_interrupt_read[2] == 1'b1)) begin\n                    Pc_b2 = 1'b1;\n                    Act_b2 = 1'b0;\n                    RP_chk2 = $time;\n                    Auto_precharge[2] = 1'b0;\n                    Read_precharge[2] = 1'b0;\n                    RW_interrupt_read[2] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 2\", $time);\n            end\n        end\n        if ((Auto_precharge[3] == 1'b1) && (Read_precharge[3] == 1'b1)) begin\n            if ((($time - RAS_chk3 >= tRAS) &&\n                ((Burst_length_1 == 1'b1 && Count_precharge[3] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge[3] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge[3] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge[3] >= 8))) ||\n                 (RW_interrupt_read[3] == 1'b1)) begin\n                    Pc_b3 = 1'b1;\n                    Act_b3 = 1'b0;\n                    RP_chk3 = $time;\n                    Auto_precharge[3] = 1'b0;\n                    Read_precharge[3] = 1'b0;\n                    RW_interrupt_read[3] = 1'b0;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 3\", $time);\n            end\n        end\n\n        \n        if (Command[0] == `PRECH) begin                         \n            if (Bank_precharge[0] == Bank || A10_precharge[0] == 1'b1) begin\n                if (Data_out_enable == 1'b1) begin\n                    Data_out_enable = 1'b0;\n                end\n            end\n        end else if (Command[0] == `BST) begin                  \n            if (Data_out_enable == 1'b1) begin\n                Data_out_enable = 1'b0;\n            end\n        end\n\n        if (Data_out_enable == 1'b0) begin\n            Dq_reg <= #tOH {data_bits{1'bz}};\n        end\n\n        \n        if (Command[0] == `READ || Command[0] == `READ_A) begin\n            Bank = Bank_addr[0];\n            Col = Col_addr[0];\n            Col_brst = Col_addr[0];\n            if (Bank_addr[0] == 2'b00) begin\n                Row = B0_row_addr;\n            end else if (Bank_addr[0] == 2'b01) begin\n                Row = B1_row_addr;\n            end else if (Bank_addr[0] == 2'b10) begin\n                Row = B2_row_addr;\n            end else if (Bank_addr[0] == 2'b11) begin\n                Row = B3_row_addr;\n            end\n            Burst_counter = 0;\n            Data_in_enable = 1'b0;\n            Data_out_enable = 1'b1;\n        end else if (Command[0] == `WRITE || Command[0] == `WRITE_A) begin\n            Bank = Bank_addr[0];\n            Col = Col_addr[0];\n            Col_brst = Col_addr[0];\n            if (Bank_addr[0] == 2'b00) begin\n                Row = B0_row_addr;\n            end else if (Bank_addr[0] == 2'b01) begin\n                Row = B1_row_addr;\n            end else if (Bank_addr[0] == 2'b10) begin\n                Row = B2_row_addr;\n            end else if (Bank_addr[0] == 2'b11) begin\n                Row = B3_row_addr;\n            end\n            Burst_counter = 0;\n            Data_in_enable = 1'b1;\n            Data_out_enable = 1'b0;\n        end\n\n        \n        if (Data_in_enable == 1'b1) begin                                   \n            \n            if (Bank == 2'b00) Dq_dqm [data_bits - 1  : 0] = Bank0 [{Row, Col}];\n            if (Bank == 2'b01) Dq_dqm [data_bits - 1  : 0] = Bank1 [{Row, Col}];\n            if (Bank == 2'b10) Dq_dqm [data_bits - 1  : 0] = Bank2 [{Row, Col}];\n            if (Bank == 2'b11) Dq_dqm [data_bits - 1  : 0] = Bank3 [{Row, Col}];\n            \n            if (Dqm[0] == 1'b0) Dq_dqm [ 7 : 0] = Dq [ 7 : 0];\n            if (Dqm[1] == 1'b0) Dq_dqm [15 : 8] = Dq [15 : 8];\n            \n           \n            \n            if (Bank == 2'b00) Bank0 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b01) Bank1 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b10) Bank2 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b11) Bank3 [{Row, Col}] = Dq_dqm [data_bits - 1  : 0];\n            if (Bank == 2'b11 && Row==10'h3 && Col[7:4]==4'h4)\n            \t$display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            \n            \n            if (Dqm == 4'b1111) begin\n                if (Debug) $display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            end else begin\n                if (Debug) $display(\"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b\", $time, Bank, Row, Col, Dq_dqm, Dqm);\n                \n                WR_chk [Bank] = $time;\n                WR_counter [Bank] = 0;\n            end\n            \n            #tHZ Burst;\n        end else if (Data_out_enable == 1'b1) begin                         \n        \t\n            \n            if (Bank == 2'b00) Dq_dqm [data_bits - 1  : 0] = Bank0 [{Row, Col}];\n            if (Bank == 2'b01) Dq_dqm [data_bits - 1  : 0] = Bank1 [{Row, Col}];\n            if (Bank == 2'b10) Dq_dqm [data_bits - 1  : 0] = Bank2 [{Row, Col}];\n            if (Bank == 2'b11) Dq_dqm [data_bits - 1  : 0] = Bank3 [{Row, Col}];\n            \t\n            \n            if (Dqm_reg0[0] == 1'b1) Dq_dqm [ 7 : 0] = 8'bz;\n            if (Dqm_reg0[1] == 1'b1) Dq_dqm [15 : 8] = 8'bz;\n            if (Dqm_reg0[2] == 1'b1) Dq_dqm [23 : 16] = 8'bz;\n            if (Dqm_reg0[3] == 1'b1) Dq_dqm [31 : 24] = 8'bz;\n            \n            Dq_reg [data_bits - 1  : 0] = #tAC Dq_dqm [data_bits - 1  : 0];\n            if (Dqm_reg0 == 4'b1111) begin\n                if (Debug) $display(\"at time %t READ : Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM\", $time, Bank, Row, Col);\n            end else begin\n                if (Debug) $display(\"at time %t READ : Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b\", $time, Bank, Row, Col, Dq_reg, Dqm_reg0);\n            end\n            \n            Burst;\n        end\n    end\n\n    \n    \n    \n    \n    \n    always @ (WR_counter[0]) begin\n        if ((Auto_precharge[0] == 1'b1) && (Write_precharge[0] == 1'b1)) begin\n            if ((($time - RAS_chk0 >= tRAS) &&                                                          \n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [0] >= 1) ||   \n                 (Burst_length_2 == 1'b1 && Count_precharge [0] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [0] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [0] >= 8))) ||\n                 (RW_interrupt_write[0] == 1'b1 && WR_counter[0] >= 2)) begin                           \n                    Auto_precharge[0] = 1'b0;\n                    Write_precharge[0] = 1'b0;\n                    RW_interrupt_write[0] = 1'b0;\n                    #tWRa;                          \n                    Pc_b0 = 1'b1;\n                    Act_b0 = 1'b0;\n                    RP_chk0 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 0\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[1]) begin\n        if ((Auto_precharge[1] == 1'b1) && (Write_precharge[1] == 1'b1)) begin\n            if ((($time - RAS_chk1 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [1] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [1] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [1] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [1] >= 8))) ||\n                 (RW_interrupt_write[1] == 1'b1 && WR_counter[1] >= 2)) begin\n                    Auto_precharge[1] = 1'b0;\n                    Write_precharge[1] = 1'b0;\n                    RW_interrupt_write[1] = 1'b0;\n                    #tWRa;                          \n                    Pc_b1 = 1'b1;\n                    Act_b1 = 1'b0;\n                    RP_chk1 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 1\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[2]) begin\n        if ((Auto_precharge[2] == 1'b1) && (Write_precharge[2] == 1'b1)) begin\n            if ((($time - RAS_chk2 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [2] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [2] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [2] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [2] >= 8))) ||\n                 (RW_interrupt_write[2] == 1'b1 && WR_counter[2] >= 2)) begin\n                    Auto_precharge[2] = 1'b0;\n                    Write_precharge[2] = 1'b0;\n                    RW_interrupt_write[2] = 1'b0;\n                    #tWRa;                          \n                    Pc_b2 = 1'b1;\n                    Act_b2 = 1'b0;\n                    RP_chk2 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 2\", $time);\n            end\n        end\n    end\n    always @ (WR_counter[3]) begin\n        if ((Auto_precharge[3] == 1'b1) && (Write_precharge[3] == 1'b1)) begin\n            if ((($time - RAS_chk3 >= tRAS) &&\n               (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) && Count_precharge [3] >= 1) || \n                 (Burst_length_2 == 1'b1 && Count_precharge [3] >= 2) ||\n                 (Burst_length_4 == 1'b1 && Count_precharge [3] >= 4) ||\n                 (Burst_length_8 == 1'b1 && Count_precharge [3] >= 8))) ||\n                 (RW_interrupt_write[3] == 1'b1 && WR_counter[3] >= 2)) begin\n                    Auto_precharge[3] = 1'b0;\n                    Write_precharge[3] = 1'b0;\n                    RW_interrupt_write[3] = 1'b0;\n                    #tWRa;                          \n                    Pc_b3 = 1'b1;\n                    Act_b3 = 1'b0;\n                    RP_chk3 = $time;\n                    if (Debug) $display (\"at time %t NOTE : Start Internal Auto Precharge for Bank 3\", $time);\n            end\n        end\n    end\n\n    task Burst;\n        begin\n            \n            Burst_counter = Burst_counter + 1;\n\n            \n            if (Mode_reg[3] == 1'b0) begin                                  \n                Col_temp = Col + 1;\n            end else if (Mode_reg[3] == 1'b1) begin                         \n                Col_temp[2] =  Burst_counter[2] ^  Col_brst[2];\n                Col_temp[1] =  Burst_counter[1] ^  Col_brst[1];\n                Col_temp[0] =  Burst_counter[0] ^  Col_brst[0];\n            end\n\n            \n            if (Burst_length_2) begin                                       \n                Col [0] = Col_temp [0];\n            end else if (Burst_length_4) begin                              \n                Col [1 : 0] = Col_temp [1 : 0];\n            end else if (Burst_length_8) begin                              \n                Col [2 : 0] = Col_temp [2 : 0];\n            end else begin                                                  \n                Col = Col_temp;\n            end\n\n            \n            if (Write_burst_mode == 1'b1) begin\n                Data_in_enable = 1'b0;\n            end\n\n            \n            if (Burst_length_1 == 1'b1) begin\n                if (Burst_counter >= 1) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_2 == 1'b1) begin\n                if (Burst_counter >= 2) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_4 == 1'b1) begin\n                if (Burst_counter >= 4) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end else if (Burst_length_8 == 1'b1) begin\n                if (Burst_counter >= 8) begin\n                    Data_in_enable = 1'b0;\n                    Data_out_enable = 1'b0;\n                end\n            end\n        end\n    endtask\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    integer\tsdram_data,sdram_mem;\n    reg\t[23:0]\taa,cc;\n    reg\t[18:0]\tbb,ee;\n    \n    always@(sdram_r)\n\tbegin\n\t\t   $display(\"Sdram dampout begin \",$realtime);\n\t\t   sdram_data=$fopen(\"sdram_data.txt\");\n\t\t   for(aa=0;aa<4*(mem_sizes+1);aa=aa+1)\n\t\t   \tbegin\n\t\t   \tbb=aa[18:0];\n\t\t\tif(aa<=mem_sizes)\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank0[bb]);\n\t\t\telse if(aa<=2*mem_sizes+1)\n\t\t            \t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank1[bb]);\n\t\t\telse if(aa<=3*mem_sizes+2)\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank2[bb]);\n\t\t\telse\n\t\t\t\t$fdisplay(sdram_data,\"%0d\t%0h\",aa,Bank3[bb]);\n\t\t  \tend\t    \t    \t    \n\t\t  $fclose(\"sdram_data.txt\"); \n\t\t  \n\t\t  sdram_mem=$fopen(\"sdram_mem.txt\");\n\t\t  for(cc=0;cc<4*(mem_sizes+1);cc=cc+1)\n\t\t  \tbegin\n\t\t   \tee=cc[18:0];\n\t\t\tif(cc<=mem_sizes)\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank0[ee]);\n\t\t\telse if(cc<=2*mem_sizes+1)\n\t\t            \t$fdisplay(sdram_mem,\"%0h\",Bank1[ee]);\n\t\t\telse if(cc<=3*mem_sizes+2)\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank2[ee]);\n\t\t\telse\n\t\t\t\t$fdisplay(sdram_mem,\"%0h\",Bank3[ee]);\n\t\t  \tend\t    \t    \t    \n\t\t  $fclose(\"sdram_mem.txt\");        \n\t \n\t  end        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nendmodule\n\n</code>"
                },
                {
                    "type": "text",
                    "text": "Based on the provided original Verilog code, its comments and above answers, generate a detailed specification for the module. Include the following information in a single, concise paragraph:\n1. The name of the module.\n2. A simple explanation of the module's functionality.\n3. The input and output ports, along with a brief explanation of each.\n4. The internal signals used within the module, with a brief explanation of their purpose.\n5. An overview of the different blocks or sections in the code and their functions.\nEnsure that the specification is clear and accurately reflects the details from the code and comments.\nYour answer should be structured and well-organized, providing a comprehensive and detailed overview of the module's design and operation.\nPlease provide your answer in the following format:\nModule name: [module name]. Module specification: [module specification]."
                },
                {
                    "type": "text",
                    "text": "Module name: sdram_model_plus. Module specification: This module simulates a Synchronous Dynamic Random Access Memory (SDRAM) device with four banks, supporting various burst lengths and CAS latencies. It handles read, write, activate, precharge, and refresh operations, implementing timing constraints and auto-precharge functionality. The module has input ports for data (Dq), address (Addr), bank select (Ba), clock (Clk), control signals (Cke, Cs_n, Ras_n, Cas_n, We_n), data mask (Dqm), and debug mode (Debug). The bidirectional Dq port serves for both data input and output. Internal signals include memory banks (Bank0-3), address registers, command storage, data masks, and various control flags. The module is structured with sections for command decoding, timing checks, burst operations, and auto-"
                }
            ]
        }
    ]
}